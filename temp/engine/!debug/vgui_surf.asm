; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\vgui_surf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??0?$Dar@D@vgui@@QAE@XZ				; vgui::Dar<char>::Dar<char>
PUBLIC	??0?$Dar@D@vgui@@QAE@H@Z			; vgui::Dar<char>::Dar<char>
PUBLIC	?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z		; vgui::Dar<char>::ensureCapacity
PUBLIC	?setCount@?$Dar@D@vgui@@QAEXH@Z			; vgui::Dar<char>::setCount
PUBLIC	?getCount@?$Dar@D@vgui@@QAEHXZ			; vgui::Dar<char>::getCount
PUBLIC	?addElement@?$Dar@D@vgui@@QAEXD@Z		; vgui::Dar<char>::addElement
PUBLIC	?hasElement@?$Dar@D@vgui@@QAE_ND@Z		; vgui::Dar<char>::hasElement
PUBLIC	?putElement@?$Dar@D@vgui@@QAEXD@Z		; vgui::Dar<char>::putElement
PUBLIC	?insertElementAt@?$Dar@D@vgui@@QAEXDH@Z		; vgui::Dar<char>::insertElementAt
PUBLIC	?setElementAt@?$Dar@D@vgui@@QAEXDH@Z		; vgui::Dar<char>::setElementAt
PUBLIC	?removeElementAt@?$Dar@D@vgui@@QAEXH@Z		; vgui::Dar<char>::removeElementAt
PUBLIC	?removeElement@?$Dar@D@vgui@@QAEXD@Z		; vgui::Dar<char>::removeElement
PUBLIC	?removeAll@?$Dar@D@vgui@@QAEXXZ			; vgui::Dar<char>::removeAll
PUBLIC	??A?$Dar@D@vgui@@QAEDH@Z			; vgui::Dar<char>::operator[]
PUBLIC	??4?$Dar@D@vgui@@QAEAAV01@ABV01@@Z		; vgui::Dar<char>::operator=
PUBLIC	??4?$Dar@D@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Dar<char>::operator=
PUBLIC	??0?$Dar@PAD@vgui@@QAE@XZ			; vgui::Dar<char *>::Dar<char *>
PUBLIC	??0?$Dar@PAD@vgui@@QAE@H@Z			; vgui::Dar<char *>::Dar<char *>
PUBLIC	?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z		; vgui::Dar<char *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAD@vgui@@QAEXH@Z		; vgui::Dar<char *>::setCount
PUBLIC	?getCount@?$Dar@PAD@vgui@@QAEHXZ		; vgui::Dar<char *>::getCount
PUBLIC	?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z		; vgui::Dar<char *>::addElement
PUBLIC	?hasElement@?$Dar@PAD@vgui@@QAE_NPAD@Z		; vgui::Dar<char *>::hasElement
PUBLIC	?putElement@?$Dar@PAD@vgui@@QAEXPAD@Z		; vgui::Dar<char *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z	; vgui::Dar<char *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z	; vgui::Dar<char *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAD@vgui@@QAEXH@Z	; vgui::Dar<char *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAD@vgui@@QAEXPAD@Z	; vgui::Dar<char *>::removeElement
PUBLIC	?removeAll@?$Dar@PAD@vgui@@QAEXXZ		; vgui::Dar<char *>::removeAll
PUBLIC	??A?$Dar@PAD@vgui@@QAEPADH@Z			; vgui::Dar<char *>::operator[]
PUBLIC	??4?$Dar@PAD@vgui@@QAEAAV01@ABV01@@Z		; vgui::Dar<char *>::operator=
PUBLIC	??4?$Dar@PAD@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Dar<char *>::operator=
PUBLIC	??0?$Dar@H@vgui@@QAE@XZ				; vgui::Dar<int>::Dar<int>
PUBLIC	??0?$Dar@H@vgui@@QAE@H@Z			; vgui::Dar<int>::Dar<int>
PUBLIC	?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z		; vgui::Dar<int>::ensureCapacity
PUBLIC	?setCount@?$Dar@H@vgui@@QAEXH@Z			; vgui::Dar<int>::setCount
PUBLIC	?getCount@?$Dar@H@vgui@@QAEHXZ			; vgui::Dar<int>::getCount
PUBLIC	?addElement@?$Dar@H@vgui@@QAEXH@Z		; vgui::Dar<int>::addElement
PUBLIC	?hasElement@?$Dar@H@vgui@@QAE_NH@Z		; vgui::Dar<int>::hasElement
PUBLIC	?putElement@?$Dar@H@vgui@@QAEXH@Z		; vgui::Dar<int>::putElement
PUBLIC	?insertElementAt@?$Dar@H@vgui@@QAEXHH@Z		; vgui::Dar<int>::insertElementAt
PUBLIC	?setElementAt@?$Dar@H@vgui@@QAEXHH@Z		; vgui::Dar<int>::setElementAt
PUBLIC	?removeElementAt@?$Dar@H@vgui@@QAEXH@Z		; vgui::Dar<int>::removeElementAt
PUBLIC	?removeElement@?$Dar@H@vgui@@QAEXH@Z		; vgui::Dar<int>::removeElement
PUBLIC	?removeAll@?$Dar@H@vgui@@QAEXXZ			; vgui::Dar<int>::removeAll
PUBLIC	??A?$Dar@H@vgui@@QAEHH@Z			; vgui::Dar<int>::operator[]
PUBLIC	??4?$Dar@H@vgui@@QAEAAV01@ABV01@@Z		; vgui::Dar<int>::operator=
PUBLIC	??4?$Dar@H@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Dar<int>::operator=
PUBLIC	??0?$Dar@PAVButton@vgui@@@vgui@@QAE@XZ		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>
PUBLIC	??0?$Dar@PAVButton@vgui@@@vgui@@QAE@H@Z		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>
PUBLIC	?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z	; vgui::Dar<vgui::Button *>::setCount
PUBLIC	?getCount@?$Dar@PAVButton@vgui@@@vgui@@QAEHXZ	; vgui::Dar<vgui::Button *>::getCount
PUBLIC	?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::addElement
PUBLIC	?hasElement@?$Dar@PAVButton@vgui@@@vgui@@QAE_NPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::hasElement
PUBLIC	?putElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z ; vgui::Dar<vgui::Button *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z ; vgui::Dar<vgui::Button *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVButton@vgui@@@vgui@@QAEXXZ	; vgui::Dar<vgui::Button *>::removeAll
PUBLIC	??A?$Dar@PAVButton@vgui@@@vgui@@QAEPAVButton@1@H@Z ; vgui::Dar<vgui::Button *>::operator[]
PUBLIC	??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::Button *>::operator=
PUBLIC	??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::Button *>::operator=
PUBLIC	??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>
PUBLIC	??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>
PUBLIC	?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::setCount
PUBLIC	?getCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::SurfaceBase *>::getCount
PUBLIC	?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::addElement
PUBLIC	?hasElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE_NPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::hasElement
PUBLIC	?putElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z ; vgui::Dar<vgui::SurfaceBase *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z ; vgui::Dar<vgui::SurfaceBase *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::SurfaceBase *>::removeAll
PUBLIC	??A?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEPAVSurfaceBase@1@H@Z ; vgui::Dar<vgui::SurfaceBase *>::operator[]
PUBLIC	??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::SurfaceBase *>::operator=
PUBLIC	??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::SurfaceBase *>::operator=
PUBLIC	??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>
PUBLIC	??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::InputSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAE_NPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z ; vgui::Dar<vgui::InputSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z ; vgui::Dar<vgui::InputSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::InputSignal *>::removeAll
PUBLIC	??A?$Dar@PAVInputSignal@vgui@@@vgui@@QAEPAVInputSignal@1@H@Z ; vgui::Dar<vgui::InputSignal *>::operator[]
PUBLIC	??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::InputSignal *>::operator=
PUBLIC	??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::InputSignal *>::operator=
PUBLIC	??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@XZ ; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>
PUBLIC	??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@H@Z ; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::FocusChangeSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE_NPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z ; vgui::Dar<vgui::FocusChangeSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z ; vgui::Dar<vgui::FocusChangeSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::FocusChangeSignal *>::removeAll
PUBLIC	??A?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEPAVFocusChangeSignal@1@H@Z ; vgui::Dar<vgui::FocusChangeSignal *>::operator[]
PUBLIC	??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::operator=
PUBLIC	??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::operator=
PUBLIC	??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>
PUBLIC	??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::FrameSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE_NPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z ; vgui::Dar<vgui::FrameSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z ; vgui::Dar<vgui::FrameSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::FrameSignal *>::removeAll
PUBLIC	??A?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEPAVFrameSignal@1@H@Z ; vgui::Dar<vgui::FrameSignal *>::operator[]
PUBLIC	??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::FrameSignal *>::operator=
PUBLIC	??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::FrameSignal *>::operator=
PUBLIC	??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>
PUBLIC	??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::ActionSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAE_NPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z ; vgui::Dar<vgui::ActionSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z ; vgui::Dar<vgui::ActionSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::ActionSignal *>::removeAll
PUBLIC	??A?$Dar@PAVActionSignal@vgui@@@vgui@@QAEPAVActionSignal@1@H@Z ; vgui::Dar<vgui::ActionSignal *>::operator[]
PUBLIC	??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::ActionSignal *>::operator=
PUBLIC	??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::ActionSignal *>::operator=
PUBLIC	??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>
PUBLIC	??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@H@Z ; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::IntChangeSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE_NPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z ; vgui::Dar<vgui::IntChangeSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z ; vgui::Dar<vgui::IntChangeSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::IntChangeSignal *>::removeAll
PUBLIC	??A?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEPAVIntChangeSignal@1@H@Z ; vgui::Dar<vgui::IntChangeSignal *>::operator[]
PUBLIC	??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::IntChangeSignal *>::operator=
PUBLIC	??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::IntChangeSignal *>::operator=
PUBLIC	??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>
PUBLIC	??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::TickSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAE_NPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z ; vgui::Dar<vgui::TickSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z ; vgui::Dar<vgui::TickSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::TickSignal *>::removeAll
PUBLIC	??A?$Dar@PAVTickSignal@vgui@@@vgui@@QAEPAVTickSignal@1@H@Z ; vgui::Dar<vgui::TickSignal *>::operator[]
PUBLIC	??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::TickSignal *>::operator=
PUBLIC	??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::TickSignal *>::operator=
PUBLIC	??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@XZ		; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>
PUBLIC	??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>
PUBLIC	?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z	; vgui::Dar<vgui::Dar<char> *>::setCount
PUBLIC	?getCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEHXZ	; vgui::Dar<vgui::Dar<char> *>::getCount
PUBLIC	?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::addElement
PUBLIC	?hasElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE_NPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::hasElement
PUBLIC	?putElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z ; vgui::Dar<vgui::Dar<char> *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z ; vgui::Dar<vgui::Dar<char> *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::removeElement
PUBLIC	?removeAll@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXXZ	; vgui::Dar<vgui::Dar<char> *>::removeAll
PUBLIC	??A?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEPAV?$Dar@D@1@H@Z ; vgui::Dar<vgui::Dar<char> *>::operator[]
PUBLIC	??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::Dar<char> *>::operator=
PUBLIC	??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::Dar<char> *>::operator=
PUBLIC	??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@XZ		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>
PUBLIC	??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@H@Z		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>
PUBLIC	?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z	; vgui::Dar<vgui::Frame *>::setCount
PUBLIC	?getCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEHXZ	; vgui::Dar<vgui::Frame *>::getCount
PUBLIC	?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::addElement
PUBLIC	?hasElement@?$Dar@PAVFrame@vgui@@@vgui@@QAE_NPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::hasElement
PUBLIC	?putElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z ; vgui::Dar<vgui::Frame *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z ; vgui::Dar<vgui::Frame *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVFrame@vgui@@@vgui@@QAEXXZ	; vgui::Dar<vgui::Frame *>::removeAll
PUBLIC	??A?$Dar@PAVFrame@vgui@@@vgui@@QAEPAVFrame@1@H@Z ; vgui::Dar<vgui::Frame *>::operator[]
PUBLIC	??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::Frame *>::operator=
PUBLIC	??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::Frame *>::operator=
PUBLIC	??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>
PUBLIC	??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>
PUBLIC	?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::setCount
PUBLIC	?getCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::DesktopIcon *>::getCount
PUBLIC	?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::addElement
PUBLIC	?hasElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE_NPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::hasElement
PUBLIC	?putElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z ; vgui::Dar<vgui::DesktopIcon *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z ; vgui::Dar<vgui::DesktopIcon *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::DesktopIcon *>::removeAll
PUBLIC	??A?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEPAVDesktopIcon@1@H@Z ; vgui::Dar<vgui::DesktopIcon *>::operator[]
PUBLIC	??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::DesktopIcon *>::operator=
PUBLIC	??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::DesktopIcon *>::operator=
PUBLIC	??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>
PUBLIC	??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::ChangeSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE_NPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z ; vgui::Dar<vgui::ChangeSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z ; vgui::Dar<vgui::ChangeSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::ChangeSignal *>::removeAll
PUBLIC	??A?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEPAVChangeSignal@1@H@Z ; vgui::Dar<vgui::ChangeSignal *>::operator[]
PUBLIC	??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::ChangeSignal *>::operator=
PUBLIC	??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::ChangeSignal *>::operator=
PUBLIC	??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@XZ		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>
PUBLIC	??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@H@Z		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>
PUBLIC	?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z	; vgui::Dar<vgui::Panel *>::setCount
PUBLIC	?getCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEHXZ	; vgui::Dar<vgui::Panel *>::getCount
PUBLIC	?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::addElement
PUBLIC	?hasElement@?$Dar@PAVPanel@vgui@@@vgui@@QAE_NPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::hasElement
PUBLIC	?putElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z ; vgui::Dar<vgui::Panel *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z ; vgui::Dar<vgui::Panel *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVPanel@vgui@@@vgui@@QAEXXZ	; vgui::Dar<vgui::Panel *>::removeAll
PUBLIC	??A?$Dar@PAVPanel@vgui@@@vgui@@QAEPAVPanel@1@H@Z ; vgui::Dar<vgui::Panel *>::operator[]
PUBLIC	??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::Panel *>::operator=
PUBLIC	??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::Panel *>::operator=
PUBLIC	??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@XZ		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>
PUBLIC	??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@H@Z		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>
PUBLIC	?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z	; vgui::Dar<vgui::Label *>::setCount
PUBLIC	?getCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEHXZ	; vgui::Dar<vgui::Label *>::getCount
PUBLIC	?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::addElement
PUBLIC	?hasElement@?$Dar@PAVLabel@vgui@@@vgui@@QAE_NPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::hasElement
PUBLIC	?putElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z ; vgui::Dar<vgui::Label *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z ; vgui::Dar<vgui::Label *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVLabel@vgui@@@vgui@@QAEXXZ	; vgui::Dar<vgui::Label *>::removeAll
PUBLIC	??A?$Dar@PAVLabel@vgui@@@vgui@@QAEPAVLabel@1@H@Z ; vgui::Dar<vgui::Label *>::operator[]
PUBLIC	??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::Label *>::operator=
PUBLIC	??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::Label *>::operator=
PUBLIC	??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@XZ	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>
PUBLIC	??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@H@Z	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>
PUBLIC	?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::setCount
PUBLIC	?getCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEHXZ ; vgui::Dar<vgui::RepaintSignal *>::getCount
PUBLIC	?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::addElement
PUBLIC	?hasElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE_NPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::hasElement
PUBLIC	?putElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::putElement
PUBLIC	?insertElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z ; vgui::Dar<vgui::RepaintSignal *>::insertElementAt
PUBLIC	?setElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z ; vgui::Dar<vgui::RepaintSignal *>::setElementAt
PUBLIC	?removeElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::removeElementAt
PUBLIC	?removeElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::removeElement
PUBLIC	?removeAll@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXXZ ; vgui::Dar<vgui::RepaintSignal *>::removeAll
PUBLIC	??A?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEPAVRepaintSignal@1@H@Z ; vgui::Dar<vgui::RepaintSignal *>::operator[]
PUBLIC	??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ; vgui::Dar<vgui::RepaintSignal *>::operator=
PUBLIC	??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<vgui::RepaintSignal *>::operator=
PUBLIC	??0Cursor@vgui@@QAE@ABV01@@Z			; vgui::Cursor::Cursor
PUBLIC	??0Cursor@vgui@@QAE@$$QAV01@@Z			; vgui::Cursor::Cursor
PUBLIC	??4Cursor@vgui@@QAEAAV01@ABV01@@Z		; vgui::Cursor::operator=
PUBLIC	??4Cursor@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Cursor::operator=
PUBLIC	??0App@vgui@@QAE@ABV01@@Z			; vgui::App::App
PUBLIC	??0App@vgui@@QAE@$$QAV01@@Z			; vgui::App::App
PUBLIC	??4App@vgui@@QAEAAV01@ABV01@@Z			; vgui::App::operator=
PUBLIC	??4App@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::App::operator=
PUBLIC	??0Font@vgui@@QAE@ABV01@@Z			; vgui::Font::Font
PUBLIC	??0Font@vgui@@QAE@$$QAV01@@Z			; vgui::Font::Font
PUBLIC	??4Font@vgui@@QAEAAV01@ABV01@@Z			; vgui::Font::operator=
PUBLIC	??4Font@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Font::operator=
PUBLIC	??0Scheme@vgui@@QAE@ABV01@@Z			; vgui::Scheme::Scheme
PUBLIC	??0Scheme@vgui@@QAE@$$QAV01@@Z			; vgui::Scheme::Scheme
PUBLIC	??4Scheme@vgui@@QAEAAV01@ABV01@@Z		; vgui::Scheme::operator=
PUBLIC	??4Scheme@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Scheme::operator=
PUBLIC	??0Color@vgui@@QAE@ABV01@@Z			; vgui::Color::Color
PUBLIC	??0Color@vgui@@QAE@$$QAV01@@Z			; vgui::Color::Color
PUBLIC	??4Color@vgui@@QAEAAV01@ABV01@@Z		; vgui::Color::operator=
PUBLIC	??4Color@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Color::operator=
PUBLIC	??0Panel@vgui@@QAE@ABV01@@Z			; vgui::Panel::Panel
PUBLIC	??0Panel@vgui@@QAE@$$QAV01@@Z			; vgui::Panel::Panel
PUBLIC	??4Panel@vgui@@QAEAAV01@ABV01@@Z		; vgui::Panel::operator=
PUBLIC	??4Panel@vgui@@QAEAAV01@$$QAV01@@Z		; vgui::Panel::operator=
PUBLIC	??0SurfaceBase@vgui@@QAE@ABV01@@Z		; vgui::SurfaceBase::SurfaceBase
PUBLIC	??4SurfaceBase@vgui@@QAEAAV01@ABV01@@Z		; vgui::SurfaceBase::operator=
PUBLIC	??0InputSignal@vgui@@QAE@XZ			; vgui::InputSignal::InputSignal
PUBLIC	??0InputSignal@vgui@@QAE@ABV01@@Z		; vgui::InputSignal::InputSignal
PUBLIC	??0InputSignal@vgui@@QAE@$$QAV01@@Z		; vgui::InputSignal::InputSignal
PUBLIC	??4InputSignal@vgui@@QAEAAV01@ABV01@@Z		; vgui::InputSignal::operator=
PUBLIC	??4InputSignal@vgui@@QAEAAV01@$$QAV01@@Z	; vgui::InputSignal::operator=
PUBLIC	?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ; CEngineSurface::InitVertex
PUBLIC	??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z	; CEngineSurface::CEngineSurface
PUBLIC	??1CEngineSurface@@QAE@XZ			; CEngineSurface::~CEngineSurface
PUBLIC	?setFullscreenMode@CEngineSurface@@UAE_NHHH@Z	; CEngineSurface::setFullscreenMode
PUBLIC	?setWindowedMode@CEngineSurface@@UAEXXZ		; CEngineSurface::setWindowedMode
PUBLIC	?setTitle@CEngineSurface@@UAEXPBD@Z		; CEngineSurface::setTitle
PUBLIC	?createPopup@CEngineSurface@@UAEXPAVPanel@vgui@@@Z ; CEngineSurface::createPopup
PUBLIC	?isWithin@CEngineSurface@@UAE_NHH@Z		; CEngineSurface::isWithin
PUBLIC	?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z ; CEngineSurface::SetupPaintState
PUBLIC	?hasFocus@CEngineSurface@@UAE_NXZ		; CEngineSurface::hasFocus
PUBLIC	?createNewTextureID@CEngineSurface@@MAEHXZ	; CEngineSurface::createNewTextureID
PUBLIC	?drawSetColor@CEngineSurface@@MAEXHHHH@Z	; CEngineSurface::drawSetColor
PUBLIC	?drawSetTextColor@CEngineSurface@@MAEXHHHH@Z	; CEngineSurface::drawSetTextColor
PUBLIC	?drawFilledRect@CEngineSurface@@MAEXHHHH@Z	; CEngineSurface::drawFilledRect
PUBLIC	?drawOutlinedRect@CEngineSurface@@MAEXHHHH@Z	; CEngineSurface::drawOutlinedRect
PUBLIC	?drawSetTextFont@CEngineSurface@@MAEXPAVFont@vgui@@@Z ; CEngineSurface::drawSetTextFont
PUBLIC	?drawSetTextPos@CEngineSurface@@MAEXHH@Z	; CEngineSurface::drawSetTextPos
PUBLIC	?drawPrintText@CEngineSurface@@MAEXPBDH@Z	; CEngineSurface::drawPrintText
PUBLIC	?drawSetTextureRGBA@CEngineSurface@@MAEXHPBDHH@Z ; CEngineSurface::drawSetTextureRGBA
PUBLIC	?drawSetTexture@CEngineSurface@@MAEXH@Z		; CEngineSurface::drawSetTexture
PUBLIC	?drawTexturedRect@CEngineSurface@@MAEXHHHH@Z	; CEngineSurface::drawTexturedRect
PUBLIC	?drawPrintChar@CEngineSurface@@MAEXHHHHMMMMQAH@Z ; CEngineSurface::drawPrintChar
PUBLIC	?addCharToBuffer@CEngineSurface@@MAEXPBUvpoint_t@@0QAH@Z ; CEngineSurface::addCharToBuffer
PUBLIC	?setCursor@CEngineSurface@@MAEXPAVCursor@vgui@@@Z ; CEngineSurface::setCursor
PUBLIC	?pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z ; CEngineSurface::pushMakeCurrent
PUBLIC	?popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z ; CEngineSurface::popMakeCurrent
PUBLIC	?createPlat@CEngineSurface@@MAE_NXZ		; CEngineSurface::createPlat
PUBLIC	?recreateContext@CEngineSurface@@MAE_NXZ	; CEngineSurface::recreateContext
PUBLIC	?enableMouseCapture@CEngineSurface@@MAEX_N@Z	; CEngineSurface::enableMouseCapture
PUBLIC	?invalidate@CEngineSurface@@MAEXPAVPanel@vgui@@@Z ; CEngineSurface::invalidate
PUBLIC	?setAsTopMost@CEngineSurface@@MAEX_N@Z		; CEngineSurface::setAsTopMost
PUBLIC	?applyChanges@CEngineSurface@@MAEXXZ		; CEngineSurface::applyChanges
PUBLIC	?swapBuffers@CEngineSurface@@MAEXXZ		; CEngineSurface::swapBuffers
PUBLIC	?flushBuffer@CEngineSurface@@MAEXXZ		; CEngineSurface::flushBuffer
PUBLIC	??0?$Dar@PAUFontInfo@@@vgui@@QAE@XZ		; vgui::Dar<FontInfo *>::Dar<FontInfo *>
PUBLIC	?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ; vgui::Dar<FontInfo *>::ensureCapacity
PUBLIC	?setCount@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z	; vgui::Dar<FontInfo *>::setCount
PUBLIC	?getCount@?$Dar@PAUFontInfo@@@vgui@@QAEHXZ	; vgui::Dar<FontInfo *>::getCount
PUBLIC	?addElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::addElement
PUBLIC	?hasElement@?$Dar@PAUFontInfo@@@vgui@@QAE_NPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::hasElement
PUBLIC	?putElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::putElement
PUBLIC	??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z ; vgui::Dar<FontInfo *>::operator[]
PUBLIC	??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@ABV01@@Z	; vgui::Dar<FontInfo *>::operator=
PUBLIC	??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@$$QAV01@@Z ; vgui::Dar<FontInfo *>::operator=
PUBLIC	??_7Cursor@vgui@@6B@				; vgui::Cursor::`vftable'
PUBLIC	??_7App@vgui@@6B@				; vgui::App::`vftable'
PUBLIC	??_7Font@vgui@@6B@				; vgui::Font::`vftable'
PUBLIC	??_7Scheme@vgui@@6B@				; vgui::Scheme::`vftable'
PUBLIC	??_7Color@vgui@@6B@				; vgui::Color::`vftable'
PUBLIC	??_7Panel@vgui@@6B@				; vgui::Panel::`vftable'
PUBLIC	??_7SurfaceBase@vgui@@6B@			; vgui::SurfaceBase::`vftable'
PUBLIC	??_7InputSignal@vgui@@6B@			; vgui::InputSignal::`vftable'
PUBLIC	??_7CEngineSurface@@6B@				; CEngineSurface::`vftable'
PUBLIC	?__LINE__Var@?0??pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z@4JA ; `CEngineSurface::pushMakeCurrent'::`1'::__LINE__Var
PUBLIC	??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z@4JA ; `CEngineSurface::popMakeCurrent'::`1'::__LINE__Var
PUBLIC	??_C@_08KNONEIAK@top?5?$DO?$DN?50@		; `string'
PUBLIC	??_C@_0CC@LLENABMC@paintStack?$FLtop?$FN?4m_pPanel?5?$DN?$DN?5pan@ ; `string'
PUBLIC	??_R4SurfaceBase@vgui@@6B@			; vgui::SurfaceBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSurfaceBase@vgui@@@8			; vgui::SurfaceBase `RTTI Type Descriptor'
PUBLIC	??_R3SurfaceBase@vgui@@8			; vgui::SurfaceBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SurfaceBase@vgui@@8			; vgui::SurfaceBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SurfaceBase@vgui@@8		; vgui::SurfaceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InputSignal@vgui@@6B@			; vgui::InputSignal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInputSignal@vgui@@@8			; vgui::InputSignal `RTTI Type Descriptor'
PUBLIC	??_R3InputSignal@vgui@@8			; vgui::InputSignal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InputSignal@vgui@@8			; vgui::InputSignal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InputSignal@vgui@@8		; vgui::InputSignal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Panel@vgui@@6B@				; vgui::Panel::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPanel@vgui@@@8				; vgui::Panel `RTTI Type Descriptor'
PUBLIC	??_R3Panel@vgui@@8				; vgui::Panel::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Panel@vgui@@8				; vgui::Panel::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Panel@vgui@@8			; vgui::Panel::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Cursor@vgui@@6B@				; vgui::Cursor::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCursor@vgui@@@8				; vgui::Cursor `RTTI Type Descriptor'
PUBLIC	??_R3Cursor@vgui@@8				; vgui::Cursor::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Cursor@vgui@@8				; vgui::Cursor::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Cursor@vgui@@8			; vgui::Cursor::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Scheme@vgui@@6B@				; vgui::Scheme::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVScheme@vgui@@@8				; vgui::Scheme `RTTI Type Descriptor'
PUBLIC	??_R3Scheme@vgui@@8				; vgui::Scheme::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Scheme@vgui@@8				; vgui::Scheme::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Scheme@vgui@@8			; vgui::Scheme::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4App@vgui@@6B@				; vgui::App::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVApp@vgui@@@8				; vgui::App `RTTI Type Descriptor'
PUBLIC	??_R3App@vgui@@8				; vgui::App::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2App@vgui@@8				; vgui::App::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@App@vgui@@8			; vgui::App::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Font@vgui@@6B@				; vgui::Font::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFont@vgui@@@8				; vgui::Font `RTTI Type Descriptor'
PUBLIC	??_R3Font@vgui@@8				; vgui::Font::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Font@vgui@@8				; vgui::Font::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Font@vgui@@8			; vgui::Font::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Color@vgui@@6B@				; vgui::Color::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVColor@vgui@@@8				; vgui::Color `RTTI Type Descriptor'
PUBLIC	??_R3Color@vgui@@8				; vgui::Color::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Color@vgui@@8				; vgui::Color::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Color@vgui@@8			; vgui::Color::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CEngineSurface@@6B@			; CEngineSurface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEngineSurface@@@8			; CEngineSurface `RTTI Type Descriptor'
PUBLIC	??_R3CEngineSurface@@8				; CEngineSurface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEngineSurface@@8				; CEngineSurface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEngineSurface@@8			; CEngineSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@4080000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isspace:PROC
EXTRN	_memset:PROC
EXTRN	__imp__exit:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_VGUI_DrawShutdown:PROC
EXTRN	_VGUI_SetupDrawingRect:PROC
EXTRN	_VGUI_SetupDrawingImage:PROC
EXTRN	_VGUI_BindTexture:PROC
EXTRN	_VGUI_EnableTexture:PROC
EXTRN	_VGUI_UploadTexture:PROC
EXTRN	_VGUI_DrawQuad:PROC
EXTRN	_VGUI_DrawBuffer:PROC
EXTRN	_VGUI_GenerateTexture:PROC
EXTRN	_SetScissorRect:PROC
EXTRN	_ClipRect:PROC
EXTRN	?getHotspot@Cursor@vgui@@UAEXAAH0@Z:PROC	; vgui::Cursor::getHotspot
EXTRN	?privateInit@Cursor@vgui@@EAEXPAVBitmap@2@HH@Z:PROC ; vgui::Cursor::privateInit
EXTRN	?getBitmap@Cursor@vgui@@UAEPAVBitmap@2@XZ:PROC	; vgui::Cursor::getBitmap
EXTRN	?getDefaultCursor@Cursor@vgui@@UAE?AW4DefaultCursor@12@XZ:PROC ; vgui::Cursor::getDefaultCursor
EXTRN	?start@App@vgui@@UAEXXZ:PROC			; vgui::App::start
EXTRN	?stop@App@vgui@@UAEXXZ:PROC			; vgui::App::stop
EXTRN	?externalTick@App@vgui@@UAEXXZ:PROC		; vgui::App::externalTick
EXTRN	?wasMousePressed@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasMousePressed
EXTRN	?wasMouseDoublePressed@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasMouseDoublePressed
EXTRN	?isMouseDown@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z:PROC ; vgui::App::isMouseDown
EXTRN	?wasMouseReleased@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasMouseReleased
EXTRN	?wasKeyPressed@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasKeyPressed
EXTRN	?isKeyDown@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z:PROC ; vgui::App::isKeyDown
EXTRN	?wasKeyTyped@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasKeyTyped
EXTRN	?wasKeyReleased@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z:PROC ; vgui::App::wasKeyReleased
EXTRN	?addTickSignal@App@vgui@@UAEXPAVTickSignal@2@@Z:PROC ; vgui::App::addTickSignal
EXTRN	?setCursorPos@App@vgui@@UAEXHH@Z:PROC		; vgui::App::setCursorPos
EXTRN	?getCursorPos@App@vgui@@UAEXAAH0@Z:PROC		; vgui::App::getCursorPos
EXTRN	?setMouseCapture@App@vgui@@UAEXPAVPanel@2@@Z:PROC ; vgui::App::setMouseCapture
EXTRN	?setMouseArena@App@vgui@@UAEXHHHH_N@Z:PROC	; vgui::App::setMouseArena
EXTRN	?setMouseArena@App@vgui@@UAEXPAVPanel@2@@Z:PROC	; vgui::App::setMouseArena
EXTRN	?requestFocus@App@vgui@@UAEXPAVPanel@2@@Z:PROC	; vgui::App::requestFocus
EXTRN	?getFocus@App@vgui@@UAEPAVPanel@2@XZ:PROC	; vgui::App::getFocus
EXTRN	?repaintAll@App@vgui@@UAEXXZ:PROC		; vgui::App::repaintAll
EXTRN	?setScheme@App@vgui@@UAEXPAVScheme@2@@Z:PROC	; vgui::App::setScheme
EXTRN	?getScheme@App@vgui@@UAEPAVScheme@2@XZ:PROC	; vgui::App::getScheme
EXTRN	?enableBuildMode@App@vgui@@UAEXXZ:PROC		; vgui::App::enableBuildMode
EXTRN	?getTimeMillis@App@vgui@@UAEJXZ:PROC		; vgui::App::getTimeMillis
EXTRN	?getKeyCodeChar@App@vgui@@UAEDW4KeyCode@2@_N@Z:PROC ; vgui::App::getKeyCodeChar
EXTRN	?getKeyCodeText@App@vgui@@UAEXW4KeyCode@2@PADH@Z:PROC ; vgui::App::getKeyCodeText
EXTRN	?getClipboardTextCount@App@vgui@@UAEHXZ:PROC	; vgui::App::getClipboardTextCount
EXTRN	?setClipboardText@App@vgui@@UAEXPBDH@Z:PROC	; vgui::App::setClipboardText
EXTRN	?getClipboardText@App@vgui@@UAEHHPADH@Z:PROC	; vgui::App::getClipboardText
EXTRN	?reset@App@vgui@@UAEXXZ:PROC			; vgui::App::reset
EXTRN	?internalSetMouseArena@App@vgui@@UAEXHHHH_N@Z:PROC ; vgui::App::internalSetMouseArena
EXTRN	?setRegistryString@App@vgui@@UAE_NPBD0@Z:PROC	; vgui::App::setRegistryString
EXTRN	?getRegistryString@App@vgui@@UAE_NPBDPADH@Z:PROC ; vgui::App::getRegistryString
EXTRN	?setRegistryInteger@App@vgui@@UAE_NPBDH@Z:PROC	; vgui::App::setRegistryInteger
EXTRN	?getRegistryInteger@App@vgui@@UAE_NPBDAAH@Z:PROC ; vgui::App::getRegistryInteger
EXTRN	?setCursorOveride@App@vgui@@UAEXPAVCursor@2@@Z:PROC ; vgui::App::setCursorOveride
EXTRN	?getCursorOveride@App@vgui@@UAEPAVCursor@2@XZ:PROC ; vgui::App::getCursorOveride
EXTRN	?setMinimumTickMillisInterval@App@vgui@@UAEXH@Z:PROC ; vgui::App::setMinimumTickMillisInterval
EXTRN	?run@App@vgui@@UAEXXZ:PROC			; vgui::App::run
EXTRN	?internalCursorMoved@App@vgui@@UAEXHHPAVSurfaceBase@2@@Z:PROC ; vgui::App::internalCursorMoved
EXTRN	?internalMousePressed@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalMousePressed
EXTRN	?internalMouseDoublePressed@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalMouseDoublePressed
EXTRN	?internalMouseReleased@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalMouseReleased
EXTRN	?internalMouseWheeled@App@vgui@@UAEXHPAVSurfaceBase@2@@Z:PROC ; vgui::App::internalMouseWheeled
EXTRN	?internalKeyPressed@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalKeyPressed
EXTRN	?internalKeyTyped@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalKeyTyped
EXTRN	?internalKeyReleased@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z:PROC ; vgui::App::internalKeyReleased
EXTRN	?init@App@vgui@@EAEXXZ:PROC			; vgui::App::init
EXTRN	?updateMouseFocus@App@vgui@@EAEXHHPAVSurfaceBase@2@@Z:PROC ; vgui::App::updateMouseFocus
EXTRN	?setMouseFocus@App@vgui@@EAEXPAVPanel@2@@Z:PROC	; vgui::App::setMouseFocus
EXTRN	?surfaceBaseCreated@App@vgui@@MAEXPAVSurfaceBase@2@@Z:PROC ; vgui::App::surfaceBaseCreated
EXTRN	?surfaceBaseDeleted@App@vgui@@MAEXPAVSurfaceBase@2@@Z:PROC ; vgui::App::surfaceBaseDeleted
EXTRN	?platTick@App@vgui@@MAEXXZ:PROC			; vgui::App::platTick
EXTRN	?internalTick@App@vgui@@MAEXXZ:PROC		; vgui::App::internalTick
EXTRN	?init@Font@vgui@@EAEXPBDPAXHHHMH_N222@Z:PROC	; vgui::Font::init
EXTRN	?getCharRGBA@Font@vgui@@UAEXHHHHHPAE@Z:PROC	; vgui::Font::getCharRGBA
EXTRN	?getCharABCwide@Font@vgui@@UAEXHAAH00@Z:PROC	; vgui::Font::getCharABCwide
EXTRN	?getTextSize@Font@vgui@@UAEXPBDAAH1@Z:PROC	; vgui::Font::getTextSize
EXTRN	?getTall@Font@vgui@@UAEHXZ:PROC			; vgui::Font::getTall
EXTRN	?getId@Font@vgui@@UAEHXZ:PROC			; vgui::Font::getId
EXTRN	?setColor@Scheme@vgui@@UAEXW4SchemeColor@12@HHHH@Z:PROC ; vgui::Scheme::setColor
EXTRN	?getColor@Scheme@vgui@@UAEXW4SchemeColor@12@AAH111@Z:PROC ; vgui::Scheme::getColor
EXTRN	?setFont@Scheme@vgui@@UAEXW4SchemeFont@12@PAVFont@2@@Z:PROC ; vgui::Scheme::setFont
EXTRN	?getFont@Scheme@vgui@@UAEPAVFont@2@W4SchemeFont@12@@Z:PROC ; vgui::Scheme::getFont
EXTRN	?setCursor@Scheme@vgui@@UAEXW4SchemeCursor@12@PAVCursor@2@@Z:PROC ; vgui::Scheme::setCursor
EXTRN	?getCursor@Scheme@vgui@@UAEPAVCursor@2@W4SchemeCursor@12@@Z:PROC ; vgui::Scheme::getCursor
EXTRN	?init@Color@vgui@@EAEXXZ:PROC			; vgui::Color::init
EXTRN	?setColor@Color@vgui@@UAEXHHHH@Z:PROC		; vgui::Color::setColor
EXTRN	?setColor@Color@vgui@@UAEXW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Color::setColor
EXTRN	?getColor@Color@vgui@@UAEXAAH000@Z:PROC		; vgui::Color::getColor
EXTRN	?getColor@Color@vgui@@UAEXAAW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Color::getColor
EXTRN	??AColor@vgui@@UAEHH@Z:PROC			; vgui::Color::operator[]
EXTRN	?setPos@Panel@vgui@@UAEXHH@Z:PROC		; vgui::Panel::setPos
EXTRN	?getPos@Panel@vgui@@UAEXAAH0@Z:PROC		; vgui::Panel::getPos
EXTRN	?setSize@Panel@vgui@@UAEXHH@Z:PROC		; vgui::Panel::setSize
EXTRN	?getSize@Panel@vgui@@UAEXAAH0@Z:PROC		; vgui::Panel::getSize
EXTRN	?setBounds@Panel@vgui@@UAEXHHHH@Z:PROC		; vgui::Panel::setBounds
EXTRN	?getBounds@Panel@vgui@@UAEXAAH000@Z:PROC	; vgui::Panel::getBounds
EXTRN	?getWide@Panel@vgui@@UAEHXZ:PROC		; vgui::Panel::getWide
EXTRN	?getTall@Panel@vgui@@UAEHXZ:PROC		; vgui::Panel::getTall
EXTRN	?getParent@Panel@vgui@@UAEPAV12@XZ:PROC		; vgui::Panel::getParent
EXTRN	?setVisible@Panel@vgui@@UAEX_N@Z:PROC		; vgui::Panel::setVisible
EXTRN	?isVisible@Panel@vgui@@UAE_NXZ:PROC		; vgui::Panel::isVisible
EXTRN	?isVisibleUp@Panel@vgui@@UAE_NXZ:PROC		; vgui::Panel::isVisibleUp
EXTRN	?repaint@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::repaint
EXTRN	?repaintAll@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::repaintAll
EXTRN	?getAbsExtents@Panel@vgui@@UAEXAAH000@Z:PROC	; vgui::Panel::getAbsExtents
EXTRN	?getClipRect@Panel@vgui@@UAEXAAH000@Z:PROC	; vgui::Panel::getClipRect
EXTRN	?setParent@Panel@vgui@@UAEXPAV12@@Z:PROC	; vgui::Panel::setParent
EXTRN	?addChild@Panel@vgui@@UAEXPAV12@@Z:PROC		; vgui::Panel::addChild
EXTRN	?insertChildAt@Panel@vgui@@UAEXPAV12@H@Z:PROC	; vgui::Panel::insertChildAt
EXTRN	?removeChild@Panel@vgui@@UAEXPAV12@@Z:PROC	; vgui::Panel::removeChild
EXTRN	?wasMousePressed@Panel@vgui@@UAE_NW4MouseCode@2@@Z:PROC ; vgui::Panel::wasMousePressed
EXTRN	?wasMouseDoublePressed@Panel@vgui@@UAE_NW4MouseCode@2@@Z:PROC ; vgui::Panel::wasMouseDoublePressed
EXTRN	?isMouseDown@Panel@vgui@@UAE_NW4MouseCode@2@@Z:PROC ; vgui::Panel::isMouseDown
EXTRN	?wasMouseReleased@Panel@vgui@@UAE_NW4MouseCode@2@@Z:PROC ; vgui::Panel::wasMouseReleased
EXTRN	?wasKeyPressed@Panel@vgui@@UAE_NW4KeyCode@2@@Z:PROC ; vgui::Panel::wasKeyPressed
EXTRN	?isKeyDown@Panel@vgui@@UAE_NW4KeyCode@2@@Z:PROC	; vgui::Panel::isKeyDown
EXTRN	?wasKeyTyped@Panel@vgui@@UAE_NW4KeyCode@2@@Z:PROC ; vgui::Panel::wasKeyTyped
EXTRN	?wasKeyReleased@Panel@vgui@@UAE_NW4KeyCode@2@@Z:PROC ; vgui::Panel::wasKeyReleased
EXTRN	?addInputSignal@Panel@vgui@@UAEXPAVInputSignal@2@@Z:PROC ; vgui::Panel::addInputSignal
EXTRN	?removeInputSignal@Panel@vgui@@UAEXPAVInputSignal@2@@Z:PROC ; vgui::Panel::removeInputSignal
EXTRN	?addRepaintSignal@Panel@vgui@@UAEXPAVRepaintSignal@2@@Z:PROC ; vgui::Panel::addRepaintSignal
EXTRN	?removeRepaintSignal@Panel@vgui@@UAEXPAVRepaintSignal@2@@Z:PROC ; vgui::Panel::removeRepaintSignal
EXTRN	?isWithin@Panel@vgui@@UAE_NHH@Z:PROC		; vgui::Panel::isWithin
EXTRN	?isWithinTraverse@Panel@vgui@@UAEPAV12@HH@Z:PROC ; vgui::Panel::isWithinTraverse
EXTRN	?localToScreen@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::localToScreen
EXTRN	?screenToLocal@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::screenToLocal
EXTRN	?setCursor@Panel@vgui@@UAEXPAVCursor@2@@Z:PROC	; vgui::Panel::setCursor
EXTRN	?setCursor@Panel@vgui@@UAEXW4SchemeCursor@Scheme@2@@Z:PROC ; vgui::Panel::setCursor
EXTRN	?getCursor@Panel@vgui@@UAEPAVCursor@2@XZ:PROC	; vgui::Panel::getCursor
EXTRN	?setMinimumSize@Panel@vgui@@UAEXHH@Z:PROC	; vgui::Panel::setMinimumSize
EXTRN	?getMinimumSize@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::getMinimumSize
EXTRN	?requestFocus@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::requestFocus
EXTRN	?hasFocus@Panel@vgui@@UAE_NXZ:PROC		; vgui::Panel::hasFocus
EXTRN	?getChildCount@Panel@vgui@@UAEHXZ:PROC		; vgui::Panel::getChildCount
EXTRN	?getChild@Panel@vgui@@UAEPAV12@H@Z:PROC		; vgui::Panel::getChild
EXTRN	?setLayout@Panel@vgui@@UAEXPAVLayout@2@@Z:PROC	; vgui::Panel::setLayout
EXTRN	?invalidateLayout@Panel@vgui@@UAEX_N@Z:PROC	; vgui::Panel::invalidateLayout
EXTRN	?setFocusNavGroup@Panel@vgui@@UAEXPAVFocusNavGroup@2@@Z:PROC ; vgui::Panel::setFocusNavGroup
EXTRN	?requestFocusPrev@Panel@vgui@@UAEXXZ:PROC	; vgui::Panel::requestFocusPrev
EXTRN	?requestFocusNext@Panel@vgui@@UAEXXZ:PROC	; vgui::Panel::requestFocusNext
EXTRN	?addFocusChangeSignal@Panel@vgui@@UAEXPAVFocusChangeSignal@2@@Z:PROC ; vgui::Panel::addFocusChangeSignal
EXTRN	?isAutoFocusNavEnabled@Panel@vgui@@UAE_NXZ:PROC	; vgui::Panel::isAutoFocusNavEnabled
EXTRN	?setAutoFocusNavEnabled@Panel@vgui@@UAEX_N@Z:PROC ; vgui::Panel::setAutoFocusNavEnabled
EXTRN	?setBorder@Panel@vgui@@UAEXPAVBorder@2@@Z:PROC	; vgui::Panel::setBorder
EXTRN	?setPaintBorderEnabled@Panel@vgui@@UAEX_N@Z:PROC ; vgui::Panel::setPaintBorderEnabled
EXTRN	?setPaintBackgroundEnabled@Panel@vgui@@UAEX_N@Z:PROC ; vgui::Panel::setPaintBackgroundEnabled
EXTRN	?setPaintEnabled@Panel@vgui@@UAEX_N@Z:PROC	; vgui::Panel::setPaintEnabled
EXTRN	?getInset@Panel@vgui@@UAEXAAH000@Z:PROC		; vgui::Panel::getInset
EXTRN	?getPaintSize@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::getPaintSize
EXTRN	?setPreferredSize@Panel@vgui@@UAEXHH@Z:PROC	; vgui::Panel::setPreferredSize
EXTRN	?getPreferredSize@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::getPreferredSize
EXTRN	?getSurfaceBase@Panel@vgui@@UAEPAVSurfaceBase@2@XZ:PROC ; vgui::Panel::getSurfaceBase
EXTRN	?isEnabled@Panel@vgui@@UAE_NXZ:PROC		; vgui::Panel::isEnabled
EXTRN	?setEnabled@Panel@vgui@@UAEX_N@Z:PROC		; vgui::Panel::setEnabled
EXTRN	?setBuildGroup@Panel@vgui@@UAEXPAVBuildGroup@2@PBD@Z:PROC ; vgui::Panel::setBuildGroup
EXTRN	?isBuildGroupEnabled@Panel@vgui@@UAE_NXZ:PROC	; vgui::Panel::isBuildGroupEnabled
EXTRN	?removeAllChildren@Panel@vgui@@UAEXXZ:PROC	; vgui::Panel::removeAllChildren
EXTRN	?repaintParent@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::repaintParent
EXTRN	?createPropertyPanel@Panel@vgui@@UAEPAV12@XZ:PROC ; vgui::Panel::createPropertyPanel
EXTRN	?getPersistanceText@Panel@vgui@@UAEXPADH@Z:PROC	; vgui::Panel::getPersistanceText
EXTRN	?applyPersistanceText@Panel@vgui@@UAEXPBD@Z:PROC ; vgui::Panel::applyPersistanceText
EXTRN	?setFgColor@Panel@vgui@@UAEXW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Panel::setFgColor
EXTRN	?setBgColor@Panel@vgui@@UAEXW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Panel::setBgColor
EXTRN	?setFgColor@Panel@vgui@@UAEXHHHH@Z:PROC		; vgui::Panel::setFgColor
EXTRN	?setBgColor@Panel@vgui@@UAEXHHHH@Z:PROC		; vgui::Panel::setBgColor
EXTRN	?getFgColor@Panel@vgui@@UAEXAAH000@Z:PROC	; vgui::Panel::getFgColor
EXTRN	?getBgColor@Panel@vgui@@UAEXAAH000@Z:PROC	; vgui::Panel::getBgColor
EXTRN	?setBgColor@Panel@vgui@@UAEXVColor@2@@Z:PROC	; vgui::Panel::setBgColor
EXTRN	?setFgColor@Panel@vgui@@UAEXVColor@2@@Z:PROC	; vgui::Panel::setFgColor
EXTRN	?getBgColor@Panel@vgui@@UAEXAAVColor@2@@Z:PROC	; vgui::Panel::getBgColor
EXTRN	?getFgColor@Panel@vgui@@UAEXAAVColor@2@@Z:PROC	; vgui::Panel::getFgColor
EXTRN	?setAsMouseCapture@Panel@vgui@@UAEX_N@Z:PROC	; vgui::Panel::setAsMouseCapture
EXTRN	?setAsMouseArena@Panel@vgui@@UAEX_N@Z:PROC	; vgui::Panel::setAsMouseArena
EXTRN	?getApp@Panel@vgui@@UAEPAVApp@2@XZ:PROC		; vgui::Panel::getApp
EXTRN	?getVirtualSize@Panel@vgui@@UAEXAAH0@Z:PROC	; vgui::Panel::getVirtualSize
EXTRN	?setLayoutInfo@Panel@vgui@@UAEXPAVLayoutInfo@2@@Z:PROC ; vgui::Panel::setLayoutInfo
EXTRN	?getLayoutInfo@Panel@vgui@@UAEPAVLayoutInfo@2@XZ:PROC ; vgui::Panel::getLayoutInfo
EXTRN	?isCursorNone@Panel@vgui@@UAE_NXZ:PROC		; vgui::Panel::isCursorNone
EXTRN	?solveTraverse@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::solveTraverse
EXTRN	?paintTraverse@Panel@vgui@@UAEXXZ:PROC		; vgui::Panel::paintTraverse
EXTRN	?setSurfaceBaseTraverse@Panel@vgui@@UAEXPAVSurfaceBase@2@@Z:PROC ; vgui::Panel::setSurfaceBaseTraverse
EXTRN	?performLayout@Panel@vgui@@MAEXXZ:PROC		; vgui::Panel::performLayout
EXTRN	?internalPerformLayout@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::internalPerformLayout
EXTRN	?drawSetColor@Panel@vgui@@MAEXW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Panel::drawSetColor
EXTRN	?drawSetColor@Panel@vgui@@MAEXHHHH@Z:PROC	; vgui::Panel::drawSetColor
EXTRN	?drawFilledRect@Panel@vgui@@MAEXHHHH@Z:PROC	; vgui::Panel::drawFilledRect
EXTRN	?drawOutlinedRect@Panel@vgui@@MAEXHHHH@Z:PROC	; vgui::Panel::drawOutlinedRect
EXTRN	?drawSetTextFont@Panel@vgui@@MAEXW4SchemeFont@Scheme@2@@Z:PROC ; vgui::Panel::drawSetTextFont
EXTRN	?drawSetTextFont@Panel@vgui@@MAEXPAVFont@2@@Z:PROC ; vgui::Panel::drawSetTextFont
EXTRN	?drawSetTextColor@Panel@vgui@@MAEXW4SchemeColor@Scheme@2@@Z:PROC ; vgui::Panel::drawSetTextColor
EXTRN	?drawSetTextColor@Panel@vgui@@MAEXHHHH@Z:PROC	; vgui::Panel::drawSetTextColor
EXTRN	?drawSetTextPos@Panel@vgui@@MAEXHH@Z:PROC	; vgui::Panel::drawSetTextPos
EXTRN	?drawPrintText@Panel@vgui@@MAEXPBDH@Z:PROC	; vgui::Panel::drawPrintText
EXTRN	?drawPrintText@Panel@vgui@@MAEXHHPBDH@Z:PROC	; vgui::Panel::drawPrintText
EXTRN	?drawPrintChar@Panel@vgui@@MAEXD@Z:PROC		; vgui::Panel::drawPrintChar
EXTRN	?drawPrintChar@Panel@vgui@@MAEXHHD@Z:PROC	; vgui::Panel::drawPrintChar
EXTRN	?drawSetTextureRGBA@Panel@vgui@@MAEXHPBDHH@Z:PROC ; vgui::Panel::drawSetTextureRGBA
EXTRN	?drawSetTexture@Panel@vgui@@MAEXH@Z:PROC	; vgui::Panel::drawSetTexture
EXTRN	?drawTexturedRect@Panel@vgui@@MAEXHHHH@Z:PROC	; vgui::Panel::drawTexturedRect
EXTRN	?solve@Panel@vgui@@MAEXXZ:PROC			; vgui::Panel::solve
EXTRN	?paintTraverse@Panel@vgui@@MAEX_N@Z:PROC	; vgui::Panel::paintTraverse
EXTRN	?paintBackground@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::paintBackground
EXTRN	?paint@Panel@vgui@@MAEXXZ:PROC			; vgui::Panel::paint
EXTRN	?paintBuildOverlay@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::paintBuildOverlay
EXTRN	?internalCursorMoved@Panel@vgui@@MAEXHH@Z:PROC	; vgui::Panel::internalCursorMoved
EXTRN	?internalCursorEntered@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::internalCursorEntered
EXTRN	?internalCursorExited@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::internalCursorExited
EXTRN	?internalMousePressed@Panel@vgui@@MAEXW4MouseCode@2@@Z:PROC ; vgui::Panel::internalMousePressed
EXTRN	?internalMouseDoublePressed@Panel@vgui@@MAEXW4MouseCode@2@@Z:PROC ; vgui::Panel::internalMouseDoublePressed
EXTRN	?internalMouseReleased@Panel@vgui@@MAEXW4MouseCode@2@@Z:PROC ; vgui::Panel::internalMouseReleased
EXTRN	?internalMouseWheeled@Panel@vgui@@MAEXH@Z:PROC	; vgui::Panel::internalMouseWheeled
EXTRN	?internalKeyPressed@Panel@vgui@@MAEXW4KeyCode@2@@Z:PROC ; vgui::Panel::internalKeyPressed
EXTRN	?internalKeyTyped@Panel@vgui@@MAEXW4KeyCode@2@@Z:PROC ; vgui::Panel::internalKeyTyped
EXTRN	?internalKeyReleased@Panel@vgui@@MAEXW4KeyCode@2@@Z:PROC ; vgui::Panel::internalKeyReleased
EXTRN	?internalKeyFocusTicked@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::internalKeyFocusTicked
EXTRN	?internalFocusChanged@Panel@vgui@@MAEX_N@Z:PROC	; vgui::Panel::internalFocusChanged
EXTRN	?internalSetCursor@Panel@vgui@@MAEXXZ:PROC	; vgui::Panel::internalSetCursor
EXTRN	??0SurfaceBase@vgui@@QAE@PAVPanel@1@@Z:PROC	; vgui::SurfaceBase::SurfaceBase
EXTRN	??1SurfaceBase@vgui@@IAE@XZ:PROC		; vgui::SurfaceBase::~SurfaceBase
EXTRN	?getPanel@SurfaceBase@vgui@@UAEPAVPanel@2@XZ:PROC ; vgui::SurfaceBase::getPanel
EXTRN	?requestSwap@SurfaceBase@vgui@@UAEXXZ:PROC	; vgui::SurfaceBase::requestSwap
EXTRN	?resetModeInfo@SurfaceBase@vgui@@UAEXXZ:PROC	; vgui::SurfaceBase::resetModeInfo
EXTRN	?getModeInfoCount@SurfaceBase@vgui@@UAEHXZ:PROC	; vgui::SurfaceBase::getModeInfoCount
EXTRN	?getModeInfo@SurfaceBase@vgui@@UAE_NHAAH00@Z:PROC ; vgui::SurfaceBase::getModeInfo
EXTRN	?getApp@SurfaceBase@vgui@@UAEPAVApp@2@XZ:PROC	; vgui::SurfaceBase::getApp
EXTRN	?setEmulatedCursorVisible@SurfaceBase@vgui@@UAEX_N@Z:PROC ; vgui::SurfaceBase::setEmulatedCursorVisible
EXTRN	?setEmulatedCursorPos@SurfaceBase@vgui@@UAEXHH@Z:PROC ; vgui::SurfaceBase::setEmulatedCursorPos
EXTRN	?addModeInfo@SurfaceBase@vgui@@MAEXHHH@Z:PROC	; vgui::SurfaceBase::addModeInfo
EXTRN	?VGUI_InitCursors@@YAXXZ:PROC			; VGUI_InitCursors
EXTRN	?VGUI_CursorSelect@@YAXPAVCursor@vgui@@@Z:PROC	; VGUI_CursorSelect
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_g_color_table:BYTE
EXTRN	_vgui_colorstrings:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?staticRGBA@@3PADA DB 0100000H DUP (?)			; staticRGBA
?g_VertexBuffer@@3PAUvpoint_t@@A DB 05000H DUP (?)	; g_VertexBuffer
?g_iVertexBufferEntriesUsed@@3HA DD 01H DUP (?)		; g_iVertexBufferEntriesUsed
?staticContextCount@@3HA DD 01H DUP (?)			; staticContextCount
?staticFont@@3PAVFont@vgui@@A DD 01H DUP (?)		; staticFont
?staticFontInfo@@3PAUFontInfo@@A DD 01H DUP (?)		; staticFontInfo
?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A DB 0cH DUP (?) ; staticFontInfoDar
?paintStack@@3PAUPaintStack@@A DB 0e0H DUP (?)		; paintStack
?staticPaintStackPos@@3HA DD 01H DUP (?)		; staticPaintStackPos
?hasColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4_NA DB 01H DUP (?) ; `CEngineSurface::drawPrintText'::`2'::hasColor
_BSS	ENDS
CRT$XCU	SEGMENT
?staticFontInfoDar$initializer$@@3P6AXXZA DD FLAT:??__EstaticFontInfoDar@@YAXXZ ; staticFontInfoDar$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4080000000000000
CONST	SEGMENT
__real@4080000000000000 DQ 04080000000000000r	; 512
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CEngineSurface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEngineSurface@@8 DD FLAT:??_R0?AVCEngineSurface@@@8 ; CEngineSurface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEngineSurface@@8
rdata$r	ENDS
;	COMDAT ??_R2CEngineSurface@@8
rdata$r	SEGMENT
??_R2CEngineSurface@@8 DD FLAT:??_R1A@?0A@EA@CEngineSurface@@8 ; CEngineSurface::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SurfaceBase@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R3CEngineSurface@@8
rdata$r	SEGMENT
??_R3CEngineSurface@@8 DD 00H				; CEngineSurface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEngineSurface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEngineSurface@@@8
data$rs	SEGMENT
??_R0?AVCEngineSurface@@@8 DD FLAT:??_7type_info@@6B@	; CEngineSurface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEngineSurface@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEngineSurface@@6B@
rdata$r	SEGMENT
??_R4CEngineSurface@@6B@ DD 00H				; CEngineSurface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEngineSurface@@@8
	DD	FLAT:??_R3CEngineSurface@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Color@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Color@vgui@@8 DD FLAT:??_R0?AVColor@vgui@@@8 ; vgui::Color::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Color@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2Color@vgui@@8
rdata$r	SEGMENT
??_R2Color@vgui@@8 DD FLAT:??_R1A@?0A@EA@Color@vgui@@8	; vgui::Color::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Color@vgui@@8
rdata$r	SEGMENT
??_R3Color@vgui@@8 DD 00H				; vgui::Color::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Color@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVColor@vgui@@@8
data$rs	SEGMENT
??_R0?AVColor@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::Color `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVColor@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Color@vgui@@6B@
rdata$r	SEGMENT
??_R4Color@vgui@@6B@ DD 00H				; vgui::Color::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVColor@vgui@@@8
	DD	FLAT:??_R3Color@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Font@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Font@vgui@@8 DD FLAT:??_R0?AVFont@vgui@@@8 ; vgui::Font::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Font@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2Font@vgui@@8
rdata$r	SEGMENT
??_R2Font@vgui@@8 DD FLAT:??_R1A@?0A@EA@Font@vgui@@8	; vgui::Font::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Font@vgui@@8
rdata$r	SEGMENT
??_R3Font@vgui@@8 DD 00H				; vgui::Font::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Font@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFont@vgui@@@8
data$rs	SEGMENT
??_R0?AVFont@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::Font `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFont@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Font@vgui@@6B@
rdata$r	SEGMENT
??_R4Font@vgui@@6B@ DD 00H				; vgui::Font::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFont@vgui@@@8
	DD	FLAT:??_R3Font@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@App@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@App@vgui@@8 DD FLAT:??_R0?AVApp@vgui@@@8	; vgui::App::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3App@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2App@vgui@@8
rdata$r	SEGMENT
??_R2App@vgui@@8 DD FLAT:??_R1A@?0A@EA@App@vgui@@8	; vgui::App::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3App@vgui@@8
rdata$r	SEGMENT
??_R3App@vgui@@8 DD 00H					; vgui::App::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2App@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVApp@vgui@@@8
data$rs	SEGMENT
??_R0?AVApp@vgui@@@8 DD FLAT:??_7type_info@@6B@		; vgui::App `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVApp@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4App@vgui@@6B@
rdata$r	SEGMENT
??_R4App@vgui@@6B@ DD 00H				; vgui::App::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVApp@vgui@@@8
	DD	FLAT:??_R3App@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Scheme@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Scheme@vgui@@8 DD FLAT:??_R0?AVScheme@vgui@@@8 ; vgui::Scheme::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Scheme@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2Scheme@vgui@@8
rdata$r	SEGMENT
??_R2Scheme@vgui@@8 DD FLAT:??_R1A@?0A@EA@Scheme@vgui@@8 ; vgui::Scheme::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Scheme@vgui@@8
rdata$r	SEGMENT
??_R3Scheme@vgui@@8 DD 00H				; vgui::Scheme::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Scheme@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVScheme@vgui@@@8
data$rs	SEGMENT
??_R0?AVScheme@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::Scheme `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVScheme@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Scheme@vgui@@6B@
rdata$r	SEGMENT
??_R4Scheme@vgui@@6B@ DD 00H				; vgui::Scheme::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVScheme@vgui@@@8
	DD	FLAT:??_R3Scheme@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Cursor@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Cursor@vgui@@8 DD FLAT:??_R0?AVCursor@vgui@@@8 ; vgui::Cursor::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Cursor@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2Cursor@vgui@@8
rdata$r	SEGMENT
??_R2Cursor@vgui@@8 DD FLAT:??_R1A@?0A@EA@Cursor@vgui@@8 ; vgui::Cursor::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Cursor@vgui@@8
rdata$r	SEGMENT
??_R3Cursor@vgui@@8 DD 00H				; vgui::Cursor::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Cursor@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCursor@vgui@@@8
data$rs	SEGMENT
??_R0?AVCursor@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::Cursor `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCursor@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Cursor@vgui@@6B@
rdata$r	SEGMENT
??_R4Cursor@vgui@@6B@ DD 00H				; vgui::Cursor::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCursor@vgui@@@8
	DD	FLAT:??_R3Cursor@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Panel@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Panel@vgui@@8 DD FLAT:??_R0?AVPanel@vgui@@@8 ; vgui::Panel::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Panel@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2Panel@vgui@@8
rdata$r	SEGMENT
??_R2Panel@vgui@@8 DD FLAT:??_R1A@?0A@EA@Panel@vgui@@8	; vgui::Panel::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Panel@vgui@@8
rdata$r	SEGMENT
??_R3Panel@vgui@@8 DD 00H				; vgui::Panel::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Panel@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPanel@vgui@@@8
data$rs	SEGMENT
??_R0?AVPanel@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::Panel `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPanel@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Panel@vgui@@6B@
rdata$r	SEGMENT
??_R4Panel@vgui@@6B@ DD 00H				; vgui::Panel::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPanel@vgui@@@8
	DD	FLAT:??_R3Panel@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InputSignal@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InputSignal@vgui@@8 DD FLAT:??_R0?AVInputSignal@vgui@@@8 ; vgui::InputSignal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InputSignal@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2InputSignal@vgui@@8
rdata$r	SEGMENT
??_R2InputSignal@vgui@@8 DD FLAT:??_R1A@?0A@EA@InputSignal@vgui@@8 ; vgui::InputSignal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3InputSignal@vgui@@8
rdata$r	SEGMENT
??_R3InputSignal@vgui@@8 DD 00H				; vgui::InputSignal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2InputSignal@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInputSignal@vgui@@@8
data$rs	SEGMENT
??_R0?AVInputSignal@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::InputSignal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInputSignal@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4InputSignal@vgui@@6B@
rdata$r	SEGMENT
??_R4InputSignal@vgui@@6B@ DD 00H			; vgui::InputSignal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInputSignal@vgui@@@8
	DD	FLAT:??_R3InputSignal@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SurfaceBase@vgui@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SurfaceBase@vgui@@8 DD FLAT:??_R0?AVSurfaceBase@vgui@@@8 ; vgui::SurfaceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SurfaceBase@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R2SurfaceBase@vgui@@8
rdata$r	SEGMENT
??_R2SurfaceBase@vgui@@8 DD FLAT:??_R1A@?0A@EA@SurfaceBase@vgui@@8 ; vgui::SurfaceBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SurfaceBase@vgui@@8
rdata$r	SEGMENT
??_R3SurfaceBase@vgui@@8 DD 00H				; vgui::SurfaceBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SurfaceBase@vgui@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSurfaceBase@vgui@@@8
data$rs	SEGMENT
??_R0?AVSurfaceBase@vgui@@@8 DD FLAT:??_7type_info@@6B@	; vgui::SurfaceBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSurfaceBase@vgui@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SurfaceBase@vgui@@6B@
rdata$r	SEGMENT
??_R4SurfaceBase@vgui@@6B@ DD 00H			; vgui::SurfaceBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSurfaceBase@vgui@@@8
	DD	FLAT:??_R3SurfaceBase@vgui@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CC@LLENABMC@paintStack?$FLtop?$FN?4m_pPanel?5?$DN?$DN?5pan@
CONST	SEGMENT
??_C@_0CC@LLENABMC@paintStack?$FLtop?$FN?4m_pPanel?5?$DN?$DN?5pan@ DB 'pa'
	DB	'intStack[top].m_pPanel == panel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNONEIAK@top?5?$DO?$DN?50@
CONST	SEGMENT
??_C@_08KNONEIAK@top?5?$DO?$DN?50@ DB 'top >= 0', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z@4JA DD 01bfH ; `CEngineSurface::popMakeCurrent'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z@4JA DD 01a1H ; `CEngineSurface::pushMakeCurrent'::`1'::__LINE__Var
_DATA	ENDS
_DATA	SEGMENT
?numColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4HA DD 07H ; `CEngineSurface::drawPrintText'::`2'::numColor
_DATA	ENDS
;	COMDAT ??_7CEngineSurface@@6B@
CONST	SEGMENT
??_7CEngineSurface@@6B@ DD FLAT:??_R4CEngineSurface@@6B@ ; CEngineSurface::`vftable'
	DD	FLAT:?getPanel@SurfaceBase@vgui@@UAEPAVPanel@2@XZ
	DD	FLAT:?requestSwap@SurfaceBase@vgui@@UAEXXZ
	DD	FLAT:?resetModeInfo@SurfaceBase@vgui@@UAEXXZ
	DD	FLAT:?getModeInfoCount@SurfaceBase@vgui@@UAEHXZ
	DD	FLAT:?getModeInfo@SurfaceBase@vgui@@UAE_NHAAH00@Z
	DD	FLAT:?getApp@SurfaceBase@vgui@@UAEPAVApp@2@XZ
	DD	FLAT:?setEmulatedCursorVisible@SurfaceBase@vgui@@UAEX_N@Z
	DD	FLAT:?setEmulatedCursorPos@SurfaceBase@vgui@@UAEXHH@Z
	DD	FLAT:?setTitle@CEngineSurface@@UAEXPBD@Z
	DD	FLAT:?setFullscreenMode@CEngineSurface@@UAE_NHHH@Z
	DD	FLAT:?setWindowedMode@CEngineSurface@@UAEXXZ
	DD	FLAT:?setAsTopMost@CEngineSurface@@MAEX_N@Z
	DD	FLAT:?createPopup@CEngineSurface@@UAEXPAVPanel@vgui@@@Z
	DD	FLAT:?hasFocus@CEngineSurface@@UAE_NXZ
	DD	FLAT:?isWithin@CEngineSurface@@UAE_NHH@Z
	DD	FLAT:?createNewTextureID@CEngineSurface@@MAEHXZ
	DD	FLAT:?addModeInfo@SurfaceBase@vgui@@MAEXHHH@Z
	DD	FLAT:?drawSetColor@CEngineSurface@@MAEXHHHH@Z
	DD	FLAT:?drawFilledRect@CEngineSurface@@MAEXHHHH@Z
	DD	FLAT:?drawOutlinedRect@CEngineSurface@@MAEXHHHH@Z
	DD	FLAT:?drawSetTextFont@CEngineSurface@@MAEXPAVFont@vgui@@@Z
	DD	FLAT:?drawSetTextColor@CEngineSurface@@MAEXHHHH@Z
	DD	FLAT:?drawSetTextPos@CEngineSurface@@MAEXHH@Z
	DD	FLAT:?drawPrintText@CEngineSurface@@MAEXPBDH@Z
	DD	FLAT:?drawSetTextureRGBA@CEngineSurface@@MAEXHPBDHH@Z
	DD	FLAT:?drawSetTexture@CEngineSurface@@MAEXH@Z
	DD	FLAT:?drawTexturedRect@CEngineSurface@@MAEXHHHH@Z
	DD	FLAT:?invalidate@CEngineSurface@@MAEXPAVPanel@vgui@@@Z
	DD	FLAT:?enableMouseCapture@CEngineSurface@@MAEX_N@Z
	DD	FLAT:?setCursor@CEngineSurface@@MAEXPAVCursor@vgui@@@Z
	DD	FLAT:?swapBuffers@CEngineSurface@@MAEXXZ
	DD	FLAT:?pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z
	DD	FLAT:?popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z
	DD	FLAT:?applyChanges@CEngineSurface@@MAEXXZ
	DD	FLAT:?drawPrintChar@CEngineSurface@@MAEXHHHHMMMMQAH@Z
	DD	FLAT:?addCharToBuffer@CEngineSurface@@MAEXPBUvpoint_t@@0QAH@Z
	DD	FLAT:?createPlat@CEngineSurface@@MAE_NXZ
	DD	FLAT:?recreateContext@CEngineSurface@@MAE_NXZ
	DD	FLAT:?flushBuffer@CEngineSurface@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7InputSignal@vgui@@6B@
CONST	SEGMENT
??_7InputSignal@vgui@@6B@ DD FLAT:??_R4InputSignal@vgui@@6B@ ; vgui::InputSignal::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7SurfaceBase@vgui@@6B@
CONST	SEGMENT
??_7SurfaceBase@vgui@@6B@ DD FLAT:??_R4SurfaceBase@vgui@@6B@ ; vgui::SurfaceBase::`vftable'
	DD	FLAT:?getPanel@SurfaceBase@vgui@@UAEPAVPanel@2@XZ
	DD	FLAT:?requestSwap@SurfaceBase@vgui@@UAEXXZ
	DD	FLAT:?resetModeInfo@SurfaceBase@vgui@@UAEXXZ
	DD	FLAT:?getModeInfoCount@SurfaceBase@vgui@@UAEHXZ
	DD	FLAT:?getModeInfo@SurfaceBase@vgui@@UAE_NHAAH00@Z
	DD	FLAT:?getApp@SurfaceBase@vgui@@UAEPAVApp@2@XZ
	DD	FLAT:?setEmulatedCursorVisible@SurfaceBase@vgui@@UAEX_N@Z
	DD	FLAT:?setEmulatedCursorPos@SurfaceBase@vgui@@UAEXHH@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?addModeInfo@SurfaceBase@vgui@@MAEXHHH@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7Panel@vgui@@6B@
CONST	SEGMENT
??_7Panel@vgui@@6B@ DD FLAT:??_R4Panel@vgui@@6B@	; vgui::Panel::`vftable'
	DD	FLAT:?setPos@Panel@vgui@@UAEXHH@Z
	DD	FLAT:?getPos@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?setSize@Panel@vgui@@UAEXHH@Z
	DD	FLAT:?getSize@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?setBounds@Panel@vgui@@UAEXHHHH@Z
	DD	FLAT:?getBounds@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?getWide@Panel@vgui@@UAEHXZ
	DD	FLAT:?getTall@Panel@vgui@@UAEHXZ
	DD	FLAT:?getParent@Panel@vgui@@UAEPAV12@XZ
	DD	FLAT:?setVisible@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?isVisible@Panel@vgui@@UAE_NXZ
	DD	FLAT:?isVisibleUp@Panel@vgui@@UAE_NXZ
	DD	FLAT:?repaint@Panel@vgui@@UAEXXZ
	DD	FLAT:?repaintAll@Panel@vgui@@UAEXXZ
	DD	FLAT:?getAbsExtents@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?getClipRect@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?setParent@Panel@vgui@@UAEXPAV12@@Z
	DD	FLAT:?addChild@Panel@vgui@@UAEXPAV12@@Z
	DD	FLAT:?insertChildAt@Panel@vgui@@UAEXPAV12@H@Z
	DD	FLAT:?removeChild@Panel@vgui@@UAEXPAV12@@Z
	DD	FLAT:?wasMousePressed@Panel@vgui@@UAE_NW4MouseCode@2@@Z
	DD	FLAT:?wasMouseDoublePressed@Panel@vgui@@UAE_NW4MouseCode@2@@Z
	DD	FLAT:?isMouseDown@Panel@vgui@@UAE_NW4MouseCode@2@@Z
	DD	FLAT:?wasMouseReleased@Panel@vgui@@UAE_NW4MouseCode@2@@Z
	DD	FLAT:?wasKeyPressed@Panel@vgui@@UAE_NW4KeyCode@2@@Z
	DD	FLAT:?isKeyDown@Panel@vgui@@UAE_NW4KeyCode@2@@Z
	DD	FLAT:?wasKeyTyped@Panel@vgui@@UAE_NW4KeyCode@2@@Z
	DD	FLAT:?wasKeyReleased@Panel@vgui@@UAE_NW4KeyCode@2@@Z
	DD	FLAT:?addInputSignal@Panel@vgui@@UAEXPAVInputSignal@2@@Z
	DD	FLAT:?removeInputSignal@Panel@vgui@@UAEXPAVInputSignal@2@@Z
	DD	FLAT:?addRepaintSignal@Panel@vgui@@UAEXPAVRepaintSignal@2@@Z
	DD	FLAT:?removeRepaintSignal@Panel@vgui@@UAEXPAVRepaintSignal@2@@Z
	DD	FLAT:?isWithin@Panel@vgui@@UAE_NHH@Z
	DD	FLAT:?isWithinTraverse@Panel@vgui@@UAEPAV12@HH@Z
	DD	FLAT:?localToScreen@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?screenToLocal@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?setCursor@Panel@vgui@@UAEXW4SchemeCursor@Scheme@2@@Z
	DD	FLAT:?setCursor@Panel@vgui@@UAEXPAVCursor@2@@Z
	DD	FLAT:?getCursor@Panel@vgui@@UAEPAVCursor@2@XZ
	DD	FLAT:?setMinimumSize@Panel@vgui@@UAEXHH@Z
	DD	FLAT:?getMinimumSize@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?requestFocus@Panel@vgui@@UAEXXZ
	DD	FLAT:?hasFocus@Panel@vgui@@UAE_NXZ
	DD	FLAT:?getChildCount@Panel@vgui@@UAEHXZ
	DD	FLAT:?getChild@Panel@vgui@@UAEPAV12@H@Z
	DD	FLAT:?setLayout@Panel@vgui@@UAEXPAVLayout@2@@Z
	DD	FLAT:?invalidateLayout@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setFocusNavGroup@Panel@vgui@@UAEXPAVFocusNavGroup@2@@Z
	DD	FLAT:?requestFocusPrev@Panel@vgui@@UAEXXZ
	DD	FLAT:?requestFocusNext@Panel@vgui@@UAEXXZ
	DD	FLAT:?addFocusChangeSignal@Panel@vgui@@UAEXPAVFocusChangeSignal@2@@Z
	DD	FLAT:?isAutoFocusNavEnabled@Panel@vgui@@UAE_NXZ
	DD	FLAT:?setAutoFocusNavEnabled@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setBorder@Panel@vgui@@UAEXPAVBorder@2@@Z
	DD	FLAT:?setPaintBorderEnabled@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setPaintBackgroundEnabled@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setPaintEnabled@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?getInset@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?getPaintSize@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?setPreferredSize@Panel@vgui@@UAEXHH@Z
	DD	FLAT:?getPreferredSize@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?getSurfaceBase@Panel@vgui@@UAEPAVSurfaceBase@2@XZ
	DD	FLAT:?isEnabled@Panel@vgui@@UAE_NXZ
	DD	FLAT:?setEnabled@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setBuildGroup@Panel@vgui@@UAEXPAVBuildGroup@2@PBD@Z
	DD	FLAT:?isBuildGroupEnabled@Panel@vgui@@UAE_NXZ
	DD	FLAT:?removeAllChildren@Panel@vgui@@UAEXXZ
	DD	FLAT:?repaintParent@Panel@vgui@@UAEXXZ
	DD	FLAT:?createPropertyPanel@Panel@vgui@@UAEPAV12@XZ
	DD	FLAT:?getPersistanceText@Panel@vgui@@UAEXPADH@Z
	DD	FLAT:?applyPersistanceText@Panel@vgui@@UAEXPBD@Z
	DD	FLAT:?setFgColor@Panel@vgui@@UAEXVColor@2@@Z
	DD	FLAT:?setFgColor@Panel@vgui@@UAEXHHHH@Z
	DD	FLAT:?setFgColor@Panel@vgui@@UAEXW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?setBgColor@Panel@vgui@@UAEXVColor@2@@Z
	DD	FLAT:?setBgColor@Panel@vgui@@UAEXHHHH@Z
	DD	FLAT:?setBgColor@Panel@vgui@@UAEXW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?getFgColor@Panel@vgui@@UAEXAAVColor@2@@Z
	DD	FLAT:?getFgColor@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?getBgColor@Panel@vgui@@UAEXAAVColor@2@@Z
	DD	FLAT:?getBgColor@Panel@vgui@@UAEXAAH000@Z
	DD	FLAT:?setAsMouseCapture@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?setAsMouseArena@Panel@vgui@@UAEX_N@Z
	DD	FLAT:?getApp@Panel@vgui@@UAEPAVApp@2@XZ
	DD	FLAT:?getVirtualSize@Panel@vgui@@UAEXAAH0@Z
	DD	FLAT:?setLayoutInfo@Panel@vgui@@UAEXPAVLayoutInfo@2@@Z
	DD	FLAT:?getLayoutInfo@Panel@vgui@@UAEPAVLayoutInfo@2@XZ
	DD	FLAT:?isCursorNone@Panel@vgui@@UAE_NXZ
	DD	FLAT:?solveTraverse@Panel@vgui@@UAEXXZ
	DD	FLAT:?paintTraverse@Panel@vgui@@MAEX_N@Z
	DD	FLAT:?paintTraverse@Panel@vgui@@UAEXXZ
	DD	FLAT:?setSurfaceBaseTraverse@Panel@vgui@@UAEXPAVSurfaceBase@2@@Z
	DD	FLAT:?performLayout@Panel@vgui@@MAEXXZ
	DD	FLAT:?internalPerformLayout@Panel@vgui@@MAEXXZ
	DD	FLAT:?drawSetColor@Panel@vgui@@MAEXHHHH@Z
	DD	FLAT:?drawSetColor@Panel@vgui@@MAEXW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?drawFilledRect@Panel@vgui@@MAEXHHHH@Z
	DD	FLAT:?drawOutlinedRect@Panel@vgui@@MAEXHHHH@Z
	DD	FLAT:?drawSetTextFont@Panel@vgui@@MAEXPAVFont@2@@Z
	DD	FLAT:?drawSetTextFont@Panel@vgui@@MAEXW4SchemeFont@Scheme@2@@Z
	DD	FLAT:?drawSetTextColor@Panel@vgui@@MAEXHHHH@Z
	DD	FLAT:?drawSetTextColor@Panel@vgui@@MAEXW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?drawSetTextPos@Panel@vgui@@MAEXHH@Z
	DD	FLAT:?drawPrintText@Panel@vgui@@MAEXHHPBDH@Z
	DD	FLAT:?drawPrintText@Panel@vgui@@MAEXPBDH@Z
	DD	FLAT:?drawPrintChar@Panel@vgui@@MAEXHHD@Z
	DD	FLAT:?drawPrintChar@Panel@vgui@@MAEXD@Z
	DD	FLAT:?drawSetTextureRGBA@Panel@vgui@@MAEXHPBDHH@Z
	DD	FLAT:?drawSetTexture@Panel@vgui@@MAEXH@Z
	DD	FLAT:?drawTexturedRect@Panel@vgui@@MAEXHHHH@Z
	DD	FLAT:?solve@Panel@vgui@@MAEXXZ
	DD	FLAT:?paintBackground@Panel@vgui@@MAEXXZ
	DD	FLAT:?paint@Panel@vgui@@MAEXXZ
	DD	FLAT:?paintBuildOverlay@Panel@vgui@@MAEXXZ
	DD	FLAT:?internalCursorMoved@Panel@vgui@@MAEXHH@Z
	DD	FLAT:?internalCursorEntered@Panel@vgui@@MAEXXZ
	DD	FLAT:?internalCursorExited@Panel@vgui@@MAEXXZ
	DD	FLAT:?internalMousePressed@Panel@vgui@@MAEXW4MouseCode@2@@Z
	DD	FLAT:?internalMouseDoublePressed@Panel@vgui@@MAEXW4MouseCode@2@@Z
	DD	FLAT:?internalMouseReleased@Panel@vgui@@MAEXW4MouseCode@2@@Z
	DD	FLAT:?internalMouseWheeled@Panel@vgui@@MAEXH@Z
	DD	FLAT:?internalKeyPressed@Panel@vgui@@MAEXW4KeyCode@2@@Z
	DD	FLAT:?internalKeyTyped@Panel@vgui@@MAEXW4KeyCode@2@@Z
	DD	FLAT:?internalKeyReleased@Panel@vgui@@MAEXW4KeyCode@2@@Z
	DD	FLAT:?internalKeyFocusTicked@Panel@vgui@@MAEXXZ
	DD	FLAT:?internalFocusChanged@Panel@vgui@@MAEX_N@Z
	DD	FLAT:?internalSetCursor@Panel@vgui@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7Color@vgui@@6B@
CONST	SEGMENT
??_7Color@vgui@@6B@ DD FLAT:??_R4Color@vgui@@6B@	; vgui::Color::`vftable'
	DD	FLAT:?init@Color@vgui@@EAEXXZ
	DD	FLAT:?setColor@Color@vgui@@UAEXW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?setColor@Color@vgui@@UAEXHHHH@Z
	DD	FLAT:?getColor@Color@vgui@@UAEXAAW4SchemeColor@Scheme@2@@Z
	DD	FLAT:?getColor@Color@vgui@@UAEXAAH000@Z
	DD	FLAT:??AColor@vgui@@UAEHH@Z
CONST	ENDS
;	COMDAT ??_7Scheme@vgui@@6B@
CONST	SEGMENT
??_7Scheme@vgui@@6B@ DD FLAT:??_R4Scheme@vgui@@6B@	; vgui::Scheme::`vftable'
	DD	FLAT:?setColor@Scheme@vgui@@UAEXW4SchemeColor@12@HHHH@Z
	DD	FLAT:?getColor@Scheme@vgui@@UAEXW4SchemeColor@12@AAH111@Z
	DD	FLAT:?setFont@Scheme@vgui@@UAEXW4SchemeFont@12@PAVFont@2@@Z
	DD	FLAT:?getFont@Scheme@vgui@@UAEPAVFont@2@W4SchemeFont@12@@Z
	DD	FLAT:?setCursor@Scheme@vgui@@UAEXW4SchemeCursor@12@PAVCursor@2@@Z
	DD	FLAT:?getCursor@Scheme@vgui@@UAEPAVCursor@2@W4SchemeCursor@12@@Z
CONST	ENDS
;	COMDAT ??_7Font@vgui@@6B@
CONST	SEGMENT
??_7Font@vgui@@6B@ DD FLAT:??_R4Font@vgui@@6B@		; vgui::Font::`vftable'
	DD	FLAT:?init@Font@vgui@@EAEXPBDPAXHHHMH_N222@Z
	DD	FLAT:?getCharRGBA@Font@vgui@@UAEXHHHHHPAE@Z
	DD	FLAT:?getCharABCwide@Font@vgui@@UAEXHAAH00@Z
	DD	FLAT:?getTextSize@Font@vgui@@UAEXPBDAAH1@Z
	DD	FLAT:?getTall@Font@vgui@@UAEHXZ
	DD	FLAT:?getId@Font@vgui@@UAEHXZ
CONST	ENDS
;	COMDAT ??_7App@vgui@@6B@
CONST	SEGMENT
??_7App@vgui@@6B@ DD FLAT:??_R4App@vgui@@6B@		; vgui::App::`vftable'
	DD	FLAT:?start@App@vgui@@UAEXXZ
	DD	FLAT:?stop@App@vgui@@UAEXXZ
	DD	FLAT:?externalTick@App@vgui@@UAEXXZ
	DD	FLAT:?wasMousePressed@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z
	DD	FLAT:?wasMouseDoublePressed@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z
	DD	FLAT:?isMouseDown@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z
	DD	FLAT:?wasMouseReleased@App@vgui@@UAE_NW4MouseCode@2@PAVPanel@2@@Z
	DD	FLAT:?wasKeyPressed@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z
	DD	FLAT:?isKeyDown@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z
	DD	FLAT:?wasKeyTyped@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z
	DD	FLAT:?wasKeyReleased@App@vgui@@UAE_NW4KeyCode@2@PAVPanel@2@@Z
	DD	FLAT:?addTickSignal@App@vgui@@UAEXPAVTickSignal@2@@Z
	DD	FLAT:?setCursorPos@App@vgui@@UAEXHH@Z
	DD	FLAT:?getCursorPos@App@vgui@@UAEXAAH0@Z
	DD	FLAT:?setMouseCapture@App@vgui@@UAEXPAVPanel@2@@Z
	DD	FLAT:?setMouseArena@App@vgui@@UAEXPAVPanel@2@@Z
	DD	FLAT:?setMouseArena@App@vgui@@UAEXHHHH_N@Z
	DD	FLAT:?requestFocus@App@vgui@@UAEXPAVPanel@2@@Z
	DD	FLAT:?getFocus@App@vgui@@UAEPAVPanel@2@XZ
	DD	FLAT:?repaintAll@App@vgui@@UAEXXZ
	DD	FLAT:?setScheme@App@vgui@@UAEXPAVScheme@2@@Z
	DD	FLAT:?getScheme@App@vgui@@UAEPAVScheme@2@XZ
	DD	FLAT:?enableBuildMode@App@vgui@@UAEXXZ
	DD	FLAT:?getTimeMillis@App@vgui@@UAEJXZ
	DD	FLAT:?getKeyCodeChar@App@vgui@@UAEDW4KeyCode@2@_N@Z
	DD	FLAT:?getKeyCodeText@App@vgui@@UAEXW4KeyCode@2@PADH@Z
	DD	FLAT:?getClipboardTextCount@App@vgui@@UAEHXZ
	DD	FLAT:?setClipboardText@App@vgui@@UAEXPBDH@Z
	DD	FLAT:?getClipboardText@App@vgui@@UAEHHPADH@Z
	DD	FLAT:?reset@App@vgui@@UAEXXZ
	DD	FLAT:?internalSetMouseArena@App@vgui@@UAEXHHHH_N@Z
	DD	FLAT:?setRegistryString@App@vgui@@UAE_NPBD0@Z
	DD	FLAT:?getRegistryString@App@vgui@@UAE_NPBDPADH@Z
	DD	FLAT:?setRegistryInteger@App@vgui@@UAE_NPBDH@Z
	DD	FLAT:?getRegistryInteger@App@vgui@@UAE_NPBDAAH@Z
	DD	FLAT:?setCursorOveride@App@vgui@@UAEXPAVCursor@2@@Z
	DD	FLAT:?getCursorOveride@App@vgui@@UAEPAVCursor@2@XZ
	DD	FLAT:?setMinimumTickMillisInterval@App@vgui@@UAEXH@Z
	DD	FLAT:__purecall
	DD	FLAT:?run@App@vgui@@UAEXXZ
	DD	FLAT:?internalCursorMoved@App@vgui@@UAEXHHPAVSurfaceBase@2@@Z
	DD	FLAT:?internalMousePressed@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?internalMouseDoublePressed@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?internalMouseReleased@App@vgui@@UAEXW4MouseCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?internalMouseWheeled@App@vgui@@UAEXHPAVSurfaceBase@2@@Z
	DD	FLAT:?internalKeyPressed@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?internalKeyTyped@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?internalKeyReleased@App@vgui@@UAEXW4KeyCode@2@PAVSurfaceBase@2@@Z
	DD	FLAT:?init@App@vgui@@EAEXXZ
	DD	FLAT:?updateMouseFocus@App@vgui@@EAEXHHPAVSurfaceBase@2@@Z
	DD	FLAT:?setMouseFocus@App@vgui@@EAEXPAVPanel@2@@Z
	DD	FLAT:?surfaceBaseCreated@App@vgui@@MAEXPAVSurfaceBase@2@@Z
	DD	FLAT:?surfaceBaseDeleted@App@vgui@@MAEXPAVSurfaceBase@2@@Z
	DD	FLAT:?platTick@App@vgui@@MAEXXZ
	DD	FLAT:?internalTick@App@vgui@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7Cursor@vgui@@6B@
CONST	SEGMENT
??_7Cursor@vgui@@6B@ DD FLAT:??_R4Cursor@vgui@@6B@	; vgui::Cursor::`vftable'
	DD	FLAT:?getHotspot@Cursor@vgui@@UAEXAAH0@Z
	DD	FLAT:?privateInit@Cursor@vgui@@EAEXPAVBitmap@2@HH@Z
	DD	FLAT:?getBitmap@Cursor@vgui@@UAEPAVBitmap@2@XZ
	DD	FLAT:?getDefaultCursor@Cursor@vgui@@UAE?AW4DefaultCursor@12@XZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01d7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	011cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0340H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	011bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z$0
__ehfuncinfo$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ??__EstaticFontInfoDar@@YAXXZ
text$di	SEGMENT
??__EstaticFontInfoDar@@YAXXZ PROC			; `dynamic initializer for 'staticFontInfoDar'', COMDAT

; 43   : static Dar<FontInfo*> staticFontInfoDar;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	??0?$Dar@PAUFontInfo@@@vgui@@QAE@XZ	; vgui::Dar<FontInfo *>::Dar<FontInfo *>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__EstaticFontInfoDar@@YAXXZ ENDP			; `dynamic initializer for 'staticFontInfoDar''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@$$QAV01@@Z PROC	; vgui::Dar<FontInfo *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP	; vgui::Dar<FontInfo *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<FontInfo *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAUFontInfo@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<FontInfo *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z PROC	; vgui::Dar<FontInfo *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z ENDP	; vgui::Dar<FontInfo *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z PROC ; vgui::Dar<FontInfo *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAUFontInfo@@@vgui@@QAE_NPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ENDP ; vgui::Dar<FontInfo *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAUFontInfo@@@vgui@@QAE_NPAUFontInfo@@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAUFontInfo@@@vgui@@QAE_NPAUFontInfo@@@Z PROC ; vgui::Dar<FontInfo *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAUFontInfo@@@vgui@@QAE_NPAUFontInfo@@@Z ENDP ; vgui::Dar<FontInfo *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z PROC ; vgui::Dar<FontInfo *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ; vgui::Dar<FontInfo *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ENDP ; vgui::Dar<FontInfo *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAUFontInfo@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAUFontInfo@@@vgui@@QAEHXZ PROC		; vgui::Dar<FontInfo *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAUFontInfo@@@vgui@@QAEHXZ ENDP		; vgui::Dar<FontInfo *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z PROC	; vgui::Dar<FontInfo *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<FontInfo *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z PROC	; vgui::Dar<FontInfo *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<FontInfo *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAUFontInfo@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAUFontInfo@@@vgui@@QAE@XZ PROC		; vgui::Dar<FontInfo *>::Dar<FontInfo *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ; vgui::Dar<FontInfo *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAUFontInfo@@@vgui@@QAE@XZ ENDP		; vgui::Dar<FontInfo *>::Dar<FontInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?flushBuffer@CEngineSurface@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flushBuffer@CEngineSurface@@MAEXXZ PROC		; CEngineSurface::flushBuffer, COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	if( g_iVertexBufferEntriesUsed <= 0 )

	cmp	DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 0
	jg	SHORT $LN2@flushBuffe

; 284  : 		return;

	jmp	SHORT $LN1@flushBuffe
$LN2@flushBuffe:

; 285  : 
; 286  : 	VGUI_DrawBuffer( g_VertexBuffer, g_iVertexBufferEntriesUsed );

	mov	eax, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	push	eax
	push	OFFSET ?g_VertexBuffer@@3PAUvpoint_t@@A
	call	_VGUI_DrawBuffer
	add	esp, 8

; 287  : 	g_iVertexBufferEntriesUsed = 0;

	mov	DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 0
$LN1@flushBuffe:

; 288  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?flushBuffer@CEngineSurface@@MAEXXZ ENDP		; CEngineSurface::flushBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?swapBuffers@CEngineSurface@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?swapBuffers@CEngineSurface@@MAEXXZ PROC		; CEngineSurface::swapBuffers, COMDAT
; _this$ = ecx

; 85   : 	virtual void swapBuffers( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?swapBuffers@CEngineSurface@@MAEXXZ ENDP		; CEngineSurface::swapBuffers
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?applyChanges@CEngineSurface@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?applyChanges@CEngineSurface@@MAEXXZ PROC		; CEngineSurface::applyChanges, COMDAT
; _this$ = ecx

; 84   : 	virtual void applyChanges( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?applyChanges@CEngineSurface@@MAEXXZ ENDP		; CEngineSurface::applyChanges
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?setAsTopMost@CEngineSurface@@MAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?setAsTopMost@CEngineSurface@@MAEX_N@Z PROC		; CEngineSurface::setAsTopMost, COMDAT
; _this$ = ecx

; 83   : 	virtual void setAsTopMost( bool state ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setAsTopMost@CEngineSurface@@MAEX_N@Z ENDP		; CEngineSurface::setAsTopMost
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?invalidate@CEngineSurface@@MAEXPAVPanel@vgui@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_panel$ = 8						; size = 4
?invalidate@CEngineSurface@@MAEXPAVPanel@vgui@@@Z PROC	; CEngineSurface::invalidate, COMDAT
; _this$ = ecx

; 82   : 	virtual void invalidate( Panel *panel ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?invalidate@CEngineSurface@@MAEXPAVPanel@vgui@@@Z ENDP	; CEngineSurface::invalidate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?enableMouseCapture@CEngineSurface@@MAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_state$ = 8						; size = 1
?enableMouseCapture@CEngineSurface@@MAEX_N@Z PROC	; CEngineSurface::enableMouseCapture, COMDAT
; _this$ = ecx

; 81   : 	virtual void enableMouseCapture( bool state ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?enableMouseCapture@CEngineSurface@@MAEX_N@Z ENDP	; CEngineSurface::enableMouseCapture
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?recreateContext@CEngineSurface@@MAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?recreateContext@CEngineSurface@@MAE_NXZ PROC		; CEngineSurface::recreateContext, COMDAT
; _this$ = ecx

; 80   : 	virtual bool recreateContext( void ) { return false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?recreateContext@CEngineSurface@@MAE_NXZ ENDP		; CEngineSurface::recreateContext
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?createPlat@CEngineSurface@@MAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?createPlat@CEngineSurface@@MAE_NXZ PROC		; CEngineSurface::createPlat, COMDAT
; _this$ = ecx

; 79   : 	virtual bool createPlat( void ) { return false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?createPlat@CEngineSurface@@MAE_NXZ ENDP		; CEngineSurface::createPlat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z
_TEXT	SEGMENT
tv85 = -76						; size = 4
tv74 = -76						; size = 4
_top$ = -8						; size = 4
_this$ = -4						; size = 4
_panel$ = 8						; size = 4
?popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z PROC ; CEngineSurface::popMakeCurrent, COMDAT
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	flushBuffer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	call	eax

; 449  : 
; 450  : 	int top = staticPaintStackPos - 1;

	mov	eax, DWORD PTR ?staticPaintStackPos@@3HA
	sub	eax, 1
	mov	DWORD PTR _top$[ebp], eax

; 451  : 
; 452  : 	// more pops that pushes?
; 453  : 	Assert( top >= 0 );

	js	SHORT $LN4@popMakeCur
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN5@popMakeCur
$LN4@popMakeCur:
	mov	DWORD PTR tv74[ebp], 0
$LN5@popMakeCur:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z@4JA
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_08KNONEIAK@top?5?$DO?$DN?50@
	mov	ecx, DWORD PTR tv74[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 454  : 
; 455  : 	// didn't pop in reverse order of push?
; 456  : 	Assert( paintStack[top].m_pPanel == panel );

	imul	eax, DWORD PTR _top$[ebp], 28
	mov	ecx, DWORD PTR ?paintStack@@3PAUPaintStack@@A[eax]
	cmp	ecx, DWORD PTR _panel$[ebp]
	jne	SHORT $LN6@popMakeCur
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN7@popMakeCur
$LN6@popMakeCur:
	mov	DWORD PTR tv85[ebp], 0
$LN7@popMakeCur:
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z@4JA
	add	edx, 9
	push	edx
	push	OFFSET ??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CC@LLENABMC@paintStack?$FLtop?$FN?4m_pPanel?5?$DN?$DN?5pan@
	mov	eax, DWORD PTR tv85[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 457  : 
; 458  : 	staticPaintStackPos--;

	mov	eax, DWORD PTR ?staticPaintStackPos@@3HA
	sub	eax, 1
	mov	DWORD PTR ?staticPaintStackPos@@3HA, eax

; 459  : 
; 460  : 	if( top > 0 ) SetupPaintState( &paintStack[top-1] );

	cmp	DWORD PTR _top$[ebp], 0
	jle	SHORT $LN1@popMakeCur
	mov	eax, DWORD PTR _top$[ebp]
	sub	eax, 1
	imul	ecx, eax, 28
	add	ecx, OFFSET ?paintStack@@3PAUPaintStack@@A
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z ; CEngineSurface::SetupPaintState
$LN1@popMakeCur:

; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?popMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@@Z ENDP ; CEngineSurface::popMakeCurrent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z
_TEXT	SEGMENT
_paintState$ = -60					; size = 4
_clipRect$ = -56					; size = 16
_absExtents$ = -40					; size = 16
_insets$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_panel$ = 8						; size = 4
_useInsets$ = 12					; size = 1
?pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z PROC ; CEngineSurface::pushMakeCurrent, COMDAT
; _this$ = ecx

; 417  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 418  : 	int insets[4] = { 0, 0, 0, 0 };

	mov	DWORD PTR _insets$[ebp], 0
	mov	DWORD PTR _insets$[ebp+4], 0
	mov	DWORD PTR _insets$[ebp+8], 0
	mov	DWORD PTR _insets$[ebp+12], 0

; 419  : 	int absExtents[4];
; 420  : 	int clipRect[4];
; 421  : 
; 422  : 	if( useInsets )

	movzx	eax, BYTE PTR _useInsets$[ebp]
	test	eax, eax
	je	SHORT $LN2@pushMakeCu

; 423  : 		panel->getInset( insets[0], insets[1], insets[2], insets[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _insets$[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _insets$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR _insets$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _insets$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	eax, DWORD PTR [edx+228]
	call	eax
$LN2@pushMakeCu:

; 424  : 	panel->getAbsExtents( absExtents[0], absExtents[1], absExtents[2], absExtents[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _absExtents$[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _absExtents$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR _absExtents$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _absExtents$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 425  : 	panel->getClipRect( clipRect[0], clipRect[1], clipRect[2], clipRect[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _clipRect$[ebp+ecx]
	push	edx
	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _clipRect$[ebp+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR _clipRect$[ebp+edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _clipRect$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 426  : 
; 427  : 	PaintStack *paintState = &paintStack[staticPaintStackPos];

	imul	eax, DWORD PTR ?staticPaintStackPos@@3HA, 28
	add	eax, OFFSET ?paintStack@@3PAUPaintStack@@A
	mov	DWORD PTR _paintState$[ebp], eax

; 428  : 
; 429  : 	ASSERT( staticPaintStackPos < MAX_PAINT_STACK );

	cmp	DWORD PTR ?staticPaintStackPos@@3HA, 8
	jl	SHORT $LN3@pushMakeCu
	mov	eax, DWORD PTR ?__LINE__Var@?0??pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z@4JA
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DN@NAFAEAIP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN3@pushMakeCu:

; 430  : 
; 431  : 	paintState->m_pPanel = panel;

	mov	eax, DWORD PTR _paintState$[ebp]
	mov	ecx, DWORD PTR _panel$[ebp]
	mov	DWORD PTR [eax], ecx

; 432  : 
; 433  : 	// determine corrected top left origin
; 434  : 	paintState->iTranslateX = insets[0] + absExtents[0];	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _insets$[ebp+ecx]
	add	ecx, DWORD PTR _absExtents$[ebp+eax]
	mov	edx, DWORD PTR _paintState$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 435  : 	paintState->iTranslateY = insets[1] + absExtents[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _insets$[ebp+eax]
	add	edx, DWORD PTR _absExtents$[ebp+ecx]
	mov	eax, DWORD PTR _paintState$[ebp]
	mov	DWORD PTR [eax+8], edx

; 436  : 	// setup clipping rectangle for scissoring
; 437  : 	paintState->iScissorLeft = clipRect[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _paintState$[ebp]
	mov	eax, DWORD PTR _clipRect$[ebp+ecx]
	mov	DWORD PTR [edx+12], eax

; 438  : 	paintState->iScissorTop = clipRect[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR _clipRect$[ebp+eax]
	mov	DWORD PTR [ecx+20], edx

; 439  : 	paintState->iScissorRight = clipRect[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR _clipRect$[ebp+eax]
	mov	DWORD PTR [ecx+16], edx

; 440  : 	paintState->iScissorBottom = clipRect[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _paintState$[ebp]
	mov	eax, DWORD PTR _clipRect$[ebp+ecx]
	mov	DWORD PTR [edx+24], eax

; 441  : 
; 442  : 	SetupPaintState( paintState );

	mov	eax, DWORD PTR _paintState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z ; CEngineSurface::SetupPaintState

; 443  : 	staticPaintStackPos++;

	mov	eax, DWORD PTR ?staticPaintStackPos@@3HA
	add	eax, 1
	mov	DWORD PTR ?staticPaintStackPos@@3HA, eax

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?pushMakeCurrent@CEngineSurface@@MAEXPAVPanel@vgui@@_N@Z ENDP ; CEngineSurface::pushMakeCurrent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?setCursor@CEngineSurface@@MAEXPAVCursor@vgui@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cursor$ = 8						; size = 4
?setCursor@CEngineSurface@@MAEXPAVCursor@vgui@@@Z PROC	; CEngineSurface::setCursor, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 	_currentCursor = cursor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cursor$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 70   : 	VGUI_CursorSelect( cursor );

	mov	eax, DWORD PTR _cursor$[ebp]
	push	eax
	call	?VGUI_CursorSelect@@YAXPAVCursor@vgui@@@Z ; VGUI_CursorSelect
	add	esp, 4

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCursor@CEngineSurface@@MAEXPAVCursor@vgui@@@Z ENDP	; CEngineSurface::setCursor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?addCharToBuffer@CEngineSurface@@MAEXPBUvpoint_t@@0QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ul$ = 8						; size = 4
_lr$ = 12						; size = 4
_color$ = 16						; size = 4
?addCharToBuffer@CEngineSurface@@MAEXPBUvpoint_t@@0QAH@Z PROC ; CEngineSurface::addCharToBuffer, COMDAT
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	if( g_iVertexBufferEntriesUsed >= MAXVERTEXBUFFERS )

	cmp	DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 1024 ; 00000400H
	jl	SHORT $LN2@addCharToB

; 240  : 		flushBuffer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	call	eax
$LN2@addCharToB:

; 241  : 
; 242  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].coord[0] = ul->coord[0];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+eax+8], ecx

; 243  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].coord[1] = ul->coord[1];

	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[ecx+edx+8], eax

; 244  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].point[0] = ul->point[0];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+eax], ecx

; 245  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].point[1] = ul->point[1];

	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[ecx+edx], eax

; 246  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].color[0] = color[0];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	eax, 1
	imul	eax, eax, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+eax+16], cl

; 247  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].color[1] = color[1];

	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	edx, 1
	shl	edx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[ecx+edx+16], al

; 248  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].color[2] = color[2];

	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	edx, 1
	shl	edx, 1
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[ecx+edx+16], al

; 249  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 0].color[3] = 255 - color[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [edx+ecx]
	imul	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, 20
	mov	edx, 1
	imul	edx, edx, 3
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[ecx+edx+16], al

; 250  : 
; 251  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].coord[0] = lr->coord[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 1
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+8], ecx

; 252  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].coord[1] = ul->coord[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 1
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+8], eax

; 253  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].point[0] = lr->point[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 1
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx], ecx

; 254  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].point[1] = ul->point[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 1
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx], eax

; 255  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].color[0] = color[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 1
	imul	eax, edx, 20
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+16], cl

; 256  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].color[1] = color[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 1
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 257  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].color[2] = color[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 1
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 1
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 258  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 1].color[3] = 255 - color[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 1
	imul	edx, ecx, 20
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 259  : 
; 260  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].coord[0] = lr->coord[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 2
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+8], ecx

; 261  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].coord[1] = lr->coord[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 2
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+8], eax

; 262  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].point[0] = lr->point[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 2
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx], ecx

; 263  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].point[1] = lr->point[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 2
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx], eax

; 264  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].color[0] = color[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 2
	imul	eax, edx, 20
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+16], cl

; 265  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].color[1] = color[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 2
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 266  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].color[2] = color[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 2
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 1
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 267  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 2].color[3] = 255 - color[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 2
	imul	edx, ecx, 20
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 268  : 
; 269  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].coord[0] = ul->coord[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 3
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+8], ecx

; 270  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].coord[1] = lr->coord[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 3
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+8], eax

; 271  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].point[0] = ul->point[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 3
	imul	eax, edx, 20
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ul$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx], ecx

; 272  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].point[1] = lr->point[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 3
	imul	edx, ecx, 20
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lr$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx], eax

; 273  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].color[0] = color[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	edx, 3
	imul	eax, edx, 20
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[eax+edx+16], cl

; 274  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].color[1] = color[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 3
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 0
	mov	esi, DWORD PTR _color$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 275  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].color[2] = color[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 3
	imul	edx, ecx, 20
	mov	ecx, 1
	shl	ecx, 1
	mov	esi, DWORD PTR _color$[ebp]
	movzx	eax, BYTE PTR [esi+eax]
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 276  : 	g_VertexBuffer[g_iVertexBufferEntriesUsed + 3].color[3] = 255 - color[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	ecx, 3
	imul	edx, ecx, 20
	mov	ecx, 1
	imul	ecx, ecx, 3
	mov	BYTE PTR ?g_VertexBuffer@@3PAUvpoint_t@@A[edx+ecx+16], al

; 277  : 
; 278  : 	g_iVertexBufferEntriesUsed += 4;

	mov	eax, DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA
	add	eax, 4
	mov	DWORD PTR ?g_iVertexBufferEntriesUsed@@3HA, eax

; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?addCharToBuffer@CEngineSurface@@MAEXPBUvpoint_t@@0QAH@Z ENDP ; CEngineSurface::addCharToBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawPrintChar@CEngineSurface@@MAEXHHHHMMMMQAH@Z
_TEXT	SEGMENT
_clippedRect$ = -88					; size = 40
_lr$ = -48						; size = 20
_ul$ = -28						; size = 20
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_wide$ = 16						; size = 4
_tall$ = 20						; size = 4
_s0$ = 24						; size = 4
_t0$ = 28						; size = 4
_s1$ = 32						; size = 4
_t1$ = 36						; size = 4
_color$ = 40						; size = 4
?drawPrintChar@CEngineSurface@@MAEXHHHHMMMMQAH@Z PROC	; CEngineSurface::drawPrintChar, COMDAT
; _this$ = ecx

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 	vpoint_t	ul, lr;
; 293  : 
; 294  : 	ul.point[0] = x;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _ul$[ebp+ecx], xmm0

; 295  : 	ul.point[1] = y;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _ul$[ebp+eax], xmm0

; 296  : 	lr.point[0] = x + wide;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _wide$[ebp]
	cvtsi2ss xmm0, eax
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lr$[ebp+edx], xmm0

; 297  : 	lr.point[1] = y + tall;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _tall$[ebp]
	cvtsi2ss xmm0, eax
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _lr$[ebp+ecx], xmm0

; 298  : 
; 299  : 	// gets at the texture coords for this character in its texture page
; 300  : 	ul.coord[0] = s0;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _s0$[ebp]
	movss	DWORD PTR _ul$[ebp+ecx+8], xmm0

; 301  : 	ul.coord[1] = t0;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _t0$[ebp]
	movss	DWORD PTR _ul$[ebp+eax+8], xmm0

; 302  : 	lr.coord[0] = s1;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR _lr$[ebp+ecx+8], xmm0

; 303  : 	lr.coord[1] = t1;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _lr$[ebp+eax+8], xmm0

; 304  : 
; 305  : 	vpoint_t clippedRect[2];
; 306  : 
; 307  : 	if( !ClipRect( ul, lr, &clippedRect[0], &clippedRect[1] ))

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _lr$[ebp]
	push	edx
	lea	eax, DWORD PTR _ul$[ebp]
	push	eax
	call	_ClipRect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@drawPrintC

; 308  : 		return;

	jmp	SHORT $LN1@drawPrintC
$LN2@drawPrintC:

; 309  : #if 1
; 310  : 	// TESTTEST: needs to be more tested
; 311  : 	addCharToBuffer( &clippedRect[0], &clippedRect[1], color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	lea	edx, DWORD PTR _clippedRect$[ebp+ecx]
	push	edx
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _clippedRect$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	call	eax
$LN1@drawPrintC:

; 312  : #else                                        
; 313  : 	VGUI_SetupDrawingImage( color );
; 314  : 	VGUI_DrawQuad( &clippedRect[0], &clippedRect[1] ); // draw the letter
; 315  : #endif
; 316  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?drawPrintChar@CEngineSurface@@MAEXHHHHMMMMQAH@Z ENDP	; CEngineSurface::drawPrintChar
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawTexturedRect@CEngineSurface@@MAEXHHHH@Z
_TEXT	SEGMENT
_clippedRect$ = -88					; size = 40
_rect$ = -48						; size = 40
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?drawTexturedRect@CEngineSurface@@MAEXHHHH@Z PROC	; CEngineSurface::drawTexturedRect, COMDAT
; _this$ = ecx

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 401  : 	vpoint_t rect[2];
; 402  : 	vpoint_t clippedRect[2];
; 403  : 
; 404  : 	// it's not a vertex, just fill rectangle
; 405  : 	InitVertex( rect[0], x0, y0, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _rect$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ; CEngineSurface::InitVertex

; 406  : 	InitVertex( rect[1], x1, y1, 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ; CEngineSurface::InitVertex

; 407  : 
; 408  : 	// fully clipped?
; 409  : 	if( !ClipRect( rect[0], rect[1], &clippedRect[0], &clippedRect[1] ))

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	call	_ClipRect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@drawTextur

; 410  : 		return;	

	jmp	SHORT $LN1@drawTextur
$LN2@drawTextur:

; 411  : 
; 412  : 	VGUI_SetupDrawingImage( _drawColor );	

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	_VGUI_SetupDrawingImage
	add	esp, 4

; 413  : 	VGUI_DrawQuad( &clippedRect[0], &clippedRect[1] );

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	call	_VGUI_DrawQuad
	add	esp, 8
$LN1@drawTextur:

; 414  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawTexturedRect@CEngineSurface@@MAEXHHHH@Z ENDP	; CEngineSurface::drawTexturedRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetTexture@CEngineSurface@@MAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
?drawSetTexture@CEngineSurface@@MAEXH@Z PROC		; CEngineSurface::drawSetTexture, COMDAT
; _this$ = ecx

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 	if( _currentTexture != id )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR _id$[ebp]
	je	SHORT $LN2@drawSetTex

; 392  : 	{
; 393  : 		_currentTexture = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 394  : 		flushBuffer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	call	eax
$LN2@drawSetTex:

; 395  : 	}
; 396  : 	VGUI_BindTexture( id );

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_VGUI_BindTexture
	add	esp, 4

; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?drawSetTexture@CEngineSurface@@MAEXH@Z ENDP		; CEngineSurface::drawSetTexture
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetTextureRGBA@CEngineSurface@@MAEXHPBDHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_id$ = 8						; size = 4
_rgba$ = 12						; size = 4
_wide$ = 16						; size = 4
_tall$ = 20						; size = 4
?drawSetTextureRGBA@CEngineSurface@@MAEXHPBDHH@Z PROC	; CEngineSurface::drawSetTextureRGBA, COMDAT
; _this$ = ecx

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	VGUI_UploadTexture( id, rgba, wide, tall );

	mov	eax, DWORD PTR _tall$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wide$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rgba$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_VGUI_UploadTexture
	add	esp, 16					; 00000010H

; 386  : 	_currentTexture = id;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawSetTextureRGBA@CEngineSurface@@MAEXHPBDHH@Z ENDP	; CEngineSurface::drawSetTextureRGBA
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawPrintText@CEngineSurface@@MAEXPBDH@Z
_TEXT	SEGMENT
_wide$1 = -88						; size = 4
_t1$2 = -84						; size = 4
_s1$3 = -80						; size = 4
_t0$4 = -76						; size = 4
_s0$5 = -72						; size = 4
_curCh$6 = -68						; size = 4
_abcC$7 = -64						; size = 4
_abcB$8 = -60						; size = 4
_abcA$9 = -56						; size = 4
_i$10 = -52						; size = 4
_j$11 = -48						; size = 4
_j$12 = -44						; size = 4
_iTotalWidth$ = -40					; size = 4
_curTextColor$ = -36					; size = 16
_tall$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_textLen$ = 12						; size = 4
?drawPrintText@CEngineSurface@@MAEXPBDH@Z PROC		; CEngineSurface::drawPrintText, COMDAT
; _this$ = ecx

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 	static bool hasColor = 0;
; 321  : 	static int numColor = 7;
; 322  : 
; 323  : 	if( !COM_CheckString( text ) || !staticFont || !staticFontInfo )

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@drawPrintT
	cmp	DWORD PTR ?staticFont@@3PAVFont@vgui@@A, 0
	je	SHORT $LN12@drawPrintT
	cmp	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, 0
	jne	SHORT $LN11@drawPrintT
$LN12@drawPrintT:

; 324  : 		return;

	jmp	$LN1@drawPrintT
$LN11@drawPrintT:

; 325  : 
; 326  : 	int x = _drawTextPos[0] + _translateX;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR _x$[ebp], eax

; 327  : 	int y = _drawTextPos[1] + _translateY;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+36]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+80]
	mov	DWORD PTR _y$[ebp], edx

; 328  : 	int tall = staticFont->getTall();

	mov	eax, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _tall$[ebp], eax

; 329  : 	int curTextColor[4];
; 330  : 	int iTotalWidth = 0;

	mov	DWORD PTR _iTotalWidth$[ebp], 0

; 331  : 
; 332  : 	//  HACKHACK: allow color strings in VGUI
; 333  : 	if( numColor != 7 && vgui_colorstrings->value )

	cmp	DWORD PTR ?numColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4HA, 7
	je	SHORT $LN13@drawPrintT
	mov	eax, DWORD PTR _vgui_colorstrings
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@drawPrintT

; 334  : 	{
; 335  : 		for( int j = 0; j < 3; j++ ) // grab predefined color

	mov	DWORD PTR _j$12[ebp], 0
	jmp	SHORT $LN4@drawPrintT
$LN2@drawPrintT:
	mov	eax, DWORD PTR _j$12[ebp]
	add	eax, 1
	mov	DWORD PTR _j$12[ebp], eax
$LN4@drawPrintT:
	cmp	DWORD PTR _j$12[ebp], 3
	jge	SHORT $LN3@drawPrintT

; 336  : 			curTextColor[j] = g_color_table[numColor][j];

	mov	eax, DWORD PTR _j$12[ebp]
	mov	ecx, DWORD PTR ?numColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4HA
	movzx	edx, BYTE PTR _g_color_table[eax+ecx*4]
	mov	eax, DWORD PTR _j$12[ebp]
	mov	DWORD PTR _curTextColor$[ebp+eax*4], edx
	jmp	SHORT $LN2@drawPrintT
$LN3@drawPrintT:

; 337  :           }

	jmp	SHORT $LN6@drawPrintT
$LN13@drawPrintT:

; 338  :           else
; 339  :           {
; 340  : 		for( int j = 0; j < 3; j++ ) // revert default color

	mov	DWORD PTR _j$11[ebp], 0
	jmp	SHORT $LN7@drawPrintT
$LN5@drawPrintT:
	mov	eax, DWORD PTR _j$11[ebp]
	add	eax, 1
	mov	DWORD PTR _j$11[ebp], eax
$LN7@drawPrintT:
	cmp	DWORD PTR _j$11[ebp], 3
	jge	SHORT $LN6@drawPrintT

; 341  : 			curTextColor[j] = _drawTextColor[j];

	mov	eax, DWORD PTR _j$11[ebp]
	mov	ecx, DWORD PTR _j$11[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+60]
	mov	DWORD PTR _curTextColor$[ebp+eax*4], ecx
	jmp	SHORT $LN5@drawPrintT
$LN6@drawPrintT:

; 342  : 	}
; 343  : 	curTextColor[3] = _drawTextColor[3]; // copy alpha

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+60]
	mov	DWORD PTR _curTextColor$[ebp+eax], ecx

; 344  : 
; 345  : 	if( textLen == 1 && vgui_colorstrings->value )

	cmp	DWORD PTR _textLen$[ebp], 1
	jne	SHORT $LN19@drawPrintT
	mov	eax, DWORD PTR _vgui_colorstrings
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@drawPrintT

; 346  : 	{
; 347  : 		if( *text == '^' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN16@drawPrintT

; 348  : 		{
; 349  : 			hasColor = true;

	mov	BYTE PTR ?hasColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4_NA, 1

; 350  : 			return; // skip '^'

	jmp	$LN1@drawPrintT

; 351  : 		}

	jmp	SHORT $LN19@drawPrintT
$LN16@drawPrintT:

; 352  : 		else if( hasColor && isdigit( *text ))

	movzx	eax, BYTE PTR ?hasColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4_NA
	test	eax, eax
	je	SHORT $LN18@drawPrintT
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@drawPrintT

; 353  : 		{
; 354  : 			numColor = ColorIndex( *text );

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 48					; 00000030H
	and	ecx, 7
	mov	DWORD PTR ?numColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4HA, ecx

; 355  : 			hasColor = false; // handled

	mov	BYTE PTR ?hasColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4_NA, 0

; 356  : 			return; // skip colornum

	jmp	$LN1@drawPrintT

; 357  : 		}

	jmp	SHORT $LN19@drawPrintT
$LN18@drawPrintT:

; 358  : 		else hasColor = false;

	mov	BYTE PTR ?hasColor@?1??drawPrintText@CEngineSurface@@MAEXPBDH@Z@4_NA, 0
$LN19@drawPrintT:

; 359  : 	}
; 360  : 
; 361  : 	for( int i = 0; i < textLen; i++ )

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN10@drawPrintT
$LN8@drawPrintT:
	mov	eax, DWORD PTR _i$10[ebp]
	add	eax, 1
	mov	DWORD PTR _i$10[ebp], eax
$LN10@drawPrintT:
	mov	eax, DWORD PTR _i$10[ebp]
	cmp	eax, DWORD PTR _textLen$[ebp]
	jge	$LN9@drawPrintT

; 362  : 	{
; 363  : 		int abcA, abcB, abcC;
; 364  : 		int curCh = (byte)text[i];

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$10[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _curCh$6[ebp], ecx

; 365  : 
; 366  : 		staticFont->getCharABCwide( curCh, abcA, abcB, abcC );

	lea	eax, DWORD PTR _abcC$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _abcB$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _abcA$9[ebp]
	push	edx
	mov	eax, DWORD PTR _curCh$6[ebp]
	push	eax
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 367  : 
; 368  : 		float s0 = staticFontInfo->texCoord[curCh][0];

	mov	eax, DWORD PTR _curCh$6[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _s0$5[ebp], xmm0

; 369  : 		float t0 = staticFontInfo->texCoord[curCh][1];

	mov	eax, DWORD PTR _curCh$6[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _t0$4[ebp], xmm0

; 370  : 		float s1 = staticFontInfo->texCoord[curCh][2];

	mov	eax, DWORD PTR _curCh$6[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _s1$3[ebp], xmm0

; 371  : 		float t1 = staticFontInfo->texCoord[curCh][3];

	mov	eax, DWORD PTR _curCh$6[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _t1$2[ebp], xmm0

; 372  : 		int wide = abcB;

	mov	eax, DWORD PTR _abcB$8[ebp]
	mov	DWORD PTR _wide$1[ebp], eax

; 373  : 
; 374  : 		iTotalWidth += abcA;

	mov	eax, DWORD PTR _iTotalWidth$[ebp]
	add	eax, DWORD PTR _abcA$9[ebp]
	mov	DWORD PTR _iTotalWidth$[ebp], eax

; 375  : 		drawSetTexture( staticFontInfo->bindIndex[staticFontInfo->pageForChar[curCh]] );

	mov	eax, DWORD PTR _curCh$6[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	ecx, DWORD PTR [eax+edx*4+1032]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	call	edx

; 376  : 		drawPrintChar( x + iTotalWidth, y, wide, tall, s0, t0, s1, t1, curTextColor );

	lea	eax, DWORD PTR _curTextColor$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t1$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t0$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s0$5[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _tall$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wide$1[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _iTotalWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+136]
	call	edx

; 377  : 		iTotalWidth += wide + abcC;

	mov	eax, DWORD PTR _wide$1[ebp]
	add	eax, DWORD PTR _abcC$7[ebp]
	add	eax, DWORD PTR _iTotalWidth$[ebp]
	mov	DWORD PTR _iTotalWidth$[ebp], eax

; 378  : 	}

	jmp	$LN8@drawPrintT
$LN9@drawPrintT:

; 379  : 
; 380  : 	_drawTextPos[0] += iTotalWidth;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	add	eax, DWORD PTR _iTotalWidth$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+36], eax
$LN1@drawPrintT:

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?drawPrintText@CEngineSurface@@MAEXPBDH@Z ENDP		; CEngineSurface::drawPrintText
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetTextPos@CEngineSurface@@MAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?drawSetTextPos@CEngineSurface@@MAEXHH@Z PROC		; CEngineSurface::drawSetTextPos, COMDAT
; _this$ = ecx

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 	_drawTextPos[0] = x;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+36], eax

; 234  : 	_drawTextPos[1] = y;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx+eax+36], edx

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?drawSetTextPos@CEngineSurface@@MAEXHH@Z ENDP		; CEngineSurface::drawSetTextPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetTextFont@CEngineSurface@@MAEXPAVFont@vgui@@@Z
_TEXT	SEGMENT
$T1 = -116						; size = 4
_tall$2 = -48						; size = 4
_wide$3 = -44						; size = 4
_abcC$4 = -40						; size = 4
_abcB$5 = -36						; size = 4
_abcA$6 = -32						; size = 4
_i$7 = -28						; size = 4
_y$8 = -24						; size = 4
_x$9 = -20						; size = 4
_currentPage$10 = -16					; size = 4
_i$11 = -12						; size = 4
_buildFont$12 = -5					; size = 1
_this$ = -4						; size = 4
_font$ = 8						; size = 4
?drawSetTextFont@CEngineSurface@@MAEXPAVFont@vgui@@@Z PROC ; CEngineSurface::drawSetTextFont, COMDAT
; _this$ = ecx

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 	staticFont = font;

	mov	eax, DWORD PTR _font$[ebp]
	mov	DWORD PTR ?staticFont@@3PAVFont@vgui@@A, eax

; 143  : 
; 144  : 	if( font )

	cmp	DWORD PTR _font$[ebp], 0
	je	$LN11@drawSetTex

; 145  : 	{
; 146  : 		bool	buildFont = false;

	mov	BYTE PTR _buildFont$12[ebp], 0

; 147  : 
; 148  : 		staticFontInfo = NULL;

	mov	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, 0

; 149  : 
; 150  : 		for( int i = 0; i < staticFontInfoDar.getCount(); i++ )

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN4@drawSetTex
$LN2@drawSetTex:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN4@drawSetTex:
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	?getCount@?$Dar@PAUFontInfo@@@vgui@@QAEHXZ ; vgui::Dar<FontInfo *>::getCount
	cmp	DWORD PTR _i$11[ebp], eax
	jge	SHORT $LN3@drawSetTex

; 151  : 		{
; 152  : 			if( staticFontInfoDar[i]->id == font->getId( ))

	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z ; vgui::Dar<FontInfo *>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _font$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _font$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN10@drawSetTex

; 153  : 			{
; 154  : 				staticFontInfo = staticFontInfoDar[i];

	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	??A?$Dar@PAUFontInfo@@@vgui@@QAEPAUFontInfo@@H@Z ; vgui::Dar<FontInfo *>::operator[]
	mov	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, eax

; 155  : 				if( staticFontInfo->contextCount != staticContextCount )

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	ecx, DWORD PTR [eax+9256]
	cmp	ecx, DWORD PTR ?staticContextCount@@3HA
	je	SHORT $LN10@drawSetTex

; 156  : 					buildFont = true;

	mov	BYTE PTR _buildFont$12[ebp], 1
$LN10@drawSetTex:

; 157  : 			}
; 158  : 		}

	jmp	SHORT $LN2@drawSetTex
$LN3@drawSetTex:

; 159  : 
; 160  : 		if( !staticFontInfo || buildFont )

	cmp	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, 0
	je	SHORT $LN12@drawSetTex
	movzx	eax, BYTE PTR _buildFont$12[ebp]
	test	eax, eax
	je	$LN11@drawSetTex
$LN12@drawSetTex:

; 161  : 		{
; 162  : 			staticFontInfo = new FontInfo;

	push	9260					; 0000242cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, eax

; 163  : 			staticFontInfo->id = 0;

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [eax], 0

; 164  : 			staticFontInfo->pageCount = 0;

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [eax+4], 0

; 165  : 			staticFontInfo->bindIndex[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [edx+ecx+1032], 0

; 166  : 			staticFontInfo->bindIndex[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [ecx+eax+1032], 0

; 167  : 			staticFontInfo->bindIndex[2] = 0;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [ecx+eax+1032], 0

; 168  : 			staticFontInfo->bindIndex[3] = 0;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [edx+ecx+1032], 0

; 169  : 			memset( staticFontInfo->pageForChar, 0, sizeof( staticFontInfo->pageForChar ));

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	add	eax, 8
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 170  : 			staticFontInfo->contextCount = -1;

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [eax+9256], -1

; 171  : 			staticFontInfo->id = staticFont->getId();

	mov	eax, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [ecx], eax

; 172  : 			staticFontInfoDar.putElement( staticFontInfo );

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	push	eax
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	?putElement@?$Dar@PAUFontInfo@@@vgui@@QAEXPAUFontInfo@@@Z ; vgui::Dar<FontInfo *>::putElement

; 173  : 			staticFontInfo->contextCount = staticContextCount;

	mov	eax, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	ecx, DWORD PTR ?staticContextCount@@3HA
	mov	DWORD PTR [eax+9256], ecx

; 174  : 
; 175  : 			int currentPage = 0;

	mov	DWORD PTR _currentPage$10[ebp], 0

; 176  : 			int x = 0, y = 0;

	mov	DWORD PTR _x$9[ebp], 0
	mov	DWORD PTR _y$8[ebp], 0

; 177  : 
; 178  : 			memset( staticRGBA, 0, sizeof( staticRGBA ));

	push	1048576					; 00100000H
	push	0
	push	OFFSET ?staticRGBA@@3PADA
	call	_memset
	add	esp, 12					; 0000000cH

; 179  : 
; 180  : 			for( int i = 0; i < 256; i++ )

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN7@drawSetTex
$LN5@drawSetTex:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN7@drawSetTex:
	cmp	DWORD PTR _i$7[ebp], 256		; 00000100H
	jge	$LN6@drawSetTex

; 181  : 			{
; 182  : 				int abcA, abcB, abcC;
; 183  : 				staticFont->getCharABCwide( i, abcA, abcB, abcC );

	lea	eax, DWORD PTR _abcC$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _abcB$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _abcA$6[ebp]
	push	edx
	mov	eax, DWORD PTR _i$7[ebp]
	push	eax
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 184  : 
; 185  : 				int wide = abcB;

	mov	eax, DWORD PTR _abcB$5[ebp]
	mov	DWORD PTR _wide$3[ebp], eax

; 186  : 
; 187  : 				if( isspace( i )) continue;

	mov	eax, DWORD PTR _i$7[ebp]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@drawSetTex
	jmp	SHORT $LN5@drawSetTex
$LN13@drawSetTex:

; 188  : 
; 189  : 				int tall = staticFont->getTall();

	mov	eax, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _tall$2[ebp], eax

; 190  : 
; 191  : 				if( x + wide + 1 > FONT_SIZE )

	mov	eax, DWORD PTR _wide$3[ebp]
	mov	ecx, DWORD PTR _x$9[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	cmp	edx, 512				; 00000200H
	jle	SHORT $LN14@drawSetTex

; 192  : 				{
; 193  : 					x = 0;

	mov	DWORD PTR _x$9[ebp], 0

; 194  : 					y += tall + 1;

	mov	eax, DWORD PTR _tall$2[ebp]
	mov	ecx, DWORD PTR _y$8[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _y$8[ebp], edx
$LN14@drawSetTex:

; 195  : 				}
; 196  : 
; 197  : 				if( y + tall + 1 > FONT_SIZE )

	mov	eax, DWORD PTR _tall$2[ebp]
	mov	ecx, DWORD PTR _y$8[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	cmp	edx, 512				; 00000200H
	jle	$LN15@drawSetTex

; 198  : 				{
; 199  : 					if( !staticFontInfo->bindIndex[currentPage] )

	mov	eax, DWORD PTR _currentPage$10[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	cmp	DWORD PTR [ecx+eax*4+1032], 0
	jne	SHORT $LN16@drawSetTex

; 200  : 						staticFontInfo->bindIndex[currentPage] = createNewTextureID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	ecx, DWORD PTR _currentPage$10[ebp]
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [edx+ecx*4+1032], eax
$LN16@drawSetTex:

; 201  : 					drawSetTextureRGBA( staticFontInfo->bindIndex[currentPage], staticRGBA, FONT_SIZE, FONT_SIZE );

	push	512					; 00000200H
	push	512					; 00000200H
	push	OFFSET ?staticRGBA@@3PADA
	mov	eax, DWORD PTR _currentPage$10[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	edx, DWORD PTR [ecx+eax*4+1032]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 202  : 					currentPage++;

	mov	eax, DWORD PTR _currentPage$10[ebp]
	add	eax, 1
	mov	DWORD PTR _currentPage$10[ebp], eax

; 203  : 
; 204  : 					if( currentPage == FONT_PAGES )

	cmp	DWORD PTR _currentPage$10[ebp], 8
	jne	SHORT $LN17@drawSetTex

; 205  : 						break;

	jmp	$LN6@drawSetTex
$LN17@drawSetTex:

; 206  : 
; 207  : 					memset( staticRGBA, 0, sizeof( staticRGBA ));

	push	1048576					; 00100000H
	push	0
	push	OFFSET ?staticRGBA@@3PADA
	call	_memset
	add	esp, 12					; 0000000cH

; 208  : 					x = y = 0;

	mov	DWORD PTR _y$8[ebp], 0
	mov	eax, DWORD PTR _y$8[ebp]
	mov	DWORD PTR _x$9[ebp], eax
$LN15@drawSetTex:

; 209  : 				}
; 210  : 
; 211  : 				staticFont->getCharRGBA( i, x, y, FONT_SIZE, FONT_SIZE, (byte *)staticRGBA );

	push	OFFSET ?staticRGBA@@3PADA
	push	512					; 00000200H
	push	512					; 00000200H
	mov	eax, DWORD PTR _y$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$7[ebp]
	push	edx
	mov	eax, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?staticFont@@3PAVFont@vgui@@A
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 212  : 				staticFontInfo->pageForChar[i] = currentPage;

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	edx, DWORD PTR _currentPage$10[ebp]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 213  : 				staticFontInfo->texCoord[i][0] = (float)((double)x / (double)FONT_SIZE );

	cvtsi2sd xmm0, DWORD PTR _x$9[ebp]
	divsd	xmm0, QWORD PTR __real@4080000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _i$7[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0

; 214  : 				staticFontInfo->texCoord[i][1] = (float)((double)y / (double)FONT_SIZE );

	cvtsi2sd xmm0, DWORD PTR _y$8[ebp]
	divsd	xmm0, QWORD PTR __real@4080000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _i$7[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	edx, DWORD PTR [ecx+eax+1064]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 215  : 				staticFontInfo->texCoord[i][2] = (float)((double)(x + wide)/(double)FONT_SIZE );

	mov	eax, DWORD PTR _x$9[ebp]
	add	eax, DWORD PTR _wide$3[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@4080000000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _i$7[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	eax, DWORD PTR [edx+ecx+1064]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 216  : 				staticFontInfo->texCoord[i][3] = (float)((double)(y + tall)/(double)FONT_SIZE );

	mov	eax, DWORD PTR _y$8[ebp]
	add	eax, DWORD PTR _tall$2[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@4080000000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _i$7[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	lea	eax, DWORD PTR [edx+ecx+1064]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 217  : 				x += wide + 1;

	mov	eax, DWORD PTR _wide$3[ebp]
	mov	ecx, DWORD PTR _x$9[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _x$9[ebp], edx

; 218  : 			}

	jmp	$LN5@drawSetTex
$LN6@drawSetTex:

; 219  : 
; 220  : 			if( currentPage != FONT_PAGES )

	cmp	DWORD PTR _currentPage$10[ebp], 8
	je	SHORT $LN18@drawSetTex

; 221  : 			{
; 222  : 				if( !staticFontInfo->bindIndex[currentPage] )

	mov	eax, DWORD PTR _currentPage$10[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	cmp	DWORD PTR [ecx+eax*4+1032], 0
	jne	SHORT $LN19@drawSetTex

; 223  : 					staticFontInfo->bindIndex[currentPage] = createNewTextureID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	mov	ecx, DWORD PTR _currentPage$10[ebp]
	mov	edx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [edx+ecx*4+1032], eax
$LN19@drawSetTex:

; 224  : 				drawSetTextureRGBA( staticFontInfo->bindIndex[currentPage], staticRGBA, FONT_SIZE, FONT_SIZE );

	push	512					; 00000200H
	push	512					; 00000200H
	push	OFFSET ?staticRGBA@@3PADA
	mov	eax, DWORD PTR _currentPage$10[ebp]
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	edx, DWORD PTR [ecx+eax*4+1032]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	call	eax
$LN18@drawSetTex:

; 225  : 			}
; 226  : 			staticFontInfo->pageCount = currentPage + 1;

	mov	eax, DWORD PTR _currentPage$10[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A
	mov	DWORD PTR [ecx+4], eax
$LN11@drawSetTex:

; 227  : 		}
; 228  : 	}
; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?drawSetTextFont@CEngineSurface@@MAEXPAVFont@vgui@@@Z ENDP ; CEngineSurface::drawSetTextFont
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawOutlinedRect@CEngineSurface@@MAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?drawOutlinedRect@CEngineSurface@@MAEXHHHH@Z PROC	; CEngineSurface::drawOutlinedRect, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 	if( _drawColor[3] >= 255 ) return;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+44], 255		; 000000ffH
	jl	SHORT $LN2@drawOutlin
	jmp	$LN1@drawOutlin
$LN2@drawOutlin:

; 133  : 
; 134  : 	drawFilledRect( x0, y0, x1, y0 + 1 );		// top

	mov	eax, DWORD PTR _y0$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y0$[ebp]
	push	edx
	mov	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 135  : 	drawFilledRect( x0, y1 - 1, x1, y1 );		// bottom

	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 136  : 	drawFilledRect( x0, y0 + 1, x0 + 1, y1 - 1 );	// left

	mov	eax, DWORD PTR _y1$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _x0$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _y0$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax

; 137  : 	drawFilledRect( x1 - 1, y0 + 1, x1, y1 - 1 );	// right

	mov	eax, DWORD PTR _y1$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y0$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
$LN1@drawOutlin:

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawOutlinedRect@CEngineSurface@@MAEXHHHH@Z ENDP	; CEngineSurface::drawOutlinedRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawFilledRect@CEngineSurface@@MAEXHHHH@Z
_TEXT	SEGMENT
_clippedRect$ = -88					; size = 40
_rect$ = -48						; size = 40
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?drawFilledRect@CEngineSurface@@MAEXHHHH@Z PROC		; CEngineSurface::drawFilledRect, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 	vpoint_t rect[2];
; 113  : 	vpoint_t clippedRect[2];
; 114  : 
; 115  : 	if( _drawColor[3] >= 255 ) return;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx+44], 255		; 000000ffH
	jl	SHORT $LN2@drawFilled
	jmp	$LN1@drawFilled
$LN2@drawFilled:

; 116  : 
; 117  : 	InitVertex( rect[0], x0, y0, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _rect$[ebp+eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ; CEngineSurface::InitVertex

; 118  : 	InitVertex( rect[1], x1, y1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ; CEngineSurface::InitVertex

; 119  : 
; 120  : 	// fully clipped?
; 121  : 	if( !ClipRect( rect[0], rect[1], &clippedRect[0], &clippedRect[1] ))

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _rect$[ebp+edx]
	push	eax
	call	_ClipRect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN3@drawFilled

; 122  : 		return;	

	jmp	SHORT $LN1@drawFilled
$LN3@drawFilled:

; 123  : 
; 124  : 	VGUI_SetupDrawingRect( _drawColor );	

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	_VGUI_SetupDrawingRect
	add	esp, 4

; 125  : 	VGUI_EnableTexture( false );

	push	0
	call	_VGUI_EnableTexture
	add	esp, 4

; 126  : 	VGUI_DrawQuad( &clippedRect[0], &clippedRect[1] );

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _clippedRect$[ebp+eax]
	push	ecx
	call	_VGUI_DrawQuad
	add	esp, 8

; 127  : 	VGUI_EnableTexture( true );

	push	1
	call	_VGUI_EnableTexture
	add	esp, 4
$LN1@drawFilled:

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawFilledRect@CEngineSurface@@MAEXHHHH@Z ENDP		; CEngineSurface::drawFilledRect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetTextColor@CEngineSurface@@MAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?drawSetTextColor@CEngineSurface@@MAEXHHHH@Z PROC	; CEngineSurface::drawSetTextColor, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	_drawTextColor[0] = r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+ecx+60], eax

; 105  : 	_drawTextColor[1] = g;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+eax+60], edx

; 106  : 	_drawTextColor[2] = b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+eax+60], edx

; 107  : 	_drawTextColor[3] = a;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+ecx+60], eax

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawSetTextColor@CEngineSurface@@MAEXHHHH@Z ENDP	; CEngineSurface::drawSetTextColor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?drawSetColor@CEngineSurface@@MAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?drawSetColor@CEngineSurface@@MAEXHHHH@Z PROC		; CEngineSurface::drawSetColor, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	_drawColor[0] = r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx+ecx+44], eax

; 97   : 	_drawColor[1] = g;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR [ecx+eax+44], edx

; 98   : 	_drawColor[2] = b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+eax+44], edx

; 99   : 	_drawColor[3] = a;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [edx+ecx+44], eax

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?drawSetColor@CEngineSurface@@MAEXHHHH@Z ENDP		; CEngineSurface::drawSetColor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?createNewTextureID@CEngineSurface@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?createNewTextureID@CEngineSurface@@MAEHXZ PROC		; CEngineSurface::createNewTextureID, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return VGUI_GenerateTexture();

	call	_VGUI_GenerateTexture

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?createNewTextureID@CEngineSurface@@MAEHXZ ENDP		; CEngineSurface::createNewTextureID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?hasFocus@CEngineSurface@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?hasFocus@CEngineSurface@@UAE_NXZ PROC			; CEngineSurface::hasFocus, COMDAT
; _this$ = ecx

; 60   : 	virtual bool hasFocus( void ) { return true; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?hasFocus@CEngineSurface@@UAE_NXZ ENDP			; CEngineSurface::hasFocus
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_paintState$ = 8					; size = 4
?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z PROC ; CEngineSurface::SetupPaintState, COMDAT
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	_translateX = paintState->iTranslateX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+76], edx

; 76   : 	_translateY = paintState->iTranslateY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+80], edx

; 77   : 	SetScissorRect( paintState->iScissorLeft, paintState->iScissorTop, paintState->iScissorRight, paintState->iScissorBottom );

	mov	eax, DWORD PTR _paintState$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _paintState$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _paintState$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_SetScissorRect
	add	esp, 16					; 00000010H

; 78   : 	currentPanel = paintState->m_pPanel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _paintState$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+88], edx

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetupPaintState@CEngineSurface@@QAEXPBUPaintStack@@@Z ENDP ; CEngineSurface::SetupPaintState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?isWithin@CEngineSurface@@UAE_NHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?isWithin@CEngineSurface@@UAE_NHH@Z PROC		; CEngineSurface::isWithin, COMDAT
; _this$ = ecx

; 55   : 	virtual bool isWithin( int x, int y ) { return true; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?isWithin@CEngineSurface@@UAE_NHH@Z ENDP		; CEngineSurface::isWithin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?createPopup@CEngineSurface@@UAEXPAVPanel@vgui@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_embeddedPanel$ = 8					; size = 4
?createPopup@CEngineSurface@@UAEXPAVPanel@vgui@@@Z PROC	; CEngineSurface::createPopup, COMDAT
; _this$ = ecx

; 54   : 	virtual void createPopup( Panel* embeddedPanel ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?createPopup@CEngineSurface@@UAEXPAVPanel@vgui@@@Z ENDP	; CEngineSurface::createPopup
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?setTitle@CEngineSurface@@UAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_title$ = 8						; size = 4
?setTitle@CEngineSurface@@UAEXPBD@Z PROC		; CEngineSurface::setTitle, COMDAT
; _this$ = ecx

; 53   : 	virtual void setTitle( const char *title ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setTitle@CEngineSurface@@UAEXPBD@Z ENDP		; CEngineSurface::setTitle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?setWindowedMode@CEngineSurface@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setWindowedMode@CEngineSurface@@UAEXXZ PROC		; CEngineSurface::setWindowedMode, COMDAT
; _this$ = ecx

; 52   : 	virtual void setWindowedMode( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setWindowedMode@CEngineSurface@@UAEXXZ ENDP		; CEngineSurface::setWindowedMode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_main.h
;	COMDAT ?setFullscreenMode@CEngineSurface@@UAE_NHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wide$ = 8						; size = 4
_tall$ = 12						; size = 4
_bpp$ = 16						; size = 4
?setFullscreenMode@CEngineSurface@@UAE_NHHH@Z PROC	; CEngineSurface::setFullscreenMode, COMDAT
; _this$ = ecx

; 51   : 	virtual bool setFullscreenMode( int wide, int tall, int bpp ) { return false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setFullscreenMode@CEngineSurface@@UAE_NHHH@Z ENDP	; CEngineSurface::setFullscreenMode
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ??1CEngineSurface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CEngineSurface@@QAE@XZ PROC				; CEngineSurface::~CEngineSurface, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CEngineSurface@@6B@

; 64   : 	VGUI_DrawShutdown ();

	call	_VGUI_DrawShutdown

; 65   : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceBase@vgui@@IAE@XZ		; vgui::SurfaceBase::~SurfaceBase
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CEngineSurface@@QAE@XZ ENDP				; CEngineSurface::~CEngineSurface
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_embeddedPanel$ = 8					; size = 4
??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z PROC		; CEngineSurface::CEngineSurface, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 47   : CEngineSurface :: CEngineSurface( Panel *embeddedPanel ):SurfaceBase( embeddedPanel )

	mov	eax, DWORD PTR _embeddedPanel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SurfaceBase@vgui@@QAE@PAVPanel@1@@Z	; vgui::SurfaceBase::SurfaceBase
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 48   : {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CEngineSurface@@6B@

; 49   : 	_drawTextColor[0] = _drawTextColor[1] = _drawTextColor[2] = _drawTextColor[3] = 255;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+60], 255		; 000000ffH
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+60], 255		; 000000ffH
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+60], 255		; 000000ffH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+60], 255		; 000000ffH

; 50   : 	_drawColor[0] = _drawColor[1] = _drawColor[2] = _drawColor[3] = 255;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+44], 255		; 000000ffH
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+44], 255		; 000000ffH
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+44], 255		; 000000ffH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+44], 255		; 000000ffH

; 51   : 	_drawTextPos[0] = _drawTextPos[1] = _currentTexture = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+36], 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+36], 0

; 52   : 
; 53   : 	staticFont = NULL;

	mov	DWORD PTR ?staticFont@@3PAVFont@vgui@@A, 0

; 54   : 	staticFontInfo = NULL;

	mov	DWORD PTR ?staticFontInfo@@3PAUFontInfo@@A, 0

; 55   : 	staticFontInfoDar.setCount( 0 );

	push	0
	mov	ecx, OFFSET ?staticFontInfoDar@@3V?$Dar@PAUFontInfo@@@vgui@@A
	call	?setCount@?$Dar@PAUFontInfo@@@vgui@@QAEXH@Z ; vgui::Dar<FontInfo *>::setCount

; 56   : 	staticPaintStackPos = 0;

	mov	DWORD PTR ?staticPaintStackPos@@3HA, 0

; 57   : 	staticContextCount++;

	mov	eax, DWORD PTR ?staticContextCount@@3HA
	add	eax, 1
	mov	DWORD PTR ?staticContextCount@@3HA, eax

; 58   : 
; 59   : 	VGUI_InitCursors ();

	call	?VGUI_InitCursors@@YAXXZ		; VGUI_InitCursors

; 60   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SurfaceBase@vgui@@IAE@XZ		; vgui::SurfaceBase::~SurfaceBase
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CEngineSurface@@QAE@PAVPanel@vgui@@@Z ENDP		; CEngineSurface::CEngineSurface
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\vgui\vgui_surf.cpp
;	COMDAT ?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vertex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_u$ = 20						; size = 4
_v$ = 24						; size = 4
?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z PROC ; CEngineSurface::InitVertex, COMDAT
; _this$ = ecx

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 	vertex.point[0] = x + _translateX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR [eax+76]
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _vertex$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 84   : 	vertex.point[1] = y + _translateY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR [eax+80]
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _vertex$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 85   : 	vertex.coord[0] = u;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vertex$[ebp]
	movss	xmm0, DWORD PTR _u$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 86   : 	vertex.coord[1] = v;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vertex$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR [ecx+eax+8], xmm0

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?InitVertex@CEngineSurface@@AAEXAAUvpoint_t@@HHMM@Z ENDP ; CEngineSurface::InitVertex
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4InputSignal@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InputSignal@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::InputSignal::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4InputSignal@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::InputSignal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4InputSignal@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InputSignal@vgui@@QAEAAV01@ABV01@@Z PROC		; vgui::InputSignal::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4InputSignal@vgui@@QAEAAV01@ABV01@@Z ENDP		; vgui::InputSignal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0InputSignal@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InputSignal@vgui@@QAE@$$QAV01@@Z PROC		; vgui::InputSignal::InputSignal, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7InputSignal@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0InputSignal@vgui@@QAE@$$QAV01@@Z ENDP		; vgui::InputSignal::InputSignal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0InputSignal@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InputSignal@vgui@@QAE@ABV01@@Z PROC			; vgui::InputSignal::InputSignal, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7InputSignal@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0InputSignal@vgui@@QAE@ABV01@@Z ENDP			; vgui::InputSignal::InputSignal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0InputSignal@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0InputSignal@vgui@@QAE@XZ PROC			; vgui::InputSignal::InputSignal, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7InputSignal@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0InputSignal@vgui@@QAE@XZ ENDP			; vgui::InputSignal::InputSignal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4SurfaceBase@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SurfaceBase@vgui@@QAEAAV01@ABV01@@Z PROC		; vgui::SurfaceBase::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4SurfaceBase@vgui@@QAEAAV01@ABV01@@Z ENDP		; vgui::SurfaceBase::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0SurfaceBase@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0SurfaceBase@vgui@@QAE@ABV01@@Z PROC			; vgui::SurfaceBase::SurfaceBase, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SurfaceBase@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0SurfaceBase@vgui@@QAE@ABV01@@Z ENDP			; vgui::SurfaceBase::SurfaceBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Panel@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_$S40$1 = -28						; size = 4
_$S39$2 = -24						; size = 4
_$S38$3 = -20						; size = 4
_$S37$4 = -16						; size = 4
_$S36$5 = -12						; size = 4
_$S35$6 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Panel@vgui@@QAEAAV01@$$QAV01@@Z PROC			; vgui::Panel::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S35$6[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S35$6[ebp]
	add	eax, 1
	mov	DWORD PTR _$S35$6[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S35$6[ebp], 2
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _$S35$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S35$6[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S36$5[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S36$5[ebp]
	add	eax, 1
	mov	DWORD PTR _$S36$5[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S36$5[ebp], 2
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _$S36$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S36$5[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+12]
	mov	DWORD PTR [ecx+eax*4+12], edx
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S37$4[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S37$4[ebp]
	add	eax, 1
	mov	DWORD PTR _$S37$4[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S37$4[ebp], 2
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _$S37$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S37$4[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+20]
	mov	DWORD PTR [ecx+eax*4+20], edx
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	DWORD PTR _$S38$3[ebp], 0
	jmp	SHORT $LN13@operator
$LN11@operator:
	mov	eax, DWORD PTR _$S38$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S38$3[ebp], eax
$LN13@operator:
	cmp	DWORD PTR _$S38$3[ebp], 2
	jae	SHORT $LN12@operator
	mov	eax, DWORD PTR _$S38$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S38$3[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+28]
	mov	DWORD PTR [ecx+eax*4+28], edx
	jmp	SHORT $LN11@operator
$LN12@operator:
	mov	DWORD PTR _$S39$2[ebp], 0
	jmp	SHORT $LN16@operator
$LN14@operator:
	mov	eax, DWORD PTR _$S39$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S39$2[ebp], eax
$LN16@operator:
	cmp	DWORD PTR _$S39$2[ebp], 2
	jae	SHORT $LN15@operator
	mov	eax, DWORD PTR _$S39$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S39$2[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+36]
	mov	DWORD PTR [ecx+eax*4+36], edx
	jmp	SHORT $LN14@operator
$LN15@operator:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR _$S40$1[ebp], 0
	jmp	SHORT $LN19@operator
$LN17@operator:
	mov	eax, DWORD PTR _$S40$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S40$1[ebp], eax
$LN19@operator:
	cmp	DWORD PTR _$S40$1[ebp], 4
	jae	SHORT $LN18@operator
	mov	eax, DWORD PTR _$S40$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S40$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+88]
	mov	DWORD PTR [ecx+eax*4+88], edx
	jmp	SHORT $LN17@operator
$LN18@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+112]
	mov	BYTE PTR [eax+112], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+140], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+144], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+148]
	mov	BYTE PTR [eax+148], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+149]
	mov	BYTE PTR [eax+149], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+152], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??4Color@vgui@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??4Color@vgui@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+180], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+184]
	mov	BYTE PTR [eax+184], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+185]
	mov	BYTE PTR [eax+185], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+186]
	mov	BYTE PTR [eax+186], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Panel@vgui@@QAEAAV01@$$QAV01@@Z ENDP			; vgui::Panel::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Panel@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_$S34$1 = -28						; size = 4
_$S33$2 = -24						; size = 4
_$S32$3 = -20						; size = 4
_$S31$4 = -16						; size = 4
_$S30$5 = -12						; size = 4
_$S29$6 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Panel@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Panel::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S29$6[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S29$6[ebp]
	add	eax, 1
	mov	DWORD PTR _$S29$6[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S29$6[ebp], 2
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _$S29$6[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S29$6[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S30$5[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S30$5[ebp]
	add	eax, 1
	mov	DWORD PTR _$S30$5[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S30$5[ebp], 2
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _$S30$5[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S30$5[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+12]
	mov	DWORD PTR [ecx+eax*4+12], edx
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S31$4[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S31$4[ebp]
	add	eax, 1
	mov	DWORD PTR _$S31$4[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S31$4[ebp], 2
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _$S31$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S31$4[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+20]
	mov	DWORD PTR [ecx+eax*4+20], edx
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	DWORD PTR _$S32$3[ebp], 0
	jmp	SHORT $LN13@operator
$LN11@operator:
	mov	eax, DWORD PTR _$S32$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S32$3[ebp], eax
$LN13@operator:
	cmp	DWORD PTR _$S32$3[ebp], 2
	jae	SHORT $LN12@operator
	mov	eax, DWORD PTR _$S32$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S32$3[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+28]
	mov	DWORD PTR [ecx+eax*4+28], edx
	jmp	SHORT $LN11@operator
$LN12@operator:
	mov	DWORD PTR _$S33$2[ebp], 0
	jmp	SHORT $LN16@operator
$LN14@operator:
	mov	eax, DWORD PTR _$S33$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S33$2[ebp], eax
$LN16@operator:
	cmp	DWORD PTR _$S33$2[ebp], 2
	jae	SHORT $LN15@operator
	mov	eax, DWORD PTR _$S33$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S33$2[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+36]
	mov	DWORD PTR [ecx+eax*4+36], edx
	jmp	SHORT $LN14@operator
$LN15@operator:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR _$S34$1[ebp], 0
	jmp	SHORT $LN19@operator
$LN17@operator:
	mov	eax, DWORD PTR _$S34$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S34$1[ebp], eax
$LN19@operator:
	cmp	DWORD PTR _$S34$1[ebp], 4
	jae	SHORT $LN18@operator
	mov	eax, DWORD PTR _$S34$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S34$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+88]
	mov	DWORD PTR [ecx+eax*4+88], edx
	jmp	SHORT $LN17@operator
$LN18@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+112]
	mov	BYTE PTR [eax+112], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+140], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+144], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+148]
	mov	BYTE PTR [eax+148], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+149]
	mov	BYTE PTR [eax+149], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+152], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??4Color@vgui@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??4Color@vgui@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+180], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+184]
	mov	BYTE PTR [eax+184], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+185]
	mov	BYTE PTR [eax+185], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+186]
	mov	BYTE PTR [eax+186], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Panel@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Panel::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Panel@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Panel@vgui@@QAE@$$QAV01@@Z PROC			; vgui::Panel::Panel, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Panel@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR [eax+40], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+112]
	mov	BYTE PTR [eax+112], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+140], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+144], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+148]
	mov	BYTE PTR [eax+148], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+149]
	mov	BYTE PTR [eax+149], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+152], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??0Color@vgui@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??0Color@vgui@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+180], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+184]
	mov	BYTE PTR [eax+184], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+185]
	mov	BYTE PTR [eax+185], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+186]
	mov	BYTE PTR [eax+186], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Panel@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::Panel::Panel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Panel@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Panel@vgui@@QAE@ABV01@@Z PROC			; vgui::Panel::Panel, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Panel@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+28], edx
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR [eax+40], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+112]
	mov	BYTE PTR [eax+112], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+120]
	mov	BYTE PTR [eax+120], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax+124], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+140], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+144], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+148]
	mov	BYTE PTR [eax+148], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+149]
	mov	BYTE PTR [eax+149], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+152], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 156				; 0000009cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??0Color@vgui@@QAE@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??0Color@vgui@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+180], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+184]
	mov	BYTE PTR [eax+184], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+185]
	mov	BYTE PTR [eax+185], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+186]
	mov	BYTE PTR [eax+186], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Panel@vgui@@QAE@ABV01@@Z ENDP			; vgui::Panel::Panel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Color@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_$S28$1 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Color@vgui@@QAEAAV01@$$QAV01@@Z PROC			; vgui::Color::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S28$1[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S28$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S28$1[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S28$1[ebp], 4
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S28$1[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S28$1[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Color@vgui@@QAEAAV01@$$QAV01@@Z ENDP			; vgui::Color::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Color@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_$S27$1 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Color@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Color::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S27$1[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S27$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S27$1[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S27$1[ebp], 4
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S27$1[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S27$1[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Color@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Color::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Color@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Color@vgui@@QAE@$$QAV01@@Z PROC			; vgui::Color::Color, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Color@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Color@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::Color::Color
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Color@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Color@vgui@@QAE@ABV01@@Z PROC			; vgui::Color::Color, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Color@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Color@vgui@@QAE@ABV01@@Z ENDP			; vgui::Color::Color
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Scheme@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_$S26$1 = -16						; size = 4
_$S25$2 = -12						; size = 4
_$S24$3 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Scheme@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::Scheme::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S24$3[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S24$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S24$3[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S24$3[ebp], 36		; 00000024H
	jae	SHORT $LN3@operator
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ___that$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	ecx, DWORD PTR _$S24$3[ebp]
	mov	esi, DWORD PTR _$S24$3[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S25$2[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S25$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S25$2[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S25$2[ebp], 5
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _$S25$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S25$2[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+148]
	mov	DWORD PTR [ecx+eax*4+148], edx
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S26$1[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S26$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S26$1[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S26$1[ebp], 14		; 0000000eH
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _$S26$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S26$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+168]
	mov	DWORD PTR [ecx+eax*4+168], edx
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Scheme@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::Scheme::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Scheme@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_$S23$1 = -16						; size = 4
_$S22$2 = -12						; size = 4
_$S21$3 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Scheme@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Scheme::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S21$3[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S21$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S21$3[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S21$3[ebp], 36		; 00000024H
	jae	SHORT $LN3@operator
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ___that$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	ecx, DWORD PTR _$S21$3[ebp]
	mov	esi, DWORD PTR _$S21$3[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S22$2[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S22$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S22$2[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S22$2[ebp], 5
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _$S22$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S22$2[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+148]
	mov	DWORD PTR [ecx+eax*4+148], edx
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S23$1[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S23$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S23$1[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S23$1[ebp], 14		; 0000000eH
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _$S23$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S23$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+168]
	mov	DWORD PTR [ecx+eax*4+168], edx
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Scheme@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Scheme::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Scheme@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Scheme@vgui@@QAE@$$QAV01@@Z PROC			; vgui::Scheme::Scheme, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Scheme@vgui@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4
	mov	ecx, 36					; 00000024H
	rep movsd
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 148				; 00000094H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 168				; 000000a8H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 168				; 000000a8H
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Scheme@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::Scheme::Scheme
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Scheme@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Scheme@vgui@@QAE@ABV01@@Z PROC			; vgui::Scheme::Scheme, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Scheme@vgui@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4
	mov	ecx, 36					; 00000024H
	rep movsd
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 148				; 00000094H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 168				; 000000a8H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 168				; 000000a8H
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Scheme@vgui@@QAE@ABV01@@Z ENDP			; vgui::Scheme::Scheme
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Font@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Font@vgui@@QAEAAV01@$$QAV01@@Z PROC			; vgui::Font::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Font@vgui@@QAEAAV01@$$QAV01@@Z ENDP			; vgui::Font::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Font@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Font@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Font::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Font@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Font::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Font@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Font@vgui@@QAE@$$QAV01@@Z PROC			; vgui::Font::Font, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Font@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Font@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::Font::Font
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Font@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Font@vgui@@QAE@ABV01@@Z PROC				; vgui::Font::Font, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Font@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Font@vgui@@QAE@ABV01@@Z ENDP				; vgui::Font::Font
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4App@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_$S20$1 = -40						; size = 4
_$S19$2 = -36						; size = 4
_$S18$3 = -32						; size = 4
_$S17$4 = -28						; size = 4
_$S16$5 = -24						; size = 4
_$S15$6 = -20						; size = 4
_$S14$7 = -16						; size = 4
_$S13$8 = -12						; size = 4
_$S12$9 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4App@vgui@@QAEAAV01@$$QAV01@@Z PROC			; vgui::App::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR _$S12$9[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S12$9[ebp]
	add	eax, 1
	mov	DWORD PTR _$S12$9[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S12$9[ebp], 3
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S12$9[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S12$9[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+40], dl
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S13$8[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S13$8[ebp]
	add	eax, 1
	mov	DWORD PTR _$S13$8[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S13$8[ebp], 3
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S13$8[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S13$8[ebp]
	mov	dl, BYTE PTR [ecx+43]
	mov	BYTE PTR [eax+43], dl
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S14$7[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S14$7[ebp]
	add	eax, 1
	mov	DWORD PTR _$S14$7[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S14$7[ebp], 3
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S14$7[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S14$7[ebp]
	mov	dl, BYTE PTR [ecx+46]
	mov	BYTE PTR [eax+46], dl
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	DWORD PTR _$S15$6[ebp], 0
	jmp	SHORT $LN13@operator
$LN11@operator:
	mov	eax, DWORD PTR _$S15$6[ebp]
	add	eax, 1
	mov	DWORD PTR _$S15$6[ebp], eax
$LN13@operator:
	cmp	DWORD PTR _$S15$6[ebp], 3
	jae	SHORT $LN12@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S15$6[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S15$6[ebp]
	mov	dl, BYTE PTR [ecx+49]
	mov	BYTE PTR [eax+49], dl
	jmp	SHORT $LN11@operator
$LN12@operator:
	mov	DWORD PTR _$S16$5[ebp], 0
	jmp	SHORT $LN16@operator
$LN14@operator:
	mov	eax, DWORD PTR _$S16$5[ebp]
	add	eax, 1
	mov	DWORD PTR _$S16$5[ebp], eax
$LN16@operator:
	cmp	DWORD PTR _$S16$5[ebp], 103		; 00000067H
	jae	SHORT $LN15@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S16$5[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S16$5[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax+52], dl
	jmp	SHORT $LN14@operator
$LN15@operator:
	mov	DWORD PTR _$S17$4[ebp], 0
	jmp	SHORT $LN19@operator
$LN17@operator:
	mov	eax, DWORD PTR _$S17$4[ebp]
	add	eax, 1
	mov	DWORD PTR _$S17$4[ebp], eax
$LN19@operator:
	cmp	DWORD PTR _$S17$4[ebp], 103		; 00000067H
	jae	SHORT $LN18@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S17$4[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S17$4[ebp]
	mov	dl, BYTE PTR [ecx+155]
	mov	BYTE PTR [eax+155], dl
	jmp	SHORT $LN17@operator
$LN18@operator:
	mov	DWORD PTR _$S18$3[ebp], 0
	jmp	SHORT $LN22@operator
$LN20@operator:
	mov	eax, DWORD PTR _$S18$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S18$3[ebp], eax
$LN22@operator:
	cmp	DWORD PTR _$S18$3[ebp], 103		; 00000067H
	jae	SHORT $LN21@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S18$3[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S18$3[ebp]
	mov	dl, BYTE PTR [ecx+258]
	mov	BYTE PTR [eax+258], dl
	jmp	SHORT $LN20@operator
$LN21@operator:
	mov	DWORD PTR _$S19$2[ebp], 0
	jmp	SHORT $LN25@operator
$LN23@operator:
	mov	eax, DWORD PTR _$S19$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S19$2[ebp], eax
$LN25@operator:
	cmp	DWORD PTR _$S19$2[ebp], 103		; 00000067H
	jae	SHORT $LN24@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S19$2[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S19$2[ebp]
	mov	dl, BYTE PTR [ecx+361]
	mov	BYTE PTR [eax+361], dl
	jmp	SHORT $LN23@operator
$LN24@operator:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 464				; 000001d0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	DWORD PTR [eax+476], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+480]
	mov	BYTE PTR [eax+480], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+481]
	mov	BYTE PTR [eax+481], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	DWORD PTR [eax+484], edx
	mov	DWORD PTR _$S20$1[ebp], 0
	jmp	SHORT $LN28@operator
$LN26@operator:
	mov	eax, DWORD PTR _$S20$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S20$1[ebp], eax
$LN28@operator:
	cmp	DWORD PTR _$S20$1[ebp], 14		; 0000000eH
	jae	SHORT $LN27@operator
	mov	eax, DWORD PTR _$S20$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S20$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+488]
	mov	DWORD PTR [ecx+eax*4+488], edx
	jmp	SHORT $LN26@operator
$LN27@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+544]
	mov	DWORD PTR [eax+544], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	mov	DWORD PTR [eax+548], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	mov	DWORD PTR [eax+552], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4App@vgui@@QAEAAV01@$$QAV01@@Z ENDP			; vgui::App::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4App@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_$S11$1 = -40						; size = 4
_$S10$2 = -36						; size = 4
_$S9$3 = -32						; size = 4
_$S8$4 = -28						; size = 4
_$S7$5 = -24						; size = 4
_$S6$6 = -20						; size = 4
_$S5$7 = -16						; size = 4
_$S4$8 = -12						; size = 4
_$S3$9 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4App@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::App::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR _$S3$9[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S3$9[ebp]
	add	eax, 1
	mov	DWORD PTR _$S3$9[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S3$9[ebp], 3
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S3$9[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S3$9[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+40], dl
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	DWORD PTR _$S4$8[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR _$S4$8[ebp]
	add	eax, 1
	mov	DWORD PTR _$S4$8[ebp], eax
$LN7@operator:
	cmp	DWORD PTR _$S4$8[ebp], 3
	jae	SHORT $LN6@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S4$8[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S4$8[ebp]
	mov	dl, BYTE PTR [ecx+43]
	mov	BYTE PTR [eax+43], dl
	jmp	SHORT $LN5@operator
$LN6@operator:
	mov	DWORD PTR _$S5$7[ebp], 0
	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	eax, DWORD PTR _$S5$7[ebp]
	add	eax, 1
	mov	DWORD PTR _$S5$7[ebp], eax
$LN10@operator:
	cmp	DWORD PTR _$S5$7[ebp], 3
	jae	SHORT $LN9@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S5$7[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S5$7[ebp]
	mov	dl, BYTE PTR [ecx+46]
	mov	BYTE PTR [eax+46], dl
	jmp	SHORT $LN8@operator
$LN9@operator:
	mov	DWORD PTR _$S6$6[ebp], 0
	jmp	SHORT $LN13@operator
$LN11@operator:
	mov	eax, DWORD PTR _$S6$6[ebp]
	add	eax, 1
	mov	DWORD PTR _$S6$6[ebp], eax
$LN13@operator:
	cmp	DWORD PTR _$S6$6[ebp], 3
	jae	SHORT $LN12@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S6$6[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S6$6[ebp]
	mov	dl, BYTE PTR [ecx+49]
	mov	BYTE PTR [eax+49], dl
	jmp	SHORT $LN11@operator
$LN12@operator:
	mov	DWORD PTR _$S7$5[ebp], 0
	jmp	SHORT $LN16@operator
$LN14@operator:
	mov	eax, DWORD PTR _$S7$5[ebp]
	add	eax, 1
	mov	DWORD PTR _$S7$5[ebp], eax
$LN16@operator:
	cmp	DWORD PTR _$S7$5[ebp], 103		; 00000067H
	jae	SHORT $LN15@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S7$5[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S7$5[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax+52], dl
	jmp	SHORT $LN14@operator
$LN15@operator:
	mov	DWORD PTR _$S8$4[ebp], 0
	jmp	SHORT $LN19@operator
$LN17@operator:
	mov	eax, DWORD PTR _$S8$4[ebp]
	add	eax, 1
	mov	DWORD PTR _$S8$4[ebp], eax
$LN19@operator:
	cmp	DWORD PTR _$S8$4[ebp], 103		; 00000067H
	jae	SHORT $LN18@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S8$4[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S8$4[ebp]
	mov	dl, BYTE PTR [ecx+155]
	mov	BYTE PTR [eax+155], dl
	jmp	SHORT $LN17@operator
$LN18@operator:
	mov	DWORD PTR _$S9$3[ebp], 0
	jmp	SHORT $LN22@operator
$LN20@operator:
	mov	eax, DWORD PTR _$S9$3[ebp]
	add	eax, 1
	mov	DWORD PTR _$S9$3[ebp], eax
$LN22@operator:
	cmp	DWORD PTR _$S9$3[ebp], 103		; 00000067H
	jae	SHORT $LN21@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S9$3[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S9$3[ebp]
	mov	dl, BYTE PTR [ecx+258]
	mov	BYTE PTR [eax+258], dl
	jmp	SHORT $LN20@operator
$LN21@operator:
	mov	DWORD PTR _$S10$2[ebp], 0
	jmp	SHORT $LN25@operator
$LN23@operator:
	mov	eax, DWORD PTR _$S10$2[ebp]
	add	eax, 1
	mov	DWORD PTR _$S10$2[ebp], eax
$LN25@operator:
	cmp	DWORD PTR _$S10$2[ebp], 103		; 00000067H
	jae	SHORT $LN24@operator
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S10$2[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S10$2[ebp]
	mov	dl, BYTE PTR [ecx+361]
	mov	BYTE PTR [eax+361], dl
	jmp	SHORT $LN23@operator
$LN24@operator:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 464				; 000001d0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	DWORD PTR [eax+476], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+480]
	mov	BYTE PTR [eax+480], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+481]
	mov	BYTE PTR [eax+481], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	DWORD PTR [eax+484], edx
	mov	DWORD PTR _$S11$1[ebp], 0
	jmp	SHORT $LN28@operator
$LN26@operator:
	mov	eax, DWORD PTR _$S11$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S11$1[ebp], eax
$LN28@operator:
	cmp	DWORD PTR _$S11$1[ebp], 14		; 0000000eH
	jae	SHORT $LN27@operator
	mov	eax, DWORD PTR _$S11$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S11$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+488]
	mov	DWORD PTR [ecx+eax*4+488], edx
	jmp	SHORT $LN26@operator
$LN27@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+544]
	mov	DWORD PTR [eax+544], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	mov	DWORD PTR [eax+548], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	mov	DWORD PTR [eax+552], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4App@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::App::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0App@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0App@vgui@@QAE@$$QAV01@@Z PROC			; vgui::App::App, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7App@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 43					; 0000002bH
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 46					; 0000002eH
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 49					; 00000031H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 52					; 00000034H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 52					; 00000034H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 155				; 0000009bH
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 155				; 0000009bH
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 258				; 00000102H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 258				; 00000102H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 361				; 00000169H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 361				; 00000169H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 464				; 000001d0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	DWORD PTR [eax+476], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+480]
	mov	BYTE PTR [eax+480], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+481]
	mov	BYTE PTR [eax+481], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	DWORD PTR [eax+484], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 488				; 000001e8H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 488				; 000001e8H
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+544]
	mov	DWORD PTR [eax+544], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	mov	DWORD PTR [eax+548], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	mov	DWORD PTR [eax+552], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0App@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::App::App
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0App@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0App@vgui@@QAE@ABV01@@Z PROC				; vgui::App::App, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7App@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 43					; 0000002bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 43					; 0000002bH
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 46					; 0000002eH
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 49					; 00000031H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	movzx	eax, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 52					; 00000034H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 52					; 00000034H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 155				; 0000009bH
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 155				; 0000009bH
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 258				; 00000102H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 258				; 00000102H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 361				; 00000169H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 361				; 00000169H
	mov	ecx, 25					; 00000019H
	rep movsd
	movsw
	movsb
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 464				; 000001d0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+476]
	mov	DWORD PTR [eax+476], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+480]
	mov	BYTE PTR [eax+480], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+481]
	mov	BYTE PTR [eax+481], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+484]
	mov	DWORD PTR [eax+484], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 488				; 000001e8H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 488				; 000001e8H
	mov	ecx, 14					; 0000000eH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+544]
	mov	DWORD PTR [eax+544], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	mov	DWORD PTR [eax+548], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	mov	DWORD PTR [eax+552], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0App@vgui@@QAE@ABV01@@Z ENDP				; vgui::App::App
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Cursor@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_$S2$1 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Cursor@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::Cursor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S2$1[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S2$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S2$1[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S2$1[ebp], 2
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _$S2$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S2$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Cursor@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::Cursor::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4Cursor@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_$S1$1 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Cursor@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Cursor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S1$1[ebp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR _$S1$1[ebp]
	add	eax, 1
	mov	DWORD PTR _$S1$1[ebp], eax
$LN4@operator:
	cmp	DWORD PTR _$S1$1[ebp], 2
	jae	SHORT $LN3@operator
	mov	eax, DWORD PTR _$S1$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S1$1[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	jmp	SHORT $LN2@operator
$LN3@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4Cursor@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Cursor::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Cursor@vgui@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Cursor@vgui@@QAE@$$QAV01@@Z PROC			; vgui::Cursor::Cursor, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Cursor@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Cursor@vgui@@QAE@$$QAV01@@Z ENDP			; vgui::Cursor::Cursor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0Cursor@vgui@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Cursor@vgui@@QAE@ABV01@@Z PROC			; vgui::Cursor::Cursor, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Cursor@vgui@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Cursor@vgui@@QAE@ABV01@@Z ENDP			; vgui::Cursor::Cursor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEPAVRepaintSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEPAVRepaintSignal@1@H@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEPAVRepaintSignal@1@H@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::RepaintSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::RepaintSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@H@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE_NPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ; vgui::Dar<vgui::RepaintSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE_NPAVRepaintSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE_NPAVRepaintSignal@2@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE_NPAVRepaintSignal@2@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXPAVRepaintSignal@2@@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEHXZ PROC ; vgui::Dar<vgui::RepaintSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEHXZ ENDP ; vgui::Dar<vgui::RepaintSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::RepaintSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVRepaintSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::RepaintSignal *>::Dar<vgui::RepaintSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC	; vgui::Dar<vgui::Label *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP	; vgui::Dar<vgui::Label *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<vgui::Label *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVLabel@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<vgui::Label *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVLabel@vgui@@@vgui@@QAEPAVLabel@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVLabel@vgui@@@vgui@@QAEPAVLabel@1@H@Z PROC	; vgui::Dar<vgui::Label *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVLabel@vgui@@@vgui@@QAEPAVLabel@1@H@Z ENDP	; vgui::Dar<vgui::Label *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVLabel@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVLabel@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::Label *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVLabel@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::Label *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z PROC ; vgui::Dar<vgui::Label *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ENDP ; vgui::Dar<vgui::Label *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Label *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Label *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z PROC ; vgui::Dar<vgui::Label *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z ENDP ; vgui::Dar<vgui::Label *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z PROC ; vgui::Dar<vgui::Label *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@H@Z ENDP ; vgui::Dar<vgui::Label *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z PROC ; vgui::Dar<vgui::Label *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVLabel@vgui@@@vgui@@QAE_NPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ; vgui::Dar<vgui::Label *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ENDP ; vgui::Dar<vgui::Label *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVLabel@vgui@@@vgui@@QAE_NPAVLabel@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVLabel@vgui@@@vgui@@QAE_NPAVLabel@2@@Z PROC ; vgui::Dar<vgui::Label *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVLabel@vgui@@@vgui@@QAE_NPAVLabel@2@@Z ENDP ; vgui::Dar<vgui::Label *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z PROC ; vgui::Dar<vgui::Label *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVLabel@vgui@@@vgui@@QAEXPAVLabel@2@@Z ENDP ; vgui::Dar<vgui::Label *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::Label *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::Label *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::Label *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::Label *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Label *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Label *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@H@Z PROC		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@H@Z ENDP		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVLabel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Label *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVLabel@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::Label *>::Dar<vgui::Label *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC	; vgui::Dar<vgui::Panel *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP	; vgui::Dar<vgui::Panel *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<vgui::Panel *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVPanel@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<vgui::Panel *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVPanel@vgui@@@vgui@@QAEPAVPanel@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVPanel@vgui@@@vgui@@QAEPAVPanel@1@H@Z PROC	; vgui::Dar<vgui::Panel *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVPanel@vgui@@@vgui@@QAEPAVPanel@1@H@Z ENDP	; vgui::Dar<vgui::Panel *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVPanel@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVPanel@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::Panel *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVPanel@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::Panel *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z PROC ; vgui::Dar<vgui::Panel *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ENDP ; vgui::Dar<vgui::Panel *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Panel *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Panel *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z PROC ; vgui::Dar<vgui::Panel *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z ENDP ; vgui::Dar<vgui::Panel *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z PROC ; vgui::Dar<vgui::Panel *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@H@Z ENDP ; vgui::Dar<vgui::Panel *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z PROC ; vgui::Dar<vgui::Panel *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVPanel@vgui@@@vgui@@QAE_NPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ; vgui::Dar<vgui::Panel *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ENDP ; vgui::Dar<vgui::Panel *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVPanel@vgui@@@vgui@@QAE_NPAVPanel@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVPanel@vgui@@@vgui@@QAE_NPAVPanel@2@@Z PROC ; vgui::Dar<vgui::Panel *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVPanel@vgui@@@vgui@@QAE_NPAVPanel@2@@Z ENDP ; vgui::Dar<vgui::Panel *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z PROC ; vgui::Dar<vgui::Panel *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVPanel@vgui@@@vgui@@QAEXPAVPanel@2@@Z ENDP ; vgui::Dar<vgui::Panel *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::Panel *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::Panel *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::Panel *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::Panel *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Panel *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Panel *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@H@Z PROC		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@H@Z ENDP		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVPanel@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Panel *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVPanel@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::Panel *>::Dar<vgui::Panel *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEPAVChangeSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEPAVChangeSignal@1@H@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEPAVChangeSignal@1@H@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::ChangeSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::ChangeSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE_NPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ; vgui::Dar<vgui::ChangeSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE_NPAVChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE_NPAVChangeSignal@2@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE_NPAVChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXPAVChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEHXZ PROC ; vgui::Dar<vgui::ChangeSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEHXZ ENDP ; vgui::Dar<vgui::ChangeSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ChangeSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVChangeSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::ChangeSignal *>::Dar<vgui::ChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEPAVDesktopIcon@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEPAVDesktopIcon@1@H@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEPAVDesktopIcon@1@H@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::DesktopIcon *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::DesktopIcon *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@H@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE_NPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ; vgui::Dar<vgui::DesktopIcon *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE_NPAVDesktopIcon@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE_NPAVDesktopIcon@2@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE_NPAVDesktopIcon@2@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXPAVDesktopIcon@2@@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::DesktopIcon *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::DesktopIcon *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::DesktopIcon *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVDesktopIcon@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::DesktopIcon *>::Dar<vgui::DesktopIcon *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC	; vgui::Dar<vgui::Frame *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP	; vgui::Dar<vgui::Frame *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<vgui::Frame *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFrame@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<vgui::Frame *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVFrame@vgui@@@vgui@@QAEPAVFrame@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVFrame@vgui@@@vgui@@QAEPAVFrame@1@H@Z PROC	; vgui::Dar<vgui::Frame *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVFrame@vgui@@@vgui@@QAEPAVFrame@1@H@Z ENDP	; vgui::Dar<vgui::Frame *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVFrame@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVFrame@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::Frame *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVFrame@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::Frame *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z PROC ; vgui::Dar<vgui::Frame *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ENDP ; vgui::Dar<vgui::Frame *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Frame *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Frame *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z PROC ; vgui::Dar<vgui::Frame *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z ENDP ; vgui::Dar<vgui::Frame *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z PROC ; vgui::Dar<vgui::Frame *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@H@Z ENDP ; vgui::Dar<vgui::Frame *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z PROC ; vgui::Dar<vgui::Frame *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVFrame@vgui@@@vgui@@QAE_NPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ; vgui::Dar<vgui::Frame *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ENDP ; vgui::Dar<vgui::Frame *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVFrame@vgui@@@vgui@@QAE_NPAVFrame@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVFrame@vgui@@@vgui@@QAE_NPAVFrame@2@@Z PROC ; vgui::Dar<vgui::Frame *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVFrame@vgui@@@vgui@@QAE_NPAVFrame@2@@Z ENDP ; vgui::Dar<vgui::Frame *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z PROC ; vgui::Dar<vgui::Frame *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVFrame@vgui@@@vgui@@QAEXPAVFrame@2@@Z ENDP ; vgui::Dar<vgui::Frame *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::Frame *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::Frame *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::Frame *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::Frame *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Frame *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Frame *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@H@Z PROC		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@H@Z ENDP		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrame@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Frame *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVFrame@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::Frame *>::Dar<vgui::Frame *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::Dar<char> *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<vgui::Dar<char> *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<vgui::Dar<char> *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEPAV?$Dar@D@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEPAV?$Dar@D@1@H@Z PROC ; vgui::Dar<vgui::Dar<char> *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEPAV?$Dar@D@1@H@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::Dar<char> *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::Dar<char> *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z PROC ; vgui::Dar<vgui::Dar<char> *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Dar<char> *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z PROC ; vgui::Dar<vgui::Dar<char> *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z PROC ; vgui::Dar<vgui::Dar<char> *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@H@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z PROC ; vgui::Dar<vgui::Dar<char> *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE_NPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ; vgui::Dar<vgui::Dar<char> *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE_NPAV?$Dar@D@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE_NPAV?$Dar@D@2@@Z PROC ; vgui::Dar<vgui::Dar<char> *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE_NPAV?$Dar@D@2@@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z PROC ; vgui::Dar<vgui::Dar<char> *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXPAV?$Dar@D@2@@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::Dar<char> *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::Dar<char> *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::Dar<char> *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::Dar<char> *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@H@Z PROC		; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@H@Z ENDP		; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Dar<char> *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAV?$Dar@D@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::Dar<char> *>::Dar<vgui::Dar<char> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::TickSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::TickSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVTickSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVTickSignal@vgui@@@vgui@@QAEPAVTickSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVTickSignal@vgui@@@vgui@@QAEPAVTickSignal@1@H@Z PROC ; vgui::Dar<vgui::TickSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVTickSignal@vgui@@@vgui@@QAEPAVTickSignal@1@H@Z ENDP ; vgui::Dar<vgui::TickSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::TickSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::TickSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z PROC ; vgui::Dar<vgui::TickSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::TickSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::TickSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z PROC ; vgui::Dar<vgui::TickSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z ENDP ; vgui::Dar<vgui::TickSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z PROC ; vgui::Dar<vgui::TickSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@H@Z ENDP ; vgui::Dar<vgui::TickSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z PROC ; vgui::Dar<vgui::TickSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAE_NPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ; vgui::Dar<vgui::TickSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAE_NPAVTickSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAE_NPAVTickSignal@2@@Z PROC ; vgui::Dar<vgui::TickSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAE_NPAVTickSignal@2@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z PROC ; vgui::Dar<vgui::TickSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXPAVTickSignal@2@@Z ENDP ; vgui::Dar<vgui::TickSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::TickSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::TickSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::TickSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::TickSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::TickSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::TickSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVTickSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::TickSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVTickSignal@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::TickSignal *>::Dar<vgui::TickSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEPAVIntChangeSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEPAVIntChangeSignal@1@H@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEPAVIntChangeSignal@1@H@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::IntChangeSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::IntChangeSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE_NPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ; vgui::Dar<vgui::IntChangeSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE_NPAVIntChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE_NPAVIntChangeSignal@2@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE_NPAVIntChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXPAVIntChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEHXZ PROC ; vgui::Dar<vgui::IntChangeSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEHXZ ENDP ; vgui::Dar<vgui::IntChangeSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::IntChangeSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVIntChangeSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::IntChangeSignal *>::Dar<vgui::IntChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVActionSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVActionSignal@vgui@@@vgui@@QAEPAVActionSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVActionSignal@vgui@@@vgui@@QAEPAVActionSignal@1@H@Z PROC ; vgui::Dar<vgui::ActionSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVActionSignal@vgui@@@vgui@@QAEPAVActionSignal@1@H@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::ActionSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::ActionSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ActionSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z PROC ; vgui::Dar<vgui::ActionSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z PROC ; vgui::Dar<vgui::ActionSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@H@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAE_NPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ; vgui::Dar<vgui::ActionSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAE_NPAVActionSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAE_NPAVActionSignal@2@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAE_NPAVActionSignal@2@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z PROC ; vgui::Dar<vgui::ActionSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXPAVActionSignal@2@@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEHXZ PROC ; vgui::Dar<vgui::ActionSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEHXZ ENDP ; vgui::Dar<vgui::ActionSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ActionSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVActionSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::ActionSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVActionSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::ActionSignal *>::Dar<vgui::ActionSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEPAVFrameSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEPAVFrameSignal@1@H@Z PROC ; vgui::Dar<vgui::FrameSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEPAVFrameSignal@1@H@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::FrameSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::FrameSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FrameSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z PROC ; vgui::Dar<vgui::FrameSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z PROC ; vgui::Dar<vgui::FrameSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@H@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE_NPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ; vgui::Dar<vgui::FrameSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE_NPAVFrameSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE_NPAVFrameSignal@2@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE_NPAVFrameSignal@2@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z PROC ; vgui::Dar<vgui::FrameSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXPAVFrameSignal@2@@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::FrameSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::FrameSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FrameSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFrameSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FrameSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVFrameSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::FrameSignal *>::Dar<vgui::FrameSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEPAVFocusChangeSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEPAVFocusChangeSignal@1@H@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEPAVFocusChangeSignal@1@H@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::FocusChangeSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@H@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE_NPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ; vgui::Dar<vgui::FocusChangeSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE_NPAVFocusChangeSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE_NPAVFocusChangeSignal@2@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE_NPAVFocusChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXPAVFocusChangeSignal@2@@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEHXZ PROC ; vgui::Dar<vgui::FocusChangeSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEHXZ ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::FocusChangeSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVFocusChangeSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::FocusChangeSignal *>::Dar<vgui::FocusChangeSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::InputSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::InputSignal *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVInputSignal@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVInputSignal@vgui@@@vgui@@QAEPAVInputSignal@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVInputSignal@vgui@@@vgui@@QAEPAVInputSignal@1@H@Z PROC ; vgui::Dar<vgui::InputSignal *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVInputSignal@vgui@@@vgui@@QAEPAVInputSignal@1@H@Z ENDP ; vgui::Dar<vgui::InputSignal *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::InputSignal *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::InputSignal *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z PROC ; vgui::Dar<vgui::InputSignal *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::InputSignal *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::InputSignal *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z PROC ; vgui::Dar<vgui::InputSignal *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z ENDP ; vgui::Dar<vgui::InputSignal *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z PROC ; vgui::Dar<vgui::InputSignal *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@H@Z ENDP ; vgui::Dar<vgui::InputSignal *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z PROC ; vgui::Dar<vgui::InputSignal *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAE_NPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ; vgui::Dar<vgui::InputSignal *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAE_NPAVInputSignal@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAE_NPAVInputSignal@2@@Z PROC ; vgui::Dar<vgui::InputSignal *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAE_NPAVInputSignal@2@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z PROC ; vgui::Dar<vgui::InputSignal *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXPAVInputSignal@2@@Z ENDP ; vgui::Dar<vgui::InputSignal *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::InputSignal *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::InputSignal *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::InputSignal *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::InputSignal *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::InputSignal *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::InputSignal *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVInputSignal@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::InputSignal *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVInputSignal@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::InputSignal *>::Dar<vgui::InputSignal *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEPAVSurfaceBase@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEPAVSurfaceBase@1@H@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEPAVSurfaceBase@1@H@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXXZ PROC ; vgui::Dar<vgui::SurfaceBase *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXXZ ENDP ; vgui::Dar<vgui::SurfaceBase *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@H@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE_NPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ; vgui::Dar<vgui::SurfaceBase *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE_NPAVSurfaceBase@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE_NPAVSurfaceBase@2@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE_NPAVSurfaceBase@2@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXPAVSurfaceBase@2@@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::SurfaceBase *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::SurfaceBase *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@H@Z PROC	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@H@Z ENDP	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@XZ PROC	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::SurfaceBase *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVSurfaceBase@vgui@@@vgui@@QAE@XZ ENDP	; vgui::Dar<vgui::SurfaceBase *>::Dar<vgui::SurfaceBase *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z PROC ; vgui::Dar<vgui::Button *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@$$QAV01@@Z ENDP ; vgui::Dar<vgui::Button *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@ABV01@@Z PROC	; vgui::Dar<vgui::Button *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAVButton@vgui@@@vgui@@QAEAAV01@ABV01@@Z ENDP	; vgui::Dar<vgui::Button *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAVButton@vgui@@@vgui@@QAEPAVButton@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAVButton@vgui@@@vgui@@QAEPAVButton@1@H@Z PROC	; vgui::Dar<vgui::Button *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAVButton@vgui@@@vgui@@QAEPAVButton@1@H@Z ENDP	; vgui::Dar<vgui::Button *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAVButton@vgui@@@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAVButton@vgui@@@vgui@@QAEXXZ PROC	; vgui::Dar<vgui::Button *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAVButton@vgui@@@vgui@@QAEXXZ ENDP	; vgui::Dar<vgui::Button *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z PROC ; vgui::Dar<vgui::Button *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ENDP ; vgui::Dar<vgui::Button *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Button *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Button *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z PROC ; vgui::Dar<vgui::Button *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z ENDP ; vgui::Dar<vgui::Button *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z PROC ; vgui::Dar<vgui::Button *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@H@Z ENDP ; vgui::Dar<vgui::Button *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z PROC ; vgui::Dar<vgui::Button *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAVButton@vgui@@@vgui@@QAE_NPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ; vgui::Dar<vgui::Button *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ENDP ; vgui::Dar<vgui::Button *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAVButton@vgui@@@vgui@@QAE_NPAVButton@2@@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAVButton@vgui@@@vgui@@QAE_NPAVButton@2@@Z PROC ; vgui::Dar<vgui::Button *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAVButton@vgui@@@vgui@@QAE_NPAVButton@2@@Z ENDP ; vgui::Dar<vgui::Button *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z PROC ; vgui::Dar<vgui::Button *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAVButton@vgui@@@vgui@@QAEXPAVButton@2@@Z ENDP ; vgui::Dar<vgui::Button *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAVButton@vgui@@@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAVButton@vgui@@@vgui@@QAEHXZ PROC	; vgui::Dar<vgui::Button *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAVButton@vgui@@@vgui@@QAEHXZ ENDP	; vgui::Dar<vgui::Button *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z PROC	; vgui::Dar<vgui::Button *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ENDP	; vgui::Dar<vgui::Button *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z PROC ; vgui::Dar<vgui::Button *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ENDP ; vgui::Dar<vgui::Button *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVButton@vgui@@@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAVButton@vgui@@@vgui@@QAE@H@Z PROC		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAVButton@vgui@@@vgui@@QAE@H@Z ENDP		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAVButton@vgui@@@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAVButton@vgui@@@vgui@@QAE@XZ PROC		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAVButton@vgui@@@vgui@@QAEXH@Z ; vgui::Dar<vgui::Button *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAVButton@vgui@@@vgui@@QAE@XZ ENDP		; vgui::Dar<vgui::Button *>::Dar<vgui::Button *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@H@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@H@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::Dar<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@H@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::Dar<int>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@H@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@H@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Dar<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@H@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Dar<int>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@H@vgui@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@H@vgui@@QAEHH@Z PROC				; vgui::Dar<int>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@H@vgui@@QAEHH@Z ENDP				; vgui::Dar<int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@H@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@H@vgui@@QAEXXZ PROC			; vgui::Dar<int>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@H@vgui@@QAEXXZ ENDP			; vgui::Dar<int>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@H@vgui@@QAEXH@Z PROC		; vgui::Dar<int>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@H@vgui@@QAEXH@Z ENDP		; vgui::Dar<int>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@H@vgui@@QAEXH@Z PROC		; vgui::Dar<int>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@H@vgui@@QAEXH@Z ENDP		; vgui::Dar<int>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@H@vgui@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@H@vgui@@QAEXHH@Z PROC		; vgui::Dar<int>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@H@vgui@@QAEXHH@Z ENDP		; vgui::Dar<int>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@H@vgui@@QAEXHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@H@vgui@@QAEXHH@Z PROC		; vgui::Dar<int>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@H@vgui@@QAEXHH@Z ENDP		; vgui::Dar<int>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@H@vgui@@QAEXH@Z PROC			; vgui::Dar<int>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@H@vgui@@QAE_NH@Z	; vgui::Dar<int>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@H@vgui@@QAEXH@Z ENDP			; vgui::Dar<int>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@H@vgui@@QAE_NH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@H@vgui@@QAE_NH@Z PROC			; vgui::Dar<int>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@H@vgui@@QAE_NH@Z ENDP			; vgui::Dar<int>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@H@vgui@@QAEXH@Z PROC			; vgui::Dar<int>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@H@vgui@@QAEXH@Z ENDP			; vgui::Dar<int>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@H@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@H@vgui@@QAEHXZ PROC			; vgui::Dar<int>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@H@vgui@@QAEHXZ ENDP			; vgui::Dar<int>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@H@vgui@@QAEXH@Z PROC			; vgui::Dar<int>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@H@vgui@@QAEXH@Z ENDP			; vgui::Dar<int>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z PROC		; vgui::Dar<int>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z ENDP		; vgui::Dar<int>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@H@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@H@vgui@@QAE@H@Z PROC				; vgui::Dar<int>::Dar<int>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@H@vgui@@QAE@H@Z ENDP				; vgui::Dar<int>::Dar<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@H@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@H@vgui@@QAE@XZ PROC				; vgui::Dar<int>::Dar<int>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@H@vgui@@QAEXH@Z	; vgui::Dar<int>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@H@vgui@@QAE@XZ ENDP				; vgui::Dar<int>::Dar<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAD@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAD@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::Dar<char *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAD@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::Dar<char *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@PAD@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@PAD@vgui@@QAEAAV01@ABV01@@Z PROC		; vgui::Dar<char *>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@PAD@vgui@@QAEAAV01@ABV01@@Z ENDP		; vgui::Dar<char *>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@PAD@vgui@@QAEPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@PAD@vgui@@QAEPADH@Z PROC			; vgui::Dar<char *>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	eax, eax
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@PAD@vgui@@QAEPADH@Z ENDP			; vgui::Dar<char *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@PAD@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@PAD@vgui@@QAEXXZ PROC			; vgui::Dar<char *>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@PAD@vgui@@QAEXXZ ENDP			; vgui::Dar<char *>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@PAD@vgui@@QAEXPAD@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?removeElement@?$Dar@PAD@vgui@@QAEXPAD@Z PROC		; vgui::Dar<char *>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@PAD@vgui@@QAEXH@Z ; vgui::Dar<char *>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@PAD@vgui@@QAEXPAD@Z ENDP		; vgui::Dar<char *>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@PAD@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@PAD@vgui@@QAEXH@Z PROC		; vgui::Dar<char *>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@PAD@vgui@@QAEXH@Z ENDP		; vgui::Dar<char *>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?setElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z PROC		; vgui::Dar<char *>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z ENDP		; vgui::Dar<char *>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
_index$ = 12						; size = 4
?insertElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z PROC	; vgui::Dar<char *>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z	; vgui::Dar<char *>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z	; vgui::Dar<char *>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@PAD@vgui@@QAEXPADH@Z ENDP	; vgui::Dar<char *>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@PAD@vgui@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?putElement@?$Dar@PAD@vgui@@QAEXPAD@Z PROC		; vgui::Dar<char *>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@PAD@vgui@@QAE_NPAD@Z	; vgui::Dar<char *>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z	; vgui::Dar<char *>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@PAD@vgui@@QAEXPAD@Z ENDP		; vgui::Dar<char *>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@PAD@vgui@@QAE_NPAD@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?hasElement@?$Dar@PAD@vgui@@QAE_NPAD@Z PROC		; vgui::Dar<char *>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _elem$[ebp]
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@PAD@vgui@@QAE_NPAD@Z ENDP		; vgui::Dar<char *>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 4
?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z PROC		; vgui::Dar<char *>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z	; vgui::Dar<char *>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _elem$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@PAD@vgui@@QAEXPAD@Z ENDP		; vgui::Dar<char *>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@PAD@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@PAD@vgui@@QAEHXZ PROC			; vgui::Dar<char *>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@PAD@vgui@@QAEHXZ ENDP			; vgui::Dar<char *>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@PAD@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@PAD@vgui@@QAEXH@Z PROC			; vgui::Dar<char *>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@PAD@vgui@@QAEXH@Z ENDP			; vgui::Dar<char *>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z PROC		; vgui::Dar<char *>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	xor	ecx, ecx
	mov	eax, DWORD PTR _newCapacity$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], eax

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _newData$[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z ENDP		; vgui::Dar<char *>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAD@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@PAD@vgui@@QAE@H@Z PROC				; vgui::Dar<char *>::Dar<char *>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z	; vgui::Dar<char *>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@PAD@vgui@@QAE@H@Z ENDP				; vgui::Dar<char *>::Dar<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@PAD@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@PAD@vgui@@QAE@XZ PROC				; vgui::Dar<char *>::Dar<char *>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@PAD@vgui@@QAEXH@Z	; vgui::Dar<char *>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@PAD@vgui@@QAE@XZ ENDP				; vgui::Dar<char *>::Dar<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@D@vgui@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@D@vgui@@QAEAAV01@$$QAV01@@Z PROC		; vgui::Dar<char>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@D@vgui@@QAEAAV01@$$QAV01@@Z ENDP		; vgui::Dar<char>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4?$Dar@D@vgui@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Dar@D@vgui@@QAEAAV01@ABV01@@Z PROC			; vgui::Dar<char>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Dar@D@vgui@@QAEAAV01@ABV01@@Z ENDP			; vgui::Dar<char>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??A?$Dar@D@vgui@@QAEDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Dar@D@vgui@@QAEDH@Z PROC				; vgui::Dar<char>::operator[], COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@operator
$LN3@operator:

; 158  : 		{
; 159  : 			return null;

	xor	al, al
	jmp	SHORT $LN1@operator
$LN2@operator:

; 160  : 		}
; 161  : 		return _data[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	al, BYTE PTR [ecx+edx]
$LN1@operator:

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Dar@D@vgui@@QAEDH@Z ENDP				; vgui::Dar<char>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeAll@?$Dar@D@vgui@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?removeAll@?$Dar@D@vgui@@QAEXXZ PROC			; vgui::Dar<char>::removeAll, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?removeAll@?$Dar@D@vgui@@QAEXXZ ENDP			; vgui::Dar<char>::removeAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElement@?$Dar@D@vgui@@QAEXD@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
?removeElement@?$Dar@D@vgui@@QAEXD@Z PROC		; vgui::Dar<char>::removeElement, COMDAT
; _this$ = ecx

; 141  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@removeElem

; 143  : 		{
; 144  : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	movsx	ecx, BYTE PTR _elem$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN5@removeElem

; 145  : 			{
; 146  : 				removeElementAt(i);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeElementAt@?$Dar@D@vgui@@QAEXH@Z	; vgui::Dar<char>::removeElementAt

; 147  : 				break;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 148  : 			}
; 149  : 		}

	jmp	SHORT $LN2@removeElem
$LN1@removeElem:

; 150  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElement@?$Dar@D@vgui@@QAEXD@Z ENDP		; vgui::Dar<char>::removeElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?removeElementAt@?$Dar@D@vgui@@QAEXH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?removeElementAt@?$Dar@D@vgui@@QAEXH@Z PROC		; vgui::Dar<char>::removeElementAt, COMDAT
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@removeElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN5@removeElem
$LN6@removeElem:

; 129  : 		{
; 130  : 			return;

	jmp	SHORT $LN1@removeElem
$LN5@removeElem:

; 131  : 		}
; 132  :    
; 133  : 		//slide everything to the right of index, left one.
; 134  : 		for(int i=index;i<(_count-1);i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@removeElem
$LN2@removeElem:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@removeElem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@removeElem

; 135  : 		{
; 136  : 			_data[i]=_data[i+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	cl, BYTE PTR [ecx+esi+1]
	mov	BYTE PTR [eax+edx], cl

; 137  : 		}

	jmp	SHORT $LN2@removeElem
$LN3@removeElem:

; 138  : 		_count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@removeElem:

; 139  : 	} 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?removeElementAt@?$Dar@D@vgui@@QAEXH@Z ENDP		; vgui::Dar<char>::removeElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setElementAt@?$Dar@D@vgui@@QAEXDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
_index$ = 12						; size = 4
?setElementAt@?$Dar@D@vgui@@QAEXDH@Z PROC		; vgui::Dar<char>::setElementAt, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		if((index<0)||(index>=_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN3@setElement
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN2@setElement
$LN3@setElement:

; 121  : 		{
; 122  : 			return;

	jmp	SHORT $LN1@setElement
$LN2@setElement:

; 123  : 		}
; 124  : 		_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	al, BYTE PTR _elem$[ebp]
	mov	BYTE PTR [ecx+edx], al
$LN1@setElement:

; 125  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?setElementAt@?$Dar@D@vgui@@QAEXDH@Z ENDP		; vgui::Dar<char>::setElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?insertElementAt@?$Dar@D@vgui@@QAEXDH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
_index$ = 12						; size = 4
?insertElementAt@?$Dar@D@vgui@@QAEXDH@Z PROC		; vgui::Dar<char>::insertElementAt, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		if((index<0)||(index>_count))

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN6@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@insertElem
$LN6@insertElem:

; 101  : 		{
; 102  : 			return;

	jmp	SHORT $LN1@insertElem
$LN5@insertElem:

; 103  : 		}
; 104  : 		if((index==_count)||(_count==0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@insertElem
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@insertElem
$LN9@insertElem:

; 105  : 		{
; 106  : 			addElement(elem);

	movzx	eax, BYTE PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@D@vgui@@QAEXD@Z	; vgui::Dar<char>::addElement

; 107  : 		}

	jmp	SHORT $LN1@insertElem
$LN7@insertElem:

; 108  : 		else
; 109  : 		{
; 110  : 			addElement(elem); //just to make sure it is big enough

	movzx	eax, BYTE PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@D@vgui@@QAEXD@Z	; vgui::Dar<char>::addElement

; 111  : 			for(int i=_count-1;i>index;i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@insertElem
$LN2@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@insertElem:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jle	SHORT $LN3@insertElem

; 112  : 			{
; 113  : 				_data[i]=_data[i-1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _i$1[ebp]
	mov	cl, BYTE PTR [ecx+esi-1]
	mov	BYTE PTR [eax+edx], cl

; 114  : 			}

	jmp	SHORT $LN2@insertElem
$LN3@insertElem:

; 115  : 			_data[index]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _index$[ebp]
	mov	al, BYTE PTR _elem$[ebp]
	mov	BYTE PTR [ecx+edx], al
$LN1@insertElem:

; 116  : 		}
; 117  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?insertElementAt@?$Dar@D@vgui@@QAEXDH@Z ENDP		; vgui::Dar<char>::insertElementAt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?putElement@?$Dar@D@vgui@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
?putElement@?$Dar@D@vgui@@QAEXD@Z PROC			; vgui::Dar<char>::putElement, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		if(hasElement(elem))

	movzx	eax, BYTE PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasElement@?$Dar@D@vgui@@QAE_ND@Z	; vgui::Dar<char>::hasElement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@putElement

; 93   : 		{
; 94   : 			return;

	jmp	SHORT $LN1@putElement
$LN2@putElement:

; 95   : 		}
; 96   : 		addElement(elem);

	movzx	eax, BYTE PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addElement@?$Dar@D@vgui@@QAEXD@Z	; vgui::Dar<char>::addElement
$LN1@putElement:

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?putElement@?$Dar@D@vgui@@QAEXD@Z ENDP			; vgui::Dar<char>::putElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?hasElement@?$Dar@D@vgui@@QAE_ND@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
?hasElement@?$Dar@D@vgui@@QAE_ND@Z PROC			; vgui::Dar<char>::hasElement, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		for(int i=0;i<_count;i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@hasElement
$LN2@hasElement:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@hasElement:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@hasElement

; 82   : 		{
; 83   : 			if(_data[i]==elem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$1[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	movsx	ecx, BYTE PTR _elem$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN5@hasElement

; 84   : 			{
; 85   : 				return true;

	mov	al, 1
	jmp	SHORT $LN1@hasElement
$LN5@hasElement:

; 86   : 			}
; 87   : 		}

	jmp	SHORT $LN2@hasElement
$LN3@hasElement:

; 88   : 	return false;

	xor	al, al
$LN1@hasElement:

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hasElement@?$Dar@D@vgui@@QAE_ND@Z ENDP			; vgui::Dar<char>::hasElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?addElement@?$Dar@D@vgui@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_elem$ = 8						; size = 1
?addElement@?$Dar@D@vgui@@QAEXD@Z PROC			; vgui::Dar<char>::addElement, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		ensureCapacity(_count+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z	; vgui::Dar<char>::ensureCapacity

; 76   : 		_data[_count]=elem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	dl, BYTE PTR _elem$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 77   : 		_count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?addElement@?$Dar@D@vgui@@QAEXD@Z ENDP			; vgui::Dar<char>::addElement
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?getCount@?$Dar@D@vgui@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCount@?$Dar@D@vgui@@QAEHXZ PROC			; vgui::Dar<char>::getCount, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		return _count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 72   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getCount@?$Dar@D@vgui@@QAEHXZ ENDP			; vgui::Dar<char>::getCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?setCount@?$Dar@D@vgui@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?setCount@?$Dar@D@vgui@@QAEXH@Z PROC			; vgui::Dar<char>::setCount, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if((count<0)||(count>_capacity))

	cmp	DWORD PTR _count$[ebp], 0
	jl	SHORT $LN3@setCount
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN2@setCount
$LN3@setCount:

; 64   : 		{
; 65   : 			return;

	jmp	SHORT $LN1@setCount
$LN2@setCount:

; 66   : 		}
; 67   : 		_count=count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@setCount:

; 68   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setCount@?$Dar@D@vgui@@QAEXH@Z ENDP			; vgui::Dar<char>::setCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_i$3 = -16						; size = 4
_newData$ = -12						; size = 4
_newCapacity$ = -8					; size = 4
_this$ = -4						; size = 4
_wantedCapacity$ = 8					; size = 4
?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z PROC		; vgui::Dar<char>::ensureCapacity, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		if(wantedCapacity<=_capacity){return;}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _wantedCapacity$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN7@ensureCapa
	jmp	$LN10@ensureCapa
$LN7@ensureCapa:

; 42   : 
; 43   : 		//double capacity until it is >= wantedCapacity
; 44   : 		//this could be done with math, but iterative is just so much more fun
; 45   : 		int newCapacity=_capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _newCapacity$[ebp], ecx

; 46   : 		if(newCapacity==0){newCapacity=1;}

	cmp	DWORD PTR _newCapacity$[ebp], 0
	jne	SHORT $LN2@ensureCapa
	mov	DWORD PTR _newCapacity$[ebp], 1
$LN2@ensureCapa:

; 47   : 		while(newCapacity<wantedCapacity){newCapacity*=2;}

	mov	eax, DWORD PTR _newCapacity$[ebp]
	cmp	eax, DWORD PTR _wantedCapacity$[ebp]
	jge	SHORT $LN3@ensureCapa
	mov	eax, DWORD PTR _newCapacity$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newCapacity$[ebp], eax
	jmp	SHORT $LN2@ensureCapa
$LN3@ensureCapa:

; 48   : 
; 49   : 		//allocate and zero newData
; 50   : 		ELEMTYPE* newData=new ELEMTYPE[newCapacity]; 

	mov	eax, DWORD PTR _newCapacity$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newData$[ebp], ecx

; 51   : 		if(newData==null){exit(0);return;}

	cmp	DWORD PTR _newData$[ebp], 0
	jne	SHORT $LN9@ensureCapa
	push	0
	call	DWORD PTR __imp__exit
	jmp	SHORT $LN10@ensureCapa
$LN9@ensureCapa:

; 52   : 		memset(newData,0,sizeof(ELEMTYPE)*newCapacity);

	mov	eax, DWORD PTR _newCapacity$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _newData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 53   : 		_capacity=newCapacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newCapacity$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 54   :    
; 55   : 		//copy data into newData
; 56   : 		for(int i=0;i<_count;i++){newData[i]=_data[i];}

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@ensureCapa
$LN4@ensureCapa:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@ensureCapa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@ensureCapa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _newData$[ebp]
	add	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _i$3[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN4@ensureCapa
$LN5@ensureCapa:

; 57   : 
; 58   : 		delete[] _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 59   : 		_data=newData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newData$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN10@ensureCapa:

; 60   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z ENDP		; vgui::Dar<char>::ensureCapacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@D@vgui@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_initialCapacity$ = 8					; size = 4
??0?$Dar@D@vgui@@QAE@H@Z PROC				; vgui::Dar<char>::Dar<char>, COMDAT
; _this$ = ecx

; 31   : 	Dar(int initialCapacity)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	{
; 33   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 34   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 35   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 36   : 		ensureCapacity(initialCapacity);

	mov	eax, DWORD PTR _initialCapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z	; vgui::Dar<char>::ensureCapacity

; 37   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Dar@D@vgui@@QAE@H@Z ENDP				; vgui::Dar<char>::Dar<char>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\utils\vgui\include\VGUI_Dar.h
;	COMDAT ??0?$Dar@D@vgui@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Dar@D@vgui@@QAE@XZ PROC				; vgui::Dar<char>::Dar<char>, COMDAT
; _this$ = ecx

; 24   : 	Dar()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 	{
; 26   : 		_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 27   : 		_capacity=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 28   : 		_data=null;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 29   : 		ensureCapacity(4);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ensureCapacity@?$Dar@D@vgui@@QAEXH@Z	; vgui::Dar<char>::ensureCapacity

; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Dar@D@vgui@@QAE@XZ ENDP				; vgui::Dar<char>::Dar<char>
_TEXT	ENDS
END
