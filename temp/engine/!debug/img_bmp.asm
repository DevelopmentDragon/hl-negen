; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_bmp.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Image_LoadBMP
PUBLIC	_Image_SaveBMP
PUBLIC	?__LINE__Var@?0??Image_LoadBMP@@9@9		; `Image_LoadBMP'::`1'::__LINE__Var
PUBLIC	??_C@_02DGHHEOAL@BM@				; `string'
PUBLIC	??_C@_0EH@FKABKFPN@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@ ; `string'
PUBLIC	??_C@_0DC@FCCBPJCO@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5inval@ ; `string'
PUBLIC	??_C@_0EJ@MLNPNCLB@?$FO3Warning?3?$FO7?5Image_LoadBMP?3?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0EG@CLGIAIPB@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@ ; `string'
PUBLIC	??_C@_0BF@CEPAENOH@?$CDXASH_SYSTEMFONT_001@	; `string'
PUBLIC	??_C@_05FPHPPOBA@?$CDlogo@			; `string'
PUBLIC	??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_SaveBMP@@9@9		; `Image_SaveBMP'::`1'::__LINE__Var
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	__real@3f800000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_SetClipboardData:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Image_GetPaletteBMP:PROC
EXTRN	_Image_ValidSize:PROC
EXTRN	_Image_CheckFlag:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_SaveBMP@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_SaveBMP@@9@9 DD 0136H		; `Image_SaveBMP'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_bmp.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPHPPOBA@?$CDlogo@
CONST	SEGMENT
??_C@_05FPHPPOBA@?$CDlogo@ DB '#logo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CEPAENOH@?$CDXASH_SYSTEMFONT_001@
CONST	SEGMENT
??_C@_0BF@CEPAENOH@?$CDXASH_SYSTEMFONT_001@ DB '#XASH_SYSTEMFONT_001', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@CLGIAIPB@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@
CONST	SEGMENT
??_C@_0EG@CLGIAIPB@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@ DB '^1Erro'
	DB	'r:^7 Image_LoadBMP: only uncompressed BMP files supported (%s'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@MLNPNCLB@?$FO3Warning?3?$FO7?5Image_LoadBMP?3?5?$CFs?5@
CONST	SEGMENT
??_C@_0EJ@MLNPNCLB@?$FO3Warning?3?$FO7?5Image_LoadBMP?3?5?$CFs?5@ DB '^3W'
	DB	'arning:^7 Image_LoadBMP: %s have incorrect file size %i shoul'
	DB	'd be %i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FCCBPJCO@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5inval@
CONST	SEGMENT
??_C@_0DC@FCCBPJCO@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5inval@ DB '^1Error'
	DB	':^7 Image_LoadBMP: invalid header size %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@FKABKFPN@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@
CONST	SEGMENT
??_C@_0EH@FKABKFPN@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@ DB '^1Erro'
	DB	'r:^7 Image_LoadBMP: only Windows-style BMP files supported (%'
	DB	's)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DGHHEOAL@BM@
CONST	SEGMENT
??_C@_02DGHHEOAL@BM@ DB 'BM', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_LoadBMP@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_LoadBMP@@9@9 DD 019H		; `Image_LoadBMP'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0649H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01196H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_bmp.c
;	COMDAT _Image_SaveBMP
_TEXT	SEGMENT
tv146 = -1332						; size = 4
tv75 = -1332						; size = 4
_y$ = -1136						; size = 4
_x$ = -1132						; size = 4
_i$ = -1128						; size = 4
_pixel_size$ = -1124					; size = 4
_biTrueWidth$ = -1120					; size = 4
_cbPalBytes$ = -1116					; size = 4
_pbBmpBits$ = -1112					; size = 4
_pb$ = -1108						; size = 4
_clipbuf$ = -1104					; size = 4
_cbBmpBits$ = -1100					; size = 4
_rgrgbPalette$ = -1096					; size = 1024
_cur_size$ = -72					; size = 4
_total_size$ = -68					; size = 4
_bmih$ = -64						; size = 40
_bmfh$ = -24						; size = 14
_pfile$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_pix$ = 12						; size = 4
_Image_SaveBMP PROC					; COMDAT

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1332				; 00000534H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 311  : 	file_t		*pfile = NULL;

	mov	DWORD PTR _pfile$[ebp], 0

; 312  : 	BITMAPFILEHEADER	bmfh;
; 313  : 	BITMAPINFOHEADER	bmih;
; 314  : 	size_t		total_size, cur_size;
; 315  : 	RGBQUAD		rgrgbPalette[256];
; 316  : 	dword		cbBmpBits;
; 317  : 	byte		*clipbuf = NULL;

	mov	DWORD PTR _clipbuf$[ebp], 0

; 318  : 	byte		*pb, *pbBmpBits;
; 319  : 	dword		cbPalBytes = 0;

	mov	DWORD PTR _cbPalBytes$[ebp], 0

; 320  : 	dword		biTrueWidth;
; 321  : 	int		pixel_size;
; 322  : 	int		i, x, y;
; 323  : 
; 324  : 	if( FS_FileExists( name, false ) && !Image_CheckFlag( IL_ALLOW_OVERWRITE ) && !host.write_to_clipboard )

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@Image_Save
	push	4
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@Image_Save
	cmp	DWORD PTR _host+34384, 0
	jne	SHORT $LN13@Image_Save

; 325  : 		return false; // already existed

	xor	eax, eax
	jmp	$LN1@Image_Save
$LN13@Image_Save:

; 326  : 
; 327  : 	// bogus parameter check
; 328  : 	if( !pix->buffer )

	mov	eax, DWORD PTR _pix$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@Image_Save

; 329  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Save
$LN14@Image_Save:

; 330  : 
; 331  : 	// get image description
; 332  : 	switch( pix->type )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR tv75[ebp]
	sub	edx, 1
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 4
	ja	SHORT $LN19@Image_Save
	mov	eax, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN41@Image_Save[eax*4]
$LN16@Image_Save:

; 333  : 	{
; 334  : 	case PF_INDEXED_24:
; 335  : 	case PF_INDEXED_32:
; 336  : 		pixel_size = 1;

	mov	DWORD PTR _pixel_size$[ebp], 1

; 337  : 		break;

	jmp	SHORT $LN2@Image_Save
$LN17@Image_Save:

; 338  : 	case PF_RGB_24:
; 339  : 		pixel_size = 3;

	mov	DWORD PTR _pixel_size$[ebp], 3

; 340  : 		break;

	jmp	SHORT $LN2@Image_Save
$LN18@Image_Save:

; 341  : 	case PF_RGBA_32:
; 342  : 		pixel_size = 4;

	mov	DWORD PTR _pixel_size$[ebp], 4

; 343  : 		break;	

	jmp	SHORT $LN2@Image_Save
$LN19@Image_Save:

; 344  : 	default:
; 345  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Save
$LN2@Image_Save:

; 346  : 	}
; 347  : 
; 348  : 	if( !host.write_to_clipboard )

	cmp	DWORD PTR _host+34384, 0
	jne	SHORT $LN20@Image_Save

; 349  : 	{
; 350  : 		pfile = FS_Open( name, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pfile$[ebp], eax

; 351  : 		if( !pfile ) return false;

	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN20@Image_Save
	xor	eax, eax
	jmp	$LN1@Image_Save
$LN20@Image_Save:

; 352  : 	}
; 353  : 
; 354  : 	// NOTE: align transparency column will sucessfully removed
; 355  : 	// after create sprite or lump image, it's just standard requiriments 
; 356  : 	biTrueWidth = ((pix->width + 3) & ~3);

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	mov	DWORD PTR _biTrueWidth$[ebp], ecx

; 357  : 	cbBmpBits = biTrueWidth * pix->height * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	imul	ecx, DWORD PTR _biTrueWidth$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	DWORD PTR _cbBmpBits$[ebp], ecx

; 358  : 	if( pixel_size == 1 ) cbPalBytes = 256 * sizeof( RGBQUAD );

	cmp	DWORD PTR _pixel_size$[ebp], 1
	jne	SHORT $LN22@Image_Save
	mov	DWORD PTR _cbPalBytes$[ebp], 1024	; 00000400H
$LN22@Image_Save:

; 359  : 
; 360  : 	// Bogus file header check
; 361  : 	bmfh.bfType = MAKEWORD( 'B', 'M' );

	mov	eax, 19778				; 00004d42H
	mov	WORD PTR _bmfh$[ebp], ax

; 362  : 	bmfh.bfSize = sizeof( bmfh ) + sizeof( bmih ) + cbBmpBits + cbPalBytes;

	mov	eax, DWORD PTR _cbPalBytes$[ebp]
	mov	ecx, DWORD PTR _cbBmpBits$[ebp]
	lea	edx, DWORD PTR [ecx+eax+54]
	mov	DWORD PTR _bmfh$[ebp+2], edx

; 363  : 	bmfh.bfReserved1 = 0;

	xor	eax, eax
	mov	WORD PTR _bmfh$[ebp+6], ax

; 364  : 	bmfh.bfReserved2 = 0;

	xor	eax, eax
	mov	WORD PTR _bmfh$[ebp+8], ax

; 365  : 	bmfh.bfOffBits = sizeof( bmfh ) + sizeof( bmih ) + cbPalBytes;

	mov	eax, DWORD PTR _cbPalBytes$[ebp]
	add	eax, 54					; 00000036H
	mov	DWORD PTR _bmfh$[ebp+10], eax

; 366  : 
; 367  : 	if( host.write_to_clipboard )

	cmp	DWORD PTR _host+34384, 0
	je	SHORT $LN23@Image_Save

; 368  : 	{
; 369  : 		// NOTE: the cbPalBytes may be 0
; 370  : 		total_size = sizeof( bmih ) + cbPalBytes + cbBmpBits;

	mov	eax, DWORD PTR _cbBmpBits$[ebp]
	mov	ecx, DWORD PTR _cbPalBytes$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _total_size$[ebp], edx

; 371  : 		clipbuf = Z_Malloc( total_size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveBMP@@9@9
	add	eax, 61					; 0000003dH
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _total_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clipbuf$[ebp], eax

; 372  : 		cur_size = 0;

	mov	DWORD PTR _cur_size$[ebp], 0

; 373  : 	}

	jmp	SHORT $LN24@Image_Save
$LN23@Image_Save:

; 374  : 	else
; 375  : 	{
; 376  : 		// write header
; 377  : 		FS_Write( pfile, &bmfh, sizeof( bmfh ));

	push	14					; 0000000eH
	lea	eax, DWORD PTR _bmfh$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN24@Image_Save:

; 378  : 	}
; 379  : 
; 380  : 	// size of structure
; 381  : 	bmih.biSize = sizeof( bmih );

	mov	DWORD PTR _bmih$[ebp], 40		; 00000028H

; 382  : 	bmih.biWidth = biTrueWidth;

	mov	eax, DWORD PTR _biTrueWidth$[ebp]
	mov	DWORD PTR _bmih$[ebp+4], eax

; 383  : 	bmih.biHeight = pix->height;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _bmih$[ebp+8], ecx

; 384  : 	bmih.biPlanes = 1;

	mov	eax, 1
	mov	WORD PTR _bmih$[ebp+12], ax

; 385  : 	bmih.biBitCount = pixel_size * 8;

	mov	eax, DWORD PTR _pixel_size$[ebp]
	shl	eax, 3
	mov	WORD PTR _bmih$[ebp+14], ax

; 386  : 	bmih.biCompression = BI_RGB;

	mov	DWORD PTR _bmih$[ebp+16], 0

; 387  : 	bmih.biSizeImage = cbBmpBits;

	mov	eax, DWORD PTR _cbBmpBits$[ebp]
	mov	DWORD PTR _bmih$[ebp+20], eax

; 388  : 	bmih.biXPelsPerMeter = 0;

	mov	DWORD PTR _bmih$[ebp+24], 0

; 389  : 	bmih.biYPelsPerMeter = 0;

	mov	DWORD PTR _bmih$[ebp+28], 0

; 390  : 	bmih.biClrUsed = ( pixel_size == 1 ) ? 256 : 0;

	cmp	DWORD PTR _pixel_size$[ebp], 1
	jne	SHORT $LN39@Image_Save
	mov	DWORD PTR tv146[ebp], 256		; 00000100H
	jmp	SHORT $LN40@Image_Save
$LN39@Image_Save:
	mov	DWORD PTR tv146[ebp], 0
$LN40@Image_Save:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR _bmih$[ebp+32], eax

; 391  : 	bmih.biClrImportant = 0;

	mov	DWORD PTR _bmih$[ebp+36], 0

; 392  : 
; 393  : 	if( host.write_to_clipboard )

	cmp	DWORD PTR _host+34384, 0
	je	SHORT $LN25@Image_Save

; 394  : 	{
; 395  : 		memcpy( clipbuf + cur_size, &bmih, sizeof( bmih ));

	push	40					; 00000028H
	lea	eax, DWORD PTR _bmih$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clipbuf$[ebp]
	add	ecx, DWORD PTR _cur_size$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 396  : 		cur_size += sizeof( bmih );

	mov	eax, DWORD PTR _cur_size$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _cur_size$[ebp], eax

; 397  : 	}

	jmp	SHORT $LN26@Image_Save
$LN25@Image_Save:

; 398  : 	else
; 399  : 	{
; 400  : 		// Write info header
; 401  : 		FS_Write( pfile, &bmih, sizeof( bmih ));

	push	40					; 00000028H
	lea	eax, DWORD PTR _bmih$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN26@Image_Save:

; 402  : 	}
; 403  : 
; 404  : 	pbBmpBits = Mem_Malloc( host.imagepool, cbBmpBits );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveBMP@@9@9
	add	eax, 94					; 0000005eH
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _cbBmpBits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pbBmpBits$[ebp], eax

; 405  : 
; 406  : 	if( pixel_size == 1 )

	cmp	DWORD PTR _pixel_size$[ebp], 1
	jne	$LN27@Image_Save

; 407  : 	{
; 408  : 		pb = pix->palette;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pb$[ebp], ecx

; 409  : 
; 410  : 		// copy over used entries
; 411  : 		for( i = 0; i < (int)bmih.biClrUsed; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_Save
$LN4@Image_Save:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_Save:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bmih$[ebp+32]
	jge	$LN5@Image_Save

; 412  : 		{
; 413  : 			rgrgbPalette[i].rgbRed = *pb++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pb$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _rgrgbPalette$[ebp+eax*4+2], dl
	mov	eax, DWORD PTR _pb$[ebp]
	add	eax, 1
	mov	DWORD PTR _pb$[ebp], eax

; 414  : 			rgrgbPalette[i].rgbGreen = *pb++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pb$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _rgrgbPalette$[ebp+eax*4+1], dl
	mov	eax, DWORD PTR _pb$[ebp]
	add	eax, 1
	mov	DWORD PTR _pb$[ebp], eax

; 415  : 			rgrgbPalette[i].rgbBlue = *pb++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pb$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _rgrgbPalette$[ebp+eax*4], dl
	mov	eax, DWORD PTR _pb$[ebp]
	add	eax, 1
	mov	DWORD PTR _pb$[ebp], eax

; 416  : 
; 417  : 			// bmp feature - can store 32-bit palette if present
; 418  : 			// some viewers e.g. fimg.exe can show alpha-chanell for it
; 419  : 			if( pix->type == PF_INDEXED_32 )

	mov	eax, DWORD PTR _pix$[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN28@Image_Save

; 420  : 				rgrgbPalette[i].rgbReserved = *pb++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pb$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _rgrgbPalette$[ebp+eax*4+3], dl
	mov	eax, DWORD PTR _pb$[ebp]
	add	eax, 1
	mov	DWORD PTR _pb$[ebp], eax
	jmp	SHORT $LN29@Image_Save
$LN28@Image_Save:

; 421  : 			else rgrgbPalette[i].rgbReserved = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _rgrgbPalette$[ebp+eax*4+3], 0
$LN29@Image_Save:

; 422  : 		}

	jmp	$LN4@Image_Save
$LN5@Image_Save:

; 423  : 
; 424  : 		if( host.write_to_clipboard )

	cmp	DWORD PTR _host+34384, 0
	je	SHORT $LN30@Image_Save

; 425  : 		{
; 426  : 			memcpy( clipbuf + cur_size, rgrgbPalette, cbPalBytes );

	mov	eax, DWORD PTR _cbPalBytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgrgbPalette$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clipbuf$[ebp]
	add	edx, DWORD PTR _cur_size$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 427  : 			cur_size += cbPalBytes;

	mov	eax, DWORD PTR _cur_size$[ebp]
	add	eax, DWORD PTR _cbPalBytes$[ebp]
	mov	DWORD PTR _cur_size$[ebp], eax

; 428  : 		}

	jmp	SHORT $LN27@Image_Save
$LN30@Image_Save:

; 429  : 		else
; 430  : 		{
; 431  : 			// write palette
; 432  : 			FS_Write( pfile, rgrgbPalette, cbPalBytes );

	mov	eax, DWORD PTR _cbPalBytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgrgbPalette$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN27@Image_Save:

; 433  : 		}
; 434  : 	}
; 435  : 
; 436  : 	pb = pix->buffer;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pb$[ebp], ecx

; 437  : 
; 438  : 	for( y = 0; y < bmih.biHeight; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN9@Image_Save
$LN7@Image_Save:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN9@Image_Save:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _bmih$[ebp+8]
	jge	$LN8@Image_Save

; 439  : 	{
; 440  : 		i = (bmih.biHeight - 1 - y ) * (bmih.biWidth);

	mov	eax, DWORD PTR _bmih$[ebp+8]
	sub	eax, 1
	sub	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _bmih$[ebp+4]
	mov	DWORD PTR _i$[ebp], eax

; 441  : 
; 442  : 		for( x = 0; x < pix->width; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN12@Image_Save
$LN10@Image_Save:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN12@Image_Save:
	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _x$[ebp], ecx
	jge	$LN11@Image_Save

; 443  : 		{
; 444  : 			if( pixel_size == 1 )

	cmp	DWORD PTR _pixel_size$[ebp], 1
	jne	SHORT $LN32@Image_Save

; 445  : 			{
; 446  : 				// 8-bit
; 447  : 				pbBmpBits[i] = pb[x];

	mov	eax, DWORD PTR _pbBmpBits$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pb$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 448  : 			}

	jmp	$LN33@Image_Save
$LN32@Image_Save:

; 449  : 			else
; 450  : 			{
; 451  : 				// 24 bit
; 452  : 				pbBmpBits[i*pixel_size+0] = pb[x*pixel_size+2];

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _pixel_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pbBmpBits$[ebp]
	mov	esi, DWORD PTR _pb$[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx], al

; 453  : 				pbBmpBits[i*pixel_size+1] = pb[x*pixel_size+1];

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _pixel_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pbBmpBits$[ebp]
	mov	esi, DWORD PTR _pb$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx+1], al

; 454  : 				pbBmpBits[i*pixel_size+2] = pb[x*pixel_size+0];

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _pixel_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pbBmpBits$[ebp]
	mov	esi, DWORD PTR _pb$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx+2], al
$LN33@Image_Save:

; 455  : 			}
; 456  : 
; 457  : 			if( pixel_size == 4 ) // write alpha channel

	cmp	DWORD PTR _pixel_size$[ebp], 4
	jne	SHORT $LN34@Image_Save

; 458  : 				pbBmpBits[i*pixel_size+3] = pb[x*pixel_size+3];

	mov	eax, DWORD PTR _x$[ebp]
	imul	eax, DWORD PTR _pixel_size$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pbBmpBits$[ebp]
	mov	esi, DWORD PTR _pb$[ebp]
	mov	al, BYTE PTR [esi+eax+3]
	mov	BYTE PTR [edx+ecx+3], al
$LN34@Image_Save:

; 459  : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 460  : 		}

	jmp	$LN10@Image_Save
$LN11@Image_Save:

; 461  : 
; 462  : 		pb += pix->width * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	add	ecx, DWORD PTR _pb$[ebp]
	mov	DWORD PTR _pb$[ebp], ecx

; 463  : 	}

	jmp	$LN7@Image_Save
$LN8@Image_Save:

; 464  : 
; 465  : 	if( host.write_to_clipboard )

	cmp	DWORD PTR _host+34384, 0
	je	SHORT $LN35@Image_Save

; 466  : 	{
; 467  : 		memcpy( clipbuf + cur_size, pbBmpBits, cbBmpBits );

	mov	eax, DWORD PTR _cbBmpBits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbBmpBits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clipbuf$[ebp]
	add	edx, DWORD PTR _cur_size$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 468  : 		cur_size += cbBmpBits;

	mov	eax, DWORD PTR _cur_size$[ebp]
	add	eax, DWORD PTR _cbBmpBits$[ebp]
	mov	DWORD PTR _cur_size$[ebp], eax

; 469  : 		Sys_SetClipboardData( clipbuf, total_size );

	mov	eax, DWORD PTR _total_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clipbuf$[ebp]
	push	ecx
	call	_Sys_SetClipboardData
	add	esp, 8

; 470  : 		Z_Free( clipbuf );

	cmp	DWORD PTR _clipbuf$[ebp], 0
	je	SHORT $LN37@Image_Save
	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveBMP@@9@9
	add	eax, 160				; 000000a0H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clipbuf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN37@Image_Save:

; 471  : 	}

	jmp	SHORT $LN36@Image_Save
$LN35@Image_Save:

; 472  : 	else
; 473  : 	{
; 474  : 		// write bitmap bits (remainder of file)
; 475  : 		FS_Write( pfile, pbBmpBits, cbBmpBits );

	mov	eax, DWORD PTR _cbBmpBits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbBmpBits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 476  : 		FS_Close( pfile );

	mov	eax, DWORD PTR _pfile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN36@Image_Save:

; 477  : 	}
; 478  : 
; 479  : 	Mem_Free( pbBmpBits );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveBMP@@9@9
	add	eax, 169				; 000000a9H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pbBmpBits$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 480  : 
; 481  : 	return true;

	mov	eax, 1
$LN1@Image_Save:

; 482  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN41@Image_Save:
	DD	$LN16@Image_Save
	DD	$LN16@Image_Save
	DD	$LN18@Image_Save
	DD	$LN19@Image_Save
	DD	$LN17@Image_Save
_Image_SaveBMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_bmp.c
;	COMDAT _Image_LoadBMP
_TEXT	SEGMENT
tv339 = -1364						; size = 4
tv337 = -1360						; size = 4
tv328 = -1360						; size = 4
tv300 = -1360						; size = 4
_palIndex$1 = -1164					; size = 4
_k$2 = -1160						; size = 4
_c$3 = -1156						; size = 4
_shortPixel$4 = -1152					; size = 2
_alpha$5 = -1148					; size = 1
_blue$6 = -1147						; size = 1
_green$7 = -1146					; size = 1
_red$8 = -1145						; size = 1
_bhdr$ = -1144						; size = 54
_load_qfont$ = -1088					; size = 4
_reflectivity$ = -1084					; size = 12
_bps$ = -1072						; size = 4
_padSize$ = -1068					; size = 4
_cbPalBytes$ = -1064					; size = 4
_bpp$ = -1060						; size = 4
_row$ = -1056						; size = 4
_rows$ = -1052						; size = 4
_column$ = -1048					; size = 4
_columns$ = -1044					; size = 4
_i$ = -1040						; size = 4
_palette$ = -1036					; size = 1024
_pixbuf$ = -12						; size = 4
_buf_p$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadBMP PROC					; COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1364				; 00000554H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 26   : 	byte	*buf_p, *pixbuf;
; 27   : 	byte	palette[256][4];
; 28   : 	int	i, columns, column, rows, row, bpp = 1;

	mov	DWORD PTR _bpp$[ebp], 1

; 29   : 	int	cbPalBytes = 0, padSize = 0, bps = 0;

	mov	DWORD PTR _cbPalBytes$[ebp], 0
	mov	DWORD PTR _padSize$[ebp], 0
	mov	DWORD PTR _bps$[ebp], 0

; 30   : 	int	reflectivity[3] = { 0, 0, 0 };

	mov	DWORD PTR _reflectivity$[ebp], 0
	mov	DWORD PTR _reflectivity$[ebp+4], 0
	mov	DWORD PTR _reflectivity$[ebp+8], 0

; 31   : 	qboolean	load_qfont = false;

	mov	DWORD PTR _load_qfont$[ebp], 0

; 32   : 	bmp_t	bhdr;
; 33   : 
; 34   : 	if( filesize < sizeof( bhdr )) return false; 

	cmp	DWORD PTR _filesize$[ebp], 54		; 00000036H
	jae	SHORT $LN24@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN24@Image_Load:

; 35   : 
; 36   : 	buf_p = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _buf_p$[ebp], eax

; 37   : 	bhdr.id[0] = *buf_p++;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _bhdr$[ebp+ecx], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 38   : 	bhdr.id[1] = *buf_p++;				// move pointer

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _buf_p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _bhdr$[ebp+eax], dl
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_p$[ebp], eax

; 39   : 	bhdr.fileSize = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+2], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 40   : 	bhdr.reserved0 = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+6], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 41   : 	bhdr.bitmapDataOffset = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+10], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 42   : 	bhdr.bitmapHeaderSize = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+14], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 43   : 	bhdr.width = *(long *)buf_p;		buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+18], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 44   : 	bhdr.height = *(long *)buf_p;		buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+22], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 45   : 	bhdr.planes = *(short *)buf_p;	buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _bhdr$[ebp+26], cx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 46   : 	bhdr.bitsPerPixel = *(short *)buf_p;	buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _bhdr$[ebp+28], cx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 47   : 	bhdr.compression = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+30], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 48   : 	bhdr.bitmapDataSize = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+34], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 49   : 	bhdr.hRes = *(long *)buf_p;		buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+38], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 50   : 	bhdr.vRes = *(long *)buf_p;		buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+42], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 51   : 	bhdr.colors = *(long *)buf_p;		buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+46], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 52   : 	bhdr.importantColors = *(long *)buf_p;	buf_p += 4;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bhdr$[ebp+50], ecx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_p$[ebp], eax

; 53   : 
; 54   : 	// bogus file header check
; 55   : 	if( bhdr.reserved0 != 0 ) return false;

	cmp	DWORD PTR _bhdr$[ebp+6], 0
	je	SHORT $LN25@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN25@Image_Load:

; 56   : 	if( bhdr.planes != 1 ) return false;

	movzx	eax, WORD PTR _bhdr$[ebp+26]
	cmp	eax, 1
	je	SHORT $LN26@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN26@Image_Load:

; 57   : 
; 58   : 	if( memcmp( bhdr.id, "BM", 2 ))

	push	2
	push	OFFSET ??_C@_02DGHHEOAL@BM@
	lea	eax, DWORD PTR _bhdr$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@Image_Load

; 59   : 	{
; 60   : 		Con_DPrintf( S_ERROR "Image_LoadBMP: only Windows-style BMP files supported (%s)\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EH@FKABKFPN@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@
	call	_Con_DPrintf
	add	esp, 8

; 61   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN27@Image_Load:

; 62   : 	} 
; 63   : 
; 64   : 	if( bhdr.bitmapHeaderSize != 0x28 )

	cmp	DWORD PTR _bhdr$[ebp+14], 40		; 00000028H
	je	SHORT $LN28@Image_Load

; 65   : 	{
; 66   : 		Con_DPrintf( S_ERROR "Image_LoadBMP: invalid header size %i\n", bhdr.bitmapHeaderSize );

	mov	eax, DWORD PTR _bhdr$[ebp+14]
	push	eax
	push	OFFSET ??_C@_0DC@FCCBPJCO@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5inval@
	call	_Con_DPrintf
	add	esp, 8

; 67   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN28@Image_Load:

; 68   : 	}
; 69   : 
; 70   : 	// bogus info header check
; 71   : 	if( bhdr.fileSize != filesize )

	mov	eax, DWORD PTR _bhdr$[ebp+2]
	cmp	eax, DWORD PTR _filesize$[ebp]
	je	SHORT $LN29@Image_Load

; 72   : 	{
; 73   : 		// Sweet Half-Life issues. splash.bmp have bogus filesize
; 74   : 		Con_Reportf( S_WARN "Image_LoadBMP: %s have incorrect file size %i should be %i\n", name, filesize, bhdr.fileSize );

	mov	eax, DWORD PTR _bhdr$[ebp+2]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0EJ@MLNPNCLB@?$FO3Warning?3?$FO7?5Image_LoadBMP?3?5?$CFs?5@
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN29@Image_Load:

; 75   :           }
; 76   :           
; 77   : 	// bogus compression?  Only non-compressed supported.
; 78   : 	if( bhdr.compression != BI_RGB ) 

	cmp	DWORD PTR _bhdr$[ebp+30], 0
	je	SHORT $LN30@Image_Load

; 79   : 	{
; 80   : 		Con_DPrintf( S_ERROR "Image_LoadBMP: only uncompressed BMP files supported (%s)\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EG@CLGIAIPB@?$FO1Error?3?$FO7?5Image_LoadBMP?3?5only?5@
	call	_Con_DPrintf
	add	esp, 8

; 81   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN30@Image_Load:

; 82   : 	}
; 83   : 
; 84   : 	image.width = columns = bhdr.width;

	mov	eax, DWORD PTR _bhdr$[ebp+18]
	mov	DWORD PTR _columns$[ebp], eax
	mov	cx, WORD PTR _columns$[ebp]
	mov	WORD PTR _image+8, cx

; 85   : 	image.height = rows = abs( bhdr.height );

	mov	eax, DWORD PTR _bhdr$[ebp+22]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _rows$[ebp], eax
	mov	cx, WORD PTR _rows$[ebp]
	mov	WORD PTR _image+10, cx

; 86   : 
; 87   : 	if( !Image_ValidSize( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@Image_Load

; 88   : 		return false;          

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN31@Image_Load:

; 89   : 
; 90   : 	// special case for loading qfont (menu font)
; 91   : 	if( !Q_strncmp( name, "#XASH_SYSTEMFONT_001", 20 ))

	push	20					; 00000014H
	push	OFFSET ??_C@_0BF@CEPAENOH@?$CDXASH_SYSTEMFONT_001@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@Image_Load

; 92   : 	{
; 93   : 		// NOTE: same as system font we can use 4-bit bmps only
; 94   : 		// step1: move main layer into alpha-channel (give grayscale from RED channel)
; 95   : 		// step2: fill main layer with 255 255 255 color (white)
; 96   : 		// step3: ????
; 97   : 		// step4: PROFIT!!! (economy up to 150 kb for menu.dll final size)
; 98   : 		image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax

; 99   : 		load_qfont = true;

	mov	DWORD PTR _load_qfont$[ebp], 1
$LN32@Image_Load:

; 100  : 	}
; 101  : 
; 102  : 	if( bhdr.bitsPerPixel <= 8 )

	movzx	eax, WORD PTR _bhdr$[ebp+28]
	cmp	eax, 8
	jg	SHORT $LN35@Image_Load

; 103  : 	{
; 104  : 		// figure out how many entries are actually in the table
; 105  : 		if( bhdr.colors == 0 )

	cmp	DWORD PTR _bhdr$[ebp+46], 0
	jne	SHORT $LN34@Image_Load

; 106  : 		{
; 107  : 			bhdr.colors = 256;

	mov	DWORD PTR _bhdr$[ebp+46], 256		; 00000100H

; 108  : 			cbPalBytes = (1 << bhdr.bitsPerPixel) * sizeof( RGBQUAD );

	movzx	ecx, WORD PTR _bhdr$[ebp+28]
	mov	eax, 1
	shl	eax, cl
	shl	eax, 2
	mov	DWORD PTR _cbPalBytes$[ebp], eax

; 109  : 		}

	jmp	SHORT $LN35@Image_Load
$LN34@Image_Load:

; 110  : 		else cbPalBytes = bhdr.colors * sizeof( RGBQUAD );

	mov	eax, DWORD PTR _bhdr$[ebp+46]
	shl	eax, 2
	mov	DWORD PTR _cbPalBytes$[ebp], eax
$LN35@Image_Load:

; 111  : 	}
; 112  : 
; 113  : 	memcpy( palette, buf_p, cbPalBytes );

	mov	eax, DWORD PTR _cbPalBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_p$[ebp]
	push	ecx
	lea	edx, DWORD PTR _palette$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 114  : 
; 115  : 	// setup gradient alpha for player decal
; 116  : 	if( !Q_strncmp( name, "#logo", 5 ))

	push	5
	push	OFFSET ??_C@_05FPHPPOBA@?$CDlogo@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN36@Image_Load

; 117  : 	{
; 118  : 		for( i = 0; i < bhdr.colors; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Load
$LN2@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bhdr$[ebp+46]
	jae	SHORT $LN3@Image_Load

; 119  : 			palette[i][3] = i;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [ecx+eax], dl
	jmp	SHORT $LN2@Image_Load
$LN3@Image_Load:

; 120  : 		image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
$LN36@Image_Load:

; 121  : 	}
; 122  : 
; 123  : 	if( Image_CheckFlag( IL_OVERVIEW ) && bhdr.bitsPerPixel == 8 )

	push	64					; 00000040H
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	$LN6@Image_Load
	movzx	eax, WORD PTR _bhdr$[ebp+28]
	cmp	eax, 8
	jne	$LN6@Image_Load

; 124  : 	{
; 125  : 		// convert green background into alpha-layer, make opacity for all other entries
; 126  : 		for( i = 0; i < bhdr.colors; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Load
$LN5@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bhdr$[ebp+46]
	jae	$LN6@Image_Load

; 127  : 		{
; 128  : 			if( palette[i][0] == 0 && palette[i][1] == 255 && palette[i][2] == 0 )

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	movzx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	jne	$LN38@Image_Load
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 255				; 000000ffH
	jne	$LN38@Image_Load
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	jne	SHORT $LN38@Image_Load

; 129  : 			{
; 130  : 				palette[i][0] = palette[i][1] = palette[i][2] = palette[i][3] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR [ecx+eax], 0
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _palette$[ebp+ecx*4]
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR [edx+eax], 0
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _palette$[ebp+ecx*4]
	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR [edx+eax], 0
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _palette$[ebp+ecx*4]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR [edx+ecx], 0

; 131  : 				image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax

; 132  : 			}

	jmp	SHORT $LN39@Image_Load
$LN38@Image_Load:

; 133  : 			else palette[i][3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH
$LN39@Image_Load:

; 134  : 		}

	jmp	$LN5@Image_Load
$LN6@Image_Load:

; 135  : 	}
; 136  : 
; 137  : 	if( Image_CheckFlag( IL_KEEP_8BIT ) && bhdr.bitsPerPixel == 8 )

	push	2
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	$LN40@Image_Load
	movzx	eax, WORD PTR _bhdr$[ebp+28]
	cmp	eax, 8
	jne	$LN40@Image_Load

; 138  : 	{
; 139  : 		pixbuf = image.palette = Mem_Malloc( host.imagepool, 1024 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadBMP@@9@9
	add	eax, 114				; 00000072H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+72, eax
	mov	edx, DWORD PTR _image+72
	mov	DWORD PTR _pixbuf$[ebp], edx

; 140  : 
; 141  : 		// bmp have a reversed palette colors
; 142  : 		for( i = 0; i < bhdr.colors; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Image_Load
$LN8@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bhdr$[ebp+46]
	jae	$LN9@Image_Load

; 143  : 		{
; 144  : 			*pixbuf++ = palette[i][2];

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 145  : 			*pixbuf++ = palette[i][1];

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 146  : 			*pixbuf++ = palette[i][0];

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 147  : 			*pixbuf++ = palette[i][3];

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 148  : 		}

	jmp	$LN8@Image_Load
$LN9@Image_Load:

; 149  : 		image.type = PF_INDEXED_32; // 32 bit palette

	mov	DWORD PTR _image+20, 2

; 150  : 	}

	jmp	SHORT $LN41@Image_Load
$LN40@Image_Load:

; 151  : 	else
; 152  : 	{
; 153  : 		image.palette = NULL;

	mov	DWORD PTR _image+72, 0

; 154  : 		image.type = PF_RGBA_32;

	mov	DWORD PTR _image+20, 3

; 155  : 		bpp = 4;

	mov	DWORD PTR _bpp$[ebp], 4
$LN41@Image_Load:

; 156  : 	}
; 157  : 
; 158  : 	buf_p += cbPalBytes;

	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, DWORD PTR _cbPalBytes$[ebp]
	mov	DWORD PTR _buf_p$[ebp], eax

; 159  : 	image.size = image.width * image.height * bpp;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	imul	eax, DWORD PTR _bpp$[ebp]
	mov	DWORD PTR _image+28, eax

; 160  : 	image.rgba = Mem_Malloc( host.imagepool, image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadBMP@@9@9
	add	eax, 135				; 00000087H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 161  : 	bps = image.width * (bhdr.bitsPerPixel >> 3);

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _bhdr$[ebp+28]
	sar	ecx, 3
	imul	eax, ecx
	mov	DWORD PTR _bps$[ebp], eax

; 162  : 
; 163  : 	switch( bhdr.bitsPerPixel )

	movzx	eax, WORD PTR _bhdr$[ebp+28]
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR tv300[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv300[ebp], ecx
	cmp	DWORD PTR tv300[ebp], 23		; 00000017H
	ja	$LN11@Image_Load
	mov	edx, DWORD PTR tv300[ebp]
	movzx	eax, BYTE PTR $LN71@Image_Load[edx]
	jmp	DWORD PTR $LN72@Image_Load[eax*4]
$LN42@Image_Load:

; 164  : 	{
; 165  : 	case 1:
; 166  : 		padSize = (( 32 - ( bhdr.width % 32 )) / 8 ) % 4;

	mov	eax, DWORD PTR _bhdr$[ebp+18]
	and	eax, -2147483617			; 8000001fH
	jns	SHORT $LN75@Image_Load
	dec	eax
	or	eax, -32				; ffffffe0H
	inc	eax
$LN75@Image_Load:
	mov	ecx, 32					; 00000020H
	sub	ecx, eax
	mov	eax, ecx
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN76@Image_Load
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN76@Image_Load:
	mov	DWORD PTR _padSize$[ebp], eax

; 167  : 		break;

	jmp	$LN11@Image_Load
$LN43@Image_Load:

; 168  : 	case 4:
; 169  : 		padSize = (( 8 - ( bhdr.width % 8 )) / 2 ) % 4;

	mov	eax, DWORD PTR _bhdr$[ebp+18]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN77@Image_Load
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN77@Image_Load:
	mov	ecx, 8
	sub	ecx, eax
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN78@Image_Load
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN78@Image_Load:
	mov	DWORD PTR _padSize$[ebp], eax

; 170  : 		break;

	jmp	SHORT $LN11@Image_Load
$LN44@Image_Load:

; 171  : 	case 16:
; 172  : 		padSize = ( 4 - ( image.width * 2 % 4 )) % 4;

	movzx	eax, WORD PTR _image+8
	shl	eax, 1
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN79@Image_Load
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN79@Image_Load:
	mov	ecx, 4
	sub	ecx, eax
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN80@Image_Load
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN80@Image_Load:
	mov	DWORD PTR _padSize$[ebp], ecx

; 173  : 		break;

	jmp	SHORT $LN11@Image_Load
$LN45@Image_Load:

; 174  : 	case 8:
; 175  : 	case 24:
; 176  : 		padSize = ( 4 - ( bps % 4 )) % 4;

	mov	eax, DWORD PTR _bps$[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN81@Image_Load
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN81@Image_Load:
	mov	ecx, 4
	sub	ecx, eax
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN82@Image_Load
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN82@Image_Load:
	mov	DWORD PTR _padSize$[ebp], ecx
$LN11@Image_Load:

; 177  : 		break;
; 178  : 	}
; 179  : 
; 180  : 	for( row = rows - 1; row >= 0; row-- )

	mov	eax, DWORD PTR _rows$[ebp]
	sub	eax, 1
	mov	DWORD PTR _row$[ebp], eax
	jmp	SHORT $LN15@Image_Load
$LN13@Image_Load:
	mov	eax, DWORD PTR _row$[ebp]
	sub	eax, 1
	mov	DWORD PTR _row$[ebp], eax
$LN15@Image_Load:
	cmp	DWORD PTR _row$[ebp], 0
	jl	$LN14@Image_Load

; 181  : 	{
; 182  : 		pixbuf = image.rgba + (row * columns * bpp);

	mov	eax, DWORD PTR _row$[ebp]
	imul	eax, DWORD PTR _columns$[ebp]
	imul	eax, DWORD PTR _bpp$[ebp]
	add	eax, DWORD PTR _image+40
	mov	DWORD PTR _pixbuf$[ebp], eax

; 183  : 
; 184  : 		for( column = 0; column < columns; column++ )

	mov	DWORD PTR _column$[ebp], 0
	jmp	SHORT $LN18@Image_Load
$LN16@Image_Load:
	mov	eax, DWORD PTR _column$[ebp]
	add	eax, 1
	mov	DWORD PTR _column$[ebp], eax
$LN18@Image_Load:
	mov	eax, DWORD PTR _column$[ebp]
	cmp	eax, DWORD PTR _columns$[ebp]
	jge	$LN17@Image_Load

; 185  : 		{
; 186  : 			byte	red, green, blue, alpha;
; 187  : 			word	shortPixel;
; 188  : 			int	c, k, palIndex;
; 189  : 
; 190  : 			switch( bhdr.bitsPerPixel )

	movzx	eax, WORD PTR _bhdr$[ebp+28]
	mov	DWORD PTR tv328[ebp], eax
	mov	ecx, DWORD PTR tv328[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv328[ebp], ecx
	cmp	DWORD PTR tv328[ebp], 31		; 0000001fH
	ja	$LN62@Image_Load
	mov	edx, DWORD PTR tv328[ebp]
	movzx	eax, BYTE PTR $LN73@Image_Load[edx]
	jmp	DWORD PTR $LN74@Image_Load[eax*4]
$LN47@Image_Load:

; 191  : 			{
; 192  : 			case 1:
; 193  : 				alpha = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _alpha$5[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 194  : 				column--;	// ingnore main iterations

	mov	eax, DWORD PTR _column$[ebp]
	sub	eax, 1
	mov	DWORD PTR _column$[ebp], eax

; 195  : 				for( c = 0, k = 128; c < 8; c++, k >>= 1 )

	mov	DWORD PTR _c$3[ebp], 0
	mov	DWORD PTR _k$2[ebp], 128		; 00000080H
	jmp	SHORT $LN23@Image_Load
$LN21@Image_Load:
	mov	eax, DWORD PTR _c$3[ebp]
	add	eax, 1
	mov	DWORD PTR _c$3[ebp], eax
	mov	ecx, DWORD PTR _k$2[ebp]
	sar	ecx, 1
	mov	DWORD PTR _k$2[ebp], ecx
$LN23@Image_Load:
	cmp	DWORD PTR _c$3[ebp], 8
	jge	$LN22@Image_Load

; 196  : 				{
; 197  : 					red = green = blue = (!!(alpha & k) == 1 ? 0xFF : 0x00);

	movzx	eax, BYTE PTR _alpha$5[ebp]
	and	eax, DWORD PTR _k$2[ebp]
	je	SHORT $LN67@Image_Load
	mov	DWORD PTR tv337[ebp], 1
	jmp	SHORT $LN68@Image_Load
$LN67@Image_Load:
	mov	DWORD PTR tv337[ebp], 0
$LN68@Image_Load:
	cmp	DWORD PTR tv337[ebp], 1
	jne	SHORT $LN69@Image_Load
	mov	DWORD PTR tv339[ebp], 255		; 000000ffH
	jmp	SHORT $LN70@Image_Load
$LN69@Image_Load:
	mov	DWORD PTR tv339[ebp], 0
$LN70@Image_Load:
	mov	cl, BYTE PTR tv339[ebp]
	mov	BYTE PTR _blue$6[ebp], cl
	mov	dl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR _green$7[ebp], dl
	mov	al, BYTE PTR _green$7[ebp]
	mov	BYTE PTR _red$8[ebp], al

; 198  : 					*pixbuf++ = red;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 199  : 					*pixbuf++ = green;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 200  : 					*pixbuf++ = blue;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 201  : 					*pixbuf++ = 0x00;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 202  : 					if( ++column == columns )

	mov	eax, DWORD PTR _column$[ebp]
	add	eax, 1
	mov	DWORD PTR _column$[ebp], eax
	mov	ecx, DWORD PTR _column$[ebp]
	cmp	ecx, DWORD PTR _columns$[ebp]
	jne	SHORT $LN48@Image_Load

; 203  : 						break;

	jmp	SHORT $LN22@Image_Load
$LN48@Image_Load:

; 204  : 				}

	jmp	$LN21@Image_Load
$LN22@Image_Load:

; 205  : 				break;

	jmp	$LN19@Image_Load
$LN49@Image_Load:

; 206  : 			case 4:
; 207  : 				alpha = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _alpha$5[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 208  : 				palIndex = alpha >> 4;

	movzx	eax, BYTE PTR _alpha$5[ebp]
	sar	eax, 4
	mov	DWORD PTR _palIndex$1[ebp], eax

; 209  : 				if( load_qfont )

	cmp	DWORD PTR _load_qfont$[ebp], 0
	je	SHORT $LN50@Image_Load

; 210  : 				{
; 211  : 					*pixbuf++ = red = 255;

	mov	BYTE PTR _red$8[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 212  : 					*pixbuf++ = green = 255;

	mov	BYTE PTR _green$7[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 213  : 					*pixbuf++ = blue = 255;

	mov	BYTE PTR _blue$6[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 214  : 					*pixbuf++ = palette[palIndex][2];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 215  : 				}

	jmp	$LN51@Image_Load
$LN50@Image_Load:

; 216  : 				else
; 217  : 				{
; 218  : 					*pixbuf++ = red = palette[palIndex][2];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _red$8[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 219  : 					*pixbuf++ = green = palette[palIndex][1];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _green$7[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 220  : 					*pixbuf++ = blue = palette[palIndex][0];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _blue$6[ebp], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 221  : 					*pixbuf++ = palette[palIndex][3];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx
$LN51@Image_Load:

; 222  : 				}
; 223  : 				if( ++column == columns ) break;

	mov	eax, DWORD PTR _column$[ebp]
	add	eax, 1
	mov	DWORD PTR _column$[ebp], eax
	mov	ecx, DWORD PTR _column$[ebp]
	cmp	ecx, DWORD PTR _columns$[ebp]
	jne	SHORT $LN52@Image_Load
	jmp	$LN19@Image_Load
$LN52@Image_Load:

; 224  : 				palIndex = alpha & 0x0F;

	movzx	eax, BYTE PTR _alpha$5[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _palIndex$1[ebp], eax

; 225  : 				if( load_qfont )

	cmp	DWORD PTR _load_qfont$[ebp], 0
	je	SHORT $LN53@Image_Load

; 226  : 				{
; 227  : 					*pixbuf++ = red = 255;

	mov	BYTE PTR _red$8[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 228  : 					*pixbuf++ = green = 255;

	mov	BYTE PTR _green$7[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 229  : 					*pixbuf++ = blue = 255;

	mov	BYTE PTR _blue$6[ebp], 255		; 000000ffH
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 230  : 					*pixbuf++ = palette[palIndex][2];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 231  : 				}

	jmp	$LN54@Image_Load
$LN53@Image_Load:

; 232  : 				else
; 233  : 				{
; 234  : 					*pixbuf++ = red = palette[palIndex][2];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _red$8[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 235  : 					*pixbuf++ = green = palette[palIndex][1];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _green$7[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 236  : 					*pixbuf++ = blue = palette[palIndex][0];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _blue$6[ebp], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 237  : 					*pixbuf++ = palette[palIndex][3];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _pixbuf$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx
$LN54@Image_Load:

; 238  : 				}
; 239  : 				break;

	jmp	$LN19@Image_Load
$LN55@Image_Load:

; 240  : 			case 8:
; 241  : 				palIndex = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _palIndex$1[ebp], ecx
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 242  : 				red = palette[palIndex][2];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _red$8[ebp], al

; 243  : 				green = palette[palIndex][1];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _green$7[ebp], al

; 244  : 				blue = palette[palIndex][0];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _blue$6[ebp], cl

; 245  : 				alpha = palette[palIndex][3];

	mov	eax, DWORD PTR _palIndex$1[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _alpha$5[ebp], cl

; 246  : 
; 247  : 				if( Image_CheckFlag( IL_KEEP_8BIT ))

	push	2
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	SHORT $LN56@Image_Load

; 248  : 				{
; 249  : 					*pixbuf++ = palIndex;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _palIndex$1[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 250  : 				}

	jmp	SHORT $LN57@Image_Load
$LN56@Image_Load:

; 251  : 				else
; 252  : 				{
; 253  : 					*pixbuf++ = red;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 254  : 					*pixbuf++ = green;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 255  : 					*pixbuf++ = blue;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 256  : 					*pixbuf++ = alpha;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _alpha$5[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx
$LN57@Image_Load:

; 257  : 				}
; 258  : 				break;

	jmp	$LN19@Image_Load
$LN58@Image_Load:

; 259  : 			case 16:
; 260  : 				shortPixel = *(word *)buf_p, buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _shortPixel$4[ebp], cx
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 2
	mov	DWORD PTR _buf_p$[ebp], edx

; 261  : 				*pixbuf++ = blue = (shortPixel & ( 31 << 10 )) >> 7;

	movzx	eax, WORD PTR _shortPixel$4[ebp]
	and	eax, 31744				; 00007c00H
	sar	eax, 7
	mov	BYTE PTR _blue$6[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 262  : 				*pixbuf++ = green = (shortPixel & ( 31 << 5 )) >> 2;

	movzx	eax, WORD PTR _shortPixel$4[ebp]
	and	eax, 992				; 000003e0H
	sar	eax, 2
	mov	BYTE PTR _green$7[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 263  : 				*pixbuf++ = red = (shortPixel & ( 31 )) << 3;

	movzx	eax, WORD PTR _shortPixel$4[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 3
	mov	BYTE PTR _red$8[ebp], al
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	mov	dl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pixbuf$[ebp], eax

; 264  : 				*pixbuf++ = 0xff;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 265  : 				break;

	jmp	$LN19@Image_Load
$LN59@Image_Load:

; 266  : 			case 24:
; 267  : 				blue = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _blue$6[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 268  : 				green = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _green$7[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 269  : 				red = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _red$8[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 270  : 				*pixbuf++ = red;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 271  : 				*pixbuf++ = green;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 272  : 				*pixbuf++ = blue;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 273  : 				*pixbuf++ = 0xFF;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _pixbuf$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pixbuf$[ebp], ecx

; 274  : 				break;

	jmp	$LN19@Image_Load
$LN60@Image_Load:

; 275  : 			case 32:
; 276  : 				blue = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _blue$6[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 277  : 				green = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _green$7[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 278  : 				red = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _red$8[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 279  : 				alpha = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _alpha$5[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 280  : 				*pixbuf++ = red;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$8[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 281  : 				*pixbuf++ = green;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$7[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 282  : 				*pixbuf++ = blue;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$6[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 283  : 				*pixbuf++ = alpha;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _alpha$5[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 284  : 				if( alpha != 255 ) image.flags |= IMAGE_HAS_ALPHA;

	movzx	eax, BYTE PTR _alpha$5[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN61@Image_Load
	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
$LN61@Image_Load:

; 285  : 				break;

	jmp	SHORT $LN19@Image_Load
$LN62@Image_Load:

; 286  : 			default:
; 287  : 				Mem_Free( image.palette );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadBMP@@9@9
	add	eax, 262				; 00000106H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _image+72
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 288  : 				Mem_Free( image.rgba );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadBMP@@9@9
	add	eax, 263				; 00000107H
	push	eax
	push	OFFSET ??_C@_0DN@JCMIBFEE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _image+40
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 289  : 				return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN19@Image_Load:

; 290  : 			}
; 291  : 
; 292  : 			if( red != green || green != blue )

	movzx	eax, BYTE PTR _red$8[ebp]
	movzx	ecx, BYTE PTR _green$7[ebp]
	cmp	eax, ecx
	jne	SHORT $LN64@Image_Load
	movzx	eax, BYTE PTR _green$7[ebp]
	movzx	ecx, BYTE PTR _blue$6[ebp]
	cmp	eax, ecx
	je	SHORT $LN63@Image_Load
$LN64@Image_Load:

; 293  : 				image.flags |= IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax
$LN63@Image_Load:

; 294  : 
; 295  : 			reflectivity[0] += red;

	mov	eax, 4
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _red$8[ebp]
	add	edx, DWORD PTR _reflectivity$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _reflectivity$[ebp+ecx], edx

; 296  : 			reflectivity[1] += green;

	mov	eax, 4
	shl	eax, 0
	movzx	ecx, BYTE PTR _green$7[ebp]
	add	ecx, DWORD PTR _reflectivity$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _reflectivity$[ebp+edx], ecx

; 297  : 			reflectivity[2] += blue;

	mov	eax, 4
	shl	eax, 1
	movzx	ecx, BYTE PTR _blue$6[ebp]
	add	ecx, DWORD PTR _reflectivity$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _reflectivity$[ebp+edx], ecx

; 298  : 		}

	jmp	$LN16@Image_Load
$LN17@Image_Load:

; 299  : 		buf_p += padSize;	// actual only for 4-bit bmps

	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, DWORD PTR _padSize$[ebp]
	mov	DWORD PTR _buf_p$[ebp], eax

; 300  : 	}

	jmp	$LN13@Image_Load
$LN14@Image_Load:

; 301  : 
; 302  : 	VectorDivide( reflectivity, ( image.width * image.height ), image.fogParams );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cvtsi2ss xmm1, edx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	ecx, 1
	imul	edx, ecx, 0
	cvttss2si eax, xmm0
	mov	BYTE PTR _image[edx+76], al
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cvtsi2ss xmm1, edx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	ecx, 1
	shl	ecx, 0
	cvttss2si edx, xmm0
	mov	BYTE PTR _image[ecx+76], dl
	mov	eax, 4
	shl	eax, 1
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+eax]
	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	eax, 1
	shl	eax, 1
	cvttss2si ecx, xmm0
	mov	BYTE PTR _image[eax+76], cl

; 303  : 	if( image.palette ) Image_GetPaletteBMP( image.palette );

	cmp	DWORD PTR _image+72, 0
	je	SHORT $LN65@Image_Load
	mov	eax, DWORD PTR _image+72
	push	eax
	call	_Image_GetPaletteBMP
	add	esp, 4
$LN65@Image_Load:

; 304  : 	image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax

; 305  : 
; 306  : 	return true;

	mov	eax, 1
$LN1@Image_Load:

; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@Image_Load:
	DD	$LN42@Image_Load
	DD	$LN43@Image_Load
	DD	$LN45@Image_Load
	DD	$LN44@Image_Load
	DD	$LN11@Image_Load
$LN71@Image_Load:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
$LN74@Image_Load:
	DD	$LN47@Image_Load
	DD	$LN49@Image_Load
	DD	$LN55@Image_Load
	DD	$LN58@Image_Load
	DD	$LN59@Image_Load
	DD	$LN60@Image_Load
	DD	$LN62@Image_Load
$LN73@Image_Load:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_Image_LoadBMP ENDP
_TEXT	ENDS
END
