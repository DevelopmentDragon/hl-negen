; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_world.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_sv_areanodes:BYTE:0500H
_DATA	ENDS
PUBLIC	_SV_TestEntityPosition
PUBLIC	_SV_ClearWorld
PUBLIC	_SV_UnlinkEdict
PUBLIC	_SV_ClipMoveToEntity
PUBLIC	_SV_CustomClipMoveToEntity
PUBLIC	_SV_Move
PUBLIC	_SV_MoveNoEnts
PUBLIC	_SV_MoveNormal
PUBLIC	_SV_TraceTexture
PUBLIC	_SV_TraceSurface
PUBLIC	_SV_MoveToss
PUBLIC	_SV_LinkEdict
PUBLIC	_SV_TouchLinks
PUBLIC	_SV_TruePointContents
PUBLIC	_SV_PointContents
PUBLIC	_SV_RunLightStyles
PUBLIC	_SV_SetLightStyle
PUBLIC	_SV_GetLightStyle
PUBLIC	_SV_LightForEntity
PUBLIC	_SV_InitBoxHull
PUBLIC	_SV_StudioPlayerBlend
PUBLIC	_SV_CheckSphereIntersection
PUBLIC	_SV_HullForBox
PUBLIC	_SV_HullAutoSelect
PUBLIC	_SV_HullForBsp
PUBLIC	_SV_HullForEntity
PUBLIC	_SV_HullForStudioModel
PUBLIC	_SV_CreateAreaNode
PUBLIC	_SV_FindTouchedLeafs
PUBLIC	_SV_WaterLinks
PUBLIC	_SV_PortalCSG
PUBLIC	_SV_ClipToWorldBrush
PUBLIC	??_C@_0DC@MLEANCHK@Entity?5?$CFi?5?$CI?$CFs?$CJ?5SOLID_BSP?5with?5a@ ; `string'
PUBLIC	??_C@_0DP@NEODGGBA@?8?$CFs?8?5has?5SOLID_BSP?5without?5MOVE@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_LinkEdict@@9@9		; `SV_LinkEdict'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_TestEntityPosition@@9@9	; `SV_TestEntityPosition'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_ClipToEntity@@9@9		; `SV_ClipToEntity'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@EDIMEKPL@trigger?5in?5clipping?5list?6@ ; `string'
PUBLIC	??_C@_0CC@DPHHNEEJ@SV_GetLightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40400000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41700000
PUBLIC	__real@41c00000
PUBLIC	__real@42000000
PUBLIC	__real@42100000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@4479c000
PUBLIC	__real@c1700000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Host_Error:PROC
EXTRN	_fabs:PROC
EXTRN	__imp__floor:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_BoundsIntersect:PROC
EXTRN	_SphereIntersect:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_Mod_StudioExtradata:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_Mod_HullForStudio:PROC
EXTRN	_Mod_HitgroupForStudioHull:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteFloat:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_InsertLinkBefore:PROC
EXTRN	_RemoveLink:PROC
EXTRN	_ClearLink:PROC
EXTRN	_World_MoveBounds:PROC
EXTRN	_World_TransformAABB:PROC
EXTRN	_World_CombineTraces:PROC
EXTRN	_BoxOnPlaneSide:PROC
EXTRN	_RankForContents:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_CheckVelocity:PROC
EXTRN	_SV_ClassName:PROC
EXTRN	_SV_CopyTraceToGlobal:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_SetMinMaxSize:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_PM_RecursiveHullCheck:PROC
EXTRN	_PM_HullPointContents:PROC
EXTRN	_PM_RecursiveSurfCheck:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_world:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_clienttrace:BYTE
EXTRN	_sv_lighting_modulate:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_box_hull DB	028H DUP (?)
_box_clipnodes DQ 06H DUP (?)
_box_planes DB	078H DUP (?)
_iTouchLinkSemaphore DD 01H DUP (?)
_sv_numareanodes DD 01H DUP (?)
_sv_pointColor DD 03H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c1700000
CONST	SEGMENT
__real@c1700000 DD 0c1700000r			; -15
CONST	ENDS
;	COMDAT __real@4479c000
CONST	SEGMENT
__real@4479c000 DD 04479c000r			; 999
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42100000
CONST	SEGMENT
__real@42100000 DD 042100000r			; 36
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CC@DPHHNEEJ@SV_GetLightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5@
CONST	SEGMENT
??_C@_0CC@DPHHNEEJ@SV_GetLightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5@ DB 'SV'
	DB	'_GetLightStyle: style: %i >= %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EDIMEKPL@trigger?5in?5clipping?5list?6@
CONST	SEGMENT
??_C@_0BK@EDIMEKPL@trigger?5in?5clipping?5list?6@ DB 'trigger in clipping'
	DB	' list', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ClipToEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ClipToEntity@@9@9 DD 0475H		; `SV_ClipToEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_TestEntityPosition@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_TestEntityPosition@@9@9 DD 0337H	; `SV_TestEntityPosition'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_world.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_LinkEdict@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_LinkEdict@@9@9 DD 0279H		; `SV_LinkEdict'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DP@NEODGGBA@?8?$CFs?8?5has?5SOLID_BSP?5without?5MOVE@
CONST	SEGMENT
??_C@_0DP@NEODGGBA@?8?$CFs?8?5has?5SOLID_BSP?5without?5MOVE@ DB '''%s'' h'
	DB	'as SOLID_BSP without MOVETYPE_PUSH or MOVETYPE_PUSHSTEP', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MLEANCHK@Entity?5?$CFi?5?$CI?$CFs?$CJ?5SOLID_BSP?5with?5a@
CONST	SEGMENT
??_C@_0DC@MLEANCHK@Entity?5?$CFi?5?$CI?$CFs?$CJ?5SOLID_BSP?5with?5a@ DB 'E'
	DB	'ntity %i (%s) SOLID_BSP with a non bsp model %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0855H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	017cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0d76H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0322H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0333H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04bdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	023aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	04a7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	031aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	029eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0213H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0388H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0628H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	025aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0254H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02fcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0a77H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	018cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_RecursiveLightPoint
_TEXT	SEGMENT
tv401 = -164						; size = 4
tv453 = -160						; size = 4
tv390 = -160						; size = 4
tv237 = -160						; size = 4
tv226 = -160						; size = 4
tv178 = -160						; size = 4
tv176 = -160						; size = 4
tv170 = -160						; size = 4
tv132 = -160						; size = 4
_tmax$1 = -92						; size = 4
_smax$2 = -88						; size = 4
_mid$ = -84						; size = 12
_lm$ = -72						; size = 4
_info$ = -68						; size = 4
_tex$ = -64						; size = 4
_surf$ = -60						; size = 4
_sample_size$ = -56					; size = 4
_t$ = -52						; size = 4
_s$ = -48						; size = 4
_dt$ = -44						; size = 4
_ds$ = -40						; size = 4
_size$ = -36						; size = 4
_side$ = -32						; size = 4
_map$ = -28						; size = 4
_i$ = -24						; size = 4
_frac$ = -20						; size = 4
_scale$ = -16						; size = 4
_back$ = -12						; size = 4
_front$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_node$ = 12						; size = 4
_start$ = 16						; size = 4
_end$ = 20						; size = 4
_SV_RecursiveLightPoint PROC				; COMDAT

; 1559 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1560 : 	float		front, back, scale, frac;
; 1561 : 	int		i, map, side, size;
; 1562 : 	float		ds, dt, s, t;
; 1563 : 	int		sample_size;
; 1564 : 	msurface_t	*surf;
; 1565 : 	mtexinfo_t	*tex;
; 1566 : 	mextrasurf_t	*info;
; 1567 : 	color24		*lm;
; 1568 : 	vec3_t		mid;
; 1569 : 
; 1570 : 	// didn't hit anything
; 1571 : 	if( !node || node->contents < 0 )

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN9@SV_Recursi
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN8@SV_Recursi
$LN9@SV_Recursi:

; 1572 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_Recursi
$LN8@SV_Recursi:

; 1573 : 
; 1574 : 	// calculate mid point
; 1575 : 	front = PlaneDiff( start, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN20@SV_Recursi
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN21@SV_Recursi
$LN20@SV_Recursi:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv132[ebp], xmm0
$LN21@SV_Recursi:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv132[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _front$[ebp], xmm0

; 1576 : 	back = PlaneDiff( end, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN22@SV_Recursi
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN23@SV_Recursi
$LN22@SV_Recursi:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv170[ebp], xmm0
$LN23@SV_Recursi:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv170[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _back$[ebp], xmm0

; 1577 : 
; 1578 : 	side = front < 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN24@SV_Recursi
	mov	DWORD PTR tv176[ebp], 1
	jmp	SHORT $LN25@SV_Recursi
$LN24@SV_Recursi:
	mov	DWORD PTR tv176[ebp], 0
$LN25@SV_Recursi:
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 1579 : 	if(( back < 0.0f ) == side )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN26@SV_Recursi
	mov	DWORD PTR tv178[ebp], 1
	jmp	SHORT $LN27@SV_Recursi
$LN26@SV_Recursi:
	mov	DWORD PTR tv178[ebp], 0
$LN27@SV_Recursi:
	mov	eax, DWORD PTR tv178[ebp]
	cmp	eax, DWORD PTR _side$[ebp]
	jne	SHORT $LN10@SV_Recursi

; 1580 : 		return SV_RecursiveLightPoint( model, node->children[side], start, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_SV_RecursiveLightPoint
	add	esp, 16					; 00000010H
	jmp	$LN1@SV_Recursi
$LN10@SV_Recursi:

; 1581 : 
; 1582 : 	frac = front / ( front - back );

	movss	xmm0, DWORD PTR _front$[ebp]
	subss	xmm0, DWORD PTR _back$[ebp]
	movss	xmm1, DWORD PTR _front$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 1583 : 
; 1584 : 	VectorLerp( start, frac, end, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv226[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv226[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 1585 : 
; 1586 : 	// co down front side	
; 1587 : 	if( SV_RecursiveLightPoint( model, node->children[side], start, mid ))

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_SV_RecursiveLightPoint
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN11@SV_Recursi

; 1588 : 		return true; // hit something

	mov	eax, 1
	jmp	$LN1@SV_Recursi
$LN11@SV_Recursi:

; 1589 : 
; 1590 : 	if(( back < 0.0f ) == side )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN28@SV_Recursi
	mov	DWORD PTR tv237[ebp], 1
	jmp	SHORT $LN29@SV_Recursi
$LN28@SV_Recursi:
	mov	DWORD PTR tv237[ebp], 0
$LN29@SV_Recursi:
	mov	eax, DWORD PTR tv237[ebp]
	cmp	eax, DWORD PTR _side$[ebp]
	jne	SHORT $LN12@SV_Recursi

; 1591 : 		return false;// didn't hit anything

	xor	eax, eax
	jmp	$LN1@SV_Recursi
$LN12@SV_Recursi:

; 1592 : 
; 1593 : 	// check for impact on this node
; 1594 : 	surf = model->surfaces + node->firstsurface;

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _model$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], edx

; 1595 : 
; 1596 : 	for( i = 0; i < node->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Recursi
$LN2@SV_Recursi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN4@SV_Recursi:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN3@SV_Recursi

; 1597 : 	{
; 1598 : 		int	smax, tmax;
; 1599 : 
; 1600 : 		tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 1601 : 		info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 1602 : 
; 1603 : 		if( FBitSet( surf->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN13@SV_Recursi

; 1604 : 			continue;	// no lightmaps

	jmp	SHORT $LN2@SV_Recursi
$LN13@SV_Recursi:

; 1605 : 
; 1606 : 		s = DotProduct( mid, info->lmvecs[0] ) + info->lmvecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _s$[ebp], xmm0

; 1607 : 		t = DotProduct( mid, info->lmvecs[1] ) + info->lmvecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _t$[ebp], xmm0

; 1608 : 
; 1609 : 		if( s < info->lightmapmins[0] || t < info->lightmapmins[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR _s$[ebp]
	ja	SHORT $LN15@SV_Recursi
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	comiss	xmm0, DWORD PTR _t$[ebp]
	jbe	SHORT $LN14@SV_Recursi
$LN15@SV_Recursi:

; 1610 : 			continue;

	jmp	$LN2@SV_Recursi
$LN14@SV_Recursi:

; 1611 : 
; 1612 : 		ds = s - info->lightmapmins[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _ds$[ebp], xmm1

; 1613 : 		dt = t - info->lightmapmins[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _t$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _dt$[ebp], xmm1

; 1614 : 		
; 1615 : 		if ( ds > info->lightextents[0] || dt > info->lightextents[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _ds$[ebp]
	comiss	xmm1, xmm0
	ja	SHORT $LN17@SV_Recursi
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+52]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dt$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@SV_Recursi
$LN17@SV_Recursi:

; 1616 : 			continue;

	jmp	$LN2@SV_Recursi
$LN16@SV_Recursi:

; 1617 : 
; 1618 : 		if( !surf->samples )

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN18@SV_Recursi

; 1619 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_Recursi
$LN18@SV_Recursi:

; 1620 : 
; 1621 : 		sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 1622 : 		smax = (info->lightextents[0] / sample_size) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$2[ebp], eax

; 1623 : 		tmax = (info->lightextents[1] / sample_size) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$1[ebp], eax

; 1624 : 		ds /= sample_size;

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _ds$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _ds$[ebp], xmm1

; 1625 : 		dt /= sample_size;

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _dt$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _dt$[ebp], xmm1

; 1626 : 
; 1627 : 		VectorClear( sv_pointColor );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _sv_pointColor[eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _sv_pointColor[ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _sv_pointColor[eax], xmm0

; 1628 : 
; 1629 : 		lm = surf->samples + Q_rint( dt ) * smax + Q_rint( ds );

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dt$[ebp]
	jbe	SHORT $LN30@SV_Recursi
	movss	xmm0, DWORD PTR _dt$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv390[ebp], eax
	jmp	SHORT $LN31@SV_Recursi
$LN30@SV_Recursi:
	movss	xmm0, DWORD PTR _dt$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv390[ebp], ecx
$LN31@SV_Recursi:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _ds$[ebp]
	jbe	SHORT $LN32@SV_Recursi
	movss	xmm0, DWORD PTR _ds$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv401[ebp], edx
	jmp	SHORT $LN33@SV_Recursi
$LN32@SV_Recursi:
	movss	xmm0, DWORD PTR _ds$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv401[ebp], eax
$LN33@SV_Recursi:
	mov	ecx, DWORD PTR tv390[ebp]
	imul	ecx, DWORD PTR _smax$2[ebp]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, edx
	imul	edx, DWORD PTR tv401[ebp], 3
	add	ecx, edx
	mov	DWORD PTR _lm$[ebp], ecx

; 1630 : 		size = smax * tmax;

	mov	eax, DWORD PTR _smax$2[ebp]
	imul	eax, DWORD PTR _tmax$1[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 1631 : 
; 1632 : 		for( map = 0; map < MAXLIGHTMAPS && surf->styles[map] != 255; map++ )

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN7@SV_Recursi
$LN5@SV_Recursi:
	mov	eax, DWORD PTR _map$[ebp]
	add	eax, 1
	mov	DWORD PTR _map$[ebp], eax
$LN7@SV_Recursi:
	cmp	DWORD PTR _map$[ebp], 4
	jge	$LN6@SV_Recursi
	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	$LN6@SV_Recursi

; 1633 : 		{
; 1634 : 			scale = sv.lightstyles[surf->styles[map]].value;

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	imul	edx, ecx, 1296
	movss	xmm0, DWORD PTR _sv[edx+727500]
	movss	DWORD PTR _scale$[ebp], xmm0

; 1635 : 
; 1636 : 			sv_pointColor[0] += lm->r * scale;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lm$[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _scale$[ebp]
	addss	xmm0, DWORD PTR _sv_pointColor[ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _sv_pointColor[edx], xmm0

; 1637 : 			sv_pointColor[1] += lm->g * scale;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lm$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _scale$[ebp]
	addss	xmm0, DWORD PTR _sv_pointColor[eax]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _sv_pointColor[eax], xmm0

; 1638 : 			sv_pointColor[2] += lm->b * scale;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lm$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _scale$[ebp]
	addss	xmm0, DWORD PTR _sv_pointColor[eax]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _sv_pointColor[eax], xmm0

; 1639 : 
; 1640 : 			lm += size; // skip to next lightmap

	imul	eax, DWORD PTR _size$[ebp], 3
	add	eax, DWORD PTR _lm$[ebp]
	mov	DWORD PTR _lm$[ebp], eax

; 1641 : 		}

	jmp	$LN5@SV_Recursi
$LN6@SV_Recursi:

; 1642 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Recursi

; 1643 : 	}

	jmp	$LN2@SV_Recursi
$LN3@SV_Recursi:

; 1644 : 
; 1645 : 	// go down back side
; 1646 : 	return SV_RecursiveLightPoint( model, node->children[!side], mid, end );

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN34@SV_Recursi
	mov	DWORD PTR tv453[ebp], 1
	jmp	SHORT $LN35@SV_Recursi
$LN34@SV_Recursi:
	mov	DWORD PTR tv453[ebp], 0
$LN35@SV_Recursi:
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv453[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_SV_RecursiveLightPoint
	add	esp, 16					; 00000010H
$LN1@SV_Recursi:

; 1647 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RecursiveLightPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClipToWorldBrush
_TEXT	SEGMENT
$T1 = -192						; size = 56
_trace$ = -72						; size = 56
_touch$ = -16						; size = 4
_next$ = -12						; size = 4
_l$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_clip$ = 12						; size = 4
_SV_ClipToWorldBrush PROC				; COMDAT

; 1309 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1310 : 	link_t	*l, *next;
; 1311 : 	edict_t	*touch;
; 1312 : 	trace_t	trace;
; 1313 : 
; 1314 : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_ClipToW
$LN2@SV_ClipToW:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_ClipToW:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_ClipToW

; 1315 : 	{
; 1316 : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 1317 : 
; 1318 : 		touch = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _touch$[ebp], eax

; 1319 : 
; 1320 : 		if( touch->v.solid != SOLID_BSP || touch == clip->passedict || !( touch->v.flags & FL_WORLDBRUSH ))

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 4
	jne	SHORT $LN6@SV_ClipToW
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR _touch$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	je	SHORT $LN6@SV_ClipToW
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 33554432				; 02000000H
	jne	SHORT $LN5@SV_ClipToW
$LN6@SV_ClipToW:

; 1321 : 			continue;

	jmp	SHORT $LN2@SV_ClipToW
$LN5@SV_ClipToW:

; 1322 : 
; 1323 : 		if( !BoundsIntersect( clip->boxmins, clip->boxmaxs, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN7@SV_ClipToW

; 1324 : 			continue;

	jmp	SHORT $LN2@SV_ClipToW
$LN7@SV_ClipToW:

; 1325 : 
; 1326 : 		if( clip->trace.allsolid ) return;

	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN8@SV_ClipToW
	jmp	$LN11@SV_ClipToW
$LN8@SV_ClipToW:

; 1327 : 
; 1328 : 		SV_ClipMoveToEntity( touch, clip->start, clip->mins, clip->maxs, clip->end, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H

; 1329 : 
; 1330 : 		clip->trace = World_CombineTraces( &clip->trace, &trace, touch );

	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_World_CombineTraces
	add	esp, 16					; 00000010H
	mov	edi, DWORD PTR _clip$[ebp]
	add	edi, 68					; 00000044H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	rep movsd

; 1331 : 	}

	jmp	$LN2@SV_ClipToW
$LN3@SV_ClipToW:

; 1332 : 
; 1333 : 	// recurse down both sides
; 1334 : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN9@SV_ClipToW
	jmp	SHORT $LN11@SV_ClipToW
$LN9@SV_ClipToW:

; 1335 : 
; 1336 : 	if( clip->boxmaxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN10@SV_ClipToW

; 1337 : 		SV_ClipToWorldBrush( node->children[0], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_SV_ClipToWorldBrush
	add	esp, 8
$LN10@SV_ClipToW:

; 1338 : 
; 1339 : 	if( clip->boxmins[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN11@SV_ClipToW

; 1340 : 		SV_ClipToWorldBrush( node->children[1], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_ClipToWorldBrush
	add	esp, 8
$LN11@SV_ClipToW:

; 1341 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipToWorldBrush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClipToPortals
_TEXT	SEGMENT
_touch$ = -12						; size = 4
_next$ = -8						; size = 4
_l$ = -4						; size = 4
_node$ = 8						; size = 4
_clip$ = 12						; size = 4
_SV_ClipToPortals PROC					; COMDAT

; 1277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1278 : 	link_t	*l, *next;
; 1279 : 	edict_t	*touch;
; 1280 : 
; 1281 : 	// touch linked edicts
; 1282 : 	for( l = node->portal_edicts.next; l != &node->portal_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_ClipToP
$LN2@SV_ClipToP:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_ClipToP:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 32					; 00000020H
	cmp	DWORD PTR _l$[ebp], eax
	je	SHORT $LN3@SV_ClipToP

; 1283 : 	{
; 1284 : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 1285 : 
; 1286 : 		touch = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _touch$[ebp], eax

; 1287 : 
; 1288 : 		if( !SV_ClipToEntity( touch, clip ))

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	_SV_ClipToEntity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@SV_ClipToP

; 1289 : 			return; // trace.allsoild

	jmp	SHORT $LN8@SV_ClipToP
$LN5@SV_ClipToP:

; 1290 : 	}

	jmp	SHORT $LN2@SV_ClipToP
$LN3@SV_ClipToP:

; 1291 : 	
; 1292 : 	// recurse down both sides
; 1293 : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN6@SV_ClipToP
	jmp	SHORT $LN8@SV_ClipToP
$LN6@SV_ClipToP:

; 1294 : 
; 1295 : 	if( clip->boxmaxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN7@SV_ClipToP

; 1296 : 		SV_ClipToPortals( node->children[0], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_SV_ClipToPortals
	add	esp, 8
$LN7@SV_ClipToP:

; 1297 : 	if( clip->boxmins[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN8@SV_ClipToP

; 1298 : 		SV_ClipToPortals( node->children[1], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_ClipToPortals
	add	esp, 8
$LN8@SV_ClipToP:

; 1299 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipToPortals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClipToLinks
_TEXT	SEGMENT
_touch$ = -12						; size = 4
_next$ = -8						; size = 4
_l$ = -4						; size = 4
_node$ = 8						; size = 4
_clip$ = 12						; size = 4
_SV_ClipToLinks PROC					; COMDAT

; 1245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1246 : 	link_t	*l, *next;
; 1247 : 	edict_t	*touch;
; 1248 : 
; 1249 : 	// touch linked edicts
; 1250 : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_ClipToL
$LN2@SV_ClipToL:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_ClipToL:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	SHORT $LN3@SV_ClipToL

; 1251 : 	{
; 1252 : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 1253 : 
; 1254 : 		touch = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _touch$[ebp], eax

; 1255 : 
; 1256 : 		if( !SV_ClipToEntity( touch, clip ))

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	_SV_ClipToEntity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@SV_ClipToL

; 1257 : 			return; // trace.allsoild

	jmp	SHORT $LN8@SV_ClipToL
$LN5@SV_ClipToL:

; 1258 : 	}

	jmp	SHORT $LN2@SV_ClipToL
$LN3@SV_ClipToL:

; 1259 : 	
; 1260 : 	// recurse down both sides
; 1261 : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN6@SV_ClipToL
	jmp	SHORT $LN8@SV_ClipToL
$LN6@SV_ClipToL:

; 1262 : 
; 1263 : 	if( clip->boxmaxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN7@SV_ClipToL

; 1264 : 		SV_ClipToLinks( node->children[0], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_SV_ClipToLinks
	add	esp, 8
$LN7@SV_ClipToL:

; 1265 : 	if( clip->boxmins[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN8@SV_ClipToL

; 1266 : 		SV_ClipToLinks( node->children[1], clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	_SV_ClipToLinks
	add	esp, 8
$LN8@SV_ClipToL:

; 1267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipToLinks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClipToEntity
_TEXT	SEGMENT
$T1 = -184						; size = 56
_mod$ = -64						; size = 4
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_touch$ = 8						; size = 4
_clip$ = 12						; size = 4
_SV_ClipToEntity PROC					; COMDAT

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1142 : 	trace_t	trace;
; 1143 : 	model_t	*mod;
; 1144 : 
; 1145 : 	if( touch->v.groupinfo && SV_IsValidEdict( clip->passedict ) && clip->passedict->v.groupinfo != 0 )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	$LN4@SV_ClipToE
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClipToEntity@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	cmp	DWORD PTR [ecx+800], 0
	je	SHORT $LN4@SV_ClipToE

; 1146 : 	{
; 1147 : 		if( svs.groupop == GROUP_OP_AND && !FBitSet( touch->v.groupinfo, clip->passedict->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN3@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _touch$[ebp]
	mov	eax, DWORD PTR [edx+800]
	and	eax, DWORD PTR [ecx+800]
	jne	SHORT $LN3@SV_ClipToE

; 1148 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN3@SV_ClipToE:

; 1149 : 
; 1150 : 		if( svs.groupop == GROUP_OP_NAND && FBitSet( touch->v.groupinfo, clip->passedict->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN4@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _touch$[ebp]
	mov	eax, DWORD PTR [edx+800]
	and	eax, DWORD PTR [ecx+800]
	je	SHORT $LN4@SV_ClipToE

; 1151 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN4@SV_ClipToE:

; 1152 : 	}
; 1153 : 
; 1154 : 	if( touch == clip->passedict || touch->v.solid == SOLID_NOT )

	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR _touch$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	je	SHORT $LN6@SV_ClipToE
	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN5@SV_ClipToE
$LN6@SV_ClipToE:

; 1155 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN5@SV_ClipToE:

; 1156 : 
; 1157 : 	if( touch->v.solid == SOLID_TRIGGER )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 1
	jne	SHORT $LN7@SV_ClipToE

; 1158 : 		Host_Error( "trigger in clipping list\n" );

	push	OFFSET ??_C@_0BK@EDIMEKPL@trigger?5in?5clipping?5list?6@
	call	_Host_Error
	add	esp, 4
$LN7@SV_ClipToE:

; 1159 : 
; 1160 : 	// custom user filter
; 1161 : 	if( svgame.dllFuncs2.pfnShouldCollide )

	cmp	DWORD PTR _svgame+19480, 0
	je	SHORT $LN9@SV_ClipToE

; 1162 : 	{
; 1163 : 		if( !svgame.dllFuncs2.pfnShouldCollide( touch, clip->passedict ))

	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _touch$[ebp]
	push	edx
	call	DWORD PTR _svgame+19480
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_ClipToE

; 1164 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN9@SV_ClipToE:

; 1165 : 	}
; 1166 : 
; 1167 : 	// monsterclip filter (solid custom is a static or dynamic bodies)
; 1168 : 	if( touch->v.solid == SOLID_BSP || touch->v.solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 4
	je	SHORT $LN12@SV_ClipToE
	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 5
	jne	SHORT $LN10@SV_ClipToE
$LN12@SV_ClipToE:

; 1169 : 	{
; 1170 : 		// func_monsterclip works only with monsters that have same flag!
; 1171 : 		if( FBitSet( touch->v.flags, FL_MONSTERCLIP ) && !clip->monsterclip )

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN13@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	SHORT $LN13@SV_ClipToE

; 1172 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN13@SV_ClipToE:

; 1173 : 	}

	jmp	SHORT $LN14@SV_ClipToE
$LN10@SV_ClipToE:

; 1174 : 	else
; 1175 : 	{
; 1176 : 		// ignore all monsters but pushables
; 1177 : 		if( clip->type == MOVE_NOMONSTERS && touch->v.movetype != MOVETYPE_PUSHSTEP )

	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+124], 1
	jne	SHORT $LN14@SV_ClipToE
	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+396], 13			; 0000000dH
	je	SHORT $LN14@SV_ClipToE

; 1178 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN14@SV_ClipToE:

; 1179 : 	}
; 1180 : 
; 1181 : 	mod = SV_ModelHandle( touch->v.modelindex );

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 1182 : 
; 1183 : 	if( mod && mod->type == mod_brush && clip->ignoretrans )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN16@SV_ClipToE
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN16@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN16@SV_ClipToE

; 1184 : 	{
; 1185 : 		// we ignore brushes with rendermode != kRenderNormal and without FL_WORLDBRUSH set
; 1186 : 		if( touch->v.rendermode != kRenderNormal && !FBitSet( touch->v.flags, FL_WORLDBRUSH ))

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+496], 0
	je	SHORT $LN16@SV_ClipToE
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 33554432				; 02000000H
	jne	SHORT $LN16@SV_ClipToE

; 1187 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN16@SV_ClipToE:

; 1188 : 	}
; 1189 : 
; 1190 : 	if( !BoundsIntersect( clip->boxmins, clip->boxmaxs, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN17@SV_ClipToE

; 1191 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN17@SV_ClipToE:

; 1192 : 
; 1193 : 	// aditional check to intersects clients with sphere
; 1194 : 	if( touch->v.solid != SOLID_SLIDEBOX && !SV_CheckSphereIntersection( touch, clip->start, clip->end ))

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 3
	je	SHORT $LN18@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	_SV_CheckSphereIntersection
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@SV_ClipToE

; 1195 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN18@SV_ClipToE:

; 1196 : 
; 1197 : 	// Xash3D extension
; 1198 : 	if( SV_IsValidEdict( clip->passedict ) && clip->passedict->v.solid == SOLID_TRIGGER )

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClipToEntity@@9@9
	add	eax, 57					; 00000039H
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	cmp	DWORD PTR [ecx+400], 1
	jne	SHORT $LN20@SV_ClipToE

; 1199 : 	{
; 1200 : 		// never collide items and player (because call "give" always stuck item in player
; 1201 : 		// and total trace returns fail (old half-life bug)
; 1202 : 		// items touch should be done in SV_TouchLinks not here
; 1203 : 		if( FBitSet( touch->v.flags, FL_CLIENT|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	je	SHORT $LN20@SV_ClipToE

; 1204 : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN20@SV_ClipToE:

; 1205 : 	}
; 1206 : 
; 1207 : 	// g-cont. make sure what size is really zero - check all the components
; 1208 : 	if( SV_IsValidEdict( clip->passedict ) && !VectorIsNull( clip->passedict->v.size ) && VectorIsNull( touch->v.size ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClipToEntity@@9@9
	add	eax, 67					; 00000043H
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN21@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@SV_ClipToE
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@SV_ClipToE
$LN22@SV_ClipToE:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@SV_ClipToE
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@SV_ClipToE
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@SV_ClipToE

; 1209 : 		return true; // points never interact

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN21@SV_ClipToE:

; 1210 : 
; 1211 : 	// might intersect, so do an exact clip
; 1212 : 	if( clip->trace.allsolid ) return false;

	mov	eax, DWORD PTR _clip$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN23@SV_ClipToE
	xor	eax, eax
	jmp	$LN1@SV_ClipToE
$LN23@SV_ClipToE:

; 1213 : 
; 1214 : 	if( SV_IsValidEdict( clip->passedict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClipToEntity@@9@9
	add	eax, 73					; 00000049H
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@SV_ClipToE

; 1215 : 	{
; 1216 : 	 	if( touch->v.owner == clip->passedict )

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax+644]
	cmp	edx, DWORD PTR [ecx+64]
	jne	SHORT $LN25@SV_ClipToE

; 1217 : 			return true; // don't clip against own missiles

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN25@SV_ClipToE:

; 1218 : 		if( clip->passedict->v.owner == touch )

	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR [ecx+644]
	cmp	edx, DWORD PTR _touch$[ebp]
	jne	SHORT $LN26@SV_ClipToE

; 1219 : 			return true; // don't clip against owner

	mov	eax, 1
	jmp	$LN1@SV_ClipToE
$LN26@SV_ClipToE:

; 1220 : 	}
; 1221 : 
; 1222 : 	// make sure we don't hit the world if we're inside the portal
; 1223 : 	if( touch->v.solid == SOLID_PORTAL )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN27@SV_ClipToE

; 1224 : 		SV_PortalCSG( touch, clip->mins, clip->maxs, clip->start, clip->end, &clip->trace );

	mov	eax, DWORD PTR _clip$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	call	_SV_PortalCSG
	add	esp, 24					; 00000018H
$LN27@SV_ClipToE:

; 1225 : 
; 1226 : 	if( touch->v.solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 5
	jne	SHORT $LN28@SV_ClipToE

; 1227 : 		SV_CustomClipMoveToEntity( touch, clip->start, clip->mins, clip->maxs, clip->end, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	call	_SV_CustomClipMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN31@SV_ClipToE
$LN28@SV_ClipToE:

; 1228 : 	else if( FBitSet( touch->v.flags, FL_MONSTER ))

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 32					; 00000020H
	je	SHORT $LN30@SV_ClipToE

; 1229 : 		SV_ClipMoveToEntity( touch, clip->start, clip->mins2, clip->maxs2, clip->end, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN31@SV_ClipToE
$LN30@SV_ClipToE:

; 1230 : 	else SV_ClipMoveToEntity( touch, clip->start, clip->mins, clip->maxs, clip->end, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H
$LN31@SV_ClipToE:

; 1231 : 
; 1232 : 	clip->trace = World_CombineTraces( &clip->trace, &trace, touch );

	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clip$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_World_CombineTraces
	add	esp, 16					; 00000010H
	mov	edi, DWORD PTR _clip$[ebp]
	add	edi, 68					; 00000044H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	rep movsd

; 1233 : 
; 1234 : 	return true;

	mov	eax, 1
$LN1@SV_ClipToE:

; 1235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipToEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_PortalCSG
_TEXT	SEGMENT
tv621 = -232						; size = 4
tv460 = -232						; size = 4
tv226 = -232						; size = 4
tv199 = -232						; size = 4
tv172 = -232						; size = 4
_frac$1 = -164						; size = 4
_de$2 = -160						; size = 4
_ds$3 = -156						; size = 4
_nearest$4 = -152					; size = 12
_d$5 = -140						; size = 4
_portalradius$ = -136					; size = 4
_model$ = -132						; size = 4
_hitplane$ = -128					; size = 4
_bestfrac$ = -124					; size = 4
_worldpos$ = -120					; size = 12
_k$ = -108						; size = 4
_plane$ = -104						; size = 4
_planes$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_portal$ = 8						; size = 4
_trace_mins$ = 12					; size = 4
_trace_maxs$ = 16					; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_trace$ = 28						; size = 4
_SV_PortalCSG PROC					; COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1003 : 	vec4_t	planes[6];	//far, near, right, left, up, down
; 1004 : 	int	plane, k;
; 1005 : 	vec3_t	worldpos;
; 1006 : 	float	bestfrac;
; 1007 : 	int	hitplane;
; 1008 : 	model_t	*model;
; 1009 : 	float	portalradius;
; 1010 : 	
; 1011 : 	// only run this code if we impacted on the portal's parent.
; 1012 : 	if( trace->fraction == 1.0f && !trace->startsolid )

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PortalC
	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@SV_PortalC

; 1013 : 		return;

	jmp	$LN26@SV_PortalC
$LN11@SV_PortalC:

; 1014 : 
; 1015 : 	// decide which clipping hull to use, based on the size
; 1016 : 	model = SV_ModelHandle( portal->v.modelindex );

	mov	eax, DWORD PTR _portal$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 1017 : 
; 1018 : 	if( !model || model->type != mod_brush )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN13@SV_PortalC
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN12@SV_PortalC
$LN13@SV_PortalC:

; 1019 : 		return;

	jmp	$LN26@SV_PortalC
$LN12@SV_PortalC:

; 1020 : 
; 1021 : 	// make sure we use a sane valid position.
; 1022 : 	if( trace->startsolid ) VectorCopy( start, worldpos );

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN14@SV_PortalC
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _worldpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _worldpos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _worldpos$[ebp+ecx], eax
	jmp	SHORT $LN15@SV_PortalC
$LN14@SV_PortalC:

; 1023 : 	else VectorCopy( trace->endpos, worldpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+20]
	mov	DWORD PTR _worldpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+edx+20]
	mov	DWORD PTR _worldpos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _worldpos$[ebp+ecx], eax
$LN15@SV_PortalC:

; 1024 : 
; 1025 : 	// determine the csg area. normals should be facing in
; 1026 : 	AngleVectors( portal->v.angles, planes[1], planes[3], planes[5] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 5
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	push	edx
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	push	edx
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _portal$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1027 : 	VectorNegate(planes[1], planes[0]);

	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv172[ebp], xmm0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1028 : 	VectorNegate(planes[3], planes[2]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv199[ebp], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1029 : 	VectorNegate(planes[5], planes[4]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 5
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 16					; 00000010H
	shl	edx, 2
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 5
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR [edx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 16					; 00000010H
	shl	ecx, 2
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 5
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv226[ebp], xmm0
	mov	edx, 16					; 00000010H
	shl	edx, 2
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv226[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1030 : 
; 1031 : 	portalradius = model->radius * 0.5f;

	mov	eax, DWORD PTR _model$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _portalradius$[ebp], xmm0

; 1032 : 	planes[0][3] = DotProduct( portal->v.origin, planes[0] ) - (4.0f / 32.0f);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3e000000
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 1033 : 	planes[1][3] = DotProduct( portal->v.origin, planes[1] ) - (4.0f / 32.0f);	//an epsilon beyond the portal

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+eax+136]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+edx+136]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3e000000
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR [edx+ecx], xmm0

; 1034 : 	planes[2][3] = DotProduct( portal->v.origin, planes[2] ) - portalradius;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+eax+136]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+edx+136]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _portalradius$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR [edx+ecx], xmm0

; 1035 : 	planes[3][3] = DotProduct( portal->v.origin, planes[3] ) - portalradius;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _portalradius$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 1036 : 	planes[4][3] = DotProduct( portal->v.origin, planes[4] ) - portalradius;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 2
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 2
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+eax+136]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 2
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+edx+136]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _portalradius$[ebp]
	mov	ecx, 16					; 00000010H
	shl	ecx, 2
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR [edx+ecx], xmm0

; 1037 : 	planes[5][3] = DotProduct( portal->v.origin, planes[5] ) - portalradius;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 5
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+136]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 5
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 5
	lea	edx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _portal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx+136]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _portalradius$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 5
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 1038 : 
; 1039 : 	// if we're actually inside the csg region
; 1040 : 	for( plane = 0; plane < 6; plane++ )

	mov	DWORD PTR _plane$[ebp], 0
	jmp	SHORT $LN4@SV_PortalC
$LN2@SV_PortalC:
	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 1
	mov	DWORD PTR _plane$[ebp], eax
$LN4@SV_PortalC:
	cmp	DWORD PTR _plane$[ebp], 6
	jge	$LN3@SV_PortalC

; 1041 : 	{
; 1042 : 		float	d = DotProduct( worldpos, planes[plane] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _worldpos$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _worldpos$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _worldpos$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _d$5[ebp], xmm0

; 1043 : 		vec3_t	nearest;
; 1044 : 
; 1045 : 		for( k = 0; k < 3; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@SV_PortalC
$LN5@SV_PortalC:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@SV_PortalC:
	cmp	DWORD PTR _k$[ebp], 3
	jge	SHORT $LN6@SV_PortalC

; 1046 : 			nearest[k] = (planes[plane][k]>=0) ? trace_maxs[k] : trace_mins[k];

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN28@SV_PortalC
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _trace_maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv460[ebp], xmm0
	jmp	SHORT $LN29@SV_PortalC
$LN28@SV_PortalC:
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _trace_mins$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv460[ebp], xmm0
$LN29@SV_PortalC:
	mov	ecx, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR tv460[ebp]
	movss	DWORD PTR _nearest$4[ebp+ecx*4], xmm0
	jmp	SHORT $LN5@SV_PortalC
$LN6@SV_PortalC:

; 1047 : 
; 1048 : 		// front plane gets further away with side
; 1049 : 		if( !plane )

	cmp	DWORD PTR _plane$[ebp], 0
	jne	$LN16@SV_PortalC

; 1050 : 		{
; 1051 : 			planes[plane][3] -= DotProduct( nearest, planes[plane] );

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _plane$[ebp]
	shl	esi, 4
	lea	esi, DWORD PTR _planes$[ebp+esi]
	mov	edi, 4
	imul	edi, edi, 0
	movss	xmm0, DWORD PTR _nearest$4[ebp+edx]
	mulss	xmm0, DWORD PTR [esi+edi]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _plane$[ebp]
	shl	esi, 4
	lea	esi, DWORD PTR _planes$[ebp+esi]
	mov	edi, 4
	shl	edi, 0
	movss	xmm1, DWORD PTR _nearest$4[ebp+edx]
	mulss	xmm1, DWORD PTR [esi+edi]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _plane$[ebp]
	shl	esi, 4
	lea	esi, DWORD PTR _planes$[ebp+esi]
	mov	edi, 4
	shl	edi, 1
	movss	xmm1, DWORD PTR _nearest$4[ebp+edx]
	mulss	xmm1, DWORD PTR [esi+edi]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _plane$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _planes$[ebp+edx]
	movss	DWORD PTR [eax+ecx], xmm1

; 1052 : 		}	

	jmp	SHORT $LN18@SV_PortalC
$LN16@SV_PortalC:

; 1053 : 		else if( plane > 1 )

	cmp	DWORD PTR _plane$[ebp], 1
	jle	SHORT $LN18@SV_PortalC

; 1054 : 		{
; 1055 : 			// side planes get nearer with size
; 1056 : 			planes[plane][3] += 24; // DotProduct( nearest, planes[plane] );

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR __real@41c00000
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	movss	DWORD PTR [ecx+edx], xmm0
$LN18@SV_PortalC:

; 1057 : 		}
; 1058 : 
; 1059 : 		if( d - planes[plane][3] >= 0 )

	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _d$5[ebp]
	subss	xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN19@SV_PortalC

; 1060 : 			continue;	// endpos is inside

	jmp	$LN2@SV_PortalC
	jmp	SHORT $LN20@SV_PortalC
$LN19@SV_PortalC:

; 1061 : 		else return; // end is already outside

	jmp	$LN26@SV_PortalC
$LN20@SV_PortalC:

; 1062 : 	}

	jmp	$LN2@SV_PortalC
$LN3@SV_PortalC:

; 1063 : 
; 1064 : 	// yup, we're inside, the trace shouldn't end where it actually did
; 1065 : 	bestfrac = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bestfrac$[ebp], xmm0

; 1066 : 	hitplane = -1;

	mov	DWORD PTR _hitplane$[ebp], -1

; 1067 : 
; 1068 : 	for( plane = 0; plane < 6; plane++ )

	mov	DWORD PTR _plane$[ebp], 0
	jmp	SHORT $LN10@SV_PortalC
$LN8@SV_PortalC:
	mov	eax, DWORD PTR _plane$[ebp]
	add	eax, 1
	mov	DWORD PTR _plane$[ebp], eax
$LN10@SV_PortalC:
	cmp	DWORD PTR _plane$[ebp], 6
	jge	$LN9@SV_PortalC

; 1069 : 	{
; 1070 : 		float	ds = DotProduct( start, planes[plane] ) - planes[plane][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _ds$3[ebp], xmm0

; 1071 : 		float	de = DotProduct( end, planes[plane] ) - planes[plane][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane$[ebp]
	shl	edx, 4
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _end$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _plane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _de$2[ebp], xmm0

; 1072 : 		float	frac;
; 1073 : 
; 1074 : 		if( ds >= 0 && de < 0 )

	movss	xmm0, DWORD PTR _ds$3[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN22@SV_PortalC
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _de$2[ebp]
	jbe	SHORT $LN22@SV_PortalC

; 1075 : 		{
; 1076 : 			frac = (ds) / (ds - de);

	movss	xmm0, DWORD PTR _ds$3[ebp]
	subss	xmm0, DWORD PTR _de$2[ebp]
	movss	xmm1, DWORD PTR _ds$3[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$1[ebp], xmm1

; 1077 : 			if( frac < bestfrac )

	movss	xmm0, DWORD PTR _bestfrac$[ebp]
	comiss	xmm0, DWORD PTR _frac$1[ebp]
	jbe	SHORT $LN22@SV_PortalC

; 1078 : 			{
; 1079 : 				if( frac < 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$1[ebp]
	jbe	SHORT $LN23@SV_PortalC

; 1080 : 					frac = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$1[ebp], xmm0
$LN23@SV_PortalC:

; 1081 : 				bestfrac = frac;

	movss	xmm0, DWORD PTR _frac$1[ebp]
	movss	DWORD PTR _bestfrac$[ebp], xmm0

; 1082 : 				hitplane = plane;

	mov	eax, DWORD PTR _plane$[ebp]
	mov	DWORD PTR _hitplane$[ebp], eax
$LN22@SV_PortalC:

; 1083 : 			}
; 1084 : 		}
; 1085 : 	}

	jmp	$LN8@SV_PortalC
$LN9@SV_PortalC:

; 1086 : 
; 1087 : 	trace->startsolid = trace->allsolid = false;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1088 : 
; 1089 : 	// if we cross the front of the portal, don't shorten the trace,
; 1090 : 	// that will artificially clip us
; 1091 : 	if( hitplane == 0 && trace->fraction > bestfrac )

	cmp	DWORD PTR _hitplane$[ebp], 0
	jne	SHORT $LN24@SV_PortalC
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR _bestfrac$[ebp]
	jbe	SHORT $LN24@SV_PortalC

; 1092 : 		return;

	jmp	$LN26@SV_PortalC
$LN24@SV_PortalC:

; 1093 : 
; 1094 : 	// okay, elongate to clip to the portal hole properly.
; 1095 : 	VectorLerp( start, bestfrac, end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _bestfrac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, DWORD PTR _bestfrac$[ebp]
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+ecx]
	mulss	xmm0, DWORD PTR _bestfrac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [eax+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv621[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv621[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0

; 1096 : 	trace->fraction = bestfrac;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _bestfrac$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 1097 : 
; 1098 : 	if( hitplane >= 0 )

	cmp	DWORD PTR _hitplane$[ebp], 0
	jl	$LN26@SV_PortalC

; 1099 : 	{
; 1100 : 		VectorCopy( planes[hitplane], trace->plane.normal );

	mov	eax, DWORD PTR _hitplane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [esi+edx+32], eax
	mov	ecx, DWORD PTR _hitplane$[ebp]
	shl	ecx, 4
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [esi+ecx+32], edx
	mov	eax, DWORD PTR _hitplane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax+32], ecx

; 1101 : 		trace->plane.dist = planes[hitplane][3];

	mov	eax, DWORD PTR _hitplane$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+44], eax

; 1102 : 		if( hitplane == 1 ) trace->ent = portal;

	cmp	DWORD PTR _hitplane$[ebp], 1
	jne	SHORT $LN26@SV_PortalC
	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _portal$[ebp]
	mov	DWORD PTR [eax+48], ecx
$LN26@SV_PortalC:

; 1103 : 	}
; 1104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PortalCSG ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_WaterLinks
_TEXT	SEGMENT
tv175 = -180						; size = 4
_matrix$1 = -112					; size = 64
_mod$ = -48						; size = 4
_offset$ = -44						; size = 12
_test$ = -32						; size = 12
_hull$ = -20						; size = 4
_touch$ = -16						; size = 4
_next$ = -12						; size = 4
_l$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_pCont$ = 12						; size = 4
_node$ = 16						; size = 4
_SV_WaterLinks PROC					; COMDAT

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 709  : 	link_t	*l, *next;
; 710  : 	edict_t	*touch;
; 711  : 	hull_t	*hull;
; 712  : 	vec3_t	test, offset;
; 713  : 	model_t	*mod;
; 714  : 
; 715  : 	// get water edicts
; 716  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_WaterLi
$LN2@SV_WaterLi:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_WaterLi:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_WaterLi

; 717  : 	{
; 718  : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 719  : 		touch = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _touch$[ebp], eax

; 720  : 
; 721  : 		if( touch->v.solid != SOLID_NOT ) // disabled ?

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	SHORT $LN5@SV_WaterLi

; 722  : 			continue;

	jmp	SHORT $LN2@SV_WaterLi
$LN5@SV_WaterLi:

; 723  : 
; 724  : 		if( touch->v.groupinfo )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN8@SV_WaterLi

; 725  : 		{
; 726  : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( touch->v.groupinfo, svs.groupmask ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN7@SV_WaterLi
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, DWORD PTR _svs+20
	jne	SHORT $LN7@SV_WaterLi

; 727  : 				continue;

	jmp	SHORT $LN2@SV_WaterLi
$LN7@SV_WaterLi:

; 728  : 
; 729  : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( touch->v.groupinfo, svs.groupmask ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN8@SV_WaterLi
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, DWORD PTR _svs+20
	je	SHORT $LN8@SV_WaterLi

; 730  : 				continue;

	jmp	SHORT $LN2@SV_WaterLi
$LN8@SV_WaterLi:

; 731  : 		}
; 732  : 
; 733  : 		mod = SV_ModelHandle( touch->v.modelindex );

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 734  : 
; 735  : 		// only brushes can have special contents
; 736  : 		if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN10@SV_WaterLi
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN9@SV_WaterLi
$LN10@SV_WaterLi:

; 737  : 			continue;

	jmp	$LN2@SV_WaterLi
$LN9@SV_WaterLi:

; 738  : 
; 739  : 		if( !BoundsIntersect( origin, origin, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN11@SV_WaterLi

; 740  : 			continue;

	jmp	$LN2@SV_WaterLi
$LN11@SV_WaterLi:

; 741  : 
; 742  : 		// check water brushes accuracy
; 743  : 		hull = SV_HullForBsp( touch, vec3_origin, vec3_origin, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	_SV_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 744  : 
; 745  : 		// support for rotational water
; 746  : 		if( FBitSet( mod->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( touch->v.angles ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	je	$LN12@SV_WaterLi
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@SV_WaterLi
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@SV_WaterLi
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_WaterLi
$LN14@SV_WaterLi:

; 747  : 		{
; 748  : 			matrix4x4	matrix;
; 749  : 			Matrix4x4_CreateFromEntity( matrix, touch->v.angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 750  : 			Matrix4x4_VectorITransform( matrix, origin, test );

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 751  : 		}

	jmp	$LN13@SV_WaterLi
$LN12@SV_WaterLi:

; 752  : 		else
; 753  : 		{
; 754  : 			// offset the test point appropriately for this hull.
; 755  : 			VectorSubtract( origin, offset, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _test$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv175[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv175[ebp]
	movss	DWORD PTR _test$[ebp+eax], xmm0
$LN13@SV_WaterLi:

; 756  : 		}
; 757  : 
; 758  : 		// test hull for intersection with this model
; 759  : 		if( PM_HullPointContents( hull, hull->firstclipnode, test ) == CONTENTS_EMPTY )

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN15@SV_WaterLi

; 760  : 			continue;

	jmp	$LN2@SV_WaterLi
$LN15@SV_WaterLi:

; 761  : 
; 762  : 		// compare contents ranking
; 763  : 		if( RankForContents( touch->v.skin ) > RankForContents( *pCont ))

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+404]
	push	ecx
	call	_RankForContents
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _pCont$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_RankForContents
	add	esp, 4
	cmp	esi, eax
	jle	SHORT $LN16@SV_WaterLi

; 764  : 			*pCont = touch->v.skin; // new content has more priority

	mov	eax, DWORD PTR _pCont$[ebp]
	mov	ecx, DWORD PTR _touch$[ebp]
	mov	edx, DWORD PTR [ecx+404]
	mov	DWORD PTR [eax], edx
$LN16@SV_WaterLi:

; 765  : 	}

	jmp	$LN2@SV_WaterLi
$LN3@SV_WaterLi:

; 766  : 	
; 767  : 	// recurse down both sides
; 768  : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN17@SV_WaterLi
	jmp	SHORT $LN19@SV_WaterLi
$LN17@SV_WaterLi:

; 769  : 	
; 770  : 	if( origin[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN18@SV_WaterLi

; 771  : 		SV_WaterLinks( origin, pCont, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	mov	ecx, DWORD PTR _pCont$[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_SV_WaterLinks
	add	esp, 12					; 0000000cH
$LN18@SV_WaterLi:

; 772  : 	if( origin[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN19@SV_WaterLi

; 773  : 		SV_WaterLinks( origin, pCont, node->children[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	mov	eax, DWORD PTR _pCont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_SV_WaterLinks
	add	esp, 12					; 0000000cH
$LN19@SV_WaterLi:

; 774  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WaterLinks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_FindTouchedLeafs
_TEXT	SEGMENT
tv143 = -84						; size = 4
tv134 = -80						; size = 4
tv135 = -76						; size = 4
_leaf$ = -8						; size = 4
_sides$ = -4						; size = 4
_ent$ = 8						; size = 4
_node$ = 12						; size = 4
_headnode$ = 16						; size = 4
_SV_FindTouchedLeafs PROC				; COMDAT

; 591  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 592  : 	int	sides;
; 593  : 	mleaf_t	*leaf;
; 594  : 
; 595  : 	if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN2@SV_FindTou

; 596  : 		return;

	jmp	$LN8@SV_FindTou
$LN2@SV_FindTou:

; 597  : 	
; 598  : 	// add an efrag if the node is a leaf
; 599  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN3@SV_FindTou

; 600  : 	{
; 601  : 		if( ent->num_leafs > ( MAX_ENT_LEAFS - 1 ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+20], 47			; 0000002fH
	jle	SHORT $LN4@SV_FindTou

; 602  : 		{
; 603  : 			// continue counting leafs,
; 604  : 			// so we know how many it's overrun
; 605  : 			ent->num_leafs = (MAX_ENT_LEAFS + 1);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+20], 49			; 00000031H

; 606  : 		}

	jmp	SHORT $LN5@SV_FindTou
$LN4@SV_FindTou:

; 607  : 		else
; 608  : 		{
; 609  : 			leaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$[ebp], eax

; 610  : 			ent->leafnums[ent->num_leafs] = leaf->cluster;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _leaf$[ebp]
	mov	ax, WORD PTR [eax+52]
	mov	WORD PTR [edx+ecx*2+24], ax

; 611  : 			ent->num_leafs++;			

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN5@SV_FindTou:

; 612  : 		}
; 613  : 		return;

	jmp	$LN8@SV_FindTou
$LN3@SV_FindTou:

; 614  : 	}
; 615  : 	
; 616  : 	// NODE_MIXED
; 617  : 	sides = BOX_ON_PLANE_SIDE( ent->v.absmin, ent->v.absmax, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN14@SV_FindTou
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	edx, BYTE PTR [eax+16]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+328]
	comiss	xmm0, DWORD PTR [ecx+12]
	jb	SHORT $LN12@SV_FindTou
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN13@SV_FindTou
$LN12@SV_FindTou:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	eax, BYTE PTR [ecx+16]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [ecx+eax*4+340]
	jb	SHORT $LN10@SV_FindTou
	mov	DWORD PTR tv134[ebp], 2
	jmp	SHORT $LN11@SV_FindTou
$LN10@SV_FindTou:
	mov	DWORD PTR tv134[ebp], 3
$LN11@SV_FindTou:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR tv135[ebp], edx
$LN13@SV_FindTou:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN15@SV_FindTou
$LN14@SV_FindTou:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv143[ebp], eax
$LN15@SV_FindTou:
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR _sides$[ebp], edx

; 618  : 
; 619  : 	if(( sides == 3 ) && ( *headnode == -1 ))

	cmp	DWORD PTR _sides$[ebp], 3
	jne	SHORT $LN6@SV_FindTou
	mov	eax, DWORD PTR _headnode$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN6@SV_FindTou

; 620  : 		*headnode = node - sv.worldmodel->nodes;

	mov	eax, DWORD PTR _sv+2595644
	mov	ecx, DWORD PTR _node$[ebp]
	sub	ecx, DWORD PTR [eax+164]
	mov	eax, ecx
	cdq
	mov	ecx, 52					; 00000034H
	idiv	ecx
	mov	edx, DWORD PTR _headnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@SV_FindTou:

; 621  : 	
; 622  : 	// recurse down the contacted sides
; 623  : 	if( sides & 1 ) SV_FindTouchedLeafs( ent, node->children[0], headnode );

	mov	eax, DWORD PTR _sides$[ebp]
	and	eax, 1
	je	SHORT $LN7@SV_FindTou
	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_FindTouchedLeafs
	add	esp, 12					; 0000000cH
$LN7@SV_FindTou:

; 624  : 	if( sides & 2 ) SV_FindTouchedLeafs( ent, node->children[1], headnode );

	mov	eax, DWORD PTR _sides$[ebp]
	and	eax, 2
	je	SHORT $LN8@SV_FindTou
	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_FindTouchedLeafs
	add	esp, 12					; 0000000cH
$LN8@SV_FindTou:

; 625  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindTouchedLeafs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_CreateAreaNode
_TEXT	SEGMENT
tv133 = -136						; size = 4
_maxs2$ = -68						; size = 12
_mins2$ = -56						; size = 12
_maxs1$ = -44						; size = 12
_mins1$ = -32						; size = 12
_size$ = -20						; size = 12
_anode$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_depth$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_SV_CreateAreaNode PROC					; COMDAT

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 421  : 	areanode_t	*anode;
; 422  : 	vec3_t		size;
; 423  : 	vec3_t		mins1, maxs1;
; 424  : 	vec3_t		mins2, maxs2;
; 425  : 
; 426  : 	anode = &sv_areanodes[sv_numareanodes++];

	imul	eax, DWORD PTR _sv_numareanodes, 40
	add	eax, OFFSET _sv_areanodes
	mov	DWORD PTR _anode$[ebp], eax
	mov	ecx, DWORD PTR _sv_numareanodes
	add	ecx, 1
	mov	DWORD PTR _sv_numareanodes, ecx

; 427  : 
; 428  : 	ClearLink( &anode->trigger_edicts );

	mov	eax, DWORD PTR _anode$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_ClearLink
	add	esp, 4

; 429  : 	ClearLink( &anode->solid_edicts );

	mov	eax, DWORD PTR _anode$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	_ClearLink
	add	esp, 4

; 430  : 	ClearLink( &anode->portal_edicts );

	mov	eax, DWORD PTR _anode$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_ClearLink
	add	esp, 4

; 431  : 	
; 432  : 	if( depth == AREA_DEPTH )

	cmp	DWORD PTR _depth$[ebp], 4
	jne	SHORT $LN2@SV_CreateA

; 433  : 	{
; 434  : 		anode->axis = -1;

	mov	eax, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [eax], -1

; 435  : 		anode->children[0] = anode->children[1] = NULL;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx+eax+8], 0

; 436  : 		return anode;

	mov	eax, DWORD PTR _anode$[ebp]
	jmp	$LN1@SV_CreateA
$LN2@SV_CreateA:

; 437  : 	}
; 438  : 	
; 439  : 	VectorSubtract( maxs, mins, size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv133[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR _size$[ebp+eax], xmm0

; 440  : 	if( size[0] > size[1] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	comiss	xmm0, DWORD PTR _size$[ebp+edx]
	jbe	SHORT $LN3@SV_CreateA

; 441  : 		anode->axis = 0;

	mov	eax, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN4@SV_CreateA
$LN3@SV_CreateA:

; 442  : 	else anode->axis = 1;

	mov	eax, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [eax], 1
$LN4@SV_CreateA:

; 443  : 	
; 444  : 	anode->dist = 0.5f * ( maxs[anode->axis] + mins[anode->axis] );

	mov	eax, DWORD PTR _anode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _anode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	addss	xmm0, DWORD PTR [esi+eax*4]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _anode$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 445  : 	VectorCopy( mins, mins1 );	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _mins1$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins1$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _mins1$[ebp+ecx], eax

; 446  : 	VectorCopy( mins, mins2 );	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _mins2$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins2$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _mins2$[ebp+ecx], eax

; 447  : 	VectorCopy( maxs, maxs1 );	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _maxs1$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs1$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _maxs1$[ebp+ecx], eax

; 448  : 	VectorCopy( maxs, maxs2 );	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _maxs2$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs2$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _maxs2$[ebp+ecx], eax

; 449  : 	
; 450  : 	maxs1[anode->axis] = mins2[anode->axis] = anode->dist;

	mov	eax, DWORD PTR _anode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _anode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mins2$[ebp+ecx*4], eax
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _anode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mins2$[ebp+edx*4]
	mov	DWORD PTR _maxs1$[ebp+ecx*4], edx

; 451  : 	anode->children[0] = SV_CreateAreaNode( depth+1, mins2, maxs2 );

	lea	eax, DWORD PTR _maxs2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	add	edx, 1
	push	edx
	call	_SV_CreateAreaNode
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 452  : 	anode->children[1] = SV_CreateAreaNode( depth+1, mins1, maxs1 );

	lea	eax, DWORD PTR _maxs1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	add	edx, 1
	push	edx
	call	_SV_CreateAreaNode
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _anode$[ebp]
	mov	DWORD PTR [edx+ecx+8], eax

; 453  : 
; 454  : 	return anode;

	mov	eax, DWORD PTR _anode$[ebp]
$LN1@SV_CreateA:

; 455  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CreateAreaNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_HullForStudioModel
_TEXT	SEGMENT
tv167 = -136						; size = 4
tv93 = -136						; size = 4
$T1 = -132						; size = 4
_iBlend$2 = -64						; size = 4
_angles$3 = -60						; size = 12
_blending$4 = -48					; size = 2
_controller$5 = -44					; size = 4
_pseqdesc$6 = -40					; size = 4
_pstudio$7 = -36					; size = 4
_mod$ = -32						; size = 4
_size$ = -28						; size = 12
_hull$ = -16						; size = 4
_scale$ = -12						; size = 4
_useComplexHull$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_offset$ = 20						; size = 4
_numhitboxes$ = 24					; size = 4
_SV_HullForStudioModel PROC				; COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 327  : 	qboolean		useComplexHull;
; 328  : 	float		scale = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _scale$[ebp], xmm0

; 329  : 	hull_t		*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 330  : 	vec3_t		size;
; 331  : 	model_t		*mod;
; 332  : 
; 333  : 	if(( mod = SV_ModelHandle( ent->v.modelindex )) == NULL )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN2@SV_HullFor

; 334  : 	{
; 335  : 		*numhitboxes = 1;

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [eax], 1

; 336  : 		return SV_HullForEntity( ent, mins, maxs, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_HullForEntity
	add	esp, 16					; 00000010H
	jmp	$LN1@SV_HullFor
$LN2@SV_HullFor:

; 337  : 	}
; 338  : 
; 339  : 	VectorSubtract( maxs, mins, size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv93[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv93[ebp]
	movss	DWORD PTR _size$[ebp+eax], xmm0

; 340  : 	useComplexHull = false;

	mov	DWORD PTR _useComplexHull$[ebp], 0

; 341  : 
; 342  : 	if( VectorIsNull( size ) && !FBitSet( svgame.globals->trace_flags, FTRACE_SIMPLEBOX ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@SV_HullFor
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _size$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@SV_HullFor
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _size$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@SV_HullFor
	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [eax+132]
	and	ecx, 1
	jne	$LN6@SV_HullFor

; 343  : 	{
; 344  : 		useComplexHull = true;

	mov	DWORD PTR _useComplexHull$[ebp], 1

; 345  : 
; 346  : 		if( FBitSet( ent->v.flags, FL_CLIENT|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	je	SHORT $LN6@SV_HullFor

; 347  : 		{
; 348  : 			if( sv_clienttrace.value == 0.0f )

	movss	xmm0, DWORD PTR _sv_clienttrace+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SV_HullFor

; 349  : 			{
; 350  : 				// so no way to trace studiomodels by hitboxes
; 351  : 				// use bbox instead
; 352  : 				useComplexHull = false;

	mov	DWORD PTR _useComplexHull$[ebp], 0

; 353  : 			}

	jmp	SHORT $LN6@SV_HullFor
$LN5@SV_HullFor:

; 354  : 			else
; 355  : 			{
; 356  : 				scale = sv_clienttrace.value * 0.5f;

	movss	xmm0, DWORD PTR _sv_clienttrace+12
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _scale$[ebp], xmm0

; 357  : 				VectorSet( size, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _size$[ebp+eax], xmm0
$LN6@SV_HullFor:

; 358  : 			}
; 359  : 		}
; 360  : 	}
; 361  : 
; 362  : 	if( FBitSet( mod->flags, STUDIO_TRACE_HITBOX ) || useComplexHull )

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 512				; 00000200H
	jne	SHORT $LN8@SV_HullFor
	cmp	DWORD PTR _useComplexHull$[ebp], 0
	je	$LN10@SV_HullFor
$LN8@SV_HullFor:

; 363  : 	{
; 364  : 		VectorScale( size, scale, size );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _size$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _size$[ebp+eax]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv167[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _size$[ebp+ecx], xmm0

; 365  : 		VectorClear( offset );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _offset$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _offset$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _offset$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 366  : 
; 367  : 		if( FBitSet( ent->v.flags, FL_CLIENT|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	je	$LN9@SV_HullFor

; 368  : 		{
; 369  : 			studiohdr_t	*pstudio;
; 370  : 			mstudioseqdesc_t	*pseqdesc;
; 371  : 			byte		controller[4];
; 372  : 			byte		blending[2];
; 373  : 			vec3_t		angles;
; 374  : 			int		iBlend;
; 375  : 
; 376  : 			pstudio = Mod_StudioExtradata( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudio$7[ebp], eax

; 377  : 			pseqdesc = (mstudioseqdesc_t *)((byte *)pstudio + pstudio->seqindex) + ent->v.sequence;

	mov	eax, DWORD PTR _pstudio$7[ebp]
	mov	ecx, DWORD PTR _pstudio$7[ebp]
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _ent$[ebp]
	imul	eax, DWORD PTR [edx+464], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$6[ebp], ecx

; 378  : 			VectorCopy( ent->v.angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _angles$3[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _angles$3[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _angles$3[ebp+ecx], eax

; 379  : 
; 380  : 			SV_StudioPlayerBlend( pseqdesc, &iBlend, &angles[PITCH] );

	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _angles$3[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _iBlend$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$6[ebp]
	push	ecx
	call	_SV_StudioPlayerBlend
	add	esp, 12					; 0000000cH

; 381  : 
; 382  : 			controller[0] = controller[1] = 0x7F;

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _controller$5[ebp+eax], 127	; 0000007fH
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _controller$5[ebp+edx], 127	; 0000007fH

; 383  : 			controller[2] = controller[3] = 0x7F;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _controller$5[ebp+ecx], 127	; 0000007fH
	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _controller$5[ebp+edx], 127	; 0000007fH

; 384  : 			blending[0] = (byte)iBlend;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _iBlend$2[ebp]
	mov	BYTE PTR _blending$4[ebp+ecx], dl

; 385  : 			blending[1] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN13@SV_HullFor
	jmp	SHORT $LN14@SV_HullFor
$LN13@SV_HullFor:
	call	___report_rangecheckfailure
$LN14@SV_HullFor:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _blending$4[ebp+eax], 0

; 386  : 
; 387  : 			hull = Mod_HullForStudio( mod, ent->v.frame, ent->v.sequence, angles, ent->v.origin, size, controller, blending, numhitboxes, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	push	ecx
	lea	edx, DWORD PTR _blending$4[ebp]
	push	edx
	lea	eax, DWORD PTR _controller$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR _angles$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+472]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_HullForStudio
	add	esp, 40					; 00000028H
	mov	DWORD PTR _hull$[ebp], eax

; 388  : 		}

	jmp	SHORT $LN10@SV_HullFor
$LN9@SV_HullFor:

; 389  : 		else
; 390  : 		{
; 391  : 			hull = Mod_HullForStudio( mod, ent->v.frame, ent->v.sequence, ent->v.angles, ent->v.origin, size, ent->v.controller, ent->v.blending, numhitboxes, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numhitboxes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 488				; 000001e8H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 484				; 000001e4H
	push	eax
	lea	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+472]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_HullForStudio
	add	esp, 40					; 00000028H
	mov	DWORD PTR _hull$[ebp], eax
$LN10@SV_HullFor:

; 392  : 		}
; 393  : 	}
; 394  : 
; 395  : 	if( hull ) return hull;

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN11@SV_HullFor
	mov	eax, DWORD PTR _hull$[ebp]
	jmp	SHORT $LN1@SV_HullFor
$LN11@SV_HullFor:

; 396  : 
; 397  : 	*numhitboxes = 1;

	mov	eax, DWORD PTR _numhitboxes$[ebp]
	mov	DWORD PTR [eax], 1

; 398  : 	return SV_HullForEntity( ent, mins, maxs, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_HullForEntity
	add	esp, 16					; 00000010H
$LN1@SV_HullFor:

; 399  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HullForStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_HullForEntity
_TEXT	SEGMENT
tv162 = -100						; size = 4
tv138 = -100						; size = 4
_hullmaxs$ = -32					; size = 12
_hullmins$ = -20					; size = 12
_hull$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_offset$ = 20						; size = 4
_SV_HullForEntity PROC					; COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 294  : 	hull_t	*hull;
; 295  : 	vec3_t	hullmins, hullmaxs;
; 296  : 
; 297  : 	if( ent->v.solid == SOLID_BSP || ent->v.solid == SOLID_PORTAL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 4
	je	SHORT $LN4@SV_HullFor
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN2@SV_HullFor
$LN4@SV_HullFor:

; 298  : 	{
; 299  : 		if( ent->v.solid != SOLID_PORTAL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	je	SHORT $LN6@SV_HullFor

; 300  : 		{
; 301  : 			if( ent->v.movetype != MOVETYPE_PUSH && ent->v.movetype != MOVETYPE_PUSHSTEP )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 7
	je	SHORT $LN6@SV_HullFor
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 13			; 0000000dH
	je	SHORT $LN6@SV_HullFor

; 302  : 				Host_Error( "'%s' has SOLID_BSP without MOVETYPE_PUSH or MOVETYPE_PUSHSTEP\n", SV_ClassName( ent ));

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DP@NEODGGBA@?8?$CFs?8?5has?5SOLID_BSP?5without?5MOVE@
	call	_Host_Error
	add	esp, 8
$LN6@SV_HullFor:

; 303  : 		}
; 304  : 		hull = SV_HullForBsp( ent, mins, maxs, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 305  : 	}

	jmp	$LN3@SV_HullFor
$LN2@SV_HullFor:

; 306  : 	else
; 307  : 	{
; 308  : 		// create a temp hull from bounding box sizes
; 309  : 		VectorSubtract( ent->v.mins, maxs, hullmins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+352]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _hullmins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+352]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _hullmins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+352]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv138[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv138[ebp]
	movss	DWORD PTR _hullmins$[ebp+eax], xmm0

; 310  : 		VectorSubtract( ent->v.maxs, mins, hullmaxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+364]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _hullmaxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+364]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _hullmaxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+364]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv162[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv162[ebp]
	movss	DWORD PTR _hullmaxs$[ebp+eax], xmm0

; 311  : 		hull = SV_HullForBox( hullmins, hullmaxs );

	lea	eax, DWORD PTR _hullmaxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _hullmins$[ebp]
	push	ecx
	call	_SV_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 312  : 		
; 313  : 		VectorCopy( ent->v.origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx], eax
$LN3@SV_HullFor:

; 314  : 	}
; 315  : 
; 316  : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HullForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_HullForBsp
_TEXT	SEGMENT
tv269 = -92						; size = 4
tv245 = -92						; size = 4
tv183 = -92						; size = 4
tv140 = -92						; size = 4
_size$ = -24						; size = 12
_model$ = -12						; size = 4
_hull$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_offset$ = 20						; size = 4
_SV_HullForBsp PROC					; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 222  : 	hull_t		*hull;
; 223  : 	model_t		*model;
; 224  : 	vec3_t		size;
; 225  : 
; 226  : 	if( svgame.physFuncs.SV_HullForBsp != NULL )

	cmp	DWORD PTR _svgame+19580, 0
	je	SHORT $LN3@SV_HullFor

; 227  : 	{
; 228  : 		hull = svgame.physFuncs.SV_HullForBsp( ent, mins, maxs, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19580
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 229  : 		if( hull ) return hull;

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN3@SV_HullFor
	mov	eax, DWORD PTR _hull$[ebp]
	jmp	$LN1@SV_HullFor
$LN3@SV_HullFor:

; 230  : 	}
; 231  : 
; 232  : 	// decide which clipping hull to use, based on the size
; 233  : 	model = SV_ModelHandle( ent->v.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 234  : 
; 235  : 	if( !model || model->type != mod_brush )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN5@SV_HullFor
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN4@SV_HullFor
$LN5@SV_HullFor:

; 236  : 		Host_Error( "Entity %i (%s) SOLID_BSP with a non bsp model %s\n", NUM_FOR_EDICT( ent ), SV_ClassName( ent ), STRING( ent->v.model ));

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	push	eax
	push	OFFSET ??_C@_0DC@MLEANCHK@Entity?5?$CFi?5?$CI?$CFs?$CJ?5SOLID_BSP?5with?5a@
	call	_Host_Error
	add	esp, 16					; 00000010H
$LN4@SV_HullFor:

; 237  : 
; 238  : 	VectorSubtract( maxs, mins, size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv140[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _size$[ebp+eax], xmm0

; 239  : 
; 240  : #ifdef RANDOM_HULL_NULLIZATION
; 241  : 	// author: The FiEctro
; 242  : 	hull = &model->hulls[COM_RandomLong( 0, 0 )];
; 243  : #endif
; 244  : 	// g-cont: find a better method to detect quake-maps?
; 245  : 	if( FBitSet( world.flags, FWORLD_SKYSPHERE ))

	mov	eax, DWORD PTR _world+8
	and	eax, 1
	je	$LN6@SV_HullFor

; 246  : 	{
; 247  : 		// alternate hull select for quake maps
; 248  : 		if( size[0] < 3.0f || ent->v.solid == SOLID_PORTAL )

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@40400000
	comiss	xmm0, DWORD PTR _size$[ebp+ecx]
	ja	SHORT $LN10@SV_HullFor
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN8@SV_HullFor
$LN10@SV_HullFor:

; 249  : 			hull = &model->hulls[0];

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _model$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax
	jmp	SHORT $LN12@SV_HullFor
$LN8@SV_HullFor:

; 250  : 		else if( size[0] <= 32.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@42000000
	comiss	xmm0, DWORD PTR _size$[ebp+ecx]
	jb	SHORT $LN11@SV_HullFor

; 251  : 			hull = &model->hulls[1];

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx
	jmp	SHORT $LN12@SV_HullFor
$LN11@SV_HullFor:

; 252  : 		else hull = &model->hulls[2];

	mov	eax, 40					; 00000028H
	shl	eax, 1
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx
$LN12@SV_HullFor:

; 253  : 
; 254  : 		VectorSubtract( hull->clip_mins, mins, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv183[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv183[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 255  : 	}

	jmp	$LN14@SV_HullFor
$LN6@SV_HullFor:

; 256  : 	else
; 257  : 	{
; 258  : 		if( size[0] <= 8.0f || ent->v.solid == SOLID_PORTAL )

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@41000000
	comiss	xmm0, DWORD PTR _size$[ebp+ecx]
	jae	SHORT $LN15@SV_HullFor
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN13@SV_HullFor
$LN15@SV_HullFor:

; 259  : 		{
; 260  : 			hull = &model->hulls[0];

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _model$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 261  : 			VectorCopy( hull->clip_mins, offset ); 

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx], eax

; 262  : 		}

	jmp	$LN14@SV_HullFor
$LN13@SV_HullFor:

; 263  : 		else
; 264  : 		{
; 265  : 			if( size[0] <= 36.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@42100000
	comiss	xmm0, DWORD PTR _size$[ebp+ecx]
	jb	SHORT $LN16@SV_HullFor

; 266  : 			{
; 267  : 				if( size[2] <= 36.0f )

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@42100000
	comiss	xmm0, DWORD PTR _size$[ebp+eax]
	jb	SHORT $LN18@SV_HullFor

; 268  : 					hull = &model->hulls[3];

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _model$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax
	jmp	SHORT $LN19@SV_HullFor
$LN18@SV_HullFor:

; 269  : 				else hull = &model->hulls[1];

	mov	eax, 40					; 00000028H
	shl	eax, 0
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx
$LN19@SV_HullFor:

; 270  : 			}

	jmp	SHORT $LN17@SV_HullFor
$LN16@SV_HullFor:

; 271  : 			else hull = &model->hulls[2];

	mov	eax, 40					; 00000028H
	shl	eax, 1
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx
$LN17@SV_HullFor:

; 272  : 
; 273  : 			VectorSubtract( hull->clip_mins, mins, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv245[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv245[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN14@SV_HullFor:

; 274  : 		}
; 275  : 	}
; 276  : 
; 277  : 	VectorAdd( offset, ent->v.origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR [esi+eax+136]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [esi+ecx+136]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [esi+eax+136]
	movss	DWORD PTR tv269[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv269[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 278  : 
; 279  : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]
$LN1@SV_HullFor:

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_HullAutoSelect
_TEXT	SEGMENT
tv267 = -124						; size = 8
tv317 = -116						; size = 8
tv258 = -108						; size = 8
tv220 = -104						; size = 4
tv142 = -104						; size = 4
_hull$ = -36						; size = 4
_clip_size$ = -32					; size = 12
_hullNumber$ = -20					; size = 4
_i$ = -16						; size = 4
_lastdiff$ = -12					; size = 4
_curdiff$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_size$ = 20						; size = 4
_offset$ = 24						; size = 4
_SV_HullAutoSelect PROC					; COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 182  : 	float	curdiff;
; 183  : 	float	lastdiff = 999;

	movss	xmm0, DWORD PTR __real@4479c000
	movss	DWORD PTR _lastdiff$[ebp], xmm0

; 184  : 	int	i, hullNumber = 0;	// assume we fail

	mov	DWORD PTR _hullNumber$[ebp], 0

; 185  : 	vec3_t	clip_size;
; 186  : 	hull_t	*hull;
; 187  : 
; 188  : 	// NOTE: this is not matched with hardcoded values in some cases...
; 189  : 	for( i = 0; i < MAX_MAP_HULLS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_HullAut
$LN2@SV_HullAut:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_HullAut:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@SV_HullAut

; 190  : 	{
; 191  : 		VectorSubtract( model->hulls[i].clip_maxs, model->hulls[i].clip_mins, clip_size );

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	esi, DWORD PTR _model$[ebp]
	lea	eax, DWORD PTR [esi+eax+208]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+ecx+28]
	subss	xmm0, DWORD PTR [eax+esi+16]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _clip_size$[ebp+edx], xmm0
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	esi, DWORD PTR _model$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+208]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [edx+eax+28]
	subss	xmm0, DWORD PTR [ecx+esi+16]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _clip_size$[ebp+edx], xmm0
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	esi, DWORD PTR _model$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+208]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax+28]
	subss	xmm0, DWORD PTR [ecx+esi+16]
	movss	DWORD PTR tv142[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR _clip_size$[ebp+edx], xmm0

; 192  : 		curdiff = floor( VectorAvg( size )) - floor( VectorAvg( clip_size ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR [esi+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _size$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	divss	xmm0, DWORD PTR __real@40400000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv258[ebp]
	movsd	xmm0, QWORD PTR tv258[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _clip_size$[ebp+ecx]
	addss	xmm1, DWORD PTR _clip_size$[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	addss	xmm1, DWORD PTR _clip_size$[ebp+eax]
	divss	xmm1, DWORD PTR __real@40400000
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv317[ebp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv267[ebp]
	movsd	xmm0, QWORD PTR tv317[ebp]
	subsd	xmm0, QWORD PTR tv267[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _curdiff$[ebp], xmm0

; 193  : 		curdiff = fabs( curdiff );

	cvtss2sd xmm0, DWORD PTR _curdiff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _curdiff$[ebp]

; 194  : 
; 195  : 		if( curdiff < lastdiff )

	movss	xmm0, DWORD PTR _lastdiff$[ebp]
	comiss	xmm0, DWORD PTR _curdiff$[ebp]
	jbe	SHORT $LN5@SV_HullAut

; 196  : 		{
; 197  : 			hullNumber = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _hullNumber$[ebp], eax

; 198  : 			lastdiff = curdiff;

	movss	xmm0, DWORD PTR _curdiff$[ebp]
	movss	DWORD PTR _lastdiff$[ebp], xmm0
$LN5@SV_HullAut:

; 199  : 		}
; 200  : 	}

	jmp	$LN2@SV_HullAut
$LN3@SV_HullAut:

; 201  : 
; 202  : 	// TraceHull stuff
; 203  : 	hull = &model->hulls[hullNumber];

	imul	eax, DWORD PTR _hullNumber$[ebp], 40
	mov	ecx, DWORD PTR _model$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx

; 204  : 
; 205  : 	// calculate an offset value to center the origin
; 206  : 	// NOTE: never get offset of drawing hull
; 207  : 	if( !hullNumber ) VectorCopy( hull->clip_mins, offset );

	cmp	DWORD PTR _hullNumber$[ebp], 0
	jne	SHORT $LN6@SV_HullAut
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx], eax
	jmp	$LN7@SV_HullAut
$LN6@SV_HullAut:

; 208  : 	else VectorSubtract( hull->clip_mins, mins, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv220[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN7@SV_HullAut:

; 209  : 
; 210  : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]

; 211  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HullAutoSelect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_HullForBox
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_SV_HullForBox PROC					; COMDAT

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 163  : 	box_planes[0].dist = maxs[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _box_planes[eax+12], ecx

; 164  : 	box_planes[1].dist = mins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 20					; 00000014H
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _box_planes[edx+12], ecx

; 165  : 	box_planes[2].dist = maxs[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 20					; 00000014H
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _box_planes[ecx+12], eax

; 166  : 	box_planes[3].dist = mins[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _box_planes[edx+12], eax

; 167  : 	box_planes[4].dist = maxs[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _box_planes[ecx+12], eax

; 168  : 	box_planes[5].dist = mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _box_planes[edx+12], eax

; 169  : 
; 170  : 	return &box_hull;

	mov	eax, OFFSET _box_hull

; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_HullForBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_CheckSphereIntersection
_TEXT	SEGMENT
tv178 = -148						; size = 8
tv258 = -140						; size = 8
tv279 = -132						; size = 8
tv250 = -124						; size = 8
tv146 = -120						; size = 4
_mod$ = -52						; size = 4
_pseqdesc$ = -48					; size = 4
_pstudiohdr$ = -44					; size = 4
_traceDir$ = -40					; size = 12
_traceOrg$ = -28					; size = 12
_radiusSquared$ = -16					; size = 4
_sequence$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_SV_CheckSphereIntersection PROC			; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 120  : 	int		i, sequence;
; 121  : 	float		radiusSquared;
; 122  : 	vec3_t		traceOrg, traceDir;
; 123  : 	studiohdr_t	*pstudiohdr;
; 124  : 	mstudioseqdesc_t	*pseqdesc;
; 125  : 	model_t		*mod;
; 126  : 
; 127  : 	if( !FBitSet( ent->v.flags, FL_CLIENT|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	jne	SHORT $LN5@SV_CheckSp

; 128  : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_CheckSp
$LN5@SV_CheckSp:

; 129  : 
; 130  : 	if(( mod = SV_ModelHandle( ent->v.modelindex )) == NULL )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN6@SV_CheckSp

; 131  : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_CheckSp
$LN6@SV_CheckSp:

; 132  : 
; 133  : 	if(( pstudiohdr = (studiohdr_t *)Mod_StudioExtradata( mod )) == NULL )

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudiohdr$[ebp], eax
	cmp	DWORD PTR _pstudiohdr$[ebp], 0
	jne	SHORT $LN7@SV_CheckSp

; 134  : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_CheckSp
$LN7@SV_CheckSp:

; 135  : 
; 136  : 	sequence = ent->v.sequence;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	mov	DWORD PTR _sequence$[ebp], ecx

; 137  : 	if( sequence < 0 || sequence >= pstudiohdr->numseq )

	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $LN9@SV_CheckSp
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _sequence$[ebp]
	cmp	ecx, DWORD PTR [eax+164]
	jl	SHORT $LN8@SV_CheckSp
$LN9@SV_CheckSp:

; 138  : 		sequence = 0;

	mov	DWORD PTR _sequence$[ebp], 0
$LN8@SV_CheckSp:

; 139  : 
; 140  : 	pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + sequence;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _sequence$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 141  : 
; 142  : 	VectorCopy( start, traceOrg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _traceOrg$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _traceOrg$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _traceOrg$[ebp+ecx], eax

; 143  : 	VectorSubtract( end, start, traceDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _traceDir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _traceDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv146[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR _traceDir$[ebp+eax], xmm0

; 144  : 	radiusSquared = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _radiusSquared$[ebp], xmm0

; 145  : 
; 146  : 	for ( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckSp
$LN2@SV_CheckSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckSp:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@SV_CheckSp

; 147  : 		radiusSquared += Q_max( fabs( pseqdesc->bbmin[i] ), fabs( pseqdesc->bbmax[i] ));

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4+96]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv250[ebp]
	movsd	xmm0, QWORD PTR tv250[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+edx*4+108]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv279[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv258[ebp]
	movsd	xmm0, QWORD PTR tv279[ebp]
	comisd	xmm0, QWORD PTR tv258[ebp]
	jbe	SHORT $LN11@SV_CheckSp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx*4+96]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv178[ebp]
	jmp	SHORT $LN12@SV_CheckSp
$LN11@SV_CheckSp:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4+108]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv178[ebp]
$LN12@SV_CheckSp:
	cvtss2sd xmm0, DWORD PTR _radiusSquared$[ebp]
	addsd	xmm0, QWORD PTR tv178[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _radiusSquared$[ebp], xmm0
	jmp	$LN2@SV_CheckSp
$LN3@SV_CheckSp:

; 148  : 
; 149  : 	return SphereIntersect( ent->v.origin, radiusSquared, traceOrg, traceDir );

	lea	eax, DWORD PTR _traceDir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _traceOrg$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _radiusSquared$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	call	_SphereIntersect
	add	esp, 16					; 00000010H
$LN1@SV_CheckSp:

; 150  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckSphereIntersection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_StudioPlayerBlend
_TEXT	SEGMENT
_pseqdesc$ = 8						; size = 4
_pBlend$ = 12						; size = 4
_pPitch$ = 16						; size = 4
_SV_StudioPlayerBlend PROC				; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 89   : 	// calc up/down pointing
; 90   : 	*pBlend = (*pPitch * 3);

	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@40400000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [edx], ecx

; 91   : 
; 92   : 	if( *pBlend < pseqdesc->blendstart[0] )

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+136]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@SV_StudioP

; 93   : 	{
; 94   : 		*pPitch -= pseqdesc->blendstart[0] / 3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _pPitch$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 95   : 		*pBlend = 0;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 0

; 96   : 	}

	jmp	$LN5@SV_StudioP
$LN2@SV_StudioP:

; 97   : 	else if( *pBlend > pseqdesc->blendend[0] )

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx+144]
	jbe	SHORT $LN4@SV_StudioP

; 98   : 	{
; 99   : 		*pPitch -= pseqdesc->blendend[0] / 3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+144]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _pPitch$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 100  : 		*pBlend = 255;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 255			; 000000ffH

; 101  : 	}

	jmp	$LN5@SV_StudioP
$LN4@SV_StudioP:

; 102  : 	else
; 103  : 	{
; 104  : 		if( pseqdesc->blendend[0] - pseqdesc->blendstart[0] < 0.1f ) // catch qc error

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	esi, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+144]
	subss	xmm0, DWORD PTR [esi+eax+136]
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@SV_StudioP

; 105  : 			*pBlend = 127;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 127			; 0000007fH
	jmp	SHORT $LN7@SV_StudioP
$LN6@SV_StudioP:

; 106  : 		else *pBlend = 255.0f * (*pBlend - pseqdesc->blendstart[0]) / (pseqdesc->blendend[0] - pseqdesc->blendstart[0]);

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	subss	xmm0, DWORD PTR [eax+edx+136]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	esi, DWORD PTR _pseqdesc$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+144]
	subss	xmm1, DWORD PTR [esi+ecx+136]
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@SV_StudioP:

; 107  : 		*pPitch = 0;

	mov	eax, DWORD PTR _pPitch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0
$LN5@SV_StudioP:

; 108  : 	}
; 109  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StudioPlayerBlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_InitBoxHull
_TEXT	SEGMENT
_side$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_InitBoxHull PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 57   : 	int	i, side;
; 58   : 
; 59   : 	box_hull.clipnodes = box_clipnodes;

	mov	DWORD PTR _box_hull, OFFSET _box_clipnodes

; 60   : 	box_hull.planes = box_planes;

	mov	DWORD PTR _box_hull+4, OFFSET _box_planes

; 61   : 	box_hull.firstclipnode = 0;

	mov	DWORD PTR _box_hull+8, 0

; 62   : 	box_hull.lastclipnode = 5;

	mov	DWORD PTR _box_hull+12, 5

; 63   : 
; 64   : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_InitBox
$LN2@SV_InitBox:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_InitBox:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@SV_InitBox

; 65   : 	{
; 66   : 		box_clipnodes[i].planenum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _box_clipnodes[eax*8], ecx

; 67   : 		
; 68   : 		side = i & 1;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	mov	DWORD PTR _side$[ebp], eax

; 69   : 		
; 70   : 		box_clipnodes[i].children[side] = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _side$[ebp]
	shl	eax, 1
	or	ecx, -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _box_clipnodes[eax+edx*8+4], cx

; 71   : 		if( i != 5 ) box_clipnodes[i].children[side^1] = i + 1;

	cmp	DWORD PTR _i$[ebp], 5
	je	SHORT $LN5@SV_InitBox
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _box_clipnodes[ecx+edx*8+4], ax
	jmp	SHORT $LN6@SV_InitBox
$LN5@SV_InitBox:

; 72   : 		else box_clipnodes[i].children[side^1] = CONTENTS_SOLID;

	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	shl	eax, 1
	mov	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _box_clipnodes[eax+edx*8+4], cx
$LN6@SV_InitBox:

; 73   : 		
; 74   : 		box_planes[i].type = i>>1;

	mov	eax, DWORD PTR _i$[ebp]
	sar	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _box_planes[ecx+16], al

; 75   : 		box_planes[i].normal[i>>1] = 1;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _i$[ebp]
	sar	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _box_planes[eax+ecx*4], xmm0

; 76   : 		box_planes[i].signbits = 0;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _box_planes[eax+17], 0

; 77   : 	}

	jmp	$LN2@SV_InitBox
$LN3@SV_InitBox:

; 78   : 	
; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitBoxHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_LightForEntity
_TEXT	SEGMENT
_end$ = -28						; size = 12
_start$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pEdict$ = 8						; size = 4
_SV_LightForEntity PROC					; COMDAT

; 1722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1723 : 	vec3_t	start, end;
; 1724 : 
; 1725 : 	if( FBitSet( pEdict->v.effects, EF_FULLBRIGHT ) || !sv.worldmodel->lightdata )

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+448]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN3@SV_LightFo
	mov	eax, DWORD PTR _sv+2595644
	cmp	DWORD PTR [eax+380], 0
	jne	SHORT $LN2@SV_LightFo
$LN3@SV_LightFo:

; 1726 : 		return 255;

	mov	eax, 255				; 000000ffH
	jmp	$LN1@SV_LightFo
$LN2@SV_LightFo:

; 1727 : 
; 1728 : 	// player has more precision light level that come from client-side
; 1729 : 	if( FBitSet( pEdict->v.flags, FL_CLIENT ))

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN4@SV_LightFo

; 1730 : 		return pEdict->v.light_level;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [eax+460]
	jmp	$LN1@SV_LightFo
$LN4@SV_LightFo:

; 1731 : 
; 1732 : 	VectorCopy( pEdict->v.origin, start );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _start$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _start$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _start$[ebp+ecx], eax

; 1733 : 	VectorCopy( pEdict->v.origin, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _end$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEdict$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _end$[ebp+ecx], eax

; 1734 : 
; 1735 : 	if( FBitSet( pEdict->v.effects, EF_INVLIGHT ))

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+448]
	and	ecx, 16					; 00000010H
	je	SHORT $LN5@SV_LightFo

; 1736 : 		end[2] = start[2] + world.size[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _start$[ebp+eax]
	addss	xmm0, DWORD PTR _world[ecx+2620]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _end$[ebp+edx], xmm0
	jmp	SHORT $LN6@SV_LightFo
$LN5@SV_LightFo:

; 1737 : 	else end[2] = start[2] - world.size[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _start$[ebp+eax]
	subss	xmm0, DWORD PTR _world[ecx+2620]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _end$[ebp+edx], xmm0
$LN6@SV_LightFo:

; 1738 : 	VectorSet( sv_pointColor, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _sv_pointColor[ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _sv_pointColor[edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _sv_pointColor[eax], xmm0

; 1739 : 
; 1740 : 	SV_RecursiveLightPoint( sv.worldmodel, sv.worldmodel->nodes, start, end );

	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	lea	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sv+2595644
	mov	eax, DWORD PTR [edx+164]
	push	eax
	mov	ecx, DWORD PTR _sv+2595644
	push	ecx
	call	_SV_RecursiveLightPoint
	add	esp, 16					; 00000010H

; 1741 : 
; 1742 : 	return VectorAvg( sv_pointColor );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _sv_pointColor[ecx]
	addss	xmm0, DWORD PTR _sv_pointColor[edx]
	mov	eax, 4
	shl	eax, 1
	addss	xmm0, DWORD PTR _sv_pointColor[eax]
	divss	xmm0, DWORD PTR __real@40400000
	cvttss2si eax, xmm0
$LN1@SV_LightFo:

; 1743 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LightForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_GetLightStyle
_TEXT	SEGMENT
_style$ = 8						; size = 4
_SV_GetLightStyle PROC					; COMDAT

; 1706 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1707 : 	if( style < 0 ) style = 0;

	cmp	DWORD PTR _style$[ebp], 0
	jge	SHORT $LN2@SV_GetLigh
	mov	DWORD PTR _style$[ebp], 0
$LN2@SV_GetLigh:

; 1708 : 	if( style >= MAX_LIGHTSTYLES )

	cmp	DWORD PTR _style$[ebp], 64		; 00000040H
	jl	SHORT $LN3@SV_GetLigh

; 1709 : 		Host_Error( "SV_GetLightStyle: style: %i >= %d", style, MAX_LIGHTSTYLES );

	push	64					; 00000040H
	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@DPHHNEEJ@SV_GetLightStyle?3?5style?3?5?$CFi?5?$DO?$DN?5@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN3@SV_GetLigh:

; 1710 : 
; 1711 : 	return sv.lightstyles[style].pattern;

	imul	eax, DWORD PTR _style$[ebp], 1296
	add	eax, OFFSET _sv+726216

; 1712 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_SetLightStyle
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_style$ = 8						; size = 4
_s$ = 12						; size = 4
_f$ = 16						; size = 4
_SV_SetLightStyle PROC					; COMDAT

; 1677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1678 : 	int	j, k;
; 1679 : 
; 1680 : 	Q_strncpy( sv.lightstyles[style].pattern, s, sizeof( sv.lightstyles[0].pattern ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	imul	ecx, DWORD PTR _style$[ebp], 1296
	add	ecx, OFFSET _sv+726216
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1681 : 	sv.lightstyles[style].time = f;

	imul	eax, DWORD PTR _style$[ebp], 1296
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _sv[eax+727508], xmm0

; 1682 : 
; 1683 : 	j = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _j$[ebp], eax

; 1684 : 	sv.lightstyles[style].length = j;

	imul	eax, DWORD PTR _style$[ebp], 1296
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _sv[eax+727496], ecx

; 1685 : 
; 1686 : 	for( k = 0; k < j; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@SV_SetLigh
$LN2@SV_SetLigh:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@SV_SetLigh:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jge	SHORT $LN3@SV_SetLigh

; 1687 : 		sv.lightstyles[style].map[k] = (float)(s[k] - 'a');

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 97					; 00000061H
	cvtsi2ss xmm0, ecx
	imul	edx, DWORD PTR _style$[ebp], 1296
	mov	eax, DWORD PTR _k$[ebp]
	movss	DWORD PTR _sv[edx+eax*4+726472], xmm0
	jmp	SHORT $LN2@SV_SetLigh
$LN3@SV_SetLigh:

; 1688 : 
; 1689 : 	if( sv.state != ss_active ) return;

	cmp	DWORD PTR _sv, 2
	je	SHORT $LN5@SV_SetLigh
	jmp	SHORT $LN1@SV_SetLigh
$LN5@SV_SetLigh:

; 1690 : 
; 1691 : 	// tell the clients about changed lightstyle
; 1692 : 	MSG_BeginServerCmd( &sv.reliable_datagram, svc_lightstyle );

	push	0
	push	1
	push	12					; 0000000cH
	push	OFFSET _sv+2431724
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1693 : 	MSG_WriteByte( &sv.reliable_datagram, style );

	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	push	OFFSET _sv+2431724
	call	_MSG_WriteByte
	add	esp, 8

; 1694 : 	MSG_WriteString( &sv.reliable_datagram, sv.lightstyles[style].pattern );

	imul	eax, DWORD PTR _style$[ebp], 1296
	add	eax, OFFSET _sv+726216
	push	eax
	push	OFFSET _sv+2431724
	call	_MSG_WriteString
	add	esp, 8

; 1695 : 	MSG_WriteFloat( &sv.reliable_datagram, sv.lightstyles[style].time );

	imul	eax, DWORD PTR _style$[ebp], 1296
	push	ecx
	movss	xmm0, DWORD PTR _sv[eax+727508]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _sv+2431724
	call	_MSG_WriteFloat
	add	esp, 8
$LN1@SV_SetLigh:

; 1696 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_RunLightStyles
_TEXT	SEGMENT
_scale$ = -16						; size = 4
_ls$ = -12						; size = 4
_ofs$ = -8						; size = 4
_i$ = -4						; size = 4
_SV_RunLightStyles PROC					; COMDAT

; 1650 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1651 : 	int		i, ofs;
; 1652 : 	lightstyle_t	*ls;
; 1653 : 	float		scale;
; 1654 : 
; 1655 : 	scale = sv_lighting_modulate->value;

	mov	eax, DWORD PTR _sv_lighting_modulate
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _scale$[ebp], xmm0

; 1656 : 
; 1657 : 	// run lightstyles animation
; 1658 : 	for( i = 0, ls = sv.lightstyles; i < MAX_LIGHTSTYLES; i++, ls++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _ls$[ebp], OFFSET _sv+726216
	jmp	SHORT $LN4@SV_RunLigh
$LN2@SV_RunLigh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ls$[ebp]
	add	ecx, 1296				; 00000510H
	mov	DWORD PTR _ls$[ebp], ecx
$LN4@SV_RunLigh:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN3@SV_RunLigh

; 1659 : 	{
; 1660 : 		ls->time += sv.frametime;

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	addss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [ecx+1292], xmm0

; 1661 : 		ofs = (ls->time * 10);

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+1292]
	mulss	xmm0, DWORD PTR __real@41200000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _ofs$[ebp], ecx

; 1662 : 
; 1663 : 		if( ls->length == 0 ) ls->value = scale; // disable this light

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1280], 0
	jne	SHORT $LN5@SV_RunLigh
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1284], xmm0
	jmp	SHORT $LN8@SV_RunLigh
$LN5@SV_RunLigh:

; 1664 : 		else if( ls->length == 1 ) ls->value = ( ls->map[0] / 12.0f ) * scale;

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1280], 1
	jne	SHORT $LN7@SV_RunLigh
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+256]
	divss	xmm0, DWORD PTR __real@41400000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [eax+1284], xmm0
	jmp	SHORT $LN8@SV_RunLigh
$LN7@SV_RunLigh:

; 1665 : 		else ls->value = ( ls->map[ofs % ls->length] / 12.0f ) * scale;

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _ofs$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	divss	xmm0, DWORD PTR __real@41400000
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [ecx+1284], xmm0
$LN8@SV_RunLigh:

; 1666 : 	}

	jmp	$LN2@SV_RunLigh
$LN3@SV_RunLigh:

; 1667 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RunLightStyles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_PointContents
_TEXT	SEGMENT
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_SV_PointContents PROC					; COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 806  : 	int cont = SV_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_SV_TruePointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 807  : 
; 808  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN2@SV_PointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN2@SV_PointCo

; 809  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN2@SV_PointCo:

; 810  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 811  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_TruePointContents
_TEXT	SEGMENT
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_SV_TruePointContents PROC				; COMDAT

; 783  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 784  : 	int	cont;
; 785  : 
; 786  : 	// sanity check
; 787  : 	if( !p ) return CONTENTS_NONE;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN2@SV_TruePoi
	xor	eax, eax
	jmp	SHORT $LN1@SV_TruePoi
$LN2@SV_TruePoi:

; 788  : 
; 789  : 	// get base contents from world
; 790  : 	cont = PM_HullPointContents( &sv.worldmodel->hulls[0], 0, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	0
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _sv+2595644
	lea	ecx, DWORD PTR [eax+edx+208]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cont$[ebp], eax

; 791  : 
; 792  : 	// check all water entities
; 793  : 	SV_WaterLinks( p, &cont, sv_areanodes );

	push	OFFSET _sv_areanodes
	lea	eax, DWORD PTR _cont$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_SV_WaterLinks
	add	esp, 12					; 0000000cH

; 794  : 
; 795  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]
$LN1@SV_TruePoi:

; 796  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_TouchLinks
_TEXT	SEGMENT
tv193 = -180						; size = 4
_matrix$1 = -112					; size = 64
_mod$ = -48						; size = 4
_offset$ = -44						; size = 12
_test$ = -32						; size = 12
_hull$ = -20						; size = 4
_touch$ = -16						; size = 4
_next$ = -12						; size = 4
_l$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_node$ = 12						; size = 4
_SV_TouchLinks PROC					; COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 505  : 	link_t	*l, *next;
; 506  : 	edict_t	*touch;
; 507  : 	hull_t	*hull;
; 508  : 	vec3_t	test, offset;
; 509  : 	model_t	*mod;
; 510  : 
; 511  : 	// touch linked edicts
; 512  : 	for( l = node->trigger_edicts.next; l != &node->trigger_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_TouchLi
$LN2@SV_TouchLi:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_TouchLi:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 16					; 00000010H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_TouchLi

; 513  : 	{
; 514  : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 515  : 		touch = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _touch$[ebp], eax

; 516  : 
; 517  : 		if( svgame.physFuncs.SV_TriggerTouch != NULL )

	cmp	DWORD PTR _svgame+19516, 0
	je	SHORT $LN5@SV_TouchLi

; 518  : 		{
; 519  : 			// user dll can override trigger checking (Xash3D extension)
; 520  : 			if( !svgame.physFuncs.SV_TriggerTouch( ent, touch ))

	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19516
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@SV_TouchLi

; 521  : 				continue;

	jmp	SHORT $LN2@SV_TouchLi
$LN7@SV_TouchLi:

; 522  : 		}

	jmp	$LN18@SV_TouchLi
$LN5@SV_TouchLi:

; 523  : 		else
; 524  : 		{
; 525  : 			if( touch == ent || touch->v.solid != SOLID_TRIGGER ) // disabled ?

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	eax, DWORD PTR _ent$[ebp]
	je	SHORT $LN9@SV_TouchLi
	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+400], 1
	je	SHORT $LN8@SV_TouchLi
$LN9@SV_TouchLi:

; 526  : 				continue;

	jmp	SHORT $LN2@SV_TouchLi
$LN8@SV_TouchLi:

; 527  : 
; 528  : 			if( touch->v.groupinfo && ent->v.groupinfo )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN12@SV_TouchLi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN12@SV_TouchLi

; 529  : 			{
; 530  : 				if( svs.groupop == GROUP_OP_AND && !FBitSet( touch->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN11@SV_TouchLi
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	jne	SHORT $LN11@SV_TouchLi

; 531  : 					continue;

	jmp	$LN2@SV_TouchLi
$LN11@SV_TouchLi:

; 532  : 
; 533  : 				if( svs.groupop == GROUP_OP_NAND && FBitSet( touch->v.groupinfo, ent->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN12@SV_TouchLi
	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	je	SHORT $LN12@SV_TouchLi

; 534  : 					continue;

	jmp	$LN2@SV_TouchLi
$LN12@SV_TouchLi:

; 535  : 			}
; 536  : 
; 537  : 			if( !BoundsIntersect( ent->v.absmin, ent->v.absmax, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 340				; 00000154H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 328				; 00000148H
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN13@SV_TouchLi

; 538  : 				continue;

	jmp	$LN2@SV_TouchLi
$LN13@SV_TouchLi:

; 539  : 
; 540  : 			mod = SV_ModelHandle( touch->v.modelindex );

	mov	eax, DWORD PTR _touch$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 541  : 
; 542  : 			// check brush triggers accuracy
; 543  : 			if( mod && mod->type == mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	$LN18@SV_TouchLi
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	$LN18@SV_TouchLi

; 544  : 			{
; 545  : 				// force to select bsp-hull
; 546  : 				hull = SV_HullForBsp( touch, ent->v.mins, ent->v.maxs, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 364				; 0000016cH
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 352				; 00000160H
	push	edx
	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	call	_SV_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 547  : 
; 548  : 				// support for rotational triggers
; 549  : 				if( FBitSet( mod->flags, MODEL_HAS_ORIGIN ) && !VectorIsNull( touch->v.angles ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	je	$LN15@SV_TouchLi
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_TouchLi
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_TouchLi
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _touch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@SV_TouchLi
$LN17@SV_TouchLi:

; 550  : 				{
; 551  : 					matrix4x4	matrix;
; 552  : 					Matrix4x4_CreateFromEntity( matrix, touch->v.angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 553  : 					Matrix4x4_VectorITransform( matrix, ent->v.origin, test );

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	lea	edx, DWORD PTR _matrix$1[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 554  : 				}

	jmp	$LN16@SV_TouchLi
$LN15@SV_TouchLi:

; 555  : 				else
; 556  : 				{
; 557  : 					// offset the test point appropriately for this hull.
; 558  : 					VectorSubtract( ent->v.origin, offset, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _test$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _test$[ebp+eax], xmm0
$LN16@SV_TouchLi:

; 559  : 				}
; 560  : 
; 561  : 				// test hull for intersection with this model
; 562  : 				if( PM_HullPointContents( hull, hull->firstclipnode, test ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _test$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN18@SV_TouchLi

; 563  : 					continue;

	jmp	$LN2@SV_TouchLi
$LN18@SV_TouchLi:

; 564  : 			}
; 565  : 		}
; 566  : 
; 567  : 		// never touch the triggers when "playersonly" is active
; 568  : 		if( !sv.playersonly )

	cmp	DWORD PTR _sv+2595648, 0
	jne	SHORT $LN19@SV_TouchLi

; 569  : 		{
; 570  : 			svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 571  : 			svgame.dllFuncs.pfnTouch( touch, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19288
	add	esp, 8
$LN19@SV_TouchLi:

; 572  : 		}
; 573  : 	}

	jmp	$LN2@SV_TouchLi
$LN3@SV_TouchLi:

; 574  : 	
; 575  : 	// recurse down both sides
; 576  : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN20@SV_TouchLi
	jmp	SHORT $LN22@SV_TouchLi
$LN20@SV_TouchLi:

; 577  : 	
; 578  : 	if( ent->v.absmax[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+340]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN21@SV_TouchLi

; 579  : 		SV_TouchLinks( ent, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_TouchLinks
	add	esp, 8
$LN21@SV_TouchLi:

; 580  : 	if( ent->v.absmin[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4+328]
	jbe	SHORT $LN22@SV_TouchLi

; 581  : 		SV_TouchLinks( ent, node->children[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_TouchLinks
	add	esp, 8
$LN22@SV_TouchLi:

; 582  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TouchLinks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_LinkEdict
_TEXT	SEGMENT
_headnode$ = -8						; size = 4
_node$ = -4						; size = 4
_ent$ = 8						; size = 4
_touch_triggers$ = 12					; size = 4
_SV_LinkEdict PROC					; COMDAT

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 634  : 	areanode_t	*node;
; 635  : 	int		headnode;
; 636  : 
; 637  : 	if( ent->area.prev ) SV_UnlinkEdict( ent );	// unlink from old position

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@SV_LinkEdi
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_UnlinkEdict
	add	esp, 4
$LN4@SV_LinkEdi:

; 638  : 	if( ent == svgame.edicts ) return;		// don't add the world

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	eax, DWORD PTR _svgame+7928
	jne	SHORT $LN5@SV_LinkEdi
	jmp	$LN21@SV_LinkEdi
$LN5@SV_LinkEdi:

; 639  : 	if( !SV_IsValidEdict( ent )) return;		// never add freed ents

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LinkEdict@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_LinkEdi
	jmp	$LN21@SV_LinkEdi
$LN6@SV_LinkEdi:

; 640  : 
; 641  : 	// set the abs box
; 642  : 	svgame.dllFuncs.pfnSetAbsBox( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19308
	add	esp, 4

; 643  : 
; 644  : 	if( ent->v.movetype == MOVETYPE_FOLLOW && SV_IsValidEdict( ent->v.aiment ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 12			; 0000000cH
	jne	SHORT $LN7@SV_LinkEdi
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_LinkEdict@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@SV_LinkEdi

; 645  : 	{
; 646  : 		memcpy( ent->leafnums, ent->v.aiment->leafnums, sizeof( ent->leafnums ));

	push	96					; 00000060H
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 647  : 		ent->num_leafs = ent->v.aiment->num_leafs;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax

; 648  : 		ent->headnode = ent->v.aiment->headnode;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax

; 649  : 	}

	jmp	SHORT $LN10@SV_LinkEdi
$LN7@SV_LinkEdi:

; 650  : 	else
; 651  : 	{
; 652  : 		// link to PVS leafs
; 653  : 		ent->num_leafs = 0;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+20], 0

; 654  : 		ent->headnode = -1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+16], -1

; 655  : 		headnode = -1;

	mov	DWORD PTR _headnode$[ebp], -1

; 656  : 
; 657  : 		if( ent->v.modelindex )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+308], 0
	je	SHORT $LN9@SV_LinkEdi

; 658  : 			SV_FindTouchedLeafs( ent, sv.worldmodel->nodes, &headnode );

	lea	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sv+2595644
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FindTouchedLeafs
	add	esp, 12					; 0000000cH
$LN9@SV_LinkEdi:

; 659  : 
; 660  : 		if( ent->num_leafs > MAX_ENT_LEAFS )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+20], 48			; 00000030H
	jle	SHORT $LN10@SV_LinkEdi

; 661  : 		{
; 662  : 			memset( ent->leafnums, -1, sizeof( ent->leafnums ));

	push	96					; 00000060H
	push	-1
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 663  : 			ent->num_leafs = 0;	// so we use headnode instead

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+20], 0

; 664  : 			ent->headnode = headnode;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _headnode$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN10@SV_LinkEdi:

; 665  : 		}
; 666  : 	}
; 667  : 
; 668  : 	// ignore non-solid bodies
; 669  : 	if( ent->v.solid == SOLID_NOT && ent->v.skin >= CONTENTS_EMPTY )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN11@SV_LinkEdi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+404], -1
	jl	SHORT $LN11@SV_LinkEdi

; 670  : 		return;

	jmp	$LN21@SV_LinkEdi
$LN11@SV_LinkEdi:

; 671  : 
; 672  : 	// find the first node that the ent's box crosses
; 673  : 	node = sv_areanodes;

	mov	DWORD PTR _node$[ebp], OFFSET _sv_areanodes
$LN2@SV_LinkEdi:

; 674  : 
; 675  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@SV_LinkEdi

; 676  : 	{
; 677  : 		if( node->axis == -1 ) break;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN12@SV_LinkEdi
	jmp	SHORT $LN3@SV_LinkEdi
$LN12@SV_LinkEdi:

; 678  : 		if( ent->v.absmin[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4+328]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN13@SV_LinkEdi

; 679  : 			node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN16@SV_LinkEdi
$LN13@SV_LinkEdi:

; 680  : 		else if( ent->v.absmax[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4+340]
	jbe	SHORT $LN15@SV_LinkEdi

; 681  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _node$[ebp], edx
	jmp	SHORT $LN16@SV_LinkEdi
$LN15@SV_LinkEdi:

; 682  : 		else break; // crosses the node

	jmp	SHORT $LN3@SV_LinkEdi
$LN16@SV_LinkEdi:

; 683  : 	}

	jmp	SHORT $LN2@SV_LinkEdi
$LN3@SV_LinkEdi:

; 684  : 	
; 685  : 	// link it in	
; 686  : 	if( ent->v.solid == SOLID_TRIGGER )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 1
	jne	SHORT $LN17@SV_LinkEdi

; 687  : 		InsertLinkBefore( &ent->area, &node->trigger_edicts );

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 8
	push	ecx
	call	_InsertLinkBefore
	add	esp, 8
	jmp	SHORT $LN20@SV_LinkEdi
$LN17@SV_LinkEdi:

; 688  : 	else if( ent->v.solid == SOLID_PORTAL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN19@SV_LinkEdi

; 689  : 		InsertLinkBefore( &ent->area, &node->portal_edicts );

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 8
	push	ecx
	call	_InsertLinkBefore
	add	esp, 8
	jmp	SHORT $LN20@SV_LinkEdi
$LN19@SV_LinkEdi:

; 690  : 	else InsertLinkBefore( &ent->area, &node->solid_edicts );

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 8
	push	ecx
	call	_InsertLinkBefore
	add	esp, 8
$LN20@SV_LinkEdi:

; 691  : 
; 692  : 	if( touch_triggers && !iTouchLinkSemaphore )

	cmp	DWORD PTR _touch_triggers$[ebp], 0
	je	SHORT $LN21@SV_LinkEdi
	cmp	DWORD PTR _iTouchLinkSemaphore, 0
	jne	SHORT $LN21@SV_LinkEdi

; 693  : 	{
; 694  : 		iTouchLinkSemaphore = true;

	mov	DWORD PTR _iTouchLinkSemaphore, 1

; 695  : 		SV_TouchLinks( ent, sv_areanodes );

	push	OFFSET _sv_areanodes
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_TouchLinks
	add	esp, 8

; 696  : 		iTouchLinkSemaphore = false;

	mov	DWORD PTR _iTouchLinkSemaphore, 0
$LN21@SV_LinkEdi:

; 697  : 	}
; 698  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LinkEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_MoveToss
_TEXT	SEGMENT
tv243 = -264						; size = 4
tv219 = -264						; size = 4
tv201 = -264						; size = 4
$T1 = -260						; size = 56
_i$ = -140						; size = 4
_trace$ = -136						; size = 56
_original_avelocity$ = -80				; size = 12
_original_angles$ = -68					; size = 12
_original_velocity$ = -56				; size = 12
_original_origin$ = -44					; size = 12
_end$ = -32						; size = 12
_move$ = -20						; size = 12
_gravity$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_tossent$ = 12						; size = 4
_ignore$ = 16						; size = 4
_SV_MoveToss PROC					; COMDAT

; 1507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1508 : 	float 	gravity;
; 1509 : 	vec3_t	move, end;
; 1510 : 	vec3_t	original_origin;
; 1511 : 	vec3_t	original_velocity;
; 1512 : 	vec3_t	original_angles;
; 1513 : 	vec3_t	original_avelocity;
; 1514 : 	trace_t	trace;
; 1515 : 	int	i;
; 1516 : 
; 1517 : 	VectorCopy( tossent->v.origin, original_origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _original_origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _original_origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _original_origin$[ebp+ecx], eax

; 1518 : 	VectorCopy( tossent->v.velocity, original_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _original_velocity$[ebp+ecx], eax

; 1519 : 	VectorCopy( tossent->v.angles, original_angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _original_angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _original_angles$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR [edx+eax+208]
	mov	DWORD PTR _original_angles$[ebp+ecx], eax

; 1520 : 	VectorCopy( tossent->v.avelocity, original_avelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+220]
	mov	DWORD PTR _original_avelocity$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+220]
	mov	DWORD PTR _original_avelocity$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR [edx+eax+220]
	mov	DWORD PTR _original_avelocity$[ebp+ecx], eax

; 1521 : 	gravity = tossent->v.gravity * svgame.movevars.gravity * 0.05f;

	mov	eax, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [eax+452]
	mulss	xmm0, DWORD PTR _svgame+7936
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _gravity$[ebp], xmm0

; 1522 : 
; 1523 : 	for( i = 0; i < 200; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_MoveTos
$LN2@SV_MoveTos:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_MoveTos:
	cmp	DWORD PTR _i$[ebp], 200			; 000000c8H
	jge	$LN3@SV_MoveTos

; 1524 : 	{
; 1525 : 		SV_CheckVelocity( tossent );

	mov	eax, DWORD PTR _tossent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1526 : 		tossent->v.velocity[2] -= gravity;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	subss	xmm0, DWORD PTR _gravity$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 1527 : 		VectorMA( tossent->v.angles, 0.05f, tossent->v.avelocity, tossent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	mulss	xmm0, DWORD PTR [edx+eax+220]
	mov	eax, DWORD PTR _tossent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+208]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	mulss	xmm0, DWORD PTR [eax+edx+220]
	mov	edx, DWORD PTR _tossent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+208]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	mulss	xmm0, DWORD PTR [ecx+eax+220]
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+208]
	addss	xmm1, xmm0
	movss	DWORD PTR tv201[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0

; 1528 : 		VectorScale( tossent->v.velocity, 0.05f, move );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+160]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+160]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR tv219[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _move$[ebp+ecx], xmm0

; 1529 : 		VectorAdd( tossent->v.origin, move, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR _move$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR _move$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR _move$[ebp+ecx]
	movss	DWORD PTR tv243[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv243[ebp]
	movss	DWORD PTR _end$[ebp+eax], xmm0

; 1530 : 		trace = SV_Move( tossent->v.origin, tossent->v.mins, tossent->v.maxs, end, MOVE_NORMAL, tossent, false );

	push	0
	mov	eax, DWORD PTR _tossent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tossent$[ebp]
	add	edx, 364				; 0000016cH
	push	edx
	mov	eax, DWORD PTR _tossent$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	mov	ecx, DWORD PTR _tossent$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1531 : 		VectorCopy( trace.endpos, tossent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 1532 : 		if( trace.fraction < 1.0f ) break;

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _trace$[ebp+16]
	jbe	SHORT $LN5@SV_MoveTos
	jmp	SHORT $LN3@SV_MoveTos
$LN5@SV_MoveTos:

; 1533 : 	}

	jmp	$LN2@SV_MoveTos
$LN3@SV_MoveTos:

; 1534 : 
; 1535 : 	VectorCopy( original_origin, tossent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR _original_origin$[ebp+ecx]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR _original_origin$[ebp+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR _original_origin$[ebp+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 1536 : 	VectorCopy( original_velocity, tossent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR _original_velocity$[ebp+ecx]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR _original_velocity$[ebp+edx]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR _original_velocity$[ebp+eax]
	mov	DWORD PTR [edx+ecx+160], eax

; 1537 : 	VectorCopy( original_angles, tossent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR _original_angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+208], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR _original_angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+208], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR _original_angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+208], eax

; 1538 : 	VectorCopy( original_avelocity, tossent->v.avelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	ecx, DWORD PTR _original_avelocity$[ebp+ecx]
	mov	DWORD PTR [edx+eax+220], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tossent$[ebp]
	mov	edx, DWORD PTR _original_avelocity$[ebp+edx]
	mov	DWORD PTR [ecx+eax+220], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tossent$[ebp]
	mov	eax, DWORD PTR _original_avelocity$[ebp+eax]
	mov	DWORD PTR [edx+ecx+220], eax

; 1539 : 
; 1540 : 	return trace;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 1541 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveToss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_TraceSurface
_TEXT	SEGMENT
tv148 = -180						; size = 4
tv95 = -180						; size = 4
_offset$ = -112						; size = 12
_end_l$ = -100						; size = 12
_start_l$ = -88						; size = 12
_hull$ = -76						; size = 4
_bmodel$ = -72						; size = 4
_matrix$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_SV_TraceSurface PROC					; COMDAT

; 1456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1457 : 	matrix4x4		matrix;
; 1458 : 	model_t		*bmodel;
; 1459 : 	hull_t		*hull;
; 1460 : 	vec3_t		start_l, end_l;
; 1461 : 	vec3_t		offset;
; 1462 : 
; 1463 : 	bmodel = SV_ModelHandle( ent->v.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _bmodel$[ebp], eax

; 1464 : 	if( !bmodel || bmodel->type != mod_brush )

	cmp	DWORD PTR _bmodel$[ebp], 0
	je	SHORT $LN3@SV_TraceSu
	mov	eax, DWORD PTR _bmodel$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN2@SV_TraceSu
$LN3@SV_TraceSu:

; 1465 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_TraceSu
$LN2@SV_TraceSu:

; 1466 : 
; 1467 : 	hull = SV_HullForBsp( ent, vec3_origin, vec3_origin, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 1468 : 
; 1469 : 	VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv95[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 1470 : 	VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv148[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0

; 1471 : 
; 1472 : 	// rotate start and end into the models frame of reference
; 1473 : 	if( !VectorIsNull( ent->v.angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SV_TraceSu
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SV_TraceSu
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@SV_TraceSu
$LN5@SV_TraceSu:

; 1474 : 	{
; 1475 : 		Matrix4x4_CreateFromEntity( matrix, ent->v.angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1476 : 		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 1477 : 		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN4@SV_TraceSu:

; 1478 : 	}
; 1479 : 
; 1480 : 	return PM_RecursiveSurfCheck( bmodel, &bmodel->nodes[hull->firstclipnode], start_l, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	imul	eax, DWORD PTR [edx+8], 52
	mov	ecx, DWORD PTR _bmodel$[ebp]
	add	eax, DWORD PTR [ecx+164]
	push	eax
	mov	edx, DWORD PTR _bmodel$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
$LN1@SV_TraceSu:

; 1481 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_TraceTexture
_TEXT	SEGMENT
_surf$ = -4						; size = 4
_ent$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_SV_TraceTexture PROC					; COMDAT

; 1492 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1493 : 	msurface_t	*surf = SV_TraceSurface( ent, start, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _surf$[ebp], eax

; 1494 : 
; 1495 : 	if( !surf || !surf->texinfo || !surf->texinfo->texture )

	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN3@SV_TraceTe
	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@SV_TraceTe
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN2@SV_TraceTe
$LN3@SV_TraceTe:

; 1496 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SV_TraceTe
$LN2@SV_TraceTe:

; 1497 : 
; 1498 : 	return surf->texinfo->texture->name;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+36]
$LN1@SV_TraceTe:

; 1499 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_MoveNormal
_TEXT	SEGMENT
$T1 = -120						; size = 56
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_type$ = 28						; size = 4
_e$ = 32						; size = 4
_SV_MoveNormal PROC					; COMDAT

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 1400 : 	return SV_Move( start, mins, maxs, end, type, e, false );

	push	0
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 1401 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveNormal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_MoveNoEnts
_TEXT	SEGMENT
tv93 = -224						; size = 4
_trace_fraction$ = -156					; size = 4
_trace_endpos$ = -152					; size = 12
_clip$ = -140						; size = 136
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_type$ = 28						; size = 4
_e$ = 32						; size = 4
_SV_MoveNoEnts PROC					; COMDAT

; 1409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1410 : 	moveclip_t	clip;
; 1411 : 	vec3_t		trace_endpos;
; 1412 : 	float		trace_fraction;
; 1413 : 
; 1414 : 	memset( &clip, 0, sizeof( moveclip_t ));

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1415 : 	SV_ClipMoveToEntity( EDICT_NUM( 0 ), start, mins, maxs, end, &clip.trace );

	lea	eax, DWORD PTR _clip$[ebp+68]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	push	0
	call	_SV_EdictNum
	add	esp, 4
	push	eax
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H

; 1416 : 
; 1417 : 	if( clip.trace.fraction != 0.0f )

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@SV_MoveNoE

; 1418 : 	{
; 1419 : 		VectorCopy( clip.trace.endpos, trace_endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clip$[ebp+ecx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clip$[ebp+edx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clip$[ebp+edx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx

; 1420 : 		trace_fraction = clip.trace.fraction;

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	movss	DWORD PTR _trace_fraction$[ebp], xmm0

; 1421 : 		clip.trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clip$[ebp+84], xmm0

; 1422 : 		clip.start = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _clip$[ebp+56], eax

; 1423 : 		clip.end = trace_endpos;

	lea	eax, DWORD PTR _trace_endpos$[ebp]
	mov	DWORD PTR _clip$[ebp+60], eax

; 1424 : 		clip.type = (type & 0xFF);

	mov	eax, DWORD PTR _type$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _clip$[ebp+124], eax

; 1425 : 		clip.ignoretrans = type >> 8;

	mov	eax, DWORD PTR _type$[ebp]
	sar	eax, 8
	mov	DWORD PTR _clip$[ebp+128], eax

; 1426 : 		clip.monsterclip = false;

	mov	DWORD PTR _clip$[ebp+132], 0

; 1427 : 		clip.passedict = (e) ? e : EDICT_NUM( 0 );

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN4@SV_MoveNoE
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN5@SV_MoveNoE
$LN4@SV_MoveNoE:
	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR tv93[ebp], eax
$LN5@SV_MoveNoE:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR _clip$[ebp+64], ecx

; 1428 : 		clip.mins = mins;

	mov	eax, DWORD PTR _mins$[ebp]
	mov	DWORD PTR _clip$[ebp+24], eax

; 1429 : 		clip.maxs = maxs;

	mov	eax, DWORD PTR _maxs$[ebp]
	mov	DWORD PTR _clip$[ebp+28], eax

; 1430 : 
; 1431 : 		VectorCopy( mins, clip.mins2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _clip$[ebp+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _clip$[ebp+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _clip$[ebp+ecx+32], eax

; 1432 : 		VectorCopy( maxs, clip.maxs2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _clip$[ebp+eax+44], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _clip$[ebp+eax+44], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _clip$[ebp+ecx+44], eax

; 1433 : 
; 1434 : 		World_MoveBounds( start, clip.mins2, clip.maxs2, trace_endpos, clip.boxmins, clip.boxmaxs );

	lea	eax, DWORD PTR _clip$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace_endpos$[ebp]
	push	edx
	lea	eax, DWORD PTR _clip$[ebp+44]
	push	eax
	lea	ecx, DWORD PTR _clip$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_World_MoveBounds
	add	esp, 24					; 00000018H

; 1435 : 		SV_ClipToWorldBrush( sv_areanodes, &clip );

	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	push	OFFSET _sv_areanodes
	call	_SV_ClipToWorldBrush
	add	esp, 8

; 1436 : 		SV_ClipToPortals( sv_areanodes, &clip );

	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	push	OFFSET _sv_areanodes
	call	_SV_ClipToPortals
	add	esp, 8

; 1437 : 
; 1438 : 		clip.trace.fraction *= trace_fraction;

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	mulss	xmm0, DWORD PTR _trace_fraction$[ebp]
	movss	DWORD PTR _clip$[ebp+84], xmm0

; 1439 : 		svgame.globals->trace_ent = clip.trace.ent;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _clip$[ebp+116]
	mov	DWORD PTR [eax+116], ecx
$LN2@SV_MoveNoE:

; 1440 : 	}
; 1441 : 
; 1442 : 	SV_CopyTraceToGlobal( &clip.trace );

	lea	eax, DWORD PTR _clip$[ebp+68]
	push	eax
	call	_SV_CopyTraceToGlobal
	add	esp, 4

; 1443 : 
; 1444 : 	return clip.trace;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _clip$[ebp+68]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 1445 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveNoEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_Move
_TEXT	SEGMENT
tv93 = -224						; size = 4
_trace_fraction$ = -156					; size = 4
_trace_endpos$ = -152					; size = 12
_clip$ = -140						; size = 136
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_type$ = 28						; size = 4
_e$ = 32						; size = 4
_monsterclip$ = 36					; size = 4
_SV_Move PROC						; COMDAT

; 1349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1350 : 	moveclip_t	clip;
; 1351 : 	vec3_t		trace_endpos;
; 1352 : 	float		trace_fraction;
; 1353 : 
; 1354 : 	memset( &clip, 0, sizeof( moveclip_t ));

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1355 : 	SV_ClipMoveToEntity( EDICT_NUM( 0 ), start, mins, maxs, end, &clip.trace );

	lea	eax, DWORD PTR _clip$[ebp+68]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	push	0
	call	_SV_EdictNum
	add	esp, 4
	push	eax
	call	_SV_ClipMoveToEntity
	add	esp, 24					; 00000018H

; 1356 : 
; 1357 : 	if( clip.trace.fraction != 0.0f )

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@SV_Move

; 1358 : 	{
; 1359 : 		VectorCopy( clip.trace.endpos, trace_endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _clip$[ebp+ecx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clip$[ebp+edx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clip$[ebp+edx+88]
	mov	DWORD PTR _trace_endpos$[ebp+eax], ecx

; 1360 : 		trace_fraction = clip.trace.fraction;

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	movss	DWORD PTR _trace_fraction$[ebp], xmm0

; 1361 : 		clip.trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clip$[ebp+84], xmm0

; 1362 : 		clip.start = start;

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _clip$[ebp+56], eax

; 1363 : 		clip.end = trace_endpos;

	lea	eax, DWORD PTR _trace_endpos$[ebp]
	mov	DWORD PTR _clip$[ebp+60], eax

; 1364 : 		clip.type = (type & 0xFF);

	mov	eax, DWORD PTR _type$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _clip$[ebp+124], eax

; 1365 : 		clip.ignoretrans = type >> 8;

	mov	eax, DWORD PTR _type$[ebp]
	sar	eax, 8
	mov	DWORD PTR _clip$[ebp+128], eax

; 1366 : 		clip.monsterclip = false;

	mov	DWORD PTR _clip$[ebp+132], 0

; 1367 : 		clip.passedict = (e) ? e : EDICT_NUM( 0 );

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN7@SV_Move
	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN8@SV_Move
$LN7@SV_Move:
	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR tv93[ebp], eax
$LN8@SV_Move:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR _clip$[ebp+64], ecx

; 1368 : 		clip.mins = mins;

	mov	eax, DWORD PTR _mins$[ebp]
	mov	DWORD PTR _clip$[ebp+24], eax

; 1369 : 		clip.maxs = maxs;

	mov	eax, DWORD PTR _maxs$[ebp]
	mov	DWORD PTR _clip$[ebp+28], eax

; 1370 : 
; 1371 : 		if( monsterclip && !FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	cmp	DWORD PTR _monsterclip$[ebp], 0
	je	SHORT $LN3@SV_Move
	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	jne	SHORT $LN3@SV_Move

; 1372 : 			clip.monsterclip = true;

	mov	DWORD PTR _clip$[ebp+132], 1
$LN3@SV_Move:

; 1373 : 
; 1374 : 		if( clip.type == MOVE_MISSILE )

	cmp	DWORD PTR _clip$[ebp+124], 2
	jne	$LN4@SV_Move

; 1375 : 		{
; 1376 : 			VectorSet( clip.mins2, -15.0f, -15.0f, -15.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@c1700000
	movss	DWORD PTR _clip$[ebp+ecx+32], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@c1700000
	movss	DWORD PTR _clip$[ebp+edx+32], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@c1700000
	movss	DWORD PTR _clip$[ebp+eax+32], xmm0

; 1377 : 			VectorSet( clip.maxs2,  15.0f,  15.0f,  15.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _clip$[ebp+ecx+44], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _clip$[ebp+edx+44], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR _clip$[ebp+eax+44], xmm0

; 1378 : 		}

	jmp	$LN5@SV_Move
$LN4@SV_Move:

; 1379 : 		else
; 1380 : 		{
; 1381 : 			VectorCopy( mins, clip.mins2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _clip$[ebp+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _clip$[ebp+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _clip$[ebp+ecx+32], eax

; 1382 : 			VectorCopy( maxs, clip.maxs2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _clip$[ebp+eax+44], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _clip$[ebp+eax+44], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _clip$[ebp+ecx+44], eax
$LN5@SV_Move:

; 1383 : 		}
; 1384 : 
; 1385 : 		World_MoveBounds( start, clip.mins2, clip.maxs2, trace_endpos, clip.boxmins, clip.boxmaxs );

	lea	eax, DWORD PTR _clip$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace_endpos$[ebp]
	push	edx
	lea	eax, DWORD PTR _clip$[ebp+44]
	push	eax
	lea	ecx, DWORD PTR _clip$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	_World_MoveBounds
	add	esp, 24					; 00000018H

; 1386 : 		SV_ClipToLinks( sv_areanodes, &clip );

	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	push	OFFSET _sv_areanodes
	call	_SV_ClipToLinks
	add	esp, 8

; 1387 : 		SV_ClipToPortals( sv_areanodes, &clip );

	lea	eax, DWORD PTR _clip$[ebp]
	push	eax
	push	OFFSET _sv_areanodes
	call	_SV_ClipToPortals
	add	esp, 8

; 1388 : 
; 1389 : 		clip.trace.fraction *= trace_fraction;

	movss	xmm0, DWORD PTR _clip$[ebp+84]
	mulss	xmm0, DWORD PTR _trace_fraction$[ebp]
	movss	DWORD PTR _clip$[ebp+84], xmm0

; 1390 : 		svgame.globals->trace_ent = clip.trace.ent;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _clip$[ebp+116]
	mov	DWORD PTR [eax+116], ecx
$LN2@SV_Move:

; 1391 : 	}
; 1392 : 
; 1393 : 	SV_CopyTraceToGlobal( &clip.trace );

	lea	eax, DWORD PTR _clip$[ebp+68]
	push	eax
	call	_SV_CopyTraceToGlobal
	add	esp, 4

; 1394 : 
; 1395 : 	return clip.trace;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _clip$[ebp+68]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 1396 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Move ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_CustomClipMoveToEntity
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_trace$ = 28						; size = 4
_SV_CustomClipMoveToEntity PROC				; COMDAT

; 1115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1116 : 	memset( trace, 0, sizeof( trace_t ));

	push	56					; 00000038H
	push	0
	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1117 : 	VectorCopy( end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 1118 : 	trace->allsolid = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 1

; 1119 : 	trace->fraction = 1.0f;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+16], xmm0

; 1120 : 
; 1121 : 	if( svgame.physFuncs.ClipMoveToEntity != NULL )

	cmp	DWORD PTR _svgame+19536, 0
	je	SHORT $LN2@SV_CustomC

; 1122 : 	{
; 1123 : 		// do custom sweep test
; 1124 : 		svgame.physFuncs.ClipMoveToEntity( ent, start, mins, maxs, end, trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	DWORD PTR _svgame+19536
	add	esp, 24					; 00000018H

; 1125 : 	}

	jmp	SHORT $LN3@SV_CustomC
$LN2@SV_CustomC:

; 1126 : 	else
; 1127 : 	{
; 1128 : 		// function is missed, so we didn't hit anything
; 1129 : 		trace->allsolid = false;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@SV_CustomC:

; 1130 : 	}
; 1131 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CustomClipMoveToEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClipMoveToEntity
_TEXT	SEGMENT
tv442 = -296						; size = 4
tv346 = -296						; size = 4
tv325 = -296						; size = 4
tv268 = -296						; size = 4
_out_maxs$1 = -228					; size = 12
_out_mins$2 = -216					; size = 12
_matrix$ = -204						; size = 64
_transform_bbox$ = -140					; size = 4
_rotated$ = -136					; size = 4
_hullcount$ = -132					; size = 4
_j$ = -128						; size = 4
_i$ = -124						; size = 4
_trace_hitbox$ = -120					; size = 56
_last_hitgroup$ = -64					; size = 4
_temp$ = -60						; size = 12
_offset$ = -48						; size = 12
_end_l$ = -36						; size = 12
_start_l$ = -24						; size = 12
_model$ = -12						; size = 4
_hull$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_trace$ = 28						; size = 4
_SV_ClipMoveToEntity PROC				; COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 864  : 	hull_t	*hull;
; 865  : 	model_t	*model;
; 866  : 	vec3_t	start_l, end_l;
; 867  : 	vec3_t	offset, temp;
; 868  : 	int	last_hitgroup;
; 869  : 	trace_t	trace_hitbox;
; 870  : 	int	i, j, hullcount;
; 871  : 	qboolean	rotated, transform_bbox;
; 872  : 	matrix4x4	matrix;
; 873  : 
; 874  : 	memset( trace, 0, sizeof( trace_t ));

	push	56					; 00000038H
	push	0
	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 875  : 	VectorCopy( end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 876  : 	trace->fraction = 1.0f;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+16], xmm0

; 877  : 	trace->allsolid = 1;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 1

; 878  : 
; 879  : 	model = SV_ModelHandle( ent->v.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 880  : 
; 881  : 	if( model && model->type == mod_studio )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN8@SV_ClipMov
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN8@SV_ClipMov

; 882  : 	{
; 883  : 		hull = SV_HullForStudioModel( ent, mins, maxs, offset, &hullcount );

	lea	eax, DWORD PTR _hullcount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_HullForStudioModel
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hull$[ebp], eax

; 884  : 	}

	jmp	SHORT $LN9@SV_ClipMov
$LN8@SV_ClipMov:

; 885  : 	else
; 886  : 	{
; 887  : 		hull = SV_HullForEntity( ent, mins, maxs, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_HullForEntity
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$[ebp], eax

; 888  : 		hullcount = 1;

	mov	DWORD PTR _hullcount$[ebp], 1
$LN9@SV_ClipMov:

; 889  : 	}
; 890  : 
; 891  : 	// rotate start and end into the models frame of reference
; 892  : 	if(( ent->v.solid == SOLID_BSP || ent->v.solid == SOLID_PORTAL ) && !VectorIsNull( ent->v.angles ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 4
	je	SHORT $LN12@SV_ClipMov
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 6
	jne	SHORT $LN10@SV_ClipMov
$LN12@SV_ClipMov:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@SV_ClipMov
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+208]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@SV_ClipMov
$LN13@SV_ClipMov:

; 893  : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN11@SV_ClipMov
$LN10@SV_ClipMov:

; 894  : 	else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN11@SV_ClipMov:

; 895  : 
; 896  : 	if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 8
	je	$LN14@SV_ClipMov

; 897  : 	{
; 898  : 		// keep untransformed bbox less than 45 degress or train on subtransit.bsp will stop working
; 899  : 		if(( check_angles( ent->v.angles[0] ) || check_angles( ent->v.angles[2] )) && !VectorIsNull( mins ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, 90					; 0000005aH
	je	$LN19@SV_ClipMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, 180				; 000000b4H
	je	$LN19@SV_ClipMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, 270				; 0000010eH
	je	$LN19@SV_ClipMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, -90				; ffffffa6H
	je	$LN19@SV_ClipMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, -180				; ffffff4cH
	je	$LN19@SV_ClipMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+208]
	cmp	eax, -270				; fffffef2H
	je	$LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, 90					; 0000005aH
	je	$LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, 180				; 000000b4H
	je	SHORT $LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, 270				; 0000010eH
	je	SHORT $LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, -90				; ffffffa6H
	je	SHORT $LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, -180				; ffffff4cH
	je	SHORT $LN19@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+208]
	cmp	edx, -270				; fffffef2H
	jne	SHORT $LN16@SV_ClipMov
$LN19@SV_ClipMov:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_ClipMov
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_ClipMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@SV_ClipMov
$LN20@SV_ClipMov:

; 900  : 			transform_bbox = true;

	mov	DWORD PTR _transform_bbox$[ebp], 1
	jmp	SHORT $LN17@SV_ClipMov
$LN16@SV_ClipMov:

; 901  : 		else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN17@SV_ClipMov:

; 902  : 	}

	jmp	SHORT $LN15@SV_ClipMov
$LN14@SV_ClipMov:

; 903  : 	else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN15@SV_ClipMov:

; 904  : 
; 905  : 	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	$LN21@SV_ClipMov

; 906  : 	{
; 907  : 		vec3_t	out_mins, out_maxs;
; 908  : 
; 909  : 		if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	SHORT $LN23@SV_ClipMov

; 910  : 			Matrix4x4_CreateFromEntity( matrix, ent->v.angles, ent->v.origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN24@SV_ClipMov
$LN23@SV_ClipMov:

; 911  : 		else Matrix4x4_CreateFromEntity( matrix, ent->v.angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN24@SV_ClipMov:

; 912  : 
; 913  : 		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 914  : 		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 915  :                               
; 916  : 		if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	$LN3@SV_ClipMov

; 917  : 		{
; 918  : 			World_TransformAABB( matrix, mins, maxs, out_mins, out_maxs );

	lea	eax, DWORD PTR _out_maxs$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _out_mins$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_World_TransformAABB
	add	esp, 20					; 00000014H

; 919  : 			VectorSubtract( hull->clip_mins, out_mins, offset ); // calc new local offset

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR _out_mins$2[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _out_mins$2[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _out_mins$2[ebp+ecx]
	movss	DWORD PTR tv268[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 920  : 
; 921  : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@SV_ClipMov
$LN2@SV_ClipMov:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@SV_ClipMov:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN3@SV_ClipMov

; 922  : 			{
; 923  : 				if( start_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN26@SV_ClipMov

; 924  : 					start_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN27@SV_ClipMov
$LN26@SV_ClipMov:

; 925  : 				else start_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+edx*4], xmm0
$LN27@SV_ClipMov:

; 926  : 				if( end_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN28@SV_ClipMov

; 927  : 					end_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN29@SV_ClipMov
$LN28@SV_ClipMov:

; 928  : 				else end_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
$LN29@SV_ClipMov:

; 929  : 			}

	jmp	$LN2@SV_ClipMov
$LN3@SV_ClipMov:

; 930  : 		}
; 931  : 	}

	jmp	$LN22@SV_ClipMov
$LN21@SV_ClipMov:

; 932  : 	else
; 933  : 	{
; 934  : 		VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv325[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv325[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 935  : 		VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv346[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv346[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN22@SV_ClipMov:

; 936  : 	}
; 937  : 
; 938  : 	if( hullcount == 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jne	SHORT $LN30@SV_ClipMov

; 939  : 	{
; 940  : 		PM_RecursiveHullCheck( hull, hull->firstclipnode, 0.0f, 1.0f, start_l, end_l, (pmtrace_t *)trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 941  : 	}

	jmp	$LN31@SV_ClipMov
$LN30@SV_ClipMov:

; 942  : 	else
; 943  : 	{
; 944  : 		last_hitgroup = 0;

	mov	DWORD PTR _last_hitgroup$[ebp], 0

; 945  : 
; 946  : 		for( i = 0; i < hullcount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_ClipMov
$LN5@SV_ClipMov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_ClipMov:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _hullcount$[ebp]
	jge	$LN6@SV_ClipMov

; 947  : 		{
; 948  : 			memset( &trace_hitbox, 0, sizeof( trace_t ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _trace_hitbox$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 949  : 			VectorCopy( end, trace_hitbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_hitbox$[ebp+ecx+20], eax

; 950  : 			trace_hitbox.fraction = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_hitbox$[ebp+16], xmm0

; 951  : 			trace_hitbox.allsolid = 1;

	mov	DWORD PTR _trace_hitbox$[ebp], 1

; 952  : 
; 953  : 			PM_RecursiveHullCheck( &hull[i], hull[i].firstclipnode, 0.0f, 1.0f, start_l, end_l, (pmtrace_t *)&trace_hitbox );

	lea	eax, DWORD PTR _trace_hitbox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 954  : 
; 955  : 			if( i == 0 || trace_hitbox.allsolid || trace_hitbox.startsolid || trace_hitbox.fraction < trace->fraction )

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN33@SV_ClipMov
	cmp	DWORD PTR _trace_hitbox$[ebp], 0
	jne	SHORT $LN33@SV_ClipMov
	cmp	DWORD PTR _trace_hitbox$[ebp+4], 0
	jne	SHORT $LN33@SV_ClipMov
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR _trace_hitbox$[ebp+16]
	jbe	SHORT $LN32@SV_ClipMov
$LN33@SV_ClipMov:

; 956  : 			{
; 957  : 				if( trace->startsolid )

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN34@SV_ClipMov

; 958  : 				{
; 959  : 					*trace = trace_hitbox;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	mov	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 960  : 					trace->startsolid = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+4], 1

; 961  : 				}

	jmp	SHORT $LN35@SV_ClipMov
$LN34@SV_ClipMov:

; 962  : 				else *trace = trace_hitbox;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	mov	edi, DWORD PTR _trace$[ebp]
	rep movsd
$LN35@SV_ClipMov:

; 963  : 
; 964  : 				last_hitgroup = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _last_hitgroup$[ebp], eax
$LN32@SV_ClipMov:

; 965  : 			}
; 966  : 		}

	jmp	$LN5@SV_ClipMov
$LN6@SV_ClipMov:

; 967  : 
; 968  : 		trace->hitgroup = Mod_HitgroupForStudioHull( last_hitgroup );

	mov	eax, DWORD PTR _last_hitgroup$[ebp]
	push	eax
	call	_Mod_HitgroupForStudioHull
	add	esp, 4
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN31@SV_ClipMov:

; 969  : 	}
; 970  : 
; 971  : 	if( trace->fraction != 1.0f )

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN38@SV_ClipMov

; 972  : 	{
; 973  : 		// compute endpos (generic case)
; 974  : 		VectorLerp( start, trace->fraction, end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv442[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv442[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 975  : 
; 976  : 		if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	$LN37@SV_ClipMov

; 977  : 		{
; 978  : 			// transform plane
; 979  : 			VectorCopy( trace->plane.normal, temp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR _temp$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], eax

; 980  : 			Matrix4x4_TransformPositivePlane( matrix, temp, trace->plane.dist, trace->plane.normal, &trace->plane.dist );

	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _trace$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H

; 981  : 		}

	jmp	SHORT $LN38@SV_ClipMov
$LN37@SV_ClipMov:

; 982  : 		else
; 983  : 		{
; 984  : 			trace->plane.dist = DotProduct( trace->endpos, trace->plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	mulss	xmm0, DWORD PTR [esi+eax+32]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+20]
	mulss	xmm1, DWORD PTR [esi+ecx+32]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+20]
	mulss	xmm1, DWORD PTR [esi+ecx+32]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [eax+44], xmm0
$LN38@SV_ClipMov:

; 985  : 		}
; 986  : 	}
; 987  : 
; 988  : 	if( trace->fraction < 1.0f || trace->startsolid )

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+16]
	ja	SHORT $LN40@SV_ClipMov
	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN39@SV_ClipMov
$LN40@SV_ClipMov:

; 989  : 		trace->ent = ent;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+48], ecx
$LN39@SV_ClipMov:

; 990  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipMoveToEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_UnlinkEdict
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_SV_UnlinkEdict PROC					; COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 	// not linked in anywhere
; 491  : 	if( !ent->area.prev ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@SV_UnlinkE
	jmp	SHORT $LN1@SV_UnlinkE
$LN2@SV_UnlinkE:

; 492  : 
; 493  : 	RemoveLink( &ent->area );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 8
	push	eax
	call	_RemoveLink
	add	esp, 4

; 494  : 	ent->area.prev = NULL;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+8], 0

; 495  : 	ent->area.next = NULL;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN1@SV_UnlinkE:

; 496  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UnlinkEdict ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_ClearWorld
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_ClearWorld PROC					; COMDAT

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 465  : 	int	i;
; 466  : 
; 467  : 	SV_InitBoxHull(); // for box testing

	call	_SV_InitBoxHull

; 468  : 
; 469  : 	// clear lightstyles
; 470  : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_ClearWo
$LN2@SV_ClearWo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ClearWo:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@SV_ClearWo

; 471  : 	{
; 472  : 		sv.lightstyles[i].value = 256.0f;

	imul	eax, DWORD PTR _i$[ebp], 1296
	movss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR _sv[eax+727500], xmm0

; 473  : 		sv.lightstyles[i].time = 0.0f;

	imul	eax, DWORD PTR _i$[ebp], 1296
	xorps	xmm0, xmm0
	movss	DWORD PTR _sv[eax+727508], xmm0

; 474  : 	}

	jmp	SHORT $LN2@SV_ClearWo
$LN3@SV_ClearWo:

; 475  : 
; 476  : 	memset( sv_areanodes, 0, sizeof( sv_areanodes ));

	push	1280					; 00000500H
	push	0
	push	OFFSET _sv_areanodes
	call	_memset
	add	esp, 12					; 0000000cH

; 477  : 	iTouchLinkSemaphore = 0;

	mov	DWORD PTR _iTouchLinkSemaphore, 0

; 478  : 	sv_numareanodes = 0;

	mov	DWORD PTR _sv_numareanodes, 0

; 479  : 
; 480  : 	SV_CreateAreaNode( 0, sv.worldmodel->mins, sv.worldmodel->maxs );

	mov	eax, DWORD PTR _sv+2595644
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _sv+2595644
	add	ecx, 84					; 00000054H
	push	ecx
	push	0
	call	_SV_CreateAreaNode
	add	esp, 12					; 0000000cH

; 481  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClearWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_world.c
;	COMDAT _SV_TestEntityPosition
_TEXT	SEGMENT
tv67 = -188						; size = 4
$T1 = -184						; size = 56
_trace$ = -64						; size = 56
_monsterClip$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_blocker$ = 12						; size = 4
_SV_TestEntityPosition PROC				; COMDAT

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 824  : 	qboolean	monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN9@SV_TestEnt
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN10@SV_TestEnt
$LN9@SV_TestEnt:
	mov	DWORD PTR tv67[ebp], 0
$LN10@SV_TestEnt:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 825  : 	trace_t	trace;
; 826  : 
; 827  : 	if( FBitSet( ent->v.flags, FL_CLIENT|FL_FAKECLIENT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	je	$LN2@SV_TestEnt

; 828  : 	{
; 829  : 		// to avoid falling through tracktrain update client mins\maxs here
; 830  : 		if( FBitSet( ent->v.flags, FL_DUCKING )) 

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN3@SV_TestEnt

; 831  : 			SV_SetMinMaxSize( ent, svgame.pmove->player_mins[1], svgame.pmove->player_maxs[1], true );

	push	1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+324904]
	push	edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+324856]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@SV_TestEnt
$LN3@SV_TestEnt:

; 832  : 		else SV_SetMinMaxSize( ent, svgame.pmove->player_mins[0], svgame.pmove->player_maxs[0], true );

	push	1
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+324904]
	push	eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _svgame+8256
	lea	ecx, DWORD PTR [eax+edx+324856]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H
$LN2@SV_TestEnt:

; 833  : 	}
; 834  : 
; 835  : 	trace = SV_Move( ent->v.origin, ent->v.mins, ent->v.maxs, ent->v.origin, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 836  : 
; 837  : 	if( SV_IsValidEdict( blocker ) && SV_IsValidEdict( trace.ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_TestEntityPosition@@9@9
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _blocker$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@SV_TestEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_TestEntityPosition@@9@9
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_0DF@CEOLNADP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@SV_TestEnt

; 838  : 	{
; 839  : 		if( trace.ent->v.movetype == MOVETYPE_PUSH || trace.ent == blocker )

	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [eax+396], 7
	je	SHORT $LN7@SV_TestEnt
	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	eax, DWORD PTR _blocker$[ebp]
	jne	SHORT $LN6@SV_TestEnt
$LN7@SV_TestEnt:

; 840  : 			return trace.startsolid;

	mov	eax, DWORD PTR _trace$[ebp+4]
	jmp	SHORT $LN1@SV_TestEnt
$LN6@SV_TestEnt:

; 841  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_TestEnt
$LN5@SV_TestEnt:

; 842  : 	}
; 843  : 
; 844  : 	return trace.startsolid;

	mov	eax, DWORD PTR _trace$[ebp+4]
$LN1@SV_TestEnt:

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TestEntityPosition ENDP
_TEXT	ENDS
END
