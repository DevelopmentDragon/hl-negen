; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\mod_bmodel.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08PNMNOKOB@entities@			; `string'
PUBLIC	??_C@_06MEGIMCLI@planes@			; `string'
PUBLIC	??_C@_08NJIMCCJK@textures@			; `string'
PUBLIC	??_C@_08FMFHCCLE@vertexes@			; `string'
PUBLIC	??_C@_0L@CNKMJODB@visibility@			; `string'
PUBLIC	??_C@_05JJOLJDEA@nodes@				; `string'
PUBLIC	??_C@_07GNNMAGOE@texinfo@			; `string'
PUBLIC	??_C@_05FHFPJHPF@faces@				; `string'
PUBLIC	??_C@_09GHHBMBIA@lightmaps@			; `string'
PUBLIC	??_C@_09GIOIPMON@clipnodes@			; `string'
PUBLIC	??_C@_05KLALGEIB@leafs@				; `string'
PUBLIC	??_C@_09NNCMKPF@markfaces@			; `string'
PUBLIC	??_C@_05JGEJPNHM@edges@				; `string'
PUBLIC	??_C@_09GFFIGDJK@surfedges@			; `string'
PUBLIC	??_C@_06FEMFHOOG@models@			; `string'
PUBLIC	??_C@_09LODDFDED@deluxmaps@			; `string'
PUBLIC	??_C@_09FMFDCLAK@faceinfos@			; `string'
PUBLIC	??_C@_09JIDODEBC@shadowmap@			; `string'
_DATA	SEGMENT
COMM	_world:BYTE:0a48H
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_BSS	SEGMENT
_srcmodel DB	024acH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09JIDODEBC@shadowmap@
CONST	SEGMENT
??_C@_09JIDODEBC@shadowmap@ DB 'shadowmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMFDCLAK@faceinfos@
CONST	SEGMENT
??_C@_09FMFDCLAK@faceinfos@ DB 'faceinfos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LODDFDED@deluxmaps@
CONST	SEGMENT
??_C@_09LODDFDED@deluxmaps@ DB 'deluxmaps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FEMFHOOG@models@
CONST	SEGMENT
??_C@_06FEMFHOOG@models@ DB 'models', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GFFIGDJK@surfedges@
CONST	SEGMENT
??_C@_09GFFIGDJK@surfedges@ DB 'surfedges', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JGEJPNHM@edges@
CONST	SEGMENT
??_C@_05JGEJPNHM@edges@ DB 'edges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNCMKPF@markfaces@
CONST	SEGMENT
??_C@_09NNCMKPF@markfaces@ DB 'markfaces', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KLALGEIB@leafs@
CONST	SEGMENT
??_C@_05KLALGEIB@leafs@ DB 'leafs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIOIPMON@clipnodes@
CONST	SEGMENT
??_C@_09GIOIPMON@clipnodes@ DB 'clipnodes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHHBMBIA@lightmaps@
CONST	SEGMENT
??_C@_09GHHBMBIA@lightmaps@ DB 'lightmaps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHFPJHPF@faces@
CONST	SEGMENT
??_C@_05FHFPJHPF@faces@ DB 'faces', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GNNMAGOE@texinfo@
CONST	SEGMENT
??_C@_07GNNMAGOE@texinfo@ DB 'texinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JJOLJDEA@nodes@
CONST	SEGMENT
??_C@_05JJOLJDEA@nodes@ DB 'nodes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNKMJODB@visibility@
CONST	SEGMENT
??_C@_0L@CNKMJODB@visibility@ DB 'visibility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FMFHCCLE@vertexes@
CONST	SEGMENT
??_C@_08FMFHCCLE@vertexes@ DB 'vertexes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NJIMCCJK@textures@
CONST	SEGMENT
??_C@_08NJIMCCJK@textures@ DB 'textures', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MEGIMCLI@planes@
CONST	SEGMENT
??_C@_06MEGIMCLI@planes@ DB 'planes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNMNOKOB@entities@
CONST	SEGMENT
??_C@_08PNMNOKOB@entities@ DB 'entities', 00H		; `string'
CONST	ENDS
PUBLIC	_Mod_LoadBrushModel
PUBLIC	_Mod_TestBmodelLumps
PUBLIC	_Mod_HeadnodeVisible
PUBLIC	_Mod_FatPVS
PUBLIC	_Mod_BoxVisible
PUBLIC	_Mod_CheckLump
PUBLIC	_Mod_ReadLump
PUBLIC	_Mod_SaveLump
PUBLIC	_Mod_PointInLeaf
PUBLIC	_Mod_AmbientLevels
PUBLIC	_Mod_SampleSizeForFace
PUBLIC	_Mod_GetPVSForPoint
PUBLIC	_Mod_UnloadBrushModel
PUBLIC	_Mod_PrintWorldStats_f
PUBLIC	_Mod_DecompressPVS
PUBLIC	_Mod_LoadBmodelLumps
PUBLIC	??_C@_0CD@FBEFGCON@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5@ ; `string'
PUBLIC	??_C@_0CB@BLAKDKDN@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5?$CFs@ ; `string'
PUBLIC	??_C@_0CI@JCBLNEDP@?$FO1Error?3?$FO7?5Mod_Load?$CFs?3?5funny?5lu@ ; `string'
PUBLIC	??_C@_0CH@OFCIPOAE@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too?5m@ ; `string'
PUBLIC	??_C@_0CJ@EBAPCGFM@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too@ ; `string'
PUBLIC	??_C@_0CG@MFBOJPAE@?$CF?912s?5?5?$CF7i?1?$CF?97i?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?4@ ; `string'
PUBLIC	??_C@_0BG@BBOCJOCH@?$FO1SIZE?5OVERFLOW?$CB?$CB?$CB?$FO7?6@ ; `string'
PUBLIC	??_C@_0BC@BGBEIFII@?$FO3SIZE?5DANGER?$CB?$FO7?6@ ; `string'
PUBLIC	??_C@_0BA@DLPMCLNL@?$FO2VERY?5FULL?$CB?$FO7?6@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0L@JPFAHBCL@?$FLvariable?$FN@		; `string'
PUBLIC	??_C@_0CD@IKFPEOPA@?$CF?915s?5?5?$CF?912s?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?41f?$CF@ ; `string'
PUBLIC	??_C@_0P@NJOFMENC@No?5map?5loaded?6@		; `string'
PUBLIC	??_C@_0DK@CJHLEKBM@Object?5names?5?5Objects?1Maxobjs?5?5@ ; `string'
PUBLIC	??_C@_0DK@NCLGKDEM@?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5@ ; `string'
PUBLIC	??_C@_0CM@IHJJKKPB@?$DN?$DN?$DN?5Total?5BSP?5file?5data?5space?5u@ ; `string'
PUBLIC	??_C@_0BP@HPFFJPPF@World?5size?5?$CI?5?$CFg?5?$CFg?5?$CFg?5?$CJ?5units?6@ ; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes@				; `string'
PUBLIC	??_C@_02JINPPBEP@No@				; `string'
PUBLIC	??_C@_0CH@GEMHJKNN@Supports?5transparency?5world?5wat@ ; `string'
PUBLIC	??_C@_07FDKIFLAA@colored@			; `string'
PUBLIC	??_C@_0L@FEJFGKNE@monochrome@			; `string'
PUBLIC	??_C@_0O@KBDFHKBH@Lighting?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BH@JEPAGEFC@World?5total?5leafs?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BF@OKPHAEMF@original?5name?3?5?$FO1?$CFs?6@ ; `string'
PUBLIC	??_C@_04NOEIOHFM@?$FO2?$CFs@			; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_0BD@OCIFFDNI@internal?5name?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_04GGPEIADJ@?$FO3?$CFs@			; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown@			; `string'
PUBLIC	??_C@_0BC@JFEJOENI@map?5compiler?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BA@HMHCEHFL@map?5editor?3?5?$CFs?6@	; `string'
PUBLIC	?__LINE__Var@?0??Mod_PointInLeaf@@9@9		; `Mod_PointInLeaf'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??Mod_GetPVSForPoint@@9@9	; `Mod_GetPVSForPoint'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_FatPVS@@9@9		; `Mod_FatPVS'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@JNODKEGC@Mod_FindModelOrigin?3?5found?5?$CFs?5w@ ; `string'
PUBLIC	??_C@_0DA@KDJJLMGP@Mod_FindModelOrigin?3?5EOF?5withou@ ; `string'
PUBLIC	??_C@_0DB@DMBFGDCJ@Mod_FindModelOrigin?3?5closing?5br@ ; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_06NHCMNMEH@origin@			; `string'
PUBLIC	??_C@_0CC@GDPMEJOM@Mod_CalcSurfaceExtents?3?5bad?5edg@ ; `string'
PUBLIC	??_C@_0CD@MJPHIMFM@?$FO1Error?3?$FO7?5Bad?5surface?5extents?5@ ; `string'
PUBLIC	??_C@_0CB@DIJBMDAC@Mod_CalcSurfaceBounds?3?5bad?5edge@ ; `string'
PUBLIC	??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_MakeHull0@@9@9		; `Mod_MakeHull0'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_SetupHull@@9@9		; `Mod_SetupHull'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@ONMMJLDG@Mod_SetupHull?3?5bad?5hull?5number?5@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9	; `Mod_LoadColoredLighting'::`1'::__LINE__Var
PUBLIC	??_C@_0M@KPNLOLCL@maps?1?$CFs?4lit@		; `string'
PUBLIC	??_C@_0CJ@DFGMPNGN@?$FO3Warning?3?$FO7?5?$CFs?5probably?5is?5out@ ; `string'
PUBLIC	??_C@_0L@DHKGJOLH@in?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0DF@HGHNGDJB@?$FO1Error?3?$FO7?5?$CFs?5has?5mismatched?5si@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9		; `Mod_LoadDeluxemap'::`1'::__LINE__Var
PUBLIC	??_C@_0N@PEBABFIJ@maps?1?$CFs?4dlit@		; `string'
PUBLIC	?__LINE__Var@?0??Mod_SetupSubmodels@@9@9	; `Mod_SetupSubmodels'::`1'::__LINE__Var
PUBLIC	??_C@_03JLINDLFM@?$CK?$CFi@			; `string'
PUBLIC	??_C@_0O@ONGNOMOA@maps?1c2a1?4bsp@		; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadSubmodels@@9@9		; `Mod_LoadSubmodels'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadEntities@@9@9		; `Mod_LoadEntities'::`1'::__LINE__Var
PUBLIC	??_C@_04ECMOMEGO@?4ent@				; `string'
PUBLIC	??_C@_0DH@NKJPPPMJ@?$FO3Warning?3?$FO7?5Entity?5patch?5is?5ol@ ; `string'
PUBLIC	??_C@_0BL@ICFKCIBG@?$FO2Read?5entity?5patch?3?$FO7?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CN@FABNGMMO@Mod_LoadEntities?3?5found?5?$CFs?5when@ ; `string'
PUBLIC	??_C@_0CN@GOGHHEMD@Mod_LoadEntities?3?5EOF?5without?5c@ ; `string'
PUBLIC	??_C@_0CO@ODLIHCCC@Mod_LoadEntities?3?5closing?5brace@ ; `string'
PUBLIC	??_C@_03GANHLHHC@wad@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL@				; `string'
PUBLIC	??_C@_06LCDNEPCB@?$CFs?4wad@			; `string'
PUBLIC	??_C@_07ONPBMBOP@message@			; `string'
PUBLIC	??_C@_08CCFHILPL@compiler@			; `string'
PUBLIC	??_C@_09GPMLCKOG@_compiler@			; `string'
PUBLIC	??_C@_09HNDCMPDF@generator@			; `string'
PUBLIC	??_C@_0L@BOHJDPEN@_generator@			; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadPlanes@@9@9		; `Mod_LoadPlanes'::`1'::__LINE__Var
PUBLIC	??_C@_0CF@GAMEGDJP@?$FO1Error?3?$FO7?5bad?5normal?5for?5plane@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadVertexes@@9@9		; `Mod_LoadVertexes'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadEdges@@9@9		; `Mod_LoadEdges'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadSurfEdges@@9@9		; `Mod_LoadSurfEdges'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadMarkSurfaces@@9@9	; `Mod_LoadMarkSurfaces'::`1'::__LINE__Var
PUBLIC	??_C@_0CP@FKACGMIN@Mod_LoadMarkFaces?3?5bad?5surface?5@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadTextures@@9@9		; `Mod_LoadTextures'::`1'::__LINE__Var
PUBLIC	??_C@_08KPIGECMN@?$CKdefault@			; `string'
PUBLIC	??_C@_09PEJHDEOI@miptex_?$CFi@			; `string'
PUBLIC	??_C@_03BNEOMJOP@sky@				; `string'
PUBLIC	??_C@_06KNCEHODH@?$CFs?4mip@			; `string'
PUBLIC	??_C@_09NEMDCCOI@?$CFs?4wad?1?$CFs@		; `string'
PUBLIC	??_C@_0L@DAOGIBEC@?$CD?$CFs?3?$CFs?4mip@	; `string'
PUBLIC	??_C@_0CC@CPEGMNDG@?$FO1Error?3?$FO7?5unable?5to?5find?5?$CFs?4mi@ ; `string'
PUBLIC	??_C@_0BA@DKDOIIAE@?$CD?$CFs?3?$CFs_luma?4mip@	; `string'
PUBLIC	??_C@_0O@JGOPFOPL@?$CFs?4wad?1?$CFs?4mip@	; `string'
PUBLIC	??_C@_0DH@GBOGMJNF@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5ba@ ; `string'
PUBLIC	??_C@_0DF@BJKAAKLM@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5mi@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadTexInfo@@9@9		; `Mod_LoadTexInfo'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadSurfaces@@9@9		; `Mod_LoadSurfaces'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@JGFJELJB@?$FO1Error?3?$FO7?5bad?5surface?5?$CFi?5from?5@ ; `string'
PUBLIC	??_C@_05ELAABIKM@water@				; `string'
PUBLIC	??_C@_05LPMGNCEN@laser@				; `string'
PUBLIC	??_C@_06FJKBNFNG@scroll@			; `string'
PUBLIC	??_C@_07FANFFIAH@?$HLscroll@			; `string'
PUBLIC	??_C@_08CFBMHPMN@reflect1@			; `string'
PUBLIC	??_C@_08DENCDAKP@?$CBreflect@			; `string'
PUBLIC	??_C@_0O@GMFBACMP@lighting?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0EB@PLJOECOM@?$FO3Warning?3?$FO7?5lighting?5invalid?5s@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadNodes@@9@9		; `Mod_LoadNodes'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadLeafs@@9@9		; `Mod_LoadLeafs'::`1'::__LINE__Var
PUBLIC	??_C@_0DJ@JDIEEHLB@?$FO3Warning?3?$FO7?5Mod_LoadLeafs?3?5inv@ ; `string'
PUBLIC	??_C@_0DI@KNHJIOGB@Mod_LoadLeafs?3?5Map?5?$CFs?5has?5leaf?5@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadClipnodes@@9@9		; `Mod_LoadClipnodes'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadVisibility@@9@9	; `Mod_LoadVisibility'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadLightVecs@@9@9		; `Mod_LoadLightVecs'::`1'::__LINE__Var
PUBLIC	??_C@_0EF@GIOPOPOK@?$FO1Error?3?$FO7?5Mod_LoadLightVecs?3?5h@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadShadowmap@@9@9		; `Mod_LoadShadowmap'::`1'::__LINE__Var
PUBLIC	??_C@_0EF@KCNBOONH@?$FO1Error?3?$FO7?5Mod_LoadShadowmap?3?5h@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadLighting@@9@9		; `Mod_LoadLighting'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@HKHAIKBM@Mod_LoadLighting?3?5bad?5lightmap?5@ ; `string'
PUBLIC	??_C@_0GF@GACEDHNO@?$FO1Error?3?$FO7?5?$CFs?5can?8t?5be?5loaded?5i@ ; `string'
PUBLIC	??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ ; `string'
PUBLIC	??_C@_05MFLOHCHP@World@				; `string'
PUBLIC	??_C@_05CIMNCBJM@Brush@				; `string'
PUBLIC	??_C@_0CI@GFCOHHNP@Mod_Load?$CFs?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5war@ ; `string'
PUBLIC	??_C@_0BL@OOFJPHFE@Mod_Load?$CFs?3?5?$CFi?5warning?$CIs?$CJ?6@ ; `string'
PUBLIC	??_C@_08NHEGNFAM@?$CFs?4wad?$DL?5@		; `string'
PUBLIC	??_C@_0CJ@JHDBDKDF@Wad?5files?5required?5to?5run?5the?5m@ ; `string'
PUBLIC	??_C@_0CL@KNKHLIAE@Mod_LoadWorld?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5@ ; `string'
PUBLIC	??_C@_0BO@MNJBEEAD@Mod_LoadWorld?3?5?$CFi?5warning?$CIs?$CJ?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadBrushModel@@9@9	; `Mod_LoadBrushModel'::`1'::__LINE__Var
PUBLIC	??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@		; `string'
PUBLIC	?__LINE__Var@?0??Mod_UnloadBrushModel@@9@9	; `Mod_UnloadBrushModel'::`1'::__LINE__Var
PUBLIC	??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_03LBJAIHPG@e?$CLb@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fefff2e40000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42a00000
PUBLIC	__real@42be0000
PUBLIC	__real@42c7fae1
PUBLIC	__real@42c80000
PUBLIC	__real@497423f0
PUBLIC	__real@c97423f0
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strtok:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strnlwr:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_toupper:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atov:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Mod_FindName:PROC
EXTRN	_Mod_InitDebugHulls:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_BoxOnPlaneSide:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_GL_SubdivideSurface:PROC
EXTRN	_R_InitSkyClouds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_r_wadtextures:DWORD
EXTRN	_tr:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_loadstat DB	048H DUP (?)
_worldmodel DD	01H DUP (?)
_g_visdata DB	01000H DUP (?)
_worldstats DB	01b0H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c97423f0
CONST	SEGMENT
__real@c97423f0 DD 0c97423f0r			; -999999
CONST	ENDS
;	COMDAT __real@497423f0
CONST	SEGMENT
__real@497423f0 DD 0497423f0r			; 999999
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42c7fae1
CONST	SEGMENT
__real@42c7fae1 DD 042c7fae1r			; 99.99
CONST	ENDS
;	COMDAT __real@42be0000
CONST	SEGMENT
__real@42be0000 DD 042be0000r			; 95
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fefff2e40000000
CONST	SEGMENT
__real@3fefff2e40000000 DQ 03fefff2e40000000r	; 0.9999
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_03LBJAIHPG@e?$CLb@
CONST	SEGMENT
??_C@_03LBJAIHPG@e?$CLb@ DB 'e+b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@ DB 'mod != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_UnloadBrushModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_UnloadBrushModel@@9@9 DD 0afcH	; `Mod_UnloadBrushModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
CONST	SEGMENT
??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@ DB '^2%s^7', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadBrushModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadBrushModel@@9@9 DD 0ae5H	; `Mod_LoadBrushModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@MNJBEEAD@Mod_LoadWorld?3?5?$CFi?5warning?$CIs?$CJ?6@
CONST	SEGMENT
??_C@_0BO@MNJBEEAD@Mod_LoadWorld?3?5?$CFi?5warning?$CIs?$CJ?6@ DB 'Mod_Lo'
	DB	'adWorld: %i warning(s)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KNKHLIAE@Mod_LoadWorld?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5@
CONST	SEGMENT
??_C@_0CL@KNKHLIAE@Mod_LoadWorld?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5@ DB 'M'
	DB	'od_LoadWorld: %i error(s), %i warning(s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JHDBDKDF@Wad?5files?5required?5to?5run?5the?5m@
CONST	SEGMENT
??_C@_0CJ@JHDBDKDF@Wad?5files?5required?5to?5run?5the?5m@ DB 'Wad files r'
	DB	'equired to run the map: "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NHEGNFAM@?$CFs?4wad?$DL?5@
CONST	SEGMENT
??_C@_08NHEGNFAM@?$CFs?4wad?$DL?5@ DB '%s.wad; ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OOFJPHFE@Mod_Load?$CFs?3?5?$CFi?5warning?$CIs?$CJ?6@
CONST	SEGMENT
??_C@_0BL@OOFJPHFE@Mod_Load?$CFs?3?5?$CFi?5warning?$CIs?$CJ?6@ DB 'Mod_Lo'
	DB	'ad%s: %i warning(s)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GFCOHHNP@Mod_Load?$CFs?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5war@
CONST	SEGMENT
??_C@_0CI@GFCOHHNP@Mod_Load?$CFs?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5war@ DB 'M'
	DB	'od_Load%s: %i error(s), %i warning(s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CIMNCBJM@Brush@
CONST	SEGMENT
??_C@_05CIMNCBJM@Brush@ DB 'Brush', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFLOHCHP@World@
CONST	SEGMENT
??_C@_05MFLOHCHP@World@ DB 'World', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
CONST	SEGMENT
??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ DB '^1E'
	DB	'rror:^7 %s has wrong version number (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@GACEDHNO@?$FO1Error?3?$FO7?5?$CFs?5can?8t?5be?5loaded?5i@
CONST	SEGMENT
??_C@_0GF@GACEDHNO@?$FO1Error?3?$FO7?5?$CFs?5can?8t?5be?5loaded?5i@ DB '^'
	DB	'1Error:^7 %s can''t be loaded in this build. Please rebuild e'
	DB	'ngine with enabled SUPPORT_BSP2_FORMAT', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HKHAIKBM@Mod_LoadLighting?3?5bad?5lightmap?5@
CONST	SEGMENT
??_C@_0DA@HKHAIKBM@Mod_LoadLighting?3?5bad?5lightmap?5@ DB 'Mod_LoadLight'
	DB	'ing: bad lightmap sample count %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadLighting@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadLighting@@9@9 DD 09f0H		; `Mod_LoadLighting'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EF@KCNBOONH@?$FO1Error?3?$FO7?5Mod_LoadShadowmap?3?5h@
CONST	SEGMENT
??_C@_0EF@KCNBOONH@?$FO1Error?3?$FO7?5Mod_LoadShadowmap?3?5h@ DB '^1Error'
	DB	':^7 Mod_LoadShadowmap: has mismatched size (%i should be %i)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadShadowmap@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadShadowmap@@9@9 DD 09deH	; `Mod_LoadShadowmap'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EF@GIOPOPOK@?$FO1Error?3?$FO7?5Mod_LoadLightVecs?3?5h@
CONST	SEGMENT
??_C@_0EF@GIOPOPOK@?$FO1Error?3?$FO7?5Mod_LoadLightVecs?3?5h@ DB '^1Error'
	DB	':^7 Mod_LoadLightVecs: has mismatched size (%i should be %i)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadLightVecs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadLightVecs@@9@9 DD 09cbH	; `Mod_LoadLightVecs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadVisibility@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadVisibility@@9@9 DD 09c0H	; `Mod_LoadVisibility'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadClipnodes@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadClipnodes@@9@9 DD 0992H	; `Mod_LoadClipnodes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@KNHJIOGB@Mod_LoadLeafs?3?5Map?5?$CFs?5has?5leaf?5@
CONST	SEGMENT
??_C@_0DI@KNHJIOGB@Mod_LoadLeafs?3?5Map?5?$CFs?5has?5leaf?5@ DB 'Mod_Load'
	DB	'Leafs: Map %s has leaf 0 is not CONTENTS_SOLID', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@JDIEEHLB@?$FO3Warning?3?$FO7?5Mod_LoadLeafs?3?5inv@
CONST	SEGMENT
??_C@_0DJ@JDIEEHLB@?$FO3Warning?3?$FO7?5Mod_LoadLeafs?3?5inv@ DB '^3Warni'
	DB	'ng:^7 Mod_LoadLeafs: invalid visofs for leaf #%i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadLeafs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadLeafs@@9@9 DD 092dH		; `Mod_LoadLeafs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadNodes@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadNodes@@9@9 DD 08ecH		; `Mod_LoadNodes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EB@PLJOECOM@?$FO3Warning?3?$FO7?5lighting?5invalid?5s@
CONST	SEGMENT
??_C@_0EB@PLJOECOM@?$FO3Warning?3?$FO7?5lighting?5invalid?5s@ DB '^3Warni'
	DB	'ng:^7 lighting invalid samplecount: %g, defaulting to %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GMFBACMP@lighting?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0O@GMFBACMP@lighting?3?5?$CFs?6@ DB 'lighting: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DENCDAKP@?$CBreflect@
CONST	SEGMENT
??_C@_08DENCDAKP@?$CBreflect@ DB '!reflect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CFBMHPMN@reflect1@
CONST	SEGMENT
??_C@_08CFBMHPMN@reflect1@ DB 'reflect1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FANFFIAH@?$HLscroll@
CONST	SEGMENT
??_C@_07FANFFIAH@?$HLscroll@ DB '{scroll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJKBNFNG@scroll@
CONST	SEGMENT
??_C@_06FJKBNFNG@scroll@ DB 'scroll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LPMGNCEN@laser@
CONST	SEGMENT
??_C@_05LPMGNCEN@laser@ DB 'laser', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELAABIKM@water@
CONST	SEGMENT
??_C@_05ELAABIKM@water@ DB 'water', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGFJELJB@?$FO1Error?3?$FO7?5bad?5surface?5?$CFi?5from?5@
CONST	SEGMENT
??_C@_0CD@JGFJELJB@?$FO1Error?3?$FO7?5bad?5surface?5?$CFi?5from?5@ DB '^1'
	DB	'Error:^7 bad surface %i from %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadSurfaces@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadSurfaces@@9@9 DD 084dH		; `Mod_LoadSurfaces'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadTexInfo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadTexInfo@@9@9 DD 081fH		; `Mod_LoadTexInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@BJKAAKLM@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5mi@
CONST	SEGMENT
??_C@_0DF@BJKAAKLM@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5mi@ DB '^1Error'
	DB	':^7 Mod_LoadTextures: missing frame %i of %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GBOGMJNF@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5ba@
CONST	SEGMENT
??_C@_0DH@GBOGMJNF@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5ba@ DB '^1Error'
	DB	':^7 Mod_LoadTextures: bad animating texture %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JGOPFOPL@?$CFs?4wad?1?$CFs?4mip@
CONST	SEGMENT
??_C@_0O@JGOPFOPL@?$CFs?4wad?1?$CFs?4mip@ DB '%s.wad/%s.mip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKDOIIAE@?$CD?$CFs?3?$CFs_luma?4mip@
CONST	SEGMENT
??_C@_0BA@DKDOIIAE@?$CD?$CFs?3?$CFs_luma?4mip@ DB '#%s:%s_luma.mip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CPEGMNDG@?$FO1Error?3?$FO7?5unable?5to?5find?5?$CFs?4mi@
CONST	SEGMENT
??_C@_0CC@CPEGMNDG@?$FO1Error?3?$FO7?5unable?5to?5find?5?$CFs?4mi@ DB '^1'
	DB	'Error:^7 unable to find %s.mip', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAOGIBEC@?$CD?$CFs?3?$CFs?4mip@
CONST	SEGMENT
??_C@_0L@DAOGIBEC@?$CD?$CFs?3?$CFs?4mip@ DB '#%s:%s.mip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NEMDCCOI@?$CFs?4wad?1?$CFs@
CONST	SEGMENT
??_C@_09NEMDCCOI@?$CFs?4wad?1?$CFs@ DB '%s.wad/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNCEHODH@?$CFs?4mip@
CONST	SEGMENT
??_C@_06KNCEHODH@?$CFs?4mip@ DB '%s.mip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BNEOMJOP@sky@
CONST	SEGMENT
??_C@_03BNEOMJOP@sky@ DB 'sky', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PEJHDEOI@miptex_?$CFi@
CONST	SEGMENT
??_C@_09PEJHDEOI@miptex_?$CFi@ DB 'miptex_%i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPIGECMN@?$CKdefault@
CONST	SEGMENT
??_C@_08KPIGECMN@?$CKdefault@ DB '*default', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadTextures@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadTextures@@9@9 DD 06fcH		; `Mod_LoadTextures'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CP@FKACGMIN@Mod_LoadMarkFaces?3?5bad?5surface?5@
CONST	SEGMENT
??_C@_0CP@FKACGMIN@Mod_LoadMarkFaces?3?5bad?5surface?5@ DB 'Mod_LoadMarkF'
	DB	'aces: bad surface number in ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadMarkSurfaces@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadMarkSurfaces@@9@9 DD 06d7H	; `Mod_LoadMarkSurfaces'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadSurfEdges@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadSurfEdges@@9@9 DD 06cbH	; `Mod_LoadSurfEdges'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadEdges@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadEdges@@9@9 DD 06a8H		; `Mod_LoadEdges'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadVertexes@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadVertexes@@9@9 DD 0684H		; `Mod_LoadVertexes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CF@GAMEGDJP@?$FO1Error?3?$FO7?5bad?5normal?5for?5plane@
CONST	SEGMENT
??_C@_0CF@GAMEGDJP@?$FO1Error?3?$FO7?5bad?5normal?5for?5plane@ DB '^1Erro'
	DB	'r:^7 bad normal for plane #%i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadPlanes@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadPlanes@@9@9 DD 0662H		; `Mod_LoadPlanes'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@BOHJDPEN@_generator@
CONST	SEGMENT
??_C@_0L@BOHJDPEN@_generator@ DB '_generator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HNDCMPDF@generator@
CONST	SEGMENT
??_C@_09HNDCMPDF@generator@ DB 'generator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPMLCKOG@_compiler@
CONST	SEGMENT
??_C@_09GPMLCKOG@_compiler@ DB '_compiler', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCFHILPL@compiler@
CONST	SEGMENT
??_C@_08CCFHILPL@compiler@ DB 'compiler', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONPBMBOP@message@
CONST	SEGMENT
??_C@_07ONPBMBOP@message@ DB 'message', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCDNEPCB@?$CFs?4wad@
CONST	SEGMENT
??_C@_06LCDNEPCB@?$CFs?4wad@ DB '%s.wad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GANHLHHC@wad@
CONST	SEGMENT
??_C@_03GANHLHHC@wad@ DB 'wad', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODLIHCCC@Mod_LoadEntities?3?5closing?5brace@
CONST	SEGMENT
??_C@_0CO@ODLIHCCC@Mod_LoadEntities?3?5closing?5brace@ DB 'Mod_LoadEntiti'
	DB	'es: closing brace without data', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GOGHHEMD@Mod_LoadEntities?3?5EOF?5without?5c@
CONST	SEGMENT
??_C@_0CN@GOGHHEMD@Mod_LoadEntities?3?5EOF?5without?5c@ DB 'Mod_LoadEntit'
	DB	'ies: EOF without closing brace', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FABNGMMO@Mod_LoadEntities?3?5found?5?$CFs?5when@
CONST	SEGMENT
??_C@_0CN@FABNGMMO@Mod_LoadEntities?3?5found?5?$CFs?5when@ DB 'Mod_LoadEn'
	DB	'tities: found %s when expecting {', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ICFKCIBG@?$FO2Read?5entity?5patch?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@ICFKCIBG@?$FO2Read?5entity?5patch?3?$FO7?5?$CFs?6@ DB '^2Read e'
	DB	'ntity patch:^7 %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NKJPPPMJ@?$FO3Warning?3?$FO7?5Entity?5patch?5is?5ol@
CONST	SEGMENT
??_C@_0DH@NKJPPPMJ@?$FO3Warning?3?$FO7?5Entity?5patch?5is?5ol@ DB '^3Warn'
	DB	'ing:^7 Entity patch is older than bsp. Ignored.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECMOMEGO@?4ent@
CONST	SEGMENT
??_C@_04ECMOMEGO@?4ent@ DB '.ent', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadEntities@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadEntities@@9@9 DD 05efH		; `Mod_LoadEntities'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadSubmodels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadSubmodels@@9@9 DD 05b5H	; `Mod_LoadSubmodels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@ONGNOMOA@maps?1c2a1?4bsp@
CONST	SEGMENT
??_C@_0O@ONGNOMOA@maps?1c2a1?4bsp@ DB 'maps/c2a1.bsp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JLINDLFM@?$CK?$CFi@
CONST	SEGMENT
??_C@_03JLINDLFM@?$CK?$CFi@ DB '*%i', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_SetupSubmodels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_SetupSubmodels@@9@9 DD 054cH	; `Mod_SetupSubmodels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@PEBABFIJ@maps?1?$CFs?4dlit@
CONST	SEGMENT
??_C@_0N@PEBABFIJ@maps?1?$CFs?4dlit@ DB 'maps/%s.dlit', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9 DD 0515H	; `Mod_LoadDeluxemap'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@HGHNGDJB@?$FO1Error?3?$FO7?5?$CFs?5has?5mismatched?5si@
CONST	SEGMENT
??_C@_0DF@HGHNGDJB@?$FO1Error?3?$FO7?5?$CFs?5has?5mismatched?5si@ DB '^1E'
	DB	'rror:^7 %s has mismatched size (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHKGJOLH@in?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@DHKGJOLH@in?5?$CB?$DN?5NULL@ DB 'in != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DFGMPNGN@?$FO3Warning?3?$FO7?5?$CFs?5probably?5is?5out@
CONST	SEGMENT
??_C@_0CJ@DFGMPNGN@?$FO3Warning?3?$FO7?5?$CFs?5probably?5is?5out@ DB '^3W'
	DB	'arning:^7 %s probably is out of date', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KPNLOLCL@maps?1?$CFs?4lit@
CONST	SEGMENT
??_C@_0M@KPNLOLCL@maps?1?$CFs?4lit@ DB 'maps/%s.lit', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9 DD 04e1H	; `Mod_LoadColoredLighting'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CD@ONMMJLDG@Mod_SetupHull?3?5bad?5hull?5number?5@
CONST	SEGMENT
??_C@_0CD@ONMMJLDG@Mod_SetupHull?3?5bad?5hull?5number?5@ DB 'Mod_SetupHul'
	DB	'l: bad hull number %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_SetupHull@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_SetupHull@@9@9 DD 04abH		; `Mod_SetupHull'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_MakeHull0@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_MakeHull0@@9@9 DD 0488H		; `Mod_MakeHull0'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@
CONST	SEGMENT
??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@ DB 'MAX_MAP_CLIPNOD'
	DB	'ES limit exceeded', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DIJBMDAC@Mod_CalcSurfaceBounds?3?5bad?5edge@
CONST	SEGMENT
??_C@_0CB@DIJBMDAC@Mod_CalcSurfaceBounds?3?5bad?5edge@ DB 'Mod_CalcSurfac'
	DB	'eBounds: bad edge', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MJPHIMFM@?$FO1Error?3?$FO7?5Bad?5surface?5extents?5@
CONST	SEGMENT
??_C@_0CD@MJPHIMFM@?$FO1Error?3?$FO7?5Bad?5surface?5extents?5@ DB '^1Erro'
	DB	'r:^7 Bad surface extents %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GDPMEJOM@Mod_CalcSurfaceExtents?3?5bad?5edg@
CONST	SEGMENT
??_C@_0CC@GDPMEJOM@Mod_CalcSurfaceExtents?3?5bad?5edg@ DB 'Mod_CalcSurfac'
	DB	'eExtents: bad edge', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHCMNMEH@origin@
CONST	SEGMENT
??_C@_06NHCMNMEH@origin@ DB 'origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DMBFGDCJ@Mod_FindModelOrigin?3?5closing?5br@
CONST	SEGMENT
??_C@_0DB@DMBFGDCJ@Mod_FindModelOrigin?3?5closing?5br@ DB 'Mod_FindModelO'
	DB	'rigin: closing brace without data', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDJJLMGP@Mod_FindModelOrigin?3?5EOF?5withou@
CONST	SEGMENT
??_C@_0DA@KDJJLMGP@Mod_FindModelOrigin?3?5EOF?5withou@ DB 'Mod_FindModelO'
	DB	'rigin: EOF without closing brace', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JNODKEGC@Mod_FindModelOrigin?3?5found?5?$CFs?5w@
CONST	SEGMENT
??_C@_0DA@JNODKEGC@Mod_FindModelOrigin?3?5found?5?$CFs?5w@ DB 'Mod_FindMo'
	DB	'delOrigin: found %s when expecting {', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_FatPVS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_FatPVS@@9@9 DD 0250H		; `Mod_FatPVS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_GetPVSForPoint@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_GetPVSForPoint@@9@9 DD 020cH	; `Mod_GetPVSForPoint'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@ DB 'node != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\mod_bmodel.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_PointInLeaf@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_PointInLeaf@@9@9 DD 01f5H		; `Mod_PointInLeaf'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@HMHCEHFL@map?5editor?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@HMHCEHFL@map?5editor?3?5?$CFs?6@ DB 'map editor: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFEJOENI@map?5compiler?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@JFEJOENI@map?5compiler?3?5?$CFs?6@ DB 'map compiler: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGPEIADJ@?$FO3?$CFs@
CONST	SEGMENT
??_C@_04GGPEIADJ@?$FO3?$CFs@ DB '^3%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCIFFDNI@internal?5name?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@OCIFFDNI@internal?5name?3?5?$CFs?6@ DB 'internal name: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOEIOHFM@?$FO2?$CFs@
CONST	SEGMENT
??_C@_04NOEIOHFM@?$FO2?$CFs@ DB '^2%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OKPHAEMF@original?5name?3?5?$FO1?$CFs?6@
CONST	SEGMENT
??_C@_0BF@OKPHAEMF@original?5name?3?5?$FO1?$CFs?6@ DB 'original name: ^1%'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JEPAGEFC@World?5total?5leafs?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@JEPAGEFC@World?5total?5leafs?3?5?$CFd?6@ DB 'World total leafs:'
	DB	' %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBDFHKBH@Lighting?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0O@KBDFHKBH@Lighting?3?5?$CFs?6@ DB 'Lighting: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FEJFGKNE@monochrome@
CONST	SEGMENT
??_C@_0L@FEJFGKNE@monochrome@ DB 'monochrome', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDKIFLAA@colored@
CONST	SEGMENT
??_C@_07FDKIFLAA@colored@ DB 'colored', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GEMHJKNN@Supports?5transparency?5world?5wat@
CONST	SEGMENT
??_C@_0CH@GEMHJKNN@Supports?5transparency?5world?5wat@ DB 'Supports trans'
	DB	'parency world water: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No@
CONST	SEGMENT
??_C@_02JINPPBEP@No@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HPFFJPPF@World?5size?5?$CI?5?$CFg?5?$CFg?5?$CFg?5?$CJ?5units?6@
CONST	SEGMENT
??_C@_0BP@HPFFJPPF@World?5size?5?$CI?5?$CFg?5?$CFg?5?$CFg?5?$CJ?5units?6@ DB 'W'
	DB	'orld size ( %g %g %g ) units', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IHJJKKPB@?$DN?$DN?$DN?5Total?5BSP?5file?5data?5space?5u@
CONST	SEGMENT
??_C@_0CM@IHJJKKPB@?$DN?$DN?$DN?5Total?5BSP?5file?5data?5space?5u@ DB '=='
	DB	'= Total BSP file data space used: %s ===', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NCLGKDEM@?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5@
CONST	SEGMENT
??_C@_0DK@NCLGKDEM@?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5@ DB '-'
	DB	'-----------  ---------------  ---------------  --------', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CJHLEKBM@Object?5names?5?5Objects?1Maxobjs?5?5@
CONST	SEGMENT
??_C@_0DK@CJHLEKBM@Object?5names?5?5Objects?1Maxobjs?5?5@ DB 'Object name'
	DB	's  Objects/Maxobjs  Memory / Maxmem  Fullness', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJOFMENC@No?5map?5loaded?6@
CONST	SEGMENT
??_C@_0P@NJOFMENC@No?5map?5loaded?6@ DB 'No map loaded', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IKFPEOPA@?$CF?915s?5?5?$CF?912s?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?41f?$CF@
CONST	SEGMENT
??_C@_0CD@IKFPEOPA@?$CF?915s?5?5?$CF?912s?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?41f?$CF@ DB '%'
	DB	'-15s  %-12s  %8i/%-8i  (%4.1f%%) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JPFAHBCL@?$FLvariable?$FN@
CONST	SEGMENT
??_C@_0L@JPFAHBCL@?$FLvariable?$FN@ DB '[variable]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DLPMCLNL@?$FO2VERY?5FULL?$CB?$FO7?6@
CONST	SEGMENT
??_C@_0BA@DLPMCLNL@?$FO2VERY?5FULL?$CB?$FO7?6@ DB '^2VERY FULL!^7', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BGBEIFII@?$FO3SIZE?5DANGER?$CB?$FO7?6@
CONST	SEGMENT
??_C@_0BC@BGBEIFII@?$FO3SIZE?5DANGER?$CB?$FO7?6@ DB '^3SIZE DANGER!^7', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BBOCJOCH@?$FO1SIZE?5OVERFLOW?$CB?$CB?$CB?$FO7?6@
CONST	SEGMENT
??_C@_0BG@BBOCJOCH@?$FO1SIZE?5OVERFLOW?$CB?$CB?$CB?$FO7?6@ DB '^1SIZE OVE'
	DB	'RFLOW!!!^7', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MFBOJPAE@?$CF?912s?5?5?$CF7i?1?$CF?97i?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?4@
CONST	SEGMENT
??_C@_0CG@MFBOJPAE@?$CF?912s?5?5?$CF7i?1?$CF?97i?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?4@ DB '%'
	DB	'-12s  %7i/%-7i  %8i/%-8i  (%4.1f%%) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EBAPCGFM@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too@
CONST	SEGMENT
??_C@_0CJ@EBAPCGFM@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too@ DB '^'
	DB	'3Warning:^7 map ^2%s^7 has too many %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OFCIPOAE@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too?5m@
CONST	SEGMENT
??_C@_0CH@OFCIPOAE@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too?5m@ DB '^'
	DB	'1Error:^7 map ^2%s^7 has too many %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JCBLNEDP@?$FO1Error?3?$FO7?5Mod_Load?$CFs?3?5funny?5lu@
CONST	SEGMENT
??_C@_0CI@JCBLNEDP@?$FO1Error?3?$FO7?5Mod_Load?$CFs?3?5funny?5lu@ DB '^1E'
	DB	'rror:^7 Mod_Load%s: funny lump size', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BLAKDKDN@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5?$CFs@
CONST	SEGMENT
??_C@_0CB@BLAKDKDN@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5?$CFs@ DB '^'
	DB	'1Error:^7 map ^2%s^7 has no %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBEFGCON@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5@
CONST	SEGMENT
??_C@_0CD@FBEFGCON@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5@ DB '^'
	DB	'3Warning:^7 map ^2%s^7 has no %s', 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_srclumps DD	00H
	DD	020H
	DD	0100000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_08PNMNOKOB@entities@
	DD	00H
	DD	FLAT:_srcmodel+128
	DD	FLAT:_srcmodel+132
	DD	01H
	DD	01H
	DD	010000H
	DD	014H
	DD	0ffffffffH
	DD	FLAT:??_C@_06MEGIMCLI@planes@
	DD	00H
	DD	FLAT:_srcmodel+16
	DD	FLAT:_srcmodel+20
	DD	02H
	DD	01H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_08NJIMCCJK@textures@
	DD	00H
	DD	FLAT:_srcmodel+136
	DD	FLAT:_srcmodel+140
	DD	03H
	DD	00H
	DD	0ffffH
	DD	0cH
	DD	0ffffffffH
	DD	FLAT:??_C@_08FMFHCCLE@vertexes@
	DD	00H
	DD	FLAT:_srcmodel+8
	DD	FLAT:_srcmodel+12
	DD	04H
	DD	00H
	DD	01000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_0L@CNKMJODB@visibility@
	DD	00H
	DD	FLAT:_srcmodel+96
	DD	FLAT:_srcmodel+100
	DD	05H
	DD	01H
	DD	07fffH
	DD	018H
	DD	02cH
	DD	FLAT:??_C@_05JJOLJDEA@nodes@
	DD	01H
	DD	FLAT:_srcmodel+24
	DD	FLAT:_srcmodel+28
	DD	06H
	DD	00H
	DD	0ffffH
	DD	028H
	DD	0ffffffffH
	DD	FLAT:??_C@_07GNNMAGOE@texinfo@
	DD	01H
	DD	FLAT:_srcmodel+48
	DD	FLAT:_srcmodel+52
	DD	07H
	DD	00H
	DD	0ffffH
	DD	014H
	DD	01cH
	DD	FLAT:??_C@_05FHFPJHPF@faces@
	DD	01H
	DD	FLAT:_srcmodel+80
	DD	FLAT:_srcmodel+84
	DD	08H
	DD	00H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_09GHHBMBIA@lightmaps@
	DD	00H
	DD	FLAT:_srcmodel+104
	DD	FLAT:_srcmodel+108
	DD	09H
	DD	00H
	DD	07fffH
	DD	08H
	DD	0cH
	DD	FLAT:??_C@_09GIOIPMON@clipnodes@
	DD	00H
	DD	FLAT:_srcmodel+40
	DD	FLAT:_srcmodel+44
	DD	0aH
	DD	01H
	DD	07fffH
	DD	01cH
	DD	02cH
	DD	FLAT:??_C@_05KLALGEIB@leafs@
	DD	01H
	DD	FLAT:_srcmodel+32
	DD	FLAT:_srcmodel+36
	DD	0bH
	DD	00H
	DD	0ffffH
	DD	02H
	DD	04H
	DD	FLAT:??_C@_09NNCMKPF@markfaces@
	DD	00H
	DD	FLAT:_srcmodel+56
	DD	FLAT:_srcmodel+60
	DD	0cH
	DD	00H
	DD	0100000H
	DD	04H
	DD	08H
	DD	FLAT:??_C@_05JGEJPNHM@edges@
	DD	00H
	DD	FLAT:_srcmodel+72
	DD	FLAT:_srcmodel+76
	DD	0dH
	DD	00H
	DD	0200000H
	DD	04H
	DD	0ffffffffH
	DD	FLAT:??_C@_09GFFIGDJK@surfedges@
	DD	00H
	DD	FLAT:_srcmodel+64
	DD	FLAT:_srcmodel+68
	DD	0eH
	DD	01H
	DD	0300H
	DD	040H
	DD	0ffffffffH
	DD	FLAT:??_C@_06FEMFHOOG@models@
	DD	01H
	DD	FLAT:_srcmodel
	DD	FLAT:_srcmodel+4
	ORG $+4
_extlumps DD	00H
	DD	00H
	DD	02000000H
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_09LODDFDED@deluxmaps@
	DD	02H
	DD	FLAT:_srcmodel+112
	DD	FLAT:_srcmodel+116
	DD	01H
	DD	00H
	DD	02000H
	DD	016H
	DD	0ffffffffH
	DD	FLAT:??_C@_09FMFDCLAK@faceinfos@
	DD	03H
	DD	FLAT:_srcmodel+88
	DD	FLAT:_srcmodel+92
	DD	08H
	DD	00H
	DD	0aaaaaaH
	DD	01H
	DD	0ffffffffH
	DD	FLAT:??_C@_09JIDODEBC@shadowmap@
	DD	02H
	DD	FLAT:_srcmodel+120
	DD	FLAT:_srcmodel+124
	ORG $+324
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0490H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0b72H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0586H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	045bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	022cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	027cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0108H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	035aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	027bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	021bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	014cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f2H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadBmodelLumps
_TEXT	SEGMENT
tv170 = -2404						; size = 4
tv162 = -2404						; size = 4
tv146 = -2404						; size = 4
tv134 = -2404						; size = 4
tv84 = -2404						; size = 4
$T1 = -2400						; size = 4
$T2 = -2396						; size = 4
_i$ = -2072						; size = 4
_wadvalue$ = -2068					; size = 2048
_mod$ = -20						; size = 4
_bmod$ = -16						; size = 4
_extrahdr$ = -12					; size = 4
_header$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod_base$ = 8						; size = 4
_isworld$ = 12						; size = 4
_Mod_LoadBmodelLumps PROC				; COMDAT

; 2622 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2404				; 00000964H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2623 : 	dheader_t		*header = (dheader_t *)mod_base;

	mov	eax, DWORD PTR _mod_base$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2624 : 	dextrahdr_t	*extrahdr = (dextrahdr_t *)((byte *)mod_base + sizeof( dheader_t ));

	mov	eax, DWORD PTR _mod_base$[ebp]
	add	eax, 124				; 0000007cH
	mov	DWORD PTR _extrahdr$[ebp], eax

; 2625 : 	dbspmodel_t	*bmod = &srcmodel;

	mov	DWORD PTR _bmod$[ebp], OFFSET _srcmodel

; 2626 : 	model_t		*mod = loadmodel;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], eax

; 2627 : 	char		wadvalue[2048];
; 2628 : 	int		i;
; 2629 : 
; 2630 : 	// always reset the intermediate struct
; 2631 : 	memset( bmod, 0, sizeof( dbspmodel_t ));

	push	9388					; 000024acH
	push	0
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2632 : 	memset( &loadstat, 0, sizeof( loadstat_t ));

	push	72					; 00000048H
	push	0
	push	OFFSET _loadstat
	call	_memset
	add	esp, 12					; 0000000cH

; 2633 : 
; 2634 : 	Q_strncpy( loadstat.name, loadmodel->name, sizeof( loadstat.name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET _loadstat
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2635 : 	wadvalue[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN26@Mod_LoadBm
	jmp	SHORT $LN27@Mod_LoadBm
$LN26@Mod_LoadBm:
	call	___report_rangecheckfailure
$LN27@Mod_LoadBm:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _wadvalue$[ebp+edx], 0

; 2636 : 
; 2637 : #ifndef SUPPORT_BSP2_FORMAT
; 2638 : 	if( header->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 844124994		; 32505342H
	jne	SHORT $LN13@Mod_LoadBm

; 2639 : 	{
; 2640 : 		Con_Printf( S_ERROR DEFAULT_BSP_BUILD_ERROR, loadmodel->name );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET ??_C@_0GF@GACEDHNO@?$FO1Error?3?$FO7?5?$CFs?5can?8t?5be?5loaded?5i@
	call	_Con_Printf
	add	esp, 8

; 2641 : 		return false;

	xor	eax, eax
	jmp	$LN25@Mod_LoadBm
$LN13@Mod_LoadBm:

; 2642 : 	}
; 2643 : #endif
; 2644 : 	switch( header->version )

	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 29			; 0000001dH
	je	SHORT $LN16@Mod_LoadBm
	cmp	DWORD PTR tv84[ebp], 30			; 0000001eH
	je	SHORT $LN16@Mod_LoadBm
	cmp	DWORD PTR tv84[ebp], 844124994		; 32505342H
	je	SHORT $LN16@Mod_LoadBm
	jmp	SHORT $LN17@Mod_LoadBm
$LN16@Mod_LoadBm:

; 2645 : 	{
; 2646 : 	case Q1BSP_VERSION:
; 2647 : 	case HLBSP_VERSION:
; 2648 : 	case QBSP2_VERSION:
; 2649 : 		break;

	jmp	SHORT $LN2@Mod_LoadBm
$LN17@Mod_LoadBm:

; 2650 : 	default:
; 2651 : 		Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", loadmodel->name, header->version, HLBSP_VERSION );

	push	30					; 0000001eH
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 2652 : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 2653 : 		return false;

	xor	eax, eax
	jmp	$LN25@Mod_LoadBm
$LN2@Mod_LoadBm:

; 2654 : 	}
; 2655 : 
; 2656 : 	bmod->version = header->version;	// share up global

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+9380], edx

; 2657 : 	if( isworld ) world.flags = 0;	// clear world settings

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN18@Mod_LoadBm
	mov	DWORD PTR _world+8, 0
$LN18@Mod_LoadBm:

; 2658 : 	bmod->isworld = isworld;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _isworld$[ebp]
	mov	DWORD PTR [eax+9384], ecx

; 2659 : 
; 2660 : 	// loading base lumps
; 2661 : 	for( i = 0; i < ARRAYSIZE( srclumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_LoadBm
$LN4@Mod_LoadBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Mod_LoadBm:
	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	jae	SHORT $LN5@Mod_LoadBm

; 2662 : 		Mod_LoadLump( mod_base, &srclumps[i], &worldstats[i], isworld ? (LUMP_SAVESTATS|LUMP_SILENT) : 0 );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN28@Mod_LoadBm
	mov	DWORD PTR tv134[ebp], 5
	jmp	SHORT $LN29@Mod_LoadBm
$LN28@Mod_LoadBm:
	mov	DWORD PTR tv134[ebp], 0
$LN29@Mod_LoadBm:
	mov	eax, DWORD PTR tv134[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _worldstats
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 36
	add	edx, OFFSET _srclumps
	push	edx
	mov	eax, DWORD PTR _mod_base$[ebp]
	push	eax
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN4@Mod_LoadBm
$LN5@Mod_LoadBm:

; 2663 : 
; 2664 : 	// loading extralumps
; 2665 : 	for( i = 0; i < ARRAYSIZE( extlumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_LoadBm
$LN7@Mod_LoadBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Mod_LoadBm:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $LN8@Mod_LoadBm

; 2666 : 		Mod_LoadLump( mod_base, &extlumps[i], &worldstats[ARRAYSIZE( srclumps ) + i], isworld ? (LUMP_SAVESTATS|LUMP_SILENT) : 0 );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN30@Mod_LoadBm
	mov	DWORD PTR tv146[ebp], 5
	jmp	SHORT $LN31@Mod_LoadBm
$LN30@Mod_LoadBm:
	mov	DWORD PTR tv146[ebp], 0
$LN31@Mod_LoadBm:
	mov	eax, DWORD PTR tv146[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 15					; 0000000fH
	shl	ecx, 4
	add	ecx, OFFSET _worldstats
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 36
	add	edx, OFFSET _extlumps
	push	edx
	mov	eax, DWORD PTR _mod_base$[ebp]
	push	eax
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN7@Mod_LoadBm
$LN8@Mod_LoadBm:

; 2667 : 
; 2668 : 	if( !bmod->isworld && loadstat.numerrors )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN19@Mod_LoadBm
	cmp	DWORD PTR _loadstat+64, 0
	je	SHORT $LN19@Mod_LoadBm

; 2669 : 	{
; 2670 : 		Con_DPrintf( "Mod_Load%s: %i error(s), %i warning(s)\n", isworld ? "World" : "Brush", loadstat.numerrors, loadstat.numwarnings );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN32@Mod_LoadBm
	mov	DWORD PTR tv162[ebp], OFFSET ??_C@_05MFLOHCHP@World@
	jmp	SHORT $LN33@Mod_LoadBm
$LN32@Mod_LoadBm:
	mov	DWORD PTR tv162[ebp], OFFSET ??_C@_05CIMNCBJM@Brush@
$LN33@Mod_LoadBm:
	mov	eax, DWORD PTR _loadstat+68
	push	eax
	mov	ecx, DWORD PTR _loadstat+64
	push	ecx
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@GFCOHHNP@Mod_Load?$CFs?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5war@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 2671 : 		return false; // there were errors, we can't load this map

	xor	eax, eax
	jmp	$LN25@Mod_LoadBm

; 2672 : 	}	

	jmp	SHORT $LN20@Mod_LoadBm
$LN19@Mod_LoadBm:

; 2673 : 	else if( !bmod->isworld && loadstat.numwarnings )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN20@Mod_LoadBm
	cmp	DWORD PTR _loadstat+68, 0
	je	SHORT $LN20@Mod_LoadBm

; 2674 : 		Con_DPrintf( "Mod_Load%s: %i warning(s)\n", isworld ? "World" : "Brush", loadstat.numwarnings );

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN34@Mod_LoadBm
	mov	DWORD PTR tv170[ebp], OFFSET ??_C@_05MFLOHCHP@World@
	jmp	SHORT $LN35@Mod_LoadBm
$LN34@Mod_LoadBm:
	mov	DWORD PTR tv170[ebp], OFFSET ??_C@_05CIMNCBJM@Brush@
$LN35@Mod_LoadBm:
	mov	eax, DWORD PTR _loadstat+68
	push	eax
	mov	ecx, DWORD PTR tv170[ebp]
	push	ecx
	push	OFFSET ??_C@_0BL@OOFJPHFE@Mod_Load?$CFs?3?5?$CFi?5warning?$CIs?$CJ?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN20@Mod_LoadBm:

; 2675 : 
; 2676 : 	// load into heap
; 2677 : 	Mod_LoadEntities( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadEntities
	add	esp, 4

; 2678 : 	Mod_LoadPlanes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadPlanes
	add	esp, 4

; 2679 : 	Mod_LoadSubmodels( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadSubmodels
	add	esp, 4

; 2680 : 	Mod_LoadVertexes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadVertexes
	add	esp, 4

; 2681 : 	Mod_LoadEdges( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadEdges
	add	esp, 4

; 2682 : 	Mod_LoadSurfEdges( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadSurfEdges
	add	esp, 4

; 2683 : 	Mod_LoadTextures( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadTextures
	add	esp, 4

; 2684 : 	Mod_LoadVisibility( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadVisibility
	add	esp, 4

; 2685 : 	Mod_LoadTexInfo( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadTexInfo
	add	esp, 4

; 2686 : 	Mod_LoadSurfaces( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadSurfaces
	add	esp, 4

; 2687 : 	Mod_LoadLighting( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadLighting
	add	esp, 4

; 2688 : 	Mod_LoadMarkSurfaces( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadMarkSurfaces
	add	esp, 4

; 2689 : 	Mod_LoadLeafs( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadLeafs
	add	esp, 4

; 2690 : 	Mod_LoadNodes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadNodes
	add	esp, 4

; 2691 : 	Mod_LoadClipnodes( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadClipnodes
	add	esp, 4

; 2692 : 
; 2693 : 	// preform some post-initalization
; 2694 : 	Mod_MakeHull0 ();

	call	_Mod_MakeHull0

; 2695 : 	Mod_SetupSubmodels( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_SetupSubmodels
	add	esp, 4

; 2696 : 
; 2697 : 	if( isworld )

	cmp	DWORD PTR _isworld$[ebp], 0
	je	SHORT $LN22@Mod_LoadBm

; 2698 : 	{
; 2699 : 		loadmodel = mod;		// restore pointer to world

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _loadmodel, eax

; 2700 : 		Mod_InitDebugHulls();	// FIXME: build hulls for separate bmodels (shells, medkits etc)

	call	_Mod_InitDebugHulls
$LN22@Mod_LoadBm:

; 2701 : 	}
; 2702 : 
; 2703 : 	for( i = 0; i < bmod->wadlist.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Mod_LoadBm
$LN10@Mod_LoadBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Mod_LoadBm:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+9372]
	jge	SHORT $LN11@Mod_LoadBm

; 2704 : 	{
; 2705 : 		if( !bmod->wadlist.wadusage[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8348], 0
	jne	SHORT $LN23@Mod_LoadBm

; 2706 : 			continue;

	jmp	SHORT $LN10@Mod_LoadBm
$LN23@Mod_LoadBm:

; 2707 : 		Q_strncat( wadvalue, va( "%s.wad; ", bmod->wadlist.wadnames[i] ), sizeof( wadvalue ));

	push	2048					; 00000800H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _bmod$[ebp]
	lea	edx, DWORD PTR [ecx+eax+156]
	push	edx
	push	OFFSET ??_C@_08NHEGNFAM@?$CFs?4wad?$DL?5@
	call	_va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _wadvalue$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 2708 : 	}

	jmp	SHORT $LN10@Mod_LoadBm
$LN11@Mod_LoadBm:

; 2709 : 
; 2710 : 	if( COM_CheckString( wadvalue ))

	lea	eax, DWORD PTR _wadvalue$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@Mod_LoadBm

; 2711 : 	{
; 2712 : 		wadvalue[Q_strlen( wadvalue ) - 2] = '\0'; // kill the last semicolon

	lea	eax, DWORD PTR _wadvalue$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	sub	eax, 2
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN36@Mod_LoadBm
	jmp	SHORT $LN37@Mod_LoadBm
$LN36@Mod_LoadBm:
	call	___report_rangecheckfailure
$LN37@Mod_LoadBm:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _wadvalue$[ebp+ecx], 0

; 2713 : 		Con_Reportf( "Wad files required to run the map: \"%s\"\n", wadvalue );

	lea	eax, DWORD PTR _wadvalue$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@JHDBDKDF@Wad?5files?5required?5to?5run?5the?5m@
	call	_Con_Reportf
	add	esp, 8
$LN24@Mod_LoadBm:

; 2714 : 	}
; 2715 : 
; 2716 : 	return true;

	mov	eax, 1
$LN25@Mod_LoadBm:

; 2717 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadBmodelLumps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadLighting
_TEXT	SEGMENT
tv67 = -92						; size = 4
_offset$1 = -24						; size = 4
_in$ = -20						; size = 4
_out$ = -16						; size = 4
_surf$ = -12						; size = 4
_lightofs$ = -8						; size = 4
_i$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadLighting PROC					; COMDAT

; 2544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2545 : 	int		i, lightofs;
; 2546 : 	msurface_t	*surf;
; 2547 : 	color24		*out;
; 2548 : 	byte		*in;
; 2549 : 
; 2550 : 	if( !bmod->lightdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $LN10@Mod_LoadLi

; 2551 : 		return;

	jmp	$LN1@Mod_LoadLi
$LN10@Mod_LoadLi:

; 2552 : 
; 2553 : 	switch( bmod->lightmap_samples )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9376]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 1
	je	SHORT $LN11@Mod_LoadLi
	cmp	DWORD PTR tv67[ebp], 3
	je	$LN13@Mod_LoadLi
	jmp	$LN14@Mod_LoadLi
$LN11@Mod_LoadLi:

; 2554 : 	{
; 2555 : 	case 1:
; 2556 : 		if( !Mod_LoadColoredLighting( bmod ))

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadColoredLighting
	add	esp, 4
	test	eax, eax
	jne	$LN12@Mod_LoadLi

; 2557 : 		{
; 2558 : 			loadmodel->lightdata = out = (color24 *)Mem_Malloc( loadmodel->mempool, bmod->lightdatasize * sizeof( color24 ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadLighting@@9@9
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+108], 3
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+380], eax

; 2559 : 			in = bmod->lightdata;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _in$[ebp], ecx

; 2560 : 
; 2561 : 			// expand the white lighting data
; 2562 : 			for( i = 0; i < bmod->lightdatasize; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_LoadLi
$LN4@Mod_LoadLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 3
	mov	DWORD PTR _out$[ebp], ecx
$LN6@Mod_LoadLi:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+108]
	jae	SHORT $LN12@Mod_LoadLi

; 2563 : 				out->r = out->g = out->b = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+2], dl
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+1], dl
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1
	mov	DWORD PTR _in$[ebp], eax
	jmp	SHORT $LN4@Mod_LoadLi
$LN12@Mod_LoadLi:

; 2564 : 		}
; 2565 : 		break;

	jmp	$LN2@Mod_LoadLi
$LN13@Mod_LoadLi:

; 2566 : 	case 3:	// load colored lighting
; 2567 : 		loadmodel->lightdata = Mem_Malloc( loadmodel->mempool, bmod->lightdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadLighting@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+380], eax

; 2568 : 		memcpy( loadmodel->lightdata, bmod->lightdata, bmod->lightdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+380]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2569 : 		SetBits( loadmodel->flags, MODEL_COLORED_LIGHTING );

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+80], ecx

; 2570 : 		break;

	jmp	SHORT $LN2@Mod_LoadLi
$LN14@Mod_LoadLi:

; 2571 : 	default:
; 2572 : 		Host_Error( "Mod_LoadLighting: bad lightmap sample count %i\n", bmod->lightmap_samples );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9376]
	push	ecx
	push	OFFSET ??_C@_0DA@HKHAIKBM@Mod_LoadLighting?3?5bad?5lightmap?5@
	call	_Host_Error
	add	esp, 8
$LN2@Mod_LoadLi:

; 2573 : 		break;
; 2574 : 	}
; 2575 : 
; 2576 : 	// not supposed to be load ?
; 2577 : 	if( FBitSet( host.features, ENGINE_LOAD_DELUXEDATA ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 4
	je	SHORT $LN15@Mod_LoadLi

; 2578 : 	{
; 2579 : 		Mod_LoadLightVecs( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadLightVecs
	add	esp, 4

; 2580 : 		Mod_LoadShadowmap( bmod );

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadShadowmap
	add	esp, 4

; 2581 : 
; 2582 : 		if( bmod->isworld && bmod->deluxdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN15@Mod_LoadLi
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $LN15@Mod_LoadLi

; 2583 : 			SetBits( world.flags, FWORLD_HAS_DELUXEMAP );

	mov	eax, DWORD PTR _world+8
	or	eax, 8
	mov	DWORD PTR _world+8, eax
$LN15@Mod_LoadLi:

; 2584 : 	}
; 2585 : 
; 2586 : 	surf = loadmodel->surfaces;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], ecx

; 2587 : 
; 2588 : 	// setup lightdata pointers
; 2589 : 	for( i = 0; i < loadmodel->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_LoadLi
$LN7@Mod_LoadLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN9@Mod_LoadLi:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+176]
	jge	$LN1@Mod_LoadLi

; 2590 : 	{
; 2591 : 		if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN17@Mod_LoadLi

; 2592 : 			lightofs = bmod->surfaces32[i].lightofs;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [edx+eax+24]
	mov	DWORD PTR _lightofs$[ebp], eax
	jmp	SHORT $LN18@Mod_LoadLi
$LN17@Mod_LoadLi:

; 2593 : 		else lightofs = bmod->surfaces[i].lightofs;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _lightofs$[ebp], eax
$LN18@Mod_LoadLi:

; 2594 : 
; 2595 : 		if( loadmodel->lightdata && lightofs != -1 )

	mov	eax, DWORD PTR _loadmodel
	cmp	DWORD PTR [eax+380], 0
	je	SHORT $LN19@Mod_LoadLi
	cmp	DWORD PTR _lightofs$[ebp], -1
	je	SHORT $LN19@Mod_LoadLi

; 2596 : 		{
; 2597 : 			int	offset = (lightofs / bmod->lightmap_samples);

	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _lightofs$[ebp]
	cdq
	idiv	DWORD PTR [ecx+9376]
	mov	DWORD PTR _offset$1[ebp], eax

; 2598 : 
; 2599 : 			// NOTE: we divide offset by three because lighting and deluxemap keep their pointers
; 2600 : 			// into three-bytes structs and shadowmap just monochrome
; 2601 : 			surf->samples = loadmodel->lightdata + offset;

	imul	eax, DWORD PTR _offset$1[ebp], 3
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+380]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [edx+84], eax

; 2602 : 
; 2603 : 			// if deluxemap is present setup it too
; 2604 : 			if( bmod->deluxedata_out )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN20@Mod_LoadLi

; 2605 : 				surf->info->deluxemap = bmod->deluxedata_out + offset;

	imul	eax, DWORD PTR _offset$1[ebp], 3
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+144]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+88], eax
$LN20@Mod_LoadLi:

; 2606 : 
; 2607 : 			// will be used by mods
; 2608 : 			if( bmod->shadowdata_out )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+148], 0
	je	SHORT $LN19@Mod_LoadLi

; 2609 : 				surf->info->shadowmap = bmod->shadowdata_out + offset;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	add	ecx, DWORD PTR _offset$1[ebp]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+92], ecx
$LN19@Mod_LoadLi:

; 2610 : 		}
; 2611 : 	}

	jmp	$LN7@Mod_LoadLi
$LN1@Mod_LoadLi:

; 2612 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadShadowmap
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadShadowmap PROC					; COMDAT

; 2526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2527 : 	if( bmod->shadowdatasize != ( bmod->lightdatasize / 3 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [eax+108]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [edx+124], eax
	je	SHORT $LN2@Mod_LoadSh

; 2528 : 	{
; 2529 : 		if( bmod->shadowdatasize > 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jbe	SHORT $LN3@Mod_LoadSh

; 2530 : 			Con_Printf( S_ERROR "Mod_LoadShadowmap: has mismatched size (%i should be %i)\n", bmod->shadowdatasize, bmod->lightdatasize / 3 );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [eax+108]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	push	eax
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	push	OFFSET ??_C@_0EF@KCNBOONH@?$FO1Error?3?$FO7?5Mod_LoadShadowmap?3?5h@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN3@Mod_LoadSh:

; 2531 : 		return;

	jmp	SHORT $LN1@Mod_LoadSh
$LN2@Mod_LoadSh:

; 2532 : 	}
; 2533 : 
; 2534 : 	bmod->shadowdata_out = Mem_Malloc( loadmodel->mempool, bmod->shadowdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadShadowmap@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [edx+148], eax

; 2535 : 	memcpy( bmod->shadowdata_out, bmod->shadowdata, bmod->shadowdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadSh:

; 2536 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadShadowmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadLightVecs
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadLightVecs PROC					; COMDAT

; 2507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2508 : 	if( bmod->deluxdatasize != bmod->lightdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [eax+116]
	cmp	edx, DWORD PTR [ecx+108]
	je	SHORT $LN2@Mod_LoadLi

; 2509 : 	{
; 2510 : 		if( bmod->deluxdatasize > 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jbe	SHORT $LN3@Mod_LoadLi

; 2511 : 			Con_Printf( S_ERROR "Mod_LoadLightVecs: has mismatched size (%i should be %i)\n", bmod->deluxdatasize, bmod->lightdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+116]
	push	eax
	push	OFFSET ??_C@_0EF@GIOPOPOK@?$FO1Error?3?$FO7?5Mod_LoadLightVecs?3?5h@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN4@Mod_LoadLi
$LN3@Mod_LoadLi:

; 2512 : 		else Mod_LoadDeluxemap( bmod ); // old method

	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_LoadDeluxemap
	add	esp, 4
$LN4@Mod_LoadLi:

; 2513 : 		return;

	jmp	SHORT $LN1@Mod_LoadLi
$LN2@Mod_LoadLi:

; 2514 : 	}
; 2515 : 
; 2516 : 	bmod->deluxedata_out = Mem_Malloc( loadmodel->mempool, bmod->deluxdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadLightVecs@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [edx+144], eax

; 2517 : 	memcpy( bmod->deluxedata_out, bmod->deluxdata, bmod->deluxdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadLi:

; 2518 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLightVecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadVisibility
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadVisibility PROC				; COMDAT

; 2496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2497 : 	loadmodel->visdata = Mem_Malloc( loadmodel->mempool, bmod->visdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadVisibility@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+376], eax

; 2498 : 	memcpy( loadmodel->visdata, bmod->visdata, bmod->visdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+376]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2499 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadClipnodes
_TEXT	SEGMENT
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadClipnodes PROC					; COMDAT

; 2450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2451 : 	dclipnode32_t	*out;
; 2452 : 	int		i;
; 2453 : 
; 2454 : 	bmod->clipnodes_out = out = (dclipnode32_t *)Mem_Malloc( loadmodel->mempool, bmod->numclipnodes * sizeof( *out ));	

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadClipnodes@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+44], 12
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+152], eax

; 2455 : 
; 2456 : 	if(( bmod->version == QBSP2_VERSION ) || ( bmod->version == HLBSP_VERSION && bmod->numclipnodes >= MAX_MAP_CLIPNODES ))

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	je	SHORT $LN10@Mod_LoadCl
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 30		; 0000001eH
	jne	$LN8@Mod_LoadCl
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+44], 32767		; 00007fffH
	jl	$LN8@Mod_LoadCl
$LN10@Mod_LoadCl:

; 2457 : 	{
; 2458 : 		dclipnode32_t	*in = bmod->clipnodes32;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _in$2[ebp], ecx

; 2459 : 
; 2460 : 		for( i = 0; i < bmod->numclipnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadCl
$LN2@Mod_LoadCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$2[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _in$2[ebp], edx
$LN4@Mod_LoadCl:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jge	SHORT $LN3@Mod_LoadCl

; 2461 : 		{
; 2462 : 			out->planenum = in->planenum;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2463 : 			out->children[0] = in->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+4], ecx

; 2464 : 			out->children[1] = in->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 2465 : 		}

	jmp	SHORT $LN2@Mod_LoadCl
$LN3@Mod_LoadCl:

; 2466 : 	}

	jmp	$LN9@Mod_LoadCl
$LN8@Mod_LoadCl:

; 2467 : 	else
; 2468 : 	{
; 2469 : 		dclipnode_t	*in = bmod->clipnodes;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _in$1[ebp], ecx

; 2470 : 
; 2471 : 		for( i = 0; i < bmod->numclipnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadCl
$LN5@Mod_LoadCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$1[ebp]
	add	edx, 8
	mov	DWORD PTR _in$1[ebp], edx
$LN7@Mod_LoadCl:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jge	$LN9@Mod_LoadCl

; 2472 : 		{
; 2473 : 			out->planenum = in->planenum;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2474 : 
; 2475 : 			out->children[0] = (unsigned short)in->children[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [edx+ecx+4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax+4], ecx

; 2476 : 			out->children[1] = (unsigned short)in->children[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$1[ebp]
	movzx	eax, WORD PTR [edx+eax+4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+ecx+4], eax

; 2477 : 
; 2478 : 			// Arguire QBSP 'broken' clipnodes
; 2479 : 			if( out->children[0] >= bmod->numclipnodes )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	cmp	ecx, DWORD PTR [eax+44]
	jl	SHORT $LN11@Mod_LoadCl

; 2480 : 				out->children[0] -= 65536;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	sub	eax, 65536				; 00010000H
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+edx+4], eax
$LN11@Mod_LoadCl:

; 2481 : 			if( out->children[1] >= bmod->numclipnodes )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	cmp	eax, DWORD PTR [edx+44]
	jl	SHORT $LN12@Mod_LoadCl

; 2482 : 				out->children[1] -= 65536;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	sub	edx, 65536				; 00010000H
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx
$LN12@Mod_LoadCl:

; 2483 : 		}

	jmp	$LN5@Mod_LoadCl
$LN9@Mod_LoadCl:

; 2484 : 	}
; 2485 : 
; 2486 : 	// FIXME: fill loadmodel->clipnodes?
; 2487 : 	loadmodel->numclipnodes = bmod->numclipnodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+192], edx

; 2488 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadClipnodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadLeafs
_TEXT	SEGMENT
_in$1 = -28						; size = 4
_in$2 = -24						; size = 4
_visclusters$ = -20					; size = 4
_p$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadLeafs PROC					; COMDAT

; 2349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2350 : 	mleaf_t	*out;
; 2351 : 	int	i, j, p;
; 2352 : 	int	visclusters = 0;

	mov	DWORD PTR _visclusters$[ebp], 0

; 2353 : 
; 2354 : 	loadmodel->leafs = out = (mleaf_t *)Mem_Calloc( loadmodel->mempool, bmod->numleafs * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadLeafs@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+36], 60
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+140], eax

; 2355 : 	loadmodel->numleafs = bmod->numleafs;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+136], edx

; 2356 : 
; 2357 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN20@Mod_LoadLe

; 2358 : 	{
; 2359 : 		visclusters = loadmodel->submodels[0].visleafs;

	mov	eax, 64					; 00000040H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+124]
	mov	ecx, DWORD PTR [eax+ecx+52]
	mov	DWORD PTR _visclusters$[ebp], ecx

; 2360 : 		world.visbytes = (visclusters + 7) >> 3;

	mov	eax, DWORD PTR _visclusters$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _world+2588, eax

; 2361 : 		world.fatbytes = (visclusters + 31) >> 3;

	mov	eax, DWORD PTR _visclusters$[ebp]
	add	eax, 31					; 0000001fH
	sar	eax, 3
	mov	DWORD PTR _world+2592, eax
$LN20@Mod_LoadLe:

; 2362 : 	}
; 2363 : 
; 2364 : 	for( i = 0; i < bmod->numleafs; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadLe
$LN2@Mod_LoadLe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Mod_LoadLe:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	$LN3@Mod_LoadLe

; 2365 : 	{
; 2366 : 		if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	$LN21@Mod_LoadLe

; 2367 : 		{
; 2368 : 			dleaf32_t	*in = &bmod->leafs32[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _in$2[ebp], eax

; 2369 : 
; 2370 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadLe
$LN5@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadLe

; 2371 : 			{
; 2372 : 				out->minmaxs[j+0] = in->mins[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [esi+edx*4+8]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 2373 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [esi+edx*4+20]
	mov	DWORD PTR [ecx+eax*4+20], edx

; 2374 : 			}

	jmp	SHORT $LN5@Mod_LoadLe
$LN6@Mod_LoadLe:

; 2375 : 
; 2376 : 			out->contents = in->contents;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2377 : 			p = in->visofs;

	mov	eax, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx

; 2378 : 
; 2379 : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadLe
$LN8@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadLe

; 2380 : 				out->ambient_sound_level[j] = in->ambient_level[j];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+56], dl
	jmp	SHORT $LN8@Mod_LoadLe
$LN9@Mod_LoadLe:

; 2381 : 
; 2382 : 			out->firstmarksurface = loadmodel->marksurfaces + in->firstmarksurface;

	mov	eax, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+204]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 2383 : 			out->nummarksurfaces = in->nummarksurfaces;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+48], edx

; 2384 : 		}

	jmp	$LN22@Mod_LoadLe
$LN21@Mod_LoadLe:

; 2385 : 		else
; 2386 : 		{
; 2387 : 			dleaf_t	*in = &bmod->leafs[i];

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _in$1[ebp], eax

; 2388 : 
; 2389 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadLe
$LN11@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN12@Mod_LoadLe

; 2390 : 			{
; 2391 : 				out->minmaxs[j+0] = in->mins[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+8]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+8], xmm0

; 2392 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+14]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+20], xmm0

; 2393 : 			}

	jmp	SHORT $LN11@Mod_LoadLe
$LN12@Mod_LoadLe:

; 2394 : 
; 2395 : 			out->contents = in->contents;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2396 : 			p = in->visofs;

	mov	eax, DWORD PTR _in$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx

; 2397 : 
; 2398 : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadLe
$LN14@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@Mod_LoadLe:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN15@Mod_LoadLe

; 2399 : 				out->ambient_sound_level[j] = in->ambient_level[j];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+56], dl
	jmp	SHORT $LN14@Mod_LoadLe
$LN15@Mod_LoadLe:

; 2400 : 
; 2401 : 			out->firstmarksurface = loadmodel->marksurfaces + in->firstmarksurface;

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax+20]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+204]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 2402 : 			out->nummarksurfaces = in->nummarksurfaces;

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN22@Mod_LoadLe:

; 2403 : 		}
; 2404 : 
; 2405 : 		if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN23@Mod_LoadLe

; 2406 : 		{
; 2407 : 			out->cluster = ( i - 1 ); // solid leaf 0 has no visdata

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 2408 : 
; 2409 : 			if( out->cluster >= visclusters )

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR _visclusters$[ebp]
	jl	SHORT $LN25@Mod_LoadLe

; 2410 : 				out->cluster = -1;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+52], -1
$LN25@Mod_LoadLe:

; 2411 : 
; 2412 : 			// ignore visofs errors on leaf 0 (solid)
; 2413 : 			if( p >= 0 && out->cluster >= 0 && loadmodel->visdata )

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN28@Mod_LoadLe
	mov	eax, DWORD PTR _out$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN28@Mod_LoadLe
	mov	eax, DWORD PTR _loadmodel
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN28@Mod_LoadLe

; 2414 : 			{
; 2415 : 				if( p < bmod->visdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jae	SHORT $LN27@Mod_LoadLe

; 2416 : 					out->compressed_vis = loadmodel->visdata + p;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+376]
	add	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN28@Mod_LoadLe
$LN27@Mod_LoadLe:

; 2417 : 				else Con_Reportf( S_WARN "Mod_LoadLeafs: invalid visofs for leaf #%i\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@JDIEEHLB@?$FO3Warning?3?$FO7?5Mod_LoadLeafs?3?5inv@
	call	_Con_Reportf
	add	esp, 8
$LN28@Mod_LoadLe:

; 2418 : 			}
; 2419 : 	          }

	jmp	SHORT $LN24@Mod_LoadLe
$LN23@Mod_LoadLe:

; 2420 : 		else out->cluster = -1; // no visclusters on bmodels

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+52], -1
$LN24@Mod_LoadLe:

; 2421 : 
; 2422 : 		if( p == -1 ) out->compressed_vis = NULL;

	cmp	DWORD PTR _p$[ebp], -1
	jne	SHORT $LN29@Mod_LoadLe
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+36], 0
	jmp	SHORT $LN30@Mod_LoadLe
$LN29@Mod_LoadLe:

; 2423 : 		else out->compressed_vis = loadmodel->visdata + p;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+376]
	add	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN30@Mod_LoadLe:

; 2424 : 
; 2425 : 		// gl underwater warp
; 2426 : 		if( out->contents != CONTENTS_EMPTY )

	mov	eax, DWORD PTR _out$[ebp]
	cmp	DWORD PTR [eax], -1
	je	SHORT $LN18@Mod_LoadLe

; 2427 : 		{
; 2428 : 			for( j = 0; j < out->nummarksurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@Mod_LoadLe
$LN17@Mod_LoadLe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@Mod_LoadLe:
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN18@Mod_LoadLe

; 2429 : 			{
; 2430 : 				// mark underwater surfaces
; 2431 : 				SetBits( out->firstmarksurface[j]->flags, SURF_UNDERWATER );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+8], ecx

; 2432 : 			}

	jmp	SHORT $LN17@Mod_LoadLe
$LN18@Mod_LoadLe:

; 2433 : 		}
; 2434 : 	}

	jmp	$LN2@Mod_LoadLe
$LN3@Mod_LoadLe:

; 2435 : 
; 2436 : 	if( bmod->isworld && loadmodel->leafs[0].contents != CONTENTS_SOLID )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN32@Mod_LoadLe
	mov	eax, 60					; 0000003cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+140]
	cmp	DWORD PTR [eax+ecx], -2			; fffffffeH
	je	SHORT $LN32@Mod_LoadLe

; 2437 : 		Host_Error( "Mod_LoadLeafs: Map %s has leaf 0 is not CONTENTS_SOLID\n", loadmodel->name );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET ??_C@_0DI@KNHJIOGB@Mod_LoadLeafs?3?5Map?5?$CFs?5has?5leaf?5@
	call	_Host_Error
	add	esp, 8
$LN32@Mod_LoadLe:

; 2438 : 
; 2439 : 	// do some final things for world
; 2440 : 	if( bmod->isworld && Mod_CheckWaterAlphaSupport( bmod ))

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN33@Mod_LoadLe
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_CheckWaterAlphaSupport
	add	esp, 4
	test	eax, eax
	je	SHORT $LN33@Mod_LoadLe

; 2441 : 		SetBits( world.flags, FWORLD_WATERALPHA );

	mov	eax, DWORD PTR _world+8
	or	eax, 4
	mov	DWORD PTR _world+8, eax
$LN33@Mod_LoadLe:

; 2442 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLeafs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadNodes
_TEXT	SEGMENT
_in$1 = -24						; size = 4
_in$2 = -20						; size = 4
_p$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadNodes PROC					; COMDAT

; 2284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 2285 : 	mnode_t	*out;
; 2286 : 	int	i, j, p;
; 2287 : 
; 2288 : 	loadmodel->nodes = out = (mnode_t *)Mem_Calloc( loadmodel->mempool, bmod->numnodes * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadNodes@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+28], 52
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+164], eax

; 2289 : 	loadmodel->numnodes = bmod->numnodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+160], edx

; 2290 : 
; 2291 : 	for( i = 0; i < loadmodel->numnodes; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadNo
$LN2@Mod_LoadNo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Mod_LoadNo:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+160]
	jge	$LN3@Mod_LoadNo

; 2292 : 	{
; 2293 : 		if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	$LN17@Mod_LoadNo

; 2294 : 		{
; 2295 : 			dnode32_t	*in = &bmod->nodes32[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _in$2[ebp], eax

; 2296 : 
; 2297 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadNo
$LN5@Mod_LoadNo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadNo

; 2298 : 			{
; 2299 : 				out->minmaxs[j+0] = in->mins[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [esi+edx*4+12]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 2300 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [esi+edx*4+24]
	mov	DWORD PTR [ecx+eax*4+20], edx

; 2301 : 			}

	jmp	SHORT $LN5@Mod_LoadNo
$LN6@Mod_LoadNo:

; 2302 : 
; 2303 : 			p = in->planenum;

	mov	eax, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 2304 : 			out->plane = loadmodel->planes + p;

	imul	eax, DWORD PTR _p$[ebp], 20
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+132]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], eax

; 2305 : 			out->firstsurface = in->firstface;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	dx, WORD PTR [ecx+36]
	mov	WORD PTR [eax+48], dx

; 2306 : 			out->numsurfaces = in->numfaces;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	dx, WORD PTR [ecx+40]
	mov	WORD PTR [eax+50], dx

; 2307 : 
; 2308 : 			for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadNo
$LN8@Mod_LoadNo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN9@Mod_LoadNo

; 2309 : 			{
; 2310 : 				p = in->children[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _p$[ebp], edx

; 2311 : 				if( p >= 0 ) out->children[j] = loadmodel->nodes + p;

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN19@Mod_LoadNo
	imul	eax, DWORD PTR _p$[ebp], 52
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+edx*4+40], eax
	jmp	SHORT $LN20@Mod_LoadNo
$LN19@Mod_LoadNo:

; 2312 : 				else out->children[j] = (mnode_t *)(loadmodel->leafs + ( -1 - p ));

	or	eax, -1
	sub	eax, DWORD PTR _p$[ebp]
	imul	ecx, eax, 60
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax*4+40], ecx
$LN20@Mod_LoadNo:

; 2313 : 			}

	jmp	SHORT $LN8@Mod_LoadNo
$LN9@Mod_LoadNo:

; 2314 : 		}

	jmp	$LN15@Mod_LoadNo
$LN17@Mod_LoadNo:

; 2315 : 		else
; 2316 : 		{
; 2317 : 			dnode_t	*in = &bmod->nodes[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _in$1[ebp], eax

; 2318 : 
; 2319 : 			for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadNo
$LN11@Mod_LoadNo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN12@Mod_LoadNo

; 2320 : 			{
; 2321 : 				out->minmaxs[j+0] = in->mins[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+8]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+8], xmm0

; 2322 : 				out->minmaxs[j+3] = in->maxs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+14]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax*4+20], xmm0

; 2323 : 			}

	jmp	SHORT $LN11@Mod_LoadNo
$LN12@Mod_LoadNo:

; 2324 : 
; 2325 : 			p = in->planenum;

	mov	eax, DWORD PTR _in$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 2326 : 			out->plane = loadmodel->planes + p;

	imul	eax, DWORD PTR _p$[ebp], 20
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+132]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+36], eax

; 2327 : 			out->firstsurface = in->firstface;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR [eax+48], dx

; 2328 : 			out->numsurfaces = in->numfaces;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	mov	dx, WORD PTR [ecx+22]
	mov	WORD PTR [eax+50], dx

; 2329 : 
; 2330 : 			for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadNo
$LN14@Mod_LoadNo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@Mod_LoadNo:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN15@Mod_LoadNo

; 2331 : 			{
; 2332 : 				p = in->children[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	mov	DWORD PTR _p$[ebp], edx

; 2333 : 				if( p >= 0 ) out->children[j] = loadmodel->nodes + p;

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN21@Mod_LoadNo
	imul	eax, DWORD PTR _p$[ebp], 52
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+edx*4+40], eax
	jmp	SHORT $LN22@Mod_LoadNo
$LN21@Mod_LoadNo:

; 2334 : 				else out->children[j] = (mnode_t *)(loadmodel->leafs + ( -1 - p ));

	or	eax, -1
	sub	eax, DWORD PTR _p$[ebp]
	imul	ecx, eax, 60
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax*4+40], ecx
$LN22@Mod_LoadNo:

; 2335 : 			}

	jmp	SHORT $LN14@Mod_LoadNo
$LN15@Mod_LoadNo:

; 2336 : 		}
; 2337 : 	}

	jmp	$LN2@Mod_LoadNo
$LN3@Mod_LoadNo:

; 2338 : 
; 2339 : 	// sets nodes and leafs
; 2340 : 	Mod_SetParent( loadmodel->nodes, NULL );

	push	0
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	call	_Mod_SetParent
	add	esp, 8

; 2341 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadNodes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadSurfaces
_TEXT	SEGMENT
tv383 = -132						; size = 4
tv376 = -132						; size = 4
_samples$1 = -64					; size = 4
_lightstyles$2 = -60					; size = 4
_tmax$3 = -56						; size = 4
_smax$4 = -52						; size = 4
_sample_size$5 = -48					; size = 4
_in$6 = -44						; size = 4
_in$7 = -40						; size = 4
_tex$8 = -36						; size = 4
_out$ = -32						; size = 4
_info$ = -28						; size = 4
_lightofs$ = -24					; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_prev_lightofs$ = -12					; size = 4
_next_lightofs$ = -8					; size = 4
_test_lightsize$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadSurfaces PROC					; COMDAT

; 2125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 2126 : 	int		test_lightsize = -1;

	mov	DWORD PTR _test_lightsize$[ebp], -1

; 2127 : 	int		next_lightofs = -1;

	mov	DWORD PTR _next_lightofs$[ebp], -1

; 2128 : 	int		prev_lightofs = -1;

	mov	DWORD PTR _prev_lightofs$[ebp], -1

; 2129 : 	int		i, j, lightofs;
; 2130 : 	mextrasurf_t	*info;
; 2131 : 	msurface_t	*out;
; 2132 : 
; 2133 : 	loadmodel->surfaces = out = Mem_Calloc( loadmodel->mempool, bmod->numsurfaces * sizeof( msurface_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSurfaces@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+84], 92
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+180], eax

; 2134 : 	info = Mem_Calloc( loadmodel->mempool, bmod->numsurfaces * sizeof( mextrasurf_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSurfaces@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+84], 324
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _info$[ebp], eax

; 2135 : 	loadmodel->numsurfaces = bmod->numsurfaces;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+176], edx

; 2136 : 
; 2137 : 	// predict samplecount based on bspversion
; 2138 : 	if( bmod->version == Q1BSP_VERSION || bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 29		; 0000001dH
	je	SHORT $LN16@Mod_LoadSu
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN14@Mod_LoadSu
$LN16@Mod_LoadSu:

; 2139 : 		bmod->lightmap_samples = 1;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9376], 1
	jmp	SHORT $LN15@Mod_LoadSu
$LN14@Mod_LoadSu:

; 2140 : 	else bmod->lightmap_samples = 3;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9376], 3
$LN15@Mod_LoadSu:

; 2141 : 
; 2142 : 	for( i = 0; i < bmod->numsurfaces; i++, out++, info++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadSu
$LN2@Mod_LoadSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 324				; 00000144H
	mov	DWORD PTR _info$[ebp], edx
$LN4@Mod_LoadSu:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+84]
	jae	$LN3@Mod_LoadSu

; 2143 : 	{
; 2144 : 		texture_t	*tex;
; 2145 : 
; 2146 : 		// setup crosslinks between two parts of msurface_t
; 2147 : 		out->info = info;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 2148 : 		info->surf = out;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2149 : 
; 2150 : 		if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	$LN17@Mod_LoadSu

; 2151 : 		{
; 2152 : 			dface32_t	*in = &bmod->surfaces32[i];

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR _in$7[ebp], eax

; 2153 : 
; 2154 : 			if(( in->firstedge + in->numedges ) > loadmodel->numsurfedges )

	mov	eax, DWORD PTR _in$7[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _in$7[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _loadmodel
	cmp	ecx, DWORD PTR [eax+184]
	jle	SHORT $LN19@Mod_LoadSu

; 2155 : 				continue;	// corrupted level?

	jmp	SHORT $LN2@Mod_LoadSu
$LN19@Mod_LoadSu:

; 2156 : 			out->firstedge = in->firstedge;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$7[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 2157 : 			out->numedges = in->numedges;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$7[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+16], edx

; 2158 : 			if( in->side ) SetBits( out->flags, SURF_PLANEBACK );

	mov	eax, DWORD PTR _in$7[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN20@Mod_LoadSu
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 2
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN20@Mod_LoadSu:

; 2159 : 			out->plane = loadmodel->planes + in->planenum;

	mov	eax, DWORD PTR _in$7[ebp]
	imul	ecx, DWORD PTR [eax], 20
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2160 : 			out->texinfo = loadmodel->texinfo + in->texinfo;

	mov	eax, DWORD PTR _in$7[ebp]
	imul	ecx, DWORD PTR [eax+16], 44
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+172]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 2161 : 
; 2162 : 			for( j = 0; j < MAXLIGHTMAPS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadSu
$LN5@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_LoadSu

; 2163 : 				out->styles[j] = in->styles[j];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$7[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [ecx+20]
	mov	BYTE PTR [eax+60], dl
	jmp	SHORT $LN5@Mod_LoadSu
$LN6@Mod_LoadSu:

; 2164 : 			lightofs = in->lightofs;

	mov	eax, DWORD PTR _in$7[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _lightofs$[ebp], ecx

; 2165 : 		}

	jmp	$LN18@Mod_LoadSu
$LN17@Mod_LoadSu:

; 2166 : 		else
; 2167 : 		{
; 2168 : 			dface_t	*in = &bmod->surfaces[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _bmod$[ebp]
	add	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR _in$6[ebp], eax

; 2169 : 
; 2170 : 			if(( in->firstedge + in->numedges ) > loadmodel->numsurfedges )

	mov	eax, DWORD PTR _in$6[ebp]
	movsx	ecx, WORD PTR [eax+8]
	mov	edx, DWORD PTR _in$6[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _loadmodel
	cmp	ecx, DWORD PTR [eax+184]
	jle	SHORT $LN21@Mod_LoadSu

; 2171 : 			{
; 2172 : 				Con_Reportf( S_ERROR "bad surface %i from %i\n", i, bmod->numsurfaces );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@JGFJELJB@?$FO1Error?3?$FO7?5bad?5surface?5?$CFi?5from?5@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2173 : 				continue;

	jmp	$LN2@Mod_LoadSu
$LN21@Mod_LoadSu:

; 2174 : 			}
; 2175 : 
; 2176 : 			out->firstedge = in->firstedge;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$6[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx

; 2177 : 			out->numedges = in->numedges;

	mov	eax, DWORD PTR _in$6[ebp]
	movsx	ecx, WORD PTR [eax+8]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 2178 : 			if( in->side ) SetBits( out->flags, SURF_PLANEBACK );

	mov	eax, DWORD PTR _in$6[ebp]
	movsx	ecx, WORD PTR [eax+2]
	test	ecx, ecx
	je	SHORT $LN22@Mod_LoadSu
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 2
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN22@Mod_LoadSu:

; 2179 : 			out->plane = loadmodel->planes + in->planenum;

	mov	eax, DWORD PTR _in$6[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	edx, ecx, 20
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+132]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 2180 : 			out->texinfo = loadmodel->texinfo + in->texinfo;

	mov	eax, DWORD PTR _in$6[ebp]
	movsx	ecx, WORD PTR [eax+10]
	imul	edx, ecx, 44
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 2181 : 
; 2182 : 			for( j = 0; j < MAXLIGHTMAPS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadSu
$LN8@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadSu

; 2183 : 				out->styles[j] = in->styles[j];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$6[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [ecx+12]
	mov	BYTE PTR [eax+60], dl
	jmp	SHORT $LN8@Mod_LoadSu
$LN9@Mod_LoadSu:

; 2184 : 			lightofs = in->lightofs;

	mov	eax, DWORD PTR _in$6[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _lightofs$[ebp], ecx
$LN18@Mod_LoadSu:

; 2185 : 		}
; 2186 : 
; 2187 : 		tex = out->texinfo->texture;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _tex$8[ebp], edx

; 2188 : 
; 2189 : 		if( !Q_strncmp( tex->name, "sky", 3 ))

	push	3
	push	OFFSET ??_C@_03BNEOMJOP@sky@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@Mod_LoadSu

; 2190 : 			SetBits( out->flags, SURF_DRAWSKY );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN23@Mod_LoadSu:

; 2191 : 
; 2192 : 		if(( tex->name[0] == '*' && Q_stricmp( tex->name, "*default" )) || tex->name[0] == '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$8[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN26@Mod_LoadSu
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08KPIGECMN@?$CKdefault@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@Mod_LoadSu
$LN26@Mod_LoadSu:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$8[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN24@Mod_LoadSu
$LN25@Mod_LoadSu:

; 2193 : 			SetBits( out->flags, SURF_DRAWTURB );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN24@Mod_LoadSu:

; 2194 : 
; 2195 : 		if( !CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadSu

; 2196 : 		{
; 2197 : 			if( !Q_strncmp( tex->name, "water", 5 ) || !Q_strnicmp( tex->name, "laser", 5 ))

	push	5
	push	OFFSET ??_C@_05ELAABIKM@water@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@Mod_LoadSu
	push	5
	push	OFFSET ??_C@_05LPMGNCEN@laser@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadSu
$LN29@Mod_LoadSu:

; 2198 : 				SetBits( out->flags, SURF_DRAWTURB );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN28@Mod_LoadSu:

; 2199 : 		}
; 2200 : 
; 2201 : 		if( !Q_strncmp( tex->name, "scroll", 6 ))

	push	6
	push	OFFSET ??_C@_06FJKBNFNG@scroll@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@Mod_LoadSu

; 2202 : 			SetBits( out->flags, SURF_CONVEYOR );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN30@Mod_LoadSu:

; 2203 : 
; 2204 : 		if( FBitSet( out->texinfo->flags, TEX_SCROLL ))

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 64					; 00000040H
	je	SHORT $LN31@Mod_LoadSu

; 2205 : 			SetBits( out->flags, SURF_CONVEYOR );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN31@Mod_LoadSu:

; 2206 : 
; 2207 : 		// g-cont. added a combined conveyor-transparent
; 2208 : 		if( !Q_strncmp( tex->name, "{scroll", 7 ))

	push	7
	push	OFFSET ??_C@_07FANFFIAH@?$HLscroll@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN32@Mod_LoadSu

; 2209 : 			SetBits( out->flags, SURF_CONVEYOR|SURF_TRANSPARENT );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 320				; 00000140H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN32@Mod_LoadSu:

; 2210 : 
; 2211 : 		// g-cont this texture from decals.wad he-he
; 2212 : 		// support !reflect for reflected water
; 2213 : 		if (!Q_strcmp(tex->name, "reflect1") || !Q_strncmp(tex->name, "!reflect", 8))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08CFBMHPMN@reflect1@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@Mod_LoadSu
	push	8
	push	OFFSET ??_C@_08DENCDAKP@?$CBreflect@
	mov	eax, DWORD PTR _tex$8[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@Mod_LoadSu
$LN34@Mod_LoadSu:

; 2214 : 		{
; 2215 : 			out->flags |= SURF_REFLECT;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 2216 : 			world.has_mirrors = true;

	mov	DWORD PTR _world+4, 1
$LN33@Mod_LoadSu:

; 2217 : 		}
; 2218 : 
; 2219 : 		if( tex->name[0] == '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$8[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN35@Mod_LoadSu

; 2220 : 			SetBits( out->flags, SURF_TRANSPARENT );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN35@Mod_LoadSu:

; 2221 : 
; 2222 : 		if( FBitSet( out->texinfo->flags, TEX_SPECIAL ))

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 1
	je	SHORT $LN36@Mod_LoadSu

; 2223 : 			SetBits( out->flags, SURF_DRAWTILED );

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN36@Mod_LoadSu:

; 2224 : 
; 2225 : 		Mod_CalcSurfaceBounds( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Mod_CalcSurfaceBounds
	add	esp, 4

; 2226 : 		Mod_CalcSurfaceExtents( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Mod_CalcSurfaceExtents
	add	esp, 4

; 2227 : 
; 2228 : 		// grab the second sample to detect colored lighting
; 2229 : 		if( test_lightsize > 0 && lightofs != -1 )

	cmp	DWORD PTR _test_lightsize$[ebp], 0
	jle	SHORT $LN38@Mod_LoadSu
	cmp	DWORD PTR _lightofs$[ebp], -1
	je	SHORT $LN38@Mod_LoadSu

; 2230 : 		{
; 2231 : 			if( lightofs > prev_lightofs && lightofs < next_lightofs )

	mov	eax, DWORD PTR _lightofs$[ebp]
	cmp	eax, DWORD PTR _prev_lightofs$[ebp]
	jle	SHORT $LN38@Mod_LoadSu
	mov	eax, DWORD PTR _lightofs$[ebp]
	cmp	eax, DWORD PTR _next_lightofs$[ebp]
	jge	SHORT $LN38@Mod_LoadSu

; 2232 : 				next_lightofs = lightofs;

	mov	eax, DWORD PTR _lightofs$[ebp]
	mov	DWORD PTR _next_lightofs$[ebp], eax
$LN38@Mod_LoadSu:

; 2233 : 		}
; 2234 : 
; 2235 : 		// grab the first sample to determine lightmap size
; 2236 : 		if( lightofs != -1 && test_lightsize == -1 )

	cmp	DWORD PTR _lightofs$[ebp], -1
	je	$LN39@Mod_LoadSu
	cmp	DWORD PTR _test_lightsize$[ebp], -1
	jne	$LN39@Mod_LoadSu

; 2237 : 		{
; 2238 : 			int	sample_size = Mod_SampleSizeForFace( out );

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$5[ebp], eax

; 2239 : 			int	smax = (info->lightextents[0] / sample_size) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$5[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$4[ebp], eax

; 2240 : 			int	tmax = (info->lightextents[1] / sample_size) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$5[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$3[ebp], eax

; 2241 : 			int	lightstyles = 0;

	mov	DWORD PTR _lightstyles$2[ebp], 0

; 2242 : 
; 2243 : 			test_lightsize = smax * tmax;

	mov	eax, DWORD PTR _smax$4[ebp]
	imul	eax, DWORD PTR _tmax$3[ebp]
	mov	DWORD PTR _test_lightsize$[ebp], eax

; 2244 : 			// count styles to right compute test_lightsize
; 2245 : 			for( j = 0; j < MAXLIGHTMAPS && out->styles[j] != 255; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadSu
$LN11@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN12@Mod_LoadSu
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN12@Mod_LoadSu

; 2246 : 				lightstyles++;

	mov	eax, DWORD PTR _lightstyles$2[ebp]
	add	eax, 1
	mov	DWORD PTR _lightstyles$2[ebp], eax
	jmp	SHORT $LN11@Mod_LoadSu
$LN12@Mod_LoadSu:

; 2247 : 
; 2248 : 			test_lightsize *= lightstyles;

	mov	eax, DWORD PTR _test_lightsize$[ebp]
	imul	eax, DWORD PTR _lightstyles$2[ebp]
	mov	DWORD PTR _test_lightsize$[ebp], eax

; 2249 : 			prev_lightofs = lightofs;

	mov	eax, DWORD PTR _lightofs$[ebp]
	mov	DWORD PTR _prev_lightofs$[ebp], eax

; 2250 : 			next_lightofs = 99999999;

	mov	DWORD PTR _next_lightofs$[ebp], 99999999 ; 05f5e0ffH
$LN39@Mod_LoadSu:

; 2251 : 		}
; 2252 : 
; 2253 : 		if( FBitSet( out->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN40@Mod_LoadSu

; 2254 : 			GL_SubdivideSurface( out ); // cut up polygon for warps

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_SubdivideSurface
	add	esp, 4
$LN40@Mod_LoadSu:

; 2255 : 	}

	jmp	$LN2@Mod_LoadSu
$LN3@Mod_LoadSu:

; 2256 : 
; 2257 : 	// now we have enough data to trying determine samplecount per lightmap pixel
; 2258 : 	if( test_lightsize > 0 && prev_lightofs != -1 && next_lightofs != -1 && next_lightofs != 99999999 )

	cmp	DWORD PTR _test_lightsize$[ebp], 0
	jle	$LN44@Mod_LoadSu
	cmp	DWORD PTR _prev_lightofs$[ebp], -1
	je	$LN44@Mod_LoadSu
	cmp	DWORD PTR _next_lightofs$[ebp], -1
	je	$LN44@Mod_LoadSu
	cmp	DWORD PTR _next_lightofs$[ebp], 99999999 ; 05f5e0ffH
	je	$LN44@Mod_LoadSu

; 2259 : 	{
; 2260 : 		float	samples = (float)(next_lightofs - prev_lightofs) / (float)test_lightsize;

	mov	eax, DWORD PTR _next_lightofs$[ebp]
	sub	eax, DWORD PTR _prev_lightofs$[ebp]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _test_lightsize$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _samples$1[ebp], xmm0

; 2261 : 
; 2262 : 		if( samples != (int)samples )

	cvttss2si eax, DWORD PTR _samples$1[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _samples$1[ebp]
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN42@Mod_LoadSu

; 2263 : 		{
; 2264 : 			test_lightsize = (test_lightsize + 3) & ~3; // align datasize and try again

	mov	eax, DWORD PTR _test_lightsize$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	DWORD PTR _test_lightsize$[ebp], eax

; 2265 : 			samples = (float)(next_lightofs - prev_lightofs) / (float)test_lightsize;

	mov	eax, DWORD PTR _next_lightofs$[ebp]
	sub	eax, DWORD PTR _prev_lightofs$[ebp]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _test_lightsize$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _samples$1[ebp], xmm0
$LN42@Mod_LoadSu:

; 2266 : 		}
; 2267 : 
; 2268 : 		if( samples == 1 || samples == 3 )

	movss	xmm0, DWORD PTR _samples$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN45@Mod_LoadSu
	movss	xmm0, DWORD PTR _samples$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@40400000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN43@Mod_LoadSu
$LN45@Mod_LoadSu:

; 2269 : 		{
; 2270 : 			bmod->lightmap_samples = (int)samples;

	cvttss2si eax, DWORD PTR _samples$1[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+9376], eax

; 2271 : 			Con_Reportf( "lighting: %s\n", (bmod->lightmap_samples == 1) ? "monochrome" : "colored" );

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9376], 1
	jne	SHORT $LN47@Mod_LoadSu
	mov	DWORD PTR tv376[ebp], OFFSET ??_C@_0L@FEJFGKNE@monochrome@
	jmp	SHORT $LN48@Mod_LoadSu
$LN47@Mod_LoadSu:
	mov	DWORD PTR tv376[ebp], OFFSET ??_C@_07FDKIFLAA@colored@
$LN48@Mod_LoadSu:
	mov	ecx, DWORD PTR tv376[ebp]
	push	ecx
	push	OFFSET ??_C@_0O@GMFBACMP@lighting?3?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8

; 2272 : 			bmod->lightmap_samples = Q_max( bmod->lightmap_samples, 1 ); // avoid division by zero

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9376], 1
	jle	SHORT $LN49@Mod_LoadSu
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+9376]
	mov	DWORD PTR tv383[ebp], edx
	jmp	SHORT $LN50@Mod_LoadSu
$LN49@Mod_LoadSu:
	mov	DWORD PTR tv383[ebp], 1
$LN50@Mod_LoadSu:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR tv383[ebp]
	mov	DWORD PTR [eax+9376], ecx

; 2273 : 		}

	jmp	SHORT $LN44@Mod_LoadSu
$LN43@Mod_LoadSu:

; 2274 : 		else Con_DPrintf( S_WARN "lighting invalid samplecount: %g, defaulting to %i\n", samples, bmod->lightmap_samples );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9376]
	push	ecx
	cvtss2sd xmm0, DWORD PTR _samples$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0EB@PLJOECOM@?$FO3Warning?3?$FO7?5lighting?5invalid?5s@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN44@Mod_LoadSu:

; 2275 : 	}
; 2276 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadTexInfo
_TEXT	SEGMENT
_in$ = -32						; size = 4
_out$ = -28						; size = 4
_fin$ = -24						; size = 4
_miptex$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_faceinfo$ = -8						; size = 4
_fout$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadTexInfo PROC					; COMDAT

; 2079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 2080 : 	mfaceinfo_t	*fout, *faceinfo;
; 2081 : 	int		i, j, miptex;
; 2082 : 	dfaceinfo_t	*fin;
; 2083 : 	mtexinfo_t	*out;
; 2084 : 	dtexinfo_t	*in;
; 2085 : 
; 2086 : 	// trying to load faceinfo
; 2087 : 	faceinfo = fout = Mem_Calloc( loadmodel->mempool, bmod->numfaceinfo * sizeof( *fout ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTexInfo@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+92], 176
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _fout$[ebp], eax
	mov	edx, DWORD PTR _fout$[ebp]
	mov	DWORD PTR _faceinfo$[ebp], edx

; 2088 : 	fin = bmod->faceinfo;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _fin$[ebp], ecx

; 2089 : 
; 2090 : 	for( i = 0; i < bmod->numfaceinfo; i++, fin++, fout++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadTe
$LN2@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, 22					; 00000016H
	mov	DWORD PTR _fin$[ebp], ecx
	mov	edx, DWORD PTR _fout$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR _fout$[ebp], edx
$LN4@Mod_LoadTe:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+92]
	jae	SHORT $LN3@Mod_LoadTe

; 2091 : 	{
; 2092 : 		Q_strncpy( fout->landname, fin->landname, sizeof( fout->landname ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2093 : 		fout->texture_step = fin->texture_step;

	mov	eax, DWORD PTR _fout$[ebp]
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR [eax+16], dx

; 2094 : 		fout->max_extent = fin->max_extent;

	mov	eax, DWORD PTR _fout$[ebp]
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	dx, WORD PTR [ecx+18]
	mov	WORD PTR [eax+18], dx

; 2095 : 		fout->groupid = fin->groupid;

	mov	eax, DWORD PTR _fout$[ebp]
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR [eax+20], dx

; 2096 : 	}

	jmp	SHORT $LN2@Mod_LoadTe
$LN3@Mod_LoadTe:

; 2097 : 
; 2098 : 	loadmodel->texinfo = out = Mem_Calloc( loadmodel->mempool, bmod->numtexinfo * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTexInfo@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+52], 44
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+172], eax

; 2099 : 	loadmodel->numtexinfo = bmod->numtexinfo;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+168], edx

; 2100 : 	in = bmod->texinfo;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _in$[ebp], ecx

; 2101 : 
; 2102 : 	for( i = 0; i < bmod->numtexinfo; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadTe
$LN5@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _in$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR _out$[ebp], edx
$LN7@Mod_LoadTe:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jae	$LN6@Mod_LoadTe

; 2103 : 	{
; 2104 : 		for( j = 0; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadTe
$LN8@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 8
	jge	SHORT $LN9@Mod_LoadTe

; 2105 : 			out->vecs[0][j] = in->vecs[0][j];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _in$[ebp]
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN8@Mod_LoadTe
$LN9@Mod_LoadTe:

; 2106 : 
; 2107 : 		miptex = in->miptex;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _miptex$[ebp], ecx

; 2108 : 		if( miptex < 0 || miptex > loadmodel->numtextures )

	cmp	DWORD PTR _miptex$[ebp], 0
	jl	SHORT $LN12@Mod_LoadTe
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _miptex$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jle	SHORT $LN11@Mod_LoadTe
$LN12@Mod_LoadTe:

; 2109 : 			miptex = 0; // this is possible?

	mov	DWORD PTR _miptex$[ebp], 0
$LN11@Mod_LoadTe:

; 2110 : 		out->texture = loadmodel->textures[miptex];

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _miptex$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+36], ecx

; 2111 : 		out->flags = in->flags;

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2112 : 
; 2113 : 		// make sure what faceinfo is really exist
; 2114 : 		if( faceinfo != NULL && in->faceinfo != -1 && in->faceinfo < bmod->numfaceinfo )

	cmp	DWORD PTR _faceinfo$[ebp], 0
	je	SHORT $LN13@Mod_LoadTe
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+38]
	cmp	ecx, -1
	je	SHORT $LN13@Mod_LoadTe
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+38]
	mov	edx, DWORD PTR _bmod$[ebp]
	cmp	ecx, DWORD PTR [edx+92]
	jae	SHORT $LN13@Mod_LoadTe

; 2115 : 			out->faceinfo = &faceinfo[in->faceinfo];

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, WORD PTR [eax+38]
	imul	edx, ecx, 176
	add	edx, DWORD PTR _faceinfo$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+32], edx
$LN13@Mod_LoadTe:

; 2116 : 	}

	jmp	$LN5@Mod_LoadTe
$LN6@Mod_LoadTe:

; 2117 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadTexInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadTextures
_TEXT	SEGMENT
_texpath$1 = -224					; size = 4
_src$2 = -220						; size = 4
_srcSize$3 = -216					; size = 4
_size$4 = -212						; size = 4
_size$5 = -208						; size = 4
_texpath$6 = -204					; size = 4
_remaining$7 = -200					; size = 4
_next_dataofs$8 = -196					; size = 4
_size$9 = -192						; size = 4
_j$ = -188						; size = 4
_i$ = -184						; size = 4
_mt$ = -180						; size = 4
_texname$ = -176					; size = 64
_custom_palette$ = -112					; size = 4
_altmax$ = -108						; size = 4
_max$ = -104						; size = 4
_num$ = -100						; size = 4
_altanims$ = -96					; size = 40
_anims$ = -56						; size = 40
_tx2$ = -16						; size = 4
_tx$ = -12						; size = 4
_in$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadTextures PROC					; COMDAT

; 1788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1789 : 	dmiptexlump_t	*in;
; 1790 : 	texture_t		*tx, *tx2;
; 1791 : 	texture_t		*anims[10];
; 1792 : 	texture_t		*altanims[10];
; 1793 : 	int		num, max, altmax;
; 1794 : 	qboolean		custom_palette;
; 1795 : 	char		texname[64];
; 1796 : 	mip_t		*mt;
; 1797 : 	int 		i, j; 
; 1798 : 
; 1799 : 	// FarEast: Not sure of this at all
; 1800 : 	if (world.loading)

	cmp	DWORD PTR _world, 0
	je	SHORT $LN26@Mod_LoadTe

; 1801 : 	{
; 1802 : 		world.has_mirrors = false;

	mov	DWORD PTR _world+4, 0
$LN26@Mod_LoadTe:

; 1803 : 	}
; 1804 : 
; 1805 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN27@Mod_LoadTe

; 1806 : 	{
; 1807 : 		// release old sky layers first
; 1808 : 		GL_FreeTexture( tr.solidskyTexture );

	mov	eax, DWORD PTR _tr+20
	push	eax
	call	_GL_FreeTexture
	add	esp, 4

; 1809 : 		GL_FreeTexture( tr.alphaskyTexture );

	mov	eax, DWORD PTR _tr+24
	push	eax
	call	_GL_FreeTexture
	add	esp, 4

; 1810 : 		tr.solidskyTexture = 0;

	mov	DWORD PTR _tr+20, 0

; 1811 : 		tr.alphaskyTexture = 0;

	mov	DWORD PTR _tr+24, 0
$LN27@Mod_LoadTe:

; 1812 : 	}
; 1813 : 
; 1814 : 	if( !bmod->texdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+140], 0
	jne	SHORT $LN28@Mod_LoadTe

; 1815 : 	{
; 1816 : 		// no textures
; 1817 : 		loadmodel->textures = NULL;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+372], 0

; 1818 : 		return;

	jmp	$LN15@Mod_LoadTe
$LN28@Mod_LoadTe:

; 1819 : 	}
; 1820 : 
; 1821 : 	in = bmod->textures;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _in$[ebp], ecx

; 1822 : 	loadmodel->textures = (texture_t **)Mem_Calloc( loadmodel->mempool, in->nummiptex * sizeof( texture_t* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTextures@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+372], eax

; 1823 : 	loadmodel->numtextures = in->nummiptex;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+368], edx

; 1824 : 
; 1825 : 	for( i = 0; i < loadmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadTe
$LN2@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadTe:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	$LN3@Mod_LoadTe

; 1826 : 	{
; 1827 : 		if( in->dataofs[i] == -1 )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], -1
	jne	SHORT $LN29@Mod_LoadTe

; 1828 : 		{
; 1829 : 			// create default texture (some mods requires this)
; 1830 : 			tx = Mem_Calloc( loadmodel->mempool, sizeof( *tx ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTextures@@9@9
	add	eax, 42					; 0000002aH
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	68					; 00000044H
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$[ebp], eax

; 1831 : 			loadmodel->textures[i] = tx;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1832 : 
; 1833 : 			Q_strncpy( tx->name, "*default", sizeof( tx->name ));

	push	16					; 00000010H
	push	OFFSET ??_C@_08KPIGECMN@?$CKdefault@
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1834 : 			tx->gl_texturenum = tr.defaultTexture;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tr
	mov	DWORD PTR [eax+24], ecx

; 1835 : 			tx->width = tx->height = 16;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+20], 16			; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+16], 16			; 00000010H

; 1836 : 			continue; // missed

	jmp	$LN2@Mod_LoadTe
$LN29@Mod_LoadTe:

; 1837 : 		}
; 1838 : 
; 1839 : 		mt = (mip_t *)((byte *)in + in->dataofs[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _mt$[ebp], edx

; 1840 : 
; 1841 : 		if( !mt->name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN30@Mod_LoadTe

; 1842 : 			Q_snprintf( mt->name, sizeof( mt->name ), "miptex_%i", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_09PEJHDEOI@miptex_?$CFi@
	push	16					; 00000010H
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN30@Mod_LoadTe:

; 1843 : 		tx = Mem_Calloc( loadmodel->mempool, sizeof( *tx ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTextures@@9@9
	add	eax, 55					; 00000037H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	68					; 00000044H
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$[ebp], eax

; 1844 : 		loadmodel->textures[i] = tx;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1845 : 
; 1846 : 		// convert to lowercase
; 1847 : 		Q_strncpy( tx->name, mt->name, sizeof( tx->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1848 : 		Q_strnlwr( tx->name, tx->name, sizeof( tx->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	call	_Q_strnlwr
	add	esp, 12					; 0000000cH

; 1849 : 		custom_palette = false;

	mov	DWORD PTR _custom_palette$[ebp], 0

; 1850 : 
; 1851 : 		tx->width = mt->width;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1852 : 		tx->height = mt->height;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 1853 : 
; 1854 : 		if( mt->offsets[0] > 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	jbe	$LN34@Mod_LoadTe

; 1855 : 		{
; 1856 : 			int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	imul	eax, edx, 85
	shr	eax, 6
	add	eax, 40					; 00000028H
	mov	DWORD PTR _size$9[ebp], eax

; 1857 : 			int	next_dataofs, remaining;
; 1858 : 
; 1859 : 			// compute next dataofset to determine allocated miptex sapce
; 1860 : 			for( j = i + 1; j < loadmodel->numtextures; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@Mod_LoadTe
$LN5@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadTe:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN6@Mod_LoadTe

; 1861 : 			{
; 1862 : 				next_dataofs = in->dataofs[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _next_dataofs$8[ebp], edx

; 1863 : 				if( next_dataofs != -1 ) break;

	cmp	DWORD PTR _next_dataofs$8[ebp], -1
	je	SHORT $LN32@Mod_LoadTe
	jmp	SHORT $LN6@Mod_LoadTe
$LN32@Mod_LoadTe:

; 1864 : 			}

	jmp	SHORT $LN5@Mod_LoadTe
$LN6@Mod_LoadTe:

; 1865 : 
; 1866 : 			if( j == loadmodel->numtextures )

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jne	SHORT $LN33@Mod_LoadTe

; 1867 : 				next_dataofs = bmod->texdatasize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _next_dataofs$8[ebp], ecx
$LN33@Mod_LoadTe:

; 1868 : 
; 1869 : 			// NOTE: imagelib detect miptex version by size
; 1870 : 			// 770 additional bytes is indicated custom palette
; 1871 : 			remaining = next_dataofs - (in->dataofs[i] + size);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	add	edx, DWORD PTR _size$9[ebp]
	mov	eax, DWORD PTR _next_dataofs$8[ebp]
	sub	eax, edx
	mov	DWORD PTR _remaining$7[ebp], eax

; 1872 : 			if( remaining >= 770 ) custom_palette = true;

	cmp	DWORD PTR _remaining$7[ebp], 770	; 00000302H
	jl	SHORT $LN34@Mod_LoadTe
	mov	DWORD PTR _custom_palette$[ebp], 1
$LN34@Mod_LoadTe:

; 1873 : 		}
; 1874 : 
; 1875 : 		// check for multi-layered sky texture (quake1 specific)
; 1876 : 		if( bmod->isworld && !Q_strncmp( mt->name, "sky", 3 ) && (( mt->width / mt->height ) == 2 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN35@Mod_LoadTe
	push	3
	push	OFFSET ??_C@_03BNEOMJOP@sky@
	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@Mod_LoadTe
	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	eax, DWORD PTR [eax+16]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	cmp	eax, 2
	jne	SHORT $LN35@Mod_LoadTe

; 1877 : 		{	
; 1878 : 			R_InitSkyClouds( mt, tx, custom_palette ); // load quake sky

	mov	eax, DWORD PTR _custom_palette$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	call	_R_InitSkyClouds
	add	esp, 12					; 0000000cH

; 1879 : 
; 1880 : 			if( tr.solidskyTexture && tr.alphaskyTexture )

	cmp	DWORD PTR _tr+20, 0
	je	SHORT $LN36@Mod_LoadTe
	cmp	DWORD PTR _tr+24, 0
	je	SHORT $LN36@Mod_LoadTe

; 1881 : 				SetBits( world.flags, FWORLD_SKYSPHERE );

	mov	eax, DWORD PTR _world+8
	or	eax, 1
	mov	DWORD PTR _world+8, eax
$LN36@Mod_LoadTe:

; 1882 : 			continue;

	jmp	$LN2@Mod_LoadTe
$LN35@Mod_LoadTe:

; 1883 : 		}
; 1884 : 
; 1885 : 		// texture loading order:
; 1886 : 		// 1. from wad
; 1887 : 		// 2. internal from map
; 1888 : 
; 1889 : 		// trying wad texture (force while r_wadtextures is 1)
; 1890 : 		if(( r_wadtextures->value && bmod->wadlist.count > 0 ) || ( mt->offsets[0] <= 0 ))

	mov	eax, DWORD PTR _r_wadtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN39@Mod_LoadTe
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9372], 0
	jg	SHORT $LN38@Mod_LoadTe
$LN39@Mod_LoadTe:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	ja	$LN9@Mod_LoadTe
$LN38@Mod_LoadTe:

; 1891 : 		{
; 1892 : 			Q_snprintf( texname, sizeof( texname ), "%s.mip", mt->name );

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	push	OFFSET ??_C@_06KNCEHODH@?$CFs?4mip@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1893 : 
; 1894 : 			// check wads in reverse order
; 1895 : 			for( j = bmod->wadlist.count - 1; j >= 0; j-- )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9372]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN10@Mod_LoadTe
$LN8@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN9@Mod_LoadTe

; 1896 : 			{
; 1897 : 				char	*texpath = va( "%s.wad/%s", bmod->wadlist.wadnames[j], texname );

	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _bmod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	push	OFFSET ??_C@_09NEMDCCOI@?$CFs?4wad?1?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _texpath$6[ebp], eax

; 1898 : 
; 1899 : 				if( FS_FileExists( texpath, false ))

	push	0
	mov	eax, DWORD PTR _texpath$6[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@Mod_LoadTe

; 1900 : 				{
; 1901 : 					tx->gl_texturenum = GL_LoadTexture( texpath, NULL, 0, TF_ALLOW_EMBOSS );

	push	16					; 00000010H
	push	0
	push	0
	mov	eax, DWORD PTR _texpath$6[ebp]
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1902 : 					bmod->wadlist.wadusage[j]++; // this wad are really used

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8348]
	add	edx, 1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+eax*4+8348], edx

; 1903 : 					break;

	jmp	SHORT $LN9@Mod_LoadTe
$LN40@Mod_LoadTe:

; 1904 : 				}
; 1905 : 			}

	jmp	$LN8@Mod_LoadTe
$LN9@Mod_LoadTe:

; 1906 : 		}
; 1907 : 
; 1908 : 		// wad failed, so use internal texture (if present)
; 1909 : 		if( mt->offsets[0] > 0 && !tx->gl_texturenum )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	jbe	$LN41@Mod_LoadTe
	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN41@Mod_LoadTe

; 1910 : 		{
; 1911 : 			// NOTE: imagelib detect miptex version by size
; 1912 : 			// 770 additional bytes is indicated custom palette
; 1913 : 			int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	imul	eax, edx, 85
	shr	eax, 6
	add	eax, 40					; 00000028H
	mov	DWORD PTR _size$5[ebp], eax

; 1914 : 
; 1915 : 			if( custom_palette ) size += sizeof( short ) + 768;

	cmp	DWORD PTR _custom_palette$[ebp], 0
	je	SHORT $LN42@Mod_LoadTe
	mov	eax, DWORD PTR _size$5[ebp]
	add	eax, 770				; 00000302H
	mov	DWORD PTR _size$5[ebp], eax
$LN42@Mod_LoadTe:

; 1916 : 			Q_snprintf( texname, sizeof( texname ), "#%s:%s.mip", loadstat.name, mt->name );

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0L@DAOGIBEC@?$CD?$CFs?3?$CFs?4mip@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1917 : 			tx->gl_texturenum = GL_LoadTexture( texname, (byte *)mt, size, TF_ALLOW_EMBOSS );

	push	16					; 00000010H
	mov	eax, DWORD PTR _size$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN41@Mod_LoadTe:

; 1918 : 		}
; 1919 : 
; 1920 : 		// if texture is completely missed
; 1921 : 		if( !tx->gl_texturenum )

	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN43@Mod_LoadTe

; 1922 : 		{
; 1923 : 			if( host.type != HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	je	SHORT $LN44@Mod_LoadTe

; 1924 : 				Con_DPrintf( S_ERROR "unable to find %s.mip\n", mt->name );

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@CPEGMNDG@?$FO1Error?3?$FO7?5unable?5to?5find?5?$CFs?4mi@
	call	_Con_DPrintf
	add	esp, 8
$LN44@Mod_LoadTe:

; 1925 : 			tx->gl_texturenum = tr.defaultTexture;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _tr
	mov	DWORD PTR [eax+24], ecx
$LN43@Mod_LoadTe:

; 1926 : 		}
; 1927 : 
; 1928 : 		// check for luma texture
; 1929 : 		if( FBitSet( R_GetTexture( tx->gl_texturenum )->flags, TF_HAS_LUMA ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	edx, DWORD PTR [eax+284]
	and	edx, 8192				; 00002000H
	je	$LN50@Mod_LoadTe

; 1930 : 		{
; 1931 : 			Q_snprintf( texname, sizeof( texname ), "#%s:%s_luma.mip", loadstat.name, mt->name );

	mov	eax, DWORD PTR _mt$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0BA@DKDOIIAE@?$CD?$CFs?3?$CFs_luma?4mip@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1932 : 
; 1933 : 			if( mt->offsets[0] > 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mt$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	jbe	SHORT $LN46@Mod_LoadTe

; 1934 : 			{
; 1935 : 				// NOTE: imagelib detect miptex version by size
; 1936 : 				// 770 additional bytes is indicated custom palette
; 1937 : 				int	size = (int)sizeof( mip_t ) + ((mt->width * mt->height * 85)>>6);

	mov	eax, DWORD PTR _mt$[ebp]
	mov	ecx, DWORD PTR _mt$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+20]
	imul	eax, edx, 85
	shr	eax, 6
	add	eax, 40					; 00000028H
	mov	DWORD PTR _size$4[ebp], eax

; 1938 : 
; 1939 : 				if( custom_palette ) size += sizeof( short ) + 768;

	cmp	DWORD PTR _custom_palette$[ebp], 0
	je	SHORT $LN48@Mod_LoadTe
	mov	eax, DWORD PTR _size$4[ebp]
	add	eax, 770				; 00000302H
	mov	DWORD PTR _size$4[ebp], eax
$LN48@Mod_LoadTe:

; 1940 : 				tx->fb_texturenum = GL_LoadTexture( texname, (byte *)mt, size, TF_MAKELUMA );

	push	16384					; 00004000H
	mov	eax, DWORD PTR _size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	WORD PTR [ecx+52], ax

; 1941 : 			}

	jmp	$LN50@Mod_LoadTe
$LN46@Mod_LoadTe:

; 1942 : 			else
; 1943 : 			{
; 1944 : 				size_t srcSize = 0;

	mov	DWORD PTR _srcSize$3[ebp], 0

; 1945 : 				byte *src = NULL;

	mov	DWORD PTR _src$2[ebp], 0

; 1946 : 
; 1947 : 				// NOTE: we can't loading it from wad as normal because _luma texture doesn't exist
; 1948 : 				// and not be loaded. But original texture is already loaded and can't be modified
; 1949 : 				// So load original texture manually and convert it to luma
; 1950 : 
; 1951 : 				// check wads in reverse order
; 1952 : 				for( j = bmod->wadlist.count - 1; j >= 0; j-- )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9372]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN13@Mod_LoadTe
$LN11@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadTe:
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN12@Mod_LoadTe

; 1953 : 				{
; 1954 : 					char	*texpath = va( "%s.wad/%s.mip", bmod->wadlist.wadnames[j], tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _bmod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	push	OFFSET ??_C@_0O@JGOPFOPL@?$CFs?4wad?1?$CFs?4mip@
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _texpath$1[ebp], eax

; 1955 : 
; 1956 : 					if( FS_FileExists( texpath, false ))

	push	0
	mov	eax, DWORD PTR _texpath$1[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@Mod_LoadTe

; 1957 : 					{
; 1958 : 						src = FS_LoadFile( texpath, &srcSize, false );

	push	0
	lea	eax, DWORD PTR _srcSize$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _texpath$1[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _src$2[ebp], eax

; 1959 : 						bmod->wadlist.wadusage[j]++; // this wad are really used

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8348]
	add	edx, 1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+eax*4+8348], edx

; 1960 : 						break;

	jmp	SHORT $LN12@Mod_LoadTe
$LN49@Mod_LoadTe:

; 1961 : 					}
; 1962 : 				}

	jmp	$LN11@Mod_LoadTe
$LN12@Mod_LoadTe:

; 1963 : 
; 1964 : 				// okay, loading it from wad or hi-res version
; 1965 : 				tx->fb_texturenum = GL_LoadTexture( texname, src, srcSize, TF_MAKELUMA );

	push	16384					; 00004000H
	mov	eax, DWORD PTR _srcSize$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	WORD PTR [ecx+52], ax

; 1966 : 				if( src ) Mem_Free( src );

	cmp	DWORD PTR _src$2[ebp], 0
	je	SHORT $LN50@Mod_LoadTe
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadTextures@@9@9
	add	eax, 178				; 000000b2H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _src$2[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN50@Mod_LoadTe:

; 1967 : 			}
; 1968 : 		}
; 1969 : 	}

	jmp	$LN2@Mod_LoadTe
$LN3@Mod_LoadTe:

; 1970 : 
; 1971 : 	// sequence the animations and detail textures
; 1972 : 	for( i = 0; i < loadmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadTe
$LN14@Mod_LoadTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Mod_LoadTe:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	$LN15@Mod_LoadTe

; 1973 : 	{
; 1974 : 		tx = loadmodel->textures[i];

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 1975 : 
; 1976 : 		if( !tx || ( tx->name[0] != '-' && tx->name[0] != '+' ))

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN52@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN51@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN51@Mod_LoadTe
$LN52@Mod_LoadTe:

; 1977 : 			continue;

	jmp	SHORT $LN14@Mod_LoadTe
$LN51@Mod_LoadTe:

; 1978 : 
; 1979 : 		if( tx->anim_next )

	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN53@Mod_LoadTe

; 1980 : 			continue;	// already sequenced

	jmp	SHORT $LN14@Mod_LoadTe
$LN53@Mod_LoadTe:

; 1981 : 
; 1982 : 		// find the number of frames in the animation
; 1983 : 		memset( anims, 0, sizeof( anims ));

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _anims$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1984 : 		memset( altanims, 0, sizeof( altanims ));

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _altanims$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1985 : 
; 1986 : 		max = tx->name[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tx$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _max$[ebp], edx

; 1987 : 		altmax = 0;

	mov	DWORD PTR _altmax$[ebp], 0

; 1988 : 
; 1989 : 		if( max >= '0' && max <= '9' )

	cmp	DWORD PTR _max$[ebp], 48		; 00000030H
	jl	SHORT $LN54@Mod_LoadTe
	cmp	DWORD PTR _max$[ebp], 57		; 00000039H
	jg	SHORT $LN54@Mod_LoadTe

; 1990 : 		{
; 1991 : 			max -= '0';

	mov	eax, DWORD PTR _max$[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _max$[ebp], eax

; 1992 : 			altmax = 0;

	mov	DWORD PTR _altmax$[ebp], 0

; 1993 : 			anims[max] = tx;

	mov	eax, DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR _anims$[ebp+eax*4], ecx

; 1994 : 			max++;

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	DWORD PTR _max$[ebp], eax

; 1995 : 		}

	jmp	SHORT $LN57@Mod_LoadTe
$LN54@Mod_LoadTe:

; 1996 : 		else if( max >= 'a' && max <= 'j' )

	cmp	DWORD PTR _max$[ebp], 97		; 00000061H
	jl	SHORT $LN56@Mod_LoadTe
	cmp	DWORD PTR _max$[ebp], 106		; 0000006aH
	jg	SHORT $LN56@Mod_LoadTe

; 1997 : 		{
; 1998 : 			altmax = max - 'a';

	mov	eax, DWORD PTR _max$[ebp]
	sub	eax, 97					; 00000061H
	mov	DWORD PTR _altmax$[ebp], eax

; 1999 : 			max = 0;

	mov	DWORD PTR _max$[ebp], 0

; 2000 : 			altanims[altmax] = tx;

	mov	eax, DWORD PTR _altmax$[ebp]
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	DWORD PTR _altanims$[ebp+eax*4], ecx

; 2001 : 			altmax++;

	mov	eax, DWORD PTR _altmax$[ebp]
	add	eax, 1
	mov	DWORD PTR _altmax$[ebp], eax

; 2002 : 		}

	jmp	SHORT $LN57@Mod_LoadTe
$LN56@Mod_LoadTe:

; 2003 : 		else Con_Printf( S_ERROR "Mod_LoadTextures: bad animating texture %s\n", tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@GBOGMJNF@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5ba@
	call	_Con_Printf
	add	esp, 8
$LN57@Mod_LoadTe:

; 2004 : 
; 2005 : 		for( j = i + 1; j < loadmodel->numtextures; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN19@Mod_LoadTe
$LN17@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@Mod_LoadTe:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	$LN18@Mod_LoadTe

; 2006 : 		{
; 2007 : 			tx2 = loadmodel->textures[j];

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx2$[ebp], eax

; 2008 : 
; 2009 : 			if( !tx2 || ( tx2->name[0] != '-' && tx2->name[0] != '+' ))

	cmp	DWORD PTR _tx2$[ebp], 0
	je	SHORT $LN59@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN58@Mod_LoadTe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN58@Mod_LoadTe
$LN59@Mod_LoadTe:

; 2010 : 				continue;

	jmp	SHORT $LN17@Mod_LoadTe
$LN58@Mod_LoadTe:

; 2011 : 
; 2012 : 			if( Q_strcmp( tx2->name + 2, tx->name + 2 ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _tx$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _tx2$[ebp]
	add	ecx, 2
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN60@Mod_LoadTe

; 2013 : 				continue;

	jmp	$LN17@Mod_LoadTe
$LN60@Mod_LoadTe:

; 2014 : 
; 2015 : 			num = tx2->name[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tx2$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _num$[ebp], edx

; 2016 : 
; 2017 : 			if( num >= '0' && num <= '9' )

	cmp	DWORD PTR _num$[ebp], 48		; 00000030H
	jl	SHORT $LN61@Mod_LoadTe
	cmp	DWORD PTR _num$[ebp], 57		; 00000039H
	jg	SHORT $LN61@Mod_LoadTe

; 2018 : 			{
; 2019 : 				num -= '0';

	mov	eax, DWORD PTR _num$[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _num$[ebp], eax

; 2020 : 				anims[num] = tx2;

	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR _anims$[ebp+eax*4], ecx

; 2021 : 				if( num + 1 > max )

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _max$[ebp]
	jle	SHORT $LN63@Mod_LoadTe

; 2022 : 					max = num + 1;

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _max$[ebp], eax
$LN63@Mod_LoadTe:

; 2023 : 			}

	jmp	SHORT $LN65@Mod_LoadTe
$LN61@Mod_LoadTe:

; 2024 : 			else if( num >= 'a' && num <= 'j' )

	cmp	DWORD PTR _num$[ebp], 97		; 00000061H
	jl	SHORT $LN64@Mod_LoadTe
	cmp	DWORD PTR _num$[ebp], 106		; 0000006aH
	jg	SHORT $LN64@Mod_LoadTe

; 2025 : 			{
; 2026 : 				num = num - 'a';

	mov	eax, DWORD PTR _num$[ebp]
	sub	eax, 97					; 00000061H
	mov	DWORD PTR _num$[ebp], eax

; 2027 : 				altanims[num] = tx2;

	mov	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR _altanims$[ebp+eax*4], ecx

; 2028 : 				if( num + 1 > altmax )

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _altmax$[ebp]
	jle	SHORT $LN66@Mod_LoadTe

; 2029 : 					altmax = num + 1;

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _altmax$[ebp], eax
$LN66@Mod_LoadTe:

; 2030 : 			}

	jmp	SHORT $LN65@Mod_LoadTe
$LN64@Mod_LoadTe:

; 2031 : 			else Con_Printf( S_ERROR "Mod_LoadTextures: bad animating texture %s\n", tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@GBOGMJNF@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5ba@
	call	_Con_Printf
	add	esp, 8
$LN65@Mod_LoadTe:

; 2032 : 		}

	jmp	$LN17@Mod_LoadTe
$LN18@Mod_LoadTe:

; 2033 : 
; 2034 : 		// link them all together
; 2035 : 		for( j = 0; j < max; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@Mod_LoadTe
$LN20@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jge	$LN21@Mod_LoadTe

; 2036 : 		{
; 2037 : 			tx2 = anims[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _anims$[ebp+eax*4]
	mov	DWORD PTR _tx2$[ebp], ecx

; 2038 : 
; 2039 : 			if( !tx2 )

	cmp	DWORD PTR _tx2$[ebp], 0
	jne	SHORT $LN67@Mod_LoadTe

; 2040 : 			{
; 2041 : 				Con_Printf( S_ERROR "Mod_LoadTextures: missing frame %i of %s\n", j, tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@BJKAAKLM@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5mi@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2042 : 				tx->anim_total = 0;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+32], 0

; 2043 : 				break;

	jmp	SHORT $LN21@Mod_LoadTe
$LN67@Mod_LoadTe:

; 2044 : 			}
; 2045 : 
; 2046 : 			tx2->anim_total = max * ANIM_CYCLE;

	mov	eax, DWORD PTR _max$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2047 : 			tx2->anim_min = j * ANIM_CYCLE;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2048 : 			tx2->anim_max = (j + 1) * ANIM_CYCLE;

	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2049 : 			tx2->anim_next = anims[(j + 1) % max];

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _max$[ebp]
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	ecx, DWORD PTR _anims$[ebp+edx*4]
	mov	DWORD PTR [eax+44], ecx

; 2050 : 			if( altmax ) tx2->alternate_anims = altanims[0];

	cmp	DWORD PTR _altmax$[ebp], 0
	je	SHORT $LN68@Mod_LoadTe
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	eax, DWORD PTR _altanims$[ebp+ecx]
	mov	DWORD PTR [edx+48], eax
$LN68@Mod_LoadTe:

; 2051 : 		}

	jmp	$LN20@Mod_LoadTe
$LN21@Mod_LoadTe:

; 2052 : 
; 2053 : 		for( j = 0; j < altmax; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN25@Mod_LoadTe
$LN23@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN25@Mod_LoadTe:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _altmax$[ebp]
	jge	$LN24@Mod_LoadTe

; 2054 : 		{
; 2055 : 			tx2 = altanims[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _altanims$[ebp+eax*4]
	mov	DWORD PTR _tx2$[ebp], ecx

; 2056 : 
; 2057 : 			if( !tx2 )

	cmp	DWORD PTR _tx2$[ebp], 0
	jne	SHORT $LN69@Mod_LoadTe

; 2058 : 			{
; 2059 : 				Con_Printf( S_ERROR "Mod_LoadTextures: missing frame %i of %s\n", j, tx->name );

	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@BJKAAKLM@?$FO1Error?3?$FO7?5Mod_LoadTextures?3?5mi@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2060 : 				tx->anim_total = 0;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+32], 0

; 2061 : 				break;

	jmp	SHORT $LN24@Mod_LoadTe
$LN69@Mod_LoadTe:

; 2062 : 			}
; 2063 : 
; 2064 : 			tx2->anim_total = altmax * ANIM_CYCLE;

	mov	eax, DWORD PTR _altmax$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2065 : 			tx2->anim_min = j * ANIM_CYCLE;

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 2066 : 			tx2->anim_max = (j+1) * ANIM_CYCLE;

	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2067 : 			tx2->anim_next = altanims[(j + 1) % altmax];

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _altmax$[ebp]
	mov	eax, DWORD PTR _tx2$[ebp]
	mov	ecx, DWORD PTR _altanims$[ebp+edx*4]
	mov	DWORD PTR [eax+44], ecx

; 2068 : 			if( max ) tx2->alternate_anims = anims[0];

	cmp	DWORD PTR _max$[ebp], 0
	je	SHORT $LN70@Mod_LoadTe
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tx2$[ebp]
	mov	eax, DWORD PTR _anims$[ebp+ecx]
	mov	DWORD PTR [edx+48], eax
$LN70@Mod_LoadTe:

; 2069 : 		}

	jmp	$LN23@Mod_LoadTe
$LN24@Mod_LoadTe:

; 2070 : 	}

	jmp	$LN14@Mod_LoadTe
$LN15@Mod_LoadTe:

; 2071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadMarkSurfaces
_TEXT	SEGMENT
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadMarkSurfaces PROC				; COMDAT

; 1751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1752 : 	msurface_t	**out;
; 1753 : 	int		i;
; 1754 : 
; 1755 : 	loadmodel->marksurfaces = out = Mem_Malloc( loadmodel->mempool, bmod->nummarkfaces * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMarkSurfaces@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+204], eax

; 1756 : 	loadmodel->nummarksurfaces = bmod->nummarkfaces;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+200], edx

; 1757 : 
; 1758 : 	if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN8@Mod_LoadMa

; 1759 : 	{
; 1760 : 		dmarkface32_t	*in = bmod->markfaces32;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _in$2[ebp], ecx

; 1761 : 
; 1762 : 		for( i = 0; i < bmod->nummarkfaces; i++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadMa
$LN2@Mod_LoadMa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$2[ebp], ecx
$LN4@Mod_LoadMa:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jae	SHORT $LN3@Mod_LoadMa

; 1763 : 		{
; 1764 : 			if( *in < 0 || *in >= loadmodel->numsurfaces )

	mov	eax, DWORD PTR _in$2[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN11@Mod_LoadMa
	mov	eax, DWORD PTR _in$2[ebp]
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+176]
	jl	SHORT $LN10@Mod_LoadMa
$LN11@Mod_LoadMa:

; 1765 : 				Host_Error( "Mod_LoadMarkFaces: bad surface number in '%s'\n", loadmodel->name );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET ??_C@_0CP@FKACGMIN@Mod_LoadMarkFaces?3?5bad?5surface?5@
	call	_Host_Error
	add	esp, 8
$LN10@Mod_LoadMa:

; 1766 : 			out[i] = loadmodel->surfaces + *in;

	mov	eax, DWORD PTR _in$2[ebp]
	imul	ecx, DWORD PTR [eax], 92
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+180]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1767 : 		}

	jmp	SHORT $LN2@Mod_LoadMa
$LN3@Mod_LoadMa:

; 1768 : 	}

	jmp	SHORT $LN1@Mod_LoadMa
$LN8@Mod_LoadMa:

; 1769 : 	else
; 1770 : 	{
; 1771 : 		dmarkface_t	*in = bmod->markfaces;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR _in$1[ebp], ecx

; 1772 : 
; 1773 : 		for( i = 0; i < bmod->nummarkfaces; i++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadMa
$LN5@Mod_LoadMa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$1[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$1[ebp], ecx
$LN7@Mod_LoadMa:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jae	SHORT $LN1@Mod_LoadMa

; 1774 : 		{
; 1775 : 			if( *in < 0 || *in >= loadmodel->numsurfaces )

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jl	SHORT $LN13@Mod_LoadMa
	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _loadmodel
	cmp	ecx, DWORD PTR [edx+176]
	jl	SHORT $LN12@Mod_LoadMa
$LN13@Mod_LoadMa:

; 1776 : 				Host_Error( "Mod_LoadMarkFaces: bad surface number in '%s'\n", loadmodel->name );

	mov	eax, DWORD PTR _loadmodel
	push	eax
	push	OFFSET ??_C@_0CP@FKACGMIN@Mod_LoadMarkFaces?3?5bad?5surface?5@
	call	_Host_Error
	add	esp, 8
$LN12@Mod_LoadMa:

; 1777 : 			out[i] = loadmodel->surfaces + *in;

	mov	eax, DWORD PTR _in$1[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _loadmodel
	add	edx, DWORD PTR [eax+180]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1778 : 		}

	jmp	SHORT $LN5@Mod_LoadMa
$LN1@Mod_LoadMa:

; 1779 : 	}
; 1780 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadMarkSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadSurfEdges
_TEXT	SEGMENT
_bmod$ = 8						; size = 4
_Mod_LoadSurfEdges PROC					; COMDAT

; 1739 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1740 : 	loadmodel->surfedges = Mem_Malloc( loadmodel->mempool, bmod->numsurfedges * sizeof( dsurfedge_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSurfEdges@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+188], eax

; 1741 : 	memcpy( loadmodel->surfedges, bmod->surfedges, bmod->numsurfedges * sizeof( dsurfedge_t ));

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+188]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1742 : 	loadmodel->numsurfedges = bmod->numsurfedges;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+184], edx

; 1743 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSurfEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadEdges
_TEXT	SEGMENT
_in$1 = -16						; size = 4
_in$2 = -12						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadEdges PROC					; COMDAT

; 1704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1705 : 	medge_t	*out;
; 1706 : 	int	i;
; 1707 : 
; 1708 : 	loadmodel->edges = out = Mem_Malloc( loadmodel->mempool, bmod->numedges * sizeof( medge_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadEdges@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+156], eax

; 1709 : 	loadmodel->numedges = bmod->numedges;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+152], edx

; 1710 : 
; 1711 : 	if( bmod->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9380], 844124994		; 32505342H
	jne	SHORT $LN8@Mod_LoadEd

; 1712 : 	{
; 1713 : 		dedge32_t	*in = (dedge32_t *)bmod->edges32;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _in$2[ebp], ecx

; 1714 : 
; 1715 : 		for( i = 0; i < bmod->numedges; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadEd
$LN2@Mod_LoadEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$2[ebp]
	add	ecx, 8
	mov	DWORD PTR _in$2[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 8
	mov	DWORD PTR _out$[ebp], edx
$LN4@Mod_LoadEd:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	jae	SHORT $LN3@Mod_LoadEd

; 1716 : 		{
; 1717 : 			out->v[0] = in->v[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx

; 1718 : 			out->v[1] = in->v[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$2[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax

; 1719 : 		}

	jmp	SHORT $LN2@Mod_LoadEd
$LN3@Mod_LoadEd:

; 1720 : 	}

	jmp	SHORT $LN1@Mod_LoadEd
$LN8@Mod_LoadEd:

; 1721 : 	else
; 1722 : 	{
; 1723 : 		dedge_t	*in = (dedge_t *)bmod->edges;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _in$1[ebp], ecx

; 1724 : 
; 1725 : 		for( i = 0; i < bmod->numedges; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadEd
$LN5@Mod_LoadEd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$1[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$1[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 8
	mov	DWORD PTR _out$[ebp], edx
$LN7@Mod_LoadEd:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+76]
	jae	SHORT $LN1@Mod_LoadEd

; 1726 : 		{
; 1727 : 			out->v[0] = (word)in->v[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$1[ebp]
	mov	cx, WORD PTR [esi+ecx]
	mov	WORD PTR [edx+eax], cx

; 1728 : 			out->v[1] = (word)in->v[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$1[ebp]
	mov	ax, WORD PTR [esi+eax]
	mov	WORD PTR [edx+ecx], ax

; 1729 : 		}

	jmp	SHORT $LN5@Mod_LoadEd
$LN1@Mod_LoadEd:

; 1730 : 	}
; 1731 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadEdges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadVertexes
_TEXT	SEGMENT
tv165 = -80						; size = 4
tv66 = -80						; size = 4
_i$ = -12						; size = 4
_out$ = -8						; size = 4
_in$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadVertexes PROC					; COMDAT

; 1668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1669 : 	dvertex_t	*in;
; 1670 : 	mvertex_t	*out;
; 1671 : 	int	i;
; 1672 : 
; 1673 : 	in = bmod->vertexes;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _in$[ebp], ecx

; 1674 : 	out = loadmodel->vertexes = Mem_Malloc( loadmodel->mempool, bmod->numvertexes * sizeof( mvertex_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadVertexes@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+12], 12
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv66[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR [edx+148], eax
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _out$[ebp], ecx

; 1675 : 	loadmodel->numvertexes = bmod->numvertexes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+144], edx

; 1676 : 
; 1677 : 	if( bmod->isworld ) ClearBounds( world.mins, world.maxs );

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN8@Mod_LoadVe
	push	OFFSET _world+2608
	push	OFFSET _world+2596
	call	_ClearBounds
	add	esp, 8
$LN8@Mod_LoadVe:

; 1678 : 
; 1679 : 	for( i = 0; i < bmod->numvertexes; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadVe
$LN2@Mod_LoadVe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], edx
$LN4@Mod_LoadVe:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN3@Mod_LoadVe

; 1680 : 	{
; 1681 : 		if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN9@Mod_LoadVe

; 1682 : 			AddPointToBounds( in->point, world.mins, world.maxs );

	push	OFFSET _world+2608
	push	OFFSET _world+2596
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH
$LN9@Mod_LoadVe:

; 1683 : 		VectorCopy( in->point, out->position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1684 : 	}

	jmp	$LN2@Mod_LoadVe
$LN3@Mod_LoadVe:

; 1685 : 
; 1686 : 	if( !bmod->isworld ) return;

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN10@Mod_LoadVe
	jmp	$LN6@Mod_LoadVe
$LN10@Mod_LoadVe:

; 1687 : 
; 1688 : 	VectorSubtract( world.maxs, world.mins, world.size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2608]
	subss	xmm0, DWORD PTR _world[eax+2596]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _world[edx+2620], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _world[eax+2608]
	subss	xmm0, DWORD PTR _world[ecx+2596]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _world[edx+2620], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _world[eax+2608]
	subss	xmm0, DWORD PTR _world[ecx+2596]
	movss	DWORD PTR tv165[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _world[edx+2620], xmm0

; 1689 : 
; 1690 : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadVe
$LN5@Mod_LoadVe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_LoadVe:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@Mod_LoadVe

; 1691 : 	{
; 1692 : 		// spread the mins / maxs by a pixel
; 1693 : 		world.mins[i] -= 1.0f;

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _world[eax*4+2596]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _world[ecx*4+2596], xmm0

; 1694 : 		world.maxs[i] += 1.0f;

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _world[eax*4+2608]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _world[ecx*4+2608], xmm0

; 1695 : 	}

	jmp	SHORT $LN5@Mod_LoadVe
$LN6@Mod_LoadVe:

; 1696 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadVertexes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadPlanes
_TEXT	SEGMENT
tv221 = -88						; size = 8
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_out$ = -8						; size = 4
_in$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadPlanes PROC					; COMDAT

; 1634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1635 : 	dplane_t	*in;
; 1636 : 	mplane_t	*out;
; 1637 : 	int	i, j;
; 1638 : 
; 1639 : 	in = bmod->planes;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _in$[ebp], ecx

; 1640 : 	loadmodel->planes = out = Mem_Malloc( loadmodel->mempool, bmod->numplanes * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadPlanes@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	imul	edx, DWORD PTR [ecx+20], 20
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+132], eax

; 1641 : 	loadmodel->numplanes = bmod->numplanes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+128], edx

; 1642 : 
; 1643 : 	for( i = 0; i < bmod->numplanes; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadPl
$LN2@Mod_LoadPl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _in$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], edx
$LN4@Mod_LoadPl:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	$LN3@Mod_LoadPl

; 1644 : 	{
; 1645 : 		out->signbits = 0;

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+17], 0

; 1646 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadPl
$LN5@Mod_LoadPl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadPl:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@Mod_LoadPl

; 1647 : 		{
; 1648 : 			out->normal[j] = in->normal[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 1649 : 
; 1650 : 			if( out->normal[j] < 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jbe	SHORT $LN8@Mod_LoadPl

; 1651 : 				SetBits( out->signbits, BIT( j ));

	mov	eax, DWORD PTR _out$[ebp]
	movzx	edx, BYTE PTR [eax+17]
	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+17], dl
$LN8@Mod_LoadPl:

; 1652 : 		}

	jmp	SHORT $LN5@Mod_LoadPl
$LN6@Mod_LoadPl:

; 1653 : 
; 1654 : 		if( VectorLength( out->normal ) < 0.5f )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv221[ebp]
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	comisd	xmm0, QWORD PTR tv221[ebp]
	jbe	SHORT $LN9@Mod_LoadPl

; 1655 : 			Con_Printf( S_ERROR "bad normal for plane #%i\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@GAMEGDJP@?$FO1Error?3?$FO7?5bad?5normal?5for?5plane@
	call	_Con_Printf
	add	esp, 8
$LN9@Mod_LoadPl:

; 1656 : 
; 1657 : 		out->dist = in->dist;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 1658 : 		out->type = in->type;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+16], dl

; 1659 : 	}

	jmp	$LN2@Mod_LoadPl
$LN3@Mod_LoadPl:

; 1660 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadPlanes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadEntities
_TEXT	SEGMENT
$T1 = -4964						; size = 4
_num$2 = -4448						; size = 4
_pszWadFile$3 = -4444					; size = 4
_ft2$4 = -4440						; size = 4
_ft1$5 = -4436						; size = 4
_entpatchsize$6 = -4432					; size = 4
_entfilename$7 = -4428					; size = 64
_pfile$ = -4364						; size = 4
_keyname$ = -4360					; size = 256
_wadstring$ = -4104					; size = 2048
_token$ = -2056						; size = 2048
_entpatch$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadEntities PROC					; COMDAT

; 1519 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4964				; 00001364H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1520 : 	byte	*entpatch = NULL;

	mov	DWORD PTR _entpatch$[ebp], 0

; 1521 : 	char	token[MAX_TOKEN];
; 1522 : 	char	wadstring[2048];
; 1523 : 	string	keyname;
; 1524 : 	char	*pfile;
; 1525 : 
; 1526 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	$LN9@Mod_LoadEn

; 1527 : 	{
; 1528 : 		char	entfilename[MAX_QPATH];
; 1529 : 		long	entpatchsize;
; 1530 : 		size_t	ft1, ft2;
; 1531 : 
; 1532 : 		// world is check for entfile too
; 1533 : 		Q_strncpy( entfilename, loadmodel->name, sizeof( entfilename ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _loadmodel
	push	eax
	lea	ecx, DWORD PTR _entfilename$7[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1534 : 		COM_ReplaceExtension( entfilename, ".ent" );

	push	OFFSET ??_C@_04ECMOMEGO@?4ent@
	lea	eax, DWORD PTR _entfilename$7[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 1535 : 
; 1536 : 		// make sure what entity patch is never than bsp
; 1537 : 		ft1 = FS_FileTime( loadmodel->name, false );

	push	0
	mov	eax, DWORD PTR _loadmodel
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft1$5[ebp], eax

; 1538 : 		ft2 = FS_FileTime( entfilename, true );

	push	1
	lea	eax, DWORD PTR _entfilename$7[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft2$4[ebp], eax

; 1539 : 
; 1540 : 		if( ft2 != -1 )

	cmp	DWORD PTR _ft2$4[ebp], -1
	je	SHORT $LN9@Mod_LoadEn

; 1541 : 		{
; 1542 : 			if( ft1 > ft2 )

	mov	eax, DWORD PTR _ft1$5[ebp]
	cmp	eax, DWORD PTR _ft2$4[ebp]
	jbe	SHORT $LN11@Mod_LoadEn

; 1543 : 			{
; 1544 : 				Con_Printf( S_WARN "Entity patch is older than bsp. Ignored.\n" );			

	push	OFFSET ??_C@_0DH@NKJPPPMJ@?$FO3Warning?3?$FO7?5Entity?5patch?5is?5ol@
	call	_Con_Printf
	add	esp, 4

; 1545 : 			}

	jmp	SHORT $LN9@Mod_LoadEn
$LN11@Mod_LoadEn:

; 1546 : 			else if(( entpatch = FS_LoadFile( entfilename, &entpatchsize, true )) != NULL )

	push	1
	lea	eax, DWORD PTR _entpatchsize$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _entfilename$7[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _entpatch$[ebp], eax
	cmp	DWORD PTR _entpatch$[ebp], 0
	je	SHORT $LN9@Mod_LoadEn

; 1547 : 			{
; 1548 : 				Con_Printf( "^2Read entity patch:^7 %s\n", entfilename );

	lea	eax, DWORD PTR _entfilename$7[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@ICFKCIBG@?$FO2Read?5entity?5patch?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1549 : 				bmod->entdatasize = entpatchsize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _entpatchsize$6[ebp]
	mov	DWORD PTR [eax+132], ecx

; 1550 : 				bmod->entdata = entpatch;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _entpatch$[ebp]
	mov	DWORD PTR [eax+128], ecx
$LN9@Mod_LoadEn:

; 1551 : 			}
; 1552 : 		}
; 1553 : 	}
; 1554 : 
; 1555 : 	// make sure what we really has terminator
; 1556 : 	loadmodel->entities = Mem_Calloc( loadmodel->mempool, bmod->entdatasize + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadEntities@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+384], eax

; 1557 : 	memcpy( loadmodel->entities, bmod->entdata, bmod->entdatasize ); // moving to private model pool

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+384]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1558 : 	if( entpatch ) Mem_Free( entpatch ); // release entpatch if present

	cmp	DWORD PTR _entpatch$[ebp], 0
	je	SHORT $LN14@Mod_LoadEn
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadEntities@@9@9
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _entpatch$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@Mod_LoadEn:

; 1559 : 	if( !bmod->isworld ) return;

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	jne	SHORT $LN15@Mod_LoadEn
	jmp	$LN33@Mod_LoadEn
$LN15@Mod_LoadEn:

; 1560 : 
; 1561 : 	pfile = (char *)loadmodel->entities;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _pfile$[ebp], ecx

; 1562 : 	world.generator[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _world[ecx+2316], 0

; 1563 : 	world.compiler[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _world[ecx+2060], 0

; 1564 : 	world.message[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _world[ecx+12], 0

; 1565 : 	bmod->wadlist.count = 0;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [eax+9372], 0
$LN2@Mod_LoadEn:

; 1566 : 
; 1567 : 	// parse all the wads for loading textures in right ordering
; 1568 : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN33@Mod_LoadEn

; 1569 : 	{
; 1570 : 		if( token[0] != '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN4@Mod_LoadEn

; 1571 : 			Host_Error( "Mod_LoadEntities: found %s when expecting {\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@FABNGMMO@Mod_LoadEntities?3?5found?5?$CFs?5when@
	call	_Host_Error
	add	esp, 8
$LN4@Mod_LoadEn:

; 1572 : 
; 1573 : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@Mod_LoadEn

; 1574 : 		{
; 1575 : 			// parse key
; 1576 : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN17@Mod_LoadEn

; 1577 : 				Host_Error( "Mod_LoadEntities: EOF without closing brace\n" );

	push	OFFSET ??_C@_0CN@GOGHHEMD@Mod_LoadEntities?3?5EOF?5without?5c@
	call	_Host_Error
	add	esp, 4
$LN17@Mod_LoadEn:

; 1578 : 			if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN18@Mod_LoadEn
	jmp	$LN5@Mod_LoadEn
$LN18@Mod_LoadEn:

; 1579 : 
; 1580 : 			Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1581 : 
; 1582 : 			// parse value	
; 1583 : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL ) 

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN19@Mod_LoadEn

; 1584 : 				Host_Error( "Mod_LoadEntities: EOF without closing brace\n" );

	push	OFFSET ??_C@_0CN@GOGHHEMD@Mod_LoadEntities?3?5EOF?5without?5c@
	call	_Host_Error
	add	esp, 4
$LN19@Mod_LoadEn:

; 1585 : 
; 1586 : 			if( token[0] == '}' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN20@Mod_LoadEn

; 1587 : 				Host_Error( "Mod_LoadEntities: closing brace without data\n" );

	push	OFFSET ??_C@_0CO@ODLIHCCC@Mod_LoadEntities?3?5closing?5brace@
	call	_Host_Error
	add	esp, 4
$LN20@Mod_LoadEn:

; 1588 : 
; 1589 : 			if( !Q_stricmp( keyname, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03GANHLHHC@wad@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN21@Mod_LoadEn

; 1590 : 			{
; 1591 : 				char	*pszWadFile;
; 1592 : 
; 1593 : 				Q_strncpy( wadstring, token, MAX_TOKEN - 2 );

	push	2046					; 000007feH
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadstring$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1594 : 				wadstring[MAX_TOKEN - 2] = 0;

	mov	eax, 1
	imul	ecx, eax, 2046
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN34@Mod_LoadEn
	jmp	SHORT $LN35@Mod_LoadEn
$LN34@Mod_LoadEn:
	call	___report_rangecheckfailure
$LN35@Mod_LoadEn:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _wadstring$[ebp+edx], 0

; 1595 : 
; 1596 : 				if( !Q_strchr( wadstring, ';' ))

	push	59					; 0000003bH
	lea	eax, DWORD PTR _wadstring$[ebp]
	push	eax
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN23@Mod_LoadEn

; 1597 : 					Q_strcat( wadstring, ";" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	lea	eax, DWORD PTR _wadstring$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN23@Mod_LoadEn:

; 1598 : 
; 1599 : 				// parse wad pathes
; 1600 : 				for( pszWadFile = strtok( wadstring, ";" ); pszWadFile != NULL; pszWadFile = strtok( NULL, ";" ))

	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	lea	eax, DWORD PTR _wadstring$[ebp]
	push	eax
	call	DWORD PTR __imp__strtok
	add	esp, 8
	mov	DWORD PTR _pszWadFile$3[ebp], eax
	jmp	SHORT $LN8@Mod_LoadEn
$LN6@Mod_LoadEn:
	push	OFFSET ??_C@_01ICJEACDI@?$DL@
	push	0
	call	DWORD PTR __imp__strtok
	add	esp, 8
	mov	DWORD PTR _pszWadFile$3[ebp], eax
$LN8@Mod_LoadEn:
	cmp	DWORD PTR _pszWadFile$3[ebp], 0
	je	$LN7@Mod_LoadEn

; 1601 : 				{
; 1602 : 					COM_FixSlashes( pszWadFile );

	mov	eax, DWORD PTR _pszWadFile$3[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1603 : 					COM_FileBase( pszWadFile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszWadFile$3[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1604 : 
; 1605 : 					// make sure what wad is really exist
; 1606 : 					if( FS_FileExists( va( "%s.wad", token ), false ))

	push	0
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_06LCDNEPCB@?$CFs?4wad@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@Mod_LoadEn

; 1607 : 					{
; 1608 : 						int num = bmod->wadlist.count++;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+9372]
	mov	DWORD PTR _num$2[ebp], ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+9372]
	add	eax, 1
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+9372], eax

; 1609 : 						Q_strncpy( bmod->wadlist.wadnames[num], token, sizeof( bmod->wadlist.wadnames[0] ));

	push	32					; 00000020H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$2[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _bmod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+156]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1610 : 						bmod->wadlist.wadusage[num] = 0;

	mov	eax, DWORD PTR _num$2[ebp]
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+eax*4+8348], 0
$LN24@Mod_LoadEn:

; 1611 : 					}
; 1612 : 
; 1613 : 					if( bmod->wadlist.count >= MAX_MAP_WADS )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9372], 256		; 00000100H
	jl	SHORT $LN25@Mod_LoadEn

; 1614 : 						break; // too many wads...

	jmp	SHORT $LN7@Mod_LoadEn
$LN25@Mod_LoadEn:

; 1615 : 				}

	jmp	$LN6@Mod_LoadEn
$LN7@Mod_LoadEn:

; 1616 : 			}

	jmp	$LN22@Mod_LoadEn
$LN21@Mod_LoadEn:

; 1617 : 			else if( !Q_stricmp( keyname, "message" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07ONPBMBOP@message@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN26@Mod_LoadEn

; 1618 : 				Q_strncpy( world.message, token, sizeof( world.message ));

	push	2048					; 00000800H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET _world+12
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN22@Mod_LoadEn
$LN26@Mod_LoadEn:

; 1619 : 			else if( !Q_stricmp( keyname, "compiler" ) || !Q_stricmp( keyname, "_compiler" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08CCFHILPL@compiler@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN30@Mod_LoadEn
	push	99999					; 0001869fH
	push	OFFSET ??_C@_09GPMLCKOG@_compiler@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@Mod_LoadEn
$LN30@Mod_LoadEn:

; 1620 : 				Q_strncpy( world.compiler, token, sizeof( world.compiler ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET _world+2060
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@Mod_LoadEn
$LN28@Mod_LoadEn:

; 1621 : 			else if( !Q_stricmp( keyname, "generator" ) || !Q_stricmp( keyname, "_generator" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09HNDCMPDF@generator@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN32@Mod_LoadEn
	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@BOHJDPEN@_generator@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@Mod_LoadEn
$LN32@Mod_LoadEn:

; 1622 : 				Q_strncpy( world.generator, token, sizeof( world.generator ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET _world+2316
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN22@Mod_LoadEn:

; 1623 : 		}

	jmp	$LN4@Mod_LoadEn
$LN5@Mod_LoadEn:

; 1624 : 		return;	// all done

	jmp	SHORT $LN33@Mod_LoadEn

; 1625 : 	}

	jmp	$LN2@Mod_LoadEn
$LN33@Mod_LoadEn:

; 1626 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadSubmodels
_TEXT	SEGMENT
tv173 = -88						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_oldmaxfaces$ = -12					; size = 4
_out$ = -8						; size = 4
_in$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadSubmodels PROC					; COMDAT

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1462 : 	dmodel_t	*in, *out;
; 1463 : 	int	oldmaxfaces;
; 1464 : 	int	i, j;
; 1465 : 
; 1466 : 	// allocate extradata for each dmodel_t
; 1467 : 	out = Mem_Malloc( loadmodel->mempool, bmod->numsubmodels * sizeof( *out ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSubmodels@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 6
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1468 : 
; 1469 : 	loadmodel->numsubmodels = bmod->numsubmodels;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+120], edx

; 1470 : 	loadmodel->submodels = out;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+124], ecx

; 1471 : 	in = bmod->submodels;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _in$[ebp], ecx

; 1472 : 
; 1473 : 	if( bmod->isworld )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN11@Mod_LoadSu

; 1474 : 		world.max_surfaces = 0;

	mov	DWORD PTR _world+2576, 0
$LN11@Mod_LoadSu:

; 1475 : 	oldmaxfaces = world.max_surfaces;

	mov	eax, DWORD PTR _world+2576
	mov	DWORD PTR _oldmaxfaces$[ebp], eax

; 1476 : 
; 1477 : 	for( i = 0; i < bmod->numsubmodels; i++, in++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadSu
$LN2@Mod_LoadSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR _in$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR _out$[ebp], edx
$LN4@Mod_LoadSu:
	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	$LN3@Mod_LoadSu

; 1478 : 	{
; 1479 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadSu
$LN5@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@Mod_LoadSu

; 1480 : 		{
; 1481 : 			// reset empty bounds to prevent error
; 1482 : 			if( in->mins[j] == 999999.0f )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	ucomiss	xmm0, DWORD PTR __real@497423f0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@Mod_LoadSu

; 1483 : 				in->mins[j] = 0.0f;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN12@Mod_LoadSu:

; 1484 : 			if( in->maxs[j] == -999999.0f)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+12]
	ucomiss	xmm0, DWORD PTR __real@c97423f0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Mod_LoadSu

; 1485 : 				in->maxs[j] = 0.0f; 

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+12], xmm0
$LN13@Mod_LoadSu:

; 1486 : 
; 1487 : 			// spread the mins / maxs by a unit
; 1488 : 			out->mins[j] = in->mins[j] - 1.0f;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 1489 : 			out->maxs[j] = in->maxs[j] + 1.0f;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+12]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx*4+12], xmm0

; 1490 : 			out->origin[j] = in->origin[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+24]
	mov	DWORD PTR [ecx+eax*4+24], edx

; 1491 : 		}

	jmp	$LN5@Mod_LoadSu
$LN6@Mod_LoadSu:

; 1492 : 
; 1493 : 		for( j = 0; j < MAX_MAP_HULLS; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadSu
$LN8@Mod_LoadSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_LoadSu:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Mod_LoadSu

; 1494 : 			out->headnode[j] = in->headnode[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+36]
	mov	DWORD PTR [ecx+eax*4+36], edx
	jmp	SHORT $LN8@Mod_LoadSu
$LN9@Mod_LoadSu:

; 1495 : 
; 1496 : 		out->visleafs = in->visleafs;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx

; 1497 : 		out->firstface = in->firstface;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 1498 : 		out->numfaces = in->numfaces;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx

; 1499 : 
; 1500 : 		if( i == 0 && bmod->isworld )

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN14@Mod_LoadSu
	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+9384], 0
	je	SHORT $LN14@Mod_LoadSu

; 1501 : 			continue; // skip the world to save mem

	jmp	$LN2@Mod_LoadSu
$LN14@Mod_LoadSu:

; 1502 : 		oldmaxfaces = Q_max( oldmaxfaces, out->numfaces ); 

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _oldmaxfaces$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jle	SHORT $LN17@Mod_LoadSu
	mov	edx, DWORD PTR _oldmaxfaces$[ebp]
	mov	DWORD PTR tv173[ebp], edx
	jmp	SHORT $LN18@Mod_LoadSu
$LN17@Mod_LoadSu:
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR tv173[ebp], ecx
$LN18@Mod_LoadSu:
	mov	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR _oldmaxfaces$[ebp], edx

; 1503 : 	}

	jmp	$LN2@Mod_LoadSu
$LN3@Mod_LoadSu:

; 1504 : 
; 1505 : 	// these array used to sort translucent faces in bmodels
; 1506 : 	if( oldmaxfaces > world.max_surfaces )

	mov	eax, DWORD PTR _oldmaxfaces$[ebp]
	cmp	eax, DWORD PTR _world+2576
	jle	SHORT $LN15@Mod_LoadSu

; 1507 : 	{
; 1508 : 		world.draw_surfaces = (sortedface_t *)Z_Realloc( world.draw_surfaces, oldmaxfaces * sizeof( sortedface_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSubmodels@@9@9
	add	eax, 47					; 0000002fH
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _oldmaxfaces$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _world+2572
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _world+2572, eax

; 1509 : 		world.max_surfaces = oldmaxfaces;

	mov	eax, DWORD PTR _oldmaxfaces$[ebp]
	mov	DWORD PTR _world+2576, eax
$LN15@Mod_LoadSu:

; 1510 : 	}
; 1511 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSubmodels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_SetupSubmodels
_TEXT	SEGMENT
_name$1 = -44						; size = 8
_surf$2 = -36						; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_bm$ = -24						; size = 4
_mod$ = -20						; size = 4
_ents$ = -16						; size = 4
_mempool$ = -12						; size = 4
_colored$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_SetupSubmodels PROC				; COMDAT

; 1356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1357 : 	qboolean	colored = false;

	mov	DWORD PTR _colored$[ebp], 0

; 1358 : 	byte	*mempool;
; 1359 : 	char	*ents;
; 1360 : 	model_t	*mod;
; 1361 : 	dmodel_t 	*bm;
; 1362 : 	int	i, j;
; 1363 : 
; 1364 : 	ents = loadmodel->entities;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR _ents$[ebp], ecx

; 1365 : 	mempool = loadmodel->mempool;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _mempool$[ebp], ecx

; 1366 : 	if( FBitSet( loadmodel->flags, MODEL_COLORED_LIGHTING ))

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 16					; 00000010H
	je	SHORT $LN11@Mod_SetupS

; 1367 : 		colored = true;

	mov	DWORD PTR _colored$[ebp], 1
$LN11@Mod_SetupS:

; 1368 : 	mod = loadmodel;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], eax

; 1369 : 
; 1370 : 	loadmodel->numframes = 2;	// regular and alternate animation

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+72], 2

; 1371 : 
; 1372 : 	// set up the submodels
; 1373 : 	for( i = 0; i < mod->numsubmodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_SetupS
$LN2@Mod_SetupS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_SetupS:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+120]
	jge	$LN3@Mod_SetupS

; 1374 : 	{
; 1375 : 		bm = &mod->submodels[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR [ecx+124]
	mov	DWORD PTR _bm$[ebp], eax

; 1376 : 
; 1377 : 		// hull 0 is just shared across all bmodels
; 1378 : 		mod->hulls[0].firstclipnode = bm->headnode[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [edx+eax+216], ecx

; 1379 : 		mod->hulls[0].lastclipnode = bm->headnode[0]; // need to be real count

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [edx+eax+220], ecx

; 1380 : 
; 1381 : 		// counting a real number of clipnodes per each submodel
; 1382 : 		CountClipNodes_r( mod->hulls[0].clipnodes, &mod->hulls[0], bm->headnode[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [edx+ecx+36]
	push	eax
	mov	ecx, 40					; 00000028H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mod$[ebp]
	lea	ecx, DWORD PTR [eax+edx+208]
	push	ecx
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+eax+208]
	push	edx
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH

; 1383 : 
; 1384 : 		// but hulls1-3 is build individually for a each given submodel
; 1385 : 		for( j = 1; j < MAX_MAP_HULLS; j++ )

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN7@Mod_SetupS
$LN5@Mod_SetupS:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_SetupS:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_SetupS

; 1386 : 			Mod_SetupHull( bmod, mod, mempool, bm->headnode[j], j );

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+36]
	push	eax
	mov	ecx, DWORD PTR _mempool$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	mov	eax, DWORD PTR _bmod$[ebp]
	push	eax
	call	_Mod_SetupHull
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@Mod_SetupS
$LN6@Mod_SetupS:

; 1387 : 
; 1388 : 		mod->firstmodelsurface = bm->firstface;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+112], edx

; 1389 : 		mod->nummodelsurfaces = bm->numfaces;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+116], edx

; 1390 : 
; 1391 : 		VectorCopy( bm->mins, mod->mins );		

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+84], eax

; 1392 : 		VectorCopy( bm->maxs, mod->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [edx+eax+96], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [esi+edx+12]
	mov	DWORD PTR [ecx+eax+96], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _bm$[ebp]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [edx+ecx+96], eax

; 1393 : 
; 1394 : 		mod->radius = RadiusFromBounds( mod->mins, mod->maxs );

	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _mod$[ebp]
	fstp	DWORD PTR [edx+108]

; 1395 : 		mod->numleafs = bm->visleafs;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _bm$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+136], edx

; 1396 : 		mod->flags = 0;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+80], 0

; 1397 : 
; 1398 : 		// this bit will be shared between all the submodels include worldmodel
; 1399 : 		if( colored ) SetBits( mod->flags, MODEL_COLORED_LIGHTING );

	cmp	DWORD PTR _colored$[ebp], 0
	je	SHORT $LN12@Mod_SetupS
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN12@Mod_SetupS:

; 1400 : 
; 1401 : 		if( i != 0 )

	cmp	DWORD PTR _i$[ebp], 0
	je	$LN16@Mod_SetupS

; 1402 : 		{
; 1403 : 			Mod_FindModelOrigin( ents, va( "*%i", i ), bm->origin );

	mov	eax, DWORD PTR _bm$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET ??_C@_03JLINDLFM@?$CK?$CFi@
	call	_va
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _ents$[ebp]
	push	edx
	call	_Mod_FindModelOrigin
	add	esp, 12					; 0000000cH

; 1404 : 
; 1405 : 			// mark models that have origin brushes
; 1406 : 			if( !VectorIsNull( bm->origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@Mod_SetupS
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@Mod_SetupS
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bm$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+24]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@Mod_SetupS
$LN15@Mod_SetupS:

; 1407 : 				SetBits( mod->flags, MODEL_HAS_ORIGIN );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 2
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN14@Mod_SetupS:

; 1408 : #ifdef HACKS_RELATED_HLMODS
; 1409 : 			// c2a1 doesn't have origin brush it's just placed at center of the level
; 1410 : 			if( !Q_stricmp( loadmodel->name, "maps/c2a1.bsp" ) && ( i == 11 ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0O@ONGNOMOA@maps?1c2a1?4bsp@
	mov	eax, DWORD PTR _loadmodel
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_SetupS
	cmp	DWORD PTR _i$[ebp], 11			; 0000000bH
	jne	SHORT $LN16@Mod_SetupS

; 1411 : 				SetBits( mod->flags, MODEL_HAS_ORIGIN );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 2
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN16@Mod_SetupS:

; 1412 : #endif
; 1413 : 		}
; 1414 : 
; 1415 : 		// sets the model flags
; 1416 : 		for( j = 0; i != 0 && j < mod->nummodelsurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_SetupS
$LN8@Mod_SetupS:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_SetupS:
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN9@Mod_SetupS
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $LN9@Mod_SetupS

; 1417 : 		{
; 1418 : 			msurface_t *surf = mod->surfaces + mod->firstmodelsurface + j;

	mov	eax, DWORD PTR _mod$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, ecx
	imul	ecx, DWORD PTR _j$[ebp], 92
	add	eax, ecx
	mov	DWORD PTR _surf$2[ebp], eax

; 1419 : 
; 1420 : 			if( FBitSet( surf->flags, SURF_CONVEYOR ))

	mov	eax, DWORD PTR _surf$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	je	SHORT $LN17@Mod_SetupS

; 1421 : 				SetBits( mod->flags, MODEL_CONVEYOR );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN17@Mod_SetupS:

; 1422 : 
; 1423 : 			if( FBitSet( surf->flags, SURF_TRANSPARENT ))

	mov	eax, DWORD PTR _surf$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN18@Mod_SetupS

; 1424 : 				SetBits( mod->flags, MODEL_TRANSPARENT );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 8
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN18@Mod_SetupS:

; 1425 : 
; 1426 : 			if( FBitSet( surf->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _surf$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN19@Mod_SetupS

; 1427 : 				SetBits( mod->flags, MODEL_LIQUID );

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 4
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN19@Mod_SetupS:

; 1428 : 		}

	jmp	$LN8@Mod_SetupS
$LN9@Mod_SetupS:

; 1429 : 
; 1430 : 		if( i < mod->numsubmodels - 1 )

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN20@Mod_SetupS

; 1431 : 		{
; 1432 : 			char	name[8];
; 1433 : 
; 1434 : 			// duplicate the basic information
; 1435 : 			Q_snprintf( name, sizeof( name ), "*%i", i + 1 );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_03JLINDLFM@?$CK?$CFi@
	push	8
	lea	ecx, DWORD PTR _name$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1436 : 			loadmodel = Mod_FindName( name, true );

	push	1
	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _loadmodel, eax

; 1437 : 			*loadmodel = *mod;

	mov	ecx, 98					; 00000062H
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edi, DWORD PTR _loadmodel
	rep movsd

; 1438 : 			Q_strncpy( loadmodel->name, name, sizeof( loadmodel->name ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _name$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1439 : 			loadmodel->mempool = NULL;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+76], 0

; 1440 : 			mod = loadmodel;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR _mod$[ebp], eax
$LN20@Mod_SetupS:

; 1441 : 		}
; 1442 : 	}

	jmp	$LN2@Mod_SetupS
$LN3@Mod_SetupS:

; 1443 : 
; 1444 : 	if( bmod->clipnodes_out != NULL )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN21@Mod_SetupS

; 1445 : 		Mem_Free( bmod->clipnodes_out );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_SetupSubmodels@@9@9
	add	eax, 89					; 00000059H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN21@Mod_SetupS:

; 1446 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetupSubmodels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadDeluxemap
_TEXT	SEGMENT
tv92 = -212						; size = 4
_in$ = -144						; size = 4
_iCompare$ = -140					; size = 4
_path$ = -136						; size = 64
_deluxdatasize$ = -72					; size = 4
_modelname$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadDeluxemap PROC					; COMDAT

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1302 : 	char	modelname[64];
; 1303 : 	size_t	deluxdatasize;
; 1304 : 	char	path[64];
; 1305 : 	int	iCompare;
; 1306 : 	byte	*in;
; 1307 : 
; 1308 : 	if( !FBitSet( host.features, ENGINE_LOAD_DELUXEDATA ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 4
	jne	SHORT $LN2@Mod_LoadDe

; 1309 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN2@Mod_LoadDe:

; 1310 : 
; 1311 : 	COM_FileBase( loadmodel->name, modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1312 : 	Q_snprintf( path, sizeof( path ), "maps/%s.dlit", modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@PEBABFIJ@maps?1?$CFs?4dlit@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1313 : 
; 1314 : 	// make sure what deluxemap is actual
; 1315 : 	if( !COM_CompareFileTime( path, loadmodel->name, &iCompare ))

	lea	eax, DWORD PTR _iCompare$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_COM_CompareFileTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Mod_LoadDe

; 1316 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN3@Mod_LoadDe:

; 1317 : 
; 1318 : 	if( iCompare < 0 ) // this may happens if level-designer used -onlyents key for hlcsg

	cmp	DWORD PTR _iCompare$[ebp], 0
	jge	SHORT $LN4@Mod_LoadDe

; 1319 : 		Con_Printf( S_WARN "%s probably is out of date\n", path );

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@DFGMPNGN@?$FO3Warning?3?$FO7?5?$CFs?5probably?5is?5out@
	call	_Con_Printf
	add	esp, 8
$LN4@Mod_LoadDe:

; 1320 : 
; 1321 : 	in = FS_LoadFile( path, &deluxdatasize, false );

	push	0
	lea	eax, DWORD PTR _deluxdatasize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], eax

; 1322 : 
; 1323 : 	Assert( in != NULL );

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN9@Mod_LoadDe
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN10@Mod_LoadDe
$LN9@Mod_LoadDe:
	mov	DWORD PTR tv92[ebp], 0
$LN10@Mod_LoadDe:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@DHKGJOLH@in?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv92[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1324 : 
; 1325 : 	if( *(uint *)in != IDDELUXEMAPHEADER || *((uint *)in + 1) != DELUXEMAP_VERSION )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 1414089809		; 54494c51H
	jne	SHORT $LN6@Mod_LoadDe
	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN5@Mod_LoadDe
$LN6@Mod_LoadDe:

; 1326 : 	{
; 1327 : 		Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1328 : 		return;

	jmp	$LN1@Mod_LoadDe
$LN5@Mod_LoadDe:

; 1329 : 	}
; 1330 : 
; 1331 : 	// skip header bytes
; 1332 : 	deluxdatasize -= 8;

	mov	eax, DWORD PTR _deluxdatasize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _deluxdatasize$[ebp], eax

; 1333 : 
; 1334 : 	if( deluxdatasize != bmod->lightdatasize )

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _deluxdatasize$[ebp]
	cmp	ecx, DWORD PTR [eax+108]
	je	SHORT $LN7@Mod_LoadDe

; 1335 : 	{
; 1336 : 		Con_Reportf( S_ERROR "%s has mismatched size (%i should be %i)\n", path, deluxdatasize, bmod->lightdatasize );

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _deluxdatasize$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@HGHNGDJB@?$FO1Error?3?$FO7?5?$CFs?5has?5mismatched?5si@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1337 : 		Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1338 : 		return;

	jmp	SHORT $LN1@Mod_LoadDe
$LN7@Mod_LoadDe:

; 1339 : 	}
; 1340 : 
; 1341 : 	bmod->deluxedata_out = Mem_Malloc( loadmodel->mempool, deluxdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _deluxdatasize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _bmod$[ebp]
	mov	DWORD PTR [ecx+144], eax

; 1342 : 	memcpy( bmod->deluxedata_out, in + 8, deluxdatasize );

	mov	eax, DWORD PTR _deluxdatasize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1343 : 	bmod->deluxdatasize = deluxdatasize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _deluxdatasize$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 1344 : 	Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadDeluxemap@@9@9
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadDe:

; 1345 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadDeluxemap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadColoredLighting
_TEXT	SEGMENT
tv90 = -212						; size = 4
_in$ = -144						; size = 4
_litdatasize$ = -140					; size = 4
_iCompare$ = -136					; size = 4
_path$ = -132						; size = 64
_modelname$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_bmod$ = 8						; size = 4
_Mod_LoadColoredLighting PROC				; COMDAT

; 1249 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1250 : 	char	modelname[64];
; 1251 : 	char	path[64];
; 1252 : 	int	iCompare;
; 1253 : 	size_t	litdatasize;
; 1254 : 	byte	*in;
; 1255 : 
; 1256 : 	COM_FileBase( loadmodel->name, modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1257 : 	Q_snprintf( path, sizeof( path ), "maps/%s.lit", modelname );

	lea	eax, DWORD PTR _modelname$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@KPNLOLCL@maps?1?$CFs?4lit@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1258 : 
; 1259 : 	// make sure what deluxemap is actual
; 1260 : 	if( !COM_CompareFileTime( path, loadmodel->name, &iCompare ))

	lea	eax, DWORD PTR _iCompare$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_COM_CompareFileTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Mod_LoadCo

; 1261 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN2@Mod_LoadCo:

; 1262 : 
; 1263 : 	if( iCompare < 0 ) // this may happens if level-designer used -onlyents key for hlcsg

	cmp	DWORD PTR _iCompare$[ebp], 0
	jge	SHORT $LN3@Mod_LoadCo

; 1264 : 		Con_Printf( S_WARN "%s probably is out of date\n", path );

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@DFGMPNGN@?$FO3Warning?3?$FO7?5?$CFs?5probably?5is?5out@
	call	_Con_Printf
	add	esp, 8
$LN3@Mod_LoadCo:

; 1265 : 
; 1266 : 	in = FS_LoadFile( path, &litdatasize, false );

	push	0
	lea	eax, DWORD PTR _litdatasize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _in$[ebp], eax

; 1267 : 
; 1268 : 	Assert( in != NULL );

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN8@Mod_LoadCo
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN9@Mod_LoadCo
$LN8@Mod_LoadCo:
	mov	DWORD PTR tv90[ebp], 0
$LN9@Mod_LoadCo:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@DHKGJOLH@in?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1269 : 
; 1270 : 	if( *(uint *)in != IDDELUXEMAPHEADER || *((uint *)in + 1) != DELUXEMAP_VERSION )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax], 1414089809		; 54494c51H
	jne	SHORT $LN5@Mod_LoadCo
	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+4], 1
	je	SHORT $LN4@Mod_LoadCo
$LN5@Mod_LoadCo:

; 1271 : 	{
; 1272 : 		Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1273 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN4@Mod_LoadCo:

; 1274 : 	}
; 1275 : 
; 1276 : 	// skip header bytes
; 1277 : 	litdatasize -= 8;

	mov	eax, DWORD PTR _litdatasize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _litdatasize$[ebp], eax

; 1278 : 
; 1279 : 	if( litdatasize != ( bmod->lightdatasize * 3 ))

	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+108], 3
	cmp	DWORD PTR _litdatasize$[ebp], ecx
	je	SHORT $LN6@Mod_LoadCo

; 1280 : 	{
; 1281 : 		Con_Printf( S_ERROR "%s has mismatched size (%i should be %i)\n", path, litdatasize, bmod->lightdatasize * 3 );

	mov	eax, DWORD PTR _bmod$[ebp]
	imul	ecx, DWORD PTR [eax+108], 3
	push	ecx
	mov	edx, DWORD PTR _litdatasize$[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@HGHNGDJB@?$FO1Error?3?$FO7?5?$CFs?5has?5mismatched?5si@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 1282 : 		Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1283 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_LoadCo
$LN6@Mod_LoadCo:

; 1284 : 	}
; 1285 : 
; 1286 : 	loadmodel->lightdata = Mem_Malloc( loadmodel->mempool, litdatasize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _litdatasize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _loadmodel
	mov	DWORD PTR [ecx+380], eax

; 1287 : 	memcpy( loadmodel->lightdata, in + 8, litdatasize );

	mov	eax, DWORD PTR _litdatasize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+380]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1288 : 	SetBits( loadmodel->flags, MODEL_COLORED_LIGHTING );

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+80], ecx

; 1289 : 	bmod->lightdatasize = litdatasize;

	mov	eax, DWORD PTR _bmod$[ebp]
	mov	ecx, DWORD PTR _litdatasize$[ebp]
	mov	DWORD PTR [eax+108], ecx

; 1290 : 	Mem_Free( in );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadColoredLighting@@9@9
	add	eax, 41					; 00000029H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1291 : 
; 1292 : 	return true;

	mov	eax, 1
$LN1@Mod_LoadCo:

; 1293 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadColoredLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_SetupHull
_TEXT	SEGMENT
tv75 = -76						; size = 4
_count$ = -8						; size = 4
_hull$ = -4						; size = 4
_bmod$ = 8						; size = 4
_mod$ = 12						; size = 4
_mempool$ = 16						; size = 4
_headnode$ = 20						; size = 4
_hullnum$ = 24						; size = 4
_Mod_SetupHull PROC					; COMDAT

; 1195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1196 : 	hull_t	*hull = &mod->hulls[hullnum];

	imul	eax, DWORD PTR _hullnum$[ebp], 40
	mov	ecx, DWORD PTR _mod$[ebp]
	lea	edx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], edx

; 1197 : 	int	count;
; 1198 : 
; 1199 : 	// assume no hull
; 1200 : 	hull->firstclipnode = hull->lastclipnode = 0;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1201 : 	hull->planes = NULL; // hull is missed

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1202 : 
; 1203 : 	if(( headnode == -1 ) || ( hullnum != 1 && headnode == 0 ))

	cmp	DWORD PTR _headnode$[ebp], -1
	je	SHORT $LN5@Mod_SetupH
	cmp	DWORD PTR _hullnum$[ebp], 1
	je	SHORT $LN4@Mod_SetupH
	cmp	DWORD PTR _headnode$[ebp], 0
	jne	SHORT $LN4@Mod_SetupH
$LN5@Mod_SetupH:

; 1204 : 		return; // hull missed

	jmp	$LN1@Mod_SetupH
$LN4@Mod_SetupH:

; 1205 : 
; 1206 : 	if( headnode >= mod->numclipnodes )

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _headnode$[ebp]
	cmp	ecx, DWORD PTR [eax+192]
	jl	SHORT $LN6@Mod_SetupH

; 1207 : 		return;	// ZHLT weird empty hulls

	jmp	$LN1@Mod_SetupH
$LN6@Mod_SetupH:

; 1208 : 
; 1209 : 	switch( hullnum )

	mov	eax, DWORD PTR _hullnum$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN7@Mod_SetupH
	cmp	DWORD PTR tv75[ebp], 2
	je	$LN8@Mod_SetupH
	cmp	DWORD PTR tv75[ebp], 3
	je	$LN9@Mod_SetupH
	jmp	$LN10@Mod_SetupH
$LN7@Mod_SetupH:

; 1210 : 	{
; 1211 : 	case 1:
; 1212 : 		VectorCopy( host.player_mins[0], hull->clip_mins ); // copy human hull

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34236]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34236]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34236]
	mov	DWORD PTR [esi+eax+16], ecx

; 1213 : 		VectorCopy( host.player_maxs[0], hull->clip_maxs );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34284]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34284]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx

; 1214 : 		break;

	jmp	$LN2@Mod_SetupH
$LN8@Mod_SetupH:

; 1215 : 	case 2:
; 1216 : 		VectorCopy( host.player_mins[3], hull->clip_mins ); // copy large hull

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34236]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34236]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34236]
	mov	DWORD PTR [esi+eax+16], ecx

; 1217 : 		VectorCopy( host.player_maxs[3], hull->clip_maxs );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[ecx+eax+34284]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[edx+eax+34284]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx

; 1218 : 		break;

	jmp	$LN2@Mod_SetupH
$LN9@Mod_SetupH:

; 1219 : 	case 3:
; 1220 : 		VectorCopy( host.player_mins[1], hull->clip_mins ); // copy head hull

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[eax+edx+34236]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[eax+ecx+34236]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34236]
	mov	DWORD PTR [esi+eax+16], ecx

; 1221 : 		VectorCopy( host.player_maxs[1], hull->clip_maxs );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR _host[eax+edx+34284]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _host[eax+ecx+34284]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _host[ecx+edx+34284]
	mov	DWORD PTR [esi+eax+28], ecx

; 1222 : 		break;

	jmp	SHORT $LN2@Mod_SetupH
$LN10@Mod_SetupH:

; 1223 : 	default:
; 1224 : 		Host_Error( "Mod_SetupHull: bad hull number %i\n", hullnum );

	mov	eax, DWORD PTR _hullnum$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@ONMMJLDG@Mod_SetupHull?3?5bad?5hull?5number?5@
	call	_Host_Error
	add	esp, 8
$LN2@Mod_SetupH:

; 1225 : 		break;
; 1226 : 	}
; 1227 : 
; 1228 : 	if( VectorIsNull( hull->clip_mins ) && VectorIsNull( hull->clip_maxs ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@Mod_SetupH
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+28]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@Mod_SetupH

; 1229 : 		return;	// no hull specified

	jmp	$LN1@Mod_SetupH
$LN11@Mod_SetupH:

; 1230 : 
; 1231 : 	CountClipNodes32_r( bmod->clipnodes_out, hull, headnode );

	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH

; 1232 : 	count = hull->lastclipnode;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _count$[ebp], ecx

; 1233 : 
; 1234 : 	// fit array to real count
; 1235 : 	hull->clipnodes = (mclipnode_t *)Mem_Malloc( mempool, sizeof( mclipnode_t ) * hull->lastclipnode );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_SetupHull@@9@9
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _mempool$[ebp]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [ecx], eax

; 1236 : 	hull->planes = mod->planes; // share planes

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+4], edx

; 1237 : 	hull->lastclipnode = 0; // restart counting

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1238 : 
; 1239 : 	// remap clipnodes to 16-bit indexes
; 1240 : 	RemapClipNodes_r( bmod->clipnodes_out, hull, headnode );

	mov	eax, DWORD PTR _headnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bmod$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	call	_RemapClipNodes_r
	add	esp, 12					; 0000000cH
$LN1@Mod_SetupH:

; 1241 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetupHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_MakeHull0
_TEXT	SEGMENT
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_hull$ = -16						; size = 4
_out$ = -12						; size = 4
_child$ = -8						; size = 4
_in$ = -4						; size = 4
_Mod_MakeHull0 PROC					; COMDAT

; 1160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1161 : 	mnode_t		*in, *child;
; 1162 : 	mclipnode_t	*out;
; 1163 : 	hull_t		*hull;
; 1164 : 	int		i, j;
; 1165 : 	
; 1166 : 	hull = &loadmodel->hulls[0];	

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _loadmodel
	lea	eax, DWORD PTR [edx+ecx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 1167 : 	hull->clipnodes = out = Mem_Malloc( loadmodel->mempool, loadmodel->numnodes * sizeof( *out ));	

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_MakeHull0@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+160]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx], eax

; 1168 : 	in = loadmodel->nodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR _in$[ebp], ecx

; 1169 : 
; 1170 : 	hull->firstclipnode = 0;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1171 : 	hull->lastclipnode = loadmodel->numnodes - 1;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+160]
	sub	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1172 : 	hull->planes = loadmodel->planes;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+132]
	mov	DWORD PTR [eax+4], edx

; 1173 : 
; 1174 : 	for( i = 0; i < loadmodel->numnodes; i++, out++, in++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_MakeHu
$LN2@Mod_MakeHu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 8
	mov	DWORD PTR _out$[ebp], ecx
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 52					; 00000034H
	mov	DWORD PTR _in$[ebp], edx
$LN4@Mod_MakeHu:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+160]
	jge	$LN1@Mod_MakeHu

; 1175 : 	{
; 1176 : 		out->planenum = in->plane - loadmodel->planes;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [eax+36]
	sub	eax, DWORD PTR [ecx+132]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx], eax

; 1177 : 
; 1178 : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_MakeHu
$LN5@Mod_MakeHu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_MakeHu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN6@Mod_MakeHu

; 1179 : 		{
; 1180 : 			child = in->children[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _child$[ebp], edx

; 1181 : 
; 1182 : 			if( child->contents < 0 )

	mov	eax, DWORD PTR _child$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN8@Mod_MakeHu

; 1183 : 				out->children[j] = child->contents;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _child$[ebp]
	mov	dx, WORD PTR [edx]
	mov	WORD PTR [ecx+eax*2+4], dx
	jmp	SHORT $LN9@Mod_MakeHu
$LN8@Mod_MakeHu:

; 1184 : 			else out->children[j] = child - loadmodel->nodes;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _child$[ebp]
	sub	ecx, DWORD PTR [eax+164]
	mov	eax, ecx
	cdq
	mov	ecx, 52					; 00000034H
	idiv	ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx+edx*2+4], ax
$LN9@Mod_MakeHu:

; 1185 : 		}

	jmp	SHORT $LN5@Mod_MakeHu
$LN6@Mod_MakeHu:

; 1186 : 	}

	jmp	$LN2@Mod_MakeHu
$LN1@Mod_MakeHu:

; 1187 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_MakeHull0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _RemapClipNodes_r
_TEXT	SEGMENT
_c$ = -16						; size = 4
_i$ = -12						; size = 4
_out$ = -8						; size = 4
_src$ = -4						; size = 4
_srcnodes$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_RemapClipNodes_r PROC					; COMDAT

; 1126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1127 : 	dclipnode32_t	*src;
; 1128 : 	mclipnode_t	*out;
; 1129 : 	int		i, c;
; 1130 : 
; 1131 : 	// leaf?
; 1132 : 	if( nodenum < 0 )

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN5@RemapClipN

; 1133 : 		return nodenum;

	mov	eax, DWORD PTR _nodenum$[ebp]
	jmp	$LN1@RemapClipN
$LN5@RemapClipN:

; 1134 : 
; 1135 : 	// emit a clipnode
; 1136 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN6@RemapClipN

; 1137 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET ??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@
	call	_Host_Error
	add	esp, 4
$LN6@RemapClipN:

; 1138 : 	src = srcnodes + nodenum;

	imul	eax, DWORD PTR _nodenum$[ebp], 12
	add	eax, DWORD PTR _srcnodes$[ebp]
	mov	DWORD PTR _src$[ebp], eax

; 1139 : 
; 1140 : 	c = hull->lastclipnode;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _c$[ebp], ecx

; 1141 : 	out = &hull->clipnodes[c];

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _out$[ebp], eax

; 1142 : 	hull->lastclipnode++;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1143 : 
; 1144 : 	out->planenum = src->planenum;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1145 : 
; 1146 : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@RemapClipN
$LN2@RemapClipN:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@RemapClipN:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@RemapClipN

; 1147 : 		out->children[i] = RemapClipNodes_r( srcnodes, hull, src->children[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcnodes$[ebp]
	push	ecx
	call	_RemapClipNodes_r
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	WORD PTR [ecx+edx*2+4], ax
	jmp	SHORT $LN2@RemapClipN
$LN3@RemapClipN:

; 1148 : 
; 1149 : 	return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN1@RemapClipN:

; 1150 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_RemapClipNodes_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _CountClipNodes32_r
_TEXT	SEGMENT
_src$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_CountClipNodes32_r PROC				; COMDAT

; 1108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1109 : 	// leaf?
; 1110 : 	if( nodenum < 0 ) return;

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN2@CountClipN
	jmp	SHORT $LN1@CountClipN
$LN2@CountClipN:

; 1111 : 
; 1112 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN3@CountClipN

; 1113 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET ??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@
	call	_Host_Error
	add	esp, 4
$LN3@CountClipN:

; 1114 : 	hull->lastclipnode++;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1115 : 
; 1116 : 	CountClipNodes32_r( src, hull, src[nodenum].children[0] );

	imul	eax, DWORD PTR _nodenum$[ebp], 12
	add	eax, DWORD PTR _src$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+edx+4]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH

; 1117 : 	CountClipNodes32_r( src, hull, src[nodenum].children[1] );

	imul	eax, DWORD PTR _nodenum$[ebp], 12
	add	eax, DWORD PTR _src$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [eax+ecx+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_CountClipNodes32_r
	add	esp, 12					; 0000000cH
$LN1@CountClipN:

; 1118 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CountClipNodes32_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _CountClipNodes_r
_TEXT	SEGMENT
_src$ = 8						; size = 4
_hull$ = 12						; size = 4
_nodenum$ = 16						; size = 4
_CountClipNodes_r PROC					; COMDAT

; 1090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1091 : 	// leaf?
; 1092 : 	if( nodenum < 0 ) return;

	cmp	DWORD PTR _nodenum$[ebp], 0
	jge	SHORT $LN2@CountClipN
	jmp	SHORT $LN1@CountClipN
$LN2@CountClipN:

; 1093 : 
; 1094 : 	if( hull->lastclipnode == MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+12], 32767		; 00007fffH
	jne	SHORT $LN3@CountClipN

; 1095 : 		Host_Error( "MAX_MAP_CLIPNODES limit exceeded\n" );

	push	OFFSET ??_C@_0CC@NEGLCMME@MAX_MAP_CLIPNODES?5limit?5exceede@
	call	_Host_Error
	add	esp, 4
$LN3@CountClipN:

; 1096 : 	hull->lastclipnode++;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1097 : 
; 1098 : 	CountClipNodes_r( src, hull, src[nodenum].children[0] );

	mov	eax, DWORD PTR _nodenum$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH

; 1099 : 	CountClipNodes_r( src, hull, src[nodenum].children[1] );

	mov	eax, DWORD PTR _nodenum$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax+4]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_CountClipNodes_r
	add	esp, 12					; 0000000cH
$LN1@CountClipN:

; 1100 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CountClipNodes_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_SetParent
_TEXT	SEGMENT
_node$ = 8						; size = 4
_parent$ = 12						; size = 4
_Mod_SetParent PROC					; COMDAT

; 1076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1077 : 	node->parent = parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1078 : 
; 1079 : 	if( node->contents < 0 ) return; // it's leaf

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN2@Mod_SetPar
	jmp	SHORT $LN1@Mod_SetPar
$LN2@Mod_SetPar:

; 1080 : 	Mod_SetParent( node->children[0], node );

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_Mod_SetParent
	add	esp, 8

; 1081 : 	Mod_SetParent( node->children[1], node );

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_Mod_SetParent
	add	esp, 8
$LN1@Mod_SetPar:

; 1082 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetParent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_CalcSurfaceBounds
_TEXT	SEGMENT
tv196 = -80						; size = 4
_v$ = -12						; size = 4
_e$ = -8						; size = 4
_i$ = -4						; size = 4
_surf$ = 8						; size = 4
_Mod_CalcSurfaceBounds PROC				; COMDAT

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1050 : 	int	i, e;
; 1051 : 	mvertex_t	*v;
; 1052 : 
; 1053 : 	ClearBounds( surf->info->mins, surf->info->maxs );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	call	_ClearBounds
	add	esp, 8

; 1054 : 
; 1055 : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CalcSu
$LN2@Mod_CalcSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_CalcSu:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@Mod_CalcSu

; 1056 : 	{
; 1057 : 		e = loadmodel->surfedges[surf->firstedge + i];

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _e$[ebp], ecx

; 1058 : 
; 1059 : 		if( e >= loadmodel->numedges || e <= -loadmodel->numedges )

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR [eax+152]
	jge	SHORT $LN6@Mod_CalcSu
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+152]
	neg	ecx
	cmp	DWORD PTR _e$[ebp], ecx
	jg	SHORT $LN5@Mod_CalcSu
$LN6@Mod_CalcSu:

; 1060 : 			Host_Error( "Mod_CalcSurfaceBounds: bad edge\n" );

	push	OFFSET ??_C@_0CB@DIJBMDAC@Mod_CalcSurfaceBounds?3?5bad?5edge@
	call	_Host_Error
	add	esp, 4
$LN5@Mod_CalcSu:

; 1061 : 
; 1062 : 		if( e >= 0 ) v = &loadmodel->vertexes[loadmodel->edges[e].v[0]];

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN7@Mod_CalcSu
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _v$[ebp], ecx
	jmp	SHORT $LN8@Mod_CalcSu
$LN7@Mod_CalcSu:

; 1063 : 		else v = &loadmodel->vertexes[loadmodel->edges[-e].v[1]];

	mov	eax, DWORD PTR _e$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+156]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, 2
	shl	ecx, 0
	movzx	edx, WORD PTR [eax+ecx]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+148]
	mov	DWORD PTR _v$[ebp], eax
$LN8@Mod_CalcSu:

; 1064 : 		AddPointToBounds( v->position, surf->info->mins, surf->info->maxs );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 1065 : 	}

	jmp	$LN2@Mod_CalcSu
$LN3@Mod_CalcSu:

; 1066 : 
; 1067 : 	VectorAverage( surf->info->mins, surf->info->maxs, surf->info->origin );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [edx+80]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [ecx+eax+24], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [ecx+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+ecx+24], xmm0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [edx+80]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR [edx+esi+12]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv196[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR [edx+eax+24], xmm0

; 1068 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CalcSurfaceBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_CalcSurfaceExtents
_TEXT	SEGMENT
tv277 = -152						; size = 4
tv267 = -152						; size = 4
tv219 = -152						; size = 4
tv209 = -152						; size = 4
_v$ = -84						; size = 4
_tex$ = -80						; size = 4
_facenum$ = -76						; size = 4
_info$ = -72						; size = 4
_sample_size$ = -68					; size = 4
_e$ = -64						; size = 4
_j$ = -60						; size = 4
_i$ = -56						; size = 4
_bmaxs$ = -52						; size = 8
_bmins$ = -44						; size = 8
_lmmaxs$ = -36						; size = 8
_lmmins$ = -28						; size = 8
_val$ = -20						; size = 4
_maxs$ = -16						; size = 8
_mins$ = -8						; size = 8
_surf$ = 8						; size = 4
_Mod_CalcSurfaceExtents PROC				; COMDAT

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 971  : 	float		mins[2], maxs[2], val;
; 972  : 	float		lmmins[2], lmmaxs[2];
; 973  : 	int		bmins[2], bmaxs[2];
; 974  : 	int		i, j, e, sample_size;
; 975  : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 976  : 	int		facenum = surf - loadmodel->surfaces;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _surf$[ebp]
	sub	ecx, DWORD PTR [eax+180]
	mov	eax, ecx
	cdq
	mov	ecx, 92					; 0000005cH
	idiv	ecx
	mov	DWORD PTR _facenum$[ebp], eax

; 977  : 	mtexinfo_t	*tex;
; 978  : 	mvertex_t		*v;
; 979  : 
; 980  : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 981  : 	tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 982  : 
; 983  : 	Mod_LightMatrixFromTexMatrix( tex, info->lmvecs ); 

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_Mod_LightMatrixFromTexMatrix
	add	esp, 8

; 984  : 
; 985  : 	mins[0] = lmmins[0] = mins[1] = lmmins[1] = 999999;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _lmmins$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _lmmins$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@497423f0
	movss	DWORD PTR _mins$[ebp+edx], xmm0

; 986  : 	maxs[0] = lmmaxs[0] = maxs[1] = lmmaxs[1] =-999999;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _lmmaxs$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _lmmaxs$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR __real@c97423f0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0

; 987  : 
; 988  : 	for( i = 0; i < surf->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CalcSu
$LN2@Mod_CalcSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_CalcSu:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@Mod_CalcSu

; 989  : 	{
; 990  : 		e = loadmodel->surfedges[surf->firstedge + i];

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _e$[ebp], ecx

; 991  : 
; 992  : 		if( e >= loadmodel->numedges || e <= -loadmodel->numedges )

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	ecx, DWORD PTR [eax+152]
	jge	SHORT $LN15@Mod_CalcSu
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+152]
	neg	ecx
	cmp	DWORD PTR _e$[ebp], ecx
	jg	SHORT $LN14@Mod_CalcSu
$LN15@Mod_CalcSu:

; 993  : 			Host_Error( "Mod_CalcSurfaceExtents: bad edge\n" );

	push	OFFSET ??_C@_0CC@GDPMEJOM@Mod_CalcSurfaceExtents?3?5bad?5edg@
	call	_Host_Error
	add	esp, 4
$LN14@Mod_CalcSu:

; 994  : 
; 995  : 		if( e >= 0 ) v = &loadmodel->vertexes[loadmodel->edges[e].v[0]];

	cmp	DWORD PTR _e$[ebp], 0
	jl	SHORT $LN16@Mod_CalcSu
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _loadmodel
	add	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _v$[ebp], ecx
	jmp	SHORT $LN17@Mod_CalcSu
$LN16@Mod_CalcSu:

; 996  : 		else v = &loadmodel->vertexes[loadmodel->edges[-e].v[1]];

	mov	eax, DWORD PTR _e$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+156]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, 2
	shl	ecx, 0
	movzx	edx, WORD PTR [eax+ecx]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _loadmodel
	add	eax, DWORD PTR [ecx+148]
	mov	DWORD PTR _v$[ebp], eax
$LN17@Mod_CalcSu:

; 997  : 
; 998  : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_CalcSu
$LN5@Mod_CalcSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_CalcSu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN6@Mod_CalcSu

; 999  : 		{
; 1000 : 			val = DotProduct( v->position, surf->texinfo->vecs[j] ) + surf->texinfo->vecs[j][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 3
	addss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _val$[ebp], xmm0

; 1001 : 			mins[j] = Q_min( val, mins[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+eax*4]
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN22@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv209[ebp], xmm0
	jmp	SHORT $LN23@Mod_CalcSu
$LN22@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+ecx*4]
	movss	DWORD PTR tv209[ebp], xmm0
$LN23@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _mins$[ebp+edx*4], xmm0

; 1002 : 			maxs[j] = Q_max( val, maxs[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm0, DWORD PTR _maxs$[ebp+eax*4]
	jbe	SHORT $LN24@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv219[ebp], xmm0
	jmp	SHORT $LN25@Mod_CalcSu
$LN24@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _maxs$[ebp+ecx*4]
	movss	DWORD PTR tv219[ebp], xmm0
$LN25@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _maxs$[ebp+edx*4], xmm0

; 1003 : 		}

	jmp	$LN5@Mod_CalcSu
$LN6@Mod_CalcSu:

; 1004 : 
; 1005 : 		for( j = 0; j < 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Mod_CalcSu
$LN8@Mod_CalcSu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Mod_CalcSu:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN9@Mod_CalcSu

; 1006 : 		{
; 1007 : 			val = DotProduct( v->position, info->lmvecs[j] ) + info->lmvecs[j][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _val$[ebp], xmm0

; 1008 : 			lmmins[j] = Q_min( val, lmmins[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmins$[ebp+eax*4]
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN26@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv267[ebp], xmm0
	jmp	SHORT $LN27@Mod_CalcSu
$LN26@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmins$[ebp+ecx*4]
	movss	DWORD PTR tv267[ebp], xmm0
$LN27@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv267[ebp]
	movss	DWORD PTR _lmmins$[ebp+edx*4], xmm0

; 1009 : 			lmmaxs[j] = Q_max( val, lmmaxs[j] );

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	jbe	SHORT $LN28@Mod_CalcSu
	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN29@Mod_CalcSu
$LN28@Mod_CalcSu:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lmmaxs$[ebp+ecx*4]
	movss	DWORD PTR tv277[ebp], xmm0
$LN29@Mod_CalcSu:
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _lmmaxs$[ebp+edx*4], xmm0

; 1010 : 		}

	jmp	$LN8@Mod_CalcSu
$LN9@Mod_CalcSu:

; 1011 : 	}

	jmp	$LN2@Mod_CalcSu
$LN3@Mod_CalcSu:

; 1012 : 
; 1013 : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Mod_CalcSu
$LN11@Mod_CalcSu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Mod_CalcSu:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN12@Mod_CalcSu

; 1014 : 	{
; 1015 : 		bmins[i] = floor( mins[i] / sample_size );

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _mins$[ebp+eax*4]
	divss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bmins$[ebp+ecx*4], eax

; 1016 : 		bmaxs[i] = ceil( maxs[i] / sample_size );

	cvtsi2ss xmm0, DWORD PTR _sample_size$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _maxs$[ebp+eax*4]
	divss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bmaxs$[ebp+ecx*4], eax

; 1017 : 
; 1018 : 		surf->texturemins[i] = bmins[i] * sample_size;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bmins$[ebp+eax*4]
	imul	ecx, DWORD PTR _sample_size$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	WORD PTR [eax+edx*2+20], cx

; 1019 : 		surf->extents[i] = (bmaxs[i] - bmins[i]) * sample_size;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bmaxs$[ebp+eax*4]
	sub	edx, DWORD PTR _bmins$[ebp+ecx*4]
	imul	edx, DWORD PTR _sample_size$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	WORD PTR [ecx+eax*2+24], dx

; 1020 : 
; 1021 : 		if( FBitSet( tex->flags, TEX_WORLD_LUXELS ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 2
	je	SHORT $LN18@Mod_CalcSu

; 1022 : 		{
; 1023 : 			lmmins[i] = floor( lmmins[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cvtss2sd xmm0, DWORD PTR _lmmins$[ebp+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _lmmins$[ebp+ecx*4]

; 1024 : 			lmmaxs[i] = ceil( lmmaxs[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cvtss2sd xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _lmmaxs$[ebp+ecx*4]

; 1025 : 
; 1026 : 			info->lightmapmins[i] = lmmins[i];

	mov	eax, DWORD PTR _i$[ebp]
	cvttss2si ecx, DWORD PTR _lmmins$[ebp+eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	WORD PTR [eax+edx*2+48], cx

; 1027 : 			info->lightextents[i] = (lmmaxs[i] - lmmins[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _lmmaxs$[ebp+eax*4]
	subss	xmm0, DWORD PTR _lmmins$[ebp+ecx*4]
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	WORD PTR [ecx+eax*2+52], dx

; 1028 : 		}

	jmp	SHORT $LN19@Mod_CalcSu
$LN18@Mod_CalcSu:

; 1029 : 		else
; 1030 : 		{
; 1031 : 			// just copy texturemins
; 1032 : 			info->lightmapmins[i] = surf->texturemins[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _surf$[ebp]
	mov	dx, WORD PTR [esi+edx*2+20]
	mov	WORD PTR [ecx+eax*2+48], dx

; 1033 : 			info->lightextents[i] = surf->extents[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _surf$[ebp]
	mov	dx, WORD PTR [esi+edx*2+24]
	mov	WORD PTR [ecx+eax*2+52], dx
$LN19@Mod_CalcSu:

; 1034 : 		}
; 1035 : 
; 1036 : 		if( !FBitSet( tex->flags, TEX_SPECIAL ) && ( surf->extents[i] > 16384 ) && ( tr.block_size == BLOCK_SIZE_DEFAULT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 1
	jne	SHORT $LN20@Mod_CalcSu
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	cmp	edx, 16384				; 00004000H
	jle	SHORT $LN20@Mod_CalcSu
	cmp	DWORD PTR _tr+87580, 128		; 00000080H
	jne	SHORT $LN20@Mod_CalcSu

; 1037 : 			Con_Reportf( S_ERROR "Bad surface extents %i\n", surf->extents[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+24]
	push	edx
	push	OFFSET ??_C@_0CD@MJPHIMFM@?$FO1Error?3?$FO7?5Bad?5surface?5extents?5@
	call	_Con_Reportf
	add	esp, 8
$LN20@Mod_CalcSu:

; 1038 : 	}

	jmp	$LN11@Mod_CalcSu
$LN12@Mod_CalcSu:

; 1039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CalcSurfaceExtents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LightMatrixFromTexMatrix
_TEXT	SEGMENT
tv348 = -88						; size = 4
tv300 = -88						; size = 4
_ilength$1 = -20					; size = 4
_ilength$2 = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_lmscale$ = -4						; size = 4
_tx$ = 8						; size = 4
_lmvecs$ = 12						; size = 4
_Mod_LightMatrixFromTexMatrix PROC			; COMDAT

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 923  : 	float	lmscale = LM_SAMPLE_SIZE;

	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR _lmscale$[ebp], xmm0

; 924  : 	int	i, j;
; 925  : 
; 926  : 	// this is can't be possible but who knews
; 927  : 	if( FBitSet( tx->flags, TEX_EXTRA_LIGHTMAP ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 8
	je	SHORT $LN8@Mod_LightM

; 928  : 		lmscale = LM_SAMPLE_EXTRASIZE;

	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _lmscale$[ebp], xmm0
$LN8@Mod_LightM:

; 929  : 
; 930  : 	if( tx->faceinfo )

	mov	eax, DWORD PTR _tx$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN9@Mod_LightM

; 931  : 		lmscale = tx->faceinfo->texture_step;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movzx	edx, WORD PTR [ecx+16]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _lmscale$[ebp], xmm0
$LN9@Mod_LightM:

; 932  : 
; 933  : 	// copy texmatrix into lightmap matrix fisrt
; 934  : 	for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LightM
$LN2@Mod_LightM:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LightM:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@Mod_LightM

; 935  : 	{
; 936  : 		for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_LightM
$LN5@Mod_LightM:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_LightM:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_LightM

; 937  : 		{
; 938  : 			lmvecs[i][j] = tx->vecs[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 939  : 		}

	jmp	SHORT $LN5@Mod_LightM
$LN6@Mod_LightM:

; 940  : 	}

	jmp	SHORT $LN2@Mod_LightM
$LN3@Mod_LightM:

; 941  : 
; 942  : 	if( !FBitSet( tx->flags, TEX_WORLD_LUXELS ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 2
	jne	SHORT $LN10@Mod_LightM

; 943  : 		return; // just use texmatrix

	jmp	$LN1@Mod_LightM
$LN10@Mod_LightM:

; 944  : 
; 945  : 	VectorNormalize( lmvecs[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@Mod_LightM
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN11@Mod_LightM:
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+eax], xmm0
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 946  : 	VectorNormalize( lmvecs[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@Mod_LightM
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN12@Mod_LightM:
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 947  : 
; 948  : 	if( FBitSet( tx->flags, TEX_AXIAL_LUXELS ))

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 4
	je	SHORT $LN13@Mod_LightM

; 949  : 	{
; 950  : 		Mod_MakeNormalAxial( lmvecs[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	push	ecx
	call	_Mod_MakeNormalAxial
	add	esp, 4

; 951  : 		Mod_MakeNormalAxial( lmvecs[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	push	eax
	call	_Mod_MakeNormalAxial
	add	esp, 4
$LN13@Mod_LightM:

; 952  : 	}
; 953  : 
; 954  : 	// put the lighting origin at center the of poly
; 955  : 	VectorScale( lmvecs[0], (1.0 / lmscale), lmvecs[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv300[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	movss	xmm0, DWORD PTR tv300[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 956  : 	VectorScale( lmvecs[1], -(1.0 / lmscale), lmvecs[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR [eax+ecx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _lmvecs$[ebp]
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR [ecx+edx]
	cvtss2sd xmm1, DWORD PTR _lmscale$[ebp]
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	divsd	xmm2, xmm1
	xorps	xmm2, QWORD PTR __xmm@80000000000000008000000000000000
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv348[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	movss	xmm0, DWORD PTR tv348[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 957  : 
; 958  : 	lmvecs[0][3] = lmscale * 0.5;

	cvtss2sd xmm0, DWORD PTR _lmscale$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _lmvecs$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 959  : 	lmvecs[1][3] = -lmscale * 0.5;

	movss	xmm0, DWORD PTR _lmscale$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _lmvecs$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN1@Mod_LightM:

; 960  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LightMatrixFromTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_MakeNormalAxial
_TEXT	SEGMENT
tv87 = -80						; size = 8
_type$ = -8						; size = 4
_i$ = -4						; size = 4
_normal$ = 8						; size = 4
_Mod_MakeNormalAxial PROC				; COMDAT

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 897  : 	int	i, type;
; 898  : 
; 899  : 	for( type = 0; type < 3; type++ )

	mov	DWORD PTR _type$[ebp], 0
	jmp	SHORT $LN4@Mod_MakeNo
$LN2@Mod_MakeNo:
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, 1
	mov	DWORD PTR _type$[ebp], eax
$LN4@Mod_MakeNo:
	cmp	DWORD PTR _type$[ebp], 3
	jge	SHORT $LN3@Mod_MakeNo

; 900  : 	{
; 901  : 		if( fabs( normal[type] ) > 0.9999f )

	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv87[ebp]
	movsd	xmm0, QWORD PTR tv87[ebp]
	comisd	xmm0, QWORD PTR __real@3fefff2e40000000
	jbe	SHORT $LN8@Mod_MakeNo

; 902  : 			break;

	jmp	SHORT $LN3@Mod_MakeNo
$LN8@Mod_MakeNo:

; 903  : 	}

	jmp	SHORT $LN2@Mod_MakeNo
$LN3@Mod_MakeNo:

; 904  : 
; 905  : 	// make positive and pure axial
; 906  : 	for( i = 0; i < 3 && type != 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_MakeNo
$LN5@Mod_MakeNo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_MakeNo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN6@Mod_MakeNo
	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN6@Mod_MakeNo

; 907  : 	{
; 908  : 		if( i == type )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _type$[ebp]
	jne	SHORT $LN9@Mod_MakeNo

; 909  : 			normal[i] = 1.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax*4], xmm0
	jmp	SHORT $LN10@Mod_MakeNo
$LN9@Mod_MakeNo:

; 910  : 		else normal[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN10@Mod_MakeNo:

; 911  : 	}

	jmp	SHORT $LN5@Mod_MakeNo
$LN6@Mod_MakeNo:

; 912  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_MakeNormalAxial ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_CheckWaterAlphaSupport
_TEXT	SEGMENT
tv138 = -84						; size = 4
_pvs$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_leaf$ = -4						; size = 4
_bmod$ = 8						; size = 4
_Mod_CheckWaterAlphaSupport PROC			; COMDAT

; 836  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 837  : 	mleaf_t		*leaf;
; 838  : 	int		i, j;
; 839  : 	const byte	*pvs;
; 840  : 
; 841  : 	if( bmod->visdatasize <= 0 )

	mov	eax, DWORD PTR _bmod$[ebp]
	cmp	DWORD PTR [eax+100], 0
	ja	SHORT $LN8@Mod_CheckW

; 842  : 		return true;

	mov	eax, 1
	jmp	$LN1@Mod_CheckW
$LN8@Mod_CheckW:

; 843  : 
; 844  : 	// check all liquid leafs to see if they can see into empty leafs, if any
; 845  : 	// can we can assume this map supports r_wateralpha
; 846  : 	for( i = 0, leaf = loadmodel->leafs; i < loadmodel->numleafs; i++, leaf++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _leaf$[ebp], ecx
	jmp	SHORT $LN4@Mod_CheckW
$LN2@Mod_CheckW:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _leaf$[ebp]
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR _leaf$[ebp], ecx
$LN4@Mod_CheckW:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	$LN3@Mod_CheckW

; 847  : 	{
; 848  : 		if(( leaf->contents == CONTENTS_WATER || leaf->contents == CONTENTS_SLIME ) && leaf->cluster >= 0 )

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN10@Mod_CheckW
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax], -4			; fffffffcH
	jne	$LN9@Mod_CheckW
$LN10@Mod_CheckW:
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	$LN9@Mod_CheckW

; 849  : 		{
; 850  : 			pvs = Mod_DecompressPVS( leaf->compressed_vis, world.visbytes );

	mov	eax, DWORD PTR _world+2588
	push	eax
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_Mod_DecompressPVS
	add	esp, 8
	mov	DWORD PTR _pvs$[ebp], eax

; 851  : 
; 852  : 			for( j = 0; j < loadmodel->numleafs; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_CheckW
$LN5@Mod_CheckW:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_CheckW:
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	$LN9@Mod_CheckW

; 853  : 			{
; 854  : 				if( CHECKVISBIT( pvs, loadmodel->leafs[j].cluster ) && loadmodel->leafs[j].contents == CONTENTS_EMPTY )

	imul	eax, DWORD PTR _j$[ebp], 60
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+140]
	cmp	DWORD PTR [edx+eax+52], 0
	jl	SHORT $LN13@Mod_CheckW
	imul	eax, DWORD PTR _j$[ebp], 60
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [edx+eax+52]
	sar	eax, 3
	mov	ecx, DWORD PTR _pvs$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	imul	eax, DWORD PTR _j$[ebp], 60
	mov	ecx, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [ecx+140]
	mov	ecx, DWORD PTR [ecx+eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv138[ebp], ecx
	jmp	SHORT $LN14@Mod_CheckW
$LN13@Mod_CheckW:
	mov	DWORD PTR tv138[ebp], 0
$LN14@Mod_CheckW:
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN11@Mod_CheckW
	imul	eax, DWORD PTR _j$[ebp], 60
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+140]
	cmp	DWORD PTR [edx+eax], -1
	jne	SHORT $LN11@Mod_CheckW

; 855  : 					return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_CheckW
$LN11@Mod_CheckW:

; 856  : 			}

	jmp	$LN5@Mod_CheckW
$LN9@Mod_CheckW:

; 857  : 		}
; 858  : 	}

	jmp	$LN2@Mod_CheckW
$LN3@Mod_CheckW:

; 859  : 
; 860  : 	return false;

	xor	eax, eax
$LN1@Mod_CheckW:

; 861  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckWaterAlphaSupport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_FindModelOrigin
_TEXT	SEGMENT
_origin_found$ = -2320					; size = 4
_model_found$ = -2316					; size = 4
_token$ = -2312						; size = 2048
_keyname$ = -264					; size = 256
_pfile$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_entities$ = 8						; size = 4
_modelname$ = 12					; size = 4
_origin$ = 16						; size = 4
_Mod_FindModelOrigin PROC				; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2640				; 00000a50H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 775  : 	char	*pfile;
; 776  : 	string	keyname;
; 777  : 	char	token[2048];
; 778  : 	qboolean	model_found;
; 779  : 	qboolean	origin_found;
; 780  : 
; 781  : 	if( !entities || !modelname || !*modelname )

	cmp	DWORD PTR _entities$[ebp], 0
	je	SHORT $LN7@Mod_FindMo
	cmp	DWORD PTR _modelname$[ebp], 0
	je	SHORT $LN7@Mod_FindMo
	mov	eax, DWORD PTR _modelname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@Mod_FindMo
$LN7@Mod_FindMo:

; 782  : 		return;

	jmp	$LN3@Mod_FindMo
$LN6@Mod_FindMo:

; 783  : 
; 784  : 	if( !origin || !VectorIsNull( origin ))

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN10@Mod_FindMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Mod_FindMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Mod_FindMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@Mod_FindMo
$LN10@Mod_FindMo:

; 785  : 		return;

	jmp	$LN3@Mod_FindMo
$LN8@Mod_FindMo:

; 786  : 
; 787  : 	pfile = (char *)entities;

	mov	eax, DWORD PTR _entities$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@Mod_FindMo:

; 788  : 
; 789  : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@Mod_FindMo

; 790  : 	{
; 791  : 		if( token[0] != '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 123				; 0000007bH
	je	SHORT $LN11@Mod_FindMo

; 792  : 			Host_Error( "Mod_FindModelOrigin: found %s when expecting {\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@JNODKEGC@Mod_FindModelOrigin?3?5found?5?$CFs?5w@
	call	_Host_Error
	add	esp, 8
$LN11@Mod_FindMo:

; 793  : 
; 794  : 		model_found = origin_found = false;

	mov	DWORD PTR _origin_found$[ebp], 0
	mov	eax, DWORD PTR _origin_found$[ebp]
	mov	DWORD PTR _model_found$[ebp], eax

; 795  : 		VectorClear( origin );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN4@Mod_FindMo:

; 796  : 
; 797  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@Mod_FindMo

; 798  : 		{
; 799  : 			// parse key
; 800  : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN12@Mod_FindMo

; 801  : 				Host_Error( "Mod_FindModelOrigin: EOF without closing brace\n" );

	push	OFFSET ??_C@_0DA@KDJJLMGP@Mod_FindModelOrigin?3?5EOF?5withou@
	call	_Host_Error
	add	esp, 4
$LN12@Mod_FindMo:

; 802  : 			if( token[0] == '}' ) break; // end of desc

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN13@Mod_FindMo
	jmp	$LN5@Mod_FindMo
$LN13@Mod_FindMo:

; 803  : 
; 804  : 			Q_strncpy( keyname, token, sizeof( keyname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 805  : 
; 806  : 			// parse value	
; 807  : 			if(( pfile = COM_ParseFile( pfile, token )) == NULL ) 

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN14@Mod_FindMo

; 808  : 				Host_Error( "Mod_FindModelOrigin: EOF without closing brace\n" );

	push	OFFSET ??_C@_0DA@KDJJLMGP@Mod_FindModelOrigin?3?5EOF?5withou@
	call	_Host_Error
	add	esp, 4
$LN14@Mod_FindMo:

; 809  : 
; 810  : 			if( token[0] == '}' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN15@Mod_FindMo

; 811  : 				Host_Error( "Mod_FindModelOrigin: closing brace without data\n" );

	push	OFFSET ??_C@_0DB@DMBFGDCJ@Mod_FindModelOrigin?3?5closing?5br@
	call	_Host_Error
	add	esp, 4
$LN15@Mod_FindMo:

; 812  : 
; 813  : 			if( !Q_stricmp( keyname, "model" ) && !Q_stricmp( modelname, token ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05NCCFOPHA@model@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_FindMo
	push	99999					; 0001869fH
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelname$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Mod_FindMo

; 814  : 				model_found = true;

	mov	DWORD PTR _model_found$[ebp], 1
$LN16@Mod_FindMo:

; 815  : 
; 816  : 			if( !Q_stricmp( keyname, "origin" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06NHCMNMEH@origin@
	lea	eax, DWORD PTR _keyname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@Mod_FindMo

; 817  : 			{
; 818  : 				Q_atov( origin, token, 3 );

	push	3
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_Q_atov
	add	esp, 12					; 0000000cH

; 819  : 				origin_found = true;

	mov	DWORD PTR _origin_found$[ebp], 1
$LN17@Mod_FindMo:

; 820  : 			}
; 821  : 		}

	jmp	$LN4@Mod_FindMo
$LN5@Mod_FindMo:

; 822  : 
; 823  : 		if( model_found ) break;

	cmp	DWORD PTR _model_found$[ebp], 0
	je	SHORT $LN18@Mod_FindMo
	jmp	SHORT $LN3@Mod_FindMo
$LN18@Mod_FindMo:

; 824  : 	}	

	jmp	$LN2@Mod_FindMo
$LN3@Mod_FindMo:

; 825  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FindModelOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_BoxLeafnums
_TEXT	SEGMENT
_ll$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_list$ = 16						; size = 4
_listsize$ = 20						; size = 4
_topnode$ = 24						; size = 4
_Mod_BoxLeafnums PROC					; COMDAT

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 674  : 	leaflist_t	ll;
; 675  : 
; 676  : 	if( !worldmodel ) return 0;

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN2@Mod_BoxLea
	xor	eax, eax
	jmp	$LN1@Mod_BoxLea
$LN2@Mod_BoxLea:

; 677  : 
; 678  : 	VectorCopy( mins, ll.mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _ll$[ebp+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _ll$[ebp+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _ll$[ebp+ecx+16], eax

; 679  : 	VectorCopy( maxs, ll.maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _ll$[ebp+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _ll$[ebp+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _ll$[ebp+ecx+28], eax

; 680  : 
; 681  : 	ll.maxcount = listsize;

	mov	eax, DWORD PTR _listsize$[ebp]
	mov	DWORD PTR _ll$[ebp+4], eax

; 682  : 	ll.overflowed = false;

	mov	DWORD PTR _ll$[ebp+8], 0

; 683  : 	ll.topnode = -1;

	mov	DWORD PTR _ll$[ebp+40], -1

; 684  : 	ll.list = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _ll$[ebp+12], eax

; 685  : 	ll.count = 0;

	mov	DWORD PTR _ll$[ebp], 0

; 686  : 
; 687  : 	Mod_BoxLeafnums_r( &ll, worldmodel->nodes );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _ll$[ebp]
	push	edx
	call	_Mod_BoxLeafnums_r
	add	esp, 8

; 688  : 
; 689  : 	if( topnode ) *topnode = ll.topnode;

	cmp	DWORD PTR _topnode$[ebp], 0
	je	SHORT $LN3@Mod_BoxLea
	mov	eax, DWORD PTR _topnode$[ebp]
	mov	ecx, DWORD PTR _ll$[ebp+40]
	mov	DWORD PTR [eax], ecx
$LN3@Mod_BoxLea:

; 690  : 	return ll.count;

	mov	eax, DWORD PTR _ll$[ebp]
$LN1@Mod_BoxLea:

; 691  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxLeafnums ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_BoxLeafnums_r
_TEXT	SEGMENT
tv144 = -84						; size = 4
tv135 = -80						; size = 4
tv136 = -76						; size = 4
_leaf$1 = -8						; size = 4
_sides$ = -4						; size = 4
_ll$ = 8						; size = 4
_node$ = 12						; size = 4
_Mod_BoxLeafnums_r PROC					; COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
$LN2@Mod_BoxLea:

; 624  : 	int	sides;
; 625  : 
; 626  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Mod_BoxLea

; 627  : 	{
; 628  : 		if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN4@Mod_BoxLea

; 629  : 			return;

	jmp	$LN3@Mod_BoxLea
$LN4@Mod_BoxLea:

; 630  : 
; 631  : 		if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@Mod_BoxLea

; 632  : 		{
; 633  : 			mleaf_t	*leaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$1[ebp], eax

; 634  : 
; 635  : 			// it's a leaf!
; 636  : 			if( ll->count >= ll->maxcount )

	mov	eax, DWORD PTR _ll$[ebp]
	mov	ecx, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN6@Mod_BoxLea

; 637  : 			{
; 638  : 				ll->overflowed = true;

	mov	eax, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [eax+8], 1

; 639  : 				return;

	jmp	$LN3@Mod_BoxLea
$LN6@Mod_BoxLea:

; 640  : 			}
; 641  : 
; 642  : 			ll->list[ll->count++] = leaf->cluster;

	mov	eax, DWORD PTR _ll$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ll$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _leaf$1[ebp]
	mov	dx, WORD PTR [edx+52]
	mov	WORD PTR [eax+ecx*2], dx
	mov	eax, DWORD PTR _ll$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [edx], ecx

; 643  : 			return;

	jmp	$LN3@Mod_BoxLea
$LN5@Mod_BoxLea:

; 644  : 		}
; 645  : 	
; 646  : 		sides = BOX_ON_PLANE_SIDE( ll->mins, ll->maxs, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN17@Mod_BoxLea
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movzx	edx, BYTE PTR [eax+16]
	mov	eax, DWORD PTR _ll$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+16]
	comiss	xmm0, DWORD PTR [ecx+12]
	jb	SHORT $LN15@Mod_BoxLea
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN16@Mod_BoxLea
$LN15@Mod_BoxLea:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	eax, BYTE PTR [ecx+16]
	mov	ecx, DWORD PTR _ll$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	comiss	xmm0, DWORD PTR [ecx+eax*4+28]
	jb	SHORT $LN13@Mod_BoxLea
	mov	DWORD PTR tv135[ebp], 2
	jmp	SHORT $LN14@Mod_BoxLea
$LN13@Mod_BoxLea:
	mov	DWORD PTR tv135[ebp], 3
$LN14@Mod_BoxLea:
	mov	edx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], edx
$LN16@Mod_BoxLea:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN18@Mod_BoxLea
$LN17@Mod_BoxLea:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ll$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _ll$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv144[ebp], eax
$LN18@Mod_BoxLea:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _sides$[ebp], edx

; 647  : 
; 648  : 		if( sides == 1 )

	cmp	DWORD PTR _sides$[ebp], 1
	jne	SHORT $LN7@Mod_BoxLea

; 649  : 		{
; 650  : 			node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 651  : 		}

	jmp	SHORT $LN10@Mod_BoxLea
$LN7@Mod_BoxLea:

; 652  : 		else if( sides == 2 )

	cmp	DWORD PTR _sides$[ebp], 2
	jne	SHORT $LN9@Mod_BoxLea

; 653  : 		{
; 654  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx

; 655  : 		}

	jmp	SHORT $LN10@Mod_BoxLea
$LN9@Mod_BoxLea:

; 656  : 		else
; 657  : 		{
; 658  : 			// go down both
; 659  : 			if( ll->topnode == -1 )

	mov	eax, DWORD PTR _ll$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN11@Mod_BoxLea

; 660  : 				ll->topnode = node - worldmodel->nodes;

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR _node$[ebp]
	sub	ecx, DWORD PTR [eax+164]
	mov	eax, ecx
	cdq
	mov	ecx, 52					; 00000034H
	idiv	ecx
	mov	edx, DWORD PTR _ll$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN11@Mod_BoxLea:

; 661  : 			Mod_BoxLeafnums_r( ll, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _ll$[ebp]
	push	ecx
	call	_Mod_BoxLeafnums_r
	add	esp, 8

; 662  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx
$LN10@Mod_BoxLea:

; 663  : 		}
; 664  : 	}

	jmp	$LN2@Mod_BoxLea
$LN3@Mod_BoxLea:

; 665  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxLeafnums_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_FatPVS_RecursiveBSPNode
_TEXT	SEGMENT
tv131 = -80						; size = 4
_vis$1 = -12						; size = 4
_d$2 = -8						; size = 4
_i$ = -4						; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_visbytes$ = 20						; size = 4
_node$ = 24						; size = 4
_Mod_FatPVS_RecursiveBSPNode PROC			; COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
$LN2@Mod_FatPVS:

; 555  : 	int	i;
; 556  : 
; 557  : 	while( node->contents >= 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	$LN3@Mod_FatPVS

; 558  : 	{
; 559  : 		float d = PlaneDiff( org, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN13@Mod_FatPVS
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN14@Mod_FatPVS
$LN13@Mod_FatPVS:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv131[ebp], xmm0
$LN14@Mod_FatPVS:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv131[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _d$2[ebp], xmm0

; 560  : 
; 561  : 		if( d > radius )

	movss	xmm0, DWORD PTR _d$2[ebp]
	comiss	xmm0, DWORD PTR _radius$[ebp]
	jbe	SHORT $LN7@Mod_FatPVS

; 562  : 			node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN10@Mod_FatPVS
$LN7@Mod_FatPVS:

; 563  : 		else if( d < -radius )

	movss	xmm0, DWORD PTR _radius$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _d$2[ebp]
	jbe	SHORT $LN9@Mod_FatPVS

; 564  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx
	jmp	SHORT $LN10@Mod_FatPVS
$LN9@Mod_FatPVS:

; 565  : 		else
; 566  : 		{
; 567  : 			// go down both sides
; 568  : 			Mod_FatPVS_RecursiveBSPNode( org, radius, visbuffer, visbytes, node->children[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	mov	ecx, DWORD PTR _visbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _visbuffer$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_Mod_FatPVS_RecursiveBSPNode
	add	esp, 20					; 00000014H

; 569  : 			node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx
$LN10@Mod_FatPVS:

; 570  : 		}
; 571  : 	}

	jmp	$LN2@Mod_FatPVS
$LN3@Mod_FatPVS:

; 572  : 
; 573  : 	// if this leaf is in a cluster, accumulate the vis bits
; 574  : 	if(((mleaf_t *)node)->cluster >= 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN5@Mod_FatPVS

; 575  : 	{
; 576  : 		byte	*vis = Mod_DecompressPVS( ((mleaf_t *)node)->compressed_vis, world.visbytes );

	mov	eax, DWORD PTR _world+2588
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_Mod_DecompressPVS
	add	esp, 8
	mov	DWORD PTR _vis$1[ebp], eax

; 577  : 
; 578  : 		for( i = 0; i < visbytes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_FatPVS
$LN4@Mod_FatPVS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Mod_FatPVS:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _visbytes$[ebp]
	jge	SHORT $LN5@Mod_FatPVS

; 579  : 			visbuffer[i] |= vis[i];

	mov	eax, DWORD PTR _vis$1[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _visbuffer$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, ecx
	mov	ecx, DWORD PTR _visbuffer$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN4@Mod_FatPVS
$LN5@Mod_FatPVS:

; 580  : 	}
; 581  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FatPVS_RecursiveBSPNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_DecompressPVS
_TEXT	SEGMENT
_c$ = -8						; size = 4
_out$ = -4						; size = 4
_in$ = 8						; size = 4
_visbytes$ = 12						; size = 4
_Mod_DecompressPVS PROC					; COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 457  : 	byte	*out;
; 458  : 	int	c;
; 459  : 
; 460  : 	out = g_visdata;

	mov	DWORD PTR _out$[ebp], OFFSET _g_visdata

; 461  : 
; 462  : 	if( !in )

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN6@Mod_Decomp
$LN2@Mod_Decomp:

; 463  : 	{	
; 464  : 		// no vis info, so make all visible
; 465  : 		while( visbytes )

	cmp	DWORD PTR _visbytes$[ebp], 0
	je	SHORT $LN3@Mod_Decomp

; 466  : 		{
; 467  : 			*out++ = 0xff;

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 468  : 			visbytes--;

	mov	eax, DWORD PTR _visbytes$[ebp]
	sub	eax, 1
	mov	DWORD PTR _visbytes$[ebp], eax

; 469  : 		}

	jmp	SHORT $LN2@Mod_Decomp
$LN3@Mod_Decomp:

; 470  : 		return g_visdata;

	mov	eax, OFFSET _g_visdata
	jmp	SHORT $LN1@Mod_Decomp
$LN6@Mod_Decomp:

; 471  : 	}
; 472  : 
; 473  : 	do
; 474  : 	{
; 475  : 		if( *in )

	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN10@Mod_Decomp

; 476  : 		{
; 477  : 			*out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 478  : 			continue;

	jmp	SHORT $LN4@Mod_Decomp
$LN10@Mod_Decomp:

; 479  : 		}
; 480  : 
; 481  : 		c = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _c$[ebp], edx

; 482  : 		in += 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax
$LN7@Mod_Decomp:

; 483  : 
; 484  : 		while( c )

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN4@Mod_Decomp

; 485  : 		{
; 486  : 			*out++ = 0;

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 487  : 			c--;

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax

; 488  : 		}

	jmp	SHORT $LN7@Mod_Decomp
$LN4@Mod_Decomp:

; 489  : 	} while( out - g_visdata < visbytes );

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, OFFSET _g_visdata
	cmp	eax, DWORD PTR _visbytes$[ebp]
	jl	SHORT $LN6@Mod_Decomp

; 490  : 
; 491  : 	return g_visdata;

	mov	eax, OFFSET _g_visdata
$LN1@Mod_Decomp:

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_DecompressPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_GlobUsage
_TEXT	SEGMENT
tv70 = -72						; size = 4
_percentage$ = -4					; size = 4
_szItem$ = 8						; size = 4
_itemstorage$ = 12					; size = 4
_maxstorage$ = 16					; size = 4
_Mod_GlobUsage PROC					; COMDAT

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 383  : 	float	percentage = maxstorage ? (itemstorage * 100.0f / maxstorage) : 0.0f;

	cmp	DWORD PTR _maxstorage$[ebp], 0
	je	SHORT $LN9@Mod_GlobUs
	cvtsi2ss xmm0, DWORD PTR _itemstorage$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _maxstorage$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN10@Mod_GlobUs
$LN9@Mod_GlobUs:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
$LN10@Mod_GlobUs:
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR _percentage$[ebp], xmm0

; 384  : 
; 385  : 	Con_Printf( "%-15s  %-12s  %8i/%-8i  (%4.1f%%) ", szItem, "[variable]", itemstorage, maxstorage, percentage );

	cvtss2sd xmm0, DWORD PTR _percentage$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _maxstorage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _itemstorage$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@JPFAHBCL@?$FLvariable?$FN@
	mov	edx, DWORD PTR _szItem$[ebp]
	push	edx
	push	OFFSET ??_C@_0CD@IKFPEOPA@?$CF?915s?5?5?$CF?912s?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?41f?$CF@
	call	_Con_Printf
	add	esp, 28					; 0000001cH

; 386  : 
; 387  : 	if( percentage > 99.99f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42c7fae1
	jbe	SHORT $LN2@Mod_GlobUs

; 388  : 		Con_Printf( "^1SIZE OVERFLOW!!!^7\n" );

	push	OFFSET ??_C@_0BG@BBOCJOCH@?$FO1SIZE?5OVERFLOW?$CB?$CB?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN2@Mod_GlobUs:

; 389  : 	else if( percentage > 95.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42be0000
	jbe	SHORT $LN4@Mod_GlobUs

; 390  : 		Con_Printf( "^3SIZE DANGER!^7\n" );

	push	OFFSET ??_C@_0BC@BGBEIFII@?$FO3SIZE?5DANGER?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN4@Mod_GlobUs:

; 391  : 	else if( percentage > 80.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN6@Mod_GlobUs

; 392  : 		Con_Printf( "^2VERY FULL!^7\n" );

	push	OFFSET ??_C@_0BA@DLPMCLNL@?$FO2VERY?5FULL?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_GlobUs
$LN6@Mod_GlobUs:

; 393  : 	else Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4
$LN7@Mod_GlobUs:

; 394  : 
; 395  : 	return itemstorage;

	mov	eax, DWORD PTR _itemstorage$[ebp]

; 396  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GlobUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_ArrayUsage
_TEXT	SEGMENT
tv70 = -72						; size = 4
_percentage$ = -4					; size = 4
_szItem$ = 8						; size = 4
_items$ = 12						; size = 4
_maxitems$ = 16						; size = 4
_itemsize$ = 20						; size = 4
_Mod_ArrayUsage PROC					; COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 361  : 	float	percentage = maxitems ? (items * 100.0f / maxitems) : 0.0f;

	cmp	DWORD PTR _maxitems$[ebp], 0
	je	SHORT $LN9@Mod_ArrayU
	cvtsi2ss xmm0, DWORD PTR _items$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _maxitems$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN10@Mod_ArrayU
$LN9@Mod_ArrayU:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
$LN10@Mod_ArrayU:
	movss	xmm0, DWORD PTR tv70[ebp]
	movss	DWORD PTR _percentage$[ebp], xmm0

; 362  : 
; 363  : 	Con_Printf( "%-12s  %7i/%-7i  %8i/%-8i  (%4.1f%%) ", szItem, items, maxitems, items * itemsize, maxitems * itemsize, percentage );

	cvtss2sd xmm0, DWORD PTR _percentage$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _maxitems$[ebp]
	imul	eax, DWORD PTR _itemsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _items$[ebp]
	imul	ecx, DWORD PTR _itemsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxitems$[ebp]
	push	edx
	mov	eax, DWORD PTR _items$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szItem$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@MFBOJPAE@?$CF?912s?5?5?$CF7i?1?$CF?97i?5?5?$CF8i?1?$CF?98i?5?5?$CI?$CF4?4@
	call	_Con_Printf
	add	esp, 32					; 00000020H

; 364  : 
; 365  : 	if( percentage > 99.99f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42c7fae1
	jbe	SHORT $LN2@Mod_ArrayU

; 366  : 		Con_Printf( "^1SIZE OVERFLOW!!!^7\n" );

	push	OFFSET ??_C@_0BG@BBOCJOCH@?$FO1SIZE?5OVERFLOW?$CB?$CB?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN2@Mod_ArrayU:

; 367  : 	else if( percentage > 95.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42be0000
	jbe	SHORT $LN4@Mod_ArrayU

; 368  : 		Con_Printf( "^3SIZE DANGER!^7\n" );

	push	OFFSET ??_C@_0BC@BGBEIFII@?$FO3SIZE?5DANGER?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN4@Mod_ArrayU:

; 369  : 	else if( percentage > 80.0f )

	movss	xmm0, DWORD PTR _percentage$[ebp]
	comiss	xmm0, DWORD PTR __real@42a00000
	jbe	SHORT $LN6@Mod_ArrayU

; 370  : 		Con_Printf( "^2VERY FULL!^7\n" );

	push	OFFSET ??_C@_0BA@DLPMCLNL@?$FO2VERY?5FULL?$CB?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN7@Mod_ArrayU
$LN6@Mod_ArrayU:

; 371  : 	else Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4
$LN7@Mod_ArrayU:

; 372  : 
; 373  : 	return items * itemsize;

	mov	eax, DWORD PTR _items$[ebp]
	imul	eax, DWORD PTR _itemsize$[ebp]

; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ArrayUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadLump
_TEXT	SEGMENT
_header$1 = -92						; size = 4
_header$2 = -88						; size = 4
_l$ = -84						; size = 4
_msg2$ = -80						; size = 32
_msg1$ = -48						; size = 32
_real_entrysize$ = -16					; size = 4
_numelems$ = -12					; size = 4
_version$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_info$ = 12						; size = 4
_stat$ = 16						; size = 4
_flags$ = 20						; size = 4
_Mod_LoadLump PROC					; COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 225  : 	int	version = ((dheader_t *)in)->version;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _version$[ebp], ecx

; 226  : 	size_t	numelems, real_entrysize;
; 227  : 	char	msg1[32], msg2[32];
; 228  : 	dlump_t	*l = NULL;

	mov	DWORD PTR _l$[ebp], 0

; 229  : 
; 230  : 	if( FBitSet( info->flags, USE_EXTRAHEADER ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2
	je	SHORT $LN2@Mod_LoadLu

; 231  : 	{
; 232  : 		dextrahdr_t *header = (dextrahdr_t *)((byte *)in + sizeof( dheader_t ));

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 124				; 0000007cH
	mov	DWORD PTR _header$2[ebp], eax

; 233  : 		if( header->id != IDEXTRAHEADER || header->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _header$2[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN5@Mod_LoadLu
	mov	eax, DWORD PTR _header$2[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN4@Mod_LoadLu
$LN5@Mod_LoadLu:

; 234  : 			return;

	jmp	$LN1@Mod_LoadLu
$LN4@Mod_LoadLu:

; 235  : 		l = &header->lumps[info->lumpnumber];

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _header$2[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+8]
	mov	DWORD PTR _l$[ebp], eax

; 236  : 	}

	jmp	SHORT $LN3@Mod_LoadLu
$LN2@Mod_LoadLu:

; 237  : 	else
; 238  : 	{
; 239  : 		dheader_t	*header = (dheader_t *)in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _header$1[ebp], eax

; 240  : 		l = &header->lumps[info->lumpnumber];

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _header$1[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR _l$[ebp], eax
$LN3@Mod_LoadLu:

; 241  : 	}
; 242  : 
; 243  : 	// lump is unused by engine for some reasons ?
; 244  : 	if( !l || info->entrysize <= 0 || info->maxcount <= 0 )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $LN7@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN7@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 0
	ja	SHORT $LN6@Mod_LoadLu
$LN7@Mod_LoadLu:

; 245  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN6@Mod_LoadLu:

; 246  : 
; 247  : 	real_entrysize = info->entrysize; // default

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _real_entrysize$[ebp], ecx

; 248  : 
; 249  : 	// analyze real entrysize
; 250  : 	if( version == QBSP2_VERSION && info->entrysize32 > 0 )

	cmp	DWORD PTR _version$[ebp], 844124994	; 32505342H
	jne	SHORT $LN8@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN8@Mod_LoadLu

; 251  : 	{
; 252  : 		// always use alternate entrysize for BSP2
; 253  : 		real_entrysize = info->entrysize32;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _real_entrysize$[ebp], ecx

; 254  : 	}

	jmp	SHORT $LN9@Mod_LoadLu
$LN8@Mod_LoadLu:

; 255  : 	else if( info->lumpnumber == LUMP_CLIPNODES && version != Q1BSP_VERSION )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 9
	jne	SHORT $LN9@Mod_LoadLu
	cmp	DWORD PTR _version$[ebp], 29		; 0000001dH
	je	SHORT $LN9@Mod_LoadLu

; 256  : 	{
; 257  : 		// never run this check for BSP29 because Arguire QBSP 'broken' clipnodes!
; 258  : 		if(( l->filelen % info->entrysize ) || ( l->filelen / info->entrysize ) >= MAX_MAP_CLIPNODES )

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cdq
	idiv	DWORD PTR [ecx+12]
	test	edx, edx
	jne	SHORT $LN12@Mod_LoadLu
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cdq
	idiv	DWORD PTR [ecx+12]
	cmp	eax, 32767				; 00007fffH
	jl	SHORT $LN9@Mod_LoadLu
$LN12@Mod_LoadLu:

; 259  : 		{
; 260  : 			real_entrysize = info->entrysize32;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _real_entrysize$[ebp], ecx

; 261  : 			SetBits( flags, LUMP_SILENT ); // shut up warning

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4
	mov	DWORD PTR _flags$[ebp], eax
$LN9@Mod_LoadLu:

; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	// bmodels not required the visibility
; 266  : 	if( !FBitSet( flags, LUMP_TESTONLY ) && !world.loading && info->lumpnumber == LUMP_VISIBILITY )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	SHORT $LN13@Mod_LoadLu
	cmp	DWORD PTR _world, 0
	jne	SHORT $LN13@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax], 4
	jne	SHORT $LN13@Mod_LoadLu

; 267  : 		SetBits( flags, LUMP_SILENT ); // shut up warning

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4
	mov	DWORD PTR _flags$[ebp], eax
$LN13@Mod_LoadLu:

; 268  : 
; 269  : 	// fill the stats for world
; 270  : 	if( FBitSet( flags, LUMP_SAVESTATS ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN14@Mod_LoadLu

; 271  : 	{
; 272  : 		stat->lumpname = info->loadname;

	mov	eax, DWORD PTR _stat$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx

; 273  : 		stat->entrysize = real_entrysize;

	mov	eax, DWORD PTR _stat$[ebp]
	mov	ecx, DWORD PTR _real_entrysize$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 274  : 		stat->maxcount = info->maxcount;

	mov	eax, DWORD PTR _stat$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 275  : 		if( real_entrysize != 0 )

	cmp	DWORD PTR _real_entrysize$[ebp], 0
	je	SHORT $LN14@Mod_LoadLu

; 276  : 			stat->count = l->filelen / real_entrysize;

	mov	eax, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	mov	ecx, DWORD PTR _stat$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN14@Mod_LoadLu:

; 277  : 	}
; 278  : 
; 279  : 	Q_strncpy( msg1, info->loadname, sizeof( msg1 ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	lea	edx, DWORD PTR _msg1$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 280  : 	Q_strncpy( msg2, info->loadname, sizeof( msg2 ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	lea	edx, DWORD PTR _msg2$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 281  : 	msg2[0] = Q_toupper( msg2[0] ); // first letter in cap

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _msg2$[ebp+ecx]
	push	edx
	call	_Q_toupper
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _msg2$[ebp+edx], al

; 282  : 
; 283  : 	// lump is not present
; 284  : 	if( l->filelen <= 0 )

	mov	eax, DWORD PTR _l$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN16@Mod_LoadLu

; 285  : 	{
; 286  : 		// don't warn about extra lumps - it's optional
; 287  : 		if( !FBitSet( info->flags, USE_EXTRAHEADER ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2
	jne	SHORT $LN17@Mod_LoadLu

; 288  : 		{
; 289  : 			// some data array that may be optional
; 290  : 			if( real_entrysize == sizeof( byte ))

	cmp	DWORD PTR _real_entrysize$[ebp], 1
	jne	SHORT $LN18@Mod_LoadLu

; 291  : 			{
; 292  : 				if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN20@Mod_LoadLu

; 293  : 				{
; 294  : 					Con_DPrintf( S_WARN "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0CD@FBEFGCON@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 295  : 					loadstat.numwarnings++;

	mov	eax, DWORD PTR _loadstat+68
	add	eax, 1
	mov	DWORD PTR _loadstat+68, eax
$LN20@Mod_LoadLu:

; 296  : 				}
; 297  : 			}

	jmp	SHORT $LN17@Mod_LoadLu
$LN18@Mod_LoadLu:

; 298  : 			else if( info->mincount > 0 )

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $LN17@Mod_LoadLu

; 299  : 			{
; 300  : 				// it has the mincount and the lump is completely missed!
; 301  : 				if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN22@Mod_LoadLu

; 302  : 					Con_DPrintf( S_ERROR "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0CB@BLAKDKDN@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5?$CFs@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN22@Mod_LoadLu:

; 303  : 				loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax
$LN17@Mod_LoadLu:

; 304  : 			}
; 305  : 		}
; 306  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN16@Mod_LoadLu:

; 307  : 	}
; 308  : 
; 309  : 	if( l->filelen % real_entrysize )

	mov	eax, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	test	edx, edx
	je	SHORT $LN23@Mod_LoadLu

; 310  : 	{
; 311  : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN24@Mod_LoadLu

; 312  : 			Con_DPrintf( S_ERROR "Mod_Load%s: funny lump size\n", msg2 );

	lea	eax, DWORD PTR _msg2$[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@JCBLNEDP@?$FO1Error?3?$FO7?5Mod_Load?$CFs?3?5funny?5lu@
	call	_Con_DPrintf
	add	esp, 8
$LN24@Mod_LoadLu:

; 313  : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 314  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN23@Mod_LoadLu:

; 315  : 	}
; 316  : 
; 317  : 	numelems = l->filelen / real_entrysize;

	mov	eax, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [eax+4]
	xor	edx, edx
	div	DWORD PTR _real_entrysize$[ebp]
	mov	DWORD PTR _numelems$[ebp], eax

; 318  : 
; 319  : 	if( numelems < info->mincount )

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _numelems$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN25@Mod_LoadLu

; 320  : 	{
; 321  : 		// it has the mincount and it's smaller than this limit
; 322  : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN26@Mod_LoadLu

; 323  : 			Con_DPrintf( S_ERROR "map ^2%s^7 has no %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0CB@BLAKDKDN@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5no?5?$CFs@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN26@Mod_LoadLu:

; 324  : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 325  : 		return;

	jmp	$LN1@Mod_LoadLu
$LN25@Mod_LoadLu:

; 326  : 	}
; 327  : 
; 328  : 	if( numelems > info->maxcount )

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _numelems$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	SHORT $LN27@Mod_LoadLu

; 329  : 	{
; 330  : 		// it has the maxcount and it's overflowed
; 331  : 		if( FBitSet( info->flags, CHECK_OVERFLOW ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	je	SHORT $LN28@Mod_LoadLu

; 332  : 		{
; 333  : 			if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN30@Mod_LoadLu

; 334  : 				Con_DPrintf( S_ERROR "map ^2%s^7 has too many %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0CH@OFCIPOAE@?$FO1Error?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too?5m@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN30@Mod_LoadLu:

; 335  : 			loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax

; 336  : 			return;

	jmp	SHORT $LN1@Mod_LoadLu

; 337  : 		}

	jmp	SHORT $LN27@Mod_LoadLu
$LN28@Mod_LoadLu:

; 338  : 		else if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN27@Mod_LoadLu

; 339  : 		{
; 340  : 			// just throw warning
; 341  : 			Con_DPrintf( S_WARN "map ^2%s^7 has too many %s\n", loadstat.name, msg1 );

	lea	eax, DWORD PTR _msg1$[ebp]
	push	eax
	push	OFFSET _loadstat
	push	OFFSET ??_C@_0CJ@EBAPCGFM@?$FO3Warning?3?$FO7?5map?5?$FO2?$CFs?$FO7?5has?5too@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 342  : 			loadstat.numwarnings++;

	mov	eax, DWORD PTR _loadstat+68
	add	eax, 1
	mov	DWORD PTR _loadstat+68, eax
$LN27@Mod_LoadLu:

; 343  : 		}
; 344  : 	}
; 345  : 
; 346  : 	if( FBitSet( flags, LUMP_TESTONLY ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN32@Mod_LoadLu

; 347  : 		return; // don't fill the intermediate struct

	jmp	SHORT $LN1@Mod_LoadLu
$LN32@Mod_LoadLu:

; 348  : 
; 349  : 	// all checks are passed, store pointers
; 350  : 	if( info->dataptr ) *info->dataptr = (void *)(in + l->fileofs);

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN33@Mod_LoadLu
	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [eax], ecx
$LN33@Mod_LoadLu:

; 351  : 	if( info->count ) *info->count = numelems;

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN1@Mod_LoadLu
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _numelems$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@Mod_LoadLu:

; 352  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_PrintWorldStats_f
_TEXT	SEGMENT
tv197 = -84						; size = 4
tv187 = -84						; size = 4
tv177 = -84						; size = 4
tv160 = -84						; size = 4
tv154 = -84						; size = 4
_stat$1 = -16						; size = 4
_w$ = -12						; size = 4
_totalmemory$ = -8					; size = 4
_i$ = -4						; size = 4
_Mod_PrintWorldStats_f PROC				; COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 407  : 	int	i, totalmemory = 0;

	mov	DWORD PTR _totalmemory$[ebp], 0

; 408  : 	model_t	*w = worldmodel;

	mov	eax, DWORD PTR _worldmodel
	mov	DWORD PTR _w$[ebp], eax

; 409  : 
; 410  : 	if( !w || !w->numsubmodels )

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN6@Mod_PrintW
	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+120], 0
	jne	SHORT $LN5@Mod_PrintW
$LN6@Mod_PrintW:

; 411  : 	{
; 412  : 		Con_Printf( "No map loaded\n" );

	push	OFFSET ??_C@_0P@NJOFMENC@No?5map?5loaded?6@
	call	_Con_Printf
	add	esp, 4

; 413  : 		return;

	jmp	$LN1@Mod_PrintW
$LN5@Mod_PrintW:

; 414  : 	}
; 415  : 
; 416  : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 417  : 	Con_Printf( "Object names  Objects/Maxobjs  Memory / Maxmem  Fullness\n" );

	push	OFFSET ??_C@_0DK@CJHLEKBM@Object?5names?5?5Objects?1Maxobjs?5?5@
	call	_Con_Printf
	add	esp, 4

; 418  : 	Con_Printf( "------------  ---------------  ---------------  --------\n" );

	push	OFFSET ??_C@_0DK@NCLGKDEM@?9?9?9?9?9?9?9?9?9?9?9?9?5?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5?5@
	call	_Con_Printf
	add	esp, 4

; 419  : 
; 420  : 	for( i = 0; i < ARRAYSIZE( worldstats ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_PrintW
$LN2@Mod_PrintW:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_PrintW:
	cmp	DWORD PTR _i$[ebp], 27			; 0000001bH
	jae	$LN3@Mod_PrintW

; 421  : 	{
; 422  : 		mlumpstat_t *stat = &worldstats[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _worldstats
	mov	DWORD PTR _stat$1[ebp], eax

; 423  : 
; 424  : 		if( !stat->lumpname || !stat->maxcount || !stat->count )

	mov	eax, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Mod_PrintW
	mov	eax, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN8@Mod_PrintW
	mov	eax, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN7@Mod_PrintW
$LN8@Mod_PrintW:

; 425  : 			continue; // unused or lump is empty

	jmp	SHORT $LN2@Mod_PrintW
$LN7@Mod_PrintW:

; 426  : 
; 427  : 		if( stat->entrysize == sizeof( byte ))

	mov	eax, DWORD PTR _stat$1[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN9@Mod_PrintW

; 428  : 			totalmemory += Mod_GlobUsage( stat->lumpname, stat->count, stat->maxcount );

	mov	eax, DWORD PTR _stat$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _stat$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _stat$1[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_Mod_GlobUsage
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _totalmemory$[ebp]
	mov	DWORD PTR _totalmemory$[ebp], eax
	jmp	SHORT $LN10@Mod_PrintW
$LN9@Mod_PrintW:

; 429  : 		else totalmemory += Mod_ArrayUsage( stat->lumpname, stat->count, stat->maxcount, stat->entrysize );

	mov	eax, DWORD PTR _stat$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _stat$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _stat$1[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _stat$1[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_Mod_ArrayUsage
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _totalmemory$[ebp]
	mov	DWORD PTR _totalmemory$[ebp], eax
$LN10@Mod_PrintW:

; 430  : 	}

	jmp	$LN2@Mod_PrintW
$LN3@Mod_PrintW:

; 431  : 
; 432  : 	Con_Printf( "=== Total BSP file data space used: %s ===\n", Q_memprint( totalmemory ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _totalmemory$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0CM@IHJJKKPB@?$DN?$DN?$DN?5Total?5BSP?5file?5data?5space?5u@
	call	_Con_Printf
	add	esp, 8

; 433  : 	Con_Printf( "World size ( %g %g %g ) units\n", world.size[0], world.size[1], world.size[2] );

	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR _world[eax+2620]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _world[ecx+2620]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm0, DWORD PTR _world[eax+2620]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BP@HPFFJPPF@World?5size?5?$CI?5?$CFg?5?$CFg?5?$CFg?5?$CJ?5units?6@
	call	_Con_Printf
	add	esp, 28					; 0000001cH

; 434  : 	Con_Printf( "Supports transparency world water: %s\n", FBitSet( world.flags, FWORLD_WATERALPHA ) ? "Yes" : "No" );

	mov	eax, DWORD PTR _world+8
	and	eax, 4
	je	SHORT $LN12@Mod_PrintW
	mov	DWORD PTR tv154[ebp], OFFSET ??_C@_03CCLAEDDF@Yes@
	jmp	SHORT $LN13@Mod_PrintW
$LN12@Mod_PrintW:
	mov	DWORD PTR tv154[ebp], OFFSET ??_C@_02JINPPBEP@No@
$LN13@Mod_PrintW:
	mov	ecx, DWORD PTR tv154[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@GEMHJKNN@Supports?5transparency?5world?5wat@
	call	_Con_Printf
	add	esp, 8

; 435  : 	Con_Printf( "Lighting: %s\n", FBitSet( w->flags, MODEL_COLORED_LIGHTING ) ? "colored" : "monochrome" );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 16					; 00000010H
	je	SHORT $LN14@Mod_PrintW
	mov	DWORD PTR tv160[ebp], OFFSET ??_C@_07FDKIFLAA@colored@
	jmp	SHORT $LN15@Mod_PrintW
$LN14@Mod_PrintW:
	mov	DWORD PTR tv160[ebp], OFFSET ??_C@_0L@FEJFGKNE@monochrome@
$LN15@Mod_PrintW:
	mov	edx, DWORD PTR tv160[ebp]
	push	edx
	push	OFFSET ??_C@_0O@KBDFHKBH@Lighting?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 436  : 	Con_Printf( "World total leafs: %d\n", worldmodel->numleafs + 1 );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+136]
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0BH@JEPAGEFC@World?5total?5leafs?3?5?$CFd?6@
	call	_Con_Printf
	add	esp, 8

; 437  : 	Con_Printf( "original name: ^1%s\n", worldmodel->name );

	mov	eax, DWORD PTR _worldmodel
	push	eax
	push	OFFSET ??_C@_0BF@OKPHAEMF@original?5name?3?5?$FO1?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 438  : 	Con_Printf( "internal name: %s\n", (world.message[0]) ? va( "^2%s", world.message ) : "none" );

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _world[ecx+12]
	test	edx, edx
	je	SHORT $LN16@Mod_PrintW
	push	OFFSET _world+12
	push	OFFSET ??_C@_04NOEIOHFM@?$FO2?$CFs@
	call	_va
	add	esp, 8
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN17@Mod_PrintW
$LN16@Mod_PrintW:
	mov	DWORD PTR tv177[ebp], OFFSET ??_C@_04CGFJFPFD@none@
$LN17@Mod_PrintW:
	mov	eax, DWORD PTR tv177[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@OCIFFDNI@internal?5name?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 439  : 	Con_Printf( "map compiler: %s\n", (world.compiler[0]) ? va( "^3%s", world.compiler ) : "unknown" );

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _world[ecx+2060]
	test	edx, edx
	je	SHORT $LN18@Mod_PrintW
	push	OFFSET _world+2060
	push	OFFSET ??_C@_04GGPEIADJ@?$FO3?$CFs@
	call	_va
	add	esp, 8
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN19@Mod_PrintW
$LN18@Mod_PrintW:
	mov	DWORD PTR tv187[ebp], OFFSET ??_C@_07CIFAGBMG@unknown@
$LN19@Mod_PrintW:
	mov	eax, DWORD PTR tv187[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@JFEJOENI@map?5compiler?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 440  : 	Con_Printf( "map editor: %s\n", (world.generator[0]) ? va( "^2%s", world.generator ) : "unknown" );

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _world[ecx+2316]
	test	edx, edx
	je	SHORT $LN20@Mod_PrintW
	push	OFFSET _world+2316
	push	OFFSET ??_C@_04NOEIOHFM@?$FO2?$CFs@
	call	_va
	add	esp, 8
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN21@Mod_PrintW
$LN20@Mod_PrintW:
	mov	DWORD PTR tv197[ebp], OFFSET ??_C@_07CIFAGBMG@unknown@
$LN21@Mod_PrintW:
	mov	eax, DWORD PTR tv197[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@HMHCEHFL@map?5editor?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN1@Mod_PrintW:

; 441  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_PrintWorldStats_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_UnloadBrushModel
_TEXT	SEGMENT
tv70 = -76						; size = 4
_i$ = -8						; size = 4
_tx$ = -4						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadBrushModel PROC				; COMDAT

; 2812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2813 : 	texture_t	*tx;
; 2814 : 	int	i;
; 2815 : 
; 2816 : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN10@Mod_Unload
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN11@Mod_Unload
$LN10@Mod_Unload:
	mov	DWORD PTR tv70[ebp], 0
$LN11@Mod_Unload:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadBrushModel@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2817 : 
; 2818 : 	if( mod->type != mod_brush )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN5@Mod_Unload

; 2819 : 		return; // not a bmodel

	jmp	$LN1@Mod_Unload
$LN5@Mod_Unload:

; 2820 : 
; 2821 : 	if( mod->name[0] != '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	$LN6@Mod_Unload

; 2822 : 	{
; 2823 : 		for( i = 0; i < mod->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Unload
$LN2@Mod_Unload:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Unload:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@Mod_Unload

; 2824 : 		{
; 2825 : 			tx = mod->textures[i];

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _tx$[ebp], eax

; 2826 : 			if( !tx || tx->gl_texturenum == tr.defaultTexture )

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN8@Mod_Unload
	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _tr
	jne	SHORT $LN7@Mod_Unload
$LN8@Mod_Unload:

; 2827 : 				continue;	// free slot

	jmp	SHORT $LN2@Mod_Unload
$LN7@Mod_Unload:

; 2828 : 
; 2829 : 			GL_FreeTexture( tx->gl_texturenum );	// main texture

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 2830 : 			GL_FreeTexture( tx->fb_texturenum );	// luma texture

	mov	eax, DWORD PTR _tx$[ebp]
	movzx	ecx, WORD PTR [eax+52]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 2831 : 		}

	jmp	SHORT $LN2@Mod_Unload
$LN3@Mod_Unload:

; 2832 : 		Mem_FreePool( &mod->mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadBrushModel@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH
$LN6@Mod_Unload:

; 2833 : 	}
; 2834 : 
; 2835 : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_Unload:

; 2836 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadBrushModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_GetPVSForPoint
_TEXT	SEGMENT
tv145 = -80						; size = 4
tv139 = -76						; size = 4
_leaf$ = -8						; size = 4
_node$ = -4						; size = 4
_p$ = 8							; size = 4
_Mod_GetPVSForPoint PROC				; COMDAT

; 524  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 525  : 	mnode_t	*node;
; 526  : 	mleaf_t	*leaf = NULL;

	mov	DWORD PTR _leaf$[ebp], 0

; 527  : 
; 528  : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN4@Mod_GetPVS
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_GetPVSForPoint@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mod_GetPVS:

; 529  : 
; 530  : 	node = worldmodel->nodes;

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	mov	DWORD PTR _node$[ebp], ecx
$LN2@Mod_GetPVS:

; 531  : 
; 532  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Mod_GetPVS

; 533  : 	{
; 534  : 		if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@Mod_GetPVS

; 535  : 		{
; 536  : 			leaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$[ebp], eax

; 537  : 			break; // we found a leaf

	jmp	$LN3@Mod_GetPVS
$LN5@Mod_GetPVS:

; 538  : 		}
; 539  : 		node = node->children[PlaneDiff( p, node->plane ) <= 0];

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN8@Mod_GetPVS
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN9@Mod_GetPVS
$LN8@Mod_GetPVS:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv139[ebp], xmm0
$LN9@Mod_GetPVS:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv139[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jb	SHORT $LN10@Mod_GetPVS
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN11@Mod_GetPVS
$LN10@Mod_GetPVS:
	mov	DWORD PTR tv145[ebp], 0
$LN11@Mod_GetPVS:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _node$[ebp], eax

; 540  : 	}

	jmp	$LN2@Mod_GetPVS
$LN3@Mod_GetPVS:

; 541  : 
; 542  : 	if( leaf && leaf->cluster >= 0 )

	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN6@Mod_GetPVS
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN6@Mod_GetPVS

; 543  : 		return Mod_DecompressPVS( leaf->compressed_vis, world.visbytes );

	mov	eax, DWORD PTR _world+2588
	push	eax
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_Mod_DecompressPVS
	add	esp, 8
	jmp	SHORT $LN1@Mod_GetPVS
$LN6@Mod_GetPVS:

; 544  : 	return NULL;

	xor	eax, eax
$LN1@Mod_GetPVS:

; 545  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetPVSForPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_SampleSizeForFace
_TEXT	SEGMENT
_surf$ = 8						; size = 4
_Mod_SampleSizeForFace PROC				; COMDAT

; 871  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 872  : 	if( !surf || !surf->texinfo )

	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN3@Mod_Sample
	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN2@Mod_Sample
$LN3@Mod_Sample:

; 873  : 		return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN1@Mod_Sample
$LN2@Mod_Sample:

; 874  : 
; 875  : 	// world luxels has more priority
; 876  : 	if( FBitSet( surf->texinfo->flags, TEX_WORLD_LUXELS ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 2
	je	SHORT $LN4@Mod_Sample

; 877  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Sample
$LN4@Mod_Sample:

; 878  : 
; 879  : 	if( FBitSet( surf->texinfo->flags, TEX_EXTRA_LIGHTMAP ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 8
	je	SHORT $LN5@Mod_Sample

; 880  : 		return LM_SAMPLE_EXTRASIZE;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_Sample
$LN5@Mod_Sample:

; 881  : 
; 882  : 	if( surf->texinfo->faceinfo )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN6@Mod_Sample

; 883  : 		return surf->texinfo->faceinfo->texture_step;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+32]
	movzx	eax, WORD PTR [edx+16]
	jmp	SHORT $LN1@Mod_Sample
$LN6@Mod_Sample:

; 884  : 
; 885  : 	return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
$LN1@Mod_Sample:

; 886  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SampleSizeForFace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_AmbientLevels
_TEXT	SEGMENT
_leaf$ = -4						; size = 4
_p$ = 8							; size = 4
_pvolumes$ = 12						; size = 4
_Mod_AmbientLevels PROC					; COMDAT

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 757  : 	mleaf_t	*leaf;
; 758  : 
; 759  : 	if( !worldmodel || !p || !pvolumes )

	cmp	DWORD PTR _worldmodel, 0
	je	SHORT $LN3@Mod_Ambien
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@Mod_Ambien
	cmp	DWORD PTR _pvolumes$[ebp], 0
	jne	SHORT $LN2@Mod_Ambien
$LN3@Mod_Ambien:

; 760  : 		return;	

	jmp	SHORT $LN1@Mod_Ambien
$LN2@Mod_Ambien:

; 761  : 
; 762  : 	leaf = Mod_PointInLeaf( p, worldmodel->nodes );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 763  : 	*(int *)pvolumes = *(int *)leaf->ambient_sound_level;

	mov	eax, DWORD PTR _pvolumes$[ebp]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax], edx
$LN1@Mod_Ambien:

; 764  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_AmbientLevels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_PointInLeaf
_TEXT	SEGMENT
tv147 = -72						; size = 4
tv141 = -68						; size = 4
tv70 = -68						; size = 4
_p$ = 8							; size = 4
_node$ = 12						; size = 4
_Mod_PointInLeaf PROC					; COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 502  : 	Assert( node != NULL );

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN6@Mod_PointI
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@Mod_PointI
$LN6@Mod_PointI:
	mov	DWORD PTR tv70[ebp], 0
$LN7@Mod_PointI:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_PointInLeaf@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H
$LN2@Mod_PointI:

; 503  : 
; 504  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Mod_PointI

; 505  : 	{
; 506  : 		if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN4@Mod_PointI

; 507  : 			return (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@Mod_PointI
$LN4@Mod_PointI:

; 508  : 		node = node->children[PlaneDiff( p, node->plane ) <= 0];

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN8@Mod_PointI
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN9@Mod_PointI
$LN8@Mod_PointI:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv141[ebp], xmm0
$LN9@Mod_PointI:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv141[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jb	SHORT $LN10@Mod_PointI
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN11@Mod_PointI
$LN10@Mod_PointI:
	mov	DWORD PTR tv147[ebp], 0
$LN11@Mod_PointI:
	mov	ecx, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _node$[ebp], eax

; 509  : 	}

	jmp	$LN2@Mod_PointI
$LN3@Mod_PointI:

; 510  : 
; 511  : 	// never reached
; 512  : 	return NULL;

	xor	eax, eax
$LN1@Mod_PointI:

; 513  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_PointInLeaf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_SaveLump
_TEXT	SEGMENT
_f$ = -256						; size = 4
_header$ = -252						; size = 4
_extrahdr$ = -248					; size = 4
_dummy$ = -244						; size = 4
_result$ = -240						; size = 4
_prefetch_size$ = -236					; size = 4
_buffer$ = -232						; size = 228
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpdata$ = 16						; size = 4
_lumpsize$ = 20						; size = 4
_Mod_SaveLump PROC					; COMDAT

; 2987 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2988 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 2989 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 2990 : 	int		result, dummy = lumpsize;

	mov	eax, DWORD PTR _lumpsize$[ebp]
	mov	DWORD PTR _dummy$[ebp], eax

; 2991 : 	dextrahdr_t	*extrahdr;
; 2992 : 	dheader_t		*header;
; 2993 : 	file_t		*f;
; 2994 : 
; 2995 : 	if( !lumpdata || lumpsize <= 0 )

	cmp	DWORD PTR _lumpdata$[ebp], 0
	je	SHORT $LN3@Mod_SaveLu
	cmp	DWORD PTR _lumpsize$[ebp], 0
	jg	SHORT $LN2@Mod_SaveLu
$LN3@Mod_SaveLu:

; 2996 : 		return LUMP_SAVE_NO_DATA;

	mov	eax, 7
	jmp	$LN1@Mod_SaveLu
$LN2@Mod_SaveLu:

; 2997 : 
; 2998 : 	// make sure what .bsp is placed into gamedir and not in pak
; 2999 : 	if( !FS_GetDiskPath( filename, true ))

	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@Mod_SaveLu

; 3000 : 		return LUMP_SAVE_COULDNT_OPEN;

	mov	eax, 1
	jmp	$LN1@Mod_SaveLu
$LN4@Mod_SaveLu:

; 3001 : 
; 3002 : 	// first we should sure what we allow to rewrite this .bsp
; 3003 : 	result = Mod_CheckLump( filename, lump, &dummy );

	lea	eax, DWORD PTR _dummy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lump$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Mod_CheckLump
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 3004 : 
; 3005 : 	if( result != LUMP_LOAD_NOT_EXIST )

	cmp	DWORD PTR _result$[ebp], 6
	je	SHORT $LN5@Mod_SaveLu

; 3006 : 		return result;

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@Mod_SaveLu
$LN5@Mod_SaveLu:

; 3007 : 
; 3008 : 	f = FS_Open( filename, "e+b", true );

	push	1
	push	OFFSET ??_C@_03LBJAIHPG@e?$CLb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 3009 : 
; 3010 : 	if( !f ) return LUMP_SAVE_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN6@Mod_SaveLu
	mov	eax, 1
	jmp	$LN1@Mod_SaveLu
$LN6@Mod_SaveLu:

; 3011 : 
; 3012 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	eax, DWORD PTR _prefetch_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN7@Mod_SaveLu

; 3013 : 	{
; 3014 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3015 : 		return LUMP_SAVE_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_SaveLu
$LN7@Mod_SaveLu:

; 3016 : 	}
; 3017 : 
; 3018 : 	header = (dheader_t *)buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 3019 : 
; 3020 : 	// these checks below are redundant
; 3021 : 	if( header->version != HLBSP_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 30			; 0000001eH
	je	SHORT $LN8@Mod_SaveLu

; 3022 : 	{
; 3023 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3024 : 		return LUMP_SAVE_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_SaveLu
$LN8@Mod_SaveLu:

; 3025 : 	}
; 3026 : 
; 3027 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	eax, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], eax

; 3028 : 
; 3029 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN10@Mod_SaveLu
	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN9@Mod_SaveLu
$LN10@Mod_SaveLu:

; 3030 : 	{
; 3031 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3032 : 		return LUMP_SAVE_NO_EXTRADATA;

	mov	eax, 4
	jmp	$LN1@Mod_SaveLu
$LN9@Mod_SaveLu:

; 3033 : 	}
; 3034 : 
; 3035 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN12@Mod_SaveLu
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN11@Mod_SaveLu
$LN12@Mod_SaveLu:

; 3036 : 	{
; 3037 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3038 : 		return LUMP_SAVE_INVALID_NUM;

	mov	eax, 5
	jmp	$LN1@Mod_SaveLu
$LN11@Mod_SaveLu:

; 3039 : 	}
; 3040 : 
; 3041 : 	if( extrahdr->lumps[lump].filelen != 0 )

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+eax*8+12], 0
	je	SHORT $LN13@Mod_SaveLu

; 3042 : 	{
; 3043 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3044 : 		return LUMP_SAVE_ALREADY_EXIST;

	mov	eax, 6
	jmp	$LN1@Mod_SaveLu
$LN13@Mod_SaveLu:

; 3045 : 	}
; 3046 : 
; 3047 : 	FS_Seek( f, 0, SEEK_END );

	push	2
	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 3048 : 
; 3049 : 	// will be saved later
; 3050 : 	extrahdr->lumps[lump].fileofs = FS_Tell( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	mov	DWORD PTR [edx+ecx*8+8], eax

; 3051 : 	extrahdr->lumps[lump].filelen = lumpsize;

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	mov	edx, DWORD PTR _lumpsize$[ebp]
	mov	DWORD PTR [ecx+eax*8+12], edx

; 3052 : 
; 3053 : 	if( FS_Write( f, lumpdata, lumpsize ) != lumpsize )

	mov	eax, DWORD PTR _lumpsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lumpdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _lumpsize$[ebp]
	je	SHORT $LN14@Mod_SaveLu

; 3054 : 	{
; 3055 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3056 : 		return LUMP_SAVE_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_SaveLu
$LN14@Mod_SaveLu:

; 3057 : 	}
; 3058 : 
; 3059 : 	// update the header
; 3060 : 	FS_Seek( f, sizeof( dheader_t ), SEEK_SET );

	push	0
	push	124					; 0000007cH
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 3061 : 
; 3062 : 	if( FS_Write( f, extrahdr, sizeof( dextrahdr_t )) != sizeof( dextrahdr_t ))

	push	104					; 00000068H
	mov	eax, DWORD PTR _extrahdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	cmp	eax, 104				; 00000068H
	je	SHORT $LN15@Mod_SaveLu

; 3063 : 	{
; 3064 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3065 : 		return LUMP_SAVE_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_SaveLu
$LN15@Mod_SaveLu:

; 3066 : 	}
; 3067 : 
; 3068 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 3069 : 	return LUMP_SAVE_OK;

	xor	eax, eax
$LN1@Mod_SaveLu:

; 3070 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SaveLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_ReadLump
_TEXT	SEGMENT
_length$ = -256						; size = 4
_data$ = -252						; size = 4
_header$ = -248						; size = 4
_extrahdr$ = -244					; size = 4
_prefetch_size$ = -240					; size = 4
_buffer$ = -236						; size = 228
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpdata$ = 16						; size = 4
_lumpsize$ = 20						; size = 4
_Mod_ReadLump PROC					; COMDAT

; 2905 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2906 : 	file_t		*f = FS_Open( filename, "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 2907 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 2908 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 2909 : 	dextrahdr_t	*extrahdr;
; 2910 : 	dheader_t		*header;
; 2911 : 	byte		*data;
; 2912 : 	int		length;
; 2913 : 
; 2914 : 	if( !f ) return LUMP_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@Mod_ReadLu
	mov	eax, 1
	jmp	$LN1@Mod_ReadLu
$LN2@Mod_ReadLu:

; 2915 : 
; 2916 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	eax, DWORD PTR _prefetch_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN3@Mod_ReadLu

; 2917 : 	{
; 2918 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2919 : 		return LUMP_LOAD_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_ReadLu
$LN3@Mod_ReadLu:

; 2920 : 	}
; 2921 : 
; 2922 : 	header = (dheader_t *)buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2923 : 
; 2924 : 	if( header->version != HLBSP_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 30			; 0000001eH
	je	SHORT $LN4@Mod_ReadLu

; 2925 : 	{
; 2926 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2927 : 		return LUMP_LOAD_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_ReadLu
$LN4@Mod_ReadLu:

; 2928 : 	}
; 2929 : 
; 2930 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	eax, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], eax

; 2931 : 
; 2932 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN6@Mod_ReadLu
	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN5@Mod_ReadLu
$LN6@Mod_ReadLu:

; 2933 : 	{
; 2934 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2935 : 		return LUMP_LOAD_NO_EXTRADATA;

	mov	eax, 4
	jmp	$LN1@Mod_ReadLu
$LN5@Mod_ReadLu:

; 2936 : 	}
; 2937 : 
; 2938 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN8@Mod_ReadLu
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN7@Mod_ReadLu
$LN8@Mod_ReadLu:

; 2939 : 	{
; 2940 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2941 : 		return LUMP_LOAD_INVALID_NUM;

	mov	eax, 5
	jmp	$LN1@Mod_ReadLu
$LN7@Mod_ReadLu:

; 2942 : 	}
; 2943 : 
; 2944 : 	if( extrahdr->lumps[lump].filelen <= 0 )

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+eax*8+12], 0
	jg	SHORT $LN9@Mod_ReadLu

; 2945 : 	{
; 2946 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2947 : 		return LUMP_LOAD_NOT_EXIST;

	mov	eax, 6
	jmp	$LN1@Mod_ReadLu
$LN9@Mod_ReadLu:

; 2948 : 	}
; 2949 : 
; 2950 : 	data = malloc( extrahdr->lumps[lump].filelen + 1 );

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+12]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _data$[ebp], eax

; 2951 : 	length = extrahdr->lumps[lump].filelen;

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+12]
	mov	DWORD PTR _length$[ebp], edx

; 2952 : 
; 2953 : 	if( !data )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN10@Mod_ReadLu

; 2954 : 	{
; 2955 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2956 : 		return LUMP_LOAD_MEM_FAILED;

	mov	eax, 7
	jmp	$LN1@Mod_ReadLu
$LN10@Mod_ReadLu:

; 2957 : 	}
; 2958 : 
; 2959 : 	FS_Seek( f, extrahdr->lumps[lump].fileofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+8]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2960 : 
; 2961 : 	if( FS_Read( f, data, length ) != length )

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _length$[ebp]
	je	SHORT $LN11@Mod_ReadLu

; 2962 : 	{
; 2963 : 		free( data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 2964 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2965 : 		return LUMP_LOAD_CORRUPTED;

	mov	eax, 8
	jmp	SHORT $LN1@Mod_ReadLu
$LN11@Mod_ReadLu:

; 2966 : 	}
; 2967 : 
; 2968 : 	data[length] = 0; // write term

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax], 0

; 2969 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2970 : 
; 2971 : 	if( lumpsize )

	cmp	DWORD PTR _lumpsize$[ebp], 0
	je	SHORT $LN12@Mod_ReadLu

; 2972 : 		*lumpsize = length;

	mov	eax, DWORD PTR _lumpsize$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@Mod_ReadLu:

; 2973 : 	*lumpdata = data;

	mov	eax, DWORD PTR _lumpdata$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax], ecx

; 2974 : 
; 2975 : 	return LUMP_LOAD_OK;

	xor	eax, eax
$LN1@Mod_ReadLu:

; 2976 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ReadLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_CheckLump
_TEXT	SEGMENT
_header$ = -248						; size = 4
_extrahdr$ = -244					; size = 4
_prefetch_size$ = -240					; size = 4
_buffer$ = -236						; size = 228
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpsize$ = 16						; size = 4
_Mod_CheckLump PROC					; COMDAT

; 2846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2847 : 	file_t		*f = FS_Open( filename, "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 2848 : 	byte		buffer[sizeof( dheader_t ) + sizeof( dextrahdr_t )];
; 2849 : 	size_t		prefetch_size = sizeof( buffer );

	mov	DWORD PTR _prefetch_size$[ebp], 228	; 000000e4H

; 2850 : 	dextrahdr_t	*extrahdr;
; 2851 : 	dheader_t		*header;
; 2852 : 
; 2853 : 	if( !f ) return LUMP_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@Mod_CheckL
	mov	eax, 1
	jmp	$LN1@Mod_CheckL
$LN2@Mod_CheckL:

; 2854 : 
; 2855 : 	if( FS_Read( f, buffer, prefetch_size ) != prefetch_size )

	mov	eax, DWORD PTR _prefetch_size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _prefetch_size$[ebp]
	je	SHORT $LN3@Mod_CheckL

; 2856 : 	{
; 2857 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2858 : 		return LUMP_LOAD_BAD_HEADER;

	mov	eax, 2
	jmp	$LN1@Mod_CheckL
$LN3@Mod_CheckL:

; 2859 : 	}
; 2860 : 
; 2861 : 	header = (dheader_t *)buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2862 : 
; 2863 : 	if( header->version != HLBSP_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 30			; 0000001eH
	je	SHORT $LN4@Mod_CheckL

; 2864 : 	{
; 2865 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2866 : 		return LUMP_LOAD_BAD_VERSION;

	mov	eax, 3
	jmp	$LN1@Mod_CheckL
$LN4@Mod_CheckL:

; 2867 : 	}
; 2868 : 
; 2869 : 	extrahdr = (dextrahdr_t *)((byte *)buffer + sizeof( dheader_t ));

	lea	eax, DWORD PTR _buffer$[ebp+124]
	mov	DWORD PTR _extrahdr$[ebp], eax

; 2870 : 
; 2871 : 	if( extrahdr->id != IDEXTRAHEADER || extrahdr->version != EXTRA_VERSION )

	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax], 1213415768		; 48534158H
	jne	SHORT $LN6@Mod_CheckL
	mov	eax, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [eax+4], 4
	je	SHORT $LN5@Mod_CheckL
$LN6@Mod_CheckL:

; 2872 : 	{
; 2873 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2874 : 		return LUMP_LOAD_NO_EXTRADATA;

	mov	eax, 4
	jmp	SHORT $LN1@Mod_CheckL
$LN5@Mod_CheckL:

; 2875 : 	}
; 2876 : 
; 2877 : 	if( lump < 0 || lump >= EXTRA_LUMPS )

	cmp	DWORD PTR _lump$[ebp], 0
	jl	SHORT $LN8@Mod_CheckL
	cmp	DWORD PTR _lump$[ebp], 12		; 0000000cH
	jl	SHORT $LN7@Mod_CheckL
$LN8@Mod_CheckL:

; 2878 : 	{
; 2879 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2880 : 		return LUMP_LOAD_INVALID_NUM;

	mov	eax, 5
	jmp	SHORT $LN1@Mod_CheckL
$LN7@Mod_CheckL:

; 2881 : 	}
; 2882 : 
; 2883 : 	if( extrahdr->lumps[lump].filelen <= 0 )

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _extrahdr$[ebp]
	cmp	DWORD PTR [ecx+eax*8+12], 0
	jg	SHORT $LN9@Mod_CheckL

; 2884 : 	{
; 2885 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2886 : 		return LUMP_LOAD_NOT_EXIST;

	mov	eax, 6
	jmp	SHORT $LN1@Mod_CheckL
$LN9@Mod_CheckL:

; 2887 : 	}
; 2888 : 
; 2889 : 	if( lumpsize )

	cmp	DWORD PTR _lumpsize$[ebp], 0
	je	SHORT $LN10@Mod_CheckL

; 2890 : 		*lumpsize = extrahdr->lumps[lump].filelen;

	mov	eax, DWORD PTR _lumpsize$[ebp]
	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR _extrahdr$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8+12]
	mov	DWORD PTR [eax], ecx
$LN10@Mod_CheckL:

; 2891 : 
; 2892 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2893 : 
; 2894 : 	return LUMP_LOAD_OK;

	xor	eax, eax
$LN1@Mod_CheckL:

; 2895 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CheckLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_BoxVisible
_TEXT	SEGMENT
tv94 = -656						; size = 4
_count$ = -524						; size = 4
_i$ = -520						; size = 4
_leafList$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_visbits$ = 16						; size = 4
_Mod_BoxVisible PROC					; COMDAT

; 702  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 703  : 	short	leafList[MAX_BOX_LEAFS];
; 704  : 	int	i, count;
; 705  : 
; 706  : 	if( !visbits || !mins || !maxs )

	cmp	DWORD PTR _visbits$[ebp], 0
	je	SHORT $LN6@Mod_BoxVis
	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN6@Mod_BoxVis
	cmp	DWORD PTR _maxs$[ebp], 0
	jne	SHORT $LN5@Mod_BoxVis
$LN6@Mod_BoxVis:

; 707  : 		return true;

	mov	eax, 1
	jmp	$LN1@Mod_BoxVis
$LN5@Mod_BoxVis:

; 708  : 
; 709  : 	count = Mod_BoxLeafnums( mins, maxs, leafList, MAX_BOX_LEAFS, NULL );

	push	0
	push	256					; 00000100H
	lea	eax, DWORD PTR _leafList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	call	_Mod_BoxLeafnums
	add	esp, 20					; 00000014H
	mov	DWORD PTR _count$[ebp], eax

; 710  : 
; 711  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_BoxVis
$LN2@Mod_BoxVis:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_BoxVis:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@Mod_BoxVis

; 712  : 	{
; 713  : 		if( CHECKVISBIT( visbits, leafList[i] ))

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _leafList$[ebp+eax*2]
	test	ecx, ecx
	jl	SHORT $LN9@Mod_BoxVis
	mov	edx, DWORD PTR _i$[ebp]
	movsx	eax, WORD PTR _leafList$[ebp+edx*2]
	sar	eax, 3
	mov	ecx, DWORD PTR _visbits$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _leafList$[ebp+eax*2]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN10@Mod_BoxVis
$LN9@Mod_BoxVis:
	mov	DWORD PTR tv94[ebp], 0
$LN10@Mod_BoxVis:
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN7@Mod_BoxVis

; 714  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_BoxVis
$LN7@Mod_BoxVis:

; 715  : 	}

	jmp	$LN2@Mod_BoxVis
$LN3@Mod_BoxVis:

; 716  : 	return false;

	xor	eax, eax
$LN1@Mod_BoxVis:

; 717  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_BoxVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_FatPVS
_TEXT	SEGMENT
tv74 = -76						; size = 4
_leaf$ = -8						; size = 4
_bytes$ = -4						; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_visbytes$ = 20						; size = 4
_merge$ = 24						; size = 4
_fullvis$ = 28						; size = 4
_Mod_FatPVS PROC					; COMDAT

; 592  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 593  : 	int	bytes = world.visbytes;

	mov	eax, DWORD PTR _world+2588
	mov	DWORD PTR _bytes$[ebp], eax

; 594  : 	mleaf_t	*leaf = NULL;

	mov	DWORD PTR _leaf$[ebp], 0

; 595  : 
; 596  : 	ASSERT( worldmodel != NULL );

	cmp	DWORD PTR _worldmodel, 0
	jne	SHORT $LN2@Mod_FatPVS
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_FatPVS@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mod_FatPVS:

; 597  : 
; 598  : 	leaf = Mod_PointInLeaf( org, worldmodel->nodes );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 599  : 	bytes = Q_min( bytes, visbytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	cmp	eax, DWORD PTR _visbytes$[ebp]
	jge	SHORT $LN7@Mod_FatPVS
	mov	ecx, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN8@Mod_FatPVS
$LN7@Mod_FatPVS:
	mov	edx, DWORD PTR _visbytes$[ebp]
	mov	DWORD PTR tv74[ebp], edx
$LN8@Mod_FatPVS:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _bytes$[ebp], eax

; 600  : 
; 601  : 	// enable full visibility for some reasons
; 602  : 	if( fullvis || !worldmodel->visdata || !leaf || leaf->cluster < 0 )

	cmp	DWORD PTR _fullvis$[ebp], 0
	jne	SHORT $LN4@Mod_FatPVS
	mov	eax, DWORD PTR _worldmodel
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN4@Mod_FatPVS
	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN4@Mod_FatPVS
	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jge	SHORT $LN3@Mod_FatPVS
$LN4@Mod_FatPVS:

; 603  : 	{
; 604  : 		memset( visbuffer, 0xFF, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _visbuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 605  : 		return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
	jmp	SHORT $LN1@Mod_FatPVS
$LN3@Mod_FatPVS:

; 606  : 	}
; 607  : 
; 608  : 	if( !merge ) memset( visbuffer, 0x00, bytes );

	cmp	DWORD PTR _merge$[ebp], 0
	jne	SHORT $LN5@Mod_FatPVS
	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _visbuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN5@Mod_FatPVS:

; 609  : 
; 610  : 	Mod_FatPVS_RecursiveBSPNode( org, radius, visbuffer, bytes, worldmodel->nodes );

	mov	eax, DWORD PTR _worldmodel
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _visbuffer$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_Mod_FatPVS_RecursiveBSPNode
	add	esp, 20					; 00000014H

; 611  : 
; 612  : 	return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
$LN1@Mod_FatPVS:

; 613  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_HeadnodeVisible
_TEXT	SEGMENT
tv82 = -68						; size = 4
_node$ = 8						; size = 4
_visbits$ = 12						; size = 4
_lastleaf$ = 16						; size = 4
_Mod_HeadnodeVisible PROC				; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 726  : 	if( !node || node->contents == CONTENTS_SOLID )

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN3@Mod_Headno
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN2@Mod_Headno
$LN3@Mod_Headno:

; 727  : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_Headno
$LN2@Mod_Headno:

; 728  : 
; 729  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN4@Mod_Headno

; 730  : 	{
; 731  : 		if( !CHECKVISBIT( visbits, ((mleaf_t *)node)->cluster ))

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN10@Mod_Headno
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	mov	eax, DWORD PTR _visbits$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN11@Mod_Headno
$LN10@Mod_Headno:
	mov	DWORD PTR tv82[ebp], 0
$LN11@Mod_Headno:
	cmp	DWORD PTR tv82[ebp], 0
	jne	SHORT $LN5@Mod_Headno

; 732  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Mod_Headno
$LN5@Mod_Headno:

; 733  : 
; 734  : 		if( lastleaf )

	cmp	DWORD PTR _lastleaf$[ebp], 0
	je	SHORT $LN6@Mod_Headno

; 735  : 			*lastleaf = ((mleaf_t *)node)->cluster;

	mov	eax, DWORD PTR _lastleaf$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax], edx
$LN6@Mod_Headno:

; 736  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN4@Mod_Headno:

; 737  : 	}
; 738  : 
; 739  : 	if( Mod_HeadnodeVisible( node->children[0], visbits, lastleaf ))

	mov	eax, DWORD PTR _lastleaf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _visbits$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@Mod_Headno

; 740  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN7@Mod_Headno:

; 741  : 
; 742  : 	if( Mod_HeadnodeVisible( node->children[1], visbits, lastleaf ))

	mov	eax, DWORD PTR _lastleaf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _visbits$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_Mod_HeadnodeVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@Mod_Headno

; 743  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Headno
$LN8@Mod_Headno:

; 744  : 
; 745  : 	return false;

	xor	eax, eax
$LN1@Mod_Headno:

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_HeadnodeVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_TestBmodelLumps
_TEXT	SEGMENT
tv79 = -80						; size = 4
_flags$ = -12						; size = 4
_i$ = -8						; size = 4
_header$ = -4						; size = 4
_name$ = 8						; size = 4
_mod_base$ = 12						; size = 4
_silent$ = 16						; size = 4
_Mod_TestBmodelLumps PROC				; COMDAT

; 2727 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2728 : 	dheader_t	*header = (dheader_t *)mod_base;

	mov	eax, DWORD PTR _mod_base$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 2729 : 	int	i, flags = LUMP_TESTONLY;

	mov	DWORD PTR _flags$[ebp], 2

; 2730 : 
; 2731 : 	// always reset the intermediate struct
; 2732 : 	memset( &loadstat, 0, sizeof( loadstat_t ));

	push	72					; 00000048H
	push	0
	push	OFFSET _loadstat
	call	_memset
	add	esp, 12					; 0000000cH

; 2733 : 
; 2734 : 	// store the name to correct show errors and warnings
; 2735 : 	Q_strncpy( loadstat.name, name, sizeof( loadstat.name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET _loadstat
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2736 : 	if( silent ) SetBits( flags, LUMP_SILENT );

	cmp	DWORD PTR _silent$[ebp], 0
	je	SHORT $LN10@Mod_TestBm
	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4
	mov	DWORD PTR _flags$[ebp], eax
$LN10@Mod_TestBm:

; 2737 : 
; 2738 : #ifndef SUPPORT_BSP2_FORMAT
; 2739 : 	if( header->version == QBSP2_VERSION )

	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 844124994		; 32505342H
	jne	SHORT $LN11@Mod_TestBm

; 2740 : 	{
; 2741 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN12@Mod_TestBm

; 2742 : 			Con_Printf( S_ERROR DEFAULT_BSP_BUILD_ERROR, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0GF@GACEDHNO@?$FO1Error?3?$FO7?5?$CFs?5can?8t?5be?5loaded?5i@
	call	_Con_Printf
	add	esp, 8
$LN12@Mod_TestBm:

; 2743 : 		return false;

	xor	eax, eax
	jmp	$LN1@Mod_TestBm
$LN11@Mod_TestBm:

; 2744 : 	}
; 2745 : #endif
; 2746 : 	switch( header->version )

	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 29			; 0000001dH
	je	SHORT $LN15@Mod_TestBm
	cmp	DWORD PTR tv79[ebp], 30			; 0000001eH
	je	SHORT $LN15@Mod_TestBm
	cmp	DWORD PTR tv79[ebp], 844124994		; 32505342H
	je	SHORT $LN15@Mod_TestBm
	jmp	SHORT $LN16@Mod_TestBm
$LN15@Mod_TestBm:

; 2747 : 	{
; 2748 : 	case Q1BSP_VERSION:
; 2749 : 	case HLBSP_VERSION:
; 2750 : 	case QBSP2_VERSION:
; 2751 : 		break;

	jmp	SHORT $LN2@Mod_TestBm
$LN16@Mod_TestBm:

; 2752 : 	default:
; 2753 : 		// don't early out: let me analyze errors
; 2754 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN17@Mod_TestBm

; 2755 : 			Con_Printf( S_ERROR "%s has wrong version number (%i should be %i)\n", name, header->version, HLBSP_VERSION );

	push	30					; 0000001eH
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN17@Mod_TestBm:

; 2756 : 		loadstat.numerrors++;

	mov	eax, DWORD PTR _loadstat+64
	add	eax, 1
	mov	DWORD PTR _loadstat+64, eax
$LN2@Mod_TestBm:

; 2757 : 		break;
; 2758 : 	}
; 2759 : 
; 2760 : 	// loading base lumps
; 2761 : 	for( i = 0; i < ARRAYSIZE( srclumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Mod_TestBm
$LN4@Mod_TestBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Mod_TestBm:
	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	jae	SHORT $LN5@Mod_TestBm

; 2762 : 		Mod_LoadLump( mod_base, &srclumps[i], &worldstats[i], flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _worldstats
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 36
	add	edx, OFFSET _srclumps
	push	edx
	mov	eax, DWORD PTR _mod_base$[ebp]
	push	eax
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN4@Mod_TestBm
$LN5@Mod_TestBm:

; 2763 : 
; 2764 : 	// loading extralumps
; 2765 : 	for( i = 0; i < ARRAYSIZE( extlumps ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_TestBm
$LN7@Mod_TestBm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Mod_TestBm:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jae	SHORT $LN8@Mod_TestBm

; 2766 : 		Mod_LoadLump( mod_base, &extlumps[i], &worldstats[ARRAYSIZE( srclumps ) + i], flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 15					; 0000000fH
	shl	ecx, 4
	add	ecx, OFFSET _worldstats
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 36
	add	edx, OFFSET _extlumps
	push	edx
	mov	eax, DWORD PTR _mod_base$[ebp]
	push	eax
	call	_Mod_LoadLump
	add	esp, 16					; 00000010H
	jmp	SHORT $LN7@Mod_TestBm
$LN8@Mod_TestBm:

; 2767 : 
; 2768 : 	if( loadstat.numerrors )

	cmp	DWORD PTR _loadstat+64, 0
	je	SHORT $LN18@Mod_TestBm

; 2769 : 	{
; 2770 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN20@Mod_TestBm

; 2771 : 			Con_Printf( "Mod_LoadWorld: %i error(s), %i warning(s)\n", loadstat.numerrors, loadstat.numwarnings );

	mov	eax, DWORD PTR _loadstat+68
	push	eax
	mov	ecx, DWORD PTR _loadstat+64
	push	ecx
	push	OFFSET ??_C@_0CL@KNKHLIAE@Mod_LoadWorld?3?5?$CFi?5error?$CIs?$CJ?0?5?$CFi?5@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN20@Mod_TestBm:

; 2772 : 		return false; // there were errors, we can't load this map

	xor	eax, eax
	jmp	SHORT $LN1@Mod_TestBm

; 2773 : 	}	

	jmp	SHORT $LN19@Mod_TestBm
$LN18@Mod_TestBm:

; 2774 : 	else if( loadstat.numwarnings )

	cmp	DWORD PTR _loadstat+68, 0
	je	SHORT $LN19@Mod_TestBm

; 2775 : 	{
; 2776 : 		if( !FBitSet( flags, LUMP_SILENT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN19@Mod_TestBm

; 2777 : 			Con_Printf( "Mod_LoadWorld: %i warning(s)\n", loadstat.numwarnings );

	mov	eax, DWORD PTR _loadstat+68
	push	eax
	push	OFFSET ??_C@_0BO@MNJBEEAD@Mod_LoadWorld?3?5?$CFi?5warning?$CIs?$CJ?6@
	call	_Con_Printf
	add	esp, 8
$LN19@Mod_TestBm:

; 2778 : 	}
; 2779 : 
; 2780 : 	return true;

	mov	eax, 1
$LN1@Mod_TestBm:

; 2781 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_TestBmodelLumps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_bmodel.c
;	COMDAT _Mod_LoadBrushModel
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_Mod_LoadBrushModel PROC				; COMDAT

; 2789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2790 : 	if( loaded ) *loaded = false;	

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN2@Mod_LoadBr
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@Mod_LoadBr:

; 2791 : 
; 2792 : 	loadmodel->mempool = Mem_AllocPool( va( "^2%s^7", loadmodel->name ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadBrushModel@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DH@CKBDJDHE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _loadmodel
	mov	DWORD PTR [edx+76], eax

; 2793 : 	loadmodel->type = mod_brush;

	mov	eax, DWORD PTR _loadmodel
	mov	DWORD PTR [eax+68], 0

; 2794 : 
; 2795 : 	// loading all the lumps into heap
; 2796 : 	if( !Mod_LoadBmodelLumps( buffer, world.loading ))

	mov	eax, DWORD PTR _world
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Mod_LoadBmodelLumps
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@Mod_LoadBr

; 2797 : 		return; // there were errors

	jmp	SHORT $LN1@Mod_LoadBr
$LN3@Mod_LoadBr:

; 2798 : 
; 2799 : 	if( world.loading ) worldmodel = mod;

	cmp	DWORD PTR _world, 0
	je	SHORT $LN4@Mod_LoadBr
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _worldmodel, eax
$LN4@Mod_LoadBr:

; 2800 : 
; 2801 : 	if( loaded ) *loaded = true;	// all done

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN1@Mod_LoadBr
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN1@Mod_LoadBr:

; 2802 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadBrushModel ENDP
_TEXT	ENDS
END
