; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_backend.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_r_skyBoxInfo
PUBLIC	_r_envMapInfo
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_stats:BYTE:048H
COMM	_r_speeds_msg:BYTE:0400H
_DATA	ENDS
CONST	SEGMENT
_r_skyBoxInfo DD 000000000r			; 0
	DD	043870000r			; 270
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	043340000r			; 180
	DD	010000H
	DD	0c2b40000r			; -90
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	010000H
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	043340000r			; 180
	DD	010000H
_r_envMapInfo DD 000000000r			; 0
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	00H
	DD	000000000r			; 0
	DD	043340000r			; 180
	DD	0c2b40000r			; -90
	DD	00H
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	00H
	DD	000000000r			; 0
	DD	043870000r			; 270
	DD	043340000r			; 180
	DD	00H
	DD	0c2b40000r			; -90
	DD	043340000r			; 180
	DD	0c2b40000r			; -90
	DD	00H
	DD	042b40000r			; 90
	DD	000000000r			; 0
	DD	042b40000r			; 90
	DD	00H
CONST	ENDS
PUBLIC	_GL_BackendStartFrame
PUBLIC	_GL_BackendEndFrame
PUBLIC	_GL_CleanUpTextureUnits
PUBLIC	_GL_MultiTexCoord2f
PUBLIC	_GL_SetTexCoordArrayMode
PUBLIC	_GL_LoadTexMatrix
PUBLIC	_GL_LoadTexMatrixExt
PUBLIC	_GL_LoadMatrix
PUBLIC	_GL_TexGen
PUBLIC	_GL_SelectTexture
PUBLIC	_GL_CleanupAllTextureUnits
PUBLIC	_GL_LoadIdentityTexMatrix
PUBLIC	_GL_DisableAllTexGens
PUBLIC	_GL_SetRenderMode
PUBLIC	_GL_TextureTarget
PUBLIC	_GL_Cull
PUBLIC	_R_ShowTextures
PUBLIC	_R_ShowTree
PUBLIC	_VID_ScreenShot
PUBLIC	_VID_CubemapShot
PUBLIC	_R_SpeedsMessage
PUBLIC	_R_Speeds_Printf
PUBLIC	_VID_WriteOverviewScript
PUBLIC	_R_DrawLeafNode
PUBLIC	_R_DrawNodeConnection
PUBLIC	_R_ShowTree_r
PUBLIC	??_C@_0BH@OBLNCNBL@Renderer?3?5?$FO1Engine?$FO7?6?6@ ; `string'
PUBLIC	??_C@_0CK@GKGLMGLL@?$CF3i?5wpoly?0?5?$CF3i?5apoly?6?$CF3i?5epoly?0@ ; `string'
PUBLIC	??_C@_0CL@DDFBBACK@visible?5leafs?3?6?$CF3i?5leafs?6curren@ ; `string'
PUBLIC	??_C@_0DF@FAONIALM@ReciusiveWorldNode?3?5?$CF3lf?5secs?6D@ ; `string'
PUBLIC	??_C@_0EB@HAHABGKN@?$CF3i?5alias?5models?5drawn?6?$CF3i?5stud@ ; `string'
PUBLIC	??_C@_0DM@CDKHBBFK@?$CF3i?5static?5entities?6?$CF3i?5normal?5@ ; `string'
PUBLIC	??_C@_0CJ@EAOPFKHG@?$CF3i?5tempents?6?$CF3i?5viewbeams?6?$CF3i?5@ ; `string'
PUBLIC	??_C@_0N@HADAAIKB@?$CF3i?5mirrors?6@		; `string'
PUBLIC	?__LINE__Var@?0??GL_LoadTexMatrixExt@@9@9	; `GL_LoadTexMatrixExt'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BB@GPLEAKIK@glmatrix?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0CP@ECNALKMA@?$FO1Error?3?$FO7?5GL_SelectTexture?3?5ba@ ; `string'
PUBLIC	??_C@_0CP@JCKAIHCE@?$FO1Error?3?$FO7?5GL_TextureTarget?3?5ba@ ; `string'
PUBLIC	??_C@_0BB@JNJCKILF@overviews?1?$CFs?4txt@	; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CK@LIOFGOCF@?1?1?5overview?5description?5file?5fo@ ; `string'
PUBLIC	??_C@_09NCGHNMAH@global?6?$HL?6@		; `string'
PUBLIC	??_C@_0M@PAPOOGH@?7ZOOM?7?$CF?42f?6@		; `string'
PUBLIC	??_C@_0BI@GLEJBJLB@?7ORIGIN?7?$CF?42f?7?$CF?42f?7?$CF?42f?6@ ; `string'
PUBLIC	??_C@_0N@OPHLGBJJ@?7ROTATED?7?$CFi?6@		; `string'
PUBLIC	??_C@_0M@CHJJELD@?$HN?6?6layer?6?$HL?6@		; `string'
PUBLIC	??_C@_0BL@JOKBPGFC@?7IMAGE?7?$CCoverviews?1?$CFs?4bmp?$CC?6@ ; `string'
PUBLIC	??_C@_0O@PKIGLDMP@?7HEIGHT?7?$CF?42f?6@		; `string'
PUBLIC	??_C@_02KGHIDFGE@?$HN?6@			; `string'
PUBLIC	?__LINE__Var@?0??VID_ScreenShot@@9@9		; `VID_ScreenShot'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??VID_CubemapShot@@9@9		; `VID_CubemapShot'::`1'::__LINE__Var
PUBLIC	??_C@_04JCAPCJAP@?4tga@				; `string'
PUBLIC	??_C@_0DJ@GIOCMLAK@use?5?8?$DM?9?8?5and?5?8?9?$DO?8?5keys?5to?5chang@ ; `string'
PUBLIC	??_C@_0P@MJMKNHCG@r_showtextures@		; `string'
PUBLIC	??_C@_0BC@MMDJFPBN@max?5recursion?5?$CFd?6@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40600000
PUBLIC	__real@41800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_AllowDirectPaths:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_FS_Print:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_SaveImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_Process:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_pfnNumberOfEntities:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_CL_DrawCenterPrint:PROC
EXTRN	_CL_CenterPrint:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_R_Set2DMode:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_R_DrawCubemapView:PROC
EXTRN	_Matrix4x4_ToArrayFloatGL:PROC
EXTRN	_GL_Support:PROC
EXTRN	_GL_MaxTextureUnits:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gl_showtextures:DWORD
EXTRN	_r_temppool:DWORD
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	_r_speeds:DWORD
EXTRN	_r_showtree:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40600000
CONST	SEGMENT
__real@40600000 DD 040600000r			; 3.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BC@MMDJFPBN@max?5recursion?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@MMDJFPBN@max?5recursion?5?$CFd?6@ DB 'max recursion %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJMKNHCG@r_showtextures@
CONST	SEGMENT
??_C@_0P@MJMKNHCG@r_showtextures@ DB 'r_showtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GIOCMLAK@use?5?8?$DM?9?8?5and?5?8?9?$DO?8?5keys?5to?5chang@
CONST	SEGMENT
??_C@_0DJ@GIOCMLAK@use?5?8?$DM?9?8?5and?5?8?9?$DO?8?5keys?5to?5chang@ DB 'u'
	DB	'se ''<-'' and ''->'' keys to change atlas page, ESC to quit', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?showHelp@?1??R_ShowTextures@@9@9 DD 01H		; `R_ShowTextures'::`2'::showHelp
_DATA	ENDS
;	COMDAT ??_C@_04JCAPCJAP@?4tga@
CONST	SEGMENT
??_C@_04JCAPCJAP@?4tga@ DB '.tga', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??VID_CubemapShot@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??VID_CubemapShot@@9@9 DD 022fH		; `VID_CubemapShot'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??VID_ScreenShot@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??VID_ScreenShot@@9@9 DD 01ebH		; `VID_ScreenShot'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02KGHIDFGE@?$HN?6@
CONST	SEGMENT
??_C@_02KGHIDFGE@?$HN?6@ DB '}', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKIGLDMP@?7HEIGHT?7?$CF?42f?6@
CONST	SEGMENT
??_C@_0O@PKIGLDMP@?7HEIGHT?7?$CF?42f?6@ DB 09H, 'HEIGHT', 09H, '%.2f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JOKBPGFC@?7IMAGE?7?$CCoverviews?1?$CFs?4bmp?$CC?6@
CONST	SEGMENT
??_C@_0BL@JOKBPGFC@?7IMAGE?7?$CCoverviews?1?$CFs?4bmp?$CC?6@ DB 09H, 'IMA'
	DB	'GE', 09H, '"overviews/%s.bmp"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CHJJELD@?$HN?6?6layer?6?$HL?6@
CONST	SEGMENT
??_C@_0M@CHJJELD@?$HN?6?6layer?6?$HL?6@ DB '}', 0aH, 0aH, 'layer', 0aH, '{'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OPHLGBJJ@?7ROTATED?7?$CFi?6@
CONST	SEGMENT
??_C@_0N@OPHLGBJJ@?7ROTATED?7?$CFi?6@ DB 09H, 'ROTATED', 09H, '%i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GLEJBJLB@?7ORIGIN?7?$CF?42f?7?$CF?42f?7?$CF?42f?6@
CONST	SEGMENT
??_C@_0BI@GLEJBJLB@?7ORIGIN?7?$CF?42f?7?$CF?42f?7?$CF?42f?6@ DB 09H, 'ORI'
	DB	'GIN', 09H, '%.2f', 09H, '%.2f', 09H, '%.2f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PAPOOGH@?7ZOOM?7?$CF?42f?6@
CONST	SEGMENT
??_C@_0M@PAPOOGH@?7ZOOM?7?$CF?42f?6@ DB 09H, 'ZOOM', 09H, '%.2f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NCGHNMAH@global?6?$HL?6@
CONST	SEGMENT
??_C@_09NCGHNMAH@global?6?$HL?6@ DB 'global', 0aH, '{', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LIOFGOCF@?1?1?5overview?5description?5file?5fo@
CONST	SEGMENT
??_C@_0CK@LIOFGOCF@?1?1?5overview?5description?5file?5fo@ DB '// overview'
	DB	' description file for %s.bsp', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNJCKILF@overviews?1?$CFs?4txt@
CONST	SEGMENT
??_C@_0BB@JNJCKILF@overviews?1?$CFs?4txt@ DB 'overviews/%s.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JCKAIHCE@?$FO1Error?3?$FO7?5GL_TextureTarget?3?5ba@
CONST	SEGMENT
??_C@_0CP@JCKAIHCE@?$FO1Error?3?$FO7?5GL_TextureTarget?3?5ba@ DB '^1Error'
	DB	':^7 GL_TextureTarget: bad tmu state %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ECNALKMA@?$FO1Error?3?$FO7?5GL_SelectTexture?3?5ba@
CONST	SEGMENT
??_C@_0CP@ECNALKMA@?$FO1Error?3?$FO7?5GL_SelectTexture?3?5ba@ DB '^1Error'
	DB	':^7 GL_SelectTexture: bad tmu state %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GPLEAKIK@glmatrix?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BB@GPLEAKIK@glmatrix?5?$CB?$DN?5NULL@ DB 'glmatrix != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_backend.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_LoadTexMatrixExt@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_LoadTexMatrixExt@@9@9 DD 08dH	; `GL_LoadTexMatrixExt'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@HADAAIKB@?$CF3i?5mirrors?6@
CONST	SEGMENT
??_C@_0N@HADAAIKB@?$CF3i?5mirrors?6@ DB '%3i mirrors', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EAOPFKHG@?$CF3i?5tempents?6?$CF3i?5viewbeams?6?$CF3i?5@
CONST	SEGMENT
??_C@_0CJ@EAOPFKHG@?$CF3i?5tempents?6?$CF3i?5viewbeams?6?$CF3i?5@ DB '%3i'
	DB	' tempents', 0aH, '%3i viewbeams', 0aH, '%3i particles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@CDKHBBFK@?$CF3i?5static?5entities?6?$CF3i?5normal?5@
CONST	SEGMENT
??_C@_0DM@CDKHBBFK@?$CF3i?5static?5entities?6?$CF3i?5normal?5@ DB '%3i st'
	DB	'atic entities', 0aH, '%3i normal entities', 0aH, '%3i server '
	DB	'entities', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HAHABGKN@?$CF3i?5alias?5models?5drawn?6?$CF3i?5stud@
CONST	SEGMENT
??_C@_0EB@HAHABGKN@?$CF3i?5alias?5models?5drawn?6?$CF3i?5stud@ DB '%3i al'
	DB	'ias models drawn', 0aH, '%3i studio models drawn', 0aH, '%3i '
	DB	'sprites drawn', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FAONIALM@ReciusiveWorldNode?3?5?$CF3lf?5secs?6D@
CONST	SEGMENT
??_C@_0DF@FAONIALM@ReciusiveWorldNode?3?5?$CF3lf?5secs?6D@ DB 'ReciusiveW'
	DB	'orldNode: %3lf secs', 0aH, 'DrawTextureChains %lf', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DDFBBACK@visible?5leafs?3?6?$CF3i?5leafs?6curren@
CONST	SEGMENT
??_C@_0CL@DDFBBACK@visible?5leafs?3?6?$CF3i?5leafs?6curren@ DB 'visible l'
	DB	'eafs:', 0aH, '%3i leafs', 0aH, 'current leaf %3i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GKGLMGLL@?$CF3i?5wpoly?0?5?$CF3i?5apoly?6?$CF3i?5epoly?0@
CONST	SEGMENT
??_C@_0CK@GKGLMGLL@?$CF3i?5wpoly?0?5?$CF3i?5apoly?6?$CF3i?5epoly?0@ DB '%'
	DB	'3i wpoly, %3i apoly', 0aH, '%3i epoly, %3i spoly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBLNCNBL@Renderer?3?5?$FO1Engine?$FO7?6?6@
CONST	SEGMENT
??_C@_0BH@OBLNCNBL@Renderer?3?5?$FO1Engine?$FO7?6?6@ DB 'Renderer: ^1Engi'
	DB	'ne^7', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	05bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03c3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	060dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	033H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_ShowTree_r
_TEXT	SEGMENT
tv66 = -76						; size = 4
_leaf$1 = -8						; size = 4
_downScale$ = -4					; size = 4
_node$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_scale$ = 20						; size = 4
_shownodes$ = 24					; size = 4
_R_ShowTree_r PROC					; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 775  : 	float	downScale = scale * 0.8f;

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _downScale$[ebp], xmm0

; 776  : 
; 777  : 	downScale = Q_max( downScale, 1.0f );

	movss	xmm0, DWORD PTR _downScale$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@R_ShowTree
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN15@R_ShowTree
$LN14@R_ShowTree:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv66[ebp], xmm0
$LN15@R_ShowTree:
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR _downScale$[ebp], xmm0

; 778  : 
; 779  : 	if( !node ) return;

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN2@R_ShowTree
	jmp	$LN1@R_ShowTree
$LN2@R_ShowTree:

; 780  : 
; 781  : 	tr.recursion_level++;

	mov	eax, DWORD PTR _tr+83220
	add	eax, 1
	mov	DWORD PTR _tr+83220, eax

; 782  : 
; 783  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	$LN3@R_ShowTree

; 784  : 	{
; 785  : 		mleaf_t	*leaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leaf$1[ebp], eax

; 786  : 
; 787  : 		if( tr.recursion_level > tr.max_recursion )

	mov	eax, DWORD PTR _tr+83220
	cmp	eax, DWORD PTR _tr+83224
	jle	SHORT $LN4@R_ShowTree

; 788  : 			tr.max_recursion = tr.recursion_level;

	mov	eax, DWORD PTR _tr+83220
	mov	DWORD PTR _tr+83224, eax
$LN4@R_ShowTree:

; 789  : 
; 790  : 		if( shownodes == 1 )

	cmp	DWORD PTR _shownodes$[ebp], 1
	jne	$LN5@R_ShowTree

; 791  : 		{
; 792  : 			if( cl.worldmodel->leafs == leaf )

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+140]
	cmp	ecx, DWORD PTR _leaf$1[ebp]
	jne	SHORT $LN6@R_ShowTree

; 793  : 				pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
	jmp	SHORT $LN9@R_ShowTree
$LN6@R_ShowTree:

; 794  : 			else if( RI.viewleaf && RI.viewleaf == leaf )

	cmp	DWORD PTR _RI+180, 0
	je	SHORT $LN8@R_ShowTree
	mov	eax, DWORD PTR _RI+180
	cmp	eax, DWORD PTR _leaf$1[ebp]
	jne	SHORT $LN8@R_ShowTree

; 795  : 				pglColor4f( 1.0f, 0.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
	jmp	SHORT $LN9@R_ShowTree
$LN8@R_ShowTree:

; 796  : 			else pglColor4f( 0.0f, 1.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN9@R_ShowTree:

; 797  : 			R_DrawLeafNode( x, y, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawLeafNode
	add	esp, 12					; 0000000cH
$LN5@R_ShowTree:

; 798  : 		}
; 799  : 		tr.recursion_level--;

	mov	eax, DWORD PTR _tr+83220
	sub	eax, 1
	mov	DWORD PTR _tr+83220, eax

; 800  : 		return;

	jmp	$LN1@R_ShowTree
$LN3@R_ShowTree:

; 801  : 	}
; 802  : 
; 803  : 	if( shownodes == 1 )

	cmp	DWORD PTR _shownodes$[ebp], 1
	jne	SHORT $LN10@R_ShowTree

; 804  : 	{
; 805  : 		pglColor4f( 0.0f, 0.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 806  : 		R_DrawLeafNode( x, y, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawLeafNode
	add	esp, 12					; 0000000cH

; 807  : 	}

	jmp	$LN12@R_ShowTree
$LN10@R_ShowTree:

; 808  : 	else if( shownodes == 2 )

	cmp	DWORD PTR _shownodes$[ebp], 2
	jne	SHORT $LN12@R_ShowTree

; 809  : 	{
; 810  : 		R_DrawNodeConnection( x, y, x - scale, y + scale );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawNodeConnection
	add	esp, 16					; 00000010H

; 811  : 		R_DrawNodeConnection( x, y, x + scale, y + scale );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawNodeConnection
	add	esp, 16					; 00000010H
$LN12@R_ShowTree:

; 812  : 	}
; 813  : 
; 814  : 	R_ShowTree_r( node->children[1], x - scale, y + scale, downScale, shownodes );

	mov	eax, DWORD PTR _shownodes$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 815  : 	R_ShowTree_r( node->children[0], x + scale, y + scale, downScale, shownodes );

	mov	eax, DWORD PTR _shownodes$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _scale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 816  : 
; 817  : 	tr.recursion_level--;

	mov	eax, DWORD PTR _tr+83220
	sub	eax, 1
	mov	DWORD PTR _tr+83220, eax
$LN1@R_ShowTree:

; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTree_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_DrawNodeConnection
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_R_DrawNodeConnection PROC				; COMDAT

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 767  : 	pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 768  : 		pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 769  : 		pglVertex2f( x2, y2 );

	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 770  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawNodeConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_DrawLeafNode
_TEXT	SEGMENT
_downScale$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_scale$ = 16						; size = 4
_R_DrawLeafNode PROC					; COMDAT

; 759  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 760  : 	float downScale = scale * 0.25f;// * POINT_SIZE;

	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR _downScale$[ebp], xmm0

; 761  : 
; 762  : 	R_DrawStretchPic( x - downScale * 0.5f, y - downScale * 0.5f, downScale, downScale, 0, 0, 1, 1, tr.particleTexture );

	mov	eax, DWORD PTR _tr+4
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _downScale$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _downScale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	xmm0, DWORD PTR _downScale$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 763  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawLeafNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _VID_WriteOverviewScript
_TEXT	SEGMENT
tv135 = -336						; size = 4
_f$ = -268						; size = 4
_filename$ = -264					; size = 256
_ov$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_VID_WriteOverviewScript PROC				; COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 468  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+217612

; 469  : 	string		filename;
; 470  : 	file_t		*f;
; 471  : 
; 472  : 	Q_snprintf( filename, sizeof( filename ), "overviews/%s.txt", clgame.mapname );

	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0BB@JNJCKILF@overviews?1?$CFs?4txt@
	push	256					; 00000100H
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 473  : 
; 474  : 	f = FS_Open( filename, "w", false );

	push	0
	push	OFFSET ??_C@_01NOFIACDB@w@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 475  : 	if( !f ) return;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@VID_WriteO
	jmp	$LN1@VID_WriteO
$LN2@VID_WriteO:

; 476  : 
; 477  : 	FS_Printf( f, "// overview description file for %s.bsp\n\n", clgame.mapname );

	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0CK@LIOFGOCF@?1?1?5overview?5description?5file?5fo@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 478  : 	FS_Print( f, "global\n{\n" );

	push	OFFSET ??_C@_09NCGHNMAH@global?6?$HL?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 479  : 	FS_Printf( f, "\tZOOM\t%.2f\n", ov->flZoom );

	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+40]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@PAPOOGH@?7ZOOM?7?$CF?42f?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 480  : 	FS_Printf( f, "\tORIGIN\t%.2f\t%.2f\t%.2f\n", ov->origin[0], ov->origin[1], ov->origin[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BI@GLEJBJLB@?7ORIGIN?7?$CF?42f?7?$CF?42f?7?$CF?42f?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 32					; 00000020H

; 481  : 	FS_Printf( f, "\tROTATED\t%i\n", ov->rotated ? 1 : 0 );

	mov	eax, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@VID_WriteO
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN5@VID_WriteO
$LN4@VID_WriteO:
	mov	DWORD PTR tv135[ebp], 0
$LN5@VID_WriteO:
	mov	ecx, DWORD PTR tv135[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OPHLGBJJ@?7ROTATED?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 482  : 	FS_Print( f, "}\n\nlayer\n{\n" );

	push	OFFSET ??_C@_0M@CHJJELD@?$HN?6?6layer?6?$HL?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 483  : 	FS_Printf( f, "\tIMAGE\t\"overviews/%s.bmp\"\n", clgame.mapname );

	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0BL@JOKBPGFC@?7IMAGE?7?$CCoverviews?1?$CFs?4bmp?$CC?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 12					; 0000000cH

; 484  : 	FS_Printf( f, "\tHEIGHT\t%.2f\n", ov->zFar );	// ???

	mov	eax, DWORD PTR _ov$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+32]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@PKIGLDMP@?7HEIGHT?7?$CF?42f?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 16					; 00000010H

; 485  : 	FS_Print( f, "}\n" );

	push	OFFSET ??_C@_02KGHIDFGE@?$HN?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 486  : 
; 487  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@VID_WriteO:

; 488  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_WriteOverviewScript ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_Speeds_Printf
_TEXT	SEGMENT
_text$ = -2056						; size = 2048
_argptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_R_Speeds_Printf PROC					; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2376				; 00000948H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 55   : 	va_list	argptr;
; 56   : 	char	text[2048];
; 57   : 
; 58   : 	va_start( argptr, msg );

	lea	eax, DWORD PTR _msg$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 59   : 	Q_vsprintf( text, msg, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	push	99999					; 0001869fH
	lea	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 60   : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 61   : 
; 62   : 	Q_strncat( r_speeds_msg, text, sizeof( r_speeds_msg ));

	push	1024					; 00000400H
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _r_speeds_msg
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 63   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Speeds_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_SpeedsMessage
_TEXT	SEGMENT
_out$ = 8						; size = 4
_size$ = 12						; size = 4
_R_SpeedsMessage PROC					; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 31   : 	if( clgame.drawFuncs.R_SpeedsMessage != NULL )

	cmp	DWORD PTR _clgame+200, 0
	je	SHORT $LN3@R_SpeedsMe

; 32   : 	{
; 33   : 		if( clgame.drawFuncs.R_SpeedsMessage( out, size ))

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	DWORD PTR _clgame+200
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@R_SpeedsMe

; 34   : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_SpeedsMe
$LN3@R_SpeedsMe:

; 35   : 		// otherwise pass to default handler
; 36   : 	}
; 37   : 
; 38   : 	if( r_speeds->value <= 0 ) return false;

	mov	eax, DWORD PTR _r_speeds
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jb	SHORT $LN4@R_SpeedsMe
	xor	eax, eax
	jmp	SHORT $LN1@R_SpeedsMe
$LN4@R_SpeedsMe:

; 39   : 	if( !out || !size ) return false;

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN6@R_SpeedsMe
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN5@R_SpeedsMe
$LN6@R_SpeedsMe:
	xor	eax, eax
	jmp	SHORT $LN1@R_SpeedsMe
$LN5@R_SpeedsMe:

; 40   : 
; 41   : 	Q_strncpy( out, r_speeds_msg, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET _r_speeds_msg
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 42   : 
; 43   : 	return true;

	mov	eax, 1
$LN1@R_SpeedsMe:

; 44   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpeedsMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _VID_CubemapShot
_TEXT	SEGMENT
tv199 = -356						; size = 4
_result$ = -288						; size = 4
_flags$ = -284						; size = 4
_i$ = -280						; size = 4
_basename$ = -276					; size = 256
_buffer$ = -20						; size = 4
_temp$ = -16						; size = 4
_r_side$ = -12						; size = 4
_r_shot$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_vieworg$ = 16						; size = 4
_skyshot$ = 20						; size = 4
_VID_CubemapShot PROC					; COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 560  : 	rgbdata_t		*r_shot, *r_side;
; 561  : 	byte		*temp = NULL;

	mov	DWORD PTR _temp$[ebp], 0

; 562  : 	byte		*buffer = NULL;

	mov	DWORD PTR _buffer$[ebp], 0

; 563  : 	string		basename;
; 564  : 	int		i = 1, flags, result;

	mov	DWORD PTR _i$[ebp], 1

; 565  : 
; 566  : 	if( !RI.drawWorld || !cl.worldmodel )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN8@VID_Cubema
	cmp	DWORD PTR _cl+4579004, 0
	jne	SHORT $LN7@VID_Cubema
$LN8@VID_Cubema:

; 567  : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN7@VID_Cubema:

; 568  : 
; 569  : 	// make sure the specified size is valid
; 570  : 	while( i < size ) i<<=1;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN3@VID_Cubema
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@VID_Cubema
$LN3@VID_Cubema:

; 571  : 
; 572  : 	if( i != size ) return false;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	je	SHORT $LN9@VID_Cubema
	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN9@VID_Cubema:

; 573  : 	if( size > glState.width || size > glState.height )

	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _glState
	ja	SHORT $LN11@VID_Cubema
	mov	eax, DWORD PTR _size$[ebp]
	cmp	eax, DWORD PTR _glState+4
	jbe	SHORT $LN10@VID_Cubema
$LN11@VID_Cubema:

; 574  : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Cubema
$LN10@VID_Cubema:

; 575  : 
; 576  : 	// setup refdef
; 577  : 	RI.params |= RP_ENVVIEW;	// do not render non-bmodel entities

	mov	eax, DWORD PTR _RI
	or	eax, 2
	mov	DWORD PTR _RI, eax

; 578  : 
; 579  : 	// alloc space
; 580  : 	temp = Mem_Malloc( r_temppool, size * size * 3 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_CubemapShot@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	imul	ecx, DWORD PTR _size$[ebp]
	imul	edx, ecx, 3
	push	edx
	mov	eax, DWORD PTR _r_temppool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 581  : 	buffer = Mem_Malloc( r_temppool, size * size * 3 * 6 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_CubemapShot@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	imul	ecx, DWORD PTR _size$[ebp]
	imul	edx, ecx, 3
	imul	eax, edx, 6
	push	eax
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 582  : 	r_shot = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_CubemapShot@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	36					; 00000024H
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_shot$[ebp], eax

; 583  : 	r_side = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_CubemapShot@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	36					; 00000024H
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_side$[ebp], eax

; 584  : 
; 585  : 	// use client vieworg
; 586  : 	if( !vieworg ) vieworg = RI.vieworg;

	cmp	DWORD PTR _vieworg$[ebp], 0
	jne	SHORT $LN12@VID_Cubema
	mov	DWORD PTR _vieworg$[ebp], OFFSET _RI+200
$LN12@VID_Cubema:

; 587  : 
; 588  : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@VID_Cubema
$LN4@VID_Cubema:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@VID_Cubema:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN5@VID_Cubema

; 589  : 	{
; 590  : 		// go into 3d mode
; 591  : 		R_Set2DMode( false );

	push	0
	call	_R_Set2DMode
	add	esp, 4

; 592  : 
; 593  : 		if( skyshot )

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN13@VID_Cubema

; 594  : 		{
; 595  : 			R_DrawCubemapView( vieworg, r_skyBoxInfo[i].angles, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _r_skyBoxInfo
	push	ecx
	mov	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_R_DrawCubemapView
	add	esp, 12					; 0000000cH

; 596  : 			flags = r_skyBoxInfo[i].flags;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _r_skyBoxInfo[eax+12]
	mov	DWORD PTR _flags$[ebp], ecx

; 597  : 		}

	jmp	SHORT $LN14@VID_Cubema
$LN13@VID_Cubema:

; 598  : 		else
; 599  : 		{
; 600  : 			R_DrawCubemapView( vieworg, r_envMapInfo[i].angles, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _r_envMapInfo
	push	ecx
	mov	edx, DWORD PTR _vieworg$[ebp]
	push	edx
	call	_R_DrawCubemapView
	add	esp, 12					; 0000000cH

; 601  : 			flags = r_envMapInfo[i].flags;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _r_envMapInfo[eax+12]
	mov	DWORD PTR _flags$[ebp], ecx
$LN14@VID_Cubema:

; 602  : 		}
; 603  : 
; 604  : 		pglReadPixels( 0, 0, size, size, GL_RGB, GL_UNSIGNED_BYTE, temp );

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	push	5121					; 00001401H
	push	6407					; 00001907H
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR _pglReadPixels

; 605  : 		r_side->flags = IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [eax+12], 4

; 606  : 		r_side->width = r_side->height = size;

	mov	eax, DWORD PTR _r_side$[ebp]
	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR [eax+2], cx
	mov	edx, DWORD PTR _r_side$[ebp]
	mov	ax, WORD PTR _size$[ebp]
	mov	WORD PTR [edx], ax

; 607  : 		r_side->type = PF_RGB_24;

	mov	eax, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [eax+8], 5

; 608  : 		r_side->size = r_side->width * r_side->height * 3;

	mov	eax, DWORD PTR _r_side$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _r_side$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	imul	ecx, ecx, 3
	mov	edx, DWORD PTR _r_side$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 609  : 		r_side->buffer = temp;

	mov	eax, DWORD PTR _r_side$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 610  : 
; 611  : 		if( flags ) Image_Process( &r_side, 0, 0, flags, 0.0f );

	cmp	DWORD PTR _flags$[ebp], 0
	je	SHORT $LN15@VID_Cubema
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _r_side$[ebp]
	push	ecx
	call	_Image_Process
	add	esp, 20					; 00000014H
$LN15@VID_Cubema:

; 612  : 		memcpy( buffer + (size * size * 3 * i), r_side->buffer, size * size * 3 );

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, DWORD PTR _size$[ebp]
	imul	ecx, eax, 3
	push	ecx
	mov	edx, DWORD PTR _r_side$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	imul	ecx, DWORD PTR _size$[ebp]
	imul	edx, ecx, 3
	imul	edx, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 613  : 	}

	jmp	$LN4@VID_Cubema
$LN5@VID_Cubema:

; 614  : 
; 615  : 	RI.params &= ~RP_ENVVIEW;

	mov	eax, DWORD PTR _RI
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _RI, eax

; 616  : 
; 617  : 	r_shot->flags = IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+12], 4

; 618  : 	r_shot->flags |= (skyshot) ? IMAGE_SKYBOX : IMAGE_CUBEMAP;

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN17@VID_Cubema
	mov	DWORD PTR tv199[ebp], 32		; 00000020H
	jmp	SHORT $LN18@VID_Cubema
$LN17@VID_Cubema:
	mov	DWORD PTR tv199[ebp], 1
$LN18@VID_Cubema:
	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, DWORD PTR tv199[ebp]
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 619  : 	r_shot->width = size;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR [eax], cx

; 620  : 	r_shot->height = size;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	cx, WORD PTR _size$[ebp]
	mov	WORD PTR [eax+2], cx

; 621  : 	r_shot->type = PF_RGB_24;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+8], 5

; 622  : 	r_shot->size = r_shot->width * r_shot->height * 3 * 6;

	mov	eax, DWORD PTR _r_shot$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _r_shot$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	imul	ecx, ecx, 3
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+32], edx

; 623  : 	r_shot->palette = NULL;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+20], 0

; 624  : 	r_shot->buffer = buffer;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 625  : 
; 626  : 	// make sure what we have right extension
; 627  : 	Q_strncpy( basename, base, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _base$[ebp]
	push	eax
	lea	ecx, DWORD PTR _basename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 628  : 	COM_StripExtension( basename );

	lea	eax, DWORD PTR _basename$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 629  : 	COM_DefaultExtension( basename, ".tga" );

	push	OFFSET ??_C@_04JCAPCJAP@?4tga@
	lea	eax, DWORD PTR _basename$[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 630  : 
; 631  : 	// write image as 6 sides
; 632  : 	result = FS_SaveImage( basename, r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _basename$[ebp]
	push	ecx
	call	_FS_SaveImage
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 633  : 	FS_FreeImage( r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 634  : 	FS_FreeImage( r_side );

	mov	eax, DWORD PTR _r_side$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 635  : 
; 636  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@VID_Cubema:

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CubemapShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _VID_ScreenShot
_TEXT	SEGMENT
tv146 = -88						; size = 4
_result$ = -20						; size = 4
_height$ = -16						; size = 4
_width$ = -12						; size = 4
_flags$ = -8						; size = 4
_r_shot$ = -4						; size = 4
_filename$ = 8						; size = 4
_shot_type$ = 12					; size = 4
_VID_ScreenShot PROC					; COMDAT

; 491  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 492  : 	rgbdata_t *r_shot;
; 493  : 	uint	flags = IMAGE_FLIP_Y;

	mov	DWORD PTR _flags$[ebp], 131072		; 00020000H

; 494  : 	int	width = 0, height = 0;

	mov	DWORD PTR _width$[ebp], 0
	mov	DWORD PTR _height$[ebp], 0

; 495  : 	qboolean	result;
; 496  : 
; 497  : 	r_shot = Mem_Calloc( r_temppool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_ScreenShot@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	36					; 00000024H
	mov	ecx, DWORD PTR _r_temppool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _r_shot$[ebp], eax

; 498  : 	r_shot->width = (glState.width + 3) & ~3;

	mov	eax, DWORD PTR _glState
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	WORD PTR [ecx], ax

; 499  : 	r_shot->height = (glState.height + 3) & ~3;

	mov	eax, DWORD PTR _glState+4
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	WORD PTR [ecx+2], ax

; 500  : 	r_shot->flags = IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+12], 4

; 501  : 	r_shot->type = PF_RGB_24;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+8], 5

; 502  : 	r_shot->size = r_shot->width * r_shot->height * PFDesc[r_shot->type].bpp;

	mov	eax, DWORD PTR _r_shot$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _r_shot$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	mov	edx, DWORD PTR _r_shot$[ebp]
	imul	eax, DWORD PTR [edx+8], 28
	imul	ecx, DWORD PTR _PFDesc[eax+24]
	mov	edx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 503  : 	r_shot->palette = NULL;

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [eax+20], 0

; 504  : 	r_shot->buffer = Mem_Malloc( r_temppool, r_shot->size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??VID_ScreenShot@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _r_temppool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _r_shot$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 505  : 
; 506  : 	// get screen frame
; 507  : 	pglReadPixels( 0, 0, r_shot->width, r_shot->height, GL_RGB, GL_UNSIGNED_BYTE, r_shot->buffer );

	mov	eax, DWORD PTR _r_shot$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	5121					; 00001401H
	push	6407					; 00001907H
	mov	edx, DWORD PTR _r_shot$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _r_shot$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	push	0
	push	0
	call	DWORD PTR _pglReadPixels

; 508  : 
; 509  : 	switch( shot_type )

	mov	eax, DWORD PTR _shot_type$[ebp]
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv146[ebp], ecx
	cmp	DWORD PTR tv146[ebp], 3
	ja	$LN2@VID_Screen
	mov	edx, DWORD PTR tv146[ebp]
	jmp	DWORD PTR $LN12@VID_Screen[edx*4]

; 510  : 	{
; 511  : 	case VID_SCREENSHOT:
; 512  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN5@VID_Screen:

; 513  : 	case VID_SNAPSHOT:
; 514  : 		FS_AllowDirectPaths( true );

	push	1
	call	_FS_AllowDirectPaths
	add	esp, 4

; 515  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN6@VID_Screen:

; 516  : 	case VID_LEVELSHOT:
; 517  : 		flags |= IMAGE_RESAMPLE;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1048576				; 00100000H
	mov	DWORD PTR _flags$[ebp], eax

; 518  : 		if( glState.wideScreen )

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN7@VID_Screen

; 519  : 		{
; 520  : 			height = 480;

	mov	DWORD PTR _height$[ebp], 480		; 000001e0H

; 521  : 			width = 800;

	mov	DWORD PTR _width$[ebp], 800		; 00000320H

; 522  : 		}

	jmp	SHORT $LN8@VID_Screen
$LN7@VID_Screen:

; 523  : 		else
; 524  : 		{
; 525  : 			height = 480;

	mov	DWORD PTR _height$[ebp], 480		; 000001e0H

; 526  : 			width = 640;

	mov	DWORD PTR _width$[ebp], 640		; 00000280H
$LN8@VID_Screen:

; 527  : 		}
; 528  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN9@VID_Screen:

; 529  : 	case VID_MINISHOT:
; 530  : 		flags |= IMAGE_RESAMPLE;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1048576				; 00100000H
	mov	DWORD PTR _flags$[ebp], eax

; 531  : 		height = 200;

	mov	DWORD PTR _height$[ebp], 200		; 000000c8H

; 532  : 		width = 320;

	mov	DWORD PTR _width$[ebp], 320		; 00000140H

; 533  : 		break;

	jmp	SHORT $LN2@VID_Screen
$LN10@VID_Screen:

; 534  : 	case VID_MAPSHOT:
; 535  : 		VID_WriteOverviewScript();		// store overview script too

	call	_VID_WriteOverviewScript

; 536  : 		flags |= IMAGE_RESAMPLE|IMAGE_QUANTIZE;	// GoldSrc request overviews in 8-bit format

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 34603008				; 02100000H
	mov	DWORD PTR _flags$[ebp], eax

; 537  : 		height = 768;

	mov	DWORD PTR _height$[ebp], 768		; 00000300H

; 538  : 		width = 1024;

	mov	DWORD PTR _width$[ebp], 1024		; 00000400H
$LN2@VID_Screen:

; 539  : 		break;
; 540  : 	}
; 541  : 
; 542  : 	Image_Process( &r_shot, width, height, flags, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_Image_Process
	add	esp, 20					; 00000014H

; 543  : 
; 544  : 	// write image
; 545  : 	result = FS_SaveImage( filename, r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_SaveImage
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 546  : 	host.write_to_clipboard = false;		// disable write to clipboard

	mov	DWORD PTR _host+34384, 0

; 547  : 	FS_AllowDirectPaths( false );			// always reset after store screenshot

	push	0
	call	_FS_AllowDirectPaths
	add	esp, 4

; 548  : 	FS_FreeImage( r_shot );

	mov	eax, DWORD PTR _r_shot$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 549  : 
; 550  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 551  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@VID_Screen:
	DD	$LN6@VID_Screen
	DD	$LN9@VID_Screen
	DD	$LN10@VID_Screen
	DD	$LN5@VID_Screen
_VID_ScreenShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_ShowTree
_TEXT	SEGMENT
tv71 = -76						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_R_ShowTree PROC					; COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 822  : 	float	x = (float)((glState.width - (int)POINT_SIZE) >> 1);

	mov	eax, DWORD PTR _glState
	sub	eax, 16					; 00000010H
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _x$[ebp], xmm0

; 823  : 	float	y = NODE_INTERVAL_Y(1.0);

	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR _y$[ebp], xmm0

; 824  : 
; 825  : 	if( !cl.worldmodel || !CVAR_TO_BOOL( r_showtree ))

	cmp	DWORD PTR _cl+4579004, 0
	je	SHORT $LN3@R_ShowTree
	cmp	DWORD PTR _r_showtree, 0
	je	SHORT $LN5@R_ShowTree
	mov	eax, DWORD PTR _r_showtree
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_ShowTree
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@R_ShowTree
$LN5@R_ShowTree:
	mov	DWORD PTR tv71[ebp], 0
$LN6@R_ShowTree:
	cmp	DWORD PTR tv71[ebp], 0
	jne	SHORT $LN2@R_ShowTree
$LN3@R_ShowTree:

; 826  : 		return;

	jmp	$LN1@R_ShowTree
$LN2@R_ShowTree:

; 827  : 
; 828  : 	tr.recursion_level = 0;

	mov	DWORD PTR _tr+83220, 0

; 829  : 
; 830  : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 831  : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 832  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 833  : 
; 834  : 	pglLineWidth( 2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 835  : 	pglColor3f( 1, 0.7f, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 836  : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 837  : 	R_ShowTree_r( cl.worldmodel->nodes, x, y, tr.max_recursion * 3.5f, 2 );

	push	2
	cvtsi2ss xmm0, DWORD PTR _tr+83224
	mulss	xmm0, DWORD PTR __real@40600000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 838  : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 839  : 	pglLineWidth( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 840  : 
; 841  : 	R_ShowTree_r( cl.worldmodel->nodes, x, y, tr.max_recursion * 3.5f, 1 );

	push	1
	cvtsi2ss xmm0, DWORD PTR _tr+83224
	mulss	xmm0, DWORD PTR __real@40600000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	call	_R_ShowTree_r
	add	esp, 20					; 00000014H

; 842  : 
; 843  : 	Con_NPrintf( 0, "max recursion %d\n", tr.max_recursion );

	mov	eax, DWORD PTR _tr+83224
	push	eax
	push	OFFSET ??_C@_0BC@MMDJFPBN@max?5recursion?5?$CFd?6@
	push	0
	call	_Con_NPrintf
	add	esp, 12					; 0000000cH
$LN1@R_ShowTree:

; 844  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _R_ShowTextures
_TEXT	SEGMENT
tv146 = -396						; size = 4
tv67 = -396						; size = 4
$T1 = -392						; size = 4
_shortname$ = -324					; size = 256
_numTries$ = -68					; size = 4
_charHeight$ = -64					; size = 4
_color$ = -60						; size = 4
_base_h$ = -56						; size = 4
_base_w$ = -52						; size = 4
_k$ = -48						; size = 4
_j$ = -44						; size = 4
_i$ = -40						; size = 4
_end$ = -36						; size = 4
_start$ = -32						; size = 4
_total$ = -28						; size = 4
_h$ = -24						; size = 4
_w$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_image$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_ShowTextures PROC					; COMDAT

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 651  : 	gl_texture_t	*image;
; 652  : 	float		x, y, w, h;
; 653  : 	int		total, start, end;
; 654  : 	int		i, j, k, base_w, base_h;
; 655  : 	rgba_t		color = { 192, 192, 192, 255 };

	mov	BYTE PTR _color$[ebp], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+1], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+2], 192		; 000000c0H
	mov	BYTE PTR _color$[ebp+3], 255		; 000000ffH

; 656  : 	int		charHeight, numTries = 0;

	mov	DWORD PTR _numTries$[ebp], 0

; 657  : 	static qboolean	showHelp = true;
; 658  : 	string		shortname;
; 659  : 
; 660  : 	if( !CVAR_TO_BOOL( gl_showtextures ))

	cmp	DWORD PTR _gl_showtextures, 0
	je	SHORT $LN27@R_ShowText
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@R_ShowText
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN28@R_ShowText
$LN27@R_ShowText:
	mov	DWORD PTR tv67[ebp], 0
$LN28@R_ShowText:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN8@R_ShowText

; 661  : 		return;

	jmp	$LN1@R_ShowText
$LN8@R_ShowText:

; 662  : 
; 663  : 	if( showHelp )

	cmp	DWORD PTR ?showHelp@?1??R_ShowTextures@@9@9, 0
	je	SHORT $LN9@R_ShowText

; 664  : 	{
; 665  : 		CL_CenterPrint( "use '<-' and '->' keys to change atlas page, ESC to quit", 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0DJ@GIOCMLAK@use?5?8?$DM?9?8?5and?5?8?9?$DO?8?5keys?5to?5chang@
	call	_CL_CenterPrint
	add	esp, 8

; 666  : 		showHelp = false;

	mov	DWORD PTR ?showHelp@?1??R_ShowTextures@@9@9, 0
$LN9@R_ShowText:

; 667  : 	}
; 668  : 
; 669  : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 670  : 	pglClear( GL_COLOR_BUFFER_BIT );

	push	16384					; 00004000H
	call	DWORD PTR _pglClear

; 671  : 	pglFinish();

	call	DWORD PTR _pglFinish

; 672  : 
; 673  : 	base_w = 8;	// textures view by horizontal

	mov	DWORD PTR _base_w$[ebp], 8

; 674  : 	base_h = 6;	// textures view by vertical

	mov	DWORD PTR _base_h$[ebp], 6
$rebuild_page$33:

; 675  : 
; 676  : rebuild_page:
; 677  : 	total = base_w * base_h;

	mov	eax, DWORD PTR _base_w$[ebp]
	imul	eax, DWORD PTR _base_h$[ebp]
	mov	DWORD PTR _total$[ebp], eax

; 678  : 	start = total * (gl_showtextures->value - 1);

	cvtsi2ss xmm0, DWORD PTR _total$[ebp]
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm1, DWORD PTR [eax+12]
	subss	xmm1, DWORD PTR __real@3f800000
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	DWORD PTR _start$[ebp], ecx

; 679  : 	end = total * gl_showtextures->value;

	cvtsi2ss xmm0, DWORD PTR _total$[ebp]
	mov	eax, DWORD PTR _gl_showtextures
	mulss	xmm0, DWORD PTR [eax+12]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _end$[ebp], ecx

; 680  : 	if( end > MAX_TEXTURES ) end = MAX_TEXTURES;

	cmp	DWORD PTR _end$[ebp], 4096		; 00001000H
	jle	SHORT $LN10@R_ShowText
	mov	DWORD PTR _end$[ebp], 4096		; 00001000H
$LN10@R_ShowText:

; 681  : 
; 682  : 	w = glState.width / base_w;

	mov	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _w$[ebp], xmm0

; 683  : 	h = glState.height / base_h;

	mov	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _base_h$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _h$[ebp], xmm0

; 684  : 
; 685  : 	Con_DrawStringLen( NULL, NULL, &charHeight );

	lea	eax, DWORD PTR _charHeight$[ebp]
	push	eax
	push	0
	push	0
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 686  : 
; 687  : 	for( i = j = 0; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@R_ShowText
$LN2@R_ShowText:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_ShowText:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	SHORT $LN3@R_ShowText

; 688  : 	{
; 689  : 		image = R_GetTexture( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _image$[ebp], eax

; 690  : 		if( j == start ) break; // found start

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jne	SHORT $LN11@R_ShowText
	jmp	SHORT $LN3@R_ShowText
$LN11@R_ShowText:

; 691  : 		if( pglIsTexture( image->texnum )) j++;

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	call	DWORD PTR _pglIsTexture
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@R_ShowText
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN12@R_ShowText:

; 692  : 	}

	jmp	SHORT $LN2@R_ShowText
$LN3@R_ShowText:

; 693  : 
; 694  : 	if( i == MAX_TEXTURES && gl_showtextures->value != 1 )

	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jne	$LN14@R_ShowText
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@R_ShowText

; 695  : 	{
; 696  : 		// bad case, rewind to one and try again
; 697  : 		Cvar_SetValue( "r_showtextures", max( 1, gl_showtextures->value - 1 ));

	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN29@R_ShowText
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
	jmp	SHORT $LN30@R_ShowText
$LN29@R_ShowText:
	mov	ecx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv146[ebp], xmm0
$LN30@R_ShowText:
	push	ecx
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0P@MJMKNHCG@r_showtextures@
	call	_Cvar_SetValue
	add	esp, 8

; 698  : 		if( ++numTries < 2 ) goto rebuild_page;	// to prevent infinite loop

	mov	eax, DWORD PTR _numTries$[ebp]
	add	eax, 1
	mov	DWORD PTR _numTries$[ebp], eax
	cmp	DWORD PTR _numTries$[ebp], 2
	jge	SHORT $LN14@R_ShowText
	jmp	$rebuild_page$33
$LN14@R_ShowText:

; 699  : 	}
; 700  : 
; 701  : 	for( k = 0; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@R_ShowText
$LN5@R_ShowText:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_ShowText:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	$LN6@R_ShowText

; 702  : 	{
; 703  : 		if( j == end ) break; // page is full

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jne	SHORT $LN15@R_ShowText
	jmp	$LN6@R_ShowText
$LN15@R_ShowText:

; 704  : 
; 705  : 		image = R_GetTexture( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _image$[ebp], eax

; 706  : 		if( !pglIsTexture( image->texnum ))

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	call	DWORD PTR _pglIsTexture
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@R_ShowText

; 707  : 			continue;

	jmp	SHORT $LN5@R_ShowText
$LN16@R_ShowText:

; 708  : 
; 709  : 		x = k % base_w * w;

	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 710  : 		y = k / base_w * h;

	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR _base_w$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 711  : 
; 712  : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 713  : 		GL_Bind( GL_TEXTURE0, i ); // NOTE: don't use image->texnum here, because skybox has a 'wrong' indexes

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 714  : 
; 715  : 		if( FBitSet( image->flags, TF_DEPTHMAP ) && !FBitSet( image->flags, TF_NOCOMPARE ))

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN17@R_ShowText
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN17@R_ShowText

; 716  : 			pglTexParameteri( image->target, GL_TEXTURE_COMPARE_MODE_ARB, GL_NONE );

	push	0
	push	34892					; 0000884cH
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN17@R_ShowText:

; 717  : 
; 718  : 		pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 719  : 		pglTexCoord2f( 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 720  : 		pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 721  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	eax, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [eax+268], 34037		; 000084f5H
	jne	SHORT $LN18@R_ShowText

; 722  : 			pglTexCoord2f( image->width, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+260]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN19@R_ShowText
$LN18@R_ShowText:

; 723  : 		else pglTexCoord2f( 1, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN19@R_ShowText:

; 724  : 		pglVertex2f( x + w, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 725  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	eax, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [eax+268], 34037		; 000084f5H
	jne	SHORT $LN20@R_ShowText

; 726  : 			pglTexCoord2f( image->width, image->height );

	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _image$[ebp]
	movzx	eax, WORD PTR [edx+260]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN21@R_ShowText
$LN20@R_ShowText:

; 727  : 		else pglTexCoord2f( 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN21@R_ShowText:

; 728  : 		pglVertex2f( x + w, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 729  : 		if( image->target == GL_TEXTURE_RECTANGLE_EXT )

	mov	eax, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [eax+268], 34037		; 000084f5H
	jne	SHORT $LN22@R_ShowText

; 730  : 			pglTexCoord2f( 0, image->height );

	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN23@R_ShowText
$LN22@R_ShowText:

; 731  : 		else pglTexCoord2f( 0, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN23@R_ShowText:

; 732  : 		pglVertex2f( x, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 733  : 		pglEnd();

	call	DWORD PTR _pglEnd

; 734  : 
; 735  : 		if( FBitSet( image->flags, TF_DEPTHMAP ) && !FBitSet( image->flags, TF_NOCOMPARE ))

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN24@R_ShowText
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN24@R_ShowText

; 736  : 			pglTexParameteri( image->target, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB );

	push	34894					; 0000884eH
	push	34892					; 0000884cH
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN24@R_ShowText:

; 737  : 
; 738  : 		COM_FileBase( image->name, shortname );

	lea	eax, DWORD PTR _shortname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 739  : 		if( Q_strlen( shortname ) > 18 )

	lea	eax, DWORD PTR _shortname$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 18					; 00000012H
	jle	SHORT $LN25@R_ShowText

; 740  : 		{
; 741  : 			// cutoff too long names, it looks ugly
; 742  : 			shortname[16] = '.';

	mov	eax, 1
	shl	eax, 4
	mov	BYTE PTR _shortname$[ebp+eax], 46	; 0000002eH

; 743  : 			shortname[17] = '.';

	mov	eax, 1
	imul	ecx, eax, 17
	mov	BYTE PTR _shortname$[ebp+ecx], 46	; 0000002eH

; 744  : 			shortname[18] = '\0';

	mov	eax, 1
	imul	ecx, eax, 18
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN31@R_ShowText
	jmp	SHORT $LN32@R_ShowText
$LN31@R_ShowText:
	call	___report_rangecheckfailure
$LN32@R_ShowText:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _shortname$[ebp+edx], 0
$LN25@R_ShowText:

; 745  : 		}
; 746  : 		Con_DrawString( x + 1, y + h - charHeight, shortname, color );

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	lea	ecx, DWORD PTR _shortname$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	cvtsi2ss xmm1, DWORD PTR _charHeight$[ebp]
	subss	xmm0, xmm1
	cvttss2si edx, xmm0
	push	edx
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	push	eax
	call	_Con_DrawString
	add	esp, 16					; 00000010H

; 747  : 		j++, k++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx

; 748  : 	}

	jmp	$LN5@R_ShowText
$LN6@R_ShowText:

; 749  : 
; 750  : 	CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 751  : 	pglFinish();

	call	DWORD PTR _pglFinish
$LN1@R_ShowText:

; 752  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShowTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_Cull
_TEXT	SEGMENT
_cull$ = 8						; size = 4
_GL_Cull PROC						; COMDAT

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 383  : 	if( !cull )

	cmp	DWORD PTR _cull$[ebp], 0
	jne	SHORT $LN2@GL_Cull

; 384  : 	{
; 385  : 		pglDisable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglDisable

; 386  : 		glState.faceCull = 0;

	mov	DWORD PTR _glState+564, 0

; 387  : 		return;

	jmp	SHORT $LN1@GL_Cull
$LN2@GL_Cull:

; 388  : 	}
; 389  : 
; 390  : 	pglEnable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglEnable

; 391  : 	pglCullFace( cull );

	mov	eax, DWORD PTR _cull$[ebp]
	push	eax
	call	DWORD PTR _pglCullFace

; 392  : 	glState.faceCull = cull;

	mov	eax, DWORD PTR _cull$[ebp]
	mov	DWORD PTR _glState+564, eax
$LN1@GL_Cull:

; 393  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_Cull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_TextureTarget
_TEXT	SEGMENT
_target$ = 8						; size = 4
_GL_TextureTarget PROC					; COMDAT

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 282  : 	if( glState.activeTMU < 0 || glState.activeTMU >= GL_MaxTextureUnits( ))

	cmp	DWORD PTR _glState+16, 0
	jl	SHORT $LN3@GL_Texture
	call	_GL_MaxTextureUnits
	cmp	DWORD PTR _glState+16, eax
	jl	SHORT $LN2@GL_Texture
$LN3@GL_Texture:

; 283  : 	{
; 284  : 		Con_Reportf( S_ERROR "GL_TextureTarget: bad tmu state %i\n", glState.activeTMU );

	mov	eax, DWORD PTR _glState+16
	push	eax
	push	OFFSET ??_C@_0CP@JCKAIHCE@?$FO1Error?3?$FO7?5GL_TextureTarget?3?5ba@
	call	_Con_Reportf
	add	esp, 8

; 285  : 		return; 

	jmp	SHORT $LN1@GL_Texture
$LN2@GL_Texture:

; 286  : 	}
; 287  : 
; 288  : 	if( glState.currentTextureTargets[glState.activeTMU] != target )

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _glState[eax*4+148]
	cmp	ecx, DWORD PTR _target$[ebp]
	je	SHORT $LN1@GL_Texture

; 289  : 	{
; 290  : 		if( glState.currentTextureTargets[glState.activeTMU] != GL_NONE )

	mov	eax, DWORD PTR _glState+16
	cmp	DWORD PTR _glState[eax*4+148], 0
	je	SHORT $LN5@GL_Texture

; 291  : 			pglDisable( glState.currentTextureTargets[glState.activeTMU] );

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _glState[eax*4+148]
	push	ecx
	call	DWORD PTR _pglDisable
$LN5@GL_Texture:

; 292  : 		glState.currentTextureTargets[glState.activeTMU] = target;

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR _glState[eax*4+148], ecx

; 293  : 		if( target != GL_NONE )

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN1@GL_Texture

; 294  : 			pglEnable( glState.currentTextureTargets[glState.activeTMU] );

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _glState[eax*4+148]
	push	ecx
	call	DWORD PTR _pglEnable
$LN1@GL_Texture:

; 295  : 	}
; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureTarget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_SetRenderMode
_TEXT	SEGMENT
tv67 = -68						; size = 4
_mode$ = 8						; size = 4
_GL_SetRenderMode PROC					; COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 397  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 398  : 
; 399  : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 5
	ja	SHORT $LN5@GL_SetRend
	mov	ecx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN12@GL_SetRend[ecx*4]
$LN5@GL_SetRend:

; 400  : 	{
; 401  : 	case kRenderNormal:
; 402  : 	default:
; 403  : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 404  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 405  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN7@GL_SetRend:

; 406  : 	case kRenderTransColor:
; 407  : 	case kRenderTransTexture:
; 408  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 409  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 410  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 411  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN8@GL_SetRend:

; 412  : 	case kRenderTransAlpha:
; 413  : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 414  : 		pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 415  : 		break;

	jmp	SHORT $LN1@GL_SetRend
$LN10@GL_SetRend:

; 416  : 	case kRenderGlow:
; 417  : 	case kRenderTransAdd:
; 418  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 419  : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 420  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc
$LN1@GL_SetRend:

; 421  : 		break;
; 422  : 	}
; 423  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@GL_SetRend:
	DD	$LN5@GL_SetRend
	DD	$LN7@GL_SetRend
	DD	$LN7@GL_SetRend
	DD	$LN10@GL_SetRend
	DD	$LN8@GL_SetRend
	DD	$LN10@GL_SetRend
_GL_SetRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_DisableAllTexGens
_TEXT	SEGMENT
_GL_DisableAllTexGens PROC				; COMDAT

; 215  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 216  : 	GL_TexGen( GL_S, 0 );

	push	0
	push	8192					; 00002000H
	call	_GL_TexGen
	add	esp, 8

; 217  : 	GL_TexGen( GL_T, 0 );

	push	0
	push	8193					; 00002001H
	call	_GL_TexGen
	add	esp, 8

; 218  : 	GL_TexGen( GL_R, 0 );

	push	0
	push	8194					; 00002002H
	call	_GL_TexGen
	add	esp, 8

; 219  : 	GL_TexGen( GL_Q, 0 );

	push	0
	push	8195					; 00002003H
	call	_GL_TexGen
	add	esp, 8

; 220  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_DisableAllTexGens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_LoadIdentityTexMatrix
_TEXT	SEGMENT
_GL_LoadIdentityTexMatrix PROC				; COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 168  : 	if( glState.texIdentityMatrix[glState.activeTMU] )

	mov	eax, DWORD PTR _glState+16
	movzx	ecx, BYTE PTR _glState[eax+276]
	test	ecx, ecx
	je	SHORT $LN2@GL_LoadIde

; 169  : 		return;

	jmp	SHORT $LN1@GL_LoadIde
$LN2@GL_LoadIde:

; 170  : 
; 171  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 172  : 	pglLoadIdentity();

	call	DWORD PTR _pglLoadIdentity

; 173  : 	glState.texIdentityMatrix[glState.activeTMU] = true;

	mov	eax, DWORD PTR _glState+16
	mov	BYTE PTR _glState[eax+276], 1
$LN1@GL_LoadIde:

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadIdentityTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_CleanupAllTextureUnits
_TEXT	SEGMENT
_GL_CleanupAllTextureUnits PROC				; COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 255  : 	if( !glw_state.initialized ) return;

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN2@GL_Cleanup
	jmp	SHORT $LN1@GL_Cleanup
$LN2@GL_Cleanup:

; 256  : 	// force to cleanup all the units
; 257  : 	GL_SelectTexture( GL_MaxTextureUnits() - 1 );

	call	_GL_MaxTextureUnits
	sub	eax, 1
	push	eax
	call	_GL_SelectTexture
	add	esp, 4

; 258  : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	_GL_CleanUpTextureUnits
	add	esp, 4
$LN1@GL_Cleanup:

; 259  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CleanupAllTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_SelectTexture
_TEXT	SEGMENT
_tmu$ = 8						; size = 4
_GL_SelectTexture PROC					; COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	if( !GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_SelectT

; 184  : 		return;

	jmp	SHORT $LN1@GL_SelectT
$LN2@GL_SelectT:

; 185  : 
; 186  : 	// don't allow negative texture units
; 187  : 	if( tmu < 0 ) return;

	cmp	DWORD PTR _tmu$[ebp], 0
	jge	SHORT $LN3@GL_SelectT
	jmp	SHORT $LN1@GL_SelectT
$LN3@GL_SelectT:

; 188  : 
; 189  : 	if( tmu >= GL_MaxTextureUnits( ))

	call	_GL_MaxTextureUnits
	cmp	DWORD PTR _tmu$[ebp], eax
	jl	SHORT $LN4@GL_SelectT

; 190  : 	{
; 191  : 		Con_Reportf( S_ERROR "GL_SelectTexture: bad tmu state %i\n", tmu );

	mov	eax, DWORD PTR _tmu$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@ECNALKMA@?$FO1Error?3?$FO7?5GL_SelectTexture?3?5ba@
	call	_Con_Reportf
	add	esp, 8

; 192  : 		return; 

	jmp	SHORT $LN1@GL_SelectT
$LN4@GL_SelectT:

; 193  : 	}
; 194  : 
; 195  : 	if( glState.activeTMU == tmu )

	mov	eax, DWORD PTR _glState+16
	cmp	eax, DWORD PTR _tmu$[ebp]
	jne	SHORT $LN5@GL_SelectT

; 196  : 		return;

	jmp	SHORT $LN1@GL_SelectT
$LN5@GL_SelectT:

; 197  : 
; 198  : 	glState.activeTMU = tmu;

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState+16, eax

; 199  : 
; 200  : 	if( pglActiveTextureARB )

	cmp	DWORD PTR _pglActiveTextureARB, 0
	je	SHORT $LN1@GL_SelectT

; 201  : 	{
; 202  : 		pglActiveTextureARB( tmu + GL_TEXTURE0_ARB );

	mov	eax, DWORD PTR _tmu$[ebp]
	add	eax, 33984				; 000084c0H
	push	eax
	call	DWORD PTR _pglActiveTextureARB

; 203  : 
; 204  : 		if( tmu < glConfig.max_texture_coords )

	mov	eax, DWORD PTR _tmu$[ebp]
	cmp	eax, DWORD PTR _glConfig+52
	jge	SHORT $LN1@GL_SelectT

; 205  : 			pglClientActiveTextureARB( tmu + GL_TEXTURE0_ARB );

	mov	eax, DWORD PTR _tmu$[ebp]
	add	eax, 33984				; 000084c0H
	push	eax
	call	DWORD PTR _pglClientActiveTextureARB
$LN1@GL_SelectT:

; 206  : 	}
; 207  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SelectTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_TexGen
_TEXT	SEGMENT
tv66 = -80						; size = 4
tv65 = -80						; size = 4
_gen$ = -12						; size = 4
_bit$ = -8						; size = 4
_tmu$ = -4						; size = 4
_coord$ = 8						; size = 4
_mode$ = 12						; size = 4
_GL_TexGen PROC						; COMDAT

; 304  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 305  : 	int	tmu = min( glConfig.max_texture_coords, glState.activeTMU );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glState+16
	jge	SHORT $LN14@GL_TexGen
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN15@GL_TexGen
$LN14@GL_TexGen:
	mov	edx, DWORD PTR _glState+16
	mov	DWORD PTR tv65[ebp], edx
$LN15@GL_TexGen:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _tmu$[ebp], eax

; 306  : 	int	bit, gen;
; 307  : 
; 308  : 	switch( coord )

	mov	eax, DWORD PTR _coord$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 8192				; 00002000H
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN8@GL_TexGen
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN16@GL_TexGen[edx*4]
$LN4@GL_TexGen:

; 309  : 	{
; 310  : 	case GL_S:
; 311  : 		bit = 1;

	mov	DWORD PTR _bit$[ebp], 1

; 312  : 		gen = GL_TEXTURE_GEN_S;

	mov	DWORD PTR _gen$[ebp], 3168		; 00000c60H

; 313  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN5@GL_TexGen:

; 314  : 	case GL_T:
; 315  : 		bit = 2;

	mov	DWORD PTR _bit$[ebp], 2

; 316  : 		gen = GL_TEXTURE_GEN_T;

	mov	DWORD PTR _gen$[ebp], 3169		; 00000c61H

; 317  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN6@GL_TexGen:

; 318  : 	case GL_R:
; 319  : 		bit = 4;

	mov	DWORD PTR _bit$[ebp], 4

; 320  : 		gen = GL_TEXTURE_GEN_R;

	mov	DWORD PTR _gen$[ebp], 3170		; 00000c62H

; 321  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN7@GL_TexGen:

; 322  : 	case GL_Q:
; 323  : 		bit = 8;

	mov	DWORD PTR _bit$[ebp], 8

; 324  : 		gen = GL_TEXTURE_GEN_Q;

	mov	DWORD PTR _gen$[ebp], 3171		; 00000c63H

; 325  : 		break;

	jmp	SHORT $LN2@GL_TexGen
$LN8@GL_TexGen:

; 326  : 	default: return;

	jmp	SHORT $LN1@GL_TexGen
$LN2@GL_TexGen:

; 327  : 	}
; 328  : 
; 329  : 	if( mode )

	cmp	DWORD PTR _mode$[ebp], 0
	je	SHORT $LN9@GL_TexGen

; 330  : 	{
; 331  : 		if( !( glState.genSTEnabled[tmu] & bit ))

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+308]
	and	ecx, DWORD PTR _bit$[ebp]
	jne	SHORT $LN11@GL_TexGen

; 332  : 		{
; 333  : 			pglEnable( gen );

	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	call	DWORD PTR _pglEnable

; 334  : 			glState.genSTEnabled[tmu] |= bit;

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+308]
	or	ecx, DWORD PTR _bit$[ebp]
	mov	edx, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState[edx*4+308], ecx
$LN11@GL_TexGen:

; 335  : 		}
; 336  : 		pglTexGeni( coord, GL_TEXTURE_GEN_MODE, mode );

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	push	9472					; 00002500H
	mov	ecx, DWORD PTR _coord$[ebp]
	push	ecx
	call	DWORD PTR _pglTexGeni

; 337  : 	}

	jmp	SHORT $LN1@GL_TexGen
$LN9@GL_TexGen:

; 338  : 	else
; 339  : 	{
; 340  : 		if( glState.genSTEnabled[tmu] & bit )

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+308]
	and	ecx, DWORD PTR _bit$[ebp]
	je	SHORT $LN1@GL_TexGen

; 341  : 		{
; 342  : 			pglDisable( gen );

	mov	eax, DWORD PTR _gen$[ebp]
	push	eax
	call	DWORD PTR _pglDisable

; 343  : 			glState.genSTEnabled[tmu] &= ~bit;

	mov	eax, DWORD PTR _bit$[ebp]
	not	eax
	mov	ecx, DWORD PTR _tmu$[ebp]
	and	eax, DWORD PTR _glState[ecx*4+308]
	mov	edx, DWORD PTR _tmu$[ebp]
	mov	DWORD PTR _glState[edx*4+308], eax
$LN1@GL_TexGen:

; 344  : 		}
; 345  : 	}
; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@GL_TexGen:
	DD	$LN4@GL_TexGen
	DD	$LN5@GL_TexGen
	DD	$LN6@GL_TexGen
	DD	$LN7@GL_TexGen
_GL_TexGen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_LoadMatrix
_TEXT	SEGMENT
_dest$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
_GL_LoadMatrix PROC					; COMDAT

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 155  : 	GLfloat	dest[16];
; 156  : 
; 157  : 	Matrix4x4_ToArrayFloatGL( source, dest );

	lea	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_Matrix4x4_ToArrayFloatGL
	add	esp, 8

; 158  : 	pglLoadMatrixf( dest );

	lea	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	DWORD PTR _pglLoadMatrixf

; 159  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_LoadTexMatrixExt
_TEXT	SEGMENT
tv70 = -68						; size = 4
_glmatrix$ = 8						; size = 4
_GL_LoadTexMatrixExt PROC				; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 142  : 	Assert( glmatrix != NULL );

	cmp	DWORD PTR _glmatrix$[ebp], 0
	je	SHORT $LN3@GL_LoadTex
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@GL_LoadTex
$LN3@GL_LoadTex:
	mov	DWORD PTR tv70[ebp], 0
$LN4@GL_LoadTex:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_LoadTexMatrixExt@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@JDAPEPDE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BB@GPLEAKIK@glmatrix?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 143  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 144  : 	pglLoadMatrixf( glmatrix );

	mov	eax, DWORD PTR _glmatrix$[ebp]
	push	eax
	call	DWORD PTR _pglLoadMatrixf

; 145  : 	glState.texIdentityMatrix[glState.activeTMU] = false;

	mov	eax, DWORD PTR _glState+16
	mov	BYTE PTR _glState[eax+276], 0

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTexMatrixExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_LoadTexMatrix
_TEXT	SEGMENT
_m$ = 8							; size = 4
_GL_LoadTexMatrix PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 130  : 	pglMatrixMode( GL_TEXTURE );

	push	5890					; 00001702H
	call	DWORD PTR _pglMatrixMode

; 131  : 	GL_LoadMatrix( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_GL_LoadMatrix
	add	esp, 4

; 132  : 	glState.texIdentityMatrix[glState.activeTMU] = false;

	mov	eax, DWORD PTR _glState+16
	mov	BYTE PTR _glState[eax+276], 0

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTexMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_SetTexCoordArrayMode
_TEXT	SEGMENT
tv65 = -80						; size = 4
_cmode$ = -12						; size = 4
_bit$ = -8						; size = 4
_tmu$ = -4						; size = 4
_mode$ = 8						; size = 4
_GL_SetTexCoordArrayMode PROC				; COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 355  : 	int	tmu = min( glConfig.max_texture_coords, glState.activeTMU );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glState+16
	jge	SHORT $LN14@GL_SetTexC
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv65[ebp], ecx
	jmp	SHORT $LN15@GL_SetTexC
$LN14@GL_SetTexC:
	mov	edx, DWORD PTR _glState+16
	mov	DWORD PTR tv65[ebp], edx
$LN15@GL_SetTexC:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _tmu$[ebp], eax

; 356  : 	int	bit, cmode = glState.texCoordArrayMode[tmu];

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+436]
	mov	DWORD PTR _cmode$[ebp], ecx

; 357  : 
; 358  : 	if( mode == GL_TEXTURE_COORD_ARRAY )

	cmp	DWORD PTR _mode$[ebp], 32888		; 00008078H
	jne	SHORT $LN2@GL_SetTexC

; 359  : 		bit = 1;

	mov	DWORD PTR _bit$[ebp], 1
	jmp	SHORT $LN3@GL_SetTexC
$LN2@GL_SetTexC:

; 360  : 	else if( mode == GL_TEXTURE_CUBE_MAP_ARB )

	cmp	DWORD PTR _mode$[ebp], 34067		; 00008513H
	jne	SHORT $LN4@GL_SetTexC

; 361  : 		bit = 2;

	mov	DWORD PTR _bit$[ebp], 2
	jmp	SHORT $LN3@GL_SetTexC
$LN4@GL_SetTexC:

; 362  : 	else bit = 0;

	mov	DWORD PTR _bit$[ebp], 0
$LN3@GL_SetTexC:

; 363  : 
; 364  : 	if( cmode != bit )

	mov	eax, DWORD PTR _cmode$[ebp]
	cmp	eax, DWORD PTR _bit$[ebp]
	je	SHORT $LN1@GL_SetTexC

; 365  : 	{
; 366  : 		if( cmode == 1 ) pglDisableClientState( GL_TEXTURE_COORD_ARRAY );

	cmp	DWORD PTR _cmode$[ebp], 1
	jne	SHORT $LN7@GL_SetTexC
	push	32888					; 00008078H
	call	DWORD PTR _pglDisableClientState
	jmp	SHORT $LN8@GL_SetTexC
$LN7@GL_SetTexC:

; 367  : 		else if( cmode == 2 ) pglDisable( GL_TEXTURE_CUBE_MAP_ARB );

	cmp	DWORD PTR _cmode$[ebp], 2
	jne	SHORT $LN8@GL_SetTexC
	push	34067					; 00008513H
	call	DWORD PTR _pglDisable
$LN8@GL_SetTexC:

; 368  : 
; 369  : 		if( bit == 1 ) pglEnableClientState( GL_TEXTURE_COORD_ARRAY );

	cmp	DWORD PTR _bit$[ebp], 1
	jne	SHORT $LN10@GL_SetTexC
	push	32888					; 00008078H
	call	DWORD PTR _pglEnableClientState
	jmp	SHORT $LN11@GL_SetTexC
$LN10@GL_SetTexC:

; 370  : 		else if( bit == 2 ) pglEnable( GL_TEXTURE_CUBE_MAP_ARB );

	cmp	DWORD PTR _bit$[ebp], 2
	jne	SHORT $LN11@GL_SetTexC
	push	34067					; 00008513H
	call	DWORD PTR _pglEnable
$LN11@GL_SetTexC:

; 371  : 
; 372  : 		glState.texCoordArrayMode[tmu] = bit;

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _bit$[ebp]
	mov	DWORD PTR _glState[eax*4+436], ecx
$LN1@GL_SetTexC:

; 373  : 	}
; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetTexCoordArrayMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_MultiTexCoord2f
_TEXT	SEGMENT
_texture$ = 8						; size = 4
_s$ = 12						; size = 4
_t$ = 16						; size = 4
_GL_MultiTexCoord2f PROC				; COMDAT

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 268  : 	if( !GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_MultiTe

; 269  : 		return;

	jmp	SHORT $LN3@GL_MultiTe
$LN2@GL_MultiTe:

; 270  : 
; 271  : 	if( pglMultiTexCoord2f != NULL )

	cmp	DWORD PTR _pglMultiTexCoord2f, 0
	je	SHORT $LN3@GL_MultiTe

; 272  : 		pglMultiTexCoord2f( texture + GL_TEXTURE0_ARB, s, t );

	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _texture$[ebp]
	add	eax, 33984				; 000084c0H
	push	eax
	call	DWORD PTR _pglMultiTexCoord2f
$LN3@GL_MultiTe:

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_MultiTexCoord2f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_CleanUpTextureUnits
_TEXT	SEGMENT
_i$ = -4						; size = 4
_last$ = 8						; size = 4
_GL_CleanUpTextureUnits PROC				; COMDAT

; 228  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 229  : 	int	i;
; 230  : 
; 231  : 	for( i = glState.activeTMU; i > (last - 1); i-- )

	mov	eax, DWORD PTR _glState+16
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@GL_CleanUp
$LN2@GL_CleanUp:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_CleanUp:
	mov	eax, DWORD PTR _last$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN1@GL_CleanUp

; 232  : 	{
; 233  : 		// disable upper units
; 234  : 		if( glState.currentTextureTargets[i] != GL_NONE )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _glState[eax*4+148], 0
	je	SHORT $LN5@GL_CleanUp

; 235  : 		{
; 236  : 			pglDisable( glState.currentTextureTargets[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+148]
	push	ecx
	call	DWORD PTR _pglDisable

; 237  : 			glState.currentTextureTargets[i] = GL_NONE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[eax*4+148], 0

; 238  : 			glState.currentTextures[i] = -1; // unbind texture

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[eax*4+20], -1
$LN5@GL_CleanUp:

; 239  : 		}
; 240  : 
; 241  : 		GL_SetTexCoordArrayMode( GL_NONE );

	push	0
	call	_GL_SetTexCoordArrayMode
	add	esp, 4

; 242  : 		GL_LoadIdentityTexMatrix();

	call	_GL_LoadIdentityTexMatrix

; 243  : 		GL_DisableAllTexGens();

	call	_GL_DisableAllTexGens

; 244  : 		GL_SelectTexture( i - 1 );

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	push	eax
	call	_GL_SelectTexture
	add	esp, 4

; 245  : 	}

	jmp	SHORT $LN2@GL_CleanUp
$LN1@GL_CleanUp:

; 246  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CleanUpTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_BackendEndFrame
_TEXT	SEGMENT
tv72 = -72						; size = 4
_curleaf$ = -4						; size = 4
_GL_BackendEndFrame PROC				; COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 82   : 	mleaf_t	*curleaf;
; 83   : 
; 84   : 	if( r_speeds->value <= 0 || !RI.drawWorld )

	mov	eax, DWORD PTR _r_speeds
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jae	SHORT $LN5@GL_Backend
	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN4@GL_Backend
$LN5@GL_Backend:

; 85   : 		return;

	jmp	$LN1@GL_Backend
$LN4@GL_Backend:

; 86   : 
; 87   : 	if( !RI.viewleaf )

	cmp	DWORD PTR _RI+180, 0
	jne	SHORT $LN6@GL_Backend

; 88   : 		curleaf = cl.worldmodel->leafs;

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _curleaf$[ebp], ecx
	jmp	SHORT $LN7@GL_Backend
$LN6@GL_Backend:

; 89   : 	else curleaf = RI.viewleaf;

	mov	eax, DWORD PTR _RI+180
	mov	DWORD PTR _curleaf$[ebp], eax
$LN7@GL_Backend:

; 90   : 
; 91   : 	R_Speeds_Printf( "Renderer: ^1Engine^7\n\n" );

	push	OFFSET ??_C@_0BH@OBLNCNBL@Renderer?3?5?$FO1Engine?$FO7?6?6@
	call	_R_Speeds_Printf
	add	esp, 4

; 92   : 
; 93   : 	switch( (int)r_speeds->value )

	mov	eax, DWORD PTR _r_speeds
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	sub	edx, 1
	mov	DWORD PTR tv72[ebp], edx
	cmp	DWORD PTR tv72[ebp], 5
	ja	$LN2@GL_Backend
	mov	eax, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN15@GL_Backend[eax*4]
$LN8@GL_Backend:

; 94   : 	{
; 95   : 	case 1:
; 96   : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i wpoly, %3i apoly\n%3i epoly, %3i spoly",

	mov	eax, DWORD PTR _r_stats+8
	push	eax
	mov	ecx, DWORD PTR _r_stats+4
	push	ecx
	mov	edx, DWORD PTR _r_stats+12
	push	edx
	mov	eax, DWORD PTR _r_stats
	push	eax
	push	OFFSET ??_C@_0CK@GKGLMGLL@?$CF3i?5wpoly?0?5?$CF3i?5apoly?6?$CF3i?5epoly?0@
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 97   : 		r_stats.c_world_polys, r_stats.c_alias_polys, r_stats.c_studio_polys, r_stats.c_sprite_polys );
; 98   : 		break;		

	jmp	$LN2@GL_Backend
$LN9@GL_Backend:

; 99   : 	case 2:
; 100  : 		R_Speeds_Printf( "visible leafs:\n%3i leafs\ncurrent leaf %3i\n", r_stats.c_world_leafs, curleaf - cl.worldmodel->leafs );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _curleaf$[ebp]
	sub	ecx, DWORD PTR [eax+140]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _r_stats+16
	push	edx
	push	OFFSET ??_C@_0CL@DDFBBACK@visible?5leafs?3?6?$CF3i?5leafs?6curren@
	call	_R_Speeds_Printf
	add	esp, 12					; 0000000cH

; 101  : 		R_Speeds_Printf( "ReciusiveWorldNode: %3lf secs\nDrawTextureChains %lf\n", r_stats.t_world_node, r_stats.t_world_draw );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _r_stats+56
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _r_stats+48
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0DF@FAONIALM@ReciusiveWorldNode?3?5?$CF3lf?5secs?6D@
	call	_R_Speeds_Printf
	add	esp, 20					; 00000014H

; 102  : 		break;

	jmp	$LN2@GL_Backend
$LN10@GL_Backend:

; 103  : 	case 3:
; 104  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i alias models drawn\n%3i studio models drawn\n%3i sprites drawn",

	mov	eax, DWORD PTR _r_stats+36
	push	eax
	mov	ecx, DWORD PTR _r_stats+32
	push	ecx
	mov	edx, DWORD PTR _r_stats+28
	push	edx
	push	OFFSET ??_C@_0EB@HAHABGKN@?$CF3i?5alias?5models?5drawn?6?$CF3i?5stud@
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 105  : 		r_stats.c_alias_models_drawn, r_stats.c_studio_models_drawn, r_stats.c_sprite_models_drawn );
; 106  : 		break;

	jmp	$LN2@GL_Backend
$LN11@GL_Backend:

; 107  : 	case 4:
; 108  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i static entities\n%3i normal entities\n%3i server entities",

	call	_pfnNumberOfEntities
	push	eax
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24576]
	mov	edx, DWORD PTR _tr+66792
	add	ecx, DWORD PTR [edx+24580]
	sub	ecx, DWORD PTR _r_stats+44
	push	ecx
	mov	eax, DWORD PTR _r_stats+44
	push	eax
	push	OFFSET ??_C@_0DM@CDKHBBFK@?$CF3i?5static?5entities?6?$CF3i?5normal?5@
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 109  : 		r_numStatics, r_numEntities - r_numStatics, pfnNumberOfEntities( ));
; 110  : 		break;

	jmp	SHORT $LN2@GL_Backend
$LN12@GL_Backend:

; 111  : 	case 5:
; 112  : 		Q_snprintf( r_speeds_msg, sizeof( r_speeds_msg ), "%3i tempents\n%3i viewbeams\n%3i particles",

	mov	eax, DWORD PTR _r_stats+40
	push	eax
	mov	ecx, DWORD PTR _r_stats+20
	push	ecx
	mov	edx, DWORD PTR _r_stats+24
	push	edx
	push	OFFSET ??_C@_0CJ@EAOPFKHG@?$CF3i?5tempents?6?$CF3i?5viewbeams?6?$CF3i?5@
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 113  : 		r_stats.c_active_tents_count, r_stats.c_view_beams_count, r_stats.c_particle_count );
; 114  : 		break;

	jmp	SHORT $LN2@GL_Backend
$LN13@GL_Backend:

; 115  : 	case 6: // FarEast: Restored mirror support
; 116  : 		Q_snprintf(r_speeds_msg, sizeof(r_speeds_msg), "%3i mirrors\n", r_stats.c_mirror_passes);

	mov	eax, DWORD PTR _r_stats+64
	push	eax
	push	OFFSET ??_C@_0N@HADAAIKB@?$CF3i?5mirrors?6@
	push	1024					; 00000400H
	push	OFFSET _r_speeds_msg
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN2@GL_Backend:

; 117  : 		break;
; 118  : 	}
; 119  : 
; 120  : 	memset( &r_stats, 0, sizeof( r_stats ));

	push	72					; 00000048H
	push	0
	push	OFFSET _r_stats
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@GL_Backend:

; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@GL_Backend:
	DD	$LN8@GL_Backend
	DD	$LN9@GL_Backend
	DD	$LN10@GL_Backend
	DD	$LN11@GL_Backend
	DD	$LN12@GL_Backend
	DD	$LN13@GL_Backend
_GL_BackendEndFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_backend.c
;	COMDAT _GL_BackendStartFrame
_TEXT	SEGMENT
$T1 = -68						; size = 4
_GL_BackendStartFrame PROC				; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 72   : 	r_speeds_msg[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN3@GL_Backend
	jmp	SHORT $LN4@GL_Backend
$LN3@GL_Backend:
	call	___report_rangecheckfailure
$LN4@GL_Backend:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _r_speeds_msg[edx], 0
$LN2@GL_Backend:

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BackendStartFrame ENDP
_TEXT	ENDS
END
