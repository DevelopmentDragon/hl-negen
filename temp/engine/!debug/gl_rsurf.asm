; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_rsurf.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_R_MarkLeaves
PUBLIC	_R_DrawWorld
PUBLIC	_R_DrawWaterSurfaces
PUBLIC	_R_DrawBrushModel
PUBLIC	_GL_SubdivideSurface
PUBLIC	_GL_BuildPolygonFromSurface
PUBLIC	_DrawGLPoly
PUBLIC	_R_TextureAnimation
PUBLIC	_GL_SetupFogColorForSurfaces
PUBLIC	_R_DrawAlphaTextureChains
PUBLIC	_GL_RebuildLightmaps
PUBLIC	_GL_InitRandomTable
PUBLIC	_GL_BuildLightmaps
PUBLIC	_GL_ResetFogColor
PUBLIC	_Mod_GetCurrentVis
PUBLIC	_Mod_SetOrthoBounds
PUBLIC	_R_AddDynamicLights
PUBLIC	_R_SetCacheState
PUBLIC	_DrawGLPolyChain
PUBLIC	_R_BlendLightmaps
PUBLIC	_R_RenderFullbrights
PUBLIC	_R_RenderDetails
PUBLIC	_R_RenderBrushPoly
PUBLIC	_R_DrawTextureChains
PUBLIC	_R_SetRenderMode
PUBLIC	_R_DrawStaticModel
PUBLIC	_R_RecursiveWorldNode
PUBLIC	_R_CullNodeTopView
PUBLIC	_R_DrawWorldTopView
PUBLIC	_R_DrawTriangleOutlines
PUBLIC	_GL_CreateSurfaceLightmap
PUBLIC	?__LINE__Var@?0??SubdividePolygon_r@@9@9	; `SubdividePolygon_r'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@CIADECFM@Mod_SubdividePolygon?3?5too?5many?5@ ; `string'
PUBLIC	??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_BuildPolygonFromSurface@@9@9 ; `GL_BuildPolygonFromSurface'::`1'::__LINE__Var
PUBLIC	??_C@_0BL@CLCBKDHC@glt?5?$CB?$DN?5NULL?5?$CG?$CG?5tex?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0M@NDIFDEBH@?$CKlightmap?$CFi@		; `string'
PUBLIC	??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f50624de0000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@4050000000000000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42800000
PUBLIC	__real@43800000
PUBLIC	__real@46040000
PUBLIC	__real@c20c0000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_Host_Error:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_COM_SetRandomSeed:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_fabs:PROC
EXTRN	_pow:PROC
EXTRN	_sqrt:PROC
EXTRN	__imp__floor:PROC
EXTRN	_SinCos:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_BoxOnPlaneSide:PROC
EXTRN	_CL_RunLightStyles:PROC
EXTRN	_CL_IsDevOverviewMode:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_R_CullBox:PROC
EXTRN	_R_CullSurface:PROC
EXTRN	_DrawSurfaceDecals:PROC
EXTRN	_DrawDecalsBatch:PROC
EXTRN	_R_DrawWorldHull:PROC
EXTRN	_R_DrawModelHull:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_InitDlightTexture:PROC
EXTRN	_R_BeginDrawMirror:PROC
EXTRN	_R_EndDrawMirror:PROC
EXTRN	_R_StoreEfrags:PROC
EXTRN	_R_MarkLights:PROC
EXTRN	_R_CountSurfaceDlights:PROC
EXTRN	_R_LoadIdentity:PROC
EXTRN	_R_TranslateForEntity:PROC
EXTRN	_R_RotateForEntity:PROC
EXTRN	_R_AllowFog:PROC
EXTRN	_R_AddSkyBoxSurface:PROC
EXTRN	_R_ClearSkyBox:PROC
EXTRN	_R_DrawSkyBox:PROC
EXTRN	_R_DrawClouds:PROC
EXTRN	_EmitWaterPolys:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_world:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_cl_dlights:BYTE
EXTRN	_glState:BYTE
EXTRN	_gl_keeptjunctions:DWORD
EXTRN	_gl_wireframe:DWORD
EXTRN	_gl_nosort:DWORD
EXTRN	_r_fullbright:DWORD
EXTRN	_r_detailtextures:DWORD
EXTRN	_r_novis:DWORD
EXTRN	_r_nocull:DWORD
EXTRN	_r_lockpvs:DWORD
EXTRN	_r_dynamic:DWORD
EXTRN	_r_lightmap:DWORD
EXTRN	_vid_brightness:DWORD
EXTRN	_vid_gamma:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_nColinElim DD	01H DUP (?)
_world_orthocenter DD 02H DUP (?)
_world_orthohalf DD 02H DUP (?)
_r_blocklights DD 0300000H DUP (?)
_fullbright_surfaces DD 01008H DUP (?)
_detail_surfaces DD 01008H DUP (?)
_rtable	DD	0190H DUP (?)
_draw_alpha_surfaces DD 01H DUP (?)
_draw_fullbrights DD 01H DUP (?)
_draw_details DD 01H DUP (?)
_skychain DD	01H DUP (?)
_gl_lms	DB	0401408H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c20c0000
CONST	SEGMENT
__real@c20c0000 DD 0c20c0000r			; -35
CONST	ENDS
;	COMDAT __real@46040000
CONST	SEGMENT
__real@46040000 DD 046040000r			; 8448
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f50624de0000000
CONST	SEGMENT
__real@3f50624de0000000 DQ 03f50624de0000000r	; 0.001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@
CONST	SEGMENT
??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@ DB 'AllocBlock: full', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDIFDEBH@?$CKlightmap?$CFi@
CONST	SEGMENT
??_C@_0M@NDIFDEBH@?$CKlightmap?$CFi@ DB '*lightmap%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CLCBKDHC@glt?5?$CB?$DN?5NULL?5?$CG?$CG?5tex?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BL@CLCBKDHC@glt?5?$CB?$DN?5NULL?5?$CG?$CG?5tex?5?$CB?$DN?5NULL@ DB 'g'
	DB	'lt != NULL && tex != NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_BuildPolygonFromSurface@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_BuildPolygonFromSurface@@9@9 DD 010fH ; `GL_BuildPolygonFromSurface'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_rsurf.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CIADECFM@Mod_SubdividePolygon?3?5too?5many?5@
CONST	SEGMENT
??_C@_0DI@CIADECFM@Mod_SubdividePolygon?3?5too?5many?5@ DB 'Mod_Subdivide'
	DB	'Polygon: too many vertexes on face ( %i )', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SubdividePolygon_r@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SubdividePolygon_r@@9@9 DD 052H	; `SubdividePolygon_r'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02b9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0288H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0591H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0784H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0dd2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0155H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01caH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0c5dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01afH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0806H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03acH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_CreateSurfaceLightmap
_TEXT	SEGMENT
_base$ = -20						; size = 4
_info$ = -16						; size = 4
_sample_size$ = -12					; size = 4
_tmax$ = -8						; size = 4
_smax$ = -4						; size = 4
_surf$ = 8						; size = 4
_GL_CreateSurfaceLightmap PROC				; COMDAT

; 2087 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2088 : 	int		smax, tmax;
; 2089 : 	int		sample_size;
; 2090 : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 2091 : 	byte		*base;
; 2092 : 
; 2093 : 	if( !loadmodel->lightdata )

	mov	eax, DWORD PTR _loadmodel
	cmp	DWORD PTR [eax+380], 0
	jne	SHORT $LN2@GL_CreateS

; 2094 : 		return;

	jmp	$LN1@GL_CreateS
$LN2@GL_CreateS:

; 2095 : 
; 2096 : 	if( FBitSet( surf->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@GL_CreateS

; 2097 : 		return;

	jmp	$LN1@GL_CreateS
$LN3@GL_CreateS:

; 2098 : 
; 2099 : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 2100 : 	smax = ( info->lightextents[0] / sample_size ) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$[ebp], eax

; 2101 : 	tmax = ( info->lightextents[1] / sample_size ) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$[ebp], eax

; 2102 : 
; 2103 : 	if( !LM_AllocBlock( smax, tmax, &surf->light_s, &surf->light_t ))

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _tmax$[ebp]
	push	edx
	mov	eax, DWORD PTR _smax$[ebp]
	push	eax
	call	_LM_AllocBlock
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@GL_CreateS

; 2104 : 	{
; 2105 : 		LM_UploadBlock( false );

	push	0
	call	_LM_UploadBlock
	add	esp, 4

; 2106 : 		LM_InitBlock();

	call	_LM_InitBlock

; 2107 : 
; 2108 : 		if( !LM_AllocBlock( smax, tmax, &surf->light_s, &surf->light_t ))

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _tmax$[ebp]
	push	edx
	mov	eax, DWORD PTR _smax$[ebp]
	push	eax
	call	_LM_AllocBlock
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@GL_CreateS

; 2109 : 			Host_Error( "AllocBlock: full\n" );

	push	OFFSET ??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@
	call	_Host_Error
	add	esp, 4
$LN4@GL_CreateS:

; 2110 : 	}
; 2111 : 
; 2112 : 	surf->lightmaptexturenum = gl_lms.current_lightmap_texture;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _gl_lms+4096
	mov	DWORD PTR [eax+56], ecx

; 2113 : 
; 2114 : 	base = gl_lms.lightmap_buffer;

	mov	DWORD PTR _base$[ebp], OFFSET _gl_lms+5128

; 2115 : 	base += ( surf->light_t * BLOCK_SIZE + surf->light_s ) * 4;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, DWORD PTR _tr+87580
	mov	edx, DWORD PTR _surf$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	eax, DWORD PTR _base$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _base$[ebp], ecx

; 2116 : 
; 2117 : 	R_SetCacheState( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_R_SetCacheState
	add	esp, 4

; 2118 : 	R_BuildLightMap( surf, base, BLOCK_SIZE * 4, false );

	push	0
	mov	eax, DWORD PTR _tr+87580
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _base$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	call	_R_BuildLightMap
	add	esp, 16					; 00000010H
$LN1@GL_CreateS:

; 2119 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateSurfaceLightmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawTriangleOutlines
_TEXT	SEGMENT
_v$ = -20						; size = 4
_p$ = -16						; size = 4
_surf$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_R_DrawTriangleOutlines PROC				; COMDAT

; 1889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1890 : 	int		i, j;
; 1891 : 	msurface_t	*surf;
; 1892 : 	glpoly_t		*p;
; 1893 : 	float		*v;
; 1894 : 		
; 1895 : 	if( !gl_wireframe->value )

	mov	eax, DWORD PTR _gl_wireframe
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_DrawTria

; 1896 : 		return;

	jmp	$LN1@R_DrawTria
$LN23@R_DrawTria:

; 1897 : 
; 1898 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1899 : 	pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 1900 : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1901 : 	pglPolygonMode( GL_FRONT_AND_BACK, GL_LINE );

	push	6913					; 00001b01H
	push	1032					; 00000408H
	call	DWORD PTR _pglPolygonMode

; 1902 : 
; 1903 : 	// render static surfaces first
; 1904 : 	for( i = 0; i < MAX_LIGHTMAPS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawTria
$LN2@R_DrawTria:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawTria:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@R_DrawTria

; 1905 : 	{
; 1906 : 		for( surf = gl_lms.lightmap_surfaces[i]; surf != NULL; surf = surf->info->lightmapchain )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4+4104]
	mov	DWORD PTR _surf$[ebp], ecx
	jmp	SHORT $LN7@R_DrawTria
$LN5@R_DrawTria:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _surf$[ebp], edx
$LN7@R_DrawTria:
	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN6@R_DrawTria

; 1907 : 		{
; 1908 : 			p = surf->polys;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _p$[ebp], ecx

; 1909 : 			for( ; p != NULL; p = p->chain )

	jmp	SHORT $LN10@R_DrawTria
$LN8@R_DrawTria:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx
$LN10@R_DrawTria:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN9@R_DrawTria

; 1910 : 			{
; 1911 : 				pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 1912 : 				v = p->verts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _v$[ebp], eax

; 1913 : 				for( j = 0; j < p->numverts; j++, v += VERTEXSIZE )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@R_DrawTria
$LN11@R_DrawTria:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN13@R_DrawTria:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN12@R_DrawTria

; 1914 : 					pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv
	jmp	SHORT $LN11@R_DrawTria
$LN12@R_DrawTria:

; 1915 : 				pglEnd ();

	call	DWORD PTR _pglEnd

; 1916 : 			}

	jmp	SHORT $LN8@R_DrawTria
$LN9@R_DrawTria:

; 1917 : 		}

	jmp	$LN5@R_DrawTria
$LN6@R_DrawTria:

; 1918 : 	}

	jmp	$LN2@R_DrawTria
$LN3@R_DrawTria:

; 1919 : 
; 1920 : 	// render surfaces with dynamic lightmaps
; 1921 : 	for( surf = gl_lms.dynamic_surfaces; surf != NULL; surf = surf->info->lightmapchain )

	mov	eax, DWORD PTR _gl_lms+4100
	mov	DWORD PTR _surf$[ebp], eax
	jmp	SHORT $LN16@R_DrawTria
$LN14@R_DrawTria:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _surf$[ebp], edx
$LN16@R_DrawTria:
	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN15@R_DrawTria

; 1922 : 	{
; 1923 : 		p = surf->polys;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _p$[ebp], ecx

; 1924 : 
; 1925 : 		for( ; p != NULL; p = p->chain )

	jmp	SHORT $LN19@R_DrawTria
$LN17@R_DrawTria:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx
$LN19@R_DrawTria:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN18@R_DrawTria

; 1926 : 		{
; 1927 : 			pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 1928 : 			v = p->verts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _v$[ebp], eax

; 1929 : 			for( j = 0; j < p->numverts; j++, v += VERTEXSIZE )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@R_DrawTria
$LN20@R_DrawTria:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN22@R_DrawTria:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN21@R_DrawTria

; 1930 : 				pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv
	jmp	SHORT $LN20@R_DrawTria
$LN21@R_DrawTria:

; 1931 : 			pglEnd ();

	call	DWORD PTR _pglEnd

; 1932 : 		}

	jmp	SHORT $LN17@R_DrawTria
$LN18@R_DrawTria:

; 1933 : 	}

	jmp	$LN14@R_DrawTria
$LN15@R_DrawTria:

; 1934 : 
; 1935 : 	pglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );

	push	6914					; 00001b02H
	push	1032					; 00000408H
	call	DWORD PTR _pglPolygonMode

; 1936 : 	pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable

; 1937 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN1@R_DrawTria:

; 1938 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawTriangleOutlines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawWorldTopView
_TEXT	SEGMENT
_p$1 = -20						; size = 4
_surf$ = -16						; size = 4
_clipped$ = -12						; size = 4
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_node$ = 8						; size = 4
_clipflags$ = 12					; size = 4
_R_DrawWorldTopView PROC				; COMDAT

; 1819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
$LN4@R_DrawWorl:

; 1820 : 	int		i, c, clipped;
; 1821 : 	msurface_t	*surf;
; 1822 : 
; 1823 : 	do
; 1824 : 	{
; 1825 : 		if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN11@R_DrawWorl

; 1826 : 			return;	// hit a solid leaf

	jmp	$LN3@R_DrawWorl
$LN11@R_DrawWorl:

; 1827 : 
; 1828 : 		if( node->visframe != tr.visframecount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _tr+83188
	je	SHORT $LN12@R_DrawWorl

; 1829 : 			return;

	jmp	$LN3@R_DrawWorl
$LN12@R_DrawWorl:

; 1830 : 
; 1831 : 		if( clipflags && !r_nocull->value )

	cmp	DWORD PTR _clipflags$[ebp], 0
	je	$LN6@R_DrawWorl
	mov	eax, DWORD PTR _r_nocull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DrawWorl

; 1832 : 		{
; 1833 : 			for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_DrawWorl
$LN5@R_DrawWorl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_DrawWorl:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN6@R_DrawWorl

; 1834 : 			{
; 1835 : 				const mplane_t	*p = &RI.frustum.planes[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	add	eax, OFFSET _RI+56
	mov	DWORD PTR _p$1[ebp], eax

; 1836 : 
; 1837 : 				if( !FBitSet( clipflags, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _clipflags$[ebp]
	jne	SHORT $LN14@R_DrawWorl

; 1838 : 					continue;

	jmp	SHORT $LN5@R_DrawWorl
$LN14@R_DrawWorl:

; 1839 : 
; 1840 : 				clipped = BoxOnPlaneSide( node->minmaxs, node->minmaxs + 3, p );

	mov	eax, DWORD PTR _p$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 8
	push	edx
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clipped$[ebp], eax

; 1841 : 				if( clipped == 2 ) return;

	cmp	DWORD PTR _clipped$[ebp], 2
	jne	SHORT $LN15@R_DrawWorl
	jmp	$LN3@R_DrawWorl
$LN15@R_DrawWorl:

; 1842 : 				if( clipped == 1 ) ClearBits( clipflags, BIT( i ));

	cmp	DWORD PTR _clipped$[ebp], 1
	jne	SHORT $LN16@R_DrawWorl
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR _clipflags$[ebp]
	mov	DWORD PTR _clipflags$[ebp], eax
$LN16@R_DrawWorl:

; 1843 : 			}

	jmp	SHORT $LN5@R_DrawWorl
$LN6@R_DrawWorl:

; 1844 : 		}
; 1845 : 
; 1846 : 		// cull against the screen frustum or the appropriate area's frustum.
; 1847 : 		if( R_CullNodeTopView( node ))

	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	_R_CullNodeTopView
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@R_DrawWorl

; 1848 : 			return;

	jmp	$LN3@R_DrawWorl
$LN17@R_DrawWorl:

; 1849 : 
; 1850 : 		// if a leaf node, draw stuff
; 1851 : 		if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN18@R_DrawWorl

; 1852 : 		{
; 1853 : 			R_DrawTopViewLeaf( (mleaf_t *)node, clipflags );

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_R_DrawTopViewLeaf
	add	esp, 8

; 1854 : 			return;

	jmp	$LN3@R_DrawWorl
$LN18@R_DrawWorl:

; 1855 : 		}
; 1856 : 
; 1857 : 		// draw stuff
; 1858 : 		for( c = node->numsurfaces, surf = cl.worldmodel->surfaces + node->firstsurface; c; c--, surf++ )

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movzx	eax, WORD PTR [edx+48]
	imul	ecx, eax, 92
	mov	edx, DWORD PTR _cl+4579004
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _surf$[ebp], ecx
	jmp	SHORT $LN10@R_DrawWorl
$LN8@R_DrawWorl:
	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN10@R_DrawWorl:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN9@R_DrawWorl

; 1859 : 		{
; 1860 : 			// don't process the same surface twice
; 1861 : 			if( surf->visframe == tr.framecount )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _tr+83200
	jne	SHORT $LN19@R_DrawWorl

; 1862 : 				continue;

	jmp	SHORT $LN8@R_DrawWorl
$LN19@R_DrawWorl:

; 1863 : 
; 1864 : 			surf->visframe = tr.framecount;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _tr+83200
	mov	DWORD PTR [eax], ecx

; 1865 : 
; 1866 : 			if( R_CullSurface( surf, &RI.frustum, clipflags ))

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	push	OFFSET _RI+56
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@R_DrawWorl

; 1867 : 				continue;

	jmp	SHORT $LN8@R_DrawWorl
$LN20@R_DrawWorl:

; 1868 : 
; 1869 : 			if(!( surf->flags & SURF_DRAWSKY ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	jne	SHORT $LN21@R_DrawWorl

; 1870 : 			{ 
; 1871 : 				surf->texturechain = surf->texinfo->texture->texturechain;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+40], ecx

; 1872 : 				surf->texinfo->texture->texturechain = surf;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN21@R_DrawWorl:

; 1873 : 			}
; 1874 : 		}

	jmp	SHORT $LN8@R_DrawWorl
$LN9@R_DrawWorl:

; 1875 : 
; 1876 : 		// recurse down both children, we don't care the order...
; 1877 : 		R_DrawWorldTopView( node->children[0], clipflags );

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_R_DrawWorldTopView
	add	esp, 8

; 1878 : 		node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx

; 1879 : 
; 1880 : 	} while( node );

	cmp	DWORD PTR _node$[ebp], 0
	jne	$LN4@R_DrawWorl
$LN3@R_DrawWorl:

; 1881 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawWorldTopView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawTopViewLeaf
_TEXT	SEGMENT
_i$ = -12						; size = 4
_surf$ = -8						; size = 4
_mark$ = -4						; size = 4
_pleaf$ = 8						; size = 4
_clipflags$ = 12					; size = 4
_R_DrawTopViewLeaf PROC					; COMDAT

; 1782 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1783 : 	msurface_t	**mark, *surf;
; 1784 : 	int		i;
; 1785 : 
; 1786 : 	for( i = 0, mark = pleaf->firstmarksurface; i < pleaf->nummarksurfaces; i++, mark++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mark$[ebp], ecx
	jmp	SHORT $LN4@R_DrawTopV
$LN2@R_DrawTopV:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mark$[ebp]
	add	ecx, 4
	mov	DWORD PTR _mark$[ebp], ecx
$LN4@R_DrawTopV:
	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN3@R_DrawTopV

; 1787 : 	{
; 1788 : 		surf = *mark;

	mov	eax, DWORD PTR _mark$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _surf$[ebp], ecx

; 1789 : 
; 1790 : 		// don't process the same surface twice
; 1791 : 		if( surf->visframe == tr.framecount )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _tr+83200
	jne	SHORT $LN5@R_DrawTopV

; 1792 : 			continue;

	jmp	SHORT $LN2@R_DrawTopV
$LN5@R_DrawTopV:

; 1793 : 
; 1794 : 		surf->visframe = tr.framecount;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _tr+83200
	mov	DWORD PTR [eax], ecx

; 1795 : 
; 1796 : 		if( R_CullSurface( surf, &RI.frustum, clipflags ))

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	push	OFFSET _RI+56
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@R_DrawTopV

; 1797 : 			continue;

	jmp	SHORT $LN2@R_DrawTopV
$LN6@R_DrawTopV:

; 1798 : 
; 1799 : 		if(!( surf->flags & SURF_DRAWSKY ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	jne	SHORT $LN7@R_DrawTopV

; 1800 : 		{ 
; 1801 : 			surf->texturechain = surf->texinfo->texture->texturechain;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+40], ecx

; 1802 : 			surf->texinfo->texture->texturechain = surf;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN7@R_DrawTopV:

; 1803 : 		}
; 1804 : 	}

	jmp	$LN2@R_DrawTopV
$LN3@R_DrawTopV:

; 1805 : 
; 1806 : 	// deal with model fragments in this leaf
; 1807 : 	if( pleaf->efrags )

	mov	eax, DWORD PTR _pleaf$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN8@R_DrawTopV

; 1808 : 		R_StoreEfrags( &pleaf->efrags, tr.realframecount );

	mov	eax, DWORD PTR _tr+83196
	push	eax
	mov	ecx, DWORD PTR _pleaf$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	call	_R_StoreEfrags
	add	esp, 8
$LN8@R_DrawTopV:

; 1809 : 
; 1810 : 	r_stats.c_world_leafs++;

	mov	eax, DWORD PTR _r_stats+16
	add	eax, 1
	mov	DWORD PTR _r_stats+16, eax

; 1811 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawTopViewLeaf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_CullNodeTopView
_TEXT	SEGMENT
tv211 = -128						; size = 4
tv290 = -124						; size = 8
tv283 = -116						; size = 8
tv192 = -112						; size = 4
tv178 = -112						; size = 4
tv164 = -112						; size = 4
tv137 = -112						; size = 4
_half$ = -44						; size = 12
_center$ = -32						; size = 12
_size$ = -20						; size = 8
_delta$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_R_CullNodeTopView PROC					; COMDAT

; 1761 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1762 : 	vec2_t	delta, size;
; 1763 : 	vec3_t	center, half;
; 1764 : 
; 1765 : 	// build the node center and half-diagonal
; 1766 : 	VectorAverage( node->minmaxs, node->minmaxs + 3, center );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+8]
	addss	xmm0, DWORD PTR [esi+eax+20]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _center$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+8]
	addss	xmm0, DWORD PTR [esi+eax+20]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _center$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+8]
	addss	xmm0, DWORD PTR [esi+ecx+20]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv137[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR _center$[ebp+eax], xmm0

; 1767 : 	VectorSubtract( node->minmaxs + 3, center, half );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	subss	xmm0, DWORD PTR _center$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _half$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	subss	xmm0, DWORD PTR _center$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _half$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	subss	xmm0, DWORD PTR _center$[ebp+ecx]
	movss	DWORD PTR tv164[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _half$[ebp+eax], xmm0

; 1768 : 
; 1769 : 	// cull against the screen frustum or the appropriate area's frustum.
; 1770 : 	Vector2Subtract( center, world_orthocenter, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _center$[ebp+ecx]
	subss	xmm0, DWORD PTR _world_orthocenter[eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _center$[ebp+eax]
	subss	xmm0, DWORD PTR _world_orthocenter[ecx]
	movss	DWORD PTR tv178[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 1771 : 	Vector2Add( half, world_orthohalf, size );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _half$[ebp+ecx]
	addss	xmm0, DWORD PTR _world_orthohalf[eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _half$[ebp+eax]
	addss	xmm0, DWORD PTR _world_orthohalf[ecx]
	movss	DWORD PTR tv192[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv192[ebp]
	movss	DWORD PTR _size$[ebp+edx], xmm0

; 1772 : 
; 1773 : 	return ( fabs( delta[0] ) > size[0] ) || ( fabs( delta[1] ) > size[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _delta$[ebp+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv283[ebp]
	movsd	xmm0, QWORD PTR tv283[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm1, DWORD PTR _size$[ebp+eax]
	comisd	xmm0, xmm1
	ja	SHORT $LN3@R_CullNode
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _delta$[ebp+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv290[ebp]
	movsd	xmm0, QWORD PTR tv290[ebp]
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm1, DWORD PTR _size$[ebp+edx]
	comisd	xmm0, xmm1
	ja	SHORT $LN3@R_CullNode
	mov	DWORD PTR tv211[ebp], 0
	jmp	SHORT $LN4@R_CullNode
$LN3@R_CullNode:
	mov	DWORD PTR tv211[ebp], 1
$LN4@R_CullNode:
	mov	eax, DWORD PTR tv211[ebp]

; 1774 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CullNodeTopView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_RecursiveWorldNode
_TEXT	SEGMENT
tv213 = -104						; size = 4
tv179 = -104						; size = 4
tv173 = -104						; size = 4
tv72 = -104						; size = 4
_p$1 = -36						; size = 4
_dot$ = -32						; size = 4
_side$ = -28						; size = 4
_c$ = -24						; size = 4
_pleaf$ = -20						; size = 4
_mark$ = -16						; size = 4
_surf$ = -12						; size = 4
_clipped$ = -8						; size = 4
_i$ = -4						; size = 4
_node$ = 8						; size = 4
_clipflags$ = 12					; size = 4
_R_RecursiveWorldNode PROC				; COMDAT

; 1667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
$loc0$32:

; 1668 : 	int		i, clipped;
; 1669 : 	msurface_t	*surf, **mark;
; 1670 : 	mleaf_t		*pleaf;
; 1671 : 	int		c, side;
; 1672 : 	float		dot;
; 1673 : loc0:
; 1674 : 	if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN11@R_Recursiv

; 1675 : 		return; // hit a solid leaf

	jmp	$LN1@R_Recursiv
$LN11@R_Recursiv:

; 1676 : 
; 1677 : 	if( node->visframe != tr.visframecount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _tr+83188
	je	SHORT $LN12@R_Recursiv

; 1678 : 		return;

	jmp	$LN1@R_Recursiv
$LN12@R_Recursiv:

; 1679 : 
; 1680 : 	if( clipflags && !CVAR_TO_BOOL( r_nocull ))

	cmp	DWORD PTR _clipflags$[ebp], 0
	je	$LN3@R_Recursiv
	cmp	DWORD PTR _r_nocull, 0
	je	SHORT $LN24@R_Recursiv
	mov	eax, DWORD PTR _r_nocull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@R_Recursiv
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN25@R_Recursiv
$LN24@R_Recursiv:
	mov	DWORD PTR tv72[ebp], 0
$LN25@R_Recursiv:
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN3@R_Recursiv

; 1681 : 	{
; 1682 : 		for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Recursiv
$LN2@R_Recursiv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Recursiv:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@R_Recursiv

; 1683 : 		{
; 1684 : 			const mplane_t	*p = &RI.frustum.planes[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	add	eax, OFFSET _RI+56
	mov	DWORD PTR _p$1[ebp], eax

; 1685 : 
; 1686 : 			if( !FBitSet( clipflags, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _clipflags$[ebp]
	jne	SHORT $LN14@R_Recursiv

; 1687 : 				continue;

	jmp	SHORT $LN2@R_Recursiv
$LN14@R_Recursiv:

; 1688 : 
; 1689 : 			clipped = BoxOnPlaneSide( node->minmaxs, node->minmaxs + 3, p );

	mov	eax, DWORD PTR _p$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 8
	push	edx
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clipped$[ebp], eax

; 1690 : 			if( clipped == 2 ) return;

	cmp	DWORD PTR _clipped$[ebp], 2
	jne	SHORT $LN15@R_Recursiv
	jmp	$LN1@R_Recursiv
$LN15@R_Recursiv:

; 1691 : 			if( clipped == 1 ) ClearBits( clipflags, BIT( i ));

	cmp	DWORD PTR _clipped$[ebp], 1
	jne	SHORT $LN16@R_Recursiv
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR _clipflags$[ebp]
	mov	DWORD PTR _clipflags$[ebp], eax
$LN16@R_Recursiv:

; 1692 : 		}

	jmp	SHORT $LN2@R_Recursiv
$LN3@R_Recursiv:

; 1693 : 	}
; 1694 : 
; 1695 : 	// if a leaf node, draw stuff
; 1696 : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN17@R_Recursiv

; 1697 : 	{
; 1698 : 		pleaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pleaf$[ebp], eax

; 1699 : 
; 1700 : 		mark = pleaf->firstmarksurface;

	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mark$[ebp], ecx

; 1701 : 		c = pleaf->nummarksurfaces;

	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _c$[ebp], ecx

; 1702 : 
; 1703 : 		if( c )

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN6@R_Recursiv
$LN7@R_Recursiv:

; 1704 : 		{
; 1705 : 			do
; 1706 : 			{
; 1707 : 				(*mark)->visframe = tr.framecount;

	mov	eax, DWORD PTR _mark$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _tr+83200
	mov	DWORD PTR [ecx], edx

; 1708 : 				mark++;

	mov	eax, DWORD PTR _mark$[ebp]
	add	eax, 4
	mov	DWORD PTR _mark$[ebp], eax

; 1709 : 			} while( --c );

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	jne	SHORT $LN7@R_Recursiv
$LN6@R_Recursiv:

; 1710 : 		}
; 1711 : 
; 1712 : 		// deal with model fragments in this leaf
; 1713 : 		if( pleaf->efrags )

	mov	eax, DWORD PTR _pleaf$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN19@R_Recursiv

; 1714 : 			R_StoreEfrags( &pleaf->efrags, tr.realframecount );

	mov	eax, DWORD PTR _tr+83196
	push	eax
	mov	ecx, DWORD PTR _pleaf$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	call	_R_StoreEfrags
	add	esp, 8
$LN19@R_Recursiv:

; 1715 : 
; 1716 : 		r_stats.c_world_leafs++;

	mov	eax, DWORD PTR _r_stats+16
	add	eax, 1
	mov	DWORD PTR _r_stats+16, eax

; 1717 : 		return;

	jmp	$LN1@R_Recursiv
$LN17@R_Recursiv:

; 1718 : 	}
; 1719 : 
; 1720 : 	// node is just a decision point, so go down the apropriate sides
; 1721 : 
; 1722 : 	// find which side of the node we are on
; 1723 : 	dot = PlaneDiff( tr.modelorg, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN26@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	movss	xmm0, DWORD PTR _tr[edx*4+87596]
	movss	DWORD PTR tv173[ebp], xmm0
	jmp	SHORT $LN27@R_Recursiv
$LN26@R_Recursiv:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _tr[ecx+87596]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _tr[eax+87596]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _tr[edx+87596]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv173[ebp], xmm0
$LN27@R_Recursiv:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR tv173[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _dot$[ebp], xmm0

; 1724 : 	side = (dot >= 0.0f) ? 0 : 1;

	movss	xmm0, DWORD PTR _dot$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN28@R_Recursiv
	mov	DWORD PTR tv179[ebp], 0
	jmp	SHORT $LN29@R_Recursiv
$LN28@R_Recursiv:
	mov	DWORD PTR tv179[ebp], 1
$LN29@R_Recursiv:
	mov	eax, DWORD PTR tv179[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 1725 : 
; 1726 : 	// recurse down the children, front side first
; 1727 : 	R_RecursiveWorldNode( node->children[side], clipflags );

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _side$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	call	_R_RecursiveWorldNode
	add	esp, 8

; 1728 : 
; 1729 : 	// draw stuff
; 1730 : 	for( c = node->numsurfaces, surf = cl.worldmodel->surfaces + node->firstsurface; c; c--, surf++ )

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movzx	eax, WORD PTR [edx+48]
	imul	ecx, eax, 92
	mov	edx, DWORD PTR _cl+4579004
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _surf$[ebp], ecx
	jmp	SHORT $LN10@R_Recursiv
$LN8@R_Recursiv:
	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN10@R_Recursiv:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN9@R_Recursiv

; 1731 : 	{
; 1732 : 		if( R_CullSurface( surf, &RI.frustum, clipflags ))

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	push	OFFSET _RI+56
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@R_Recursiv

; 1733 : 			continue;

	jmp	SHORT $LN8@R_Recursiv
$LN20@R_Recursiv:

; 1734 : 
; 1735 : 		if( surf->flags & SURF_DRAWSKY )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN21@R_Recursiv

; 1736 : 		{
; 1737 : 			// make sky chain to right clip the skybox
; 1738 : 			surf->texturechain = skychain;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _skychain
	mov	DWORD PTR [eax+40], ecx

; 1739 : 			skychain = surf;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	DWORD PTR _skychain, eax

; 1740 : 		}

	jmp	SHORT $LN22@R_Recursiv
$LN21@R_Recursiv:

; 1741 : 		else
; 1742 : 		{ 
; 1743 : 			surf->texturechain = surf->texinfo->texture->texturechain;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+40], ecx

; 1744 : 			surf->texinfo->texture->texturechain = surf;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN22@R_Recursiv:

; 1745 : 		}
; 1746 : 	}

	jmp	SHORT $LN8@R_Recursiv
$LN9@R_Recursiv:

; 1747 : 
; 1748 : 	// recurse down the back side
; 1749 : 	node = node->children[!side];

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN30@R_Recursiv
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN31@R_Recursiv
$LN30@R_Recursiv:
	mov	DWORD PTR tv213[ebp], 0
$LN31@R_Recursiv:
	mov	eax, DWORD PTR tv213[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	DWORD PTR _node$[ebp], edx

; 1750 : 	goto loc0;

	jmp	$loc0$32
$LN1@R_Recursiv:

; 1751 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RecursiveWorldNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawStaticModel
_TEXT	SEGMENT
_l$ = -20						; size = 4
_psurf$ = -16						; size = 4
_clmodel$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_e$ = 8							; size = 4
_R_DrawStaticModel PROC					; COMDAT

; 1616 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1617 : 	int		i, k;
; 1618 : 	model_t* clmodel;
; 1619 : 	msurface_t* psurf;
; 1620 : 	dlight_t* l;
; 1621 : 
; 1622 : 	clmodel = e->model;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _clmodel$[ebp], ecx

; 1623 : 	if (R_CullBox(clmodel->mins, clmodel->maxs))

	mov	eax, DWORD PTR _clmodel$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _clmodel$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	_R_CullBox
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@R_DrawStat

; 1624 : 		return;

	jmp	$LN6@R_DrawStat
$LN8@R_DrawStat:

; 1625 : 
; 1626 : 	// calculate dynamic lighting for bmodel
; 1627 : 	for (k = 0, l = cl_dlights; k < MAX_DLIGHTS; k++, l++)

	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _l$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@R_DrawStat
$LN2@R_DrawStat:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _l$[ebp], ecx
$LN4@R_DrawStat:
	cmp	DWORD PTR _k$[ebp], 32			; 00000020H
	jge	SHORT $LN3@R_DrawStat

; 1628 : 	{
; 1629 : 		if (l->die < cl.time || !l->radius)

	mov	eax, DWORD PTR _l$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN10@R_DrawStat
	mov	eax, DWORD PTR _l$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@R_DrawStat
$LN10@R_DrawStat:

; 1630 : 			continue;

	jmp	SHORT $LN2@R_DrawStat
$LN9@R_DrawStat:

; 1631 : 		R_MarkLights(l, 1 << k, clmodel->nodes + clmodel->hulls[0].firstclipnode);

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clmodel$[ebp]
	imul	eax, DWORD PTR [edx+ecx+216], 52
	mov	ecx, DWORD PTR _clmodel$[ebp]
	add	eax, DWORD PTR [ecx+164]
	push	eax
	mov	edx, 1
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 1632 : 	}

	jmp	SHORT $LN2@R_DrawStat
$LN3@R_DrawStat:

; 1633 : 
; 1634 : 	psurf = &clmodel->surfaces[clmodel->firstmodelsurface];

	mov	eax, DWORD PTR _clmodel$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _clmodel$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _psurf$[ebp], ecx

; 1635 : 	for (i = 0; i < clmodel->nummodelsurfaces; i++, psurf++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_DrawStat
$LN5@R_DrawStat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], ecx
$LN7@R_DrawStat:
	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $LN6@R_DrawStat

; 1636 : 	{
; 1637 : 		if (R_CullSurface(psurf, &RI.frustum, 0))

	push	0
	push	OFFSET _RI+56
	mov	eax, DWORD PTR _psurf$[ebp]
	push	eax
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@R_DrawStat

; 1638 : 			continue;

	jmp	SHORT $LN5@R_DrawStat
$LN11@R_DrawStat:

; 1639 : 
; 1640 : 		if (psurf->flags & SURF_DRAWSKY)

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN12@R_DrawStat

; 1641 : 		{
; 1642 : 			// make sky chain to right clip the skybox
; 1643 : 			psurf->texturechain = skychain;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR _skychain
	mov	DWORD PTR [eax+40], ecx

; 1644 : 			skychain = psurf;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	DWORD PTR _skychain, eax

; 1645 : 		}

	jmp	SHORT $LN13@R_DrawStat
$LN12@R_DrawStat:

; 1646 : 		else
; 1647 : 		{
; 1648 : 			psurf->texturechain = psurf->texinfo->texture->texturechain;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+40], ecx

; 1649 : 			psurf->texinfo->texture->texturechain = psurf;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _psurf$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN13@R_DrawStat:

; 1650 : 		}
; 1651 : 	}

	jmp	SHORT $LN5@R_DrawStat
$LN6@R_DrawStat:

; 1652 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStaticModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_SetRenderMode
_TEXT	SEGMENT
tv65 = -68						; size = 4
_e$ = 8							; size = 4
_R_SetRenderMode PROC					; COMDAT

; 1417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1418 : 	switch( e->curstate.rendermode )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 5
	ja	$LN10@R_SetRende
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN12@R_SetRende[edx*4]
$LN4@R_SetRende:

; 1419 : 	{
; 1420 : 	case kRenderNormal:
; 1421 : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1422 : 		break;

	jmp	$LN2@R_SetRende
$LN5@R_SetRende:

; 1423 : 	case kRenderTransColor:
; 1424 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1425 : 		pglColor4ub( e->curstate.rendercolor.r, e->curstate.rendercolor.g, e->curstate.rendercolor.b, e->curstate.renderamt );

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+988]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+994]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, BYTE PTR [ecx+993]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	push	ecx
	call	DWORD PTR _pglColor4ub

; 1426 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1427 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1428 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1429 : 		break;

	jmp	$LN2@R_SetRende
$LN6@R_SetRende:

; 1430 : 	case kRenderTransAdd:
; 1431 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1432 : 		pglColor4f( tr.blend, tr.blend, tr.blend, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1433 : 		pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 1434 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 1435 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1436 : 		break;

	jmp	$LN2@R_SetRende
$LN7@R_SetRende:

; 1437 : 	case kRenderTransAlpha:
; 1438 : 		pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 1439 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1440 : 		if( CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN8@R_SetRende

; 1441 : 		{
; 1442 : 			pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1443 : 			pglColor4f( 1.0f, 1.0f, 1.0f, tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1444 : 			pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1445 : 		}

	jmp	SHORT $LN9@R_SetRende
$LN8@R_SetRende:

; 1446 : 		else
; 1447 : 		{
; 1448 : 			pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1449 : 			pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN9@R_SetRende:

; 1450 : 		}
; 1451 : 		pglAlphaFunc( GL_GREATER, 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1452 : 		break;

	jmp	SHORT $LN2@R_SetRende
$LN10@R_SetRende:

; 1453 : 	default:
; 1454 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1455 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1456 : 		pglColor4f( 1.0f, 1.0f, 1.0f, tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1457 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 1458 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable
$LN2@R_SetRende:

; 1459 : 		break;
; 1460 : 	}
; 1461 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@R_SetRende:
	DD	$LN4@R_SetRende
	DD	$LN5@R_SetRende
	DD	$LN10@R_SetRende
	DD	$LN10@R_SetRende
	DD	$LN7@R_SetRende
	DD	$LN6@R_SetRende
_R_SetRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_SurfaceCompare
_TEXT	SEGMENT
tv157 = -112						; size = 4
tv95 = -112						; size = 4
_len2$ = -44						; size = 4
_len1$ = -40						; size = 4
_org2$ = -36						; size = 12
_org1$ = -24						; size = 12
_surf2$ = -12						; size = 4
_surf1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_R_SurfaceCompare PROC					; COMDAT

; 1393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1394 : 	msurface_t	*surf1, *surf2;
; 1395 : 	vec3_t		org1, org2;
; 1396 : 	float		len1, len2;
; 1397 : 
; 1398 : 	surf1 = (msurface_t *)a->surf;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _surf1$[ebp], ecx

; 1399 : 	surf2 = (msurface_t *)b->surf;

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _surf2$[ebp], ecx

; 1400 : 
; 1401 : 	VectorAdd( RI.currententity->origin, surf1->info->origin, org1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf1$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+ecx+3224]
	addss	xmm0, DWORD PTR [eax+edx+24]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _org1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _surf1$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+24]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _org1$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf1$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+24]
	movss	DWORD PTR tv95[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _org1$[ebp+ecx], xmm0

; 1402 : 	VectorAdd( RI.currententity->origin, surf2->info->origin, org2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf2$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+ecx+3224]
	addss	xmm0, DWORD PTR [eax+edx+24]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _org2$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _surf2$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+24]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _org2$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf2$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+24]
	movss	DWORD PTR tv157[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv157[ebp]
	movss	DWORD PTR _org2$[ebp+ecx], xmm0

; 1403 : 
; 1404 : 	// compare by plane dists
; 1405 : 	len1 = DotProduct( org1, RI.vforward ) - RI.viewplanedist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org1$[ebp+ecx]
	mulss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _org1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _org1$[ebp+eax]
	mulss	xmm1, DWORD PTR _RI[ecx+224]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _RI+4872
	movss	DWORD PTR _len1$[ebp], xmm0

; 1406 : 	len2 = DotProduct( org2, RI.vforward ) - RI.viewplanedist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org2$[ebp+ecx]
	mulss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _org2$[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _org2$[ebp+eax]
	mulss	xmm1, DWORD PTR _RI[ecx+224]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _RI+4872
	movss	DWORD PTR _len2$[ebp], xmm0

; 1407 : 
; 1408 : 	if( len1 > len2 )

	movss	xmm0, DWORD PTR _len1$[ebp]
	comiss	xmm0, DWORD PTR _len2$[ebp]
	jbe	SHORT $LN2@R_SurfaceC

; 1409 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_SurfaceC
$LN2@R_SurfaceC:

; 1410 : 	if( len1 < len2 )

	movss	xmm0, DWORD PTR _len2$[ebp]
	comiss	xmm0, DWORD PTR _len1$[ebp]
	jbe	SHORT $LN3@R_SurfaceC

; 1411 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_SurfaceC
$LN3@R_SurfaceC:

; 1412 : 
; 1413 : 	return 0;

	xor	eax, eax
$LN1@R_SurfaceC:

; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SurfaceCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawTextureChains
_TEXT	SEGMENT
_t$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_R_DrawTextureChains PROC				; COMDAT

; 1214 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1215 : 	int		i;
; 1216 : 	msurface_t	*s;
; 1217 : 	texture_t		*t;
; 1218 : 
; 1219 : 	// make sure what color is reset
; 1220 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1221 : 	R_LoadIdentity();	// set identity matrix

	call	_R_LoadIdentity

; 1222 : 
; 1223 : 	GL_SetupFogColorForSurfaces();

	call	_GL_SetupFogColorForSurfaces

; 1224 : 
; 1225 : 	// restore worldmodel
; 1226 : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 1227 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 1228 : 
; 1229 : 	if( FBitSet( world.flags, FWORLD_SKYSPHERE ) && !FBitSet( world.flags, FWORLD_CUSTOM_SKYBOX ))

	mov	eax, DWORD PTR _world+8
	and	eax, 1
	je	SHORT $LN11@R_DrawText
	mov	eax, DWORD PTR _world+8
	and	eax, 2
	jne	SHORT $LN11@R_DrawText

; 1230 : 	{
; 1231 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1232 : 		pglColor3f( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f
$LN11@R_DrawText:

; 1233 : 	}
; 1234 : 
; 1235 : 	// clip skybox surfaces
; 1236 : 	for( s = skychain; s != NULL; s = s->texturechain )

	mov	eax, DWORD PTR _skychain
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN4@R_DrawText
$LN2@R_DrawText:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s$[ebp], ecx
$LN4@R_DrawText:
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN3@R_DrawText

; 1237 : 		R_AddSkyBoxSurface( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_R_AddSkyBoxSurface
	add	esp, 4
	jmp	SHORT $LN2@R_DrawText
$LN3@R_DrawText:

; 1238 : 
; 1239 : 	if( FBitSet( world.flags, FWORLD_SKYSPHERE ) && !FBitSet( world.flags, FWORLD_CUSTOM_SKYBOX ))

	mov	eax, DWORD PTR _world+8
	and	eax, 1
	je	SHORT $LN12@R_DrawText
	mov	eax, DWORD PTR _world+8
	and	eax, 2
	jne	SHORT $LN12@R_DrawText

; 1240 : 	{
; 1241 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1242 : 		if( skychain )

	cmp	DWORD PTR _skychain, 0
	je	SHORT $LN13@R_DrawText

; 1243 : 			R_DrawClouds();

	call	_R_DrawClouds
$LN13@R_DrawText:

; 1244 : 		skychain = NULL;

	mov	DWORD PTR _skychain, 0
$LN12@R_DrawText:

; 1245 : 	}
; 1246 : 
; 1247 : 	for( i = 0; i < cl.worldmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_DrawText
$LN5@R_DrawText:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_DrawText:
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	$LN6@R_DrawText

; 1248 : 	{
; 1249 : 		t = cl.worldmodel->textures[i];

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _t$[ebp], eax

; 1250 : 		if( !t ) continue;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN14@R_DrawText
	jmp	SHORT $LN5@R_DrawText
$LN14@R_DrawText:

; 1251 : 
; 1252 : 		s = t->texturechain;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _s$[ebp], ecx

; 1253 : 
; 1254 : 		if( !s || ( i == tr.skytexturenum ))

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN16@R_DrawText
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tr+1216
	jne	SHORT $LN15@R_DrawText
$LN16@R_DrawText:

; 1255 : 			continue;

	jmp	SHORT $LN5@R_DrawText
$LN15@R_DrawText:

; 1256 : 
; 1257 : 		if(( s->flags & SURF_DRAWTURB ) && clgame.movevars.wateralpha < 1.0f )

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN17@R_DrawText
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _clgame+1180
	jbe	SHORT $LN17@R_DrawText

; 1258 : 			continue;	// draw translucent water later

	jmp	SHORT $LN5@R_DrawText
$LN17@R_DrawText:

; 1259 : 
; 1260 : 		if( CL_IsQuakeCompatible() && FBitSet( s->flags, SURF_TRANSPARENT ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN18@R_DrawText
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	je	SHORT $LN18@R_DrawText

; 1261 : 		{
; 1262 : 			draw_alpha_surfaces = true;

	mov	DWORD PTR _draw_alpha_surfaces, 1

; 1263 : 			continue;	// draw transparent surfaces later

	jmp	$LN5@R_DrawText
$LN18@R_DrawText:

; 1264 :                     }
; 1265 : 
; 1266 : 		for( ; s != NULL; s = s->texturechain )

	jmp	SHORT $LN10@R_DrawText
$LN8@R_DrawText:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s$[ebp], ecx
$LN10@R_DrawText:
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN9@R_DrawText

; 1267 : 			R_RenderBrushPoly( s, CULL_VISIBLE );

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_R_RenderBrushPoly
	add	esp, 8
	jmp	SHORT $LN8@R_DrawText
$LN9@R_DrawText:

; 1268 : 		t->texturechain = NULL;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1269 : 	}

	jmp	$LN5@R_DrawText
$LN6@R_DrawText:

; 1270 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawTextureChains ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_RenderBrushPoly
_TEXT	SEGMENT
tv216 = -70248						; size = 4
tv157 = -70248						; size = 4
tv136 = -70248						; size = 4
_tmax$1 = -69732					; size = 4
_smax$2 = -69728					; size = 4
_sample_size$3 = -69724					; size = 4
_info$4 = -69720					; size = 4
_temp$5 = -69716					; size = 69696
_t$ = -20						; size = 4
_maps$ = -16						; size = 4
_is_mirror$ = -12					; size = 4
_is_dynamic$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_fa$ = 8						; size = 4
_cull_type$ = 12					; size = 4
_R_RenderBrushPoly PROC					; COMDAT

; 1054 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 70248				; 00011268H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1055 : 	qboolean	is_dynamic = false;

	mov	DWORD PTR _is_dynamic$[ebp], 0

; 1056 : 	qboolean	is_mirror = false;

	mov	DWORD PTR _is_mirror$[ebp], 0

; 1057 : 	int	maps;
; 1058 : 	texture_t	*t;
; 1059 : 
; 1060 : 	r_stats.c_world_polys++;

	mov	eax, DWORD PTR _r_stats
	add	eax, 1
	mov	DWORD PTR _r_stats, eax

; 1061 : 
; 1062 : 	if( fa->flags & SURF_DRAWSKY )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN5@R_RenderBr

; 1063 : 		return; // already handled

	jmp	$LN32@R_RenderBr
$LN5@R_RenderBr:

; 1064 : 
; 1065 : 	t = R_TextureAnimation( fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_R_TextureAnimation
	add	esp, 4
	mov	DWORD PTR _t$[ebp], eax

; 1066 : 
; 1067 : 	if (RP_NORMALPASS() && fa->flags & SURF_REFLECT)

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	$LN6@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483648			; 80000000H
	je	$LN6@R_RenderBr

; 1068 : 	{
; 1069 : 		if (fa->info->mirrortexturenum)

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	cmp	DWORD PTR [ecx+116], 0
	je	SHORT $LN8@R_RenderBr

; 1070 : 		{
; 1071 : 			GL_Bind(GL_TEXTURE0, fa->info->mirrortexturenum);

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1072 : 			is_mirror = true;

	mov	DWORD PTR _is_mirror$[ebp], 1

; 1073 : 
; 1074 : 			// BEGIN WATER STUFF
; 1075 : 			if (fa->flags & SURF_DRAWTURB)

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN10@R_RenderBr

; 1076 : 			{
; 1077 : 				R_BeginDrawMirror(fa);

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_R_BeginDrawMirror
	add	esp, 4

; 1078 : 				GL_Bind(GL_TEXTURE1, t->gl_texturenum);

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	1
	call	_GL_Bind
	add	esp, 8

; 1079 : 				pglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi
$LN10@R_RenderBr:

; 1080 : 			}
; 1081 : 		}

	jmp	SHORT $LN9@R_RenderBr
$LN8@R_RenderBr:

; 1082 : 		else GL_Bind(GL_TEXTURE0, t->gl_texturenum); // dummy

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8
$LN9@R_RenderBr:

; 1083 : 
; 1084 : 		// DEBUG: reset the mirror texture after drawing
; 1085 : 		fa->info->mirrortexturenum = 0;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx+116], 0

; 1086 : 	}

	jmp	SHORT $LN7@R_RenderBr
$LN6@R_RenderBr:

; 1087 : 	else GL_Bind(GL_TEXTURE0, t->gl_texturenum); // dummy

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8
$LN7@R_RenderBr:

; 1088 : 
; 1089 : 	if( FBitSet( fa->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN11@R_RenderBr

; 1090 : 	{	
; 1091 : 		// warp texture, no lightmaps
; 1092 : 		EmitWaterPolys( fa, (cull_type == CULL_BACKSIDE));

	cmp	DWORD PTR _cull_type$[ebp], 1
	jne	SHORT $LN37@R_RenderBr
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN38@R_RenderBr
$LN37@R_RenderBr:
	mov	DWORD PTR tv136[ebp], 0
$LN38@R_RenderBr:
	mov	eax, DWORD PTR tv136[ebp]
	push	eax
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	call	_EmitWaterPolys
	add	esp, 8

; 1093 : 		if (is_mirror) R_EndDrawMirror();

	cmp	DWORD PTR _is_mirror$[ebp], 0
	je	SHORT $LN12@R_RenderBr
	call	_R_EndDrawMirror
$LN12@R_RenderBr:

; 1094 : 		return;

	jmp	$LN32@R_RenderBr
$LN11@R_RenderBr:

; 1095 : 	}
; 1096 : 
; 1097 : 	if( t->fb_texturenum )

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+52]
	test	ecx, ecx
	je	SHORT $LN13@R_RenderBr

; 1098 : 	{
; 1099 : 		fa->info->lumachain = fullbright_surfaces[t->fb_texturenum];

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+52]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _fullbright_surfaces[ecx*4]
	mov	DWORD PTR [eax+108], ecx

; 1100 : 		fullbright_surfaces[t->fb_texturenum] = fa->info;

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+52]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _fullbright_surfaces[ecx*4], eax

; 1101 : 		draw_fullbrights = true;

	mov	DWORD PTR _draw_fullbrights, 1
$LN13@R_RenderBr:

; 1102 : 	}
; 1103 : 
; 1104 : 	if( CVAR_TO_BOOL( r_detailtextures ))

	cmp	DWORD PTR _r_detailtextures, 0
	je	SHORT $LN39@R_RenderBr
	mov	eax, DWORD PTR _r_detailtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN39@R_RenderBr
	mov	DWORD PTR tv157[ebp], 1
	jmp	SHORT $LN40@R_RenderBr
$LN39@R_RenderBr:
	mov	DWORD PTR tv157[ebp], 0
$LN40@R_RenderBr:
	cmp	DWORD PTR tv157[ebp], 0
	je	$LN20@R_RenderBr

; 1105 : 	{
; 1106 : 		if( pglIsEnabled( GL_FOG ))

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@R_RenderBr

; 1107 : 		{
; 1108 : 			// don't apply detail textures for windows in the fog
; 1109 : 			if( RI.currententity->curstate.rendermode != kRenderTransTexture )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN17@R_RenderBr

; 1110 : 			{
; 1111 : 				if( t->dt_texturenum )

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	test	ecx, ecx
	je	SHORT $LN18@R_RenderBr

; 1112 : 				{
; 1113 : 					fa->info->detailchain = detail_surfaces[t->dt_texturenum];

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _detail_surfaces[ecx*4]
	mov	DWORD PTR [eax+100], ecx

; 1114 : 					detail_surfaces[t->dt_texturenum] = fa->info;

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _detail_surfaces[ecx*4], eax

; 1115 : 				}

	jmp	SHORT $LN19@R_RenderBr
$LN18@R_RenderBr:

; 1116 : 				else
; 1117 : 				{
; 1118 : 					// draw stub detail texture for underwater surfaces
; 1119 : 					fa->info->detailchain = detail_surfaces[tr.grayTexture];

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _tr+12
	mov	eax, DWORD PTR _detail_surfaces[edx*4]
	mov	DWORD PTR [ecx+100], eax

; 1120 : 					detail_surfaces[tr.grayTexture] = fa->info;

	mov	eax, DWORD PTR _tr+12
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR _detail_surfaces[eax*4], edx
$LN19@R_RenderBr:

; 1121 : 				}
; 1122 : 				draw_details = true;

	mov	DWORD PTR _draw_details, 1
$LN17@R_RenderBr:

; 1123 : 			}
; 1124 : 		}

	jmp	SHORT $LN20@R_RenderBr
$LN15@R_RenderBr:

; 1125 : 		else if( t->dt_texturenum )

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	test	ecx, ecx
	je	SHORT $LN20@R_RenderBr

; 1126 : 		{
; 1127 : 			fa->info->detailchain = detail_surfaces[t->dt_texturenum];

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _detail_surfaces[ecx*4]
	mov	DWORD PTR [eax+100], ecx

; 1128 : 			detail_surfaces[t->dt_texturenum] = fa->info;

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, WORD PTR [eax+54]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _detail_surfaces[ecx*4], eax

; 1129 : 			draw_details = true;

	mov	DWORD PTR _draw_details, 1
$LN20@R_RenderBr:

; 1130 : 		}
; 1131 : 	}
; 1132 : 
; 1133 : 	if (is_mirror) R_BeginDrawMirror(fa);

	cmp	DWORD PTR _is_mirror$[ebp], 0
	je	SHORT $LN21@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_R_BeginDrawMirror
	add	esp, 4
$LN21@R_RenderBr:

; 1134 : 	DrawGLPoly( fa->polys, 0.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_DrawGLPoly
	add	esp, 12					; 0000000cH

; 1135 : 	if (is_mirror) R_EndDrawMirror();

	cmp	DWORD PTR _is_mirror$[ebp], 0
	je	SHORT $LN22@R_RenderBr
	call	_R_EndDrawMirror
$LN22@R_RenderBr:

; 1136 : 
; 1137 : 	if( RI.currententity->curstate.rendermode == kRenderNormal )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN23@R_RenderBr

; 1138 : 	{
; 1139 : 		// batch decals to draw later
; 1140 : 		if( tr.num_draw_decals < MAX_DECAL_SURFS && fa->pdecals )

	cmp	DWORD PTR _tr+83180, 4096		; 00001000H
	jge	SHORT $LN25@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN25@R_RenderBr

; 1141 : 			tr.draw_decals[tr.num_draw_decals++] = fa;

	mov	eax, DWORD PTR _tr+83180
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	DWORD PTR _tr[eax*4+66796], ecx
	mov	edx, DWORD PTR _tr+83180
	add	edx, 1
	mov	DWORD PTR _tr+83180, edx
$LN25@R_RenderBr:

; 1142 : 	}

	jmp	SHORT $LN24@R_RenderBr
$LN23@R_RenderBr:

; 1143 : 	else
; 1144 : 	{
; 1145 : 		// if rendermode != kRenderNormal draw decals sequentially
; 1146 : 		DrawSurfaceDecals( fa, true, (cull_type == CULL_BACKSIDE));

	cmp	DWORD PTR _cull_type$[ebp], 1
	jne	SHORT $LN41@R_RenderBr
	mov	DWORD PTR tv216[ebp], 1
	jmp	SHORT $LN42@R_RenderBr
$LN41@R_RenderBr:
	mov	DWORD PTR tv216[ebp], 0
$LN42@R_RenderBr:
	mov	eax, DWORD PTR tv216[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	call	_DrawSurfaceDecals
	add	esp, 12					; 0000000cH
$LN24@R_RenderBr:

; 1147 : 	}
; 1148 : 
; 1149 : 	// NOTE: draw mirror through in mirror show dummy lightmapped texture
; 1150 : 	if (fa->flags & SURF_REFLECT && RP_NORMALPASS())

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN26@R_RenderBr
	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN26@R_RenderBr

; 1151 : 		return; // no lightmaps for mirror

	jmp	$LN32@R_RenderBr
$LN26@R_RenderBr:

; 1152 : 
; 1153 : 	if( FBitSet( fa->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN27@R_RenderBr

; 1154 : 		return; // no lightmaps anyway

	jmp	$LN32@R_RenderBr
$LN27@R_RenderBr:

; 1155 : 
; 1156 : 	// check for lightmap modification
; 1157 : 	for( maps = 0; maps < MAXLIGHTMAPS && fa->styles[maps] != 255; maps++ )

	mov	DWORD PTR _maps$[ebp], 0
	jmp	SHORT $LN4@R_RenderBr
$LN2@R_RenderBr:
	mov	eax, DWORD PTR _maps$[ebp]
	add	eax, 1
	mov	DWORD PTR _maps$[ebp], eax
$LN4@R_RenderBr:
	cmp	DWORD PTR _maps$[ebp], 4
	jge	SHORT $LN3@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN3@R_RenderBr

; 1158 : 	{
; 1159 : 		if( tr.lightstylevalue[fa->styles[maps]] != fa->cached_light[maps] )

	mov	eax, DWORD PTR _fa$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	mov	edx, DWORD PTR _maps$[ebp]
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR _tr[ecx*4+87324]
	cmp	ecx, DWORD PTR [eax+edx*4+64]
	je	SHORT $LN28@R_RenderBr

; 1160 : 			goto dynamic;

	jmp	SHORT $dynamic$43
$LN28@R_RenderBr:

; 1161 : 	}

	jmp	SHORT $LN2@R_RenderBr
$LN3@R_RenderBr:

; 1162 : 
; 1163 : 	// dynamic this frame or dynamic previously
; 1164 : 	if(( fa->dlightframe == tr.framecount ))

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR _tr+83200
	jne	SHORT $LN30@R_RenderBr
$dynamic$43:

; 1165 : 	{
; 1166 : dynamic:
; 1167 : 		// NOTE: at this point we have only valid textures
; 1168 : 		if( r_dynamic->value ) is_dynamic = true;

	mov	eax, DWORD PTR _r_dynamic
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@R_RenderBr
	mov	DWORD PTR _is_dynamic$[ebp], 1
$LN30@R_RenderBr:

; 1169 : 	}
; 1170 : 
; 1171 : 	if( is_dynamic )

	cmp	DWORD PTR _is_dynamic$[ebp], 0
	je	$LN31@R_RenderBr

; 1172 : 	{
; 1173 : 		if(( fa->styles[maps] >= 32 || fa->styles[maps] == 0 || fa->styles[maps] == 20 ) && ( fa->dlightframe != tr.framecount ))

	mov	eax, DWORD PTR _fa$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN35@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN35@R_RenderBr
	mov	eax, DWORD PTR _fa$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 20					; 00000014H
	jne	$LN33@R_RenderBr
$LN35@R_RenderBr:
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR _tr+83200
	je	$LN33@R_RenderBr

; 1174 : 		{
; 1175 : 			byte		temp[132*132*4];
; 1176 : 			mextrasurf_t	*info = fa->info;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$4[ebp], ecx

; 1177 : 			int		sample_size;
; 1178 : 			int		smax, tmax;
; 1179 : 
; 1180 : 			sample_size = Mod_SampleSizeForFace( fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$3[ebp], eax

; 1181 : 			smax = ( info->lightextents[0] / sample_size ) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$4[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$3[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$2[ebp], eax

; 1182 : 			tmax = ( info->lightextents[1] / sample_size ) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$4[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$3[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$1[ebp], eax

; 1183 : 
; 1184 : 			R_BuildLightMap( fa, temp, smax * 4, true );

	push	1
	mov	eax, DWORD PTR _smax$2[ebp]
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _temp$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _fa$[ebp]
	push	edx
	call	_R_BuildLightMap
	add	esp, 16					; 00000010H

; 1185 : 			R_SetCacheState( fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_R_SetCacheState
	add	esp, 4

; 1186 :                               
; 1187 : 			GL_Bind( GL_TEXTURE0, tr.lightmapTextures[fa->lightmaptexturenum] );

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _tr[ecx*4+28]
	push	edx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1188 : 
; 1189 : 			pglTexSubImage2D( GL_TEXTURE_2D, 0, fa->light_s, fa->light_t, smax, tmax,

	lea	eax, DWORD PTR _temp$5[ebp]
	push	eax
	push	5121					; 00001401H
	push	6408					; 00001908H
	mov	ecx, DWORD PTR _tmax$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _smax$2[ebp]
	push	edx
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglTexSubImage2D

; 1190 : 			GL_RGBA, GL_UNSIGNED_BYTE, temp );
; 1191 : 
; 1192 : 			fa->info->lightmapchain = gl_lms.lightmap_surfaces[fa->lightmaptexturenum];

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _gl_lms[ecx*4+4104]
	mov	DWORD PTR [eax+96], ecx

; 1193 : 			gl_lms.lightmap_surfaces[fa->lightmaptexturenum] = fa;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	DWORD PTR _gl_lms[ecx*4+4104], edx

; 1194 : 		}

	jmp	SHORT $LN34@R_RenderBr
$LN33@R_RenderBr:

; 1195 : 		else
; 1196 : 		{
; 1197 : 			fa->info->lightmapchain = gl_lms.dynamic_surfaces;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _gl_lms+4100
	mov	DWORD PTR [ecx+96], edx

; 1198 : 			gl_lms.dynamic_surfaces = fa;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	DWORD PTR _gl_lms+4100, eax
$LN34@R_RenderBr:

; 1199 : 		}
; 1200 : 	}

	jmp	SHORT $LN32@R_RenderBr
$LN31@R_RenderBr:

; 1201 : 	else
; 1202 : 	{
; 1203 : 		fa->info->lightmapchain = gl_lms.lightmap_surfaces[fa->lightmaptexturenum];

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _gl_lms[ecx*4+4104]
	mov	DWORD PTR [eax+96], ecx

; 1204 : 		gl_lms.lightmap_surfaces[fa->lightmaptexturenum] = fa;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _fa$[ebp]
	mov	DWORD PTR _gl_lms[ecx*4+4104], edx
$LN32@R_RenderBr:

; 1205 : 	}
; 1206 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderBrushPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_RenderDetails
_TEXT	SEGMENT
_i$ = -20						; size = 4
_fa$ = -16						; size = 4
_p$ = -12						; size = 4
_es$ = -8						; size = 4
_glt$ = -4						; size = 4
_R_RenderDetails PROC					; COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1005 : 	gl_texture_t	*glt;
; 1006 : 	mextrasurf_t	*es, *p;
; 1007 : 	msurface_t	*fa;
; 1008 : 	int		i;
; 1009 : 
; 1010 : 	if( !draw_details )

	cmp	DWORD PTR _draw_details, 0
	jne	SHORT $LN8@R_RenderDe

; 1011 : 		return;

	jmp	$LN1@R_RenderDe
$LN8@R_RenderDe:

; 1012 : 
; 1013 : 	GL_SetupFogColorForSurfaces();

	call	_GL_SetupFogColorForSurfaces

; 1014 : 
; 1015 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1016 : 	pglBlendFunc( GL_DST_COLOR, GL_SRC_COLOR );

	push	768					; 00000300H
	push	774					; 00000306H
	call	DWORD PTR _pglBlendFunc

; 1017 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );

	push	8449					; 00002101H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1018 : 	pglDepthFunc( GL_EQUAL );

	push	514					; 00000202H
	call	DWORD PTR _pglDepthFunc

; 1019 : 
; 1020 : 	for( i = 1; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@R_RenderDe
$LN2@R_RenderDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_RenderDe:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	$LN3@R_RenderDe

; 1021 : 	{
; 1022 : 		es = detail_surfaces[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _detail_surfaces[eax*4]
	mov	DWORD PTR _es$[ebp], ecx

; 1023 : 		if( !es ) continue;

	cmp	DWORD PTR _es$[ebp], 0
	jne	SHORT $LN9@R_RenderDe
	jmp	SHORT $LN2@R_RenderDe
$LN9@R_RenderDe:

; 1024 : 
; 1025 : 		GL_Bind( GL_TEXTURE0, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 1026 : 
; 1027 : 		for( p = es; p; p = p->detailchain )

	mov	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN7@R_RenderDe
$LN5@R_RenderDe:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _p$[ebp], ecx
$LN7@R_RenderDe:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@R_RenderDe

; 1028 : 		{
; 1029 : 			fa = p->surf;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _fa$[ebp], ecx

; 1030 : 			glt = R_GetTexture( fa->texinfo->texture->gl_texturenum ); // get texture scale

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1031 : 			DrawGLPoly( fa->polys, glt->xscale, glt->yscale );

	mov	eax, DWORD PTR _glt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+304]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _glt$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+300]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_DrawGLPoly
	add	esp, 12					; 0000000cH

; 1032 :                     }

	jmp	SHORT $LN5@R_RenderDe
$LN6@R_RenderDe:

; 1033 : 
; 1034 : 		detail_surfaces[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _detail_surfaces[eax*4], 0

; 1035 : 		es->detailchain = NULL;		

	mov	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR [eax+100], 0

; 1036 : 	}

	jmp	$LN2@R_RenderDe
$LN3@R_RenderDe:

; 1037 : 
; 1038 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1039 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1040 : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 1041 : 
; 1042 : 	draw_details = false;

	mov	DWORD PTR _draw_details, 0

; 1043 : 
; 1044 : 	// restore fog here
; 1045 : 	GL_ResetFogColor();

	call	_GL_ResetFogColor
$LN1@R_RenderDe:

; 1046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderDetails ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_RenderFullbrights
_TEXT	SEGMENT
_i$ = -12						; size = 4
_p$ = -8						; size = 4
_es$ = -4						; size = 4
_R_RenderFullbrights PROC				; COMDAT

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 962  : 	mextrasurf_t	*es, *p;
; 963  : 	int		i;
; 964  : 
; 965  : 	if( !draw_fullbrights )

	cmp	DWORD PTR _draw_fullbrights, 0
	jne	SHORT $LN8@R_RenderFu

; 966  : 		return;

	jmp	$LN1@R_RenderFu
$LN8@R_RenderFu:

; 967  : 
; 968  : 	R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4

; 969  : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 970  : 	pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 971  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 972  : 	pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 973  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 974  : 
; 975  : 	for( i = 1; i < MAX_TEXTURES; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@R_RenderFu
$LN2@R_RenderFu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_RenderFu:
	cmp	DWORD PTR _i$[ebp], 4096		; 00001000H
	jge	SHORT $LN3@R_RenderFu

; 976  : 	{
; 977  : 		es = fullbright_surfaces[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fullbright_surfaces[eax*4]
	mov	DWORD PTR _es$[ebp], ecx

; 978  : 		if( !es ) continue;

	cmp	DWORD PTR _es$[ebp], 0
	jne	SHORT $LN9@R_RenderFu
	jmp	SHORT $LN2@R_RenderFu
$LN9@R_RenderFu:

; 979  : 
; 980  : 		GL_Bind( GL_TEXTURE0, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 981  : 
; 982  : 		for( p = es; p; p = p->lumachain )

	mov	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN7@R_RenderFu
$LN5@R_RenderFu:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _p$[ebp], ecx
$LN7@R_RenderFu:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN6@R_RenderFu

; 983  : 			DrawGLPoly( p->surf->polys, 0.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_DrawGLPoly
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@R_RenderFu
$LN6@R_RenderFu:

; 984  : 
; 985  : 		fullbright_surfaces[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fullbright_surfaces[eax*4], 0

; 986  : 		es->lumachain = NULL;

	mov	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR [eax+108], 0

; 987  : 	}

	jmp	$LN2@R_RenderFu
$LN3@R_RenderFu:

; 988  : 
; 989  : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 990  : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 991  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 992  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 993  : 
; 994  : 	draw_fullbrights = false;

	mov	DWORD PTR _draw_fullbrights, 0

; 995  : 	R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN1@R_RenderFu:

; 996  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderFullbrights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_BlendLightmaps
_TEXT	SEGMENT
tv149 = -104						; size = 4
tv82 = -104						; size = 4
tv76 = -104						; size = 4
tv67 = -104						; size = 4
_drawsurf$1 = -36					; size = 4
_base$2 = -32						; size = 4
_info$3 = -28						; size = 4
_sample_size$4 = -24					; size = 4
_tmax$5 = -20						; size = 4
_smax$6 = -16						; size = 4
_i$ = -12						; size = 4
_newsurf$ = -8						; size = 4
_surf$ = -4						; size = 4
_R_BlendLightmaps PROC					; COMDAT

; 820  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 821  : 	msurface_t	*surf, *newsurf = NULL;

	mov	DWORD PTR _newsurf$[ebp], 0

; 822  : 	int		i;
; 823  : 
; 824  : 	if( CVAR_TO_BOOL( r_fullbright ) || !cl.worldmodel->lightdata )

	cmp	DWORD PTR _r_fullbright, 0
	je	SHORT $LN39@R_BlendLig
	mov	eax, DWORD PTR _r_fullbright
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN39@R_BlendLig
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN40@R_BlendLig
$LN39@R_BlendLig:
	mov	DWORD PTR tv67[ebp], 0
$LN40@R_BlendLig:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN20@R_BlendLig
	mov	eax, DWORD PTR _cl+4579004
	cmp	DWORD PTR [eax+380], 0
	jne	SHORT $LN19@R_BlendLig
$LN20@R_BlendLig:

; 825  : 		return;

	jmp	$LN1@R_BlendLig
$LN19@R_BlendLig:

; 826  : 
; 827  : 	if( RI.currententity )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN2@R_BlendLig

; 828  : 	{
; 829  : 		if( RI.currententity->curstate.effects & EF_FULLBRIGHT )

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 134217728				; 08000000H
	je	SHORT $LN22@R_BlendLig

; 830  : 			return;	// disabled by user

	jmp	$LN1@R_BlendLig
$LN22@R_BlendLig:

; 831  : 
; 832  : 		// check for rendermode
; 833  : 		switch( RI.currententity->curstate.rendermode )

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	sub	edx, 1
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 4
	ja	SHORT $LN2@R_BlendLig
	mov	eax, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN45@R_BlendLig[eax*4]
$LN23@R_BlendLig:

; 834  : 		{
; 835  : 		case kRenderTransTexture:
; 836  : 		case kRenderTransColor:
; 837  : 		case kRenderTransAdd:
; 838  : 		case kRenderGlow:
; 839  : 			return; // no lightmaps

	jmp	$LN1@R_BlendLig
$LN2@R_BlendLig:

; 840  : 		}
; 841  : 	}
; 842  : 
; 843  : 	GL_SetupFogColorForSurfaces ();

	call	_GL_SetupFogColorForSurfaces

; 844  : 
; 845  : 	if( !CVAR_TO_BOOL( r_lightmap ))

	cmp	DWORD PTR _r_lightmap, 0
	je	SHORT $LN41@R_BlendLig
	mov	eax, DWORD PTR _r_lightmap
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@R_BlendLig
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN42@R_BlendLig
$LN41@R_BlendLig:
	mov	DWORD PTR tv82[ebp], 0
$LN42@R_BlendLig:
	cmp	DWORD PTR tv82[ebp], 0
	jne	SHORT $LN27@R_BlendLig

; 846  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN28@R_BlendLig
$LN27@R_BlendLig:

; 847  : 	else pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN28@R_BlendLig:

; 848  : 
; 849  : 	// lightmapped solid surfaces
; 850  : 	pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 851  : 	pglDepthFunc( GL_EQUAL );

	push	514					; 00000202H
	call	DWORD PTR _pglDepthFunc

; 852  : 
; 853  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 854  : 	pglBlendFunc( GL_ZERO, GL_SRC_COLOR );

	push	768					; 00000300H
	push	0
	call	DWORD PTR _pglBlendFunc

; 855  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 856  : 
; 857  : 	// render static lightmaps first
; 858  : 	for( i = 0; i < MAX_LIGHTMAPS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@R_BlendLig
$LN4@R_BlendLig:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@R_BlendLig:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN5@R_BlendLig

; 859  : 	{
; 860  : 		if( gl_lms.lightmap_surfaces[i] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _gl_lms[eax*4+4104], 0
	je	SHORT $LN8@R_BlendLig

; 861  : 		{
; 862  : 			GL_Bind( GL_TEXTURE0, tr.lightmapTextures[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+28]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 863  : 
; 864  : 			for( surf = gl_lms.lightmap_surfaces[i]; surf != NULL; surf = surf->info->lightmapchain )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4+4104]
	mov	DWORD PTR _surf$[ebp], ecx
	jmp	SHORT $LN9@R_BlendLig
$LN7@R_BlendLig:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _surf$[ebp], edx
$LN9@R_BlendLig:
	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN8@R_BlendLig

; 865  : 			{
; 866  : 				if( surf->polys ) DrawGLPolyChain( surf->polys, 0.0f, 0.0f );

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN30@R_BlendLig
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_DrawGLPolyChain
	add	esp, 12					; 0000000cH
$LN30@R_BlendLig:

; 867  : 			}

	jmp	SHORT $LN7@R_BlendLig
$LN8@R_BlendLig:

; 868  : 		}
; 869  : 	}

	jmp	$LN4@R_BlendLig
$LN5@R_BlendLig:

; 870  : 
; 871  : 	// render dynamic lightmaps
; 872  : 	if( CVAR_TO_BOOL( r_dynamic ))

	cmp	DWORD PTR _r_dynamic, 0
	je	SHORT $LN43@R_BlendLig
	mov	eax, DWORD PTR _r_dynamic
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN43@R_BlendLig
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN44@R_BlendLig
$LN43@R_BlendLig:
	mov	DWORD PTR tv149[ebp], 0
$LN44@R_BlendLig:
	cmp	DWORD PTR tv149[ebp], 0
	je	$LN17@R_BlendLig

; 873  : 	{
; 874  : 		LM_InitBlock();

	call	_LM_InitBlock

; 875  : 
; 876  : 		GL_Bind( GL_TEXTURE0, tr.dlightTexture );

	mov	eax, DWORD PTR _tr+1052
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 877  : 		newsurf = gl_lms.dynamic_surfaces;

	mov	eax, DWORD PTR _gl_lms+4100
	mov	DWORD PTR _newsurf$[ebp], eax

; 878  : 
; 879  : 		for( surf = gl_lms.dynamic_surfaces; surf != NULL; surf = surf->info->lightmapchain )

	mov	eax, DWORD PTR _gl_lms+4100
	mov	DWORD PTR _surf$[ebp], eax
	jmp	SHORT $LN12@R_BlendLig
$LN10@R_BlendLig:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _surf$[ebp], edx
$LN12@R_BlendLig:
	cmp	DWORD PTR _surf$[ebp], 0
	je	$LN11@R_BlendLig

; 880  : 		{
; 881  : 			int		smax, tmax;
; 882  : 			int		sample_size;
; 883  : 			mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$3[ebp], ecx

; 884  : 			byte		*base;
; 885  : 
; 886  : 			sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$4[ebp], eax

; 887  : 			smax = ( info->lightextents[0] / sample_size ) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$3[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$4[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$6[ebp], eax

; 888  : 			tmax = ( info->lightextents[1] / sample_size ) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$3[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$4[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$5[ebp], eax

; 889  : 
; 890  : 			if( LM_AllocBlock( smax, tmax, &surf->info->dlight_s, &surf->info->dlight_t ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _tmax$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _smax$6[ebp]
	push	edx
	call	_LM_AllocBlock
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN32@R_BlendLig

; 891  : 			{
; 892  : 				base = gl_lms.lightmap_buffer;

	mov	DWORD PTR _base$2[ebp], OFFSET _gl_lms+5128

; 893  : 				base += ( surf->info->dlight_t * BLOCK_SIZE + surf->info->dlight_s ) * 4;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+44]
	imul	edx, DWORD PTR _tr+87580
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _base$2[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _base$2[ebp], ecx

; 894  : 
; 895  : 				R_BuildLightMap( surf, base, BLOCK_SIZE * 4, true );

	push	1
	mov	eax, DWORD PTR _tr+87580
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	call	_R_BuildLightMap
	add	esp, 16					; 00000010H

; 896  : 			}

	jmp	$LN33@R_BlendLig
$LN32@R_BlendLig:

; 897  : 			else
; 898  : 			{
; 899  : 				msurface_t	*drawsurf;
; 900  : 
; 901  : 				// upload what we have so far
; 902  : 				LM_UploadBlock( true );

	push	1
	call	_LM_UploadBlock
	add	esp, 4

; 903  : 
; 904  : 				// draw all surfaces that use this lightmap
; 905  : 				for( drawsurf = newsurf; drawsurf != surf; drawsurf = drawsurf->info->lightmapchain )

	mov	eax, DWORD PTR _newsurf$[ebp]
	mov	DWORD PTR _drawsurf$1[ebp], eax
	jmp	SHORT $LN15@R_BlendLig
$LN13@R_BlendLig:
	mov	eax, DWORD PTR _drawsurf$1[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _drawsurf$1[ebp], edx
$LN15@R_BlendLig:
	mov	eax, DWORD PTR _drawsurf$1[ebp]
	cmp	eax, DWORD PTR _surf$[ebp]
	je	SHORT $LN14@R_BlendLig

; 906  : 				{
; 907  : 					if( drawsurf->polys )

	mov	eax, DWORD PTR _drawsurf$1[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN34@R_BlendLig

; 908  : 					{
; 909  : 						DrawGLPolyChain( drawsurf->polys,

	mov	eax, DWORD PTR _drawsurf$1[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _drawsurf$1[ebp]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, DWORD PTR [ecx+44]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _tr+87580
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _drawsurf$1[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _drawsurf$1[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [edx+40]
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _tr+87580
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _drawsurf$1[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_DrawGLPolyChain
	add	esp, 12					; 0000000cH
$LN34@R_BlendLig:

; 910  : 						( drawsurf->light_s - drawsurf->info->dlight_s ) * ( 1.0f / (float)BLOCK_SIZE ), 
; 911  : 						( drawsurf->light_t - drawsurf->info->dlight_t ) * ( 1.0f / (float)BLOCK_SIZE ));
; 912  : 					}
; 913  : 				}

	jmp	$LN13@R_BlendLig
$LN14@R_BlendLig:

; 914  : 
; 915  : 				newsurf = drawsurf;

	mov	eax, DWORD PTR _drawsurf$1[ebp]
	mov	DWORD PTR _newsurf$[ebp], eax

; 916  : 
; 917  : 				// clear the block
; 918  : 				LM_InitBlock();

	call	_LM_InitBlock

; 919  : 
; 920  : 				// try uploading the block now
; 921  : 				if( !LM_AllocBlock( smax, tmax, &surf->info->dlight_s, &surf->info->dlight_t ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _tmax$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _smax$6[ebp]
	push	edx
	call	_LM_AllocBlock
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN35@R_BlendLig

; 922  : 					Host_Error( "AllocBlock: full\n" );

	push	OFFSET ??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@
	call	_Host_Error
	add	esp, 4
$LN35@R_BlendLig:

; 923  : 
; 924  : 				base = gl_lms.lightmap_buffer;

	mov	DWORD PTR _base$2[ebp], OFFSET _gl_lms+5128

; 925  : 				base += ( surf->info->dlight_t * BLOCK_SIZE + surf->info->dlight_s ) * 4;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+44]
	imul	edx, DWORD PTR _tr+87580
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _base$2[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _base$2[ebp], ecx

; 926  : 
; 927  : 				R_BuildLightMap( surf, base, BLOCK_SIZE * 4, true );

	push	1
	mov	eax, DWORD PTR _tr+87580
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _base$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	call	_R_BuildLightMap
	add	esp, 16					; 00000010H
$LN33@R_BlendLig:

; 928  : 			}
; 929  : 		}

	jmp	$LN10@R_BlendLig
$LN11@R_BlendLig:

; 930  : 
; 931  : 		// draw remainder of dynamic lightmaps that haven't been uploaded yet
; 932  : 		if( newsurf ) LM_UploadBlock( true );

	cmp	DWORD PTR _newsurf$[ebp], 0
	je	SHORT $LN36@R_BlendLig
	push	1
	call	_LM_UploadBlock
	add	esp, 4
$LN36@R_BlendLig:

; 933  : 
; 934  : 		for( surf = newsurf; surf != NULL; surf = surf->info->lightmapchain )

	mov	eax, DWORD PTR _newsurf$[ebp]
	mov	DWORD PTR _surf$[ebp], eax
	jmp	SHORT $LN18@R_BlendLig
$LN16@R_BlendLig:
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _surf$[ebp], edx
$LN18@R_BlendLig:
	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN17@R_BlendLig

; 935  : 		{
; 936  : 			if( surf->polys )

	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN37@R_BlendLig

; 937  : 			{
; 938  : 				DrawGLPolyChain( surf->polys,

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, DWORD PTR [ecx+44]
	cvtsi2ss xmm0, eax
	cvtsi2ss xmm1, DWORD PTR _tr+87580
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, DWORD PTR [edx+40]
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _tr+87580
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_DrawGLPolyChain
	add	esp, 12					; 0000000cH
$LN37@R_BlendLig:

; 939  : 				( surf->light_s - surf->info->dlight_s ) * ( 1.0f / (float)BLOCK_SIZE ),
; 940  : 				( surf->light_t - surf->info->dlight_t ) * ( 1.0f / (float)BLOCK_SIZE ));
; 941  : 			}
; 942  : 		}

	jmp	$LN16@R_BlendLig
$LN17@R_BlendLig:

; 943  : 	}
; 944  : 
; 945  : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 946  : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 947  : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 948  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 949  : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 950  : 
; 951  : 	// restore fog here
; 952  : 	GL_ResetFogColor();

	call	_GL_ResetFogColor
$LN1@R_BlendLig:

; 953  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@R_BlendLig:
	DD	$LN23@R_BlendLig
	DD	$LN23@R_BlendLig
	DD	$LN23@R_BlendLig
	DD	$LN2@R_BlendLig
	DD	$LN23@R_BlendLig
_R_BlendLightmaps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _DrawGLPolyChain
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_v$2 = -8						; size = 4
_dynamic$ = -4						; size = 4
_p$ = 8							; size = 4
_soffset$ = 12						; size = 4
_toffset$ = 16						; size = 4
_DrawGLPolyChain PROC					; COMDAT

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 791  : 	qboolean	dynamic = true;

	mov	DWORD PTR _dynamic$[ebp], 1

; 792  : 
; 793  : 	if( soffset == 0.0f && toffset == 0.0f )

	movss	xmm0, DWORD PTR _soffset$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@DrawGLPoly
	movss	xmm0, DWORD PTR _toffset$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@DrawGLPoly

; 794  : 		dynamic = false;

	mov	DWORD PTR _dynamic$[ebp], 0
$LN8@DrawGLPoly:

; 795  : 
; 796  : 	for( ; p != NULL; p = p->chain )

	jmp	SHORT $LN4@DrawGLPoly
$LN2@DrawGLPoly:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@DrawGLPoly:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@DrawGLPoly

; 797  : 	{
; 798  : 		float	*v;
; 799  : 		int	i;
; 800  : 
; 801  : 		pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 802  : 
; 803  : 		v = p->verts[0];

	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _v$2[ebp], eax

; 804  : 		for( i = 0; i < p->numverts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@DrawGLPoly
$LN5@DrawGLPoly:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
	mov	ecx, DWORD PTR _v$2[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$2[ebp], ecx
$LN7@DrawGLPoly:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN6@DrawGLPoly

; 805  : 		{
; 806  : 			if( !dynamic ) pglTexCoord2f( v[5], v[6] );

	cmp	DWORD PTR _dynamic$[ebp], 0
	jne	SHORT $LN9@DrawGLPoly
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$2[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$2[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN10@DrawGLPoly
$LN9@DrawGLPoly:

; 807  : 			else pglTexCoord2f( v[5] - soffset, v[6] - toffset );

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _v$2[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _toffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _v$2[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _soffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN10@DrawGLPoly:

; 808  : 			pglVertex3fv( v );

	mov	eax, DWORD PTR _v$2[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 809  : 		}

	jmp	$LN5@DrawGLPoly
$LN6@DrawGLPoly:

; 810  : 		pglEnd ();

	call	DWORD PTR _pglEnd

; 811  : 	}

	jmp	$LN2@DrawGLPoly
$LN3@DrawGLPoly:

; 812  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawGLPolyChain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_BuildLightMap
_TEXT	SEGMENT
tv208 = -116						; size = 4
tv197 = -116						; size = 4
tv186 = -116						; size = 4
_lm$ = -48						; size = 4
_info$ = -44						; size = 4
_sample_size$ = -40					; size = 4
_t$ = -36						; size = 4
_s$ = -32						; size = 4
_size$ = -28						; size = 4
_map$ = -24						; size = 4
_i$ = -20						; size = 4
_scale$ = -16						; size = 4
_bl$ = -12						; size = 4
_tmax$ = -8						; size = 4
_smax$ = -4						; size = 4
_surf$ = 8						; size = 4
_dest$ = 12						; size = 4
_stride$ = 16						; size = 4
_dynamic$ = 20						; size = 4
_R_BuildLightMap PROC					; COMDAT

; 653  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 654  : 	int		smax, tmax;
; 655  : 	uint		*bl, scale;
; 656  : 	int		i, map, size, s, t;
; 657  : 	int		sample_size;
; 658  : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 659  : 	color24		*lm;
; 660  : 
; 661  : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	mov	DWORD PTR _sample_size$[ebp], eax

; 662  : 	smax = ( info->lightextents[0] / sample_size ) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _smax$[ebp], eax

; 663  : 	tmax = ( info->lightextents[1] / sample_size ) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [ecx+eax+52]
	cdq
	idiv	DWORD PTR _sample_size$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmax$[ebp], eax

; 664  : 	size = smax * tmax;

	mov	eax, DWORD PTR _smax$[ebp]
	imul	eax, DWORD PTR _tmax$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 665  : 
; 666  : 	lm = surf->samples;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _lm$[ebp], ecx

; 667  : 
; 668  : 	memset( r_blocklights, 0, sizeof( uint ) * size * 3 );

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	imul	ecx, eax, 3
	push	ecx
	push	0
	push	OFFSET _r_blocklights
	call	_memset
	add	esp, 12					; 0000000cH

; 669  : 
; 670  : 	// add all the lightmaps
; 671  : 	for( map = 0; map < MAXLIGHTMAPS && surf->styles[map] != 255 && lm; map++ )

	mov	DWORD PTR _map$[ebp], 0
	jmp	SHORT $LN4@R_BuildLig
$LN2@R_BuildLig:
	mov	eax, DWORD PTR _map$[ebp]
	add	eax, 1
	mov	DWORD PTR _map$[ebp], eax
$LN4@R_BuildLig:
	cmp	DWORD PTR _map$[ebp], 4
	jge	$LN3@R_BuildLig
	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	$LN3@R_BuildLig
	cmp	DWORD PTR _lm$[ebp], 0
	je	$LN3@R_BuildLig

; 672  : 	{
; 673  : 		scale = tr.lightstylevalue[surf->styles[map]];

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _map$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	mov	edx, DWORD PTR _tr[ecx*4+87324]
	mov	DWORD PTR _scale$[ebp], edx

; 674  : 
; 675  : 		for( i = 0, bl = r_blocklights; i < size; i++, bl += 3, lm++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _bl$[ebp], OFFSET _r_blocklights
	jmp	SHORT $LN7@R_BuildLig
$LN5@R_BuildLig:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _bl$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _bl$[ebp], ecx
	mov	edx, DWORD PTR _lm$[ebp]
	add	edx, 3
	mov	DWORD PTR _lm$[ebp], edx
$LN7@R_BuildLig:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	$LN6@R_BuildLig

; 676  : 		{
; 677  : 			bl[0] += LightToTexGamma( lm->r ) * scale;

	mov	eax, 4
	imul	esi, eax, 0
	mov	ecx, DWORD PTR _lm$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	movzx	eax, al
	imul	eax, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR _bl$[ebp]
	add	eax, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 678  : 			bl[1] += LightToTexGamma( lm->g ) * scale;

	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edx, DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _bl$[ebp]
	add	edx, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 679  : 			bl[2] += LightToTexGamma( lm->b ) * scale;

	mov	esi, 4
	shl	esi, 1
	mov	eax, DWORD PTR _lm$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edx, DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _bl$[ebp]
	add	edx, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 680  : 		}

	jmp	$LN5@R_BuildLig
$LN6@R_BuildLig:

; 681  : 	}

	jmp	$LN2@R_BuildLig
$LN3@R_BuildLig:

; 682  : 
; 683  : 	// add all the dynamic lights
; 684  : 	if( surf->dlightframe == tr.framecount && dynamic )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	ecx, DWORD PTR _tr+83200
	jne	SHORT $LN14@R_BuildLig
	cmp	DWORD PTR _dynamic$[ebp], 0
	je	SHORT $LN14@R_BuildLig

; 685  : 		R_AddDynamicLights( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_R_AddDynamicLights
	add	esp, 4
$LN14@R_BuildLig:

; 686  : 
; 687  : 	// Put into texture format
; 688  : 	stride -= (smax << 2);

	mov	eax, DWORD PTR _smax$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _stride$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _stride$[ebp], ecx

; 689  : 	bl = r_blocklights;

	mov	DWORD PTR _bl$[ebp], OFFSET _r_blocklights

; 690  : 
; 691  : 	for( t = 0; t < tmax; t++, dest += stride )

	mov	DWORD PTR _t$[ebp], 0
	jmp	SHORT $LN10@R_BuildLig
$LN8@R_BuildLig:
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	mov	ecx, DWORD PTR _dest$[ebp]
	add	ecx, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _dest$[ebp], ecx
$LN10@R_BuildLig:
	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _tmax$[ebp]
	jge	$LN1@R_BuildLig

; 692  : 	{
; 693  : 		for( s = 0; s < smax; s++ )

	mov	DWORD PTR _s$[ebp], 0
	jmp	SHORT $LN13@R_BuildLig
$LN11@R_BuildLig:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN13@R_BuildLig:
	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _smax$[ebp]
	jge	$LN12@R_BuildLig

; 694  : 		{
; 695  : 			dest[0] = Q_min((bl[0] >> 7), 255 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bl$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	shr	eax, 7
	cmp	eax, 255				; 000000ffH
	jae	SHORT $LN16@R_BuildLig
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _bl$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	shr	ecx, 7
	mov	DWORD PTR tv186[ebp], ecx
	jmp	SHORT $LN17@R_BuildLig
$LN16@R_BuildLig:
	mov	DWORD PTR tv186[ebp], 255		; 000000ffH
$LN17@R_BuildLig:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	dl, BYTE PTR tv186[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 696  : 			dest[1] = Q_min((bl[1] >> 7), 255 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	shr	edx, 7
	cmp	edx, 255				; 000000ffH
	jae	SHORT $LN18@R_BuildLig
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	shr	edx, 7
	mov	DWORD PTR tv197[ebp], edx
	jmp	SHORT $LN19@R_BuildLig
$LN18@R_BuildLig:
	mov	DWORD PTR tv197[ebp], 255		; 000000ffH
$LN19@R_BuildLig:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	dl, BYTE PTR tv197[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 697  : 			dest[2] = Q_min((bl[2] >> 7), 255 );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	shr	edx, 7
	cmp	edx, 255				; 000000ffH
	jae	SHORT $LN20@R_BuildLig
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	shr	edx, 7
	mov	DWORD PTR tv208[ebp], edx
	jmp	SHORT $LN21@R_BuildLig
$LN20@R_BuildLig:
	mov	DWORD PTR tv208[ebp], 255		; 000000ffH
$LN21@R_BuildLig:
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	dl, BYTE PTR tv208[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 698  : 			dest[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 699  : 
; 700  : 			bl += 3;

	mov	eax, DWORD PTR _bl$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _bl$[ebp], eax

; 701  : 			dest += 4;

	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, 4
	mov	DWORD PTR _dest$[ebp], eax

; 702  : 		}

	jmp	$LN11@R_BuildLig
$LN12@R_BuildLig:

; 703  : 	}

	jmp	$LN8@R_BuildLig
$LN1@R_BuildLig:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BuildLightMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _LM_AllocBlock
_TEXT	SEGMENT
_best2$ = -16						; size = 4
_best$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_LM_AllocBlock PROC					; COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 569  : 	int	i, j;
; 570  : 	int	best, best2;
; 571  : 
; 572  : 	best = BLOCK_SIZE;

	mov	eax, DWORD PTR _tr+87580
	mov	DWORD PTR _best$[ebp], eax

; 573  : 
; 574  : 	for( i = 0; i < BLOCK_SIZE - w; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LM_AllocBl
$LN2@LM_AllocBl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LM_AllocBl:
	mov	eax, DWORD PTR _tr+87580
	sub	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@LM_AllocBl

; 575  : 	{
; 576  : 		best2 = 0;

	mov	DWORD PTR _best2$[ebp], 0

; 577  : 
; 578  : 		for( j = 0; j < w; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@LM_AllocBl
$LN5@LM_AllocBl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@LM_AllocBl:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN6@LM_AllocBl

; 579  : 		{
; 580  : 			if( gl_lms.allocated[i+j] >= best )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4]
	cmp	ecx, DWORD PTR _best$[ebp]
	jl	SHORT $LN11@LM_AllocBl

; 581  : 				break;

	jmp	SHORT $LN6@LM_AllocBl
$LN11@LM_AllocBl:

; 582  : 			if( gl_lms.allocated[i+j] > best2 )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4]
	cmp	ecx, DWORD PTR _best2$[ebp]
	jle	SHORT $LN12@LM_AllocBl

; 583  : 				best2 = gl_lms.allocated[i+j];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4]
	mov	DWORD PTR _best2$[ebp], ecx
$LN12@LM_AllocBl:

; 584  : 		}

	jmp	SHORT $LN5@LM_AllocBl
$LN6@LM_AllocBl:

; 585  : 
; 586  : 		if( j == w )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jne	SHORT $LN13@LM_AllocBl

; 587  : 		{	
; 588  : 			// this is a valid spot
; 589  : 			*x = i;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 590  : 			*y = best = best2;

	mov	eax, DWORD PTR _best2$[ebp]
	mov	DWORD PTR _best$[ebp], eax
	mov	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _best$[ebp]
	mov	DWORD PTR [ecx], edx
$LN13@LM_AllocBl:

; 591  : 		}
; 592  : 	}

	jmp	$LN2@LM_AllocBl
$LN3@LM_AllocBl:

; 593  : 
; 594  : 	if( best + h > BLOCK_SIZE )

	mov	eax, DWORD PTR _best$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cmp	eax, DWORD PTR _tr+87580
	jle	SHORT $LN14@LM_AllocBl

; 595  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@LM_AllocBl
$LN14@LM_AllocBl:

; 596  : 
; 597  : 	for( i = 0; i < w; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@LM_AllocBl
$LN8@LM_AllocBl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@LM_AllocBl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	SHORT $LN9@LM_AllocBl

; 598  : 		gl_lms.allocated[*x + i] = best + h;

	mov	eax, DWORD PTR _best$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _gl_lms[edx*4], eax
	jmp	SHORT $LN8@LM_AllocBl
$LN9@LM_AllocBl:

; 599  : 
; 600  : 	return true;

	mov	eax, 1
$LN1@LM_AllocBl:

; 601  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LM_AllocBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _LM_InitBlock
_TEXT	SEGMENT
_LM_InitBlock PROC					; COMDAT

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 564  : 	memset( gl_lms.allocated, 0, sizeof( gl_lms.allocated ));

	push	4096					; 00001000H
	push	0
	push	OFFSET _gl_lms
	call	_memset
	add	esp, 12					; 0000000cH

; 565  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LM_InitBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_SetCacheState
_TEXT	SEGMENT
_maps$ = -4						; size = 4
_surf$ = 8						; size = 4
_R_SetCacheState PROC					; COMDAT

; 546  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 547  : 	int	maps;
; 548  : 
; 549  : 	for( maps = 0; maps < MAXLIGHTMAPS && surf->styles[maps] != 255; maps++ )

	mov	DWORD PTR _maps$[ebp], 0
	jmp	SHORT $LN4@R_SetCache
$LN2@R_SetCache:
	mov	eax, DWORD PTR _maps$[ebp]
	add	eax, 1
	mov	DWORD PTR _maps$[ebp], eax
$LN4@R_SetCache:
	cmp	DWORD PTR _maps$[ebp], 4
	jge	SHORT $LN1@R_SetCache
	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN1@R_SetCache

; 550  : 	{
; 551  : 		surf->cached_light[maps] = tr.lightstylevalue[surf->styles[maps]];

	mov	eax, DWORD PTR _surf$[ebp]
	add	eax, DWORD PTR _maps$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	mov	edx, DWORD PTR _maps$[ebp]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR _tr[ecx*4+87324]
	mov	DWORD PTR [eax+edx*4+64], ecx

; 552  : 	}

	jmp	SHORT $LN2@R_SetCache
$LN1@R_SetCache:

; 553  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetCacheState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_AddDynamicLights
_TEXT	SEGMENT
tv542 = -180						; size = 8
tv274 = -176						; size = 4
tv198 = -176						; size = 4
_bl$ = -108						; size = 4
_dl$ = -104						; size = 4
_tex$ = -100						; size = 4
_sample_size$ = -96					; size = 4
_sample_frac$ = -92					; size = 4
_info$ = -88						; size = 4
_origin_l$ = -84					; size = 12
_impact$ = -72						; size = 12
_tacc$ = -60						; size = 4
_sacc$ = -56						; size = 4
_tl$ = -52						; size = 4
_sl$ = -48						; size = 4
_tmax$ = -44						; size = 4
_smax$ = -40						; size = 4
_td$ = -36						; size = 4
_sd$ = -32						; size = 4
_t$ = -28						; size = 4
_s$ = -24						; size = 4
_lnum$ = -20						; size = 4
_minlight$ = -16					; size = 4
_rad$ = -12						; size = 4
_dist$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_surf$ = 8						; size = 4
_R_AddDynamicLights PROC				; COMDAT

; 453  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 454  : 	float		dist, rad, minlight;
; 455  : 	int		lnum, s, t, sd, td, smax, tmax;
; 456  : 	float		sl, tl, sacc, tacc;
; 457  : 	vec3_t		impact, origin_l;
; 458  : 	mextrasurf_t	*info = surf->info;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 459  : 	int		sample_frac = 1.0;

	mov	DWORD PTR _sample_frac$[ebp], 1

; 460  : 	float		sample_size;
; 461  : 	mtexinfo_t	*tex;
; 462  : 	dlight_t		*dl;
; 463  : 	uint		*bl;
; 464  : 
; 465  : 	// no dlighted surfaces here
; 466  : 	if( !R_CountSurfaceDlights( surf )) return;

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_R_CountSurfaceDlights
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@R_AddDynam
	jmp	$LN3@R_AddDynam
$LN11@R_AddDynam:

; 467  : 
; 468  : 	sample_size = Mod_SampleSizeForFace( surf );

	mov	eax, DWORD PTR _surf$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sample_size$[ebp], xmm0

; 469  : 	smax = (info->lightextents[0] / sample_size) + 1;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+52]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _smax$[ebp], ecx

; 470  : 	tmax = (info->lightextents[1] / sample_size) + 1;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+52]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	cvttss2si eax, xmm0
	mov	DWORD PTR _tmax$[ebp], eax

; 471  : 	tex = surf->texinfo;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _tex$[ebp], ecx

; 472  : 
; 473  : 	if( FBitSet( tex->flags, TEX_WORLD_LUXELS ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 2
	je	SHORT $LN16@R_AddDynam

; 474  : 	{
; 475  : 		if( surf->texinfo->faceinfo )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN13@R_AddDynam

; 476  : 			sample_frac = surf->texinfo->faceinfo->texture_step;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+32]
	movzx	eax, WORD PTR [edx+16]
	mov	DWORD PTR _sample_frac$[ebp], eax
	jmp	SHORT $LN16@R_AddDynam
$LN13@R_AddDynam:

; 477  : 		else if( FBitSet( surf->texinfo->flags, TEX_EXTRA_LIGHTMAP ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+40]
	and	edx, 8
	je	SHORT $LN15@R_AddDynam

; 478  : 			sample_frac = LM_SAMPLE_EXTRASIZE;

	mov	DWORD PTR _sample_frac$[ebp], 8
	jmp	SHORT $LN16@R_AddDynam
$LN15@R_AddDynam:

; 479  : 		else sample_frac = LM_SAMPLE_SIZE;

	mov	DWORD PTR _sample_frac$[ebp], 16	; 00000010H
$LN16@R_AddDynam:

; 480  : 	}
; 481  : 
; 482  : 	for( lnum = 0; lnum < MAX_DLIGHTS; lnum++ )

	mov	DWORD PTR _lnum$[ebp], 0
	jmp	SHORT $LN4@R_AddDynam
$LN2@R_AddDynam:
	mov	eax, DWORD PTR _lnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _lnum$[ebp], eax
$LN4@R_AddDynam:
	cmp	DWORD PTR _lnum$[ebp], 32		; 00000020H
	jge	$LN3@R_AddDynam

; 483  : 	{
; 484  : 		if( !FBitSet( surf->dlightbits, BIT( lnum )))

	mov	eax, 1
	mov	ecx, DWORD PTR _lnum$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _surf$[ebp]
	and	eax, DWORD PTR [ecx+52]
	jne	SHORT $LN17@R_AddDynam

; 485  : 			continue;	// not lit by this light

	jmp	SHORT $LN2@R_AddDynam
$LN17@R_AddDynam:

; 486  : 
; 487  : 		dl = &cl_dlights[lnum];

	imul	eax, DWORD PTR _lnum$[ebp], 40
	add	eax, OFFSET _cl_dlights
	mov	DWORD PTR _dl$[ebp], eax

; 488  : 
; 489  : 		// transform light origin to local bmodel space
; 490  : 		if( !tr.modelviewIdentity )

	cmp	DWORD PTR _tr+83184, 0
	jne	SHORT $LN18@R_AddDynam

; 491  : 			Matrix4x4_VectorITransform( RI.objectMatrix, dl->origin, origin_l );

	lea	eax, DWORD PTR _origin_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dl$[ebp]
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN19@R_AddDynam
$LN18@R_AddDynam:

; 492  : 		else VectorCopy( dl->origin, origin_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _origin_l$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _origin_l$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _origin_l$[ebp+ecx], eax
$LN19@R_AddDynam:

; 493  : 
; 494  : 		rad = dl->radius;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _rad$[ebp], xmm0

; 495  : 		dist = PlaneDiff( origin_l, surf->plane );

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN29@R_AddDynam
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	movss	xmm0, DWORD PTR _origin_l$[ebp+edx*4]
	movss	DWORD PTR tv198[ebp], xmm0
	jmp	SHORT $LN30@R_AddDynam
$LN29@R_AddDynam:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _origin_l$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _origin_l$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _origin_l$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv198[ebp], xmm0
$LN30@R_AddDynam:
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR tv198[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _dist$[ebp], xmm0

; 496  : 		rad -= fabs( dist );

	cvtss2sd xmm0, DWORD PTR _dist$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv542[ebp]
	cvtss2sd xmm0, DWORD PTR _rad$[ebp]
	subsd	xmm0, QWORD PTR tv542[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _rad$[ebp], xmm0

; 497  : 
; 498  : 		// rad is now the highest intensity on the plane
; 499  : 		minlight = dl->minlight;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+28]
	movss	DWORD PTR _minlight$[ebp], xmm0

; 500  : 		if( rad < minlight )

	movss	xmm0, DWORD PTR _minlight$[ebp]
	comiss	xmm0, DWORD PTR _rad$[ebp]
	jbe	SHORT $LN20@R_AddDynam

; 501  : 			continue;

	jmp	$LN2@R_AddDynam
$LN20@R_AddDynam:

; 502  : 
; 503  : 		minlight = rad - minlight;

	movss	xmm0, DWORD PTR _rad$[ebp]
	subss	xmm0, DWORD PTR _minlight$[ebp]
	movss	DWORD PTR _minlight$[ebp], xmm0

; 504  : 
; 505  : 		if( surf->plane->type < 3 )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN21@R_AddDynam

; 506  : 		{
; 507  : 			VectorCopy( origin_l, impact );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _origin_l$[ebp+ecx]
	mov	DWORD PTR _impact$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin_l$[ebp+edx]
	mov	DWORD PTR _impact$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin_l$[ebp+edx]
	mov	DWORD PTR _impact$[ebp+eax], ecx

; 508  : 			impact[surf->plane->type] -= dist;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	movss	xmm0, DWORD PTR _impact$[ebp+edx*4]
	subss	xmm0, DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	movss	DWORD PTR _impact$[ebp+edx*4], xmm0

; 509  : 		}

	jmp	$LN22@R_AddDynam
$LN21@R_AddDynam:

; 510  : 		else VectorMA( origin_l, -dist, surf->plane->normal, impact );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dist$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, 4
	imul	edx, edx, 0
	mulss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _origin_l$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _impact$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _dist$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _origin_l$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _impact$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _dist$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 4
	shl	eax, 1
	mulss	xmm0, DWORD PTR [ecx+eax]
	movss	xmm1, DWORD PTR _origin_l$[ebp+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv274[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv274[ebp]
	movss	DWORD PTR _impact$[ebp+ecx], xmm0
$LN22@R_AddDynam:

; 511  : 
; 512  : 		sl = DotProduct( impact, info->lmvecs[0] ) + info->lmvecs[0][3] - info->lightmapmins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _impact$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _impact$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _impact$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	movsx	ecx, WORD PTR [eax+edx+48]
	cvtsi2ss xmm1, ecx
	subss	xmm0, xmm1
	movss	DWORD PTR _sl$[ebp], xmm0

; 513  : 		tl = DotProduct( impact, info->lmvecs[1] ) + info->lmvecs[1][3] - info->lightmapmins[1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR _impact$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _impact$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _impact$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	movss	DWORD PTR _tl$[ebp], xmm0

; 514  : 		bl = r_blocklights;

	mov	DWORD PTR _bl$[ebp], OFFSET _r_blocklights

; 515  : 
; 516  : 		for( t = 0, tacc = 0; t < tmax; t++, tacc += sample_size )

	mov	DWORD PTR _t$[ebp], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _tacc$[ebp], xmm0
	jmp	SHORT $LN7@R_AddDynam
$LN5@R_AddDynam:
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
	movss	xmm0, DWORD PTR _tacc$[ebp]
	addss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	DWORD PTR _tacc$[ebp], xmm0
$LN7@R_AddDynam:
	mov	eax, DWORD PTR _t$[ebp]
	cmp	eax, DWORD PTR _tmax$[ebp]
	jge	$LN6@R_AddDynam

; 517  : 		{
; 518  : 			td = (tl - tacc) * sample_frac;

	movss	xmm0, DWORD PTR _tl$[ebp]
	subss	xmm0, DWORD PTR _tacc$[ebp]
	cvtsi2ss xmm1, DWORD PTR _sample_frac$[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _td$[ebp], eax

; 519  : 			if( td < 0 ) td = -td;

	cmp	DWORD PTR _td$[ebp], 0
	jge	SHORT $LN23@R_AddDynam
	mov	eax, DWORD PTR _td$[ebp]
	neg	eax
	mov	DWORD PTR _td$[ebp], eax
$LN23@R_AddDynam:

; 520  : 
; 521  : 			for( s = 0, sacc = 0; s < smax; s++, sacc += sample_size, bl += 3 )

	mov	DWORD PTR _s$[ebp], 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _sacc$[ebp], xmm0
	jmp	SHORT $LN10@R_AddDynam
$LN8@R_AddDynam:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	movss	xmm0, DWORD PTR _sacc$[ebp]
	addss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	DWORD PTR _sacc$[ebp], xmm0
	mov	ecx, DWORD PTR _bl$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _bl$[ebp], ecx
$LN10@R_AddDynam:
	mov	eax, DWORD PTR _s$[ebp]
	cmp	eax, DWORD PTR _smax$[ebp]
	jge	$LN9@R_AddDynam

; 522  : 			{
; 523  : 				sd = (sl - sacc) * sample_frac;

	movss	xmm0, DWORD PTR _sl$[ebp]
	subss	xmm0, DWORD PTR _sacc$[ebp]
	cvtsi2ss xmm1, DWORD PTR _sample_frac$[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _sd$[ebp], eax

; 524  : 				if( sd < 0 ) sd = -sd;

	cmp	DWORD PTR _sd$[ebp], 0
	jge	SHORT $LN24@R_AddDynam
	mov	eax, DWORD PTR _sd$[ebp]
	neg	eax
	mov	DWORD PTR _sd$[ebp], eax
$LN24@R_AddDynam:

; 525  : 
; 526  : 				if( sd > td ) dist = sd + (td >> 1);

	mov	eax, DWORD PTR _sd$[ebp]
	cmp	eax, DWORD PTR _td$[ebp]
	jle	SHORT $LN25@R_AddDynam
	mov	eax, DWORD PTR _td$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR _sd$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _dist$[ebp], xmm0
	jmp	SHORT $LN26@R_AddDynam
$LN25@R_AddDynam:

; 527  : 				else dist = td + (sd >> 1);

	mov	eax, DWORD PTR _sd$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR _td$[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _dist$[ebp], xmm0
$LN26@R_AddDynam:

; 528  : 
; 529  : 				if( dist < minlight )

	movss	xmm0, DWORD PTR _minlight$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	$LN27@R_AddDynam

; 530  : 				{
; 531  : 					bl[0] += ((int)((rad - dist) * 256) * LightToTexGamma( dl->color.r )) / 256;

	mov	eax, 4
	imul	esi, eax, 0
	movss	xmm0, DWORD PTR _rad$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	cvttss2si edi, xmm0
	mov	ecx, DWORD PTR _dl$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	movzx	eax, al
	imul	eax, edi
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _bl$[ebp]
	add	eax, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	ecx, edx, 0
	mov	edx, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 532  : 					bl[1] += ((int)((rad - dist) * 256) * LightToTexGamma( dl->color.g )) / 256;

	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR _rad$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	cvttss2si edi, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edi, edx
	mov	eax, edi
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _bl$[ebp]
	add	eax, DWORD PTR [ecx+esi]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 533  : 					bl[2] += ((int)((rad - dist) * 256) * LightToTexGamma( dl->color.b )) / 256;

	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR _rad$[ebp]
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@43800000
	cvttss2si edi, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	imul	edi, edx
	mov	eax, edi
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	ecx, DWORD PTR _bl$[ebp]
	add	eax, DWORD PTR [ecx+esi]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _bl$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN27@R_AddDynam:

; 534  : 				}
; 535  : 			}

	jmp	$LN8@R_AddDynam
$LN9@R_AddDynam:

; 536  : 		}

	jmp	$LN5@R_AddDynam
$LN6@R_AddDynam:

; 537  : 	}

	jmp	$LN2@R_AddDynam
$LN3@R_AddDynam:

; 538  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AddDynamicLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _SubdividePolygon_r
_TEXT	SEGMENT
tv865 = -2140						; size = 8
tv854 = -2140						; size = 8
tv619 = -2136						; size = 8
tv218 = -2136						; size = 4
tv861 = -2132						; size = 4
tv850 = -2132						; size = 4
tv251 = -2132						; size = 4
tv219 = -2132						; size = 4
_poly$ = -1872						; size = 4
_maxs$ = -1868						; size = 12
_mins$ = -1856						; size = 12
_sample_size$ = -1844					; size = 4
_b$ = -1840						; size = 4
_f$ = -1836						; size = 4
_k$ = -1832						; size = 4
_j$ = -1828						; size = 4
_i$ = -1824						; size = 4
_v$ = -1820						; size = 4
_t$ = -1816						; size = 4
_s$ = -1812						; size = 4
_frac$ = -1808						; size = 4
_m$ = -1804						; size = 4
_dist$ = -1800						; size = 256
_warpinfo$ = -1544					; size = 4
_back$ = -1540						; size = 768
_front$ = -772						; size = 768
__$ArrayPad$ = -4					; size = 4
_warpface$ = 8						; size = 4
_numverts$ = 12						; size = 4
_verts$ = 16						; size = 4
_SubdividePolygon_r PROC				; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2140				; 0000085cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 83   : 	vec3_t		front[SUBDIVIDE_SIZE], back[SUBDIVIDE_SIZE];
; 84   : 	mextrasurf_t	*warpinfo = warpface->info;

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _warpinfo$[ebp], ecx

; 85   : 	float		dist[SUBDIVIDE_SIZE];
; 86   : 	float		m, frac, s, t, *v;
; 87   : 	int		i, j, k, f, b;
; 88   : 	float		sample_size;
; 89   : 	vec3_t		mins, maxs;
; 90   : 	glpoly_t		*poly;
; 91   : 
; 92   : 	if( numverts > ( SUBDIVIDE_SIZE - 4 ))

	cmp	DWORD PTR _numverts$[ebp], 60		; 0000003cH
	jle	SHORT $LN17@SubdivideP

; 93   : 		Host_Error( "Mod_SubdividePolygon: too many vertexes on face ( %i )\n", numverts );

	mov	eax, DWORD PTR _numverts$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@CIADECFM@Mod_SubdividePolygon?3?5too?5many?5@
	call	_Host_Error
	add	esp, 8
$LN17@SubdivideP:

; 94   : 
; 95   : 	sample_size = Mod_SampleSizeForFace( warpface );

	mov	eax, DWORD PTR _warpface$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sample_size$[ebp], xmm0

; 96   : 	BoundPoly( numverts, verts, mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _verts$[ebp]
	push	edx
	mov	eax, DWORD PTR _numverts$[ebp]
	push	eax
	call	_BoundPoly
	add	esp, 16					; 00000010H

; 97   : 
; 98   : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SubdivideP
$LN2@SubdivideP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SubdivideP:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@SubdivideP

; 99   : 	{
; 100  : 		m = ( mins[i] + maxs[i] ) * 0.5f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+eax*4]
	addss	xmm0, DWORD PTR _maxs$[ebp+ecx*4]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _m$[ebp], xmm0

; 101  : 		m = SUBDIVIDE_SIZE * floor( m / SUBDIVIDE_SIZE + 0.5f );

	movss	xmm0, DWORD PTR _m$[ebp]
	divss	xmm0, DWORD PTR __real@42800000
	addss	xmm0, DWORD PTR __real@3f000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv619[ebp]
	movsd	xmm0, QWORD PTR tv619[ebp]
	mulsd	xmm0, QWORD PTR __real@4050000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _m$[ebp], xmm0

; 102  : 		if( maxs[i] - m < 8 ) continue;

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _maxs$[ebp+eax*4]
	subss	xmm0, DWORD PTR _m$[ebp]
	movss	xmm1, DWORD PTR __real@41000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@SubdivideP
	jmp	$LN2@SubdivideP
$LN18@SubdivideP:

; 103  : 		if( m - mins[i] < 8 ) continue;

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _m$[ebp]
	subss	xmm0, DWORD PTR _mins$[ebp+eax*4]
	movss	xmm1, DWORD PTR __real@41000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@SubdivideP
	jmp	$LN2@SubdivideP
$LN19@SubdivideP:

; 104  : 
; 105  : 		// cut it
; 106  : 		v = verts + i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _verts$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _v$[ebp], edx

; 107  : 		for( j = 0; j < numverts; j++, v += 3 )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@SubdivideP
$LN5@SubdivideP:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _v$[ebp], ecx
$LN7@SubdivideP:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jge	SHORT $LN6@SubdivideP

; 108  : 			dist[j] = *v - m;

	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _dist$[ebp+ecx*4], xmm0
	jmp	SHORT $LN5@SubdivideP
$LN6@SubdivideP:

; 109  : 
; 110  : 		// wrap cases
; 111  : 		dist[j] = dist[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _dist$[ebp+ecx]
	mov	DWORD PTR _dist$[ebp+edx*4], eax

; 112  : 		v -= i;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _v$[ebp], ecx

; 113  : 		VectorCopy( verts, v );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 114  : 
; 115  : 		f = b = 0;

	mov	DWORD PTR _b$[ebp], 0
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _f$[ebp], eax

; 116  : 		v = verts;

	mov	eax, DWORD PTR _verts$[ebp]
	mov	DWORD PTR _v$[ebp], eax

; 117  : 		for( j = 0; j < numverts; j++, v += 3 )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SubdivideP
$LN8@SubdivideP:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _v$[ebp], ecx
$LN10@SubdivideP:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jge	$LN9@SubdivideP

; 118  : 		{
; 119  : 			if( dist[j] >= 0 )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	$LN20@SubdivideP

; 120  : 			{
; 121  : 				VectorCopy( v, front[f] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _f$[ebp], 12
	lea	eax, DWORD PTR _front$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _f$[ebp], 12
	lea	ecx, DWORD PTR _front$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _f$[ebp], 12
	lea	edx, DWORD PTR _front$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 122  : 				f++;

	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 1
	mov	DWORD PTR _f$[ebp], eax
$LN20@SubdivideP:

; 123  : 			}
; 124  : 
; 125  : 			if( dist[j] <= 0 )

	mov	eax, DWORD PTR _j$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dist$[ebp+eax*4]
	jb	$LN21@SubdivideP

; 126  : 			{
; 127  : 				VectorCopy (v, back[b]);

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _b$[ebp], 12
	lea	eax, DWORD PTR _back$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _b$[ebp], 12
	lea	ecx, DWORD PTR _back$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _b$[ebp], 12
	lea	edx, DWORD PTR _back$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 128  : 				b++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 1
	mov	DWORD PTR _b$[ebp], eax
$LN21@SubdivideP:

; 129  : 			}
; 130  : 
; 131  : 			if( dist[j] == 0 || dist[j+1] == 0 )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+eax*4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@SubdivideP
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+eax*4+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@SubdivideP
$LN23@SubdivideP:

; 132  : 				continue;

	jmp	$LN8@SubdivideP
$LN22@SubdivideP:

; 133  : 
; 134  : 			if(( dist[j] > 0 ) != ( dist[j+1] > 0 ))

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN32@SubdivideP
	mov	DWORD PTR tv219[ebp], 1
	jmp	SHORT $LN33@SubdivideP
$LN32@SubdivideP:
	mov	DWORD PTR tv219[ebp], 0
$LN33@SubdivideP:
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+ecx*4+4]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN30@SubdivideP
	mov	DWORD PTR tv218[ebp], 1
	jmp	SHORT $LN31@SubdivideP
$LN30@SubdivideP:
	mov	DWORD PTR tv218[ebp], 0
$LN31@SubdivideP:
	mov	edx, DWORD PTR tv219[ebp]
	cmp	edx, DWORD PTR tv218[ebp]
	je	$LN24@SubdivideP

; 135  : 			{
; 136  : 				// clip point
; 137  : 				frac = dist[j] / ( dist[j] - dist[j+1] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp+eax*4]
	subss	xmm0, DWORD PTR _dist$[ebp+ecx*4+4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp+edx*4]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 138  : 				for( k = 0; k < 3; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN13@SubdivideP
$LN11@SubdivideP:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN13@SubdivideP:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$LN12@SubdivideP

; 139  : 					front[f][k] = back[b][k] = v[k] + frac * (v[3+k] - v[k]);

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+12]
	subss	xmm0, DWORD PTR [esi+edx*4]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	addss	xmm1, xmm0
	movss	DWORD PTR tv251[ebp], xmm1
	imul	edx, DWORD PTR _b$[ebp], 12
	lea	eax, DWORD PTR _back$[ebp+edx]
	mov	ecx, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR tv251[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
	imul	edx, DWORD PTR _f$[ebp], 12
	lea	eax, DWORD PTR _front$[ebp+edx]
	mov	ecx, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR tv251[ebp]
	movss	DWORD PTR [eax+ecx*4], xmm0
	jmp	$LN11@SubdivideP
$LN12@SubdivideP:

; 140  : 				f++;

	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 1
	mov	DWORD PTR _f$[ebp], eax

; 141  : 				b++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 1
	mov	DWORD PTR _b$[ebp], eax
$LN24@SubdivideP:

; 142  : 			}
; 143  : 		}

	jmp	$LN8@SubdivideP
$LN9@SubdivideP:

; 144  : 
; 145  : 		SubdividePolygon_r( warpface, f, front[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _front$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _warpface$[ebp]
	push	ecx
	call	_SubdividePolygon_r
	add	esp, 12					; 0000000cH

; 146  : 		SubdividePolygon_r( warpface, b, back[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _back$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _warpface$[ebp]
	push	ecx
	call	_SubdividePolygon_r
	add	esp, 12					; 0000000cH

; 147  : 		return;

	jmp	$LN15@SubdivideP

; 148  : 	}

	jmp	$LN2@SubdivideP
$LN3@SubdivideP:

; 149  : 
; 150  : 	if( numverts != 4 )

	cmp	DWORD PTR _numverts$[ebp], 4
	je	SHORT $LN25@SubdivideP

; 151  : 		ClearBits( warpface->flags, SURF_DRAWTURB_QUADS ); 

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _warpface$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN25@SubdivideP:

; 152  : 
; 153  : 	// add a point in the center to help keep warp valid
; 154  : 	poly = Mem_Calloc( loadmodel->mempool, sizeof( glpoly_t ) + (numverts - 4) * VERTEXSIZE * sizeof( float ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SubdividePolygon_r@@9@9
	add	eax, 72					; 00000048H
	push	eax
	push	OFFSET ??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _numverts$[ebp]
	sub	ecx, 4
	imul	edx, ecx, 7
	lea	eax, DWORD PTR [edx*4+128]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _poly$[ebp], eax

; 155  : 	poly->next = warpface->polys;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax], edx

; 156  : 	poly->flags = warpface->flags;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 157  : 	warpface->polys = poly;

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 158  : 	poly->numverts = numverts;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _numverts$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 159  : 
; 160  : 	for( i = 0; i < numverts; i++, verts += 3 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@SubdivideP
$LN14@SubdivideP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _verts$[ebp], ecx
$LN16@SubdivideP:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jge	$LN15@SubdivideP

; 161  : 	{
; 162  : 		VectorCopy( verts, poly->verts[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	eax, DWORD PTR [ecx+eax+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 28
	mov	edx, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+16]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 163  : 
; 164  : 		if( FBitSet( warpface->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	$LN26@SubdivideP

; 165  : 		{
; 166  : 			s = DotProduct( verts, warpface->texinfo->vecs[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _warpface$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 167  : 			t = DotProduct( verts, warpface->texinfo->vecs[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _warpface$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 168  : 		}

	jmp	$LN27@SubdivideP
$LN26@SubdivideP:

; 169  : 		else
; 170  : 		{
; 171  : 			s = DotProduct( verts, warpface->texinfo->vecs[0] ) + warpface->texinfo->vecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _warpface$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _s$[ebp], xmm0

; 172  : 			t = DotProduct( verts, warpface->texinfo->vecs[1] ) + warpface->texinfo->vecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _warpface$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _warpface$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 3
	addss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _t$[ebp], xmm0

; 173  : 			s /= warpface->texinfo->texture->width; 

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv850[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv850[ebp]
	mov	ecx, DWORD PTR tv850[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv854[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv854[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 174  : 			t /= warpface->texinfo->texture->height; 

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv861[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv861[ebp]
	mov	ecx, DWORD PTR tv861[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv865[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv865[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1
$LN27@SubdivideP:

; 175  : 		}
; 176  : 
; 177  : 		poly->verts[i][3] = s;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 178  : 		poly->verts[i][4] = t;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	shl	eax, 2
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 179  : 
; 180  : 		// for speed reasons
; 181  : 		if( !FBitSet( warpface->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _warpface$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	jne	$LN28@SubdivideP

; 182  : 		{
; 183  : 			// lightmap texture coordinates
; 184  : 			s = DotProduct( verts, warpinfo->lmvecs[0] ) + warpinfo->lmvecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _warpinfo$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _warpinfo$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _warpinfo$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _warpinfo$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _s$[ebp], xmm0

; 185  : 			s -= warpinfo->lightmapmins[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _warpinfo$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 186  : 			s += warpface->light_s * sample_size;

	mov	eax, DWORD PTR _warpface$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 187  : 			s += sample_size * 0.5;

	cvtss2sd xmm0, DWORD PTR _sample_size$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, DWORD PTR _s$[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 188  : 			s /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->width;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 189  : 
; 190  : 			t = DotProduct( verts, warpinfo->lmvecs[1] ) + warpinfo->lmvecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _warpinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _warpinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _warpinfo$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _verts$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _warpinfo$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _t$[ebp], xmm0

; 191  : 			t -= warpinfo->lightmapmins[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _warpinfo$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _t$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 192  : 			t += warpface->light_t * sample_size;

	mov	eax, DWORD PTR _warpface$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _t$[ebp], xmm0

; 193  : 			t += sample_size * 0.5;

	cvtss2sd xmm0, DWORD PTR _sample_size$[ebp]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, DWORD PTR _t$[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 194  : 			t /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->height;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 195  : 
; 196  : 			poly->verts[i][5] = s;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 5
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 197  : 			poly->verts[i][6] = t;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 6
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN28@SubdivideP:

; 198  : 		}
; 199  : 	}

	jmp	$LN14@SubdivideP
$LN15@SubdivideP:

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SubdividePolygon_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _BoundPoly
_TEXT	SEGMENT
_v$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_numverts$ = 8						; size = 4
_verts$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_BoundPoly PROC						; COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 66   : 	int	i, j;
; 67   : 	float	*v;
; 68   : 
; 69   : 	ClearBounds( mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8

; 70   : 
; 71   : 	for( i = 0, v = verts; i < numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _verts$[ebp]
	mov	DWORD PTR _v$[ebp], eax
	jmp	SHORT $LN4@BoundPoly
$LN2@BoundPoly:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@BoundPoly:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numverts$[ebp]
	jge	SHORT $LN3@BoundPoly

; 72   : 	{
; 73   : 		for( j = 0; j < 3; j++, v++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@BoundPoly
$LN5@BoundPoly:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	mov	DWORD PTR _v$[ebp], ecx
$LN7@BoundPoly:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@BoundPoly

; 74   : 		{
; 75   : 			if( *v < mins[j] ) mins[j] = *v;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR [edx]
	jbe	SHORT $LN8@BoundPoly
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4], edx
$LN8@BoundPoly:

; 76   : 			if( *v > maxs[j] ) maxs[j] = *v;

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jbe	SHORT $LN9@BoundPoly
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4], edx
$LN9@BoundPoly:

; 77   : 		}

	jmp	SHORT $LN5@BoundPoly
$LN6@BoundPoly:

; 78   : 	}

	jmp	SHORT $LN2@BoundPoly
$LN3@BoundPoly:

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BoundPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _LM_UploadBlock
_TEXT	SEGMENT
_lmName$1 = -64						; size = 16
_r_lightmap$2 = -48					; size = 36
_height$3 = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dynamic$ = 8						; size = 4
_LM_UploadBlock PROC					; COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 605  : 	int	i;
; 606  : 
; 607  : 	if( dynamic )

	cmp	DWORD PTR _dynamic$[ebp], 0
	je	$LN5@LM_UploadB

; 608  : 	{
; 609  : 		int	height = 0;

	mov	DWORD PTR _height$3[ebp], 0

; 610  : 
; 611  : 		for( i = 0; i < BLOCK_SIZE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LM_UploadB
$LN2@LM_UploadB:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LM_UploadB:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tr+87580
	jge	SHORT $LN3@LM_UploadB

; 612  : 		{
; 613  : 			if( gl_lms.allocated[i] > height )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4]
	cmp	ecx, DWORD PTR _height$3[ebp]
	jle	SHORT $LN7@LM_UploadB

; 614  : 				height = gl_lms.allocated[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _gl_lms[eax*4]
	mov	DWORD PTR _height$3[ebp], ecx
$LN7@LM_UploadB:

; 615  : 		}

	jmp	SHORT $LN2@LM_UploadB
$LN3@LM_UploadB:

; 616  : 
; 617  : 		GL_Bind( GL_TEXTURE0, tr.dlightTexture );

	mov	eax, DWORD PTR _tr+1052
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 618  : 		pglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, BLOCK_SIZE, height, GL_RGBA, GL_UNSIGNED_BYTE, gl_lms.lightmap_buffer );

	push	OFFSET _gl_lms+5128
	push	5121					; 00001401H
	push	6408					; 00001908H
	mov	eax, DWORD PTR _height$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _tr+87580
	push	ecx
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglTexSubImage2D

; 619  : 	}

	jmp	$LN1@LM_UploadB
$LN5@LM_UploadB:

; 620  : 	else
; 621  : 	{
; 622  : 		rgbdata_t	r_lightmap;
; 623  : 		char	lmName[16];
; 624  : 
; 625  : 		i = gl_lms.current_lightmap_texture;

	mov	eax, DWORD PTR _gl_lms+4096
	mov	DWORD PTR _i$[ebp], eax

; 626  : 
; 627  : 		// upload static lightmaps only during loading
; 628  : 		memset( &r_lightmap, 0, sizeof( r_lightmap ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _r_lightmap$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 629  : 		Q_snprintf( lmName, sizeof( lmName ), "*lightmap%i", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@NDIFDEBH@?$CKlightmap?$CFi@
	push	16					; 00000010H
	lea	ecx, DWORD PTR _lmName$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 630  : 
; 631  : 		r_lightmap.width = BLOCK_SIZE;

	mov	ax, WORD PTR _tr+87580
	mov	WORD PTR _r_lightmap$2[ebp], ax

; 632  : 		r_lightmap.height = BLOCK_SIZE;

	mov	ax, WORD PTR _tr+87580
	mov	WORD PTR _r_lightmap$2[ebp+2], ax

; 633  : 		r_lightmap.type = PF_RGBA_32;

	mov	DWORD PTR _r_lightmap$2[ebp+8], 3

; 634  : 		r_lightmap.size = r_lightmap.width * r_lightmap.height * 4;

	movzx	eax, WORD PTR _r_lightmap$2[ebp]
	movzx	ecx, WORD PTR _r_lightmap$2[ebp+2]
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _r_lightmap$2[ebp+32], eax

; 635  : 		r_lightmap.flags = IMAGE_HAS_COLOR;

	mov	DWORD PTR _r_lightmap$2[ebp+12], 4

; 636  : 		r_lightmap.buffer = gl_lms.lightmap_buffer;

	mov	DWORD PTR _r_lightmap$2[ebp+24], OFFSET _gl_lms+5128

; 637  : 		tr.lightmapTextures[i] = GL_LoadTextureInternal( lmName, &r_lightmap, TF_FONT|TF_ATLAS_PAGE );

	push	0
	push	2103296					; 00201800H
	lea	eax, DWORD PTR _r_lightmap$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _lmName$1[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[edx*4+28], eax

; 638  : 
; 639  : 		if( ++gl_lms.current_lightmap_texture == MAX_LIGHTMAPS )

	mov	eax, DWORD PTR _gl_lms+4096
	add	eax, 1
	mov	DWORD PTR _gl_lms+4096, eax
	cmp	DWORD PTR _gl_lms+4096, 256		; 00000100H
	jne	SHORT $LN1@LM_UploadB

; 640  : 			Host_Error( "AllocBlock: full\n" );

	push	OFFSET ??_C@_0BC@HKBBBLJG@AllocBlock?3?5full?6@
	call	_Host_Error
	add	esp, 4
$LN1@LM_UploadB:

; 641  : 	}
; 642  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LM_UploadBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _Mod_SetOrthoBounds
_TEXT	SEGMENT
tv134 = -68						; size = 4
tv88 = -68						; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_Mod_SetOrthoBounds PROC				; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 55   : 	if( clgame.drawFuncs.GL_OrthoBounds )

	cmp	DWORD PTR _clgame+188, 0
	je	SHORT $LN2@Mod_SetOrt

; 56   : 	{
; 57   : 		clgame.drawFuncs.GL_OrthoBounds( mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	DWORD PTR _clgame+188
	add	esp, 8
$LN2@Mod_SetOrt:

; 58   : 	}
; 59   : 
; 60   : 	Vector2Average( maxs, mins, world_orthocenter );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _world_orthocenter[ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [esi+eax]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv88[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR _world_orthocenter[edx], xmm0

; 61   : 	Vector2Subtract( maxs, world_orthocenter, world_orthohalf );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _world_orthocenter[eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _world_orthohalf[ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _world_orthocenter[eax]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _world_orthohalf[edx], xmm0

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_SetOrthoBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _Mod_GetCurrentVis
_TEXT	SEGMENT
_Mod_GetCurrentVis PROC					; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 48   : 	if( clgame.drawFuncs.Mod_GetCurrentVis && tr.fCustomRendering )

	cmp	DWORD PTR _clgame+212, 0
	je	SHORT $LN2@Mod_GetCur
	cmp	DWORD PTR _tr+83208, 0
	je	SHORT $LN2@Mod_GetCur

; 49   : 		return clgame.drawFuncs.Mod_GetCurrentVis();

	call	DWORD PTR _clgame+212
	jmp	SHORT $LN1@Mod_GetCur
$LN2@Mod_GetCur:

; 50   : 	return RI.visbytes;

	mov	eax, OFFSET _RI+776
$LN1@Mod_GetCur:

; 51   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_GetCurrentVis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_ResetFogColor
_TEXT	SEGMENT
_GL_ResetFogColor PROC					; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 226  : 	// restore fog here
; 227  : 	if( pglIsEnabled( GL_FOG ))

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GL_ResetFo

; 228  : 		pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv
$LN1@GL_ResetFo:

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ResetFogColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_BuildLightmaps
_TEXT	SEGMENT
_m$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_GL_BuildLightmaps PROC					; COMDAT

; 2193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2194 : 	int	i, j;
; 2195 : 	model_t	*m;
; 2196 : 
; 2197 : 	// release old lightmaps
; 2198 : 	for( i = 0; i < MAX_LIGHTMAPS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_BuildLi
$LN2@GL_BuildLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_BuildLi:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@GL_BuildLi

; 2199 : 	{
; 2200 : 		if( !tr.lightmapTextures[i] ) break;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _tr[eax*4+28], 0
	jne	SHORT $LN17@GL_BuildLi
	jmp	SHORT $LN3@GL_BuildLi
$LN17@GL_BuildLi:

; 2201 : 		GL_FreeTexture( tr.lightmapTextures[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+28]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 2202 : 	}

	jmp	SHORT $LN2@GL_BuildLi
$LN3@GL_BuildLi:

; 2203 : 
; 2204 : 	memset( tr.lightmapTextures, 0, sizeof( tr.lightmapTextures ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _tr+28
	call	_memset
	add	esp, 12					; 0000000cH

; 2205 : 	memset(tr.mirror_entities, 0, sizeof(tr.mirror_entities));

	push	16384					; 00004000H
	push	0
	push	OFFSET _tr+1224
	call	_memset
	add	esp, 12					; 0000000cH

; 2206 : 	memset(tr.mirrorTextures, 0, sizeof(tr.mirrorTextures));

	push	128					; 00000080H
	push	0
	push	OFFSET _tr+1084
	call	_memset
	add	esp, 12					; 0000000cH

; 2207 : 	memset( &RI, 0, sizeof( RI ));

	push	4896					; 00001320H
	push	0
	push	OFFSET _RI
	call	_memset
	add	esp, 12					; 0000000cH

; 2208 : 
; 2209 : 	// update the lightmap blocksize
; 2210 : 	if( FBitSet( host.features, ENGINE_LARGE_LIGHTMAPS ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 16					; 00000010H
	je	SHORT $LN18@GL_BuildLi

; 2211 : 		tr.block_size = BLOCK_SIZE_MAX;

	mov	DWORD PTR _tr+87580, 1024		; 00000400H
	jmp	SHORT $LN19@GL_BuildLi
$LN18@GL_BuildLi:

; 2212 : 	else tr.block_size = BLOCK_SIZE_DEFAULT;

	mov	DWORD PTR _tr+87580, 128		; 00000080H
$LN19@GL_BuildLi:

; 2213 : 	
; 2214 : 	skychain = NULL;

	mov	DWORD PTR _skychain, 0

; 2215 : 
; 2216 : 	tr.framecount = tr.visframecount = 1;	// no dlight cache

	mov	DWORD PTR _tr+83188, 1
	mov	eax, DWORD PTR _tr+83188
	mov	DWORD PTR _tr+83200, eax

; 2217 : 	gl_lms.current_lightmap_texture = 0;

	mov	DWORD PTR _gl_lms+4096, 0

; 2218 : 	tr.modelviewIdentity = false;

	mov	DWORD PTR _tr+83184, 0

; 2219 : 	tr.realframecount = 1;

	mov	DWORD PTR _tr+83196, 1

; 2220 : 	nColinElim = 0;

	mov	DWORD PTR _nColinElim, 0

; 2221 : 	tr.num_mirrors_used = 0;

	mov	DWORD PTR _tr+1212, 0

; 2222 : 	tr.num_mirror_entities = 0;

	mov	DWORD PTR _tr+17608, 0

; 2223 : 
; 2224 : 	// setup the texture for dlights
; 2225 : 	R_InitDlightTexture();

	call	_R_InitDlightTexture

; 2226 : 
; 2227 : 	// setup all the lightstyles
; 2228 : 	CL_RunLightStyles();

	call	_CL_RunLightStyles

; 2229 : 
; 2230 : 	LM_InitBlock();	

	call	_LM_InitBlock

; 2231 : 
; 2232 : 	for( i = 0; i < cl.nummodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GL_BuildLi
$LN5@GL_BuildLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GL_BuildLi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2984344
	jge	$LN6@GL_BuildLi

; 2233 : 	{
; 2234 : 		if(( m = CL_ModelHandle( i + 1 )) == NULL )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _m$[ebp], eax
	cmp	DWORD PTR _m$[ebp], 0
	jne	SHORT $LN20@GL_BuildLi

; 2235 : 			continue;

	jmp	SHORT $LN5@GL_BuildLi
$LN20@GL_BuildLi:

; 2236 : 
; 2237 : 		if( m->name[0] == '*' || m->type != mod_brush )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _m$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN22@GL_BuildLi
	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN21@GL_BuildLi
$LN22@GL_BuildLi:

; 2238 : 			continue;

	jmp	SHORT $LN5@GL_BuildLi
$LN21@GL_BuildLi:

; 2239 : 
; 2240 : 		for( j = 0; j < m->numsurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@GL_BuildLi
$LN8@GL_BuildLi:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@GL_BuildLi:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+176]
	jge	SHORT $LN9@GL_BuildLi

; 2241 : 		{
; 2242 : 			// clearing all decal chains
; 2243 : 			m->surfaces[j].pdecals = NULL;

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [edx+eax+88], 0

; 2244 : 			m->surfaces[j].visframe = 0;

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [edx+eax], 0

; 2245 : 			loadmodel = m;

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR _loadmodel, eax

; 2246 : 
; 2247 : 			GL_CreateSurfaceLightmap( m->surfaces + j );

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	add	eax, DWORD PTR [ecx+180]
	push	eax
	call	_GL_CreateSurfaceLightmap
	add	esp, 4

; 2248 : 
; 2249 : 			if( m->surfaces[j].flags & SURF_DRAWTURB )

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	eax, DWORD PTR [edx+eax+8]
	and	eax, 16					; 00000010H
	je	SHORT $LN23@GL_BuildLi

; 2250 : 				continue;

	jmp	SHORT $LN8@GL_BuildLi
$LN23@GL_BuildLi:

; 2251 : 
; 2252 : 			GL_BuildPolygonFromSurface( m, m->surfaces + j );

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	add	eax, DWORD PTR [ecx+180]
	push	eax
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	_GL_BuildPolygonFromSurface
	add	esp, 8

; 2253 : 		}

	jmp	$LN8@GL_BuildLi
$LN9@GL_BuildLi:

; 2254 : 
; 2255 : 		// clearing visframe
; 2256 : 		for( j = 0; j < m->numleafs; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@GL_BuildLi
$LN11@GL_BuildLi:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@GL_BuildLi:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	SHORT $LN12@GL_BuildLi

; 2257 : 			m->leafs[j+1].visframe = 0;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	imul	ecx, eax, 60
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	DWORD PTR [eax+ecx+4], 0
	jmp	SHORT $LN11@GL_BuildLi
$LN12@GL_BuildLi:

; 2258 : 		for( j = 0; j < m->numnodes; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@GL_BuildLi
$LN14@GL_BuildLi:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@GL_BuildLi:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+160]
	jge	SHORT $LN15@GL_BuildLi

; 2259 : 			m->nodes[j].visframe = 0;

	imul	eax, DWORD PTR _j$[ebp], 52
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR [edx+eax+4], 0
	jmp	SHORT $LN14@GL_BuildLi
$LN15@GL_BuildLi:

; 2260 : 	}

	jmp	$LN5@GL_BuildLi
$LN6@GL_BuildLi:

; 2261 : 
; 2262 : 	LM_UploadBlock( false );

	push	0
	call	_LM_UploadBlock
	add	esp, 4

; 2263 : 
; 2264 : 	if( clgame.drawFuncs.GL_BuildLightmaps )

	cmp	DWORD PTR _clgame+184, 0
	je	SHORT $LN24@GL_BuildLi

; 2265 : 	{
; 2266 : 		// build lightmaps on the client-side
; 2267 : 		clgame.drawFuncs.GL_BuildLightmaps( );

	call	DWORD PTR _clgame+184
$LN24@GL_BuildLi:

; 2268 : 	}
; 2269 : 
; 2270 : 	// now gamma and brightness are valid
; 2271 : 	ClearBits( vid_brightness->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_brightness
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_brightness
	mov	DWORD PTR [edx+8], ecx

; 2272 : 	ClearBits( vid_gamma->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_gamma
	mov	DWORD PTR [edx+8], ecx

; 2273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BuildLightmaps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_InitRandomTable
_TEXT	SEGMENT
_tv$ = -8						; size = 4
_tu$ = -4						; size = 4
_GL_InitRandomTable PROC				; COMDAT

; 2276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2277 : 	int	tu, tv;
; 2278 : 
; 2279 : 	// make random predictable
; 2280 : 	COM_SetRandomSeed( 255 );

	push	255					; 000000ffH
	call	_COM_SetRandomSeed
	add	esp, 4

; 2281 : 
; 2282 : 	for( tu = 0; tu < MOD_FRAMES; tu++ )

	mov	DWORD PTR _tu$[ebp], 0
	jmp	SHORT $LN4@GL_InitRan
$LN2@GL_InitRan:
	mov	eax, DWORD PTR _tu$[ebp]
	add	eax, 1
	mov	DWORD PTR _tu$[ebp], eax
$LN4@GL_InitRan:
	cmp	DWORD PTR _tu$[ebp], 20			; 00000014H
	jge	SHORT $LN3@GL_InitRan

; 2283 : 	{
; 2284 : 		for( tv = 0; tv < MOD_FRAMES; tv++ )

	mov	DWORD PTR _tv$[ebp], 0
	jmp	SHORT $LN7@GL_InitRan
$LN5@GL_InitRan:
	mov	eax, DWORD PTR _tv$[ebp]
	add	eax, 1
	mov	DWORD PTR _tv$[ebp], eax
$LN7@GL_InitRan:
	cmp	DWORD PTR _tv$[ebp], 20			; 00000014H
	jge	SHORT $LN6@GL_InitRan

; 2285 : 		{
; 2286 : 			rtable[tu][tv] = COM_RandomLong( 0, 0x7FFF );

	push	32767					; 00007fffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	imul	ecx, DWORD PTR _tu$[ebp], 80
	mov	edx, DWORD PTR _tv$[ebp]
	mov	DWORD PTR _rtable[ecx+edx*4], eax

; 2287 : 		}

	jmp	SHORT $LN5@GL_InitRan
$LN6@GL_InitRan:

; 2288 : 	}

	jmp	SHORT $LN2@GL_InitRan
$LN3@GL_InitRan:

; 2289 : 
; 2290 : 	COM_SetRandomSeed( 0 );

	push	0
	call	_COM_SetRandomSeed
	add	esp, 4

; 2291 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_InitRandomTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_RebuildLightmaps
_TEXT	SEGMENT
_m$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_GL_RebuildLightmaps PROC				; COMDAT

; 2130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2131 : 	int	i, j;
; 2132 : 	model_t	*m;
; 2133 : 
; 2134 : 	if( !cl.video_prepped )

	cmp	DWORD PTR _cl+16, 0
	jne	SHORT $LN14@GL_Rebuild

; 2135 : 		return; // wait for worldmodel

	jmp	$LN1@GL_Rebuild
$LN14@GL_Rebuild:

; 2136 : 
; 2137 : 	ClearBits( vid_brightness->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_brightness
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_brightness
	mov	DWORD PTR [edx+8], ecx

; 2138 : 	ClearBits( vid_gamma->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_gamma
	mov	DWORD PTR [edx+8], ecx

; 2139 : 
; 2140 : 	// release old lightmaps
; 2141 : 	for( i = 0; i < MAX_LIGHTMAPS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Rebuild
$LN2@GL_Rebuild:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Rebuild:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@GL_Rebuild

; 2142 : 	{
; 2143 : 		if( !tr.lightmapTextures[i] ) break;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _tr[eax*4+28], 0
	jne	SHORT $LN15@GL_Rebuild
	jmp	SHORT $LN3@GL_Rebuild
$LN15@GL_Rebuild:

; 2144 : 		GL_FreeTexture( tr.lightmapTextures[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+28]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 2145 : 	}

	jmp	SHORT $LN2@GL_Rebuild
$LN3@GL_Rebuild:

; 2146 : 
; 2147 : 	// release old mirror textures
; 2148 : 	for (i = 0; i < MAX_MIRRORS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GL_Rebuild
$LN5@GL_Rebuild:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GL_Rebuild:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@GL_Rebuild

; 2149 : 	{
; 2150 : 		if (!tr.mirrorTextures[i]) break;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _tr[eax*4+1084], 0
	jne	SHORT $LN16@GL_Rebuild
	jmp	SHORT $LN6@GL_Rebuild
$LN16@GL_Rebuild:

; 2151 : 		GL_FreeTexture(tr.mirrorTextures[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+1084]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 2152 : 	}

	jmp	SHORT $LN5@GL_Rebuild
$LN6@GL_Rebuild:

; 2153 : 
; 2154 : 	memset( tr.lightmapTextures, 0, sizeof( tr.lightmapTextures ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _tr+28
	call	_memset
	add	esp, 12					; 0000000cH

; 2155 : 	gl_lms.current_lightmap_texture = 0;

	mov	DWORD PTR _gl_lms+4096, 0

; 2156 : 
; 2157 : 	// setup all the lightstyles
; 2158 : 	CL_RunLightStyles();

	call	_CL_RunLightStyles

; 2159 : 
; 2160 : 	LM_InitBlock();	

	call	_LM_InitBlock

; 2161 : 
; 2162 : 	for( i = 0; i < cl.nummodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@GL_Rebuild
$LN8@GL_Rebuild:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@GL_Rebuild:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2984344
	jge	SHORT $LN9@GL_Rebuild

; 2163 : 	{
; 2164 : 		if(( m = CL_ModelHandle( i + 1 )) == NULL )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _m$[ebp], eax
	cmp	DWORD PTR _m$[ebp], 0
	jne	SHORT $LN17@GL_Rebuild

; 2165 : 			continue;

	jmp	SHORT $LN8@GL_Rebuild
$LN17@GL_Rebuild:

; 2166 : 
; 2167 : 		if( m->name[0] == '*' || m->type != mod_brush )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _m$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN19@GL_Rebuild
	mov	eax, DWORD PTR _m$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN18@GL_Rebuild
$LN19@GL_Rebuild:

; 2168 : 			continue;

	jmp	SHORT $LN8@GL_Rebuild
$LN18@GL_Rebuild:

; 2169 : 
; 2170 : 		loadmodel = m;

	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR _loadmodel, eax

; 2171 : 
; 2172 : 		for( j = 0; j < m->numsurfaces; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@GL_Rebuild
$LN11@GL_Rebuild:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@GL_Rebuild:
	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+176]
	jge	SHORT $LN12@GL_Rebuild

; 2173 : 			GL_CreateSurfaceLightmap( m->surfaces + j );

	imul	eax, DWORD PTR _j$[ebp], 92
	mov	ecx, DWORD PTR _m$[ebp]
	add	eax, DWORD PTR [ecx+180]
	push	eax
	call	_GL_CreateSurfaceLightmap
	add	esp, 4
	jmp	SHORT $LN11@GL_Rebuild
$LN12@GL_Rebuild:

; 2174 : 	}

	jmp	$LN8@GL_Rebuild
$LN9@GL_Rebuild:

; 2175 : 	LM_UploadBlock( false );

	push	0
	call	_LM_UploadBlock
	add	esp, 4

; 2176 : 
; 2177 : 	if( clgame.drawFuncs.GL_BuildLightmaps )

	cmp	DWORD PTR _clgame+184, 0
	je	SHORT $LN1@GL_Rebuild

; 2178 : 	{
; 2179 : 		// build lightmaps on the client-side
; 2180 : 		clgame.drawFuncs.GL_BuildLightmaps( );

	call	DWORD PTR _clgame+184
$LN1@GL_Rebuild:

; 2181 : 	}
; 2182 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_RebuildLightmaps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawAlphaTextureChains
_TEXT	SEGMENT
_t$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_R_DrawAlphaTextureChains PROC				; COMDAT

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1279 : 	int		i;
; 1280 : 	msurface_t	*s;
; 1281 : 	texture_t		*t;
; 1282 : 
; 1283 : 	if( !draw_alpha_surfaces )

	cmp	DWORD PTR _draw_alpha_surfaces, 0
	jne	SHORT $LN8@R_DrawAlph

; 1284 : 		return;

	jmp	$LN1@R_DrawAlph
$LN8@R_DrawAlph:

; 1285 : 
; 1286 : 	memset( gl_lms.lightmap_surfaces, 0, sizeof( gl_lms.lightmap_surfaces ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _gl_lms+4104
	call	_memset
	add	esp, 12					; 0000000cH

; 1287 : 	gl_lms.dynamic_surfaces = NULL;

	mov	DWORD PTR _gl_lms+4100, 0

; 1288 : 
; 1289 : 	// make sure what color is reset
; 1290 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1291 : 	R_LoadIdentity(); // set identity matrix

	call	_R_LoadIdentity

; 1292 : 
; 1293 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1294 : 	pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 1295 : 	pglAlphaFunc( GL_GREATER, 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1296 : 
; 1297 : 	GL_SetupFogColorForSurfaces();

	call	_GL_SetupFogColorForSurfaces

; 1298 : 
; 1299 : 	// restore worldmodel
; 1300 : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 1301 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 1302 : 	RI.currententity->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+984], 4

; 1303 : 	draw_alpha_surfaces = false;

	mov	DWORD PTR _draw_alpha_surfaces, 0

; 1304 : 
; 1305 : 	for( i = 0; i < cl.worldmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawAlph
$LN2@R_DrawAlph:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawAlph:
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@R_DrawAlph

; 1306 : 	{
; 1307 : 		t = cl.worldmodel->textures[i];

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _t$[ebp], eax

; 1308 : 		if( !t ) continue;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN9@R_DrawAlph
	jmp	SHORT $LN2@R_DrawAlph
$LN9@R_DrawAlph:

; 1309 : 
; 1310 : 		s = t->texturechain;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _s$[ebp], ecx

; 1311 : 
; 1312 : 		if( !s || !FBitSet( s->flags, SURF_TRANSPARENT ))

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN11@R_DrawAlph
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 256				; 00000100H
	jne	SHORT $LN10@R_DrawAlph
$LN11@R_DrawAlph:

; 1313 : 			continue;

	jmp	SHORT $LN2@R_DrawAlph
$LN10@R_DrawAlph:

; 1314 : 
; 1315 : 		for( ; s != NULL; s = s->texturechain )

	jmp	SHORT $LN7@R_DrawAlph
$LN5@R_DrawAlph:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s$[ebp], ecx
$LN7@R_DrawAlph:
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN6@R_DrawAlph

; 1316 : 			R_RenderBrushPoly( s, CULL_VISIBLE );

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_R_RenderBrushPoly
	add	esp, 8
	jmp	SHORT $LN5@R_DrawAlph
$LN6@R_DrawAlph:

; 1317 : 		t->texturechain = NULL;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1318 : 	}

	jmp	$LN2@R_DrawAlph
$LN3@R_DrawAlph:

; 1319 : 
; 1320 : 	GL_ResetFogColor();

	call	_GL_ResetFogColor

; 1321 : 	R_BlendLightmaps();

	call	_R_BlendLightmaps

; 1322 : 	RI.currententity->curstate.rendermode = kRenderNormal; // restore world rendermode

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+984], 0

; 1323 : 	pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc
$LN1@R_DrawAlph:

; 1324 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawAlphaTextureChains ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_SetupFogColorForSurfaces
_TEXT	SEGMENT
tv80 = -92						; size = 4
tv76 = -92						; size = 4
_div$ = -24						; size = 4
_factor$ = -20						; size = 4
_fogColor$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_GL_SetupFogColorForSurfaces PROC			; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 204  : 	vec3_t	fogColor;
; 205  : 	float	factor, div;
; 206  : 
; 207  : 	if( !pglIsEnabled( GL_FOG ))

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GL_SetupFo

; 208  : 		return;

	jmp	$LN1@GL_SetupFo
$LN2@GL_SetupFo:

; 209  : 
; 210  : 	if( RI.currententity && RI.currententity->curstate.rendermode == kRenderTransTexture )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN3@GL_SetupFo
	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 2
	jne	SHORT $LN3@GL_SetupFo

; 211  :           {
; 212  : 		pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv

; 213  : 		return;

	jmp	$LN1@GL_SetupFo
$LN3@GL_SetupFo:

; 214  : 	}
; 215  : 
; 216  : 	div = (r_detailtextures->value) ? 2.0f : 1.0f;

	mov	eax, DWORD PTR _r_detailtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@GL_SetupFo
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN6@GL_SetupFo
$LN5@GL_SetupFo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv76[ebp], xmm0
$LN6@GL_SetupFo:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _div$[ebp], xmm0

; 217  : 	factor = (r_detailtextures->value) ? 3.0f : 2.0f;

	mov	eax, DWORD PTR _r_detailtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@GL_SetupFo
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN8@GL_SetupFo
$LN7@GL_SetupFo:
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv80[ebp], xmm0
$LN8@GL_SetupFo:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR _factor$[ebp], xmm0

; 218  : 	fogColor[0] = pow( RI.fogColor[0] / div, ( 1.0f / factor ));

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _factor$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+324]
	divss	xmm0, DWORD PTR _div$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _fogColor$[ebp+eax]

; 219  : 	fogColor[1] = pow( RI.fogColor[1] / div, ( 1.0f / factor ));

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _factor$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+324]
	divss	xmm0, DWORD PTR _div$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _fogColor$[ebp+ecx]

; 220  : 	fogColor[2] = pow( RI.fogColor[2] / div, ( 1.0f / factor ));

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _factor$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+324]
	divss	xmm0, DWORD PTR _div$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _fogColor$[ebp+ecx]

; 221  : 	pglFogfv( GL_FOG_COLOR, fogColor );

	lea	eax, DWORD PTR _fogColor$[ebp]
	push	eax
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv
$LN1@GL_SetupFo:

; 222  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetupFogColorForSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_TextureAnimation
_TEXT	SEGMENT
_speed$1 = -24						; size = 4
_ty$2 = -20						; size = 4
_tx$3 = -16						; size = 4
_reletive$ = -12					; size = 4
_count$ = -8						; size = 4
_base$ = -4						; size = 4
_s$ = 8							; size = 4
_R_TextureAnimation PROC				; COMDAT

; 402  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 403  : 	texture_t	*base = s->texinfo->texture;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _base$[ebp], edx

; 404  : 	int	count, reletive;
; 405  : 
; 406  : 	if( RI.currententity->curstate.frame )

	mov	eax, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [eax+960]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_TextureA

; 407  : 	{
; 408  : 		if( base->alternate_anims )

	mov	eax, DWORD PTR _base$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@R_TextureA

; 409  : 			base = base->alternate_anims;

	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _base$[ebp], ecx
$LN5@R_TextureA:

; 410  : 	}
; 411  : 	
; 412  : 	if( !base->anim_total )

	mov	eax, DWORD PTR _base$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN6@R_TextureA

; 413  : 		return base;

	mov	eax, DWORD PTR _base$[ebp]
	jmp	$LN1@R_TextureA
$LN6@R_TextureA:

; 414  : 
; 415  : 	if( base->name[0] == '-' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _base$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN7@R_TextureA

; 416  : 	{
; 417  : 		int	tx = (int)((s->texturemins[0] + (base->width << 16)) / base->width) % MOD_FRAMES;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, WORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	shl	edx, 16					; 00000010H
	add	eax, edx
	mov	ecx, DWORD PTR _base$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+16]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR _tx$3[ebp], edx

; 418  : 		int	ty = (int)((s->texturemins[1] + (base->height << 16)) / base->height) % MOD_FRAMES;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	eax, WORD PTR [ecx+eax+20]
	mov	edx, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shl	ecx, 16					; 00000010H
	add	eax, ecx
	mov	ecx, DWORD PTR _base$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+20]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR _ty$2[ebp], edx

; 419  : 
; 420  : 		reletive = rtable[tx][ty] % base->anim_total;

	imul	eax, DWORD PTR _tx$3[ebp], 80
	mov	ecx, DWORD PTR _ty$2[ebp]
	mov	esi, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _rtable[eax+ecx*4]
	cdq
	idiv	DWORD PTR [esi+32]
	mov	DWORD PTR _reletive$[ebp], edx

; 421  : 	}

	jmp	SHORT $LN8@R_TextureA
$LN7@R_TextureA:

; 422  : 	else
; 423  : 	{
; 424  : 		int	speed;
; 425  : 
; 426  : 		// Quake1 textures uses 10 frames per second
; 427  : 		if( FBitSet( R_GetTexture( base->gl_texturenum )->flags, TF_QUAKEPAL ))

	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	edx, DWORD PTR [eax+284]
	and	edx, 256				; 00000100H
	je	SHORT $LN9@R_TextureA

; 428  : 			speed = 10;

	mov	DWORD PTR _speed$1[ebp], 10		; 0000000aH
	jmp	SHORT $LN10@R_TextureA
$LN9@R_TextureA:

; 429  : 		else speed = 20;

	mov	DWORD PTR _speed$1[ebp], 20		; 00000014H
$LN10@R_TextureA:

; 430  : 
; 431  : 		reletive = (int)(cl.time * speed) % base->anim_total;

	cvtsi2sd xmm0, DWORD PTR _speed$1[ebp]
	mulsd	xmm0, QWORD PTR _cl+2167640
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _base$[ebp]
	cdq
	idiv	DWORD PTR [ecx+32]
	mov	DWORD PTR _reletive$[ebp], edx
$LN8@R_TextureA:

; 432  : 	}
; 433  : 
; 434  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0
$LN2@R_TextureA:

; 435  : 
; 436  : 	while( base->anim_min > reletive || base->anim_max <= reletive )

	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _reletive$[ebp]
	jg	SHORT $LN11@R_TextureA
	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	cmp	ecx, DWORD PTR _reletive$[ebp]
	jg	SHORT $LN3@R_TextureA
$LN11@R_TextureA:

; 437  : 	{
; 438  : 		base = base->anim_next;

	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _base$[ebp], ecx

; 439  : 
; 440  : 		if( !base || ++count > MOD_FRAMES )

	cmp	DWORD PTR _base$[ebp], 0
	je	SHORT $LN13@R_TextureA
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	cmp	DWORD PTR _count$[ebp], 20		; 00000014H
	jle	SHORT $LN12@R_TextureA
$LN13@R_TextureA:

; 441  : 			return s->texinfo->texture;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+36]
	jmp	SHORT $LN1@R_TextureA
$LN12@R_TextureA:

; 442  : 	}

	jmp	SHORT $LN2@R_TextureA
$LN3@R_TextureA:

; 443  : 
; 444  : 	return base;

	mov	eax, DWORD PTR _base$[ebp]
$LN1@R_TextureA:

; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TextureAnimation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _DrawGLPoly
_TEXT	SEGMENT
tv131 = -116						; size = 4
_texture$1 = -48					; size = 4
_flAngle$2 = -44					; size = 4
_flRate$3 = -40						; size = 4
_flConveyorSpeed$4 = -36				; size = 4
_hasScale$ = -32					; size = 4
_i$ = -28						; size = 4
_e$ = -24						; size = 4
_cy$ = -20						; size = 4
_tOffset$ = -16						; size = 4
_sy$ = -12						; size = 4
_sOffset$ = -8						; size = 4
_v$ = -4						; size = 4
_p$ = 8							; size = 4
_xScale$ = 12						; size = 4
_yScale$ = 16						; size = 4
_DrawGLPoly PROC					; COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 713  : 	float		*v;
; 714  : 	float		sOffset, sy;
; 715  : 	float		tOffset, cy;
; 716  : 	cl_entity_t	*e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 717  : 	int		i, hasScale = false;

	mov	DWORD PTR _hasScale$[ebp], 0

; 718  : 
; 719  : 	if( !p ) return;

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN5@DrawGLPoly
	jmp	$LN17@DrawGLPoly
$LN5@DrawGLPoly:

; 720  : 
; 721  : 	if( FBitSet( p->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 32					; 00000020H
	je	SHORT $LN6@DrawGLPoly

; 722  : 		GL_ResetFogColor();

	call	_GL_ResetFogColor
$LN6@DrawGLPoly:

; 723  : 
; 724  : 	if( p->flags & SURF_CONVEYOR )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 64					; 00000040H
	je	$LN7@DrawGLPoly

; 725  : 	{
; 726  : 		float		flConveyorSpeed = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _flConveyorSpeed$4[ebp], xmm0

; 727  : 		float		flRate, flAngle;
; 728  : 		gl_texture_t	*texture;
; 729  : 
; 730  : 		if( CL_IsQuakeCompatible() && RI.currententity == clgame.entities )

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN9@DrawGLPoly
	mov	eax, DWORD PTR _RI+28
	cmp	eax, DWORD PTR _clgame+996
	jne	SHORT $LN9@DrawGLPoly

; 731  : 		{
; 732  : 			// same as doom speed
; 733  : 			flConveyorSpeed = -35.0f;

	movss	xmm0, DWORD PTR __real@c20c0000
	movss	DWORD PTR _flConveyorSpeed$4[ebp], xmm0

; 734  : 		}

	jmp	SHORT $LN11@DrawGLPoly
$LN9@DrawGLPoly:

; 735  : 		else
; 736  : 		{
; 737  : 			flConveyorSpeed = (e->curstate.rendercolor.g<<8|e->curstate.rendercolor.b) / 16.0f;

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+993]
	shl	ecx, 8
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+994]
	or	ecx, eax
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR _flConveyorSpeed$4[ebp], xmm0

; 738  : 			if( e->curstate.rendercolor.r ) flConveyorSpeed = -flConveyorSpeed;

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	test	ecx, ecx
	je	SHORT $LN11@DrawGLPoly
	movss	xmm0, DWORD PTR _flConveyorSpeed$4[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _flConveyorSpeed$4[ebp], xmm0
$LN11@DrawGLPoly:

; 739  : 		}
; 740  : 		texture = R_GetTexture( glState.currentTextures[glState.activeTMU] );

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _glState[eax*4+20]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _texture$1[ebp], eax

; 741  : 
; 742  : 		flRate = abs( flConveyorSpeed ) / (float)texture->srcWidth;

	cvttss2si eax, DWORD PTR _flConveyorSpeed$4[ebp]
	push	eax
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _texture$1[ebp]
	movzx	edx, WORD PTR [ecx+256]
	cvtsi2ss xmm1, edx
	divss	xmm0, xmm1
	movss	DWORD PTR _flRate$3[ebp], xmm0

; 743  : 		flAngle = ( flConveyorSpeed >= 0 ) ? 180 : 0;

	movss	xmm0, DWORD PTR _flConveyorSpeed$4[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN19@DrawGLPoly
	mov	DWORD PTR tv131[ebp], 180		; 000000b4H
	jmp	SHORT $LN20@DrawGLPoly
$LN19@DrawGLPoly:
	mov	DWORD PTR tv131[ebp], 0
$LN20@DrawGLPoly:
	cvtsi2ss xmm0, DWORD PTR tv131[ebp]
	movss	DWORD PTR _flAngle$2[ebp], xmm0

; 744  : 
; 745  : 		SinCos( flAngle * ( M_PI / 180.0f ), &sy, &cy );

	lea	eax, DWORD PTR _cy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sy$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _flAngle$2[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 746  : 		sOffset = cl.time * cy * flRate;

	cvtss2sd xmm0, DWORD PTR _cy$[ebp]
	mulsd	xmm0, QWORD PTR _cl+2167640
	cvtss2sd xmm1, DWORD PTR _flRate$3[ebp]
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sOffset$[ebp], xmm0

; 747  : 		tOffset = cl.time * sy * flRate;

	cvtss2sd xmm0, DWORD PTR _sy$[ebp]
	mulsd	xmm0, QWORD PTR _cl+2167640
	cvtss2sd xmm1, DWORD PTR _flRate$3[ebp]
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _tOffset$[ebp], xmm0

; 748  : 	
; 749  : 		// make sure that we are positive
; 750  : 		if( sOffset < 0.0f ) sOffset += 1.0f + -(int)sOffset;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _sOffset$[ebp]
	jbe	SHORT $LN12@DrawGLPoly
	cvttss2si eax, DWORD PTR _sOffset$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _sOffset$[ebp]
	movss	DWORD PTR _sOffset$[ebp], xmm0
$LN12@DrawGLPoly:

; 751  : 		if( tOffset < 0.0f ) tOffset += 1.0f + -(int)tOffset;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _tOffset$[ebp]
	jbe	SHORT $LN13@DrawGLPoly
	cvttss2si eax, DWORD PTR _tOffset$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _tOffset$[ebp]
	movss	DWORD PTR _tOffset$[ebp], xmm0
$LN13@DrawGLPoly:

; 752  : 
; 753  : 		// make sure that we are in a [0,1] range
; 754  : 		sOffset = sOffset - (int)sOffset;

	cvttss2si eax, DWORD PTR _sOffset$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _sOffset$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _sOffset$[ebp], xmm1

; 755  : 		tOffset = tOffset - (int)tOffset;

	cvttss2si eax, DWORD PTR _tOffset$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _tOffset$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _tOffset$[ebp], xmm1

; 756  : 	}

	jmp	SHORT $LN8@DrawGLPoly
$LN7@DrawGLPoly:

; 757  : 	else
; 758  : 	{
; 759  : 		sOffset = tOffset = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _tOffset$[ebp], xmm0
	movss	xmm0, DWORD PTR _tOffset$[ebp]
	movss	DWORD PTR _sOffset$[ebp], xmm0
$LN8@DrawGLPoly:

; 760  : 	}
; 761  : 
; 762  : 	if( xScale != 0.0f && yScale != 0.0f )

	movss	xmm0, DWORD PTR _xScale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@DrawGLPoly
	movss	xmm0, DWORD PTR _yScale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@DrawGLPoly

; 763  : 		hasScale = true;

	mov	DWORD PTR _hasScale$[ebp], 1
$LN14@DrawGLPoly:

; 764  : 
; 765  : 	pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 766  : 
; 767  : 	for( i = 0, v = p->verts[0]; i < p->numverts; i++, v += VERTEXSIZE )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _v$[ebp], eax
	jmp	SHORT $LN4@DrawGLPoly
$LN2@DrawGLPoly:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _v$[ebp], ecx
$LN4@DrawGLPoly:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN3@DrawGLPoly

; 768  : 	{
; 769  : 		if( hasScale )

	cmp	DWORD PTR _hasScale$[ebp], 0
	je	SHORT $LN15@DrawGLPoly

; 770  : 			pglTexCoord2f(( v[3] + sOffset ) * xScale, ( v[4] + tOffset ) * yScale );

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _tOffset$[ebp]
	mulss	xmm0, DWORD PTR _yScale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _sOffset$[ebp]
	mulss	xmm0, DWORD PTR _xScale$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
	jmp	SHORT $LN16@DrawGLPoly
$LN15@DrawGLPoly:

; 771  : 		else pglTexCoord2f( v[3] + sOffset, v[4] + tOffset );

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _tOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _sOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN16@DrawGLPoly:

; 772  : 
; 773  : 		pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 774  : 	}

	jmp	$LN2@DrawGLPoly
$LN3@DrawGLPoly:

; 775  : 
; 776  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 777  : 
; 778  : 	if( FBitSet( p->flags, SURF_DRAWTILED ))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 32					; 00000020H
	je	SHORT $LN17@DrawGLPoly

; 779  : 		GL_SetupFogColorForSurfaces();

	call	_GL_SetupFogColorForSurfaces
$LN17@DrawGLPoly:

; 780  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DrawGLPoly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_BuildPolygonFromSurface
_TEXT	SEGMENT
tv742 = -184						; size = 8
tv710 = -184						; size = 8
tv973 = -180						; size = 8
tv964 = -180						; size = 8
tv955 = -180						; size = 8
tv738 = -176						; size = 4
tv706 = -176						; size = 4
tv510 = -176						; size = 4
tv450 = -176						; size = 4
tv409 = -176						; size = 4
tv92 = -176						; size = 4
_k$1 = -108						; size = 4
_j$2 = -104						; size = 4
_ilength$3 = -100					; size = 4
_ilength$4 = -96					; size = 4
_next$5 = -92						; size = 4
_this$6 = -88						; size = 4
_prev$7 = -84						; size = 4
_v2$8 = -80						; size = 12
_v1$9 = -68						; size = 12
_poly$ = -56						; size = 4
_t$ = -52						; size = 4
_s$ = -48						; size = 4
_vec$ = -44						; size = 4
_glt$ = -40						; size = 4
_tex$ = -36						; size = 4
_sample_size$ = -32					; size = 4
_info$ = -28						; size = 4
_r_pedge$ = -24						; size = 4
_pedges$ = -20						; size = 4
_lnumverts$ = -16					; size = 4
_lindex$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_fa$ = 12						; size = 4
_GL_BuildPolygonFromSurface PROC			; COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 272  : 	int		i, lindex, lnumverts;
; 273  : 	medge_t		*pedges, *r_pedge;
; 274  : 	mextrasurf_t	*info = fa->info;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _info$[ebp], ecx

; 275  : 	float		sample_size;
; 276  : 	texture_t		*tex;
; 277  : 	gl_texture_t	*glt;
; 278  : 	float		*vec;
; 279  : 	float		s, t;
; 280  : 	glpoly_t		*poly;
; 281  : 
; 282  : 	if( !mod || !fa->texinfo || !fa->texinfo->texture )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN15@GL_BuildPo
	mov	eax, DWORD PTR _fa$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN15@GL_BuildPo
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN14@GL_BuildPo
$LN15@GL_BuildPo:

; 283  : 		return; // bad polygon ?

	jmp	$LN1@GL_BuildPo
$LN14@GL_BuildPo:

; 284  : 
; 285  : 	if( FBitSet( fa->flags, SURF_CONVEYOR ) && fa->texinfo->texture->gl_texturenum != 0 )

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 64					; 00000040H
	je	$LN16@GL_BuildPo
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx+24], 0
	je	$LN16@GL_BuildPo

; 286  : 	{
; 287  : 		glt = R_GetTexture( fa->texinfo->texture->gl_texturenum );

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 288  : 		tex = fa->texinfo->texture;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _tex$[ebp], edx

; 289  : 		Assert( glt != NULL && tex != NULL );

	cmp	DWORD PTR _glt$[ebp], 0
	je	SHORT $LN24@GL_BuildPo
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN24@GL_BuildPo
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN25@GL_BuildPo
$LN24@GL_BuildPo:
	mov	DWORD PTR tv92[ebp], 0
$LN25@GL_BuildPo:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_BuildPolygonFromSurface@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BL@CLCBKDHC@glt?5?$CB?$DN?5NULL?5?$CG?$CG?5tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv92[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 290  : 
; 291  : 		// update conveyor widths for keep properly speed of scrolling
; 292  : 		glt->srcWidth = tex->width;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	dx, WORD PTR [ecx+16]
	mov	WORD PTR [eax+256], dx

; 293  : 		glt->srcHeight = tex->height;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	dx, WORD PTR [ecx+20]
	mov	WORD PTR [eax+258], dx
$LN16@GL_BuildPo:

; 294  : 	}
; 295  : 
; 296  : 	sample_size = Mod_SampleSizeForFace( fa );

	mov	eax, DWORD PTR _fa$[ebp]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _sample_size$[ebp], xmm0

; 297  : 
; 298  : 	// reconstruct the polygon
; 299  : 	pedges = mod->edges;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	DWORD PTR _pedges$[ebp], ecx

; 300  : 	lnumverts = fa->numedges;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _lnumverts$[ebp], ecx

; 301  : 
; 302  : 	// detach if already created, reconstruct again
; 303  : 	poly = fa->polys;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _poly$[ebp], ecx

; 304  : 	fa->polys = NULL;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	DWORD PTR [eax+36], 0

; 305  : 
; 306  : 	// quake simple models (healthkits etc) need to be reconstructed their polys because LM coords has changed after the map change
; 307  : 	poly = Mem_Realloc( mod->mempool, poly, sizeof( glpoly_t ) + ( lnumverts - 4 ) * VERTEXSIZE * sizeof( float ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_BuildPolygonFromSurface@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DF@MDCBIDLJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _lnumverts$[ebp]
	sub	ecx, 4
	imul	edx, ecx, 7
	lea	eax, DWORD PTR [edx*4+128]
	push	eax
	mov	ecx, DWORD PTR _poly$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _poly$[ebp], eax

; 308  : 	poly->next = fa->polys;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax], edx

; 309  : 	poly->flags = fa->flags;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 310  : 	fa->polys = poly;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR _poly$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 311  : 	poly->numverts = lnumverts;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _lnumverts$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 312  : 
; 313  : 	for( i = 0; i < lnumverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_BuildPo
$LN2@GL_BuildPo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_BuildPo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _lnumverts$[ebp]
	jge	$LN3@GL_BuildPo

; 314  : 	{
; 315  : 		lindex = mod->surfedges[fa->firstedge + i];

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _lindex$[ebp], ecx

; 316  : 
; 317  : 		if( lindex > 0 )

	cmp	DWORD PTR _lindex$[ebp], 0
	jle	SHORT $LN17@GL_BuildPo

; 318  : 		{
; 319  : 			r_pedge = &pedges[lindex];

	mov	eax, DWORD PTR _lindex$[ebp]
	mov	ecx, DWORD PTR _pedges$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _r_pedge$[ebp], edx

; 320  : 			vec = mod->vertexes[r_pedge->v[0]].position;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _r_pedge$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+148]
	add	eax, ecx
	mov	DWORD PTR _vec$[ebp], eax

; 321  : 		}

	jmp	SHORT $LN18@GL_BuildPo
$LN17@GL_BuildPo:

; 322  : 		else
; 323  : 		{
; 324  : 			r_pedge = &pedges[-lindex];

	mov	eax, DWORD PTR _lindex$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _pedges$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _r_pedge$[ebp], edx

; 325  : 			vec = mod->vertexes[r_pedge->v[1]].position;

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _r_pedge$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	add	edx, eax
	mov	DWORD PTR _vec$[ebp], edx
$LN18@GL_BuildPo:

; 326  : 		}
; 327  : 
; 328  : 		s = DotProduct( vec, fa->texinfo->vecs[0] ) + fa->texinfo->vecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR _s$[ebp], xmm0

; 329  : 		s /= fa->texinfo->texture->width;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv706[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv706[ebp]
	mov	ecx, DWORD PTR tv706[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv710[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv710[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 330  : 
; 331  : 		t = DotProduct( vec, fa->texinfo->vecs[1] ) + fa->texinfo->vecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _fa$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 3
	addss	xmm0, DWORD PTR [edx+eax]
	movss	DWORD PTR _t$[ebp], xmm0

; 332  : 		t /= fa->texinfo->texture->height;

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv738[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv738[ebp]
	mov	ecx, DWORD PTR tv738[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv742[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv742[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 333  : 
; 334  : 		VectorCopy( vec, poly->verts[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [eax+edx+16]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _vec$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	eax, DWORD PTR [ecx+eax+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 28
	mov	edx, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+16]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 335  : 		poly->verts[i][3] = s;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 336  : 		poly->verts[i][4] = t;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	shl	eax, 2
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 337  : 
; 338  : 		// lightmap texture coordinates
; 339  : 		s = DotProduct( vec, info->lmvecs[0] ) + info->lmvecs[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+eax+56]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+edx+56]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	ecx, DWORD PTR [eax+edx+56]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _s$[ebp], xmm0

; 340  : 		s -= info->lightmapmins[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, WORD PTR [edx+ecx+48]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _s$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 341  : 		s += fa->light_s * sample_size;

	mov	eax, DWORD PTR _fa$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 342  : 		s += sample_size * 0.5f;

	movss	xmm0, DWORD PTR _sample_size$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 343  : 		s /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->width;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 344  : 
; 345  : 		t = DotProduct( vec, info->lmvecs[1] ) + info->lmvecs[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+56]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _vec$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	mov	edx, DWORD PTR _info$[ebp]
	lea	eax, DWORD PTR [edx+ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _t$[ebp], xmm0

; 346  : 		t -= info->lightmapmins[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _info$[ebp]
	movsx	edx, WORD PTR [ecx+eax+48]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _t$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 347  : 		t += fa->light_t * sample_size;

	mov	eax, DWORD PTR _fa$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	addss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _t$[ebp], xmm0

; 348  : 		t += sample_size * 0.5f;

	movss	xmm0, DWORD PTR _sample_size$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _t$[ebp], xmm0

; 349  : 		t /= BLOCK_SIZE * sample_size; //fa->texinfo->texture->height;

	cvtsi2ss xmm0, DWORD PTR _tr+87580
	mulss	xmm0, DWORD PTR _sample_size$[ebp]
	movss	xmm1, DWORD PTR _t$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t$[ebp], xmm1

; 350  : 
; 351  : 		poly->verts[i][5] = s;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 5
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 352  : 		poly->verts[i][6] = t;

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, 4
	imul	ecx, eax, 6
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 353  : 	}

	jmp	$LN2@GL_BuildPo
$LN3@GL_BuildPo:

; 354  : 
; 355  : 	// remove co-linear points - Ed
; 356  : 	if( !CVAR_TO_BOOL( gl_keeptjunctions ) && !FBitSet( fa->flags, SURF_UNDERWATER ))

	cmp	DWORD PTR _gl_keeptjunctions, 0
	je	SHORT $LN26@GL_BuildPo
	mov	eax, DWORD PTR _gl_keeptjunctions
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@GL_BuildPo
	mov	DWORD PTR tv409[ebp], 1
	jmp	SHORT $LN27@GL_BuildPo
$LN26@GL_BuildPo:
	mov	DWORD PTR tv409[ebp], 0
$LN27@GL_BuildPo:
	cmp	DWORD PTR tv409[ebp], 0
	jne	$LN6@GL_BuildPo
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 128				; 00000080H
	jne	$LN6@GL_BuildPo

; 357  : 	{
; 358  : 		for( i = 0; i < lnumverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GL_BuildPo
$LN5@GL_BuildPo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GL_BuildPo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _lnumverts$[ebp]
	jge	$LN6@GL_BuildPo

; 359  : 		{
; 360  : 			vec3_t	v1, v2;
; 361  : 			float	*prev, *this, *next;
; 362  : 
; 363  : 			prev = poly->verts[(i + lnumverts - 1) % lnumverts];

	mov	eax, DWORD PTR _lnumverts$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	cdq
	idiv	DWORD PTR _lnumverts$[ebp]
	imul	edx, edx, 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _prev$7[ebp], ecx

; 364  : 			next = poly->verts[(i + 1) % lnumverts];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _lnumverts$[ebp]
	imul	eax, edx, 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _next$5[ebp], edx

; 365  : 			this = poly->verts[i];

	imul	eax, DWORD PTR _i$[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _this$6[ebp], edx

; 366  : 
; 367  : 			VectorSubtract( this, prev, v1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _this$6[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _v1$9[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$6[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _v1$9[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _this$6[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv450[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv450[ebp]
	movss	DWORD PTR _v1$9[ebp+eax], xmm0

; 368  : 			VectorNormalize( v1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v1$9[ebp+ecx]
	mulss	xmm0, DWORD PTR _v1$9[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _v1$9[ebp+ecx]
	mulss	xmm1, DWORD PTR _v1$9[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _v1$9[ebp+eax]
	mulss	xmm1, DWORD PTR _v1$9[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$4[ebp]
	movss	xmm0, DWORD PTR _ilength$4[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@GL_BuildPo
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$4[ebp]
	movss	DWORD PTR _ilength$4[ebp], xmm0
$LN20@GL_BuildPo:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v1$9[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v1$9[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _v1$9[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _v1$9[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v1$9[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _v1$9[ebp+ecx], xmm0

; 369  : 			VectorSubtract( next, prev, v2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _next$5[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _v2$8[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _next$5[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _v2$8[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _next$5[ebp]
	mov	esi, DWORD PTR _prev$7[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv510[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv510[ebp]
	movss	DWORD PTR _v2$8[ebp+eax], xmm0

; 370  : 			VectorNormalize( v2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v2$8[ebp+ecx]
	mulss	xmm0, DWORD PTR _v2$8[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _v2$8[ebp+ecx]
	mulss	xmm1, DWORD PTR _v2$8[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _v2$8[ebp+eax]
	mulss	xmm1, DWORD PTR _v2$8[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@GL_BuildPo
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN21@GL_BuildPo:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v2$8[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v2$8[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _v2$8[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _v2$8[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v2$8[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _v2$8[ebp+ecx], xmm0

; 371  : 
; 372  : 			// skip co-linear points
; 373  : 			if(( fabs( v1[0] - v2[0] ) <= 0.001f) && (fabs( v1[1] - v2[1] ) <= 0.001f) && (fabs( v1[2] - v2[2] ) <= 0.001f))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v1$9[ebp+ecx]
	subss	xmm0, DWORD PTR _v2$8[ebp+eax]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv955[ebp]
	movsd	xmm0, QWORD PTR __real@3f50624de0000000
	comisd	xmm0, QWORD PTR tv955[ebp]
	jb	$LN22@GL_BuildPo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _v1$9[ebp+eax]
	subss	xmm0, DWORD PTR _v2$8[ebp+ecx]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv964[ebp]
	movsd	xmm0, QWORD PTR __real@3f50624de0000000
	comisd	xmm0, QWORD PTR tv964[ebp]
	jb	$LN22@GL_BuildPo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _v1$9[ebp+eax]
	subss	xmm0, DWORD PTR _v2$8[ebp+ecx]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv973[ebp]
	movsd	xmm0, QWORD PTR __real@3f50624de0000000
	comisd	xmm0, QWORD PTR tv973[ebp]
	jb	SHORT $LN22@GL_BuildPo

; 374  : 			{
; 375  : 				int	j, k;
; 376  : 
; 377  : 				for( j = i + 1; j < lnumverts; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
	jmp	SHORT $LN10@GL_BuildPo
$LN8@GL_BuildPo:
	mov	eax, DWORD PTR _j$2[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
$LN10@GL_BuildPo:
	mov	eax, DWORD PTR _j$2[ebp]
	cmp	eax, DWORD PTR _lnumverts$[ebp]
	jge	SHORT $LN9@GL_BuildPo

; 378  : 				{
; 379  : 					for( k = 0; k < VERTEXSIZE; k++ )

	mov	DWORD PTR _k$1[ebp], 0
	jmp	SHORT $LN13@GL_BuildPo
$LN11@GL_BuildPo:
	mov	eax, DWORD PTR _k$1[ebp]
	add	eax, 1
	mov	DWORD PTR _k$1[ebp], eax
$LN13@GL_BuildPo:
	cmp	DWORD PTR _k$1[ebp], 7
	jge	SHORT $LN12@GL_BuildPo

; 380  : 						poly->verts[j-1][k] = poly->verts[j][k];

	imul	eax, DWORD PTR _j$2[ebp], 28
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, DWORD PTR _j$2[ebp]
	sub	eax, 1
	imul	ecx, eax, 28
	mov	eax, DWORD PTR _poly$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+16]
	mov	eax, DWORD PTR _k$1[ebp]
	mov	esi, DWORD PTR _k$1[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN11@GL_BuildPo
$LN12@GL_BuildPo:

; 381  : 				}

	jmp	SHORT $LN8@GL_BuildPo
$LN9@GL_BuildPo:

; 382  : 
; 383  : 				// retry next vertex next time, which is now current vertex
; 384  : 				lnumverts--;

	mov	eax, DWORD PTR _lnumverts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lnumverts$[ebp], eax

; 385  : 				nColinElim++;

	mov	eax, DWORD PTR _nColinElim
	add	eax, 1
	mov	DWORD PTR _nColinElim, eax

; 386  : 				i--;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN22@GL_BuildPo:

; 387  : 			}
; 388  : 		}

	jmp	$LN5@GL_BuildPo
$LN6@GL_BuildPo:

; 389  : 	}
; 390  : 
; 391  : 	poly->numverts = lnumverts;

	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _lnumverts$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@GL_BuildPo:

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BuildPolygonFromSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _GL_SubdivideSurface
_TEXT	SEGMENT
_vec$ = -788						; size = 4
_lindex$ = -784						; size = 4
_i$ = -780						; size = 4
_numverts$ = -776					; size = 4
_verts$ = -772						; size = 768
__$ArrayPad$ = -4					; size = 4
_fa$ = 8						; size = 4
_GL_SubdivideSurface PROC				; COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 916				; 00000394H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 242  : 	vec3_t	verts[SUBDIVIDE_SIZE];
; 243  : 	int	numverts;
; 244  : 	int	i, lindex;
; 245  : 	float	*vec;
; 246  : 
; 247  : 	// convert edges back to a normal polygon
; 248  : 	numverts = 0;

	mov	DWORD PTR _numverts$[ebp], 0

; 249  : 	for( i = 0; i < fa->numedges; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Subdivi
$LN2@GL_Subdivi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Subdivi:
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@GL_Subdivi

; 250  : 	{
; 251  : 		lindex = loadmodel->surfedges[fa->firstedge + i];

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+188]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _lindex$[ebp], ecx

; 252  : 
; 253  : 		if( lindex > 0 ) vec = loadmodel->vertexes[loadmodel->edges[lindex].v[0]].position;

	cmp	DWORD PTR _lindex$[ebp], 0
	jle	SHORT $LN5@GL_Subdivi
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _lindex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _loadmodel
	mov	eax, DWORD PTR [edx+148]
	add	eax, ecx
	mov	DWORD PTR _vec$[ebp], eax
	jmp	SHORT $LN6@GL_Subdivi
$LN5@GL_Subdivi:

; 254  : 		else vec = loadmodel->vertexes[loadmodel->edges[-lindex].v[1]].position;

	mov	eax, DWORD PTR _lindex$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+156]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, 2
	shl	ecx, 0
	movzx	edx, WORD PTR [eax+ecx]
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _loadmodel
	mov	edx, DWORD PTR [ecx+148]
	add	edx, eax
	mov	DWORD PTR _vec$[ebp], edx
$LN6@GL_Subdivi:

; 255  : 		VectorCopy( vec, verts[numverts] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _numverts$[ebp], 12
	lea	eax, DWORD PTR _verts$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _vec$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _numverts$[ebp], 12
	lea	ecx, DWORD PTR _verts$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _vec$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _numverts$[ebp], 12
	lea	edx, DWORD PTR _verts$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _vec$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 256  : 		numverts++;

	mov	eax, DWORD PTR _numverts$[ebp]
	add	eax, 1
	mov	DWORD PTR _numverts$[ebp], eax

; 257  : 	}

	jmp	$LN2@GL_Subdivi
$LN3@GL_Subdivi:

; 258  : 
; 259  : 	SetBits( fa->flags, SURF_DRAWTURB_QUADS ); // predict state

	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8
	mov	edx, DWORD PTR _fa$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 260  : 
; 261  : 	// do subdivide
; 262  : 	SubdividePolygon_r( fa, numverts, verts[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _verts$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _numverts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	call	_SubdividePolygon_r
	add	esp, 12					; 0000000cH

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SubdivideSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawBrushModel
_TEXT	SEGMENT
tv365 = -156						; size = 4
tv235 = -156						; size = 4
tv189 = -156						; size = 4
tv162 = -156						; size = 4
_l$ = -88						; size = 4
_rotated$ = -84						; size = 4
_clmodel$ = -80						; size = 4
_psurf$ = -76						; size = 4
_cull_type$ = -72					; size = 4
_maxs$ = -68						; size = 12
_mins$ = -56						; size = 12
_old_rendermode$ = -44					; size = 4
_oldorigin$ = -40					; size = 12
_origin_l$ = -28					; size = 12
_num_sorted$ = -16					; size = 4
_k$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_DrawBrushModel PROC					; COMDAT

; 1469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1470 : 	int		i, k, num_sorted;
; 1471 : 	vec3_t		origin_l, oldorigin;
; 1472 : 	int		old_rendermode;
; 1473 : 	vec3_t		mins, maxs;
; 1474 : 	int		cull_type;
; 1475 : 	msurface_t	*psurf;
; 1476 : 	model_t		*clmodel;
; 1477 : 	qboolean		rotated;
; 1478 : 	dlight_t		*l;
; 1479 : 
; 1480 : 	if( !RI.drawWorld ) return;

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN14@R_DrawBrus
	jmp	$LN1@R_DrawBrus
$LN14@R_DrawBrus:

; 1481 : 
; 1482 : 	clmodel = e->model;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _clmodel$[ebp], ecx

; 1483 : 
; 1484 : 	// don't reflect this entity in mirrors
; 1485 : 	if (e->curstate.effects & EF_NOREFLECT && RI.params & RP_MIRRORVIEW)

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 16777216				; 01000000H
	je	SHORT $LN15@R_DrawBrus
	mov	eax, DWORD PTR _RI
	and	eax, 1
	je	SHORT $LN15@R_DrawBrus

; 1486 : 		return;

	jmp	$LN1@R_DrawBrus
$LN15@R_DrawBrus:

; 1487 : 
; 1488 : 	// draw only in mirrors
; 1489 : 	if (e->curstate.effects & EF_REFLECTONLY && !(RI.params & RP_MIRRORVIEW))

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 33554432				; 02000000H
	je	SHORT $LN16@R_DrawBrus
	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	SHORT $LN16@R_DrawBrus

; 1490 : 		return;

	jmp	$LN1@R_DrawBrus
$LN16@R_DrawBrus:

; 1491 : 
; 1492 : 	if( !VectorIsNull( e->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@R_DrawBrus
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@R_DrawBrus
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@R_DrawBrus
$LN19@R_DrawBrus:

; 1493 : 	{
; 1494 : 		for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawBrus
$LN2@R_DrawBrus:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawBrus:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@R_DrawBrus

; 1495 : 		{
; 1496 : 			mins[i] = e->origin[i] - clmodel->radius;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+3224]
	subss	xmm0, DWORD PTR [edx+108]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _mins$[ebp+eax*4], xmm0

; 1497 : 			maxs[i] = e->origin[i] + clmodel->radius;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+3224]
	addss	xmm0, DWORD PTR [edx+108]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _maxs$[ebp+eax*4], xmm0

; 1498 : 		}

	jmp	SHORT $LN2@R_DrawBrus
$LN3@R_DrawBrus:

; 1499 : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1

; 1500 : 	}

	jmp	$LN18@R_DrawBrus
$LN17@R_DrawBrus:

; 1501 : 	else
; 1502 : 	{
; 1503 : 		VectorAdd( e->origin, clmodel->mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+84]
	movss	DWORD PTR tv162[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv162[ebp]
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 1504 : 		VectorAdd( e->origin, clmodel->maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+96]
	movss	DWORD PTR tv189[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 1505 : 		rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN18@R_DrawBrus:

; 1506 : 	}
; 1507 : 
; 1508 : 	if( R_CullBox( mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_R_CullBox
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@R_DrawBrus

; 1509 : 		return;

	jmp	$LN1@R_DrawBrus
$LN20@R_DrawBrus:

; 1510 : 
; 1511 : 	memset( gl_lms.lightmap_surfaces, 0, sizeof( gl_lms.lightmap_surfaces ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _gl_lms+4104
	call	_memset
	add	esp, 12					; 0000000cH

; 1512 : 	old_rendermode = e->curstate.rendermode;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR _old_rendermode$[ebp], ecx

; 1513 : 	gl_lms.dynamic_surfaces = NULL;

	mov	DWORD PTR _gl_lms+4100, 0

; 1514 : 
; 1515 : 	if( rotated ) R_RotateForEntity( e );

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN21@R_DrawBrus
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_RotateForEntity
	add	esp, 4
	jmp	SHORT $LN22@R_DrawBrus
$LN21@R_DrawBrus:

; 1516 : 	else R_TranslateForEntity( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_TranslateForEntity
	add	esp, 4
$LN22@R_DrawBrus:

; 1517 : 
; 1518 : 	if( CL_IsQuakeCompatible() && FBitSet( clmodel->flags, MODEL_TRANSPARENT ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN23@R_DrawBrus
	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 8
	je	SHORT $LN23@R_DrawBrus

; 1519 : 		e->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+984], 4
$LN23@R_DrawBrus:

; 1520 : 
; 1521 : 	e->visframe = tr.realframecount; // visible

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _tr+83196
	mov	DWORD PTR [eax+3316], ecx

; 1522 : 
; 1523 : 	if( rotated ) Matrix4x4_VectorITransform( RI.objectMatrix, RI.cullorigin, tr.modelorg );

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN24@R_DrawBrus
	push	OFFSET _tr+87596
	push	OFFSET _RI+260
	push	OFFSET _RI+456
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
	jmp	$LN25@R_DrawBrus
$LN24@R_DrawBrus:

; 1524 : 	else VectorSubtract( RI.cullorigin, e->origin, tr.modelorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[ecx+260]
	subss	xmm0, DWORD PTR [edx+eax+3224]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _tr[ecx+87596], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[edx+260]
	subss	xmm0, DWORD PTR [ecx+eax+3224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _tr[edx+87596], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[eax+260]
	subss	xmm0, DWORD PTR [edx+ecx+3224]
	movss	DWORD PTR tv235[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv235[ebp]
	movss	DWORD PTR _tr[eax+87596], xmm0
$LN25@R_DrawBrus:

; 1525 : 
; 1526 : 	// calculate dynamic lighting for bmodel
; 1527 : 	for( k = 0, l = cl_dlights; k < MAX_DLIGHTS; k++, l++ )

	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR _l$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN7@R_DrawBrus
$LN5@R_DrawBrus:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _l$[ebp], ecx
$LN7@R_DrawBrus:
	cmp	DWORD PTR _k$[ebp], 32			; 00000020H
	jge	$LN6@R_DrawBrus

; 1528 : 	{
; 1529 : 		if( l->die < cl.time || !l->radius )

	mov	eax, DWORD PTR _l$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN27@R_DrawBrus
	mov	eax, DWORD PTR _l$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@R_DrawBrus
$LN27@R_DrawBrus:

; 1530 : 			continue;

	jmp	SHORT $LN5@R_DrawBrus
$LN26@R_DrawBrus:

; 1531 : 
; 1532 : 		VectorCopy( l->origin, oldorigin ); // save lightorigin

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _oldorigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _oldorigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _oldorigin$[ebp+ecx], eax

; 1533 : 		Matrix4x4_VectorITransform( RI.objectMatrix, l->origin, origin_l );

	lea	eax, DWORD PTR _origin_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 1534 : 		VectorCopy( origin_l, l->origin ); // move light in bmodel space

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _origin_l$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _origin_l$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _origin_l$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1535 : 		R_MarkLights( l, 1<<k, clmodel->nodes + clmodel->hulls[0].firstclipnode );

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clmodel$[ebp]
	imul	eax, DWORD PTR [edx+ecx+216], 52
	mov	ecx, DWORD PTR _clmodel$[ebp]
	add	eax, DWORD PTR [ecx+164]
	push	eax
	mov	edx, 1
	mov	ecx, DWORD PTR _k$[ebp]
	shl	edx, cl
	push	edx
	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_R_MarkLights
	add	esp, 12					; 0000000cH

; 1536 : 		VectorCopy( oldorigin, l->origin ); // restore lightorigin

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _oldorigin$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR _oldorigin$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _oldorigin$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1537 : 	}

	jmp	$LN5@R_DrawBrus
$LN6@R_DrawBrus:

; 1538 : 
; 1539 : 	// setup the rendermode
; 1540 : 	R_SetRenderMode( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_SetRenderMode
	add	esp, 4

; 1541 : 	GL_SetupFogColorForSurfaces ();

	call	_GL_SetupFogColorForSurfaces

; 1542 : 
; 1543 : 	if( e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN28@R_DrawBrus

; 1544 : 		R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4
$LN28@R_DrawBrus:

; 1545 : 
; 1546 : 	psurf = &clmodel->surfaces[clmodel->firstmodelsurface];

	mov	eax, DWORD PTR _clmodel$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _clmodel$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _psurf$[ebp], ecx

; 1547 : 	num_sorted = 0;

	mov	DWORD PTR _num_sorted$[ebp], 0

; 1548 : 
; 1549 : 	for( i = 0; i < clmodel->nummodelsurfaces; i++, psurf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@R_DrawBrus
$LN8@R_DrawBrus:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], ecx
$LN10@R_DrawBrus:
	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	$LN9@R_DrawBrus

; 1550 : 	{
; 1551 : 		if( FBitSet( psurf->flags, SURF_DRAWTURB ) && !CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN31@R_DrawBrus
	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN31@R_DrawBrus

; 1552 : 		{
; 1553 : 			if( psurf->plane->type != PLANE_Z && !FBitSet( e->curstate.effects, EF_WATERSIDES ))

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 2
	je	SHORT $LN30@R_DrawBrus
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 67108864				; 04000000H
	jne	SHORT $LN30@R_DrawBrus

; 1554 : 				continue;

	jmp	SHORT $LN8@R_DrawBrus
$LN30@R_DrawBrus:

; 1555 : 			if( mins[2] + 1.0 >= psurf->plane->dist )

	mov	eax, 4
	shl	eax, 1
	cvtss2sd xmm0, DWORD PTR _mins$[ebp+eax]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	ecx, DWORD PTR _psurf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cvtss2sd xmm1, DWORD PTR [edx+12]
	comisd	xmm0, xmm1
	jb	SHORT $LN31@R_DrawBrus

; 1556 : 				continue;

	jmp	SHORT $LN8@R_DrawBrus
$LN31@R_DrawBrus:

; 1557 : 		}
; 1558 : 
; 1559 : 		cull_type = R_CullSurface( psurf, &RI.frustum, RI.frustum.clipFlags );

	mov	eax, DWORD PTR _RI+176
	push	eax
	push	OFFSET _RI+56
	mov	ecx, DWORD PTR _psurf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cull_type$[ebp], eax

; 1560 : 
; 1561 : 		if( cull_type >= CULL_FRUSTUM )

	cmp	DWORD PTR _cull_type$[ebp], 2
	jl	SHORT $LN32@R_DrawBrus

; 1562 : 			continue;

	jmp	$LN8@R_DrawBrus
$LN32@R_DrawBrus:

; 1563 : 
; 1564 : 		if( cull_type == CULL_BACKSIDE )

	cmp	DWORD PTR _cull_type$[ebp], 1
	jne	SHORT $LN34@R_DrawBrus

; 1565 : 		{
; 1566 : 			if( !FBitSet( psurf->flags, SURF_DRAWTURB ) && !( psurf->pdecals && e->curstate.rendermode == kRenderTransTexture ))

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN34@R_DrawBrus
	mov	eax, DWORD PTR _psurf$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN35@R_DrawBrus
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	je	SHORT $LN34@R_DrawBrus
$LN35@R_DrawBrus:

; 1567 : 				continue;

	jmp	$LN8@R_DrawBrus
$LN34@R_DrawBrus:

; 1568 : 		}
; 1569 : 
; 1570 : 		if( num_sorted < world.max_surfaces )

	mov	eax, DWORD PTR _num_sorted$[ebp]
	cmp	eax, DWORD PTR _world+2576
	jge	SHORT $LN36@R_DrawBrus

; 1571 : 		{
; 1572 : 			world.draw_surfaces[num_sorted].surf = psurf;

	mov	eax, DWORD PTR _num_sorted$[ebp]
	mov	ecx, DWORD PTR _world+2572
	mov	edx, DWORD PTR _psurf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1573 : 			world.draw_surfaces[num_sorted].cull = cull_type;

	mov	eax, DWORD PTR _num_sorted$[ebp]
	mov	ecx, DWORD PTR _world+2572
	mov	edx, DWORD PTR _cull_type$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 1574 : 			num_sorted++;

	mov	eax, DWORD PTR _num_sorted$[ebp]
	add	eax, 1
	mov	DWORD PTR _num_sorted$[ebp], eax
$LN36@R_DrawBrus:

; 1575 : 		}
; 1576 : 	}

	jmp	$LN8@R_DrawBrus
$LN9@R_DrawBrus:

; 1577 : 
; 1578 : 	// sort faces if needs
; 1579 : 	if( !FBitSet( clmodel->flags, MODEL_LIQUID ) && e->curstate.rendermode == kRenderTransTexture && !CVAR_TO_BOOL( gl_nosort ))

	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	jne	SHORT $LN37@R_DrawBrus
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 2
	jne	SHORT $LN37@R_DrawBrus
	cmp	DWORD PTR _gl_nosort, 0
	je	SHORT $LN41@R_DrawBrus
	mov	eax, DWORD PTR _gl_nosort
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@R_DrawBrus
	mov	DWORD PTR tv365[ebp], 1
	jmp	SHORT $LN42@R_DrawBrus
$LN41@R_DrawBrus:
	mov	DWORD PTR tv365[ebp], 0
$LN42@R_DrawBrus:
	cmp	DWORD PTR tv365[ebp], 0
	jne	SHORT $LN37@R_DrawBrus

; 1580 : 		qsort( world.draw_surfaces, num_sorted, sizeof( sortedface_t ), R_SurfaceCompare );

	push	OFFSET _R_SurfaceCompare
	push	8
	mov	eax, DWORD PTR _num_sorted$[ebp]
	push	eax
	mov	ecx, DWORD PTR _world+2572
	push	ecx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H
$LN37@R_DrawBrus:

; 1581 : 
; 1582 : 	// draw sorted translucent surfaces
; 1583 : 	for( i = 0; i < num_sorted; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@R_DrawBrus
$LN11@R_DrawBrus:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@R_DrawBrus:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_sorted$[ebp]
	jge	SHORT $LN12@R_DrawBrus

; 1584 : 		R_RenderBrushPoly( world.draw_surfaces[i].surf, world.draw_surfaces[i].cull );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _world+2572
	mov	edx, DWORD PTR [ecx+eax*8+4]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _world+2572
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_R_RenderBrushPoly
	add	esp, 8
	jmp	SHORT $LN11@R_DrawBrus
$LN12@R_DrawBrus:

; 1585 : 
; 1586 : 	if( e->curstate.rendermode == kRenderTransColor )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 1
	jne	SHORT $LN38@R_DrawBrus

; 1587 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN38@R_DrawBrus:

; 1588 : 
; 1589 : 	DrawDecalsBatch();

	call	_DrawDecalsBatch

; 1590 : 	GL_ResetFogColor();

	call	_GL_ResetFogColor

; 1591 : 	R_BlendLightmaps();

	call	_R_BlendLightmaps

; 1592 : 	R_RenderFullbrights();

	call	_R_RenderFullbrights

; 1593 : 	R_RenderDetails();

	call	_R_RenderDetails

; 1594 : 
; 1595 : 	// restore fog here
; 1596 : 	if( e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN39@R_DrawBrus

; 1597 : 		R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN39@R_DrawBrus:

; 1598 : 
; 1599 : 	e->curstate.rendermode = old_rendermode;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _old_rendermode$[ebp]
	mov	DWORD PTR [eax+984], ecx

; 1600 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1601 : 	pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1602 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1603 : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1604 : 	R_DrawModelHull();	// draw before restore

	call	_R_DrawModelHull

; 1605 : 	R_LoadIdentity();	// restore worldmatrix

	call	_R_LoadIdentity
$LN1@R_DrawBrus:

; 1606 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawBrushModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawWaterSurfaces
_TEXT	SEGMENT
_t$ = -12						; size = 4
_s$ = -8						; size = 4
_i$ = -4						; size = 4
_R_DrawWaterSurfaces PROC				; COMDAT

; 1332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1333 : 	int		i;
; 1334 : 	msurface_t	*s;
; 1335 : 	texture_t		*t;
; 1336 : 
; 1337 : 	if( !RI.drawWorld || RI.onlyClientDraw )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN9@R_DrawWate
	cmp	DWORD PTR _RI+12, 0
	je	SHORT $LN8@R_DrawWate
$LN9@R_DrawWate:

; 1338 : 		return;

	jmp	$LN1@R_DrawWate
$LN8@R_DrawWate:

; 1339 : 
; 1340 : 	// non-transparent water is already drawed
; 1341 : 	if( clgame.movevars.wateralpha >= 1.0f )

	movss	xmm0, DWORD PTR _clgame+1180
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN10@R_DrawWate

; 1342 : 		return;

	jmp	$LN1@R_DrawWate
$LN10@R_DrawWate:

; 1343 : 
; 1344 : 	// restore worldmodel
; 1345 : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 1346 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 1347 : 
; 1348 : 	// go back to the world matrix
; 1349 : 	R_LoadIdentity();

	call	_R_LoadIdentity

; 1350 : 
; 1351 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1352 : 	pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 1353 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1354 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1355 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1356 : 	pglColor4f( 1.0f, 1.0f, 1.0f, clgame.movevars.wateralpha );

	push	ecx
	movss	xmm0, DWORD PTR _clgame+1180
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1357 : 
; 1358 : 	for( i = 0; i < cl.worldmodel->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawWate
$LN2@R_DrawWate:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawWate:
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+368]
	jge	SHORT $LN3@R_DrawWate

; 1359 : 	{
; 1360 : 		t = cl.worldmodel->textures[i];

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _t$[ebp], eax

; 1361 : 		if( !t ) continue;

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN11@R_DrawWate
	jmp	SHORT $LN2@R_DrawWate
$LN11@R_DrawWate:

; 1362 : 
; 1363 : 		s = t->texturechain;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _s$[ebp], ecx

; 1364 : 		if( !s ) continue;

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN12@R_DrawWate
	jmp	SHORT $LN2@R_DrawWate
$LN12@R_DrawWate:

; 1365 : 
; 1366 : 		if( !FBitSet( s->flags, SURF_DRAWTURB ))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN13@R_DrawWate

; 1367 : 			continue;

	jmp	SHORT $LN2@R_DrawWate
$LN13@R_DrawWate:

; 1368 : 
; 1369 : 		// set modulate mode explicitly
; 1370 : 		GL_Bind( GL_TEXTURE0, t->gl_texturenum );

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1371 : 
; 1372 : 		for( ; s; s = s->texturechain )

	jmp	SHORT $LN7@R_DrawWate
$LN5@R_DrawWate:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s$[ebp], ecx
$LN7@R_DrawWate:
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN6@R_DrawWate

; 1373 : 			EmitWaterPolys( s, false );

	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_EmitWaterPolys
	add	esp, 8
	jmp	SHORT $LN5@R_DrawWate
$LN6@R_DrawWate:

; 1374 : 			
; 1375 : 		t->texturechain = NULL;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1376 : 	}

	jmp	$LN2@R_DrawWate
$LN3@R_DrawWate:

; 1377 : 
; 1378 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1379 : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1380 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1381 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1382 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@R_DrawWate:

; 1383 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawWaterSurfaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_DrawWorld
_TEXT	SEGMENT
_end$ = -16						; size = 8
_start$ = -8						; size = 8
_R_DrawWorld PROC					; COMDAT

; 1946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1947 : 	double	start, end;
; 1948 : 
; 1949 : 	// paranoia issues: when gl_renderer is "0" we need have something valid for currententity
; 1950 : 	// to prevent crashing until HeadShield drawing.
; 1951 : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 1952 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 1953 : 
; 1954 : 	if( !RI.drawWorld || RI.onlyClientDraw )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_DrawWorl
	cmp	DWORD PTR _RI+12, 0
	je	SHORT $LN2@R_DrawWorl
$LN3@R_DrawWorl:

; 1955 : 		return;

	jmp	$LN1@R_DrawWorl
$LN2@R_DrawWorl:

; 1956 : 
; 1957 : 	VectorCopy( RI.cullorigin, tr.modelorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx

; 1958 : 	memset( gl_lms.lightmap_surfaces, 0, sizeof( gl_lms.lightmap_surfaces ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _gl_lms+4104
	call	_memset
	add	esp, 12					; 0000000cH

; 1959 : 	memset( fullbright_surfaces, 0, sizeof( fullbright_surfaces ));

	push	16384					; 00004000H
	push	0
	push	OFFSET _fullbright_surfaces
	call	_memset
	add	esp, 12					; 0000000cH

; 1960 : 	memset( detail_surfaces, 0, sizeof( detail_surfaces ));

	push	16384					; 00004000H
	push	0
	push	OFFSET _detail_surfaces
	call	_memset
	add	esp, 12					; 0000000cH

; 1961 : 
; 1962 : 	gl_lms.dynamic_surfaces = NULL;

	mov	DWORD PTR _gl_lms+4100, 0

; 1963 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1964 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1965 : 	tr.blend = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+87592, xmm0

; 1966 : 
; 1967 : 	R_ClearSkyBox ();

	call	_R_ClearSkyBox

; 1968 : 
; 1969 : 	start = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _start$[ebp]

; 1970 : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN4@R_DrawWorl

; 1971 : 		R_DrawWorldTopView( cl.worldmodel->nodes, RI.frustum.clipFlags );

	mov	eax, DWORD PTR _RI+176
	push	eax
	mov	ecx, DWORD PTR _cl+4579004
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	_R_DrawWorldTopView
	add	esp, 8
	jmp	SHORT $LN5@R_DrawWorl
$LN4@R_DrawWorl:

; 1972 : 	else R_RecursiveWorldNode( cl.worldmodel->nodes, RI.frustum.clipFlags );

	mov	eax, DWORD PTR _RI+176
	push	eax
	mov	ecx, DWORD PTR _cl+4579004
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	_R_RecursiveWorldNode
	add	esp, 8
$LN5@R_DrawWorl:

; 1973 : 	end = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _end$[ebp]

; 1974 : 
; 1975 : 	r_stats.t_world_node = end - start;

	movsd	xmm0, QWORD PTR _end$[ebp]
	subsd	xmm0, QWORD PTR _start$[ebp]
	movsd	QWORD PTR _r_stats+48, xmm0

; 1976 : 
; 1977 : 	start = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _start$[ebp]

; 1978 : 	R_DrawTextureChains();

	call	_R_DrawTextureChains

; 1979 : 
; 1980 : 	if( !CL_IsDevOverviewMode( ))

	call	_CL_IsDevOverviewMode
	test	eax, eax
	jne	SHORT $LN7@R_DrawWorl

; 1981 : 	{
; 1982 : 		DrawDecalsBatch();

	call	_DrawDecalsBatch

; 1983 : 		GL_ResetFogColor();

	call	_GL_ResetFogColor

; 1984 : 		R_BlendLightmaps();

	call	_R_BlendLightmaps

; 1985 : 		R_RenderFullbrights();

	call	_R_RenderFullbrights

; 1986 : 		R_RenderDetails();

	call	_R_RenderDetails

; 1987 : 
; 1988 : 		if( skychain )

	cmp	DWORD PTR _skychain, 0
	je	SHORT $LN7@R_DrawWorl

; 1989 : 			R_DrawSkyBox();

	call	_R_DrawSkyBox
$LN7@R_DrawWorl:

; 1990 : 	}
; 1991 : 
; 1992 : 	end = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _end$[ebp]

; 1993 : 
; 1994 : 	r_stats.t_world_draw = end - start;

	movsd	xmm0, QWORD PTR _end$[ebp]
	subsd	xmm0, QWORD PTR _start$[ebp]
	movsd	QWORD PTR _r_stats+56, xmm0

; 1995 : 	tr.num_draw_decals = 0;

	mov	DWORD PTR _tr+83180, 0

; 1996 : 	skychain = NULL;

	mov	DWORD PTR _skychain, 0

; 1997 : 
; 1998 : 	R_DrawTriangleOutlines ();

	call	_R_DrawTriangleOutlines

; 1999 : 
; 2000 : 	R_DrawWorldHull();

	call	_R_DrawWorldHull
$LN1@R_DrawWorl:

; 2001 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rsurf.c
;	COMDAT _R_MarkLeaves
_TEXT	SEGMENT
tv202 = -104						; size = 4
tv154 = -104						; size = 4
tv134 = -104						; size = 4
_i$ = -36						; size = 4
_test$ = -32						; size = 12
_node$ = -20						; size = 4
_leaf$ = -16						; size = 4
_force$ = -12						; size = 4
_novis$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_MarkLeaves PROC					; COMDAT

; 2011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2012 : 	qboolean	novis = false;

	mov	DWORD PTR _novis$[ebp], 0

; 2013 : 	qboolean	force = false;

	mov	DWORD PTR _force$[ebp], 0

; 2014 : 	mleaf_t	*leaf = NULL;

	mov	DWORD PTR _leaf$[ebp], 0

; 2015 : 	mnode_t	*node;
; 2016 : 	vec3_t	test;
; 2017 : 	int	i;
; 2018 : 
; 2019 : 	if( !RI.drawWorld ) return;

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN8@R_MarkLeav
	jmp	$LN3@R_MarkLeav
$LN8@R_MarkLeav:

; 2020 : 
; 2021 : 	if( FBitSet( r_novis->flags, FCVAR_CHANGED ) || tr.fResetVis )

	mov	eax, DWORD PTR _r_novis
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN10@R_MarkLeav
	cmp	DWORD PTR _tr+83212, 0
	je	SHORT $LN9@R_MarkLeav
$LN10@R_MarkLeav:

; 2022 : 	{
; 2023 : 		// force recalc viewleaf
; 2024 : 		ClearBits( r_novis->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _r_novis
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _r_novis
	mov	DWORD PTR [edx+8], ecx

; 2025 : 		tr.fResetVis = false;

	mov	DWORD PTR _tr+83212, 0

; 2026 : 		RI.viewleaf = NULL;

	mov	DWORD PTR _RI+180, 0
$LN9@R_MarkLeav:

; 2027 : 	}
; 2028 : 
; 2029 : 	VectorCopy( RI.pvsorigin, test );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+188]
	mov	DWORD PTR _test$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+188]
	mov	DWORD PTR _test$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+188]
	mov	DWORD PTR _test$[ebp+eax], ecx

; 2030 : 
; 2031 : 	if( RI.viewleaf != NULL )

	cmp	DWORD PTR _RI+180, 0
	je	$LN14@R_MarkLeav

; 2032 : 	{
; 2033 : 		// merge two leafs that can be a crossed-line contents
; 2034 : 		if( RI.viewleaf->contents == CONTENTS_EMPTY )

	mov	eax, DWORD PTR _RI+180
	cmp	DWORD PTR [eax], -1
	jne	$LN12@R_MarkLeav

; 2035 : 		{
; 2036 : 			VectorSet( test, RI.pvsorigin[0], RI.pvsorigin[1], RI.pvsorigin[2] - 16.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+188]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _test$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+188]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+188]
	subss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv134[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _test$[ebp+ecx], xmm0

; 2037 : 			leaf = Mod_PointInLeaf( test, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 2038 : 		}

	jmp	$LN13@R_MarkLeav
$LN12@R_MarkLeav:

; 2039 : 		else
; 2040 : 		{
; 2041 : 			VectorSet( test, RI.pvsorigin[0], RI.pvsorigin[1], RI.pvsorigin[2] + 16.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+188]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _test$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+188]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _test$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+188]
	addss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv154[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv154[ebp]
	movss	DWORD PTR _test$[ebp+ecx], xmm0

; 2042 : 			leaf = Mod_PointInLeaf( test, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax
$LN13@R_MarkLeav:

; 2043 : 		}
; 2044 : 
; 2045 : 		if(( leaf->contents != CONTENTS_SOLID ) && ( RI.viewleaf != leaf ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	je	SHORT $LN14@R_MarkLeav
	mov	eax, DWORD PTR _RI+180
	cmp	eax, DWORD PTR _leaf$[ebp]
	je	SHORT $LN14@R_MarkLeav

; 2046 : 			force = true;

	mov	DWORD PTR _force$[ebp], 1
$LN14@R_MarkLeav:

; 2047 : 	}
; 2048 : 
; 2049 : 	if( RI.viewleaf == RI.oldviewleaf && RI.viewleaf != NULL && !force )

	mov	eax, DWORD PTR _RI+180
	cmp	eax, DWORD PTR _RI+184
	jne	SHORT $LN15@R_MarkLeav
	cmp	DWORD PTR _RI+180, 0
	je	SHORT $LN15@R_MarkLeav
	cmp	DWORD PTR _force$[ebp], 0
	jne	SHORT $LN15@R_MarkLeav

; 2050 : 		return;

	jmp	$LN3@R_MarkLeav
$LN15@R_MarkLeav:

; 2051 : 
; 2052 : 	// development aid to let you run around
; 2053 : 	// and see exactly where the pvs ends
; 2054 : 	if( r_lockpvs->value ) return;

	mov	eax, DWORD PTR _r_lockpvs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@R_MarkLeav
	jmp	$LN3@R_MarkLeav
$LN16@R_MarkLeav:

; 2055 : 
; 2056 : 	RI.oldviewleaf = RI.viewleaf;

	mov	eax, DWORD PTR _RI+180
	mov	DWORD PTR _RI+184, eax

; 2057 : 	tr.visframecount++;

	mov	eax, DWORD PTR _tr+83188
	add	eax, 1
	mov	DWORD PTR _tr+83188, eax

; 2058 : 
; 2059 : 	if( r_novis->value || RI.drawOrtho || !RI.viewleaf || !cl.worldmodel->visdata )

	mov	eax, DWORD PTR _r_novis
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@R_MarkLeav
	cmp	DWORD PTR _RI+16, 0
	jne	SHORT $LN18@R_MarkLeav
	cmp	DWORD PTR _RI+180, 0
	je	SHORT $LN18@R_MarkLeav
	mov	eax, DWORD PTR _cl+4579004
	cmp	DWORD PTR [eax+376], 0
	jne	SHORT $LN17@R_MarkLeav
$LN18@R_MarkLeav:

; 2060 : 		novis = true;

	mov	DWORD PTR _novis$[ebp], 1
$LN17@R_MarkLeav:

; 2061 : 
; 2062 : 	Mod_FatPVS( RI.pvsorigin, REFPVS_RADIUS, RI.visbytes, world.visbytes, FBitSet( RI.params, RP_OLDVIEWLEAF ), novis );

	mov	eax, DWORD PTR _novis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI
	and	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _world+2588
	push	edx
	push	OFFSET _RI+776
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+188
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 2063 : 	if( force && !novis ) Mod_FatPVS( test, REFPVS_RADIUS, RI.visbytes, world.visbytes, true, novis );

	cmp	DWORD PTR _force$[ebp], 0
	je	SHORT $LN19@R_MarkLeav
	cmp	DWORD PTR _novis$[ebp], 0
	jne	SHORT $LN19@R_MarkLeav
	mov	eax, DWORD PTR _novis$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _world+2588
	push	ecx
	push	OFFSET _RI+776
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN19@R_MarkLeav:

; 2064 : 
; 2065 : 	for( i = 0; i < cl.worldmodel->numleafs; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_MarkLeav
$LN2@R_MarkLeav:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_MarkLeav:
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	SHORT $LN3@R_MarkLeav

; 2066 : 	{
; 2067 : 		if( CHECKVISBIT( RI.visbytes, i ))

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN23@R_MarkLeav
	mov	eax, DWORD PTR _i$[ebp]
	sar	eax, 3
	movzx	edx, BYTE PTR _RI[eax+776]
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv202[ebp], ecx
	jmp	SHORT $LN24@R_MarkLeav
$LN23@R_MarkLeav:
	mov	DWORD PTR tv202[ebp], 0
$LN24@R_MarkLeav:
	cmp	DWORD PTR tv202[ebp], 0
	je	SHORT $LN6@R_MarkLeav

; 2068 : 		{
; 2069 : 			node = (mnode_t *)&cl.worldmodel->leafs[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	ecx, eax, 60
	mov	edx, DWORD PTR _cl+4579004
	add	ecx, DWORD PTR [edx+140]
	mov	DWORD PTR _node$[ebp], ecx
$LN7@R_MarkLeav:

; 2070 : 			do
; 2071 : 			{
; 2072 : 				if( node->visframe == tr.visframecount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _tr+83188
	jne	SHORT $LN21@R_MarkLeav

; 2073 : 					break;

	jmp	SHORT $LN6@R_MarkLeav
$LN21@R_MarkLeav:

; 2074 : 				node->visframe = tr.visframecount;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _tr+83188
	mov	DWORD PTR [eax+4], ecx

; 2075 : 				node = node->parent;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _node$[ebp], ecx

; 2076 : 			} while( node );

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN7@R_MarkLeav
$LN6@R_MarkLeav:

; 2077 : 		}
; 2078 : 	}

	jmp	$LN2@R_MarkLeav
$LN3@R_MarkLeav:

; 2079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_MarkLeaves ENDP
_TEXT	ENDS
END
