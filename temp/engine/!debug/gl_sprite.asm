; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_sprite.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_sprite_lerping:DWORD
COMM	_r_sprite_lighting:DWORD
COMM	_sprite_name:BYTE:040H
COMM	_group_suffix:BYTE:08H
COMM	_sprite_radius:DWORD
_DATA	ENDS
PUBLIC	_R_SpriteInit
PUBLIC	_Mod_LoadSpriteModel
PUBLIC	_R_GetSpriteFrame
PUBLIC	_R_DrawSpriteModel
PUBLIC	_Mod_LoadMapSprite
PUBLIC	_Mod_UnloadSpriteModel
PUBLIC	_R_GetSpriteFrameInterpolant
PUBLIC	_R_CullSpriteModel
PUBLIC	_R_SpriteOccluded
PUBLIC	??_C@_0CB@OLLAHFAA@enables?5sprite?5animation?5lerpin@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0BB@EJMBDKPM@r_sprite_lerping@		; `string'
PUBLIC	??_C@_0CE@NHCOJABC@enables?5sprite?5lighting?5?$CIblood?5@ ; `string'
PUBLIC	??_C@_0BC@BJEEPELI@r_sprite_lighting@		; `string'
PUBLIC	?__LINE__Var@?0??R_SpriteLoadFrame@@9@9		; `R_SpriteLoadFrame'::`1'::__LINE__Var
PUBLIC	??_C@_0BF@OINMPMLC@?$CDHUD?1?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@ ; `string'
PUBLIC	??_C@_0BB@GADPIMLE@?$CD?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@ ; `string'
PUBLIC	??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??R_SpriteLoadGroup@@9@9		; `R_SpriteLoadGroup'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9	; `Mod_LoadSpriteModel'::`1'::__LINE__Var
PUBLIC	??_C@_0CO@IIMAFKGP@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5id?5?$CI?$CFx?5@ ; `string'
PUBLIC	??_C@_0EA@GOHDLPMA@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ ; `string'
PUBLIC	??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@		; `string'
PUBLIC	??_C@_07PFPMLFBM@?$CDid?4pal@			; `string'
PUBLIC	??_C@_0O@NLIEKAKO@?$CDgradient?4pal@		; `string'
PUBLIC	??_C@_0M@NFDHFNFP@?$CDmasked?4pal@		; `string'
PUBLIC	??_C@_0M@JLBELAFH@?$CDnormal?4pal@		; `string'
PUBLIC	??_C@_0EF@NOOIKKKL@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5number?5@ ; `string'
PUBLIC	??_C@_05MIJNFGED@frame@				; `string'
PUBLIC	??_C@_05MGJOOGAJ@group@				; `string'
PUBLIC	??_C@_05FECBCJJD@angle@				; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadMapSprite@@9@9		; `Mod_LoadMapSprite'::`1'::__LINE__Var
PUBLIC	??_C@_03FGKIIOAN@?$CD?$CFs@			; `string'
PUBLIC	??_C@_0BB@PIGKLKGO@?$CDMAP?1?$CFs_?$CFi?$CFi?4spr@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_UnloadSpriteModel@@9@9	; `Mod_UnloadSpriteModel'::`1'::__LINE__Var
PUBLIC	??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??R_GetSpriteFrame@@9@9		; `R_GetSpriteFrame'::`1'::__LINE__Var
PUBLIC	??_C@_0P@HHNFGLFM@pModel?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0DG@IHGAFOLC@?$FO3Warning?3?$FO7?5R_GetSpriteFrame?3?5@ ; `string'
PUBLIC	??_C@_0EB@CCJBOCEJ@?$FO3Warning?3?$FO7?5R_GetSpriteFrameIn@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f7ff60a
PUBLIC	__real@3f800000
PUBLIC	__real@4026000000000000
PUBLIC	__real@41000000
PUBLIC	__real@42340000
PUBLIC	__real@43b40000
PUBLIC	__real@46947000
PUBLIC	__real@bf7ff60a
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_Process:PROC
EXTRN	_Image_SetForceFlags:PROC
EXTRN	_Image_ClearForceFlags:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_sqrt:PROC
EXTRN	_SinCos:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_CL_VisTraceLine:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_CullModel:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_LightPoint:PROC
EXTRN	_R_AllowFog:PROC
EXTRN	_TriWorldToScreen:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_cl:BYTE
EXTRN	_r_temppool:DWORD
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_r_traceglow:DWORD
EXTRN	_r_lightmap:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_r_texFlags DD	01H DUP (?)
_sprite_version DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf7ff60a
CONST	SEGMENT
__real@bf7ff60a DD 0bf7ff60ar			; -0.999848
CONST	ENDS
;	COMDAT __real@46947000
CONST	SEGMENT
__real@46947000 DD 046947000r			; 19000
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@4026000000000000
CONST	SEGMENT
__real@4026000000000000 DQ 04026000000000000r	; 11
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff60a
CONST	SEGMENT
__real@3f7ff60a DD 03f7ff60ar			; 0.999848
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0EB@CCJBOCEJ@?$FO3Warning?3?$FO7?5R_GetSpriteFrameIn@
CONST	SEGMENT
??_C@_0EB@CCJBOCEJ@?$FO3Warning?3?$FO7?5R_GetSpriteFrameIn@ DB '^3Warning'
	DB	':^7 R_GetSpriteFrameInterpolant: no such frame %d (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IHGAFOLC@?$FO3Warning?3?$FO7?5R_GetSpriteFrame?3?5@
CONST	SEGMENT
??_C@_0DG@IHGAFOLC@?$FO3Warning?3?$FO7?5R_GetSpriteFrame?3?5@ DB '^3Warni'
	DB	'ng:^7 R_GetSpriteFrame: no such frame %d (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHNFGLFM@pModel?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@HHNFGLFM@pModel?5?$CB?$DN?5NULL@ DB 'pModel != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_GetSpriteFrame@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_GetSpriteFrame@@9@9 DD 01e0H		; `R_GetSpriteFrame'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@ DB 'mod != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_UnloadSpriteModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_UnloadSpriteModel@@9@9 DD 01adH	; `Mod_UnloadSpriteModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@PIGKLKGO@?$CDMAP?1?$CFs_?$CFi?$CFi?4spr@
CONST	SEGMENT
??_C@_0BB@PIGKLKGO@?$CDMAP?1?$CFs_?$CFi?$CFi?4spr@ DB '#MAP/%s_%i%i.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FGKIIOAN@?$CD?$CFs@
CONST	SEGMENT
??_C@_03FGKIIOAN@?$CD?$CFs@ DB '#%s', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadMapSprite@@9@9 DD 0135H	; `Mod_LoadMapSprite'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05FECBCJJD@angle@
CONST	SEGMENT
??_C@_05FECBCJJD@angle@ DB 'angle', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group@ DB 'group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIJNFGED@frame@
CONST	SEGMENT
??_C@_05MIJNFGED@frame@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NOOIKKKL@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5number?5@
CONST	SEGMENT
??_C@_0EF@NOOIKKKL@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5number?5@ DB '^1'
	DB	'Error:^7 %s has wrong number of palette colors %i (should be '
	DB	'256)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JLBELAFH@?$CDnormal?4pal@
CONST	SEGMENT
??_C@_0M@JLBELAFH@?$CDnormal?4pal@ DB '#normal.pal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFDHFNFP@?$CDmasked?4pal@
CONST	SEGMENT
??_C@_0M@NFDHFNFP@?$CDmasked?4pal@ DB '#masked.pal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLIEKAKO@?$CDgradient?4pal@
CONST	SEGMENT
??_C@_0O@NLIEKAKO@?$CDgradient?4pal@ DB '#gradient.pal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFPMLFBM@?$CDid?4pal@
CONST	SEGMENT
??_C@_07PFPMLFBM@?$CDid?4pal@ DB '#id.pal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
CONST	SEGMENT
??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@ DB '^2%s^7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GOHDLPMA@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
CONST	SEGMENT
??_C@_0EA@GOHDLPMA@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ DB '^1E'
	DB	'rror:^7 %s has wrong version number (%i should be %i or %i)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IIMAFKGP@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5id?5?$CI?$CFx?5@
CONST	SEGMENT
??_C@_0CO@IIMAFKGP@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5id?5?$CI?$CFx?5@ DB '^'
	DB	'1Error:^7 %s has wrong id (%x should be %x)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9 DD 094H	; `Mod_LoadSpriteModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??R_SpriteLoadGroup@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_SpriteLoadGroup@@9@9 DD 066H		; `R_SpriteLoadGroup'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_sprite.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GADPIMLE@?$CD?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@
CONST	SEGMENT
??_C@_0BB@GADPIMLE@?$CD?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@ DB '#%s(%s:%i'
	DB	'%i).spr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OINMPMLC@?$CDHUD?1?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@
CONST	SEGMENT
??_C@_0BF@OINMPMLC@?$CDHUD?1?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@ DB '#HUD'
	DB	'/%s(%s:%i%i).spr', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_SpriteLoadFrame@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_SpriteLoadFrame@@9@9 DD 039H		; `R_SpriteLoadFrame'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@BJEEPELI@r_sprite_lighting@
CONST	SEGMENT
??_C@_0BC@BJEEPELI@r_sprite_lighting@ DB 'r_sprite_lighting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NHCOJABC@enables?5sprite?5lighting?5?$CIblood?5@
CONST	SEGMENT
??_C@_0CE@NHCOJABC@enables?5sprite?5lighting?5?$CIblood?5@ DB 'enables sp'
	DB	'rite lighting (blood etc)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EJMBDKPM@r_sprite_lerping@
CONST	SEGMENT
??_C@_0BB@EJMBDKPM@r_sprite_lerping@ DB 'r_sprite_lerping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OLLAHFAA@enables?5sprite?5animation?5lerpin@
CONST	SEGMENT
??_C@_0CB@OLLAHFAA@enables?5sprite?5animation?5lerpin@ DB 'enables sprite'
	DB	' animation lerping', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0695H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01a4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0224H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02afH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0202H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	071dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01072H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteAllowLerping
_TEXT	SEGMENT
_e$ = 8							; size = 4
_psprite$ = 12						; size = 4
_R_SpriteAllowLerping PROC				; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 876  : 	if( !r_sprite_lerping->value )

	mov	eax, DWORD PTR _r_sprite_lerping
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_SpriteAl

; 877  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteAl
$LN2@R_SpriteAl:

; 878  : 
; 879  : 	if( psprite->numframes <= 1 )

	mov	eax, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [eax+12], 1
	jg	SHORT $LN3@R_SpriteAl

; 880  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteAl
$LN3@R_SpriteAl:

; 881  : 
; 882  : 	if( psprite->texFormat != SPR_ADDITIVE )

	mov	eax, DWORD PTR _psprite$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	cmp	ecx, 1
	je	SHORT $LN4@R_SpriteAl

; 883  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteAl
$LN4@R_SpriteAl:

; 884  : 
; 885  : 	if( e->curstate.rendermode == kRenderNormal || e->curstate.rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN6@R_SpriteAl
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 4
	jne	SHORT $LN5@R_SpriteAl
$LN6@R_SpriteAl:

; 886  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteAl
$LN5@R_SpriteAl:

; 887  : 
; 888  : 	return true;

	mov	eax, 1
$LN1@R_SpriteAl:

; 889  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteAllowLerping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteHasLightmap
_TEXT	SEGMENT
tv73 = -68						; size = 4
_e$ = 8							; size = 4
_texFormat$ = 12					; size = 4
_R_SpriteHasLightmap PROC				; COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 844  : 	if( !r_sprite_lighting->value )

	mov	eax, DWORD PTR _r_sprite_lighting
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@R_SpriteHa

; 845  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteHa
$LN4@R_SpriteHa:

; 846  : 	
; 847  : 	if( texFormat != SPR_ALPHTEST )

	cmp	DWORD PTR _texFormat$[ebp], 3
	je	SHORT $LN5@R_SpriteHa

; 848  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteHa
$LN5@R_SpriteHa:

; 849  : 
; 850  : 	if( e->curstate.effects & EF_FULLBRIGHT )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 134217728				; 08000000H
	je	SHORT $LN6@R_SpriteHa

; 851  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteHa
$LN6@R_SpriteHa:

; 852  : 
; 853  : 	if( e->curstate.renderamt <= 127 )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+988], 127		; 0000007fH
	jg	SHORT $LN7@R_SpriteHa

; 854  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteHa
$LN7@R_SpriteHa:

; 855  : 
; 856  : 	switch( e->curstate.rendermode )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN8@R_SpriteHa
	cmp	DWORD PTR tv73[ebp], 2
	je	SHORT $LN8@R_SpriteHa
	cmp	DWORD PTR tv73[ebp], 4
	je	SHORT $LN8@R_SpriteHa
	jmp	SHORT $LN11@R_SpriteHa
$LN8@R_SpriteHa:

; 857  : 	{
; 858  : 	case kRenderNormal:
; 859  : 	case kRenderTransAlpha:
; 860  : 	case kRenderTransTexture:
; 861  : 		break;

	jmp	SHORT $LN2@R_SpriteHa
$LN11@R_SpriteHa:

; 862  : 	default:
; 863  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_SpriteHa
$LN2@R_SpriteHa:

; 864  : 	}
; 865  : 
; 866  : 	return true;

	mov	eax, 1
$LN1@R_SpriteHa:

; 867  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteHasLightmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_DrawSpriteQuad
_TEXT	SEGMENT
tv372 = -84						; size = 4
tv339 = -84						; size = 4
tv303 = -84						; size = 4
tv270 = -84						; size = 4
tv234 = -84						; size = 4
tv201 = -84						; size = 4
tv165 = -84						; size = 4
tv132 = -84						; size = 4
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_org$ = 12						; size = 4
_v_right$ = 16						; size = 4
_v_up$ = 20						; size = 4
_scale$ = 24						; size = 4
_R_DrawSpriteQuad PROC					; COMDAT

; 817  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 818  : 	vec3_t	point;
; 819  : 
; 820  : 	r_stats.c_sprite_polys++;

	mov	eax, DWORD PTR _r_stats+8
	add	eax, 1
	mov	DWORD PTR _r_stats+8, eax

; 821  : 
; 822  : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 823  : 		pglTexCoord2f( 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 824  : 		VectorMA( org, frame->down * scale, v_up, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv132[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 825  : 		VectorMA( point, frame->left * scale, v_right, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _point$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _point$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	movss	xmm1, DWORD PTR _point$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv165[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 826  : 		pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 827  : 		pglTexCoord2f( 0.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 828  : 		VectorMA( org, frame->up * scale, v_up, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv201[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 829  : 		VectorMA( point, frame->left * scale, v_right, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _point$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _point$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	movss	xmm1, DWORD PTR _point$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv234[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv234[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 830  : 		pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 831  : 		pglTexCoord2f( 1.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 832  : 		VectorMA( org, frame->up * scale, v_up, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv270[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv270[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 833  : 		VectorMA( point, frame->right * scale, v_right, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _point$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _point$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	movss	xmm1, DWORD PTR _point$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv303[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv303[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 834  : 		pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 835  :  	        	pglTexCoord2f( 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 836  : 		VectorMA( org, frame->down * scale, v_up, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	eax, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_up$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv339[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv339[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 837  : 		VectorMA( point, frame->right * scale, v_right, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [edx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _point$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _point$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	ecx, DWORD PTR _v_right$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx]
	movss	xmm1, DWORD PTR _point$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv372[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv372[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 838  : 		pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 839  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 840  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawSpriteQuad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteOccluded
_TEXT	SEGMENT
_v$1 = -20						; size = 12
_blend$2 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_origin$ = 12						; size = 4
_pscale$ = 16						; size = 4
_R_SpriteOccluded PROC					; COMDAT

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 776  : 	if( e->curstate.rendermode == kRenderGlow )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 3
	jne	$LN2@R_SpriteOc

; 777  : 	{
; 778  : 		float	blend;
; 779  : 		vec3_t	v;
; 780  : 
; 781  : 		// don't reflect this entity in mirrors
; 782  : 		if (e->curstate.effects & EF_NOREFLECT && RI.params & RP_MIRRORVIEW)

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 16777216				; 01000000H
	je	SHORT $LN4@R_SpriteOc
	mov	eax, DWORD PTR _RI
	and	eax, 1
	je	SHORT $LN4@R_SpriteOc

; 783  : 			return true;

	mov	eax, 1
	jmp	$LN1@R_SpriteOc
$LN4@R_SpriteOc:

; 784  : 
; 785  : 		// draw only in mirrors
; 786  : 		if (e->curstate.effects & EF_REFLECTONLY && !(RI.params & RP_MIRRORVIEW))

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 33554432				; 02000000H
	je	SHORT $LN5@R_SpriteOc
	mov	eax, DWORD PTR _RI
	and	eax, 1
	jne	SHORT $LN5@R_SpriteOc

; 787  : 			return true;

	mov	eax, 1
	jmp	$LN1@R_SpriteOc
$LN5@R_SpriteOc:

; 788  : 
; 789  : 		TriWorldToScreen( origin, v );

	lea	eax, DWORD PTR _v$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_TriWorldToScreen
	add	esp, 8

; 790  : 
; 791  : 		if( v[0] < RI.viewport[0] || v[0] > RI.viewport[0] + RI.viewport[2] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	cvtsi2ss xmm0, DWORD PTR _RI[eax+40]
	comiss	xmm0, DWORD PTR _v$1[ebp+ecx]
	ja	SHORT $LN7@R_SpriteOc
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[eax+40]
	add	eax, DWORD PTR _RI[edx+40]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _v$1[ebp+ecx]
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@R_SpriteOc
$LN7@R_SpriteOc:

; 792  : 			return true; // do scissor

	mov	eax, 1
	jmp	$LN1@R_SpriteOc
$LN6@R_SpriteOc:

; 793  : 		if( v[1] < RI.viewport[1] || v[1] > RI.viewport[1] + RI.viewport[3] )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _RI[ecx+40]
	comiss	xmm0, DWORD PTR _v$1[ebp+eax]
	ja	SHORT $LN9@R_SpriteOc
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	edx, edx, 3
	mov	ecx, DWORD PTR _RI[ecx+40]
	add	ecx, DWORD PTR _RI[edx+40]
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _v$1[ebp+eax]
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@R_SpriteOc
$LN9@R_SpriteOc:

; 794  : 			return true; // do scissor

	mov	eax, 1
	jmp	SHORT $LN1@R_SpriteOc
$LN8@R_SpriteOc:

; 795  : 
; 796  : 		blend = R_SpriteGlowBlend( origin, e->curstate.rendermode, e->curstate.renderfx, pscale );

	mov	eax, DWORD PTR _pscale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+996]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	call	_R_SpriteGlowBlend
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _blend$2[ebp]

; 797  : 		tr.blend *= blend;

	movss	xmm0, DWORD PTR _tr+87592
	mulss	xmm0, DWORD PTR _blend$2[ebp]
	movss	DWORD PTR _tr+87592, xmm0

; 798  : 
; 799  : 		if( blend <= 0.01f )

	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, DWORD PTR _blend$2[ebp]
	jb	SHORT $LN10@R_SpriteOc

; 800  : 			return true; // faded

	mov	eax, 1
	jmp	SHORT $LN1@R_SpriteOc
$LN10@R_SpriteOc:

; 801  : 	}

	jmp	SHORT $LN11@R_SpriteOc
$LN2@R_SpriteOc:

; 802  : 	else
; 803  : 	{
; 804  : 		if( R_CullSpriteModel( e, origin ))

	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_CullSpriteModel
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@R_SpriteOc

; 805  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_SpriteOc
$LN11@R_SpriteOc:

; 806  : 	}
; 807  : 
; 808  : 	return false;	

	xor	eax, eax
$LN1@R_SpriteOc:

; 809  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteOccluded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteGlowBlend
_TEXT	SEGMENT
tv161 = -100						; size = 4
tv160 = -96						; size = 4
tv145 = -96						; size = 4
tv84 = -96						; size = 4
_tr$ = -28						; size = 4
_glowDist$ = -24					; size = 12
_brightness$ = -12					; size = 4
_dist$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_rendermode$ = 12					; size = 4
_renderfx$ = 16						; size = 4
_pscale$ = 20						; size = 4
_R_SpriteGlowBlend PROC					; COMDAT

; 741  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 742  : 	float	dist, brightness;
; 743  : 	vec3_t	glowDist;
; 744  : 	pmtrace_t	*tr;
; 745  : 
; 746  : 	VectorSubtract( origin, RI.vieworg, glowDist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _RI[eax+200]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _glowDist$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _RI[eax+200]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _glowDist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	movss	DWORD PTR tv84[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _glowDist$[ebp+eax], xmm0

; 747  : 	dist = VectorLength( glowDist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _glowDist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _glowDist$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _glowDist$[ebp+ecx]
	mulss	xmm1, DWORD PTR _glowDist$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _glowDist$[ebp+eax]
	mulss	xmm1, DWORD PTR _glowDist$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 748  : 
; 749  : 	if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN3@R_SpriteGl

; 750  : 	{
; 751  : 		tr = CL_VisTraceLine( RI.vieworg, origin, r_traceglow->value ? PM_GLASS_IGNORE : (PM_GLASS_IGNORE|PM_STUDIO_IGNORE));

	mov	eax, DWORD PTR _r_traceglow
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_SpriteGl
	mov	DWORD PTR tv145[ebp], 4
	jmp	SHORT $LN7@R_SpriteGl
$LN6@R_SpriteGl:
	mov	DWORD PTR tv145[ebp], 5
$LN7@R_SpriteGl:
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	mov	edx, DWORD PTR _origin$[ebp]
	push	edx
	push	OFFSET _RI+200
	call	_CL_VisTraceLine
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tr$[ebp], eax

; 752  : 
; 753  : 		if(( 1.0f - tr->fraction ) * dist > 8.0f )

	mov	eax, DWORD PTR _tr$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@41000000
	jbe	SHORT $LN3@R_SpriteGl

; 754  : 			return 0.0f;

	fldz
	jmp	$LN1@R_SpriteGl
$LN3@R_SpriteGl:

; 755  : 	}
; 756  : 
; 757  : 	if( renderfx == kRenderFxNoDissipation )

	cmp	DWORD PTR _renderfx$[ebp], 14		; 0000000eH
	jne	SHORT $LN4@R_SpriteGl

; 758  : 		return 1.0f;

	fld1
	jmp	$LN1@R_SpriteGl
$LN4@R_SpriteGl:

; 759  : 
; 760  : 	brightness = GLARE_FALLOFF / ( dist * dist );

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	movss	xmm1, DWORD PTR __real@46947000
	divss	xmm1, xmm0
	movss	DWORD PTR _brightness$[ebp], xmm1

; 761  : 	brightness = bound( 0.05f, brightness, 1.0f );

	movss	xmm0, DWORD PTR _brightness$[ebp]
	comiss	xmm0, DWORD PTR __real@3d4ccccd
	jb	SHORT $LN10@R_SpriteGl
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _brightness$[ebp]
	jbe	SHORT $LN8@R_SpriteGl
	movss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR tv160[ebp], xmm0
	jmp	SHORT $LN9@R_SpriteGl
$LN8@R_SpriteGl:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv160[ebp], xmm0
$LN9@R_SpriteGl:
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR tv161[ebp], xmm0
	jmp	SHORT $LN11@R_SpriteGl
$LN10@R_SpriteGl:
	movss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR tv161[ebp], xmm0
$LN11@R_SpriteGl:
	movss	xmm0, DWORD PTR tv161[ebp]
	movss	DWORD PTR _brightness$[ebp], xmm0

; 762  : 	*pscale *= dist * ( 1.0f / 200.0f );

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3ba3d70a
	mov	eax, DWORD PTR _pscale$[ebp]
	mulss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pscale$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 763  : 
; 764  : 	return brightness;

	fld	DWORD PTR _brightness$[ebp]
$LN1@R_SpriteGl:

; 765  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteGlowBlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_CullSpriteModel
_TEXT	SEGMENT
tv188 = -100						; size = 4
tv167 = -100						; size = 4
tv143 = -100						; size = 4
tv90 = -100						; size = 4
_scale$ = -32						; size = 4
_sprite_maxs$ = -28					; size = 12
_sprite_mins$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_origin$ = 12						; size = 4
_R_CullSpriteModel PROC					; COMDAT

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 712  : 	vec3_t	sprite_mins, sprite_maxs;
; 713  : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 714  : 
; 715  : 	if( !e->model->cache.data )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+388], 0
	jne	SHORT $LN2@R_CullSpri

; 716  : 		return true;

	mov	eax, 1
	jmp	$LN1@R_CullSpri
$LN2@R_CullSpri:

; 717  : 
; 718  : 	if( e->curstate.scale > 0.0f )

	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_CullSpri

; 719  : 		scale = e->curstate.scale;

	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@R_CullSpri:

; 720  : 
; 721  : 	// scale original bbox (no rotation for sprites)
; 722  : 	VectorScale( e->model->mins, scale, sprite_mins );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+84]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _sprite_mins$[ebp+edx], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx+84]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _sprite_mins$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+3300]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax+84]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _sprite_mins$[ebp+ecx], xmm0

; 723  : 	VectorScale( e->model->maxs, scale, sprite_maxs );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+96]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _sprite_maxs$[ebp+edx], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx+96]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _sprite_maxs$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+3300]
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [edx+eax+96]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _sprite_maxs$[ebp+ecx], xmm0

; 724  : 
; 725  : 	sprite_radius = RadiusFromBounds( sprite_mins, sprite_maxs );

	lea	eax, DWORD PTR _sprite_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sprite_mins$[ebp]
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	fstp	DWORD PTR _sprite_radius

; 726  : 
; 727  : 	VectorAdd( sprite_mins, origin, sprite_mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_mins$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _sprite_mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_mins$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _sprite_mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_mins$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv167[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _sprite_mins$[ebp+eax], xmm0

; 728  : 	VectorAdd( sprite_maxs, origin, sprite_maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_maxs$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _sprite_maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_maxs$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _sprite_maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR _sprite_maxs$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv188[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _sprite_maxs$[ebp+eax], xmm0

; 729  : 
; 730  : 	return R_CullModel( e, sprite_mins, sprite_maxs );

	lea	eax, DWORD PTR _sprite_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sprite_mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_CullModel
	add	esp, 12					; 0000000cH
$LN1@R_CullSpri:

; 731  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CullSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_GetSpriteFrameInterpolant
_TEXT	SEGMENT
tv299 = -132						; size = 4
tv71 = -132						; size = 4
_angleframe$1 = -64					; size = 4
_yaw$2 = -60						; size = 4
_m_fDoInterp$ = -56					; size = 4
_targettime$ = -52					; size = 4
_fullinterval$ = -48					; size = 4
_pintervals$ = -44					; size = 4
_jinterval$ = -40					; size = 4
_jtime$ = -36						; size = 4
_time$ = -32						; size = 4
_lerpFrac$ = -28					; size = 4
_frame$ = -24						; size = 4
_numframes$ = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_pspritegroup$ = -8					; size = 4
_psprite$ = -4						; size = 4
_ent$ = 8						; size = 4
_oldframe$ = 12						; size = 4
_curframe$ = 16						; size = 4
_R_GetSpriteFrameInterpolant PROC			; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 546  : 	msprite_t		*psprite;
; 547  : 	mspritegroup_t	*pspritegroup;
; 548  : 	int		i, j, numframes, frame;
; 549  : 	float		lerpFrac, time, jtime, jinterval;
; 550  : 	float		*pintervals, fullinterval, targettime;
; 551  : 	int		m_fDoInterp;
; 552  : 
; 553  : 	psprite = ent->model->cache.data;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR _psprite$[ebp], edx

; 554  : 	frame = (int)ent->curstate.frame;

	mov	eax, DWORD PTR _ent$[ebp]
	cvttss2si ecx, DWORD PTR [eax+960]
	mov	DWORD PTR _frame$[ebp], ecx

; 555  : 	lerpFrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 556  : 
; 557  : 	// misc info
; 558  : 	m_fDoInterp = (ent->curstate.effects & EF_NOINTERP) ? false : true;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 32					; 00000020H
	je	SHORT $LN40@R_GetSprit
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN41@R_GetSprit
$LN40@R_GetSprit:
	mov	DWORD PTR tv71[ebp], 1
$LN41@R_GetSprit:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _m_fDoInterp$[ebp], edx

; 559  : 
; 560  : 	if( frame < 0 )

	cmp	DWORD PTR _frame$[ebp], 0
	jge	SHORT $LN5@R_GetSprit

; 561  : 	{
; 562  : 		frame = 0;

	mov	DWORD PTR _frame$[ebp], 0

; 563  : 	}          

	jmp	SHORT $LN7@R_GetSprit
$LN5@R_GetSprit:

; 564  : 	else if( frame >= psprite->numframes )

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jl	SHORT $LN7@R_GetSprit

; 565  : 	{
; 566  : 		Con_Reportf( S_WARN "R_GetSpriteFrameInterpolant: no such frame %d (%s)\n", frame, ent->model->name );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	mov	edx, DWORD PTR _frame$[ebp]
	push	edx
	push	OFFSET ??_C@_0EB@CCJBOCEJ@?$FO3Warning?3?$FO7?5R_GetSpriteFrameIn@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 567  : 		frame = psprite->numframes - 1;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR _frame$[ebp], ecx
$LN7@R_GetSprit:

; 568  : 	}
; 569  : 
; 570  : 	if( psprite->frames[frame].type == FRAME_SINGLE )

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 0
	jne	$LN8@R_GetSprit

; 571  : 	{
; 572  : 		if( m_fDoInterp )

	cmp	DWORD PTR _m_fDoInterp$[ebp], 0
	je	$LN10@R_GetSprit

; 573  : 		{
; 574  : 			if( ent->latched.prevblending[0] >= psprite->numframes || psprite->frames[ent->latched.prevblending[0]].type != FRAME_SINGLE )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jge	SHORT $LN13@R_GetSprit
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 0
	je	SHORT $LN12@R_GetSprit
$LN13@R_GetSprit:

; 575  : 			{
; 576  : 				// this can be happens when rendering switched between single and angled frames
; 577  : 				// or change model on replace delta-entity
; 578  : 				ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 579  : 				ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 580  : 				lerpFrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN12@R_GetSprit:

; 581  : 			}
; 582  :                               
; 583  : 			if( ent->latched.sequencetime < cl.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3172]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	$LN14@R_GetSprit

; 584  : 			{
; 585  : 				if( frame != ent->latched.prevblending[1] )

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+3216]
	cmp	DWORD PTR _frame$[ebp], edx
	je	SHORT $LN16@R_GetSprit

; 586  : 				{
; 587  : 					ent->latched.prevblending[0] = ent->latched.prevblending[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR [esi+eax+3216]
	mov	BYTE PTR [ecx+edx+3216], al

; 588  : 					ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl

; 589  : 					ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 590  : 					lerpFrac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 591  : 				}

	jmp	SHORT $LN17@R_GetSprit
$LN16@R_GetSprit:

; 592  : 				else lerpFrac = (cl.time - ent->latched.sequencetime) * 11.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3172]
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@4026000000000000
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN17@R_GetSprit:

; 593  : 			}

	jmp	SHORT $LN15@R_GetSprit
$LN14@R_GetSprit:

; 594  : 			else
; 595  : 			{
; 596  : 				ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 597  : 				ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 598  : 				lerpFrac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN15@R_GetSprit:

; 599  : 			}
; 600  : 		}

	jmp	SHORT $LN11@R_GetSprit
$LN10@R_GetSprit:

; 601  : 		else
; 602  : 		{
; 603  : 			ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 604  : 			lerpFrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN11@R_GetSprit:

; 605  : 		}
; 606  : 
; 607  : 		if( ent->latched.prevblending[0] >= psprite->numframes )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jl	SHORT $LN18@R_GetSprit

; 608  : 		{
; 609  : 			// reset interpolation on change model
; 610  : 			ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 611  : 			ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 612  : 			lerpFrac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN18@R_GetSprit:

; 613  : 		}
; 614  : 
; 615  : 		// get the interpolated frames
; 616  : 		if( oldframe ) *oldframe = psprite->frames[ent->latched.prevblending[0]].frameptr;

	cmp	DWORD PTR _oldframe$[ebp], 0
	je	SHORT $LN19@R_GetSprit
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _oldframe$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	eax, DWORD PTR [edx+eax*8+32]
	mov	DWORD PTR [ecx], eax
$LN19@R_GetSprit:

; 617  : 		if( curframe ) *curframe = psprite->frames[frame].frameptr;

	cmp	DWORD PTR _curframe$[ebp], 0
	je	SHORT $LN20@R_GetSprit
	mov	eax, DWORD PTR _curframe$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8+32]
	mov	DWORD PTR [eax], ecx
$LN20@R_GetSprit:

; 618  : 	}

	jmp	$LN38@R_GetSprit
$LN8@R_GetSprit:

; 619  : 	else if( psprite->frames[frame].type == FRAME_GROUP ) 

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 1
	jne	$LN21@R_GetSprit

; 620  : 	{
; 621  : 		pspritegroup = (mspritegroup_t *)psprite->frames[frame].frameptr;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 622  : 		pintervals = pspritegroup->intervals;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pintervals$[ebp], ecx

; 623  : 		numframes = pspritegroup->numframes;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _numframes$[ebp], ecx

; 624  : 		fullinterval = pintervals[numframes-1];

	mov	eax, DWORD PTR _numframes$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	movss	DWORD PTR _fullinterval$[ebp], xmm0

; 625  : 		jinterval = pintervals[1] - pintervals[0];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pintervals$[ebp]
	mov	esi, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [esi+edx]
	movss	DWORD PTR _jinterval$[ebp], xmm0

; 626  : 		time = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	movss	DWORD PTR _time$[ebp], xmm0

; 627  : 		jtime = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _jtime$[ebp], xmm0

; 628  : 
; 629  : 		// when loading in Mod_LoadSpriteGroup, we guaranteed all interval values
; 630  : 		// are positive, so we don't have to worry about division by zero
; 631  : 		targettime = time - ((int)(time / fullinterval)) * fullinterval;

	movss	xmm0, DWORD PTR _time$[ebp]
	divss	xmm0, DWORD PTR _fullinterval$[ebp]
	cvttss2si eax, xmm0
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _fullinterval$[ebp]
	movss	xmm1, DWORD PTR _time$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _targettime$[ebp], xmm1

; 632  : 
; 633  : 		// LordHavoc: since I can't measure the time properly when it loops from numframes - 1 to 0,
; 634  : 		// i instead measure the time of the first frame, hoping it is consistent
; 635  : 		for( i = 0, j = numframes - 1; i < (numframes - 1); i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _numframes$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN4@R_GetSprit
$LN2@R_GetSprit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_GetSprit:
	mov	eax, DWORD PTR _numframes$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@R_GetSprit

; 636  : 		{
; 637  : 			if( pintervals[i] > targettime )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _targettime$[ebp]
	jbe	SHORT $LN23@R_GetSprit

; 638  : 				break;

	jmp	SHORT $LN3@R_GetSprit
$LN23@R_GetSprit:

; 639  : 			j = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax

; 640  : 			jinterval = pintervals[i] - jtime;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR _jtime$[ebp]
	movss	DWORD PTR _jinterval$[ebp], xmm0

; 641  : 			jtime = pintervals[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _jtime$[ebp], xmm0

; 642  : 		}

	jmp	SHORT $LN2@R_GetSprit
$LN3@R_GetSprit:

; 643  : 
; 644  : 		if( m_fDoInterp )

	cmp	DWORD PTR _m_fDoInterp$[ebp], 0
	je	SHORT $LN24@R_GetSprit

; 645  : 			lerpFrac = (targettime - jtime) / jinterval;

	movss	xmm0, DWORD PTR _targettime$[ebp]
	subss	xmm0, DWORD PTR _jtime$[ebp]
	divss	xmm0, DWORD PTR _jinterval$[ebp]
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
	jmp	SHORT $LN25@R_GetSprit
$LN24@R_GetSprit:

; 646  : 		else j = i; // no lerping

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN25@R_GetSprit:

; 647  : 
; 648  : 		// get the interpolated frames
; 649  : 		if( oldframe ) *oldframe = pspritegroup->frames[j];

	cmp	DWORD PTR _oldframe$[ebp], 0
	je	SHORT $LN26@R_GetSprit
	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	DWORD PTR [eax], ecx
$LN26@R_GetSprit:

; 650  : 		if( curframe ) *curframe = pspritegroup->frames[i];

	cmp	DWORD PTR _curframe$[ebp], 0
	je	SHORT $LN27@R_GetSprit
	mov	eax, DWORD PTR _curframe$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	DWORD PTR [eax], ecx
$LN27@R_GetSprit:

; 651  : 	}

	jmp	$LN38@R_GetSprit
$LN21@R_GetSprit:

; 652  : 	else if( psprite->frames[frame].type == FRAME_ANGLED )

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 2
	jne	$LN38@R_GetSprit

; 653  : 	{
; 654  : 		// e.g. doom-style sprite monsters
; 655  : 		float	yaw = ent->angles[YAW];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	movss	DWORD PTR _yaw$2[ebp], xmm0

; 656  : 		int	angleframe = (int)(Q_rint(( RI.viewangles[1] - yaw + 45.0f ) / 360 * 8) - 4) & 7;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	subss	xmm0, DWORD PTR _yaw$2[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN42@R_GetSprit
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	subss	xmm0, DWORD PTR _yaw$2[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv299[ebp], edx
	jmp	SHORT $LN43@R_GetSprit
$LN42@R_GetSprit:
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	subss	xmm0, DWORD PTR _yaw$2[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv299[ebp], ecx
$LN43@R_GetSprit:
	mov	edx, DWORD PTR tv299[ebp]
	sub	edx, 4
	and	edx, 7
	mov	DWORD PTR _angleframe$1[ebp], edx

; 657  : 
; 658  : 		if( m_fDoInterp )

	cmp	DWORD PTR _m_fDoInterp$[ebp], 0
	je	$LN29@R_GetSprit

; 659  : 		{
; 660  : 			if( ent->latched.prevblending[0] >= psprite->numframes || psprite->frames[ent->latched.prevblending[0]].type != FRAME_ANGLED )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jge	SHORT $LN32@R_GetSprit
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 2
	je	SHORT $LN31@R_GetSprit
$LN32@R_GetSprit:

; 661  : 			{
; 662  : 				// this can be happens when rendering switched between single and angled frames
; 663  : 				// or change model on replace delta-entity
; 664  : 				ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 665  : 				ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 666  : 				lerpFrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN31@R_GetSprit:

; 667  : 			}
; 668  : 
; 669  : 			if( ent->latched.sequencetime < cl.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3172]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	$LN33@R_GetSprit

; 670  : 			{
; 671  : 				if( frame != ent->latched.prevblending[1] )

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+3216]
	cmp	DWORD PTR _frame$[ebp], edx
	je	SHORT $LN35@R_GetSprit

; 672  : 				{
; 673  : 					ent->latched.prevblending[0] = ent->latched.prevblending[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR [esi+eax+3216]
	mov	BYTE PTR [ecx+edx+3216], al

; 674  : 					ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl

; 675  : 					ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 676  : 					lerpFrac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 677  : 				}

	jmp	SHORT $LN36@R_GetSprit
$LN35@R_GetSprit:

; 678  : 				else lerpFrac = (cl.time - ent->latched.sequencetime) * ent->curstate.framerate;

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3172]
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1008]
	mulsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN36@R_GetSprit:

; 679  : 			}

	jmp	SHORT $LN34@R_GetSprit
$LN33@R_GetSprit:

; 680  : 			else
; 681  : 			{
; 682  : 				ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 683  : 				ent->latched.sequencetime = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3172], xmm0

; 684  : 				lerpFrac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN34@R_GetSprit:

; 685  : 			}
; 686  : 		}

	jmp	SHORT $LN30@R_GetSprit
$LN29@R_GetSprit:

; 687  : 		else
; 688  : 		{
; 689  : 			ent->latched.prevblending[0] = ent->latched.prevblending[1] = frame;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	dl, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [ecx+eax+3216], dl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	al, BYTE PTR _frame$[ebp]
	mov	BYTE PTR [edx+ecx+3216], al

; 690  : 			lerpFrac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN30@R_GetSprit:

; 691  : 		}
; 692  : 
; 693  : 		pspritegroup = (mspritegroup_t *)psprite->frames[ent->latched.prevblending[0]].frameptr;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3216]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 694  : 		if( oldframe ) *oldframe = pspritegroup->frames[angleframe];

	cmp	DWORD PTR _oldframe$[ebp], 0
	je	SHORT $LN37@R_GetSprit
	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _angleframe$1[ebp]
	mov	edx, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	DWORD PTR [eax], ecx
$LN37@R_GetSprit:

; 695  : 
; 696  : 		pspritegroup = (mspritegroup_t *)psprite->frames[frame].frameptr;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 697  : 		if( curframe ) *curframe = pspritegroup->frames[angleframe];

	cmp	DWORD PTR _curframe$[ebp], 0
	je	SHORT $LN38@R_GetSprit
	mov	eax, DWORD PTR _curframe$[ebp]
	mov	ecx, DWORD PTR _angleframe$1[ebp]
	mov	edx, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+8]
	mov	DWORD PTR [eax], ecx
$LN38@R_GetSprit:

; 698  : 	}
; 699  : 
; 700  : 	return lerpFrac;

	fld	DWORD PTR _lerpFrac$[ebp]

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetSpriteFrameInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteLoadGroup
_TEXT	SEGMENT
_ptemp$ = -32						; size = 4
_numframes$ = -28					; size = 4
_groupsize$ = -24					; size = 4
_i$ = -20						; size = 4
_poutintervals$ = -16					; size = 4
_pin_intervals$ = -12					; size = 4
_pspritegroup$ = -8					; size = 4
_pingroup$ = -4						; size = 4
_mod$ = 8						; size = 4
_pin$ = 12						; size = 4
_ppframe$ = 16						; size = 4
_framenum$ = 20						; size = 4
_R_SpriteLoadGroup PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 103  : 	dspritegroup_t	*pingroup;
; 104  : 	mspritegroup_t	*pspritegroup;
; 105  : 	dspriteinterval_t	*pin_intervals;
; 106  : 	float		*poutintervals;
; 107  : 	int		i, groupsize, numframes;
; 108  : 	void		*ptemp;
; 109  : 
; 110  : 	pingroup = (dspritegroup_t *)pin;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _pingroup$[ebp], eax

; 111  : 	numframes = pingroup->numframes;

	mov	eax, DWORD PTR _pingroup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _numframes$[ebp], ecx

; 112  : 
; 113  : 	groupsize = sizeof( mspritegroup_t ) + (numframes - 1) * sizeof( pspritegroup->frames[0] );

	mov	eax, DWORD PTR _numframes$[ebp]
	lea	ecx, DWORD PTR [eax*4+8]
	mov	DWORD PTR _groupsize$[ebp], ecx

; 114  : 	pspritegroup = Mem_Calloc( mod->mempool, groupsize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_SpriteLoadGroup@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _groupsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pspritegroup$[ebp], eax

; 115  : 	pspritegroup->numframes = numframes;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR _numframes$[ebp]
	mov	DWORD PTR [eax], ecx

; 116  : 
; 117  : 	*ppframe = (mspriteframe_t *)pspritegroup;

	mov	eax, DWORD PTR _ppframe$[ebp]
	mov	ecx, DWORD PTR _pspritegroup$[ebp]
	mov	DWORD PTR [eax], ecx

; 118  : 	pin_intervals = (dspriteinterval_t *)(pingroup + 1);

	mov	eax, DWORD PTR _pingroup$[ebp]
	add	eax, 4
	mov	DWORD PTR _pin_intervals$[ebp], eax

; 119  : 	poutintervals = Mem_Calloc( mod->mempool, numframes * sizeof( float ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_SpriteLoadGroup@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _numframes$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _poutintervals$[ebp], eax

; 120  : 	pspritegroup->intervals = poutintervals;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR _poutintervals$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 121  : 
; 122  : 	for( i = 0; i < numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_SpriteLo
$LN2@R_SpriteLo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_SpriteLo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numframes$[ebp]
	jge	SHORT $LN3@R_SpriteLo

; 123  : 	{
; 124  : 		*poutintervals = pin_intervals->interval;

	mov	eax, DWORD PTR _poutintervals$[ebp]
	mov	ecx, DWORD PTR _pin_intervals$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 125  : 		if( *poutintervals <= 0.0f )

	mov	eax, DWORD PTR _poutintervals$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax]
	jb	SHORT $LN8@R_SpriteLo

; 126  : 			*poutintervals = 1.0f; // set error value

	mov	eax, DWORD PTR _poutintervals$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0
$LN8@R_SpriteLo:

; 127  : 		poutintervals++;

	mov	eax, DWORD PTR _poutintervals$[ebp]
	add	eax, 4
	mov	DWORD PTR _poutintervals$[ebp], eax

; 128  : 		pin_intervals++;

	mov	eax, DWORD PTR _pin_intervals$[ebp]
	add	eax, 4
	mov	DWORD PTR _pin_intervals$[ebp], eax

; 129  : 	}

	jmp	SHORT $LN2@R_SpriteLo
$LN3@R_SpriteLo:

; 130  : 
; 131  : 	ptemp = (void *)pin_intervals;

	mov	eax, DWORD PTR _pin_intervals$[ebp]
	mov	DWORD PTR _ptemp$[ebp], eax

; 132  : 	for( i = 0; i < numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_SpriteLo
$LN5@R_SpriteLo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_SpriteLo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numframes$[ebp]
	jge	SHORT $LN6@R_SpriteLo

; 133  : 	{
; 134  : 		ptemp = R_SpriteLoadFrame( mod, ptemp, &pspritegroup->frames[i], framenum * 10 + i );

	imul	eax, DWORD PTR _framenum$[ebp], 10
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pspritegroup$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+8]
	push	eax
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_SpriteLoadFrame
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ptemp$[ebp], eax

; 135  : 	}

	jmp	SHORT $LN5@R_SpriteLo
$LN6@R_SpriteLo:

; 136  : 
; 137  : 	return (dframetype_t *)ptemp;

	mov	eax, DWORD PTR _ptemp$[ebp]

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteLoadGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteLoadFrame
_TEXT	SEGMENT
_bytes$ = -148						; size = 4
_texname$ = -144					; size = 128
_gl_texturenum$ = -16					; size = 4
_pspriteframe$ = -12					; size = 4
_pinframe$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_pin$ = 12						; size = 4
_ppframe$ = 16						; size = 4
_num$ = 20						; size = 4
_R_SpriteLoadFrame PROC					; COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 58   : 	dspriteframe_t	*pinframe;
; 59   : 	mspriteframe_t	*pspriteframe;
; 60   : 	int		gl_texturenum = 0;

	mov	DWORD PTR _gl_texturenum$[ebp], 0

; 61   : 	char		texname[128];
; 62   : 	int		bytes = 1;

	mov	DWORD PTR _bytes$[ebp], 1

; 63   : 
; 64   : 	pinframe = (dspriteframe_t *)pin;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _pinframe$[ebp], eax

; 65   : 	if( sprite_version == SPRITE_VERSION_32 )

	cmp	DWORD PTR _sprite_version, 32		; 00000020H
	jne	SHORT $LN2@R_SpriteLo

; 66   : 		bytes = 4;

	mov	DWORD PTR _bytes$[ebp], 4
$LN2@R_SpriteLo:

; 67   : 
; 68   : 	// build uinque frame name
; 69   : 	if( FBitSet( mod->flags, MODEL_CLIENT )) // it's a HUD sprite

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN3@R_SpriteLo

; 70   : 	{
; 71   : 		Q_snprintf( texname, sizeof( texname ), "#HUD/%s(%s:%i%i).spr", sprite_name, group_suffix, num / 10, num % 10 );

	mov	eax, DWORD PTR _num$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	push	OFFSET _group_suffix
	push	OFFSET _sprite_name
	push	OFFSET ??_C@_0BF@OINMPMLC@?$CDHUD?1?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@
	push	128					; 00000080H
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 72   : 		gl_texturenum = GL_LoadTexture( texname, pin, pinframe->width * pinframe->height * bytes, r_texFlags );

	mov	eax, DWORD PTR _r_texFlags
	push	eax
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR _pinframe$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texturenum$[ebp], eax

; 73   : 	}

	jmp	SHORT $LN4@R_SpriteLo
$LN3@R_SpriteLo:

; 74   : 	else
; 75   : 	{
; 76   : 		Q_snprintf( texname, sizeof( texname ), "#%s(%s:%i%i).spr", sprite_name, group_suffix, num / 10, num % 10 );

	mov	eax, DWORD PTR _num$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	eax, DWORD PTR _num$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	push	OFFSET _group_suffix
	push	OFFSET _sprite_name
	push	OFFSET ??_C@_0BB@GADPIMLE@?$CD?$CFs?$CI?$CFs?3?$CFi?$CFi?$CJ?4spr@
	push	128					; 00000080H
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 77   : 		gl_texturenum = GL_LoadTexture( texname, pin, pinframe->width * pinframe->height * bytes, r_texFlags );

	mov	eax, DWORD PTR _r_texFlags
	push	eax
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR _pinframe$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [edx+12]
	imul	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texturenum$[ebp], eax
$LN4@R_SpriteLo:

; 78   : 	}	
; 79   : 
; 80   : 	// setup frame description
; 81   : 	pspriteframe = Mem_Malloc( mod->mempool, sizeof( mspriteframe_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_SpriteLoadFrame@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pspriteframe$[ebp], eax

; 82   : 	pspriteframe->width = pinframe->width;

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 83   : 	pspriteframe->height = pinframe->height;

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 84   : 	pspriteframe->up = pinframe->origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinframe$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 85   : 	pspriteframe->left = pinframe->origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinframe$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 86   : 	pspriteframe->down = pinframe->origin[1] - pinframe->height;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR _pinframe$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	sub	eax, DWORD PTR [edx+12]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 87   : 	pspriteframe->right = pinframe->width + pinframe->origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinframe$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _pinframe$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 88   : 	pspriteframe->gl_texturenum = gl_texturenum;

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR _gl_texturenum$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 89   : 	*ppframe = pspriteframe;

	mov	eax, DWORD PTR _ppframe$[ebp]
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	mov	DWORD PTR [eax], ecx

; 90   : 
; 91   : 	return (dframetype_t *)((byte *)(pinframe + 1) + pinframe->width * pinframe->height * bytes );

	mov	eax, DWORD PTR _pinframe$[ebp]
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	edx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR [ecx+12]
	imul	edx, DWORD PTR _bytes$[ebp]
	mov	eax, DWORD PTR _pinframe$[ebp]
	lea	eax, DWORD PTR [eax+edx+16]

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteLoadFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _Mod_UnloadSpriteModel
_TEXT	SEGMENT
tv70 = -88						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_pspriteframe$ = -12					; size = 4
_pspritegroup$ = -8					; size = 4
_psprite$ = -4						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadSpriteModel PROC				; COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 430  : 	msprite_t		*psprite;
; 431  : 	mspritegroup_t	*pspritegroup;	
; 432  : 	mspriteframe_t	*pspriteframe;
; 433  : 	int		i, j;
; 434  : 
; 435  : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN14@Mod_Unload
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN15@Mod_Unload
$LN14@Mod_Unload:
	mov	DWORD PTR tv70[ebp], 0
$LN15@Mod_Unload:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadSpriteModel@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 436  : 
; 437  : 	if( mod->type == mod_sprite )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	$LN8@Mod_Unload

; 438  : 	{
; 439  : 		if( host.type != HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	je	$LN8@Mod_Unload

; 440  : 		{
; 441  : 			psprite = mod->cache.data;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _psprite$[ebp], ecx

; 442  : 
; 443  : 			if( psprite )

	cmp	DWORD PTR _psprite$[ebp], 0
	je	$LN8@Mod_Unload

; 444  : 			{
; 445  : 				// release all textures
; 446  : 				for( i = 0; i < psprite->numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Unload
$LN2@Mod_Unload:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Unload:
	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN8@Mod_Unload

; 447  : 				{
; 448  : 					if( psprite->frames[i].type == SPR_SINGLE )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 0
	jne	SHORT $LN11@Mod_Unload

; 449  : 					{
; 450  : 						pspriteframe = psprite->frames[i].frameptr;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspriteframe$[ebp], edx

; 451  : 						GL_FreeTexture( pspriteframe->gl_texturenum );

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 452  : 					}

	jmp	SHORT $LN12@Mod_Unload
$LN11@Mod_Unload:

; 453  : 					else
; 454  : 					{
; 455  : 						pspritegroup = (mspritegroup_t *)psprite->frames[i].frameptr;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 456  : 
; 457  : 						for( j = 0; j < pspritegroup->numframes; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_Unload
$LN5@Mod_Unload:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_Unload:
	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN12@Mod_Unload

; 458  : 						{
; 459  : 							pspriteframe = pspritegroup->frames[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pspritegroup$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	DWORD PTR _pspriteframe$[ebp], edx

; 460  : 							GL_FreeTexture( pspriteframe->gl_texturenum );

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 461  : 						}

	jmp	SHORT $LN5@Mod_Unload
$LN12@Mod_Unload:

; 462  : 					}
; 463  : 				}

	jmp	$LN2@Mod_Unload
$LN8@Mod_Unload:

; 464  : 			}
; 465  : 		}
; 466  : 	}
; 467  : 
; 468  : 	Mem_FreePool( &mod->mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadSpriteModel@@9@9
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 469  : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 470  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _Mod_LoadMapSprite
_TEXT	SEGMENT
tv211 = -304						; size = 4
tv203 = -304						; size = 4
_psprite$ = -236					; size = 4
_pspriteframe$ = -232					; size = 4
_numframes$ = -228					; size = 4
_linedelta$ = -224					; size = 4
_yh$ = -220						; size = 4
_xh$ = -216						; size = 4
_yl$ = -212						; size = 4
_xl$ = -208						; size = 4
_h$ = -204						; size = 4
_w$ = -200						; size = 4
_y$ = -196						; size = 4
_x$ = -192						; size = 4
_j$ = -188						; size = 4
_i$ = -184						; size = 4
_texname$ = -180					; size = 128
_temp$ = -52						; size = 36
_pix$ = -16						; size = 4
_dst$ = -12						; size = 4
_src$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_loaded$ = 20						; size = 4
_Mod_LoadMapSprite PROC					; COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 310  : 	byte		*src, *dst;
; 311  : 	rgbdata_t		*pix, temp;
; 312  : 	char		texname[128];
; 313  : 	int		i, j, x, y, w, h;
; 314  : 	int		xl, yl, xh, yh;
; 315  : 	int		linedelta, numframes;
; 316  : 	mspriteframe_t	*pspriteframe;
; 317  : 	msprite_t		*psprite;
; 318  : 
; 319  : 	if( loaded ) *loaded = false;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN14@Mod_LoadMa
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN14@Mod_LoadMa:

; 320  : 	Q_snprintf( texname, sizeof( texname ), "#%s", mod->name );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET ??_C@_03FGKIIOAN@?$CD?$CFs@
	push	128					; 00000080H
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 321  : 	Image_SetForceFlags( IL_OVERVIEW );

	push	64					; 00000040H
	call	_Image_SetForceFlags
	add	esp, 4

; 322  : 	pix = FS_LoadImage( texname, buffer, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pix$[ebp], eax

; 323  : 	Image_ClearForceFlags();

	call	_Image_ClearForceFlags

; 324  : 	if( !pix ) return;	// bad image or something else

	cmp	DWORD PTR _pix$[ebp], 0
	jne	SHORT $LN15@Mod_LoadMa
	jmp	$LN25@Mod_LoadMa
$LN15@Mod_LoadMa:

; 325  : 
; 326  : 	mod->type = mod_sprite;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+68], 1

; 327  : 	r_texFlags = 0; // no custom flags for map sprites

	mov	DWORD PTR _r_texFlags, 0

; 328  : 
; 329  : 	if( pix->width % MAPSPRITE_SIZE )

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	and	ecx, -2147483521			; 8000007fH
	jns	SHORT $LN27@Mod_LoadMa
	dec	ecx
	or	ecx, -128				; ffffff80H
	inc	ecx
$LN27@Mod_LoadMa:
	test	ecx, ecx
	je	SHORT $LN16@Mod_LoadMa

; 330  : 		w = pix->width - ( pix->width % MAPSPRITE_SIZE );

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pix$[ebp]
	movzx	eax, WORD PTR [edx]
	and	eax, -2147483521			; 8000007fH
	jns	SHORT $LN28@Mod_LoadMa
	dec	eax
	or	eax, -128				; ffffff80H
	inc	eax
$LN28@Mod_LoadMa:
	sub	ecx, eax
	mov	DWORD PTR _w$[ebp], ecx
	jmp	SHORT $LN17@Mod_LoadMa
$LN16@Mod_LoadMa:

; 331  : 	else w = pix->width;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _w$[ebp], ecx
$LN17@Mod_LoadMa:

; 332  : 
; 333  : 	if( pix->height % MAPSPRITE_SIZE )

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, -2147483521			; 8000007fH
	jns	SHORT $LN29@Mod_LoadMa
	dec	ecx
	or	ecx, -128				; ffffff80H
	inc	ecx
$LN29@Mod_LoadMa:
	test	ecx, ecx
	je	SHORT $LN18@Mod_LoadMa

; 334  : 		h = pix->height - ( pix->height % MAPSPRITE_SIZE );

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _pix$[ebp]
	movzx	eax, WORD PTR [edx+2]
	and	eax, -2147483521			; 8000007fH
	jns	SHORT $LN30@Mod_LoadMa
	dec	eax
	or	eax, -128				; ffffff80H
	inc	eax
$LN30@Mod_LoadMa:
	sub	ecx, eax
	mov	DWORD PTR _h$[ebp], ecx
	jmp	SHORT $LN19@Mod_LoadMa
$LN18@Mod_LoadMa:

; 335  : 	else h = pix->height;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _h$[ebp], ecx
$LN19@Mod_LoadMa:

; 336  : 
; 337  : 	if( w < MAPSPRITE_SIZE ) w = MAPSPRITE_SIZE;

	cmp	DWORD PTR _w$[ebp], 128			; 00000080H
	jge	SHORT $LN20@Mod_LoadMa
	mov	DWORD PTR _w$[ebp], 128			; 00000080H
$LN20@Mod_LoadMa:

; 338  : 	if( h < MAPSPRITE_SIZE ) h = MAPSPRITE_SIZE;

	cmp	DWORD PTR _h$[ebp], 128			; 00000080H
	jge	SHORT $LN21@Mod_LoadMa
	mov	DWORD PTR _h$[ebp], 128			; 00000080H
$LN21@Mod_LoadMa:

; 339  : 
; 340  : 	// resample image if needed
; 341  : 	Image_Process( &pix, w, h, IMAGE_FORCE_RGBA|IMAGE_RESAMPLE, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	9437184					; 00900000H
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pix$[ebp]
	push	edx
	call	_Image_Process
	add	esp, 20					; 00000014H

; 342  : 
; 343  : 	w = h = MAPSPRITE_SIZE;

	mov	DWORD PTR _h$[ebp], 128			; 00000080H
	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 344  : 
; 345  : 	// check range
; 346  : 	if( w > pix->width ) w = pix->width;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _w$[ebp], ecx
	jle	SHORT $LN22@Mod_LoadMa
	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR _w$[ebp], ecx
$LN22@Mod_LoadMa:

; 347  : 	if( h > pix->height ) h = pix->height;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	cmp	DWORD PTR _h$[ebp], ecx
	jle	SHORT $LN23@Mod_LoadMa
	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _h$[ebp], ecx
$LN23@Mod_LoadMa:

; 348  : 
; 349  : 	// determine how many frames we needs
; 350  : 	numframes = (pix->width * pix->height) / (w * h);

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	eax, WORD PTR [eax]
	mov	ecx, DWORD PTR _pix$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	ecx, DWORD PTR _w$[ebp]
	imul	ecx, DWORD PTR _h$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _numframes$[ebp], eax

; 351  : 	mod->mempool = Mem_AllocPool( va( "^2%s^7", mod->name ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
	add	eax, 42					; 0000002aH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+76], eax

; 352  : 	psprite = Mem_Calloc( mod->mempool, sizeof( msprite_t ) + ( numframes - 1 ) * sizeof( psprite->frames ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _numframes$[ebp]
	lea	edx, DWORD PTR [ecx*8+28]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _psprite$[ebp], eax

; 353  : 	mod->cache.data = psprite;	// make link to extradata

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 354  : 
; 355  : 	psprite->type = SPR_FWD_PARALLEL_ORIENTED;

	mov	eax, 4
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	WORD PTR [ecx], ax

; 356  : 	psprite->texFormat = SPR_ALPHTEST;

	mov	eax, 3
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	WORD PTR [ecx+2], ax

; 357  : 	psprite->numframes = mod->numframes = numframes;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _numframes$[ebp]
	mov	DWORD PTR [eax+72], ecx
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	eax, DWORD PTR _numframes$[ebp]
	mov	DWORD PTR [edx+12], eax

; 358  : 	psprite->radius = sqrt(((w >> 1) * (w >> 1)) + ((h >> 1) * (h >> 1)));

	mov	eax, DWORD PTR _w$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	sar	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _h$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR _h$[ebp]
	sar	ecx, 1
	imul	edx, ecx
	add	eax, edx
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [edx+16], eax

; 359  : 
; 360  : 	mod->mins[0] = mod->mins[1] = -w / 2;

	mov	eax, DWORD PTR _w$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv203[ebp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0

; 361  : 	mod->maxs[0] = mod->maxs[1] = w / 2;

	mov	eax, DWORD PTR _w$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv211[ebp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0

; 362  : 	mod->mins[2] = -h / 2;

	mov	eax, DWORD PTR _h$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [edx+ecx+84], xmm0

; 363  : 	mod->maxs[2] = h / 2;

	mov	eax, DWORD PTR _h$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [edx+ecx+96], xmm0

; 364  : 
; 365  : 	// create a temporary pic
; 366  : 	memset( &temp, 0, sizeof( temp ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 367  : 	temp.width = w;

	mov	ax, WORD PTR _w$[ebp]
	mov	WORD PTR _temp$[ebp], ax

; 368  : 	temp.height = h;

	mov	ax, WORD PTR _h$[ebp]
	mov	WORD PTR _temp$[ebp+2], ax

; 369  : 	temp.type = pix->type;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _temp$[ebp+8], ecx

; 370  : 	temp.flags = pix->flags;	

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _temp$[ebp+12], ecx

; 371  : 	temp.size = w * h * PFDesc[temp.type].bpp;

	mov	eax, DWORD PTR _w$[ebp]
	imul	eax, DWORD PTR _h$[ebp]
	imul	ecx, DWORD PTR _temp$[ebp+8], 28
	imul	eax, DWORD PTR _PFDesc[ecx+24]
	mov	DWORD PTR _temp$[ebp+32], eax

; 372  : 	temp.buffer = Mem_Malloc( r_temppool, temp.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
	add	eax, 63					; 0000003fH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _temp$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _r_temppool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp+24], eax

; 373  : 	temp.palette = NULL;

	mov	DWORD PTR _temp$[ebp+20], 0

; 374  : 
; 375  : 	// chop the image and upload into video memory
; 376  : 	for( i = xl = yl = 0; i < numframes; i++ )

	mov	DWORD PTR _yl$[ebp], 0
	mov	eax, DWORD PTR _yl$[ebp]
	mov	DWORD PTR _xl$[ebp], eax
	mov	ecx, DWORD PTR _xl$[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@Mod_LoadMa
$LN2@Mod_LoadMa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadMa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numframes$[ebp]
	jge	$LN3@Mod_LoadMa

; 377  : 	{
; 378  : 		xh = xl + w;

	mov	eax, DWORD PTR _xl$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _xh$[ebp], eax

; 379  : 		yh = yl + h;

	mov	eax, DWORD PTR _yl$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _yh$[ebp], eax

; 380  : 
; 381  : 		src = pix->buffer + ( yl * pix->width + xl ) * 4;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _yl$[ebp]
	add	ecx, DWORD PTR _xl$[ebp]
	mov	edx, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR [edx+24]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _src$[ebp], ecx

; 382  : 		linedelta = ( pix->width - w ) * 4;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	sub	ecx, DWORD PTR _w$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _linedelta$[ebp], ecx

; 383  : 		dst = temp.buffer;

	mov	eax, DWORD PTR _temp$[ebp+24]
	mov	DWORD PTR _dst$[ebp], eax

; 384  : 
; 385  : 		// cut block from source
; 386  : 		for( y = yl; y < yh; y++ )

	mov	eax, DWORD PTR _yl$[ebp]
	mov	DWORD PTR _y$[ebp], eax
	jmp	SHORT $LN7@Mod_LoadMa
$LN5@Mod_LoadMa:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN7@Mod_LoadMa:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _yh$[ebp]
	jge	$LN6@Mod_LoadMa

; 387  : 		{
; 388  : 			for( x = xl; x < xh; x++ )

	mov	eax, DWORD PTR _xl$[ebp]
	mov	DWORD PTR _x$[ebp], eax
	jmp	SHORT $LN10@Mod_LoadMa
$LN8@Mod_LoadMa:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN10@Mod_LoadMa:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _xh$[ebp]
	jge	SHORT $LN9@Mod_LoadMa

; 389  : 				for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadMa
$LN11@Mod_LoadMa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadMa:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN12@Mod_LoadMa

; 390  : 					*dst++ = *src++;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _dst$[ebp]
	add	eax, 1
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _src$[ebp]
	add	ecx, 1
	mov	DWORD PTR _src$[ebp], ecx
	jmp	SHORT $LN11@Mod_LoadMa
$LN12@Mod_LoadMa:
	jmp	SHORT $LN8@Mod_LoadMa
$LN9@Mod_LoadMa:

; 391  : 			src += linedelta;

	mov	eax, DWORD PTR _src$[ebp]
	add	eax, DWORD PTR _linedelta$[ebp]
	mov	DWORD PTR _src$[ebp], eax

; 392  : 		}

	jmp	$LN5@Mod_LoadMa
$LN6@Mod_LoadMa:

; 393  : 
; 394  : 		// build uinque frame name
; 395  : 		Q_snprintf( texname, sizeof( texname ), "#MAP/%s_%i%i.spr", mod->name, i / 10, i % 10 );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@PIGKLKGO@?$CDMAP?1?$CFs_?$CFi?$CFi?4spr@
	push	128					; 00000080H
	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 396  : 
; 397  : 		psprite->frames[i].frameptr = Mem_Calloc( mod->mempool, sizeof( mspriteframe_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
	add	eax, 88					; 00000058H
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [edx+ecx*8+32], eax

; 398  : 		pspriteframe = psprite->frames[i].frameptr;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspriteframe$[ebp], edx

; 399  : 		pspriteframe->width = w;

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax], ecx

; 400  : 		pspriteframe->height = h;

	mov	eax, DWORD PTR _pspriteframe$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 401  : 		pspriteframe->up = ( h >> 1 );

	mov	eax, DWORD PTR _h$[ebp]
	sar	eax, 1
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 402  : 		pspriteframe->left = -( w >> 1 );

	mov	eax, DWORD PTR _w$[ebp]
	sar	eax, 1
	neg	eax
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 403  : 		pspriteframe->down = ( h >> 1 ) - h;

	mov	eax, DWORD PTR _h$[ebp]
	sar	eax, 1
	sub	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 404  : 		pspriteframe->right = w + -( w >> 1 );

	mov	eax, DWORD PTR _w$[ebp]
	sar	eax, 1
	neg	eax
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pspriteframe$[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 405  : 		pspriteframe->gl_texturenum = GL_LoadTextureInternal( texname, &temp, TF_IMAGE );

	push	0
	push	6144					; 00001800H
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _texname$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _pspriteframe$[ebp]
	mov	DWORD PTR [edx+24], eax

; 406  : 
; 407  : 		xl += w;

	mov	eax, DWORD PTR _xl$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _xl$[ebp], eax

; 408  : 		if( xl >= pix->width )

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _xl$[ebp], ecx
	jl	SHORT $LN24@Mod_LoadMa

; 409  : 		{
; 410  : 			xl = 0;

	mov	DWORD PTR _xl$[ebp], 0

; 411  : 			yl += h;

	mov	eax, DWORD PTR _yl$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _yl$[ebp], eax
$LN24@Mod_LoadMa:

; 412  : 		}
; 413  : 	}

	jmp	$LN2@Mod_LoadMa
$LN3@Mod_LoadMa:

; 414  : 
; 415  : 	FS_FreeImage( pix );

	mov	eax, DWORD PTR _pix$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 416  : 	Mem_Free( temp.buffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadMapSprite@@9@9
	add	eax, 107				; 0000006bH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _temp$[ebp+24]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 417  : 
; 418  : 	if( loaded ) *loaded = true;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN25@Mod_LoadMa
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN25@Mod_LoadMa:

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadMapSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_DrawSpriteModel
_TEXT	SEGMENT
tv798 = -252						; size = 8
tv788 = -252						; size = 8
tv778 = -252						; size = 8
tv535 = -248						; size = 4
tv136 = -248						; size = 4
tv794 = -244						; size = 4
tv784 = -244						; size = 4
tv774 = -244						; size = 4
tv534 = -244						; size = 4
tv328 = -244						; size = 4
tv307 = -244						; size = 4
tv287 = -244						; size = 4
tv190 = -244						; size = 4
tv135 = -244						; size = 4
$T1 = -240						; size = 16
_ilength$2 = -160					; size = 4
_ilength$3 = -156					; size = 4
_lightColor$4 = -152					; size = 16
_num$5 = -136						; size = 4
_parent$6 = -132					; size = 4
_color2$ = -128						; size = 12
_color$ = -116						; size = 12
_origin$ = -104						; size = 12
_v_up$ = -92						; size = 12
_v_right$ = -80						; size = 12
_v_forward$ = -68					; size = 12
_scale$ = -56						; size = 4
_ilerp$ = -52						; size = 4
_lerp$ = -48						; size = 4
_cr$ = -44						; size = 4
_sr$ = -40						; size = 4
_dot$ = -36						; size = 4
_angle$ = -32						; size = 4
_type$ = -28						; size = 4
_i$ = -24						; size = 4
_model$ = -20						; size = 4
_psprite$ = -16						; size = 4
_oldframe$ = -12					; size = 4
_frame$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_DrawSpriteModel PROC					; COMDAT

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 898  : 	mspriteframe_t	*frame, *oldframe;
; 899  : 	msprite_t		*psprite;
; 900  : 	model_t		*model;
; 901  : 	int		i, type;
; 902  : 	float		angle, dot, sr, cr;
; 903  : 	float		lerp = 1.0f, ilerp, scale;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lerp$[ebp], xmm0

; 904  : 	vec3_t		v_forward, v_right, v_up;
; 905  : 	vec3_t		origin, color, color2;
; 906  : 
; 907  : 	if( RI.params & RP_ENVVIEW )

	mov	eax, DWORD PTR _RI
	and	eax, 2
	je	SHORT $LN9@R_DrawSpri

; 908  : 		return;

	jmp	$LN53@R_DrawSpri
$LN9@R_DrawSpri:

; 909  : 
; 910  : 	model = e->model;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _model$[ebp], ecx

; 911  : 	psprite = (msprite_t * )model->cache.data;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _psprite$[ebp], ecx

; 912  : 	VectorCopy( e->origin, origin );	// set render origin

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 913  : 
; 914  : 	// do movewith
; 915  : 	if( e->curstate.aiment > 0 && e->curstate.movetype == MOVETYPE_FOLLOW )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1100], 0
	jle	$LN13@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1000], 12		; 0000000cH
	jne	$LN13@R_DrawSpri

; 916  : 	{
; 917  : 		cl_entity_t	*parent;
; 918  : 	
; 919  : 		parent = CL_GetEntityByIndex( e->curstate.aiment );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+1100]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _parent$6[ebp], eax

; 920  : 
; 921  : 		if( parent && parent->model )

	cmp	DWORD PTR _parent$6[ebp], 0
	je	$LN13@R_DrawSpri
	mov	eax, DWORD PTR _parent$6[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	$LN13@R_DrawSpri

; 922  : 		{
; 923  : 			if( parent->model->type == mod_studio && e->curstate.body > 0 )

	mov	eax, DWORD PTR _parent$6[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN12@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1032], 0
	jle	$LN12@R_DrawSpri

; 924  : 			{
; 925  : 				int num = bound( 1, e->curstate.body, MAXSTUDIOATTACHMENTS );

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1032], 1
	jl	SHORT $LN57@R_DrawSpri
	mov	ecx, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [ecx+1032], 4
	jge	SHORT $LN55@R_DrawSpri
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+1032]
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN56@R_DrawSpri
$LN55@R_DrawSpri:
	mov	DWORD PTR tv135[ebp], 4
$LN56@R_DrawSpri:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], ecx
	jmp	SHORT $LN58@R_DrawSpri
$LN57@R_DrawSpri:
	mov	DWORD PTR tv136[ebp], 1
$LN58@R_DrawSpri:
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR _num$5[ebp], edx

; 926  : 				VectorCopy( parent->attachment[num-1], origin );

	mov	eax, DWORD PTR _num$5[ebp]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _parent$6[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _origin$[ebp+ecx], edx
	mov	eax, DWORD PTR _num$5[ebp]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _parent$6[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _origin$[ebp+edx], eax
	mov	ecx, DWORD PTR _num$5[ebp]
	sub	ecx, 1
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _parent$6[ebp]
	lea	ecx, DWORD PTR [eax+edx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _origin$[ebp+eax], ecx

; 927  : 			}

	jmp	SHORT $LN13@R_DrawSpri
$LN12@R_DrawSpri:

; 928  : 			else VectorCopy( parent->origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _parent$6[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _parent$6[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _parent$6[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _origin$[ebp+ecx], eax
$LN13@R_DrawSpri:

; 929  : 		}
; 930  : 	}
; 931  : 
; 932  : 	scale = e->curstate.scale;

	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	movss	DWORD PTR _scale$[ebp], xmm0

; 933  : 	if( !scale ) scale = 1.0f;

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@R_DrawSpri
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0
$LN14@R_DrawSpri:

; 934  : 
; 935  : 	if( R_SpriteOccluded( e, origin, &scale ))

	lea	eax, DWORD PTR _scale$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_SpriteOccluded
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@R_DrawSpri

; 936  : 		return; // sprite culled

	jmp	$LN53@R_DrawSpri
$LN15@R_DrawSpri:

; 937  : 
; 938  : 	r_stats.c_sprite_models_drawn++;

	mov	eax, DWORD PTR _r_stats+36
	add	eax, 1
	mov	DWORD PTR _r_stats+36, eax

; 939  : 
; 940  : 	if( e->curstate.rendermode == kRenderGlow || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 3
	je	SHORT $LN17@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN16@R_DrawSpri
$LN17@R_DrawSpri:

; 941  : 		R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4
$LN16@R_DrawSpri:

; 942  : 
; 943  : 	// select properly rendermode
; 944  : 	switch( e->curstate.rendermode )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR tv190[ebp], ecx
	cmp	DWORD PTR tv190[ebp], 5
	ja	SHORT $LN23@R_DrawSpri
	mov	edx, DWORD PTR tv190[ebp]
	jmp	DWORD PTR $LN63@R_DrawSpri[edx*4]
$LN18@R_DrawSpri:

; 945  : 	{
; 946  : 	case kRenderTransAlpha:
; 947  : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask
$LN19@R_DrawSpri:

; 948  : 	case kRenderTransColor:
; 949  : 	case kRenderTransTexture:
; 950  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 951  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 952  : 		break;

	jmp	SHORT $LN2@R_DrawSpri
$LN21@R_DrawSpri:

; 953  : 	case kRenderGlow:
; 954  : 		pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable
$LN22@R_DrawSpri:

; 955  : 	case kRenderTransAdd:
; 956  : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 957  : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 958  : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 959  : 		break;

	jmp	SHORT $LN2@R_DrawSpri
$LN23@R_DrawSpri:

; 960  : 	case kRenderNormal:
; 961  : 	default:
; 962  : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN2@R_DrawSpri:

; 963  : 		break;
; 964  : 	}
; 965  : 
; 966  : 	// all sprites can have color
; 967  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 968  : 	pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 969  : 
; 970  : 	// NOTE: never pass sprites with rendercolor '0 0 0' it's a stupid Valve Hammer Editor bug
; 971  : 	if( e->curstate.rendercolor.r || e->curstate.rendercolor.g || e->curstate.rendercolor.b )

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	test	ecx, ecx
	jne	SHORT $LN27@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+993]
	test	ecx, ecx
	jne	SHORT $LN27@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	test	ecx, ecx
	je	SHORT $LN25@R_DrawSpri
$LN27@R_DrawSpri:

; 972  : 	{
; 973  : 		color[0] = (float)e->curstate.rendercolor.r * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _color$[ebp+eax], xmm0

; 974  : 		color[1] = (float)e->curstate.rendercolor.g * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+993]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _color$[ebp+edx], xmm0

; 975  : 		color[2] = (float)e->curstate.rendercolor.b * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _color$[ebp+edx], xmm0

; 976  : 	}

	jmp	SHORT $LN26@R_DrawSpri
$LN25@R_DrawSpri:

; 977  : 	else
; 978  : 	{
; 979  : 		color[0] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _color$[ebp+ecx], xmm0

; 980  : 		color[1] = 1.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _color$[ebp+eax], xmm0

; 981  : 		color[2] = 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _color$[ebp+eax], xmm0
$LN26@R_DrawSpri:

; 982  : 	}
; 983  :           
; 984  : 	if( R_SpriteHasLightmap( e, psprite->texFormat ))

	mov	eax, DWORD PTR _psprite$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_SpriteHasLightmap
	add	esp, 8
	test	eax, eax
	je	$LN28@R_DrawSpri

; 985  : 	{
; 986  : 		colorVec lightColor = R_LightPoint( origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_R_LightPoint
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _lightColor$4[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lightColor$4[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _lightColor$4[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _lightColor$4[ebp+12], eax

; 987  : 		// FIXME: collect light from dlights?
; 988  : 		color2[0] = (float)lightColor.r * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _lightColor$4[ebp]
	mov	DWORD PTR tv774[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv774[ebp]
	mov	ecx, DWORD PTR tv774[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv778[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv778[ebp]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _color2$[ebp+eax], xmm0

; 989  : 		color2[1] = (float)lightColor.g * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _lightColor$4[ebp+4]
	mov	DWORD PTR tv784[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv784[ebp]
	mov	ecx, DWORD PTR tv784[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv788[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv788[ebp]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _color2$[ebp+edx], xmm0

; 990  : 		color2[2] = (float)lightColor.b * ( 1.0f / 255.0f );

	mov	eax, DWORD PTR _lightColor$4[ebp+8]
	mov	DWORD PTR tv794[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv794[ebp]
	mov	ecx, DWORD PTR tv794[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv798[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv798[ebp]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _color2$[ebp+edx], xmm0

; 991  : 		// NOTE: sprites with 'lightmap' looks ugly when alpha func is GL_GREATER 0.0
; 992  : 		pglAlphaFunc( GL_GREATER, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc
$LN28@R_DrawSpri:

; 993  : 	}
; 994  : 
; 995  : 	if( R_SpriteAllowLerping( e, psprite ))

	mov	eax, DWORD PTR _psprite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_SpriteAllowLerping
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@R_DrawSpri

; 996  : 		lerp = R_GetSpriteFrameInterpolant( e, &oldframe, &frame );

	lea	eax, DWORD PTR _frame$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldframe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_GetSpriteFrameInterpolant
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _lerp$[ebp]
	jmp	SHORT $LN30@R_DrawSpri
$LN29@R_DrawSpri:

; 997  : 	else frame = oldframe = R_GetSpriteFrame( model, e->curstate.frame, e->angles[YAW] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	cvttss2si eax, DWORD PTR [edx+960]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	_R_GetSpriteFrame
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _oldframe$[ebp], eax
	mov	edx, DWORD PTR _oldframe$[ebp]
	mov	DWORD PTR _frame$[ebp], edx
$LN30@R_DrawSpri:

; 998  : 
; 999  : 	type = psprite->type;

	mov	eax, DWORD PTR _psprite$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _type$[ebp], ecx

; 1000 : 
; 1001 : 	// automatically roll parallel sprites if requested
; 1002 : 	if( e->angles[ROLL] != 0.0f && type == SPR_FWD_PARALLEL )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN31@R_DrawSpri
	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN31@R_DrawSpri

; 1003 : 		type = SPR_FWD_PARALLEL_ORIENTED;

	mov	DWORD PTR _type$[ebp], 4
$LN31@R_DrawSpri:

; 1004 : 
; 1005 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv287[ebp], eax
	cmp	DWORD PTR tv287[ebp], 4
	ja	$LN40@R_DrawSpri
	mov	ecx, DWORD PTR tv287[ebp]
	jmp	DWORD PTR $LN64@R_DrawSpri[ecx*4]
$LN32@R_DrawSpri:

; 1006 : 	{
; 1007 : 	case SPR_ORIENTED:
; 1008 : 		AngleVectors( e->angles, v_forward, v_right, v_up );

	lea	eax, DWORD PTR _v_up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _v_forward$[ebp]
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3236				; 00000ca4H
	push	eax
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1009 : 		VectorScale( v_forward, 0.01f, v_forward );	// to avoid z-fighting

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v_forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v_forward$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _v_forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _v_forward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v_forward$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv307[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv307[ebp]
	movss	DWORD PTR _v_forward$[ebp+ecx], xmm0

; 1010 : 		VectorSubtract( origin, v_forward, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	subss	xmm0, DWORD PTR _v_forward$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR _v_forward$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR _v_forward$[ebp+ecx]
	movss	DWORD PTR tv328[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv328[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 1011 : 		break;

	jmp	$LN4@R_DrawSpri
$LN33@R_DrawSpri:

; 1012 : 	case SPR_FACING_UPRIGHT:
; 1013 : 		VectorSet( v_right, origin[1] - RI.vieworg[1], -(origin[0] - RI.vieworg[0]), 0.0f );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v_right$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _v_right$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_right$[ebp+eax], xmm0

; 1014 : 		VectorSet( v_up, 0.0f, 0.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_up$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_up$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _v_up$[ebp+eax], xmm0

; 1015 : 		VectorNormalize( v_right );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm1, DWORD PTR _v_right$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm1, DWORD PTR _v_right$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN34@R_DrawSpri
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN34@R_DrawSpri:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v_right$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _v_right$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _v_right$[ebp+ecx], xmm0

; 1016 : 		break;

	jmp	$LN4@R_DrawSpri
$LN35@R_DrawSpri:

; 1017 : 	case SPR_FWD_PARALLEL_UPRIGHT:
; 1018 : 		dot = RI.vforward[2];

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+224]
	movss	DWORD PTR _dot$[ebp], xmm0

; 1019 : 		if(( dot > 0.999848f ) || ( dot < -0.999848f ))	// cos(1 degree) = 0.999848

	movss	xmm0, DWORD PTR _dot$[ebp]
	comiss	xmm0, DWORD PTR __real@3f7ff60a
	ja	SHORT $LN37@R_DrawSpri
	movss	xmm0, DWORD PTR __real@bf7ff60a
	comiss	xmm0, DWORD PTR _dot$[ebp]
	jbe	SHORT $LN36@R_DrawSpri
$LN37@R_DrawSpri:

; 1020 : 			return; // invisible

	jmp	$LN53@R_DrawSpri
$LN36@R_DrawSpri:

; 1021 : 		VectorSet( v_up, 0.0f, 0.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_up$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_up$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _v_up$[ebp+eax], xmm0

; 1022 : 		VectorSet( v_right, RI.vforward[1], -RI.vforward[0], 0.0f );

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _v_right$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+224]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _v_right$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_right$[ebp+eax], xmm0

; 1023 : 		VectorNormalize( v_right );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm1, DWORD PTR _v_right$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm1, DWORD PTR _v_right$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN38@R_DrawSpri
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN38@R_DrawSpri:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _v_right$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _v_right$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v_right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _v_right$[ebp+ecx], xmm0

; 1024 : 		break;

	jmp	$LN4@R_DrawSpri
$LN39@R_DrawSpri:

; 1025 : 	case SPR_FWD_PARALLEL_ORIENTED:
; 1026 : 		angle = e->angles[ROLL] * (M_PI2 / 360.0f);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR _angle$[ebp], xmm0

; 1027 : 		SinCos( angle, &sr, &cr );

	lea	eax, DWORD PTR _cr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sr$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 1028 : 		for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@R_DrawSpri
$LN6@R_DrawSpri:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@R_DrawSpri:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN7@R_DrawSpri

; 1029 : 		{
; 1030 : 			v_right[i] = (RI.vright[i] * cr + RI.vup[i] * sr);

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _RI[eax*4+236]
	mulss	xmm0, DWORD PTR _cr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _RI[ecx*4+248]
	mulss	xmm1, DWORD PTR _sr$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _v_right$[ebp+edx*4], xmm0

; 1031 : 			v_up[i] = RI.vright[i] * -sr + RI.vup[i] * cr;

	movss	xmm0, DWORD PTR _sr$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax*4+236]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR _RI[ecx*4+248]
	mulss	xmm1, DWORD PTR _cr$[ebp]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _v_up$[ebp+edx*4], xmm0

; 1032 : 		}

	jmp	SHORT $LN6@R_DrawSpri
$LN7@R_DrawSpri:

; 1033 : 		break;

	jmp	$LN4@R_DrawSpri
$LN40@R_DrawSpri:

; 1034 : 	case SPR_FWD_PARALLEL: // normal sprite
; 1035 : 	default:
; 1036 : 		VectorCopy( RI.vright, v_right ); 

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+236]
	mov	DWORD PTR _v_right$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _v_right$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _v_right$[ebp+eax], ecx

; 1037 : 		VectorCopy( RI.vup, v_up );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+248]
	mov	DWORD PTR _v_up$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+248]
	mov	DWORD PTR _v_up$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+248]
	mov	DWORD PTR _v_up$[ebp+eax], ecx
$LN4@R_DrawSpri:

; 1038 : 		break;
; 1039 : 	}
; 1040 : 
; 1041 : 	if( psprite->facecull == SPR_CULL_NONE )

	mov	eax, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LN42@R_DrawSpri

; 1042 : 		GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4
$LN42@R_DrawSpri:

; 1043 : 		
; 1044 : 	if( oldframe == frame )

	mov	eax, DWORD PTR _oldframe$[ebp]
	cmp	eax, DWORD PTR _frame$[ebp]
	jne	$LN43@R_DrawSpri

; 1045 : 	{
; 1046 : 		// draw the single non-lerped frame
; 1047 : 		pglColor4f( color[0], color[1], color[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1048 : 		GL_Bind( GL_TEXTURE0, frame->gl_texturenum );

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1049 : 		R_DrawSpriteQuad( frame, origin, v_right, v_up, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _v_up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	call	_R_DrawSpriteQuad
	add	esp, 20					; 00000014H

; 1050 : 	}

	jmp	$LN46@R_DrawSpri
$LN43@R_DrawSpri:

; 1051 : 	else
; 1052 : 	{
; 1053 : 		// draw two combined lerped frames
; 1054 : 		lerp = bound( 0.0f, lerp, 1.0f );

	movss	xmm0, DWORD PTR _lerp$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN61@R_DrawSpri
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _lerp$[ebp]
	jbe	SHORT $LN59@R_DrawSpri
	movss	xmm0, DWORD PTR _lerp$[ebp]
	movss	DWORD PTR tv534[ebp], xmm0
	jmp	SHORT $LN60@R_DrawSpri
$LN59@R_DrawSpri:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv534[ebp], xmm0
$LN60@R_DrawSpri:
	movss	xmm0, DWORD PTR tv534[ebp]
	movss	DWORD PTR tv535[ebp], xmm0
	jmp	SHORT $LN62@R_DrawSpri
$LN61@R_DrawSpri:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv535[ebp], xmm0
$LN62@R_DrawSpri:
	movss	xmm0, DWORD PTR tv535[ebp]
	movss	DWORD PTR _lerp$[ebp], xmm0

; 1055 : 		ilerp = 1.0f - lerp;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _lerp$[ebp]
	movss	DWORD PTR _ilerp$[ebp], xmm0

; 1056 : 
; 1057 : 		if( ilerp != 0.0f )

	movss	xmm0, DWORD PTR _ilerp$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN45@R_DrawSpri

; 1058 : 		{
; 1059 : 			pglColor4f( color[0], color[1], color[2], tr.blend * ilerp );

	movss	xmm0, DWORD PTR _tr+87592
	mulss	xmm0, DWORD PTR _ilerp$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1060 : 			GL_Bind( GL_TEXTURE0, oldframe->gl_texturenum );

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1061 : 			R_DrawSpriteQuad( oldframe, origin, v_right, v_up, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _v_up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldframe$[ebp]
	push	eax
	call	_R_DrawSpriteQuad
	add	esp, 20					; 00000014H
$LN45@R_DrawSpri:

; 1062 : 		}
; 1063 : 
; 1064 : 		if( lerp != 0.0f )

	movss	xmm0, DWORD PTR _lerp$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN46@R_DrawSpri

; 1065 : 		{
; 1066 : 			pglColor4f( color[0], color[1], color[2], tr.blend * lerp );

	movss	xmm0, DWORD PTR _tr+87592
	mulss	xmm0, DWORD PTR _lerp$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1067 : 			GL_Bind( GL_TEXTURE0, frame->gl_texturenum );

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1068 : 			R_DrawSpriteQuad( frame, origin, v_right, v_up, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _v_up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	call	_R_DrawSpriteQuad
	add	esp, 20					; 00000014H
$LN46@R_DrawSpri:

; 1069 : 		}
; 1070 : 	}
; 1071 : 
; 1072 : 	// draw the sprite 'lightmap' :-)
; 1073 : 	if( R_SpriteHasLightmap( e, psprite->texFormat ))

	mov	eax, DWORD PTR _psprite$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_SpriteHasLightmap
	add	esp, 8
	test	eax, eax
	je	$LN47@R_DrawSpri

; 1074 : 	{
; 1075 : 		if( !r_lightmap->value )

	mov	eax, DWORD PTR _r_lightmap
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN48@R_DrawSpri

; 1076 : 			pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN49@R_DrawSpri
$LN48@R_DrawSpri:

; 1077 : 		else pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN49@R_DrawSpri:

; 1078 : 		pglDepthFunc( GL_EQUAL );

	push	514					; 00000202H
	call	DWORD PTR _pglDepthFunc

; 1079 : 		pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1080 : 		pglBlendFunc( GL_ZERO, GL_SRC_COLOR );

	push	768					; 00000300H
	push	0
	call	DWORD PTR _pglBlendFunc

; 1081 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1082 : 
; 1083 : 		pglColor4f( color2[0], color2[1], color2[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _color2$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color2$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _color2$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1084 : 		GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 1085 : 		R_DrawSpriteQuad( frame, origin, v_right, v_up, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _v_up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	call	_R_DrawSpriteQuad
	add	esp, 20					; 00000014H

; 1086 : 		pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1087 : 		pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc
$LN47@R_DrawSpri:

; 1088 : 	}
; 1089 : 
; 1090 : 	if( psprite->facecull == SPR_CULL_NONE )

	mov	eax, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LN50@R_DrawSpri

; 1091 : 		GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4
$LN50@R_DrawSpri:

; 1092 : 
; 1093 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1094 : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1095 : 
; 1096 : 	if( e->curstate.rendermode == kRenderGlow || e->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 3
	je	SHORT $LN52@R_DrawSpri
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 5
	jne	SHORT $LN51@R_DrawSpri
$LN52@R_DrawSpri:

; 1097 : 		R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN51@R_DrawSpri:

; 1098 : 
; 1099 : 	if( e->curstate.rendermode != kRenderNormal )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN53@R_DrawSpri

; 1100 : 	{
; 1101 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1102 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1103 : 		pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable
$LN53@R_DrawSpri:

; 1104 : 	}
; 1105 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@R_DrawSpri:
	DD	$LN23@R_DrawSpri
	DD	$LN19@R_DrawSpri
	DD	$LN19@R_DrawSpri
	DD	$LN21@R_DrawSpri
	DD	$LN18@R_DrawSpri
	DD	$LN22@R_DrawSpri
$LN64@R_DrawSpri:
	DD	$LN35@R_DrawSpri
	DD	$LN33@R_DrawSpri
	DD	$LN40@R_DrawSpri
	DD	$LN32@R_DrawSpri
	DD	$LN39@R_DrawSpri
_R_DrawSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_GetSpriteFrame
_TEXT	SEGMENT
tv193 = -104						; size = 4
tv70 = -104						; size = 4
_angleframe$1 = -36					; size = 4
_targettime$ = -32					; size = 4
_numframes$ = -28					; size = 4
_i$ = -24						; size = 4
_fullinterval$ = -20					; size = 4
_pintervals$ = -16					; size = 4
_pspriteframe$ = -12					; size = 4
_pspritegroup$ = -8					; size = 4
_psprite$ = -4						; size = 4
_pModel$ = 8						; size = 4
_frame$ = 12						; size = 4
_yaw$ = 16						; size = 4
_R_GetSpriteFrame PROC					; COMDAT

; 480  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 481  : 	msprite_t		*psprite;
; 482  : 	mspritegroup_t	*pspritegroup;
; 483  : 	mspriteframe_t	*pspriteframe = NULL;

	mov	DWORD PTR _pspriteframe$[ebp], 0

; 484  : 	float		*pintervals, fullinterval;
; 485  : 	int		i, numframes;
; 486  : 	float		targettime;
; 487  : 
; 488  : 	Assert( pModel != NULL );

	cmp	DWORD PTR _pModel$[ebp], 0
	je	SHORT $LN16@R_GetSprit
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN17@R_GetSprit
$LN16@R_GetSprit:
	mov	DWORD PTR tv70[ebp], 0
$LN17@R_GetSprit:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_GetSpriteFrame@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@HHNFGLFM@pModel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 489  : 	psprite = pModel->cache.data;

	mov	eax, DWORD PTR _pModel$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _psprite$[ebp], ecx

; 490  : 
; 491  : 	if( frame < 0 )

	cmp	DWORD PTR _frame$[ebp], 0
	jge	SHORT $LN5@R_GetSprit

; 492  : 	{
; 493  : 		frame = 0;

	mov	DWORD PTR _frame$[ebp], 0

; 494  : 	}

	jmp	SHORT $LN7@R_GetSprit
$LN5@R_GetSprit:

; 495  : 	else if( frame >= psprite->numframes )

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jl	SHORT $LN7@R_GetSprit

; 496  : 	{
; 497  : 		if( frame > psprite->numframes )

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jle	SHORT $LN8@R_GetSprit

; 498  : 			Con_Reportf( S_WARN "R_GetSpriteFrame: no such frame %d (%s)\n", frame, pModel->name );

	mov	eax, DWORD PTR _pModel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@IHGAFOLC@?$FO3Warning?3?$FO7?5R_GetSpriteFrame?3?5@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH
$LN8@R_GetSprit:

; 499  : 		frame = psprite->numframes - 1;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR _frame$[ebp], ecx
$LN7@R_GetSprit:

; 500  : 	}
; 501  : 
; 502  : 	if( psprite->frames[frame].type == SPR_SINGLE )

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 0
	jne	SHORT $LN9@R_GetSprit

; 503  : 	{
; 504  : 		pspriteframe = psprite->frames[frame].frameptr;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspriteframe$[ebp], edx

; 505  : 	}

	jmp	$LN14@R_GetSprit
$LN9@R_GetSprit:

; 506  : 	else if( psprite->frames[frame].type == SPR_GROUP ) 

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 1
	jne	$LN11@R_GetSprit

; 507  : 	{
; 508  : 		pspritegroup = (mspritegroup_t *)psprite->frames[frame].frameptr;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 509  : 		pintervals = pspritegroup->intervals;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pintervals$[ebp], ecx

; 510  : 		numframes = pspritegroup->numframes;

	mov	eax, DWORD PTR _pspritegroup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _numframes$[ebp], ecx

; 511  : 		fullinterval = pintervals[numframes-1];

	mov	eax, DWORD PTR _numframes$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	movss	DWORD PTR _fullinterval$[ebp], xmm0

; 512  : 
; 513  : 		// when loading in Mod_LoadSpriteGroup, we guaranteed all interval values
; 514  : 		// are positive, so we don't have to worry about division by zero
; 515  : 		targettime = cl.time - ((int)( cl.time / fullinterval )) * fullinterval;

	cvtss2sd xmm0, DWORD PTR _fullinterval$[ebp]
	movsd	xmm1, QWORD PTR _cl+2167640
	divsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _fullinterval$[ebp]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _targettime$[ebp], xmm0

; 516  : 
; 517  : 		for( i = 0; i < (numframes - 1); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_GetSprit
$LN2@R_GetSprit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_GetSprit:
	mov	eax, DWORD PTR _numframes$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@R_GetSprit

; 518  : 		{
; 519  : 			if( pintervals[i] > targettime )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pintervals$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR _targettime$[ebp]
	jbe	SHORT $LN13@R_GetSprit

; 520  : 				break;

	jmp	SHORT $LN3@R_GetSprit
$LN13@R_GetSprit:

; 521  : 		}

	jmp	SHORT $LN2@R_GetSprit
$LN3@R_GetSprit:

; 522  : 		pspriteframe = pspritegroup->frames[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pspritegroup$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	DWORD PTR _pspriteframe$[ebp], edx

; 523  : 	}

	jmp	$LN14@R_GetSprit
$LN11@R_GetSprit:

; 524  : 	else if( psprite->frames[frame].type == FRAME_ANGLED )

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [ecx+eax*8+28], 2
	jne	$LN14@R_GetSprit

; 525  : 	{
; 526  : 		int	angleframe = (int)(Q_rint(( RI.viewangles[1] - yaw + 45.0f ) / 360 * 8) - 4) & 7;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	subss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@R_GetSprit
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	subss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR tv193[ebp], edx
	jmp	SHORT $LN19@R_GetSprit
$LN18@R_GetSprit:
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	subss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	divss	xmm0, DWORD PTR __real@43b40000
	mulss	xmm0, DWORD PTR __real@41000000
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv193[ebp], ecx
$LN19@R_GetSprit:
	mov	edx, DWORD PTR tv193[ebp]
	sub	edx, 4
	and	edx, 7
	mov	DWORD PTR _angleframe$1[ebp], edx

; 527  : 
; 528  : 		// e.g. doom-style sprite monsters
; 529  : 		pspritegroup = (mspritegroup_t *)psprite->frames[frame].frameptr;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+32]
	mov	DWORD PTR _pspritegroup$[ebp], edx

; 530  : 		pspriteframe = pspritegroup->frames[angleframe];

	mov	eax, DWORD PTR _angleframe$1[ebp]
	mov	ecx, DWORD PTR _pspritegroup$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+8]
	mov	DWORD PTR _pspriteframe$[ebp], edx
$LN14@R_GetSprit:

; 531  : 	}
; 532  : 
; 533  : 	return pspriteframe;

	mov	eax, DWORD PTR _pspriteframe$[ebp]

; 534  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetSpriteFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _Mod_LoadSpriteModel
_TEXT	SEGMENT
tv328 = -116						; size = 4
tv296 = -116						; size = 4
tv257 = -116						; size = 4
tv246 = -116						; size = 4
tv189 = -116						; size = 4
tv178 = -116						; size = 4
_frametype$1 = -48					; size = 4
_pal$2 = -44						; size = 4
_src$3 = -40						; size = 4
_pal$4 = -36						; size = 4
_size$ = -32						; size = 4
_i$ = -28						; size = 4
_psprite$ = -24						; size = 4
_pframetype$ = -20					; size = 4
_numi$ = -16						; size = 4
_pin$ = -12						; size = 4
_pinhl$ = -8						; size = 4
_pinq1$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_texFlags$ = 20						; size = 4
_Mod_LoadSpriteModel PROC				; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 149  : 	dsprite_q1_t	*pinq1;
; 150  : 	dsprite_hl_t	*pinhl;
; 151  : 	dsprite_t		*pin;
; 152  : 	short		*numi = NULL;

	mov	DWORD PTR _numi$[ebp], 0

; 153  : 	dframetype_t	*pframetype;
; 154  : 	msprite_t		*psprite;
; 155  : 	int		i, size;
; 156  : 
; 157  : 	if( loaded ) *loaded = false;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN12@Mod_LoadSp
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN12@Mod_LoadSp:

; 158  : 	pin = (dsprite_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pin$[ebp], eax

; 159  : 	mod->type = mod_sprite;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+68], 1

; 160  : 	r_texFlags = texFlags;

	mov	eax, DWORD PTR _texFlags$[ebp]
	mov	DWORD PTR _r_texFlags, eax

; 161  : 	i = pin->version;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx

; 162  : 
; 163  : 	if( pin->ident != IDSPRITEHEADER )

	mov	eax, DWORD PTR _pin$[ebp]
	cmp	DWORD PTR [eax], 1347634249		; 50534449H
	je	SHORT $LN13@Mod_LoadSp

; 164  : 	{
; 165  : 		Con_DPrintf( S_ERROR "%s has wrong id (%x should be %x)\n", mod->name, pin->ident, IDSPRITEHEADER );

	push	1347634249				; 50534449H
	mov	eax, DWORD PTR _pin$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	push	OFFSET ??_C@_0CO@IIMAFKGP@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5id?5?$CI?$CFx?5@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 166  : 		return;

	jmp	$LN34@Mod_LoadSp
$LN13@Mod_LoadSp:

; 167  : 	}
; 168  : 		
; 169  : 	if( i != SPRITE_VERSION_Q1 && i != SPRITE_VERSION_HL && i != SPRITE_VERSION_32 )

	cmp	DWORD PTR _i$[ebp], 1
	je	SHORT $LN14@Mod_LoadSp
	cmp	DWORD PTR _i$[ebp], 2
	je	SHORT $LN14@Mod_LoadSp
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	je	SHORT $LN14@Mod_LoadSp

; 170  : 	{
; 171  : 		Con_DPrintf( S_ERROR "%s has wrong version number (%i should be %i or %i)\n", mod->name, i, SPRITE_VERSION_Q1, SPRITE_VERSION_HL );

	push	2
	push	1
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EA@GOHDLPMA@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
	call	_Con_DPrintf
	add	esp, 20					; 00000014H

; 172  : 		return;

	jmp	$LN34@Mod_LoadSp
$LN14@Mod_LoadSp:

; 173  : 	}
; 174  : 
; 175  : 	mod->mempool = Mem_AllocPool( va( "^2%s^7", mod->name ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+76], eax

; 176  : 	sprite_version = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _sprite_version, eax

; 177  : 
; 178  : 	if( i == SPRITE_VERSION_Q1 || i == SPRITE_VERSION_32 )

	cmp	DWORD PTR _i$[ebp], 1
	je	SHORT $LN17@Mod_LoadSp
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jne	$LN15@Mod_LoadSp
$LN17@Mod_LoadSp:

; 179  : 	{
; 180  : 		pinq1 = (dsprite_q1_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pinq1$[ebp], eax

; 181  : 		size = sizeof( msprite_t ) + ( pinq1->numframes - 1 ) * sizeof( psprite->frames );

	mov	eax, DWORD PTR _pinq1$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	lea	edx, DWORD PTR [ecx*8+28]
	mov	DWORD PTR _size$[ebp], edx

; 182  : 		psprite = Mem_Calloc( mod->mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _psprite$[ebp], eax

; 183  : 		mod->cache.data = psprite;	// make link to extradata

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 184  : 
; 185  : 		psprite->type = pinq1->type;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinq1$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR [eax], dx

; 186  : 		psprite->texFormat = SPR_ADDITIVE;	//SPR_ALPHTEST;

	mov	eax, 1
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	WORD PTR [ecx+2], ax

; 187  : 		psprite->numframes = mod->numframes = pinq1->numframes;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _pinq1$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+12], edx

; 188  : 		psprite->facecull = SPR_CULL_FRONT;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [eax+20], 0

; 189  : 		psprite->radius = pinq1->boundingradius;

	mov	eax, DWORD PTR _pinq1$[ebp]
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 190  : 		psprite->synctype = pinq1->synctype;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinq1$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+24], edx

; 191  : 
; 192  : 		// LordHavoc: hack to allow sprites to be non-fullbright
; 193  : 		for( i = 0; i < MAX_QPATH && mod->name[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadSp
$LN2@Mod_LoadSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadSp:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@Mod_LoadSp
	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Mod_LoadSp

; 194  : 			if( mod->name[i] == '!' )

	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN18@Mod_LoadSp

; 195  : 				psprite->texFormat = SPR_ALPHTEST;

	mov	eax, 3
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	WORD PTR [ecx+2], ax
$LN18@Mod_LoadSp:
	jmp	SHORT $LN2@Mod_LoadSp
$LN3@Mod_LoadSp:

; 196  : 
; 197  : 		mod->mins[0] = mod->mins[1] = -pinq1->bounds[0] * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinq1$[ebp]
	mov	eax, DWORD PTR [edx+ecx+16]
	neg	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv178[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR [edx+ecx+84], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR [edx+ecx+84], xmm0

; 198  : 		mod->maxs[0] = mod->maxs[1] = pinq1->bounds[0] * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinq1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+16]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv189[ebp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0

; 199  : 		mod->mins[2] = -pinq1->bounds[1] * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinq1$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	neg	edx
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0

; 200  : 		mod->maxs[2] = pinq1->bounds[1] * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinq1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax+16]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [eax+edx+96], xmm0

; 201  : 		numi = NULL;

	mov	DWORD PTR _numi$[ebp], 0

; 202  : 	}

	jmp	$LN19@Mod_LoadSp
$LN15@Mod_LoadSp:

; 203  : 	else if( i == SPRITE_VERSION_HL )

	cmp	DWORD PTR _i$[ebp], 2
	jne	$LN19@Mod_LoadSp

; 204  : 	{
; 205  : 		pinhl = (dsprite_hl_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pinhl$[ebp], eax

; 206  : 		size = sizeof( msprite_t ) + ( pinhl->numframes - 1 ) * sizeof( psprite->frames );

	mov	eax, DWORD PTR _pinhl$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	lea	edx, DWORD PTR [ecx*8+28]
	mov	DWORD PTR _size$[ebp], edx

; 207  : 		psprite = Mem_Calloc( mod->mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadSpriteModel@@9@9
	add	eax, 59					; 0000003bH
	push	eax
	push	OFFSET ??_C@_0DG@OHJLMIPE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _psprite$[ebp], eax

; 208  : 		mod->cache.data = psprite;	// make link to extradata

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [eax+388], ecx

; 209  : 
; 210  : 		psprite->type = pinhl->type;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	dx, WORD PTR [ecx+8]
	mov	WORD PTR [eax], dx

; 211  : 		psprite->texFormat = pinhl->texFormat;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	dx, WORD PTR [ecx+12]
	mov	WORD PTR [eax+2], dx

; 212  : 		psprite->numframes = mod->numframes = pinhl->numframes;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+12], edx

; 213  : 		psprite->facecull = pinhl->facetype;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+20], edx

; 214  : 		psprite->radius = pinhl->boundingradius;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 215  : 		psprite->synctype = pinhl->synctype;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+24], edx

; 216  : 
; 217  : 		mod->mins[0] = mod->mins[1] = -pinhl->bounds[0] * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinhl$[ebp]
	mov	eax, DWORD PTR [edx+ecx+20]
	neg	eax
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv246[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR [edx+ecx+84], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR [edx+ecx+84], xmm0

; 218  : 		mod->maxs[0] = mod->maxs[1] = pinhl->bounds[0] * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pinhl$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+20]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv257[ebp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv257[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR tv257[ebp]
	movss	DWORD PTR [ecx+eax+96], xmm0

; 219  : 		mod->mins[2] = -pinhl->bounds[1] * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinhl$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	neg	edx
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [ecx+eax+84], xmm0

; 220  : 		mod->maxs[2] = pinhl->bounds[1] * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pinhl$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax+20]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _mod$[ebp]
	movss	DWORD PTR [eax+edx+96], xmm0

; 221  : 		numi = (short *)(pinhl + 1);

	mov	eax, DWORD PTR _pinhl$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _numi$[ebp], eax
$LN19@Mod_LoadSp:

; 222  : 	}
; 223  : 
; 224  : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN20@Mod_LoadSp

; 225  : 	{
; 226  : 		// skip frames loading
; 227  : 		if( loaded ) *loaded = true;	// done

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN21@Mod_LoadSp
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN21@Mod_LoadSp:

; 228  : 		psprite->numframes = 0;

	mov	eax, DWORD PTR _psprite$[ebp]
	mov	DWORD PTR [eax+12], 0

; 229  : 		return;

	jmp	$LN34@Mod_LoadSp
$LN20@Mod_LoadSp:

; 230  : 	}
; 231  : 
; 232  : 	Q_strncpy( sprite_name, mod->name, sizeof( sprite_name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET _sprite_name
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 233  : 	COM_StripExtension( sprite_name );

	push	OFFSET _sprite_name
	call	_COM_StripExtension
	add	esp, 4

; 234  : 
; 235  : 	if( numi == NULL )

	cmp	DWORD PTR _numi$[ebp], 0
	jne	SHORT $LN22@Mod_LoadSp

; 236  : 	{
; 237  : 		rgbdata_t	*pal;
; 238  : 	
; 239  : 		pal = FS_LoadImage( "#id.pal", (byte *)&i, 768 );

	push	768					; 00000300H
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_07PFPMLFBM@?$CDid?4pal@
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pal$4[ebp], eax

; 240  : 		pframetype = (dframetype_t *)(pinq1 + 1);

	mov	eax, DWORD PTR _pinq1$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _pframetype$[ebp], eax

; 241  : 		FS_FreeImage( pal ); // palette installed, no reason to keep this data

	mov	eax, DWORD PTR _pal$4[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 242  : 	}

	jmp	$LN25@Mod_LoadSp
$LN22@Mod_LoadSp:

; 243  : 	else if( *numi == 256 )

	mov	eax, DWORD PTR _numi$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 256				; 00000100H
	jne	$LN24@Mod_LoadSp

; 244  : 	{	
; 245  : 		byte	*src = (byte *)(numi+1);

	mov	eax, DWORD PTR _numi$[ebp]
	add	eax, 2
	mov	DWORD PTR _src$3[ebp], eax

; 246  : 		rgbdata_t	*pal;
; 247  : 	
; 248  : 		// install palette
; 249  : 		switch( psprite->texFormat )

	mov	eax, DWORD PTR _psprite$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR tv296[ebp], ecx
	cmp	DWORD PTR tv296[ebp], 2
	je	SHORT $LN26@Mod_LoadSp
	cmp	DWORD PTR tv296[ebp], 3
	je	SHORT $LN27@Mod_LoadSp
	jmp	SHORT $LN28@Mod_LoadSp
$LN26@Mod_LoadSp:

; 250  : 		{
; 251  :                     case SPR_INDEXALPHA:
; 252  : 			pal = FS_LoadImage( "#gradient.pal", src, 768 ); 

	push	768					; 00000300H
	mov	eax, DWORD PTR _src$3[ebp]
	push	eax
	push	OFFSET ??_C@_0O@NLIEKAKO@?$CDgradient?4pal@
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pal$2[ebp], eax

; 253  : 			break;

	jmp	SHORT $LN5@Mod_LoadSp
$LN27@Mod_LoadSp:

; 254  : 		case SPR_ALPHTEST:		
; 255  : 			pal = FS_LoadImage( "#masked.pal", src, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR _src$3[ebp]
	push	eax
	push	OFFSET ??_C@_0M@NFDHFNFP@?$CDmasked?4pal@
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pal$2[ebp], eax

; 256  :                               break;

	jmp	SHORT $LN5@Mod_LoadSp
$LN28@Mod_LoadSp:

; 257  : 		default:
; 258  : 			pal = FS_LoadImage( "#normal.pal", src, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR _src$3[ebp]
	push	eax
	push	OFFSET ??_C@_0M@JLBELAFH@?$CDnormal?4pal@
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pal$2[ebp], eax
$LN5@Mod_LoadSp:

; 259  : 			break;
; 260  : 		}
; 261  : 
; 262  : 		pframetype = (dframetype_t *)(src + 768);

	mov	eax, DWORD PTR _src$3[ebp]
	add	eax, 768				; 00000300H
	mov	DWORD PTR _pframetype$[ebp], eax

; 263  : 		FS_FreeImage( pal ); // palette installed, no reason to keep this data

	mov	eax, DWORD PTR _pal$2[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 264  : 	}

	jmp	SHORT $LN25@Mod_LoadSp
$LN24@Mod_LoadSp:

; 265  : 	else 
; 266  : 	{
; 267  : 		Con_DPrintf( S_ERROR "%s has wrong number of palette colors %i (should be 256)\n", mod->name, *numi );

	mov	eax, DWORD PTR _numi$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	push	OFFSET ??_C@_0EF@NOOIKKKL@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5number?5@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 268  : 		return;

	jmp	$LN34@Mod_LoadSp
$LN25@Mod_LoadSp:

; 269  : 	}
; 270  : 
; 271  : 	if( mod->numframes < 1 )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+72], 1
	jge	SHORT $LN29@Mod_LoadSp

; 272  : 		return;

	jmp	$LN34@Mod_LoadSp
$LN29@Mod_LoadSp:

; 273  : 
; 274  : 	for( i = 0; i < mod->numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Mod_LoadSp
$LN7@Mod_LoadSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Mod_LoadSp:
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN8@Mod_LoadSp

; 275  : 	{
; 276  : 		frametype_t frametype = pframetype->type;

	mov	eax, DWORD PTR _pframetype$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _frametype$1[ebp], ecx

; 277  : 		psprite->frames[i].type = frametype;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psprite$[ebp]
	mov	edx, DWORD PTR _frametype$1[ebp]
	mov	DWORD PTR [ecx+eax*8+28], edx

; 278  : 
; 279  : 		switch( frametype )

	mov	eax, DWORD PTR _frametype$1[ebp]
	mov	DWORD PTR tv328[ebp], eax
	cmp	DWORD PTR tv328[ebp], 0
	je	SHORT $LN30@Mod_LoadSp
	cmp	DWORD PTR tv328[ebp], 1
	je	SHORT $LN31@Mod_LoadSp
	cmp	DWORD PTR tv328[ebp], 2
	je	SHORT $LN32@Mod_LoadSp
	jmp	$LN10@Mod_LoadSp
$LN30@Mod_LoadSp:

; 280  : 		{
; 281  : 		case FRAME_SINGLE:
; 282  : 			Q_strncpy( group_suffix, "frame", sizeof( group_suffix ));

	push	8
	push	OFFSET ??_C@_05MIJNFGED@frame@
	push	OFFSET _group_suffix
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 283  : 			pframetype = R_SpriteLoadFrame( mod, pframetype + 1, &psprite->frames[i].frameptr, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+32]
	push	eax
	mov	ecx, DWORD PTR _pframetype$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_SpriteLoadFrame
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pframetype$[ebp], eax

; 284  : 			break;

	jmp	SHORT $LN10@Mod_LoadSp
$LN31@Mod_LoadSp:

; 285  : 		case FRAME_GROUP:
; 286  : 			Q_strncpy( group_suffix, "group", sizeof( group_suffix ));

	push	8
	push	OFFSET ??_C@_05MGJOOGAJ@group@
	push	OFFSET _group_suffix
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 287  : 			pframetype = R_SpriteLoadGroup( mod, pframetype + 1, &psprite->frames[i].frameptr, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+32]
	push	eax
	mov	ecx, DWORD PTR _pframetype$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_SpriteLoadGroup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pframetype$[ebp], eax

; 288  : 			break;

	jmp	SHORT $LN10@Mod_LoadSp
$LN32@Mod_LoadSp:

; 289  : 		case FRAME_ANGLED:
; 290  : 			Q_strncpy( group_suffix, "angle", sizeof( group_suffix ));

	push	8
	push	OFFSET ??_C@_05FECBCJJD@angle@
	push	OFFSET _group_suffix
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 291  : 			pframetype = R_SpriteLoadGroup( mod, pframetype + 1, &psprite->frames[i].frameptr, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _psprite$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+32]
	push	eax
	mov	ecx, DWORD PTR _pframetype$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_SpriteLoadGroup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pframetype$[ebp], eax
$LN10@Mod_LoadSp:

; 292  : 			break;
; 293  : 		}
; 294  : 		if( pframetype == NULL ) break; // technically an error

	cmp	DWORD PTR _pframetype$[ebp], 0
	jne	SHORT $LN33@Mod_LoadSp
	jmp	SHORT $LN8@Mod_LoadSp
$LN33@Mod_LoadSp:

; 295  : 	}

	jmp	$LN7@Mod_LoadSp
$LN8@Mod_LoadSp:

; 296  : 
; 297  : 	if( loaded ) *loaded = true;	// done

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN34@Mod_LoadSp
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN34@Mod_LoadSp:

; 298  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_sprite.c
;	COMDAT _R_SpriteInit
_TEXT	SEGMENT
_R_SpriteInit PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 45   : 	r_sprite_lerping = Cvar_Get( "r_sprite_lerping", "1", FCVAR_ARCHIVE, "enables sprite animation lerping" );

	push	OFFSET ??_C@_0CB@OLLAHFAA@enables?5sprite?5animation?5lerpin@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BB@EJMBDKPM@r_sprite_lerping@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_sprite_lerping, eax

; 46   : 	r_sprite_lighting = Cvar_Get( "r_sprite_lighting", "1", FCVAR_ARCHIVE, "enables sprite lighting (blood etc)" );

	push	OFFSET ??_C@_0CE@NHCOJABC@enables?5sprite?5lighting?5?$CIblood?5@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BC@BJEEPELI@r_sprite_lighting@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_sprite_lighting, eax

; 47   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SpriteInit ENDP
_TEXT	ENDS
END
