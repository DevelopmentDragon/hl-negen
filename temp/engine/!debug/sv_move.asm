; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_move.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_MoveStep
PUBLIC	_SV_MoveTest
PUBLIC	_SV_MoveToOrigin
PUBLIC	_SV_CheckBottom
PUBLIC	_SV_VecToYaw
PUBLIC	_SV_WaterMove
PUBLIC	_SV_StepDirection
PUBLIC	_SV_FlyDirection
PUBLIC	_SV_NewChaseDir
PUBLIC	??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@	; `string'
PUBLIC	??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@	; `string'
PUBLIC	??_C@_0BE@FLMLMHEC@player?1pl_wade3?4wav@	; `string'
PUBLIC	??_C@_0BE@EGMOPHPK@player?1pl_wade4?4wav@	; `string'
PUBLIC	?__LINE__Var@?0??SV_MoveStep@@9@9		; `SV_MoveStep'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@PIDELKIF@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fc99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@400921fb60000000
PUBLIC	__real@4028000000000000
PUBLIC	__real@4066800000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@41f00000
PUBLIC	__real@42200000
PUBLIC	__real@42340000
PUBLIC	__real@42b40000
PUBLIC	__real@43070000
PUBLIC	__real@43340000
PUBLIC	__real@43570000
PUBLIC	__real@43870000
PUBLIC	__real@439d8000
PUBLIC	__real@43b40000
PUBLIC	__real@bf4ccccd
PUBLIC	__real@bf800000
PUBLIC	__real@c1200000
EXTRN	_SV_StartSound:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_atan2:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_SinCos:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_MoveNoEnts:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf4ccccd
CONST	SEGMENT
__real@bf4ccccd DD 0bf4ccccdr			; -0.8
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@439d8000
CONST	SEGMENT
__real@439d8000 DD 0439d8000r			; 315
CONST	ENDS
;	COMDAT __real@43870000
CONST	SEGMENT
__real@43870000 DD 043870000r			; 270
CONST	ENDS
;	COMDAT __real@43570000
CONST	SEGMENT
__real@43570000 DD 043570000r			; 215
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43070000
CONST	SEGMENT
__real@43070000 DD 043070000r			; 135
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT __real@400921fb60000000
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc99999a0000000
CONST	SEGMENT
__real@3fc99999a0000000 DQ 03fc99999a0000000r	; 0.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DE@PIDELKIF@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@PIDELKIF@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_move.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_MoveStep@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_MoveStep@@9@9 DD 0ffH		; `SV_MoveStep'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@EGMOPHPK@player?1pl_wade4?4wav@
CONST	SEGMENT
??_C@_0BE@EGMOPHPK@player?1pl_wade4?4wav@ DB 'player/pl_wade4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FLMLMHEC@player?1pl_wade3?4wav@
CONST	SEGMENT
??_C@_0BE@FLMLMHEC@player?1pl_wade3?4wav@ DB 'player/pl_wade3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@
CONST	SEGMENT
??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@
CONST	SEGMENT
??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0579H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0673H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02e7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	07b8H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_NewChaseDir
_TEXT	SEGMENT
tv326 = -124						; size = 8
tv415 = -116						; size = 8
tv321 = -108						; size = 8
tv151 = -104						; size = 4
tv147 = -104						; size = 4
_d$ = -36						; size = 12
_turnaround$ = -24					; size = 4
_olddir$ = -20						; size = 4
_tempdir$ = -16						; size = 4
_deltay$ = -12						; size = 4
_deltax$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_actor$ = 8						; size = 4
_destination$ = 12					; size = 4
_dist$ = 16						; size = 4
_SV_NewChaseDir PROC					; COMDAT

; 459  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 460  : 	float	deltax, deltay;
; 461  : 	float	tempdir, olddir, turnaround;
; 462  : 	vec3_t	d;
; 463  : 
; 464  : 	olddir = anglemod(((int)( actor->v.ideal_yaw / 45.0f )) * 45.0f );

	mov	eax, DWORD PTR _actor$[ebp]
	movss	xmm0, DWORD PTR [eax+300]
	divss	xmm0, DWORD PTR __real@42340000
	cvttss2si ecx, xmm0
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@42340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	fstp	DWORD PTR _olddir$[ebp]

; 465  : 	turnaround = anglemod( olddir - 180.0f );

	movss	xmm0, DWORD PTR _olddir$[ebp]
	subss	xmm0, DWORD PTR __real@43340000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	fstp	DWORD PTR _turnaround$[ebp]

; 466  : 
; 467  : 	deltax = destination[0] - actor->v.origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _destination$[ebp]
	mov	esi, DWORD PTR _actor$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+136]
	movss	DWORD PTR _deltax$[ebp], xmm0

; 468  : 	deltay = destination[1] - actor->v.origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _destination$[ebp]
	mov	esi, DWORD PTR _actor$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+136]
	movss	DWORD PTR _deltay$[ebp], xmm0

; 469  : 
; 470  : 	if( deltax > 10.0f )

	movss	xmm0, DWORD PTR _deltax$[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN8@SV_NewChas

; 471  : 		d[1] = 0.0f;

	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _d$[ebp+eax], xmm0
	jmp	SHORT $LN11@SV_NewChas
$LN8@SV_NewChas:

; 472  : 	else if( deltax < -10.0f )

	movss	xmm0, DWORD PTR __real@c1200000
	comiss	xmm0, DWORD PTR _deltax$[ebp]
	jbe	SHORT $LN10@SV_NewChas

; 473  : 		d[1] = 180.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR _d$[ebp+eax], xmm0
	jmp	SHORT $LN11@SV_NewChas
$LN10@SV_NewChas:

; 474  : 	else d[1] = -1;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _d$[ebp+eax], xmm0
$LN11@SV_NewChas:

; 475  : 
; 476  : 	if( deltay < -10.0f )

	movss	xmm0, DWORD PTR __real@c1200000
	comiss	xmm0, DWORD PTR _deltay$[ebp]
	jbe	SHORT $LN12@SV_NewChas

; 477  : 		d[2] = 270.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@43870000
	movss	DWORD PTR _d$[ebp+eax], xmm0
	jmp	SHORT $LN15@SV_NewChas
$LN12@SV_NewChas:

; 478  : 	else if( deltay > 10.0f )

	movss	xmm0, DWORD PTR _deltay$[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN14@SV_NewChas

; 479  : 		d[2] = 90.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _d$[ebp+eax], xmm0
	jmp	SHORT $LN15@SV_NewChas
$LN14@SV_NewChas:

; 480  : 	else d[2] = -1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _d$[ebp+eax], xmm0
$LN15@SV_NewChas:

; 481  : 
; 482  : 	// try direct route
; 483  : 	if( d[1] != -1.0f && d[2] != -1.0f )

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN19@SV_NewChas
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN19@SV_NewChas

; 484  : 	{
; 485  : 		if( d[1] == 0.0f )

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_NewChas

; 486  : 			tempdir = ( d[2] == 90.0f ) ? 45.0f : 315.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@42b40000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@SV_NewChas
	movss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN33@SV_NewChas
$LN32@SV_NewChas:
	movss	xmm0, DWORD PTR __real@439d8000
	movss	DWORD PTR tv147[ebp], xmm0
$LN33@SV_NewChas:
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR _tempdir$[ebp], xmm0
	jmp	SHORT $LN18@SV_NewChas
$LN17@SV_NewChas:

; 487  : 		else tempdir = ( d[2] == 90.0f ) ? 135.0f : 215.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@42b40000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN34@SV_NewChas
	movss	xmm0, DWORD PTR __real@43070000
	movss	DWORD PTR tv151[ebp], xmm0
	jmp	SHORT $LN35@SV_NewChas
$LN34@SV_NewChas:
	movss	xmm0, DWORD PTR __real@43570000
	movss	DWORD PTR tv151[ebp], xmm0
$LN35@SV_NewChas:
	movss	xmm0, DWORD PTR tv151[ebp]
	movss	DWORD PTR _tempdir$[ebp], xmm0
$LN18@SV_NewChas:

; 488  : 
; 489  : 		if( tempdir != turnaround && SV_StepDirection( actor, tempdir, dist ))

	movss	xmm0, DWORD PTR _tempdir$[ebp]
	ucomiss	xmm0, DWORD PTR _turnaround$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@SV_NewChas

; 490  : 			return;

	jmp	$LN30@SV_NewChas
$LN19@SV_NewChas:

; 491  : 	}
; 492  : 
; 493  : 	// try other directions
; 494  : 	if( COM_RandomLong( 0, 1 ) != 0 || fabs( deltay ) > fabs( deltax ))

	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@SV_NewChas
	cvtss2sd xmm0, DWORD PTR _deltay$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv321[ebp]
	movsd	xmm0, QWORD PTR tv321[ebp]
	cvtss2sd xmm1, DWORD PTR _deltax$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv415[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv326[ebp]
	movsd	xmm0, QWORD PTR tv415[ebp]
	comisd	xmm0, QWORD PTR tv326[ebp]
	jbe	SHORT $LN20@SV_NewChas
$LN21@SV_NewChas:

; 495  : 	{
; 496  : 		tempdir = d[1];

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	movss	DWORD PTR _tempdir$[ebp], xmm0

; 497  : 		d[1] = d[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _d$[ebp+eax]
	mov	DWORD PTR _d$[ebp+ecx], edx

; 498  : 		d[2] = tempdir;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	movss	DWORD PTR _d$[ebp+eax], xmm0
$LN20@SV_NewChas:

; 499  : 	}
; 500  : 
; 501  : 	if( d[1] != -1.0f && d[1] != turnaround && SV_StepDirection( actor, d[1], dist ))

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@SV_NewChas
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _turnaround$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _actor$[ebp]
	push	ecx
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN22@SV_NewChas

; 502  : 		return;

	jmp	$LN30@SV_NewChas
$LN22@SV_NewChas:

; 503  : 
; 504  : 	if( d[2] != -1.0f && d[2] != turnaround && SV_StepDirection( actor, d[2], dist ))

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@SV_NewChas
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _turnaround$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _d$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _actor$[ebp]
	push	ecx
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@SV_NewChas

; 505  : 		return;

	jmp	$LN30@SV_NewChas
$LN23@SV_NewChas:

; 506  : 
; 507  : 	// there is no direct path to the player, so pick another direction
; 508  : 	if( olddir != -1.0f && SV_StepDirection( actor, olddir, dist ))

	movss	xmm0, DWORD PTR _olddir$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _olddir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@SV_NewChas

; 509  : 		return;

	jmp	$LN30@SV_NewChas
$LN24@SV_NewChas:

; 510  : 
; 511  : 	// fine, just run somewhere.
; 512  : 	if( COM_RandomLong( 0, 1 ) != 1 )

	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 1
	je	SHORT $LN25@SV_NewChas

; 513  : 	{
; 514  : 		for( tempdir = 0; tempdir <= 315.0f; tempdir += 45.0f )

	xorps	xmm0, xmm0
	movss	DWORD PTR _tempdir$[ebp], xmm0
	jmp	SHORT $LN4@SV_NewChas
$LN2@SV_NewChas:
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	addss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR _tempdir$[ebp], xmm0
$LN4@SV_NewChas:
	movss	xmm0, DWORD PTR __real@439d8000
	comiss	xmm0, DWORD PTR _tempdir$[ebp]
	jb	SHORT $LN3@SV_NewChas

; 515  : 		{
; 516  : 			if( tempdir != turnaround && SV_StepDirection( actor, tempdir, dist ))

	movss	xmm0, DWORD PTR _tempdir$[ebp]
	ucomiss	xmm0, DWORD PTR _turnaround$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN27@SV_NewChas

; 517  : 				return;

	jmp	$LN30@SV_NewChas
$LN27@SV_NewChas:

; 518  : 		}

	jmp	SHORT $LN2@SV_NewChas
$LN3@SV_NewChas:

; 519  : 	}

	jmp	SHORT $LN6@SV_NewChas
$LN25@SV_NewChas:

; 520  : 	else
; 521  : 	{
; 522  : 		for( tempdir = 315.0f; tempdir >= 0.0f; tempdir -= 45.0f )

	movss	xmm0, DWORD PTR __real@439d8000
	movss	DWORD PTR _tempdir$[ebp], xmm0
	jmp	SHORT $LN7@SV_NewChas
$LN5@SV_NewChas:
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	subss	xmm0, DWORD PTR __real@42340000
	movss	DWORD PTR _tempdir$[ebp], xmm0
$LN7@SV_NewChas:
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@SV_NewChas

; 523  : 		{
; 524  : 			if( tempdir != turnaround && SV_StepDirection( actor, tempdir, dist ))

	movss	xmm0, DWORD PTR _tempdir$[ebp]
	ucomiss	xmm0, DWORD PTR _turnaround$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempdir$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN28@SV_NewChas

; 525  : 				return;

	jmp	SHORT $LN30@SV_NewChas
$LN28@SV_NewChas:

; 526  : 		}

	jmp	SHORT $LN5@SV_NewChas
$LN6@SV_NewChas:

; 527  : 	}
; 528  : 
; 529  : 	// we tried. run backwards. that ought to work...
; 530  : 	if( turnaround != -1.0f && SV_StepDirection( actor, turnaround, dist ))

	movss	xmm0, DWORD PTR _turnaround$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@SV_NewChas
	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _turnaround$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN29@SV_NewChas

; 531  : 		return;

	jmp	SHORT $LN30@SV_NewChas
$LN29@SV_NewChas:

; 532  : 
; 533  : 	// well, we're stuck somehow.
; 534  : 	actor->v.ideal_yaw = olddir;

	mov	eax, DWORD PTR _actor$[ebp]
	movss	xmm0, DWORD PTR _olddir$[ebp]
	movss	DWORD PTR [eax+300], xmm0

; 535  : 
; 536  : 	// if a bridge was pulled out from underneath a monster, it may not have
; 537  : 	// a valid standing position at all.
; 538  : 	if( !SV_CheckBottom( actor, WALKMOVE_NORMAL ))

	push	0
	mov	eax, DWORD PTR _actor$[ebp]
	push	eax
	call	_SV_CheckBottom
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@SV_NewChas

; 539  : 	{
; 540  : 		actor->v.flags |= FL_PARTIALGROUND;

	mov	eax, DWORD PTR _actor$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _actor$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN30@SV_NewChas:

; 541  : 	}
; 542  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_NewChaseDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_FlyDirection
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_ent$ = 8						; size = 4
_move$ = 12						; size = 4
_SV_FlyDirection PROC					; COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 450  : 	int	ret;
; 451  : 
; 452  : 	ret = SV_MoveStep( ent, move, false );

	push	0
	mov	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 453  : 	SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 454  : 
; 455  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FlyDirection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_StepDirection
_TEXT	SEGMENT
_move$ = -28						; size = 12
_cCos$ = -16						; size = 4
_cSin$ = -12						; size = 4
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_yaw$ = 12						; size = 4
_dist$ = 16						; size = 4
_SV_StepDirection PROC					; COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 434  : 	int	ret;
; 435  : 	float	cSin, cCos;
; 436  : 	vec3_t	move;
; 437  : 
; 438  : 	yaw = yaw * M_PI2 / 360.0f;

	movss	xmm0, DWORD PTR _yaw$[ebp]
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0

; 439  : 	SinCos( yaw, &cSin, &cCos );

	lea	eax, DWORD PTR _cCos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cSin$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _yaw$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 440  : 	VectorSet( move, cCos * dist, cSin * dist, 0.0f );

	movss	xmm0, DWORD PTR _cCos$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	movss	xmm0, DWORD PTR _cSin$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _move$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _move$[ebp+eax], xmm0

; 441  : 
; 442  : 	ret = SV_MoveStep( ent, move, false );

	push	0
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_MoveStep
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$[ebp], eax

; 443  : 	SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 444  : 
; 445  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 446  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_StepDirection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_WaterMove
_TEXT	SEGMENT
tv76 = -88						; size = 8
tv299 = -84						; size = 4
tv214 = -84						; size = 4
tv146 = -84						; size = 4
_flags$ = -16						; size = 4
_watertype$ = -12					; size = 4
_waterlevel$ = -8					; size = 4
_drownlevel$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_WaterMove PROC					; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 108  : 	float	drownlevel;
; 109  : 	int	waterlevel;
; 110  : 	int	watertype;
; 111  : 	int	flags;
; 112  : 
; 113  : 	if( ent->v.movetype == MOVETYPE_NOCLIP )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 8
	jne	SHORT $LN6@SV_WaterMo

; 114  : 	{
; 115  : 		ent->v.air_finished = sv.time + 12.0f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@4028000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+732], xmm0

; 116  : 		return;

	jmp	$LN35@SV_WaterMo
$LN6@SV_WaterMo:

; 117  : 	}
; 118  : 
; 119  : 	// no watermove for monsters but pushables
; 120  : 	if(( ent->v.flags & FL_MONSTER ) && ent->v.health <= 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 32					; 00000020H
	je	SHORT $LN7@SV_WaterMo
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+520]
	jb	SHORT $LN7@SV_WaterMo

; 121  : 		return;

	jmp	$LN35@SV_WaterMo
$LN7@SV_WaterMo:

; 122  : 
; 123  : 	drownlevel = (ent->v.deadflag == DEAD_NO) ? 3.0 : 1.0;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+604], 0
	jne	SHORT $LN37@SV_WaterMo
	movsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN38@SV_WaterMo
$LN37@SV_WaterMo:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv76[ebp], xmm0
$LN38@SV_WaterMo:
	cvtsd2ss xmm0, QWORD PTR tv76[ebp]
	movss	DWORD PTR _drownlevel$[ebp], xmm0

; 124  : 	waterlevel = ent->v.waterlevel;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR _waterlevel$[ebp], ecx

; 125  : 	watertype = ent->v.watertype;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+676]
	mov	DWORD PTR _watertype$[ebp], ecx

; 126  : 	flags = ent->v.flags;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	mov	DWORD PTR _flags$[ebp], ecx

; 127  : 
; 128  : 	if( !( flags & ( FL_IMMUNE_WATER|FL_GODMODE )))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 131136				; 00020040H
	jne	$LN10@SV_WaterMo

; 129  : 	{
; 130  : 		if((( flags & FL_SWIM ) && waterlevel > drownlevel ) || waterlevel <= drownlevel )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN12@SV_WaterMo
	cvtsi2ss xmm0, DWORD PTR _waterlevel$[ebp]
	comiss	xmm0, DWORD PTR _drownlevel$[ebp]
	ja	SHORT $LN11@SV_WaterMo
$LN12@SV_WaterMo:
	cvtsi2ss xmm0, DWORD PTR _waterlevel$[ebp]
	movss	xmm1, DWORD PTR _drownlevel$[ebp]
	comiss	xmm1, xmm0
	jb	$LN9@SV_WaterMo
$LN11@SV_WaterMo:

; 131  : 		{
; 132  : 			if( ent->v.air_finished > sv.time && ent->v.pain_finished > sv.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+732]
	comisd	xmm0, QWORD PTR _sv+16
	jbe	SHORT $LN13@SV_WaterMo
	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+736]
	comisd	xmm0, QWORD PTR _sv+16
	jbe	SHORT $LN13@SV_WaterMo

; 133  : 			{
; 134  : 				ent->v.dmg += 2;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+704]
	addss	xmm0, DWORD PTR __real@40000000
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+704], xmm0

; 135  : 
; 136  : 				if( ent->v.dmg < 15 )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	comiss	xmm0, DWORD PTR [eax+704]
	jbe	SHORT $LN14@SV_WaterMo

; 137  : 					ent->v.dmg = 10; // quake1 original code

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+704], xmm0
$LN14@SV_WaterMo:

; 138  : 				ent->v.pain_finished = sv.time + 1.0f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+736], xmm0
$LN13@SV_WaterMo:

; 139  : 			}
; 140  : 		}

	jmp	SHORT $LN10@SV_WaterMo
$LN9@SV_WaterMo:

; 141  : 		else
; 142  : 		{
; 143  : 			ent->v.air_finished = sv.time + 12.0f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@4028000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+732], xmm0

; 144  : 			ent->v.dmg = 2;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+704], xmm0
$LN10@SV_WaterMo:

; 145  : 		}
; 146  : 	}
; 147  : 
; 148  : 	if( !waterlevel )

	cmp	DWORD PTR _waterlevel$[ebp], 0
	jne	$LN15@SV_WaterMo

; 149  : 	{
; 150  : 		if( flags & FL_INWATER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	$LN16@SV_WaterMo

; 151  : 		{
; 152  : 			// leave the water.
; 153  : 			switch( COM_RandomLong( 0, 3 ))

	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	cmp	DWORD PTR tv146[ebp], 3
	ja	$LN2@SV_WaterMo
	mov	eax, DWORD PTR tv146[ebp]
	jmp	DWORD PTR $LN39@SV_WaterMo[eax*4]
$LN17@SV_WaterMo:

; 154  : 			{
; 155  : 			case 0:
; 156  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade1.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 157  : 				break;

	jmp	$LN2@SV_WaterMo
$LN18@SV_WaterMo:

; 158  : 			case 1:
; 159  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade2.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 160  : 				break;

	jmp	SHORT $LN2@SV_WaterMo
$LN19@SV_WaterMo:

; 161  : 			case 2:
; 162  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade3.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@FLMLMHEC@player?1pl_wade3?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 163  : 				break;

	jmp	SHORT $LN2@SV_WaterMo
$LN20@SV_WaterMo:

; 164  : 			case 3:
; 165  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade4.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@EGMOPHPK@player?1pl_wade4?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH
$LN2@SV_WaterMo:

; 166  : 				break;
; 167  : 			}
; 168  : 
; 169  : 			ent->v.flags = flags & ~FL_INWATER;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+656], eax
$LN16@SV_WaterMo:

; 170  : 		}
; 171  : 
; 172  : 		ent->v.air_finished = sv.time + 12.0f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@4028000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+732], xmm0

; 173  : 		return;

	jmp	$LN35@SV_WaterMo
$LN15@SV_WaterMo:

; 174  : 	}
; 175  : 
; 176  : 	if( watertype == CONTENTS_LAVA )

	cmp	DWORD PTR _watertype$[ebp], -5		; fffffffbH
	jne	SHORT $LN21@SV_WaterMo

; 177  : 	{
; 178  : 		if((!( flags & ( FL_IMMUNE_LAVA|FL_GODMODE ))) && ent->v.dmgtime < sv.time )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 524352				; 00080040H
	jne	SHORT $LN25@SV_WaterMo
	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+708]
	movsd	xmm1, QWORD PTR _sv+16
	comisd	xmm1, xmm0
	jbe	SHORT $LN25@SV_WaterMo

; 179  : 		{
; 180  : 			if( ent->v.radsuit_finished < sv.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+740]
	movsd	xmm1, QWORD PTR _sv+16
	comisd	xmm1, xmm0
	jbe	SHORT $LN24@SV_WaterMo

; 181  : 				ent->v.dmgtime = sv.time + 0.2f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@3fc99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+708], xmm0
	jmp	SHORT $LN25@SV_WaterMo
$LN24@SV_WaterMo:

; 182  : 			else ent->v.dmgtime = sv.time + 1.0f;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+708], xmm0
$LN25@SV_WaterMo:

; 183  : 		}
; 184  : 	}

	jmp	SHORT $LN28@SV_WaterMo
$LN21@SV_WaterMo:

; 185  : 	else if( watertype == CONTENTS_SLIME )

	cmp	DWORD PTR _watertype$[ebp], -4		; fffffffcH
	jne	SHORT $LN28@SV_WaterMo

; 186  : 	{
; 187  : 		if((!( flags & ( FL_IMMUNE_SLIME|FL_GODMODE ))) && ent->v.dmgtime < sv.time )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 262208				; 00040040H
	jne	SHORT $LN28@SV_WaterMo
	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+708]
	movsd	xmm1, QWORD PTR _sv+16
	comisd	xmm1, xmm0
	jbe	SHORT $LN28@SV_WaterMo

; 188  : 		{
; 189  : 			if( ent->v.radsuit_finished < sv.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+740]
	movsd	xmm1, QWORD PTR _sv+16
	comisd	xmm1, xmm0
	jbe	SHORT $LN28@SV_WaterMo

; 190  : 				ent->v.dmgtime = sv.time + 1.0;

	movsd	xmm0, QWORD PTR _sv+16
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+708], xmm0
$LN28@SV_WaterMo:

; 191  : 			// otherwise radsuit is fully protect entity from slime
; 192  : 		}
; 193  : 	}
; 194  : 
; 195  : 	if( !( flags & FL_INWATER ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	jne	$LN29@SV_WaterMo

; 196  : 	{
; 197  : 		if( watertype == CONTENTS_WATER )

	cmp	DWORD PTR _watertype$[ebp], -3		; fffffffdH
	jne	$LN4@SV_WaterMo

; 198  : 		{
; 199  : 			// entering the water
; 200  : 			switch( COM_RandomLong( 0, 3 ))

	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR tv214[ebp], eax
	cmp	DWORD PTR tv214[ebp], 3
	ja	$LN4@SV_WaterMo
	mov	eax, DWORD PTR tv214[ebp]
	jmp	DWORD PTR $LN40@SV_WaterMo[eax*4]
$LN31@SV_WaterMo:

; 201  : 			{
; 202  : 			case 0:
; 203  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade1.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 204  : 				break;

	jmp	$LN4@SV_WaterMo
$LN32@SV_WaterMo:

; 205  : 			case 1:
; 206  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade2.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 207  : 				break;

	jmp	SHORT $LN4@SV_WaterMo
$LN33@SV_WaterMo:

; 208  : 			case 2:
; 209  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade3.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@FLMLMHEC@player?1pl_wade3?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 210  : 				break;

	jmp	SHORT $LN4@SV_WaterMo
$LN34@SV_WaterMo:

; 211  : 			case 3:
; 212  : 				SV_StartSound( ent, CHAN_BODY, "player/pl_wade4.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@EGMOPHPK@player?1pl_wade4?4wav@
	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH
$LN4@SV_WaterMo:

; 213  : 				break;
; 214  : 			}
; 215  : 		}
; 216  : 
; 217  : 		ent->v.flags = flags | FL_INWATER;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 218  : 		ent->v.dmgtime = 0.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+708], xmm0
$LN29@SV_WaterMo:

; 219  : 	}
; 220  : 
; 221  : 	if( !( flags & FL_WATERJUMP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2048				; 00000800H
	jne	$LN35@SV_WaterMo

; 222  : 	{
; 223  : 		VectorMA( ent->v.velocity, ( ent->v.waterlevel * -0.8f * sv.frametime ), ent->v.velocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+672]
	mulss	xmm0, DWORD PTR __real@bf4ccccd
	mulss	xmm0, DWORD PTR _sv+32
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+160]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+160]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+672]
	mulss	xmm0, DWORD PTR __real@bf4ccccd
	mulss	xmm0, DWORD PTR _sv+32
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [ecx+edx+160]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+eax+160]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+672]
	mulss	xmm0, DWORD PTR __real@bf4ccccd
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+ecx+160]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+160]
	addss	xmm1, xmm0
	movss	DWORD PTR tv299[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv299[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
$LN35@SV_WaterMo:

; 224  : 	}
; 225  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN39@SV_WaterMo:
	DD	$LN17@SV_WaterMo
	DD	$LN18@SV_WaterMo
	DD	$LN19@SV_WaterMo
	DD	$LN20@SV_WaterMo
$LN40@SV_WaterMo:
	DD	$LN31@SV_WaterMo
	DD	$LN32@SV_WaterMo
	DD	$LN33@SV_WaterMo
	DD	$LN34@SV_WaterMo
_SV_WaterMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_VecToYaw
_TEXT	SEGMENT
tv140 = -76						; size = 8
_yaw$ = -4						; size = 4
_src$ = 8						; size = 4
_SV_VecToYaw PROC					; COMDAT

; 235  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 236  : 	float	yaw;
; 237  : 
; 238  : 	if( !src ) return 0.0f;

	cmp	DWORD PTR _src$[ebp], 0
	jne	SHORT $LN2@SV_VecToYa
	fldz
	jmp	$LN1@SV_VecToYa
$LN2@SV_VecToYa:

; 239  : 
; 240  : 	if( src[1] == 0.0f && src[0] == 0.0f )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_VecToYa
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_VecToYa

; 241  : 	{
; 242  : 		yaw = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _yaw$[ebp], xmm0

; 243  : 	}

	jmp	SHORT $LN5@SV_VecToYa
$LN3@SV_VecToYa:

; 244  : 	else
; 245  : 	{
; 246  : 		yaw = (int)( atan2( src[1], src[0] ) * 180.0f / M_PI );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _src$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _src$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv140[ebp]
	movsd	xmm0, QWORD PTR tv140[ebp]
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	divsd	xmm0, QWORD PTR __real@400921fb60000000
	cvttsd2si edx, xmm0
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _yaw$[ebp], xmm0

; 247  : 		if( yaw < 0 ) yaw += 360.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _yaw$[ebp]
	jbe	SHORT $LN5@SV_VecToYa
	movss	xmm0, DWORD PTR _yaw$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _yaw$[ebp], xmm0
$LN5@SV_VecToYa:

; 248  : 	}
; 249  : 	return yaw;

	fld	DWORD PTR _yaw$[ebp]
$LN1@SV_VecToYa:

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_VecToYaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_CheckBottom
_TEXT	SEGMENT
tv268 = -420						; size = 4
tv258 = -420						; size = 4
tv215 = -420						; size = 4
tv204 = -420						; size = 4
tv178 = -420						; size = 4
tv170 = -420						; size = 4
tv153 = -420						; size = 4
tv94 = -420						; size = 4
tv67 = -420						; size = 4
$T1 = -416						; size = 56
$T2 = -360						; size = 56
$T3 = -304						; size = 56
$T4 = -248						; size = 56
_y$ = -128						; size = 4
_x$ = -124						; size = 4
_trace$ = -120						; size = 56
_monsterClip$ = -64					; size = 4
_bottom$ = -60						; size = 4
_mid$ = -56						; size = 4
_stop$ = -52						; size = 12
_start$ = -40						; size = 12
_maxs$ = -28						; size = 12
_mins$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_iMode$ = 12						; size = 4
_SV_CheckBottom PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 420				; 000001a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 36   : 	vec3_t	mins, maxs, start, stop;
; 37   : 	float	mid, bottom;
; 38   : 	qboolean	monsterClip;
; 39   : 	trace_t	trace;
; 40   : 	int	x, y;
; 41   : 
; 42   : 	monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN25@SV_CheckBo
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN26@SV_CheckBo
$LN25@SV_CheckBo:
	mov	DWORD PTR tv67[ebp], 0
$LN26@SV_CheckBo:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 43   : 	VectorAdd( ent->v.origin, ent->v.mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+352]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+352]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+352]
	movss	DWORD PTR tv94[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 44   : 	VectorAdd( ent->v.origin, ent->v.maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+364]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+364]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+364]
	movss	DWORD PTR tv153[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv153[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 45   : 
; 46   : 	// if all of the points under the corners are solid world, don't bother
; 47   : 	// with the tougher checks
; 48   : 	// the corners must be within 16 of the midpoint
; 49   : 	start[2] = mins[2] - 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _start$[ebp+ecx], xmm0

; 50   : 
; 51   : 	for( x = 0; x <= 1; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN4@SV_CheckBo
$LN2@SV_CheckBo:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN4@SV_CheckBo:
	cmp	DWORD PTR _x$[ebp], 1
	jg	$LN3@SV_CheckBo

; 52   : 	{
; 53   : 		for( y = 0; y <= 1; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@SV_CheckBo
$LN5@SV_CheckBo:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN7@SV_CheckBo:
	cmp	DWORD PTR _y$[ebp], 1
	jg	$LN6@SV_CheckBo

; 54   : 		{
; 55   : 			start[0] = x ? maxs[0] : mins[0];

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN27@SV_CheckBo
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	movss	DWORD PTR tv170[ebp], xmm0
	jmp	SHORT $LN28@SV_CheckBo
$LN27@SV_CheckBo:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	movss	DWORD PTR tv170[ebp], xmm0
$LN28@SV_CheckBo:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _start$[ebp+edx], xmm0

; 56   : 			start[1] = y ? maxs[1] : mins[1];

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN29@SV_CheckBo
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+eax]
	movss	DWORD PTR tv178[ebp], xmm0
	jmp	SHORT $LN30@SV_CheckBo
$LN29@SV_CheckBo:
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv178[ebp], xmm0
$LN30@SV_CheckBo:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _start$[ebp+edx], xmm0

; 57   : 			svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 58   : 
; 59   : 			if( SV_PointContents( start ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN14@SV_CheckBo

; 60   : 				goto realcheck;

	jmp	SHORT $realcheck$35
$LN14@SV_CheckBo:

; 61   : 		}

	jmp	$LN5@SV_CheckBo
$LN6@SV_CheckBo:

; 62   : 	}

	jmp	$LN2@SV_CheckBo
$LN3@SV_CheckBo:

; 63   : 	return true; // we got out easy

	mov	eax, 1
	jmp	$LN1@SV_CheckBo
$realcheck$35:

; 64   : realcheck:
; 65   : 	// check it for real...
; 66   : 	start[2] = mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp+eax]
	mov	DWORD PTR _start$[ebp+ecx], edx

; 67   : 
; 68   : 	if( !FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	jne	SHORT $LN15@SV_CheckBo

; 69   : 		start[2] += svgame.movevars.stepsize;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _start$[ebp+eax]
	addss	xmm0, DWORD PTR _svgame+7984
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _start$[ebp+ecx], xmm0
$LN15@SV_CheckBo:

; 70   : 
; 71   : 	// the midpoint must be within 16 of the bottom
; 72   : 	start[0] = stop[0] = (mins[0] + maxs[0]) * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	addss	xmm0, DWORD PTR _maxs$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv204[ebp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR _stop$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR _start$[ebp+ecx], xmm0

; 73   : 	start[1] = stop[1] = (mins[1] + maxs[1]) * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	addss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv215[ebp], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv215[ebp]
	movss	DWORD PTR _stop$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR tv215[ebp]
	movss	DWORD PTR _start$[ebp+eax], xmm0

; 74   : 	stop[2] = start[2] - 2.0f * svgame.movevars.stepsize;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _svgame+7984
	movss	xmm1, DWORD PTR _start$[ebp+eax]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _stop$[ebp+ecx], xmm1

; 75   : 
; 76   : 	if( iMode == WALKMOVE_WORLDONLY )

	cmp	DWORD PTR _iMode$[ebp], 1
	jne	SHORT $LN16@SV_CheckBo

; 77   : 		trace = SV_MoveNoEnts( start, vec3_origin, vec3_origin, stop, MOVE_NOMONSTERS, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _stop$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	_SV_MoveNoEnts
	add	esp, 28					; 0000001cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd
	jmp	SHORT $LN17@SV_CheckBo
$LN16@SV_CheckBo:

; 78   : 	else trace = SV_Move( start, vec3_origin, vec3_origin, stop, MOVE_NOMONSTERS, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _stop$[ebp]
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd
$LN17@SV_CheckBo:

; 79   : 
; 80   : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@SV_CheckBo

; 81   : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CheckBo
$LN18@SV_CheckBo:

; 82   : 
; 83   : 	mid = bottom = trace.endpos[2];

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+20]
	movss	DWORD PTR _bottom$[ebp], xmm0
	movss	xmm0, DWORD PTR _bottom$[ebp]
	movss	DWORD PTR _mid$[ebp], xmm0

; 84   : 
; 85   : 	// the corners must be within 16 of the midpoint
; 86   : 	for( x = 0; x <= 1; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN10@SV_CheckBo
$LN8@SV_CheckBo:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN10@SV_CheckBo:
	cmp	DWORD PTR _x$[ebp], 1
	jg	$LN9@SV_CheckBo

; 87   : 	{
; 88   : 		for( y = 0; y <= 1; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN13@SV_CheckBo
$LN11@SV_CheckBo:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN13@SV_CheckBo:
	cmp	DWORD PTR _y$[ebp], 1
	jg	$LN12@SV_CheckBo

; 89   : 		{
; 90   : 			start[0] = stop[0] = x ? maxs[0] : mins[0];

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN31@SV_CheckBo
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	movss	DWORD PTR tv258[ebp], xmm0
	jmp	SHORT $LN32@SV_CheckBo
$LN31@SV_CheckBo:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	movss	DWORD PTR tv258[ebp], xmm0
$LN32@SV_CheckBo:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv258[ebp]
	movss	DWORD PTR _stop$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR tv258[ebp]
	movss	DWORD PTR _start$[ebp+ecx], xmm0

; 91   : 			start[1] = stop[1] = y ? maxs[1] : mins[1];

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN33@SV_CheckBo
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+eax]
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN34@SV_CheckBo
$LN33@SV_CheckBo:
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv268[ebp], xmm0
$LN34@SV_CheckBo:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR _stop$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR _start$[ebp+eax], xmm0

; 92   : 
; 93   : 			if( iMode == WALKMOVE_WORLDONLY )

	cmp	DWORD PTR _iMode$[ebp], 1
	jne	SHORT $LN19@SV_CheckBo

; 94   : 				trace = SV_MoveNoEnts( start, vec3_origin, vec3_origin, stop, MOVE_NOMONSTERS, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _stop$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_SV_MoveNoEnts
	add	esp, 28					; 0000001cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd
	jmp	SHORT $LN20@SV_CheckBo
$LN19@SV_CheckBo:

; 95   : 			else trace = SV_Move( start, vec3_origin, vec3_origin, stop, MOVE_NOMONSTERS, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _stop$[ebp]
	push	edx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd
$LN20@SV_CheckBo:

; 96   : 
; 97   : 			if( trace.fraction != 1.0f && trace.endpos[2] > bottom )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@SV_CheckBo
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+20]
	comiss	xmm0, DWORD PTR _bottom$[ebp]
	jbe	SHORT $LN21@SV_CheckBo

; 98   : 				bottom = trace.endpos[2];

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+20]
	movss	DWORD PTR _bottom$[ebp], xmm0
$LN21@SV_CheckBo:

; 99   : 			if( trace.fraction == 1.0f || mid - trace.endpos[2] > svgame.movevars.stepsize )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@SV_CheckBo
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _mid$[ebp]
	subss	xmm0, DWORD PTR _trace$[ebp+eax+20]
	comiss	xmm0, DWORD PTR _svgame+7984
	jbe	SHORT $LN22@SV_CheckBo
$LN23@SV_CheckBo:

; 100  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckBo
$LN22@SV_CheckBo:

; 101  : 		}

	jmp	$LN11@SV_CheckBo
$LN12@SV_CheckBo:

; 102  : 	}

	jmp	$LN8@SV_CheckBo
$LN9@SV_CheckBo:

; 103  : 	return true;

	mov	eax, 1
$LN1@SV_CheckBo:

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckBottom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_MoveToOrigin
_TEXT	SEGMENT
tv203 = -88						; size = 4
_ilength$1 = -20					; size = 4
_vecDist$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_pflGoal$ = 12						; size = 4
_dist$ = 16						; size = 4
_iMoveType$ = 20					; size = 4
_SV_MoveToOrigin PROC					; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 546  : 	vec3_t	vecDist;
; 547  : 
; 548  : 	VectorCopy( pflGoal, vecDist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pflGoal$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _vecDist$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pflGoal$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _vecDist$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pflGoal$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _vecDist$[ebp+ecx], eax

; 549  : 
; 550  : 	if( ent->v.flags & ( FL_FLY|FL_SWIM|FL_ONGROUND ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 515				; 00000203H
	je	$LN4@SV_MoveToO

; 551  : 	{
; 552  : 		if( iMoveType == MOVE_NORMAL )

	cmp	DWORD PTR _iMoveType$[ebp], 0
	jne	SHORT $LN3@SV_MoveToO

; 553  : 		{
; 554  : 			if( !SV_StepDirection( ent, ent->v.ideal_yaw, dist ))

	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+300]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_StepDirection
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_MoveToO

; 555  : 			{
; 556  : 				SV_NewChaseDir( ent, vecDist, dist );

	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _vecDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_NewChaseDir
	add	esp, 12					; 0000000cH
$LN5@SV_MoveToO:

; 557  : 			}
; 558  : 		}

	jmp	$LN4@SV_MoveToO
$LN3@SV_MoveToO:

; 559  : 		else
; 560  : 		{
; 561  : 			vecDist[0] -= ent->v.origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _vecDist$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+136]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecDist$[ebp+ecx], xmm0

; 562  : 			vecDist[1] -= ent->v.origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+136]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vecDist$[ebp+eax], xmm0

; 563  : 
; 564  : 			if( ent->v.flags & ( FL_FLY|FL_SWIM ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 3
	je	SHORT $LN6@SV_MoveToO

; 565  : 				vecDist[2] -= ent->v.origin[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+136]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vecDist$[ebp+eax], xmm0
	jmp	SHORT $LN7@SV_MoveToO
$LN6@SV_MoveToO:

; 566  : 			else vecDist[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vecDist$[ebp+eax], xmm0
$LN7@SV_MoveToO:

; 567  : 
; 568  : 			VectorNormalize( vecDist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecDist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecDist$[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecDist$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecDist$[ebp+eax]
	mulss	xmm1, DWORD PTR _vecDist$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SV_MoveToO
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN8@SV_MoveToO:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecDist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecDist$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecDist$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vecDist$[ebp+ecx], xmm0

; 569  : 			VectorScale( vecDist, dist, vecDist );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecDist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecDist$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecDist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecDist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecDist$[ebp+eax]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR tv203[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR _vecDist$[ebp+ecx], xmm0

; 570  : 			SV_FlyDirection( ent, vecDist );

	lea	eax, DWORD PTR _vecDist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_FlyDirection
	add	esp, 8
$LN4@SV_MoveToO:

; 571  : 		}
; 572  : 	}
; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveToOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_MoveTest
_TEXT	SEGMENT
tv219 = -280						; size = 4
tv134 = -280						; size = 4
$T1 = -276						; size = 56
$T2 = -220						; size = 56
_trace$ = -100						; size = 56
_end$ = -44						; size = 12
_neworg$ = -32						; size = 12
_oldorg$ = -20						; size = 12
_temp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_move$ = 12						; size = 4
_relink$ = 16						; size = 4
_SV_MoveTest PROC					; COMDAT

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 368  : 	float	temp;
; 369  : 	vec3_t	oldorg, neworg, end;
; 370  : 	trace_t	trace;
; 371  : 
; 372  : 	VectorCopy( ent->v.origin, oldorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _oldorg$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _oldorg$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _oldorg$[ebp+ecx], eax

; 373  : 	VectorAdd( ent->v.origin, move, neworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _neworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _neworg$[ebp+eax], xmm0

; 374  : 
; 375  : 	temp = svgame.movevars.stepsize;

	movss	xmm0, DWORD PTR _svgame+7984
	movss	DWORD PTR _temp$[ebp], xmm0

; 376  : 
; 377  : 	neworg[2] += temp;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	addss	xmm0, DWORD PTR _temp$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0

; 378  : 	VectorCopy( neworg, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _neworg$[ebp+ecx]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _neworg$[ebp+edx]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _neworg$[ebp+edx]
	mov	DWORD PTR _end$[ebp+eax], ecx

; 379  : 	end[2] -= temp * 2.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _temp$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _end$[ebp+eax]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _end$[ebp+ecx], xmm1

; 380  : 
; 381  : 	trace = SV_MoveNoEnts( neworg, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 364				; 0000016cH
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	lea	ecx, DWORD PTR _neworg$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	_SV_MoveNoEnts
	add	esp, 28					; 0000001cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 382  : 
; 383  : 	if( trace.allsolid != 0 )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN2@SV_MoveTes

; 384  : 		return 0;

	xor	eax, eax
	jmp	$LN11@SV_MoveTes
$LN2@SV_MoveTes:

; 385  : 
; 386  : 	if( trace.startsolid != 0 )

	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN4@SV_MoveTes

; 387  : 	{
; 388  : 		neworg[2] -= temp;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	subss	xmm0, DWORD PTR _temp$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0

; 389  : 		trace = SV_MoveNoEnts( neworg, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 364				; 0000016cH
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	lea	ecx, DWORD PTR _neworg$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_MoveNoEnts
	add	esp, 28					; 0000001cH
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 390  : 
; 391  : 		if( trace.allsolid != 0 || trace.startsolid != 0 )

	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN5@SV_MoveTes
	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN4@SV_MoveTes
$LN5@SV_MoveTes:

; 392  : 			return 0;

	xor	eax, eax
	jmp	$LN11@SV_MoveTes
$LN4@SV_MoveTes:

; 393  : 	}
; 394  : 
; 395  : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@SV_MoveTes

; 396  : 	{
; 397  : 		if( ent->v.flags & FL_PARTIALGROUND )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1024				; 00000400H
	je	$LN8@SV_MoveTes

; 398  : 		{
; 399  : 			VectorAdd( ent->v.origin, move, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv219[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0

; 400  : 			if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN9@SV_MoveTes
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN9@SV_MoveTes:

; 401  : 			ent->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 402  : 			return 1;

	mov	eax, 1
	jmp	$LN11@SV_MoveTes
$LN8@SV_MoveTes:

; 403  : 		}
; 404  : 		return 0;

	xor	eax, eax
	jmp	$LN11@SV_MoveTes

; 405  : 	}

	jmp	$LN11@SV_MoveTes
$LN6@SV_MoveTes:

; 406  : 	else
; 407  : 	{
; 408  : 		VectorCopy( trace.endpos, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 409  : 
; 410  : 		if( SV_CheckBottom( ent, WALKMOVE_WORLDONLY ) == 0 )

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckBottom
	add	esp, 8
	test	eax, eax
	jne	$LN10@SV_MoveTes

; 411  : 		{
; 412  : 			if( ent->v.flags & FL_PARTIALGROUND )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN12@SV_MoveTes

; 413  : 			{
; 414  : 				if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN13@SV_MoveTes
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN13@SV_MoveTes:

; 415  : 				return 1;

	mov	eax, 1
	jmp	$LN11@SV_MoveTes
$LN12@SV_MoveTes:

; 416  : 			}
; 417  : 
; 418  : 			VectorCopy( oldorg, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _oldorg$[ebp+ecx]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _oldorg$[ebp+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _oldorg$[ebp+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 419  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN11@SV_MoveTes

; 420  : 		}

	jmp	SHORT $LN11@SV_MoveTes
$LN10@SV_MoveTes:

; 421  : 		else
; 422  : 		{
; 423  : 			ent->v.flags &= ~FL_PARTIALGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -1025				; fffffbffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 424  : 			ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 425  : 			if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN14@SV_MoveTes
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN14@SV_MoveTes:

; 426  : 
; 427  : 			return 1;

	mov	eax, 1
$LN11@SV_MoveTes:

; 428  : 		}
; 429  : 	}
; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveTest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_move.c
;	COMDAT _SV_MoveStep
_TEXT	SEGMENT
tv321 = -348						; size = 4
tv167 = -348						; size = 4
tv138 = -348						; size = 4
tv134 = -348						; size = 4
$T1 = -344						; size = 56
$T2 = -288						; size = 56
$T3 = -232						; size = 56
_dz$ = -112						; size = 4
_enemy$ = -108						; size = 4
_monsterClip$ = -104					; size = 4
_end$ = -100						; size = 12
_neworg$ = -88						; size = 12
_oldorg$ = -76						; size = 12
_trace$ = -64						; size = 56
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_move$ = 12						; size = 4
_relink$ = 16						; size = 4
_SV_MoveStep PROC					; COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 256  : 	int	i;
; 257  : 	trace_t	trace;
; 258  : 	vec3_t	oldorg, neworg, end;
; 259  : 	qboolean	monsterClip;
; 260  : 	edict_t	*enemy;
; 261  : 	float	dz;
; 262  : 
; 263  : 	VectorCopy( ent->v.origin, oldorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _oldorg$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _oldorg$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _oldorg$[ebp+ecx], eax

; 264  : 	VectorAdd( ent->v.origin, move, neworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _neworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _neworg$[ebp+eax], xmm0

; 265  : 	monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN30@SV_MoveSte
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN31@SV_MoveSte
$LN30@SV_MoveSte:
	mov	DWORD PTR tv138[ebp], 0
$LN31@SV_MoveSte:
	mov	edx, DWORD PTR tv138[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 266  : 
; 267  : 	// well, try it.  Flying and swimming monsters are easiest.
; 268  : 	if( ent->v.flags & ( FL_SWIM|FL_FLY ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 3
	je	$LN5@SV_MoveSte

; 269  : 	{
; 270  : 		// try one move with vertical motion, then one without
; 271  : 		for( i = 0; i < 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_MoveSte
$LN2@SV_MoveSte:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_MoveSte:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN3@SV_MoveSte

; 272  : 		{
; 273  : 			VectorAdd( ent->v.origin, move, neworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _neworg$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv167[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv167[ebp]
	movss	DWORD PTR _neworg$[ebp+eax], xmm0

; 274  : 
; 275  : 			enemy = ent->v.enemy;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+636]
	mov	DWORD PTR _enemy$[ebp], ecx

; 276  : 			if( i == 0 && enemy != NULL )

	cmp	DWORD PTR _i$[ebp], 0
	jne	$LN10@SV_MoveSte
	cmp	DWORD PTR _enemy$[ebp], 0
	je	$LN10@SV_MoveSte

; 277  : 			{
; 278  : 				dz = ent->v.origin[2] - enemy->v.origin[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _enemy$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	subss	xmm0, DWORD PTR [esi+ecx+136]
	movss	DWORD PTR _dz$[ebp], xmm0

; 279  : 
; 280  : 				if( dz > 40.0f ) neworg[2] -= 8.0f;

	movss	xmm0, DWORD PTR _dz$[ebp]
	comiss	xmm0, DWORD PTR __real@42200000
	jbe	SHORT $LN8@SV_MoveSte
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	subss	xmm0, DWORD PTR __real@41000000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0
	jmp	SHORT $LN10@SV_MoveSte
$LN8@SV_MoveSte:

; 281  : 				else if( dz < 30.0f ) neworg[2] += 8.0f;

	movss	xmm0, DWORD PTR __real@41f00000
	comiss	xmm0, DWORD PTR _dz$[ebp]
	jbe	SHORT $LN10@SV_MoveSte
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	addss	xmm0, DWORD PTR __real@41000000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0
$LN10@SV_MoveSte:

; 282  : 			}
; 283  : 
; 284  : 			trace = SV_Move( ent->v.origin, ent->v.mins, ent->v.maxs, neworg, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _neworg$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 285  : 
; 286  : 			if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@SV_MoveSte

; 287  : 			{
; 288  : 				svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 289  : 
; 290  : 				// that move takes us out of the water.
; 291  : 				// apparently though, it's okay to travel into solids, lava, sky, etc :)
; 292  : 				if(( ent->v.flags & FL_SWIM ) && SV_PointContents( trace.endpos ) == CONTENTS_EMPTY )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 2
	je	SHORT $LN13@SV_MoveSte
	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN13@SV_MoveSte

; 293  : 					return 0;

	xor	eax, eax
	jmp	$LN25@SV_MoveSte
$LN13@SV_MoveSte:

; 294  : 
; 295  : 				VectorCopy( trace.endpos, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 296  : 				if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN14@SV_MoveSte
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN14@SV_MoveSte:

; 297  : 
; 298  : 				return 1;

	mov	eax, 1
	jmp	$LN25@SV_MoveSte

; 299  : 			}

	jmp	SHORT $LN15@SV_MoveSte
$LN11@SV_MoveSte:

; 300  : 			else
; 301  : 			{
; 302  : 				if( !SV_IsValidEdict( enemy ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_MoveStep@@9@9
	add	eax, 47					; 0000002fH
	push	eax
	push	OFFSET ??_C@_0DE@PIDELKIF@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _enemy$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@SV_MoveSte

; 303  : 					break;

	jmp	SHORT $LN3@SV_MoveSte
$LN15@SV_MoveSte:

; 304  : 			}
; 305  : 		}

	jmp	$LN2@SV_MoveSte
$LN3@SV_MoveSte:

; 306  : 		return 0;

	xor	eax, eax
	jmp	$LN25@SV_MoveSte

; 307  : 	}

	jmp	$LN25@SV_MoveSte
$LN5@SV_MoveSte:

; 308  : 	else
; 309  : 	{
; 310  : 		dz = svgame.movevars.stepsize;

	movss	xmm0, DWORD PTR _svgame+7984
	movss	DWORD PTR _dz$[ebp], xmm0

; 311  : 		neworg[2] += dz;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	addss	xmm0, DWORD PTR _dz$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0

; 312  : 		VectorCopy( neworg, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _neworg$[ebp+ecx]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _neworg$[ebp+edx]
	mov	DWORD PTR _end$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _neworg$[ebp+edx]
	mov	DWORD PTR _end$[ebp+eax], ecx

; 313  : 		end[2] -= dz * 2.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dz$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _end$[ebp+eax]
	subss	xmm1, xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _end$[ebp+ecx], xmm1

; 314  : 
; 315  : 		trace = SV_Move( neworg, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	lea	edx, DWORD PTR _neworg$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 316  : 		if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN16@SV_MoveSte

; 317  : 			return 0;

	xor	eax, eax
	jmp	$LN25@SV_MoveSte
$LN16@SV_MoveSte:

; 318  : 
; 319  : 		if( trace.startsolid != 0 )

	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN18@SV_MoveSte

; 320  : 		{
; 321  : 			neworg[2] -= dz;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _neworg$[ebp+eax]
	subss	xmm0, DWORD PTR _dz$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _neworg$[ebp+ecx], xmm0

; 322  : 			trace = SV_Move( neworg, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	lea	edx, DWORD PTR _neworg$[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 323  : 
; 324  : 			if( trace.allsolid != 0 || trace.startsolid != 0 )

	cmp	DWORD PTR _trace$[ebp], 0
	jne	SHORT $LN19@SV_MoveSte
	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN18@SV_MoveSte
$LN19@SV_MoveSte:

; 325  : 				return 0;

	xor	eax, eax
	jmp	$LN25@SV_MoveSte
$LN18@SV_MoveSte:

; 326  : 		}
; 327  : 
; 328  : 		if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN20@SV_MoveSte

; 329  : 		{
; 330  : 			if( ent->v.flags & FL_PARTIALGROUND )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1024				; 00000400H
	je	$LN22@SV_MoveSte

; 331  : 			{
; 332  : 				VectorAdd( ent->v.origin, move, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _move$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	movss	DWORD PTR tv321[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv321[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0

; 333  : 				if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN23@SV_MoveSte
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN23@SV_MoveSte:

; 334  : 				ent->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 335  : 				return 1;

	mov	eax, 1
	jmp	$LN25@SV_MoveSte
$LN22@SV_MoveSte:

; 336  : 			}
; 337  : 			return 0;

	xor	eax, eax
	jmp	$LN25@SV_MoveSte

; 338  : 		}

	jmp	$LN25@SV_MoveSte
$LN20@SV_MoveSte:

; 339  : 		else
; 340  : 		{
; 341  : 			VectorCopy( trace.endpos, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 342  : 
; 343  : 			if( SV_CheckBottom( ent, WALKMOVE_NORMAL ) == 0 )

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckBottom
	add	esp, 8
	test	eax, eax
	jne	$LN24@SV_MoveSte

; 344  : 			{
; 345  : 				if( ent->v.flags & FL_PARTIALGROUND )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN26@SV_MoveSte

; 346  : 				{
; 347  : 					if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN27@SV_MoveSte
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN27@SV_MoveSte:

; 348  : 					return 1;

	mov	eax, 1
	jmp	$LN25@SV_MoveSte
$LN26@SV_MoveSte:

; 349  : 				}
; 350  : 
; 351  : 				VectorCopy( oldorg, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _oldorg$[ebp+ecx]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _oldorg$[ebp+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _oldorg$[ebp+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 352  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN25@SV_MoveSte

; 353  : 			}

	jmp	SHORT $LN25@SV_MoveSte
$LN24@SV_MoveSte:

; 354  : 			else
; 355  : 			{
; 356  : 				ent->v.flags &= ~FL_PARTIALGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -1025				; fffffbffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 357  : 				ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 358  : 				if( relink ) SV_LinkEdict( ent, true );

	cmp	DWORD PTR _relink$[ebp], 0
	je	SHORT $LN28@SV_MoveSte
	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN28@SV_MoveSte:

; 359  : 
; 360  : 				return 1;

	mov	eax, 1
$LN25@SV_MoveSte:

; 361  : 			}
; 362  : 		}
; 363  : 	}
; 364  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_MoveStep ENDP
_TEXT	ENDS
END
