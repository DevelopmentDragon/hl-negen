; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_PFDesc
PUBLIC	??_C@_02HLHCNIN@ft@				; `string'
PUBLIC	??_C@_02MNOEILMP@bk@				; `string'
PUBLIC	??_C@_02HNLLPFKA@up@				; `string'
PUBLIC	??_C@_02LEBOADDI@dn@				; `string'
PUBLIC	??_C@_02BMJICGCB@rt@				; `string'
PUBLIC	??_C@_02HCNENIII@lf@				; `string'
PUBLIC	??_C@_03EKNMDEHH@_ft@				; `string'
PUBLIC	??_C@_03IAIPJCDF@_bk@				; `string'
PUBLIC	??_C@_03DANAOMFK@_up@				; `string'
PUBLIC	??_C@_03PJHFBKMC@_dn@				; `string'
PUBLIC	??_C@_03FBPDDPNL@_rt@				; `string'
PUBLIC	??_C@_03DPLPMBHC@_lf@				; `string'
PUBLIC	??_C@_02LDKJLNED@px@				; `string'
PUBLIC	??_C@_02KFBBDDDJ@nx@				; `string'
PUBLIC	??_C@_02KKLCIMAC@py@				; `string'
PUBLIC	??_C@_02LMAKACHI@ny@				; `string'
PUBLIC	??_C@_02IBJPNPMB@pz@				; `string'
PUBLIC	??_C@_02JHCHFBLL@nz@				; `string'
PUBLIC	??_C@_08HHFIIFKF@3Ds?5Sky1@			; `string'
PUBLIC	??_C@_08FMHFNGGG@3Ds?5Sky2@			; `string'
PUBLIC	??_C@_08GJNKOGEK@3Ds?5Cube@			; `string'
_DATA	SEGMENT
COMM	_image:BYTE:064H
_DATA	ENDS
;	COMDAT ??_C@_08GJNKOGEK@3Ds?5Cube@
CONST	SEGMENT
??_C@_08GJNKOGEK@3Ds?5Cube@ DB '3Ds Cube', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FMHFNGGG@3Ds?5Sky2@
CONST	SEGMENT
??_C@_08FMHFNGGG@3Ds?5Sky2@ DB '3Ds Sky2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHFIIFKF@3Ds?5Sky1@
CONST	SEGMENT
??_C@_08HHFIIFKF@3Ds?5Sky1@ DB '3Ds Sky1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHCHFBLL@nz@
CONST	SEGMENT
??_C@_02JHCHFBLL@nz@ DB 'nz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IBJPNPMB@pz@
CONST	SEGMENT
??_C@_02IBJPNPMB@pz@ DB 'pz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMAKACHI@ny@
CONST	SEGMENT
??_C@_02LMAKACHI@ny@ DB 'ny', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KKLCIMAC@py@
CONST	SEGMENT
??_C@_02KKLCIMAC@py@ DB 'py', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFBBDDDJ@nx@
CONST	SEGMENT
??_C@_02KFBBDDDJ@nx@ DB 'nx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LDKJLNED@px@
CONST	SEGMENT
??_C@_02LDKJLNED@px@ DB 'px', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DPLPMBHC@_lf@
CONST	SEGMENT
??_C@_03DPLPMBHC@_lf@ DB '_lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBPDDPNL@_rt@
CONST	SEGMENT
??_C@_03FBPDDPNL@_rt@ DB '_rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHFBKMC@_dn@
CONST	SEGMENT
??_C@_03PJHFBKMC@_dn@ DB '_dn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DANAOMFK@_up@
CONST	SEGMENT
??_C@_03DANAOMFK@_up@ DB '_up', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IAIPJCDF@_bk@
CONST	SEGMENT
??_C@_03IAIPJCDF@_bk@ DB '_bk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EKNMDEHH@_ft@
CONST	SEGMENT
??_C@_03EKNMDEHH@_ft@ DB '_ft', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCNENIII@lf@
CONST	SEGMENT
??_C@_02HCNENIII@lf@ DB 'lf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BMJICGCB@rt@
CONST	SEGMENT
??_C@_02BMJICGCB@rt@ DB 'rt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LEBOADDI@dn@
CONST	SEGMENT
??_C@_02LEBOADDI@dn@ DB 'dn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HNLLPFKA@up@
CONST	SEGMENT
??_C@_02HNLLPFKA@up@ DB 'up', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNOEILMP@bk@
CONST	SEGMENT
??_C@_02MNOEILMP@bk@ DB 'bk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HLHCNIN@ft@
CONST	SEGMENT
??_C@_02HLHCNIN@ft@ DB 'ft', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
_PFDesc	DD	00H
	DB	'raw', 00H
	ORG $+12
	DD	01908H
	DD	00H
	DD	01H
	DB	'pal 24', 00H
	ORG $+9
	DD	01908H
	DD	01H
	DD	02H
	DB	'pal 32', 00H
	ORG $+9
	DD	01908H
	DD	01H
	DD	03H
	DB	'RGBA 32', 00H
	ORG $+8
	DD	01908H
	DD	04H
	DD	04H
	DB	'BGRA 32', 00H
	ORG $+8
	DD	080e1H
	DD	04H
	DD	05H
	DB	'RGB 24', 00H
	ORG $+9
	DD	01908H
	DD	03H
	DD	06H
	DB	'BGR 24', 00H
	ORG $+9
	DD	080e0H
	DD	03H
	DD	07H
	DB	'DXT 1', 00H
	ORG $+10
	DD	083f1H
	DD	04H
	DD	08H
	DB	'DXT 3', 00H
	ORG $+10
	DD	083f2H
	DD	04H
	DD	09H
	DB	'DXT 5', 00H
	ORG $+10
	DD	083f3H
	DD	04H
	DD	0aH
	DB	'ATI 2', 00H
	ORG $+10
	DD	08837H
	DD	04H
	ORG $+4
_skybox_qv1 DD	FLAT:??_C@_02HLHCNIN@ft@
	DD	010000H
	DD	01H
	DD	FLAT:??_C@_02MNOEILMP@bk@
	DD	020000H
	DD	02H
	DD	FLAT:??_C@_02HNLLPFKA@up@
	DD	040000H
	DD	03H
	DD	FLAT:??_C@_02LEBOADDI@dn@
	DD	040000H
	DD	04H
	DD	FLAT:??_C@_02BMJICGCB@rt@
	DD	040000H
	DD	05H
	DD	FLAT:??_C@_02HCNENIII@lf@
	DD	070000H
	DD	06H
_skybox_qv2 DD	FLAT:??_C@_03EKNMDEHH@_ft@
	DD	010000H
	DD	01H
	DD	FLAT:??_C@_03IAIPJCDF@_bk@
	DD	020000H
	DD	02H
	DD	FLAT:??_C@_03DANAOMFK@_up@
	DD	040000H
	DD	03H
	DD	FLAT:??_C@_03PJHFBKMC@_dn@
	DD	040000H
	DD	04H
	DD	FLAT:??_C@_03FBPDDPNL@_rt@
	DD	040000H
	DD	05H
	DD	FLAT:??_C@_03DPLPMBHC@_lf@
	DD	070000H
	DD	06H
_cubemap_v1 DD	FLAT:??_C@_02LDKJLNED@px@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_02KFBBDDDJ@nx@
	DD	00H
	DD	02H
	DD	FLAT:??_C@_02KKLCIMAC@py@
	DD	00H
	DD	05H
	DD	FLAT:??_C@_02LMAKACHI@ny@
	DD	00H
	DD	06H
	DD	FLAT:??_C@_02IBJPNPMB@pz@
	DD	00H
	DD	03H
	DD	FLAT:??_C@_02JHCHFBLL@nz@
	DD	00H
	DD	04H
_load_cubemap DD FLAT:??_C@_08HHFIIFKF@3Ds?5Sky1@
	DD	FLAT:_skybox_qv1
	DD	FLAT:??_C@_08FMHFNGGG@3Ds?5Sky2@
	DD	FLAT:_skybox_qv2
	DD	FLAT:??_C@_08GJNKOGEK@3Ds?5Cube@
	DD	FLAT:_cubemap_v1
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_FS_LoadImage
PUBLIC	_FS_SaveImage
PUBLIC	_FS_CopyImage
PUBLIC	_FS_FreeImage
PUBLIC	_Image_Reset
PUBLIC	_ImagePack
PUBLIC	_FS_AddSideToPack
PUBLIC	?__LINE__Var@?0??ImagePack@@9@9			; `ImagePack'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_AddSideToPack@@9@9		; `FS_AddSideToPack'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_LoadImage@@9@9		; `FS_LoadImage'::`1'::__LINE__Var
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@		; `string'
PUBLIC	??_C@_0CP@LGPBIILP@?$FO3Warning?3?$FO7?5FS_LoadImage?3?5coul@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_FreeImage@@9@9		; `FS_FreeImage'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_CopyImage@@9@9		; `FS_CopyImage'::`1'::__LINE__Var
EXTRN	_memcpy:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Image_ResampleInternal:PROC
EXTRN	_Image_FlipInternal:PROC
EXTRN	_Image_Copy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?__LINE__Var@?0??FS_CopyImage@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_CopyImage@@9@9 DD 01cbH		; `FS_CopyImage'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_FreeImage@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_FreeImage@@9@9 DD 01bcH		; `FS_FreeImage'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CP@LGPBIILP@?$FO3Warning?3?$FO7?5FS_LoadImage?3?5coul@
CONST	SEGMENT
??_C@_0CP@LGPBIILP@?$FO3Warning?3?$FO7?5FS_LoadImage?3?5coul@ DB '^3Warni'
	DB	'ng:^7 FS_LoadImage: couldn''t load "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
CONST	SEGMENT
??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@ DB '%s%s.%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_LoadImage@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_LoadImage@@9@9 DD 0d4H		; `FS_LoadImage'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_AddSideToPack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_AddSideToPack@@9@9 DD 0a5H		; `FS_AddSideToPack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_main.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ImagePack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??ImagePack@@9@9 DD 070H			; `ImagePack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0351H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0604H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _FS_AddSideToPack
_TEXT	SEGMENT
_resampled$ = -12					; size = 4
_flipped$ = -8						; size = 4
_out$ = -4						; size = 4
_name$ = 8						; size = 4
_adjust_flags$ = 12					; size = 4
_FS_AddSideToPack PROC					; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 166  : 	byte	*out, *flipped;
; 167  : 	qboolean	resampled = false;

	mov	DWORD PTR _resampled$[ebp], 0

; 168  : 	
; 169  : 	// first side set average size for all cubemap sides!
; 170  : 	if( !image.cubemap )

	cmp	DWORD PTR _image+60, 0
	jne	SHORT $LN2@FS_AddSide

; 171  : 	{
; 172  : 		image.source_width = image.width;

	movzx	eax, WORD PTR _image+8
	mov	DWORD PTR _image+44, eax

; 173  : 		image.source_height = image.height;

	movzx	eax, WORD PTR _image+10
	mov	DWORD PTR _image+48, eax

; 174  : 		image.source_type = image.type;

	mov	eax, DWORD PTR _image+20
	mov	DWORD PTR _image+52, eax
$LN2@FS_AddSide:

; 175  : 	}
; 176  : 
; 177  : 	// keep constant size, render.dll expecting it
; 178  : 	image.size = image.source_width * image.source_height * 4;

	mov	eax, DWORD PTR _image+44
	imul	eax, DWORD PTR _image+48
	shl	eax, 2
	mov	DWORD PTR _image+28, eax

; 179  :           
; 180  : 	// mixing dds format with any existing ?
; 181  : 	if( image.type != image.source_type )

	mov	eax, DWORD PTR _image+20
	cmp	eax, DWORD PTR _image+52
	je	SHORT $LN3@FS_AddSide

; 182  : 		return false;

	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN3@FS_AddSide:

; 183  : 
; 184  : 	// flip image if needed
; 185  : 	flipped = Image_FlipInternal( image.rgba, &image.width, &image.height, image.source_type, adjust_flags );

	mov	eax, DWORD PTR _adjust_flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+52
	push	ecx
	push	OFFSET _image+10
	push	OFFSET _image+8
	mov	edx, DWORD PTR _image+40
	push	edx
	call	_Image_FlipInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _flipped$[ebp], eax

; 186  : 	if( !flipped ) return false; // try to reasmple dxt?

	cmp	DWORD PTR _flipped$[ebp], 0
	jne	SHORT $LN4@FS_AddSide
	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN4@FS_AddSide:

; 187  : 	if( flipped != image.rgba ) image.rgba = Image_Copy( image.size );

	mov	eax, DWORD PTR _flipped$[ebp]
	cmp	eax, DWORD PTR _image+40
	je	SHORT $LN5@FS_AddSide
	mov	eax, DWORD PTR _image+28
	push	eax
	call	_Image_Copy
	add	esp, 4
	mov	DWORD PTR _image+40, eax
$LN5@FS_AddSide:

; 188  : 
; 189  : 	// resampling image if needed
; 190  : 	out = Image_ResampleInternal((uint *)image.rgba, image.width, image.height, image.source_width, image.source_height, image.source_type, &resampled );

	lea	eax, DWORD PTR _resampled$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+52
	push	ecx
	mov	edx, DWORD PTR _image+48
	push	edx
	mov	eax, DWORD PTR _image+44
	push	eax
	movzx	ecx, WORD PTR _image+10
	push	ecx
	movzx	edx, WORD PTR _image+8
	push	edx
	mov	eax, DWORD PTR _image+40
	push	eax
	call	_Image_ResampleInternal
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 191  : 	if( !out ) return false; // try to reasmple dxt?

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN6@FS_AddSide
	xor	eax, eax
	jmp	$LN1@FS_AddSide
$LN6@FS_AddSide:

; 192  : 	if( resampled ) image.rgba = Image_Copy( image.size );

	cmp	DWORD PTR _resampled$[ebp], 0
	je	SHORT $LN7@FS_AddSide
	mov	eax, DWORD PTR _image+28
	push	eax
	call	_Image_Copy
	add	esp, 4
	mov	DWORD PTR _image+40, eax
$LN7@FS_AddSide:

; 193  : 
; 194  : 	image.cubemap = Mem_Realloc( host.imagepool, image.cubemap, image.ptr + image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_AddSideToPack@@9@9
	add	eax, 29					; 0000001dH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _image+32
	add	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _image+60
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+60, eax

; 195  : 	memcpy( image.cubemap + image.ptr, image.rgba, image.size ); // add new side

	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+40
	push	ecx
	mov	edx, DWORD PTR _image+60
	add	edx, DWORD PTR _image+32
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 196  : 
; 197  : 	Mem_Free( image.rgba );	// release source buffer

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_AddSideToPack@@9@9
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _image+40
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 198  : 	image.ptr += image.size; 	// move to next

	mov	eax, DWORD PTR _image+32
	add	eax, DWORD PTR _image+28
	mov	DWORD PTR _image+32, eax

; 199  : 	image.num_sides++;		// bump sides count

	mov	eax, DWORD PTR _image+56
	add	eax, 1
	mov	DWORD PTR _image+56, eax

; 200  : 
; 201  : 	return true;

	mov	eax, 1
$LN1@FS_AddSide:

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddSideToPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _ImagePack
_TEXT	SEGMENT
_pack$ = -4						; size = 4
_ImagePack PROC						; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 113  : 	rgbdata_t	*pack = Mem_Calloc( host.imagepool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??ImagePack@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	36					; 00000024H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pack$[ebp], eax

; 114  : 
; 115  : 	// clear any force flags
; 116  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 117  : 
; 118  : 	if( image.cubemap && image.num_sides != 6 )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN2@ImagePack
	cmp	DWORD PTR _image+56, 6
	je	SHORT $LN2@ImagePack

; 119  : 	{
; 120  : 		// this never be happens, just in case
; 121  : 		FS_FreeImage( pack );

	mov	eax, DWORD PTR _pack$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 122  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@ImagePack
$LN2@ImagePack:

; 123  : 	}
; 124  : 
; 125  : 	if( image.cubemap ) 

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN3@ImagePack

; 126  : 	{
; 127  : 		image.flags |= IMAGE_CUBEMAP;

	mov	eax, DWORD PTR _image+24
	or	eax, 1
	mov	DWORD PTR _image+24, eax

; 128  : 		pack->buffer = image.cubemap;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+60
	mov	DWORD PTR [eax+24], ecx

; 129  : 		pack->width = image.source_width;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+44
	mov	WORD PTR [eax], cx

; 130  : 		pack->height = image.source_height;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+48
	mov	WORD PTR [eax+2], cx

; 131  : 		pack->type = image.source_type;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+52
	mov	DWORD PTR [eax+8], ecx

; 132  : 		pack->size = image.size * image.num_sides;

	mov	eax, DWORD PTR _image+28
	imul	eax, DWORD PTR _image+56
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 133  : 	}

	jmp	SHORT $LN4@ImagePack
$LN3@ImagePack:

; 134  : 	else 
; 135  : 	{
; 136  : 		pack->buffer = image.rgba;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+40
	mov	DWORD PTR [eax+24], ecx

; 137  : 		pack->width = image.width;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+8
	mov	WORD PTR [eax], cx

; 138  : 		pack->height = image.height;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+10
	mov	WORD PTR [eax+2], cx

; 139  : 		pack->depth = image.depth;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+12
	mov	WORD PTR [eax+4], cx

; 140  : 		pack->type = image.type;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+20
	mov	DWORD PTR [eax+8], ecx

; 141  : 		pack->size = image.size;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+28
	mov	DWORD PTR [eax+32], ecx
$LN4@ImagePack:

; 142  : 	}
; 143  : 
; 144  : 	// copy fog params
; 145  : 	pack->fogParams[0] = image.fogParams[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _image[ecx+76]
	mov	BYTE PTR [edx+eax+28], cl

; 146  : 	pack->fogParams[1] = image.fogParams[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pack$[ebp]
	mov	al, BYTE PTR _image[eax+76]
	mov	BYTE PTR [edx+ecx+28], al

; 147  : 	pack->fogParams[2] = image.fogParams[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pack$[ebp]
	mov	al, BYTE PTR _image[eax+76]
	mov	BYTE PTR [edx+ecx+28], al

; 148  : 	pack->fogParams[3] = image.fogParams[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _image[ecx+76]
	mov	BYTE PTR [edx+eax+28], cl

; 149  : 
; 150  : 	pack->flags = image.flags;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+24
	mov	DWORD PTR [eax+12], ecx

; 151  : 	pack->numMips = image.num_mips;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _image+14
	mov	BYTE PTR [eax+18], cl

; 152  : 	pack->palette = image.palette;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _image+72
	mov	DWORD PTR [eax+20], ecx

; 153  : 	pack->encode = image.encode;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _image+16
	mov	WORD PTR [eax+16], cx

; 154  : 	
; 155  : 	return pack;

	mov	eax, DWORD PTR _pack$[ebp]
$LN1@ImagePack:

; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ImagePack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _Image_Reset
_TEXT	SEGMENT
_Image_Reset PROC					; COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 90   : 	// reset global variables
; 91   : 	image.width = image.height = image.depth = 0;

	xor	eax, eax
	mov	WORD PTR _image+12, ax
	mov	cx, WORD PTR _image+12
	mov	WORD PTR _image+10, cx
	mov	dx, WORD PTR _image+10
	mov	WORD PTR _image+8, dx

; 92   : 	image.source_width = image.source_height = 0;

	mov	DWORD PTR _image+48, 0
	mov	eax, DWORD PTR _image+48
	mov	DWORD PTR _image+44, eax

; 93   : 	image.source_type = image.num_mips = 0;

	mov	BYTE PTR _image+14, 0
	movzx	eax, BYTE PTR _image+14
	mov	DWORD PTR _image+52, eax

; 94   : 	image.num_sides = image.flags = 0;

	mov	DWORD PTR _image+24, 0
	mov	eax, DWORD PTR _image+24
	mov	DWORD PTR _image+56, eax

; 95   : 	image.encode = DXT_ENCODE_DEFAULT;

	xor	eax, eax
	mov	WORD PTR _image+16, ax

; 96   : 	image.type = PF_UNKNOWN;

	mov	DWORD PTR _image+20, 0

; 97   : 	image.fogParams[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _image[ecx+76], 0

; 98   : 	image.fogParams[1] = 0;

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _image[eax+76], 0

; 99   : 	image.fogParams[2] = 0;

	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _image[eax+76], 0

; 100  : 	image.fogParams[3] = 0;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _image[ecx+76], 0

; 101  : 
; 102  : 	// pointers will be saved with prevoius picture struct
; 103  : 	// don't care about it
; 104  : 	image.palette = NULL;

	mov	DWORD PTR _image+72, 0

; 105  : 	image.cubemap = NULL;

	mov	DWORD PTR _image+60, 0

; 106  : 	image.rgba = NULL;

	mov	DWORD PTR _image+40, 0

; 107  : 	image.ptr = 0;

	mov	DWORD PTR _image+32, 0

; 108  : 	image.size = 0;

	mov	DWORD PTR _image+28, 0

; 109  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _FS_FreeImage
_TEXT	SEGMENT
_pack$ = 8						; size = 4
_FS_FreeImage PROC					; COMDAT

; 444  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 445  : 	if( !pack ) return;

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN2@FS_FreeIma
	jmp	SHORT $LN1@FS_FreeIma
$LN2@FS_FreeIma:

; 446  : 	if( pack->buffer ) Mem_Free( pack->buffer );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@FS_FreeIma
	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FreeImage@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@FS_FreeIma:

; 447  : 	if( pack->palette ) Mem_Free( pack->palette );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN4@FS_FreeIma
	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FreeImage@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@FS_FreeIma:

; 448  : 	Mem_Free( pack );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FreeImage@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pack$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@FS_FreeIma:

; 449  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FreeImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _FS_CopyImage
_TEXT	SEGMENT
tv74 = -76						; size = 4
_palSize$ = -8						; size = 4
_out$ = -4						; size = 4
_in$ = 8						; size = 4
_FS_CopyImage PROC					; COMDAT

; 459  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 460  : 	rgbdata_t	*out;
; 461  : 	int	palSize = 0;

	mov	DWORD PTR _palSize$[ebp], 0

; 462  : 
; 463  : 	if( !in ) return NULL;

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN4@FS_CopyIma
	xor	eax, eax
	jmp	$LN1@FS_CopyIma
$LN4@FS_CopyIma:

; 464  : 
; 465  : 	out = Mem_Malloc( host.imagepool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_CopyImage@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	36					; 00000024H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 466  : 	*out = *in;

	mov	ecx, 9
	mov	esi, DWORD PTR _in$[ebp]
	mov	edi, DWORD PTR _out$[ebp]
	rep movsd

; 467  : 
; 468  : 	switch( in->type )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv74[ebp], ecx
	cmp	DWORD PTR tv74[ebp], 1
	je	SHORT $LN5@FS_CopyIma
	cmp	DWORD PTR tv74[ebp], 2
	je	SHORT $LN6@FS_CopyIma
	jmp	SHORT $LN2@FS_CopyIma
$LN5@FS_CopyIma:

; 469  : 	{
; 470  : 	case PF_INDEXED_24:
; 471  : 		palSize = 768;

	mov	DWORD PTR _palSize$[ebp], 768		; 00000300H

; 472  : 		break;

	jmp	SHORT $LN2@FS_CopyIma
$LN6@FS_CopyIma:

; 473  : 	case PF_INDEXED_32:
; 474  : 		palSize = 1024;

	mov	DWORD PTR _palSize$[ebp], 1024		; 00000400H
$LN2@FS_CopyIma:

; 475  : 		break;
; 476  : 	}
; 477  : 
; 478  : 	if( palSize )

	cmp	DWORD PTR _palSize$[ebp], 0
	je	SHORT $LN7@FS_CopyIma

; 479  : 	{
; 480  : 		out->palette = Mem_Malloc( host.imagepool, palSize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_CopyImage@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _palSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 481  : 		memcpy( out->palette, in->palette, palSize );

	mov	eax, DWORD PTR _palSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@FS_CopyIma:

; 482  : 	}
; 483  : 
; 484  : 	if( in->size )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN8@FS_CopyIma

; 485  : 	{
; 486  : 		out->buffer = Mem_Malloc( host.imagepool, in->size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_CopyImage@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 487  : 		memcpy( out->buffer, in->buffer, in->size );

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@FS_CopyIma:

; 488  : 	}
; 489  : 
; 490  : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@FS_CopyIma:

; 491  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CopyImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _FS_SaveImage
_TEXT	SEGMENT
tv73 = -680						; size = 4
tv162 = -676						; size = 4
tv71 = -676						; size = 4
_i$1 = -544						; size = 4
_box$2 = -540						; size = 4
_picBuffer$3 = -536					; size = 4
_realSize$4 = -532					; size = 4
_format$ = -528						; size = 4
_savename$ = -524					; size = 256
_path$ = -268						; size = 256
_anyformat$ = -12					; size = 4
_ext$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pix$ = 12						; size = 4
_FS_SaveImage PROC					; COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 680				; 000002a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 354  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 355  : 	qboolean		anyformat = !Q_stricmp( ext, "" ) ? true : false;

	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@FS_SaveIma
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN25@FS_SaveIma
$LN24@FS_SaveIma:
	mov	DWORD PTR tv71[ebp], 0
$LN25@FS_SaveIma:
	cmp	DWORD PTR tv71[ebp], 0
	je	SHORT $LN26@FS_SaveIma
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN27@FS_SaveIma
$LN26@FS_SaveIma:
	mov	DWORD PTR tv73[ebp], 0
$LN27@FS_SaveIma:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _anyformat$[ebp], ecx

; 356  : 	string		path, savename;
; 357  : 	const savepixformat_t *format;
; 358  : 
; 359  : 	if( !pix || !pix->buffer || anyformat )

	cmp	DWORD PTR _pix$[ebp], 0
	je	SHORT $LN12@FS_SaveIma
	mov	eax, DWORD PTR _pix$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN12@FS_SaveIma
	cmp	DWORD PTR _anyformat$[ebp], 0
	je	SHORT $LN11@FS_SaveIma
$LN12@FS_SaveIma:

; 360  : 	{
; 361  : 		// clear any force flags
; 362  : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 363  : 		return false;

	xor	eax, eax
	jmp	$LN1@FS_SaveIma
$LN11@FS_SaveIma:

; 364  : 	}
; 365  : 
; 366  : 	Q_strncpy( savename, filename, sizeof( savename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _savename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 367  : 	COM_StripExtension( savename ); // remove extension if needed

	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 368  : 
; 369  : 	if( pix->flags & (IMAGE_CUBEMAP|IMAGE_SKYBOX))

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 33					; 00000021H
	je	$LN13@FS_SaveIma

; 370  : 	{
; 371  : 		size_t		realSize = pix->size; // keep real pic size

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _realSize$4[ebp], ecx

; 372  : 		byte		*picBuffer; // to avoid corrupt memory on free data
; 373  : 		const suffix_t	*box;
; 374  : 		int		i;
; 375  : 
; 376  : 		if( pix->flags & IMAGE_SKYBOX )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 32					; 00000020H
	je	SHORT $LN15@FS_SaveIma

; 377  : 			box = skybox_qv1;

	mov	DWORD PTR _box$2[ebp], OFFSET _skybox_qv1
	jmp	SHORT $LN16@FS_SaveIma
$LN15@FS_SaveIma:

; 378  : 		else if( pix->flags & IMAGE_CUBEMAP )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	SHORT $LN17@FS_SaveIma

; 379  : 			box = cubemap_v1;

	mov	DWORD PTR _box$2[ebp], OFFSET _cubemap_v1
	jmp	SHORT $LN16@FS_SaveIma
$LN17@FS_SaveIma:

; 380  : 		else
; 381  : 		{
; 382  : 			// clear any force flags
; 383  : 			image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 384  : 			return false;	// do not happens

	xor	eax, eax
	jmp	$LN1@FS_SaveIma
$LN16@FS_SaveIma:

; 385  : 		}
; 386  : 
; 387  : 		pix->size /= 6; // now set as side size 

	mov	eax, DWORD PTR _pix$[ebp]
	mov	eax, DWORD PTR [eax+32]
	xor	edx, edx
	mov	ecx, 6
	div	ecx
	mov	edx, DWORD PTR _pix$[ebp]
	mov	DWORD PTR [edx+32], eax

; 388  : 		picBuffer = pix->buffer;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _picBuffer$3[ebp], ecx

; 389  : 
; 390  : 		// save all sides seperately
; 391  : 		for( format = image.saveformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image+4
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN4@FS_SaveIma
$LN2@FS_SaveIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN4@FS_SaveIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN3@FS_SaveIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN3@FS_SaveIma

; 392  : 		{
; 393  : 			if( !Q_stricmp( ext, format->ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN19@FS_SaveIma

; 394  : 			{
; 395  : 				for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@FS_SaveIma
$LN5@FS_SaveIma:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN7@FS_SaveIma:
	cmp	DWORD PTR _i$1[ebp], 6
	jge	SHORT $LN6@FS_SaveIma

; 396  : 				{
; 397  : 					Q_sprintf( path, format->formatstring, savename, box[i].suf, format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	imul	edx, DWORD PTR _i$1[ebp], 12
	mov	eax, DWORD PTR _box$2[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 398  : 					if( !format->savefunc( path, pix )) break; // there were errors

	mov	eax, DWORD PTR _pix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@FS_SaveIma
	jmp	SHORT $LN6@FS_SaveIma
$LN20@FS_SaveIma:

; 399  : 					pix->buffer += pix->size; // move pointer

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _pix$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR _pix$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 400  : 				}

	jmp	$LN5@FS_SaveIma
$LN6@FS_SaveIma:

; 401  : 
; 402  : 				// restore pointers
; 403  : 				pix->size = realSize;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR _realSize$4[ebp]
	mov	DWORD PTR [eax+32], ecx

; 404  : 				pix->buffer = picBuffer;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR _picBuffer$3[ebp]
	mov	DWORD PTR [eax+24], ecx

; 405  : 
; 406  : 				// clear any force flags
; 407  : 				image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 408  : 
; 409  : 				return ( i == 6 );

	cmp	DWORD PTR _i$1[ebp], 6
	jne	SHORT $LN28@FS_SaveIma
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN29@FS_SaveIma
$LN28@FS_SaveIma:
	mov	DWORD PTR tv162[ebp], 0
$LN29@FS_SaveIma:
	mov	eax, DWORD PTR tv162[ebp]
	jmp	$LN1@FS_SaveIma
$LN19@FS_SaveIma:

; 410  : 			}
; 411  : 		}

	jmp	$LN2@FS_SaveIma
$LN3@FS_SaveIma:

; 412  : 	}

	jmp	$LN14@FS_SaveIma
$LN13@FS_SaveIma:

; 413  : 	else
; 414  : 	{
; 415  : 		for( format = image.saveformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image+4
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN10@FS_SaveIma
$LN8@FS_SaveIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN10@FS_SaveIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN14@FS_SaveIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN14@FS_SaveIma

; 416  : 		{
; 417  : 			if( !Q_stricmp( ext, format->ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_SaveIma

; 418  : 			{
; 419  : 				Q_sprintf( path, format->formatstring, savename, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	edx, DWORD PTR _savename$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 420  : 				if( format->savefunc( path, pix ))

	mov	eax, DWORD PTR _pix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@FS_SaveIma

; 421  : 				{
; 422  : 					// clear any force flags
; 423  : 					image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 424  : 					return true; // saved

	mov	eax, 1
	jmp	SHORT $LN1@FS_SaveIma
$LN21@FS_SaveIma:

; 425  : 				}
; 426  : 			}
; 427  : 		}

	jmp	$LN8@FS_SaveIma
$LN14@FS_SaveIma:

; 428  : 	}
; 429  : 
; 430  : 	// clear any force flags
; 431  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 432  : 
; 433  : 	return false;

	xor	eax, eax
$LN1@FS_SaveIma:

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SaveImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_main.c
;	COMDAT _FS_LoadImage
_TEXT	SEGMENT
_f$ = -800						; size = 4
_cmap$ = -796						; size = 4
_format$ = -792						; size = 4
_filesize$ = -788					; size = 4
_i$ = -784						; size = 4
_anyformat$ = -780					; size = 4
_sidename$ = -776					; size = 256
_loadname$ = -520					; size = 256
_path$ = -264						; size = 256
_ext$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_FS_LoadImage PROC					; COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 928				; 000003a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 213  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 214  : 	string		path, loadname, sidename;
; 215  : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 216  : 	int		i, filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 217  : 	const loadpixformat_t *format;
; 218  : 	const cubepack_t	*cmap;
; 219  : 	byte		*f;
; 220  : 
; 221  : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 222  : 	Image_Reset(); // clear old image

	call	_Image_Reset

; 223  : 
; 224  : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@FS_LoadIma

; 225  : 	{
; 226  : 		// we needs to compare file extension with list of supported formats
; 227  : 		// and be sure what is real extension, not a filename with dot
; 228  : 		for( format = image.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN4@FS_LoadIma
$LN2@FS_LoadIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], eax
$LN4@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN20@FS_LoadIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@FS_LoadIma

; 229  : 		{
; 230  : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_LoadIma

; 231  : 			{
; 232  : 				COM_StripExtension( loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 233  : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 234  : 				break;

	jmp	SHORT $LN20@FS_LoadIma
$LN21@FS_LoadIma:

; 235  : 			}
; 236  : 		}

	jmp	SHORT $LN2@FS_LoadIma
$LN20@FS_LoadIma:

; 237  : 	}
; 238  : 
; 239  : 	// special mode: skip any checks, load file from buffer
; 240  : 	if( filename[0] == '#' && buffer && size )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN22@FS_LoadIma
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN22@FS_LoadIma
	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN22@FS_LoadIma

; 241  : 		goto load_internal;

	jmp	$load_internal$45
$LN22@FS_LoadIma:

; 242  : 
; 243  : 	// now try all the formats in the selected list
; 244  : 	for( format = image.loadformats; format && format->formatstring; format++)

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN7@FS_LoadIma
$LN5@FS_LoadIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], eax
$LN7@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN6@FS_LoadIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN6@FS_LoadIma

; 245  : 	{
; 246  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN24@FS_LoadIma
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN23@FS_LoadIma
$LN24@FS_LoadIma:

; 247  : 		{
; 248  : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 249  : 			image.hint = format->hint;

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+80, ecx

; 250  : 			f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	eax, DWORD PTR _filesize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 251  : 
; 252  : 			if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN23@FS_LoadIma
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	SHORT $LN23@FS_LoadIma

; 253  : 			{
; 254  : 				if( format->loadfunc( path, f, filesize ))

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@FS_LoadIma

; 255  : 				{
; 256  : 					Mem_Free( f ); // release buffer

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 257  : 					return ImagePack(); // loaded

	call	_ImagePack
	jmp	$LN1@FS_LoadIma

; 258  : 				}

	jmp	SHORT $LN23@FS_LoadIma
$LN26@FS_LoadIma:

; 259  : 				else Mem_Free( f ); // release buffer 

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 47					; 0000002fH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@FS_LoadIma:

; 260  : 			}
; 261  : 		}
; 262  : 	}

	jmp	$LN5@FS_LoadIma
$LN6@FS_LoadIma:

; 263  : 
; 264  : 	// check all cubemap sides with package suffix
; 265  : 	for( cmap = load_cubemap; cmap && cmap->type; cmap++ )

	mov	DWORD PTR _cmap$[ebp], OFFSET _load_cubemap
	jmp	SHORT $LN10@FS_LoadIma
$LN8@FS_LoadIma:
	mov	eax, DWORD PTR _cmap$[ebp]
	add	eax, 8
	mov	DWORD PTR _cmap$[ebp], eax
$LN10@FS_LoadIma:
	cmp	DWORD PTR _cmap$[ebp], 0
	je	$LN9@FS_LoadIma
	mov	eax, DWORD PTR _cmap$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN9@FS_LoadIma

; 266  : 	{
; 267  : 		for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@FS_LoadIma
$LN11@FS_LoadIma:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@FS_LoadIma:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN12@FS_LoadIma

; 268  : 		{
; 269  : 			// for support mixed cubemaps e.g. sky_ft.bmp, sky_rt.tga
; 270  : 			// NOTE: all loaders must keep sides in one format for all
; 271  : 			for( format = image.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN16@FS_LoadIma
$LN14@FS_LoadIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], eax
$LN16@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN15@FS_LoadIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN15@FS_LoadIma

; 272  : 			{
; 273  : 				if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN29@FS_LoadIma
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN28@FS_LoadIma
$LN29@FS_LoadIma:

; 274  : 				{
; 275  : 					Q_sprintf( path, format->formatstring, loadname, cmap->type[i].suf, format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _cmap$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 276  : 					image.hint = cmap->type[i].hint; // side hint

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _cmap$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _image+80, eax

; 277  : 
; 278  : 					f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	eax, DWORD PTR _filesize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 279  : 					if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	$LN28@FS_LoadIma
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	$LN28@FS_LoadIma

; 280  : 					{
; 281  : 						// this name will be used only for tell user about problems 
; 282  : 						if( format->loadfunc( path, f, filesize ))

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN31@FS_LoadIma

; 283  : 						{         
; 284  : 							Q_snprintf( sidename, sizeof( sidename ), "%s%s.%s", loadname, cmap->type[i].suf, format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _cmap$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+edx]
	push	edx
	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	push	OFFSET ??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _sidename$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 285  : 							if( FS_AddSideToPack( sidename, cmap->type[i].flags )) // process flags to flip some sides

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _cmap$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+4]
	push	eax
	lea	ecx, DWORD PTR _sidename$[ebp]
	push	ecx
	call	_FS_AddSideToPack
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@FS_LoadIma

; 286  : 							{
; 287  : 								Mem_Free( f );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 75					; 0000004bH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 288  : 								break; // loaded

	jmp	SHORT $LN15@FS_LoadIma
$LN31@FS_LoadIma:

; 289  : 							}
; 290  : 						}
; 291  : 						Mem_Free( f );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 79					; 0000004fH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN28@FS_LoadIma:

; 292  : 					}
; 293  : 				}
; 294  : 			}

	jmp	$LN14@FS_LoadIma
$LN15@FS_LoadIma:

; 295  : 
; 296  : 			if( image.num_sides != i + 1 ) // check side

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	cmp	DWORD PTR _image+56, eax
	je	SHORT $LN33@FS_LoadIma

; 297  : 			{
; 298  : 				// first side not found, probably it's not cubemap
; 299  : 				// it contain info about image_type and dimensions, don't generate black cubemaps 
; 300  : 				if( !image.cubemap ) break;

	cmp	DWORD PTR _image+60, 0
	jne	SHORT $LN34@FS_LoadIma
	jmp	SHORT $LN12@FS_LoadIma
$LN34@FS_LoadIma:

; 301  : 				// Mem_Alloc already filled memblock with 0x00, no need to do it again
; 302  : 				image.cubemap = Mem_Realloc( host.imagepool, image.cubemap, image.ptr + image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 90					; 0000005aH
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _image+32
	add	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _image+60
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+60, eax

; 303  : 				image.ptr += image.size; // move to next

	mov	eax, DWORD PTR _image+32
	add	eax, DWORD PTR _image+28
	mov	DWORD PTR _image+32, eax

; 304  : 				image.num_sides++; // merge counter

	mov	eax, DWORD PTR _image+56
	add	eax, 1
	mov	DWORD PTR _image+56, eax
$LN33@FS_LoadIma:

; 305  : 			}
; 306  : 		}

	jmp	$LN11@FS_LoadIma
$LN12@FS_LoadIma:

; 307  : 
; 308  : 		// make sure what all sides is loaded
; 309  : 		if( image.num_sides != 6 )

	cmp	DWORD PTR _image+56, 6
	je	SHORT $LN35@FS_LoadIma

; 310  : 		{
; 311  : 			// unexpected errors ?
; 312  : 			if( image.cubemap )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $LN37@FS_LoadIma

; 313  : 				Mem_Free( image.cubemap );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadImage@@9@9
	add	eax, 101				; 00000065H
	push	eax
	push	OFFSET ??_C@_0DO@DANPHGDH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _image+60
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN37@FS_LoadIma:

; 314  : 			Image_Reset();

	call	_Image_Reset

; 315  : 		}

	jmp	SHORT $LN36@FS_LoadIma
$LN35@FS_LoadIma:

; 316  : 		else break;

	jmp	SHORT $LN9@FS_LoadIma
$LN36@FS_LoadIma:

; 317  : 	}

	jmp	$LN8@FS_LoadIma
$LN9@FS_LoadIma:

; 318  : 
; 319  : 	if( image.cubemap )

	cmp	DWORD PTR _image+60, 0
	je	SHORT $load_internal$45

; 320  : 		return ImagePack(); // all done

	call	_ImagePack
	jmp	$LN1@FS_LoadIma
$load_internal$45:

; 321  : 
; 322  : load_internal:
; 323  : 	for( format = image.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _image
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN19@FS_LoadIma
$LN17@FS_LoadIma:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _format$[ebp], eax
$LN19@FS_LoadIma:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN18@FS_LoadIma
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN18@FS_LoadIma

; 324  : 	{
; 325  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN40@FS_LoadIma
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@FS_LoadIma
$LN40@FS_LoadIma:

; 326  : 		{
; 327  : 			image.hint = format->hint;

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+80, ecx

; 328  : 			if( buffer && size > 0  )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN39@FS_LoadIma
	cmp	DWORD PTR _size$[ebp], 0
	jbe	SHORT $LN39@FS_LoadIma

; 329  : 			{
; 330  : 				if( format->loadfunc( loadname, buffer, size ))

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN39@FS_LoadIma

; 331  : 					return ImagePack(); // loaded

	call	_ImagePack
	jmp	SHORT $LN1@FS_LoadIma
$LN39@FS_LoadIma:

; 332  : 			}
; 333  : 		}
; 334  : 	}

	jmp	$LN17@FS_LoadIma
$LN18@FS_LoadIma:

; 335  : 
; 336  : 	if( filename[0] != '#' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN43@FS_LoadIma

; 337  : 		Con_Reportf( S_WARN "FS_LoadImage: couldn't load \"%s\"\n", loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@LGPBIILP@?$FO3Warning?3?$FO7?5FS_LoadImage?3?5coul@
	call	_Con_Reportf
	add	esp, 8
$LN43@FS_LoadIma:

; 338  : 
; 339  : 	// clear any force flags
; 340  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 341  : 
; 342  : 	return NULL;

	xor	eax, eax
$LN1@FS_LoadIma:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadImage ENDP
_TEXT	ENDS
END
