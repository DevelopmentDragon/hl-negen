; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_rmain.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_GL_TextureData
PUBLIC	_CL_GenericHandle
EXTRN	_Cvar_Set:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_Host_Error:PROC
EXTRN	_pfnTime:PROC
EXTRN	_AVI_GetVideoFrameNumber:PROC
EXTRN	_AVI_GetVideoFrame:PROC
EXTRN	_AVI_GetVideoInfo:PROC
EXTRN	_AVI_LoadVideo:PROC
EXTRN	_AVI_IsActive:PROC
EXTRN	_AVI_FreeVideo:PROC
EXTRN	_COM_SetRandomSeed:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_pfnSPR_LoadExt:PROC
EXTRN	_CL_DrawParticlesExternal:PROC
EXTRN	_S_StreamAviSamples:PROC
EXTRN	_S_FadeMusicVolume:PROC
EXTRN	_GL_CleanUpTextureUnits:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_SetTexCoordArrayMode:PROC
EXTRN	_GL_LoadTexMatrixExt:PROC
EXTRN	_GL_TexGen:PROC
EXTRN	_GL_SelectTexture:PROC
EXTRN	_GL_LoadIdentityTexMatrix:PROC
EXTRN	_GL_TextureTarget:PROC
EXTRN	_R_DecalSetupVerts:PROC
EXTRN	_DrawSingleDecal:PROC
EXTRN	_R_EntityRemoveDecals:PROC
EXTRN	_R_UploadStretchRaw:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureArray:PROC
EXTRN	_GL_CreateTexture:PROC
EXTRN	_GL_CreateTextureArray:PROC
EXTRN	_GL_UpdateTexSize:PROC
EXTRN	_GL_FindTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_StoreEfrags:PROC
EXTRN	_R_LightVec:PROC
EXTRN	_R_StudioGetTexture:PROC
EXTRN	_GL_GetProcAddress:PROC
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_RI:BYTE:01320H
COMM	_gldepthmin:DWORD
COMM	_gldepthmax:DWORD
_DATA	ENDS
PUBLIC	_R_ClearScene
PUBLIC	_R_LoadIdentity
PUBLIC	_R_RenderScene
PUBLIC	_R_DrawCubemapView
PUBLIC	_R_SetupRefParams
PUBLIC	_R_TranslateForEntity
PUBLIC	_R_RotateForEntity
PUBLIC	_R_SetupGL
PUBLIC	_R_InitRenderAPI
PUBLIC	_R_AllowFog
PUBLIC	_R_SetupFrustum
PUBLIC	_R_FindViewLeaf
PUBLIC	_R_PushScene
PUBLIC	_R_PopScene
PUBLIC	_R_DrawFog
PUBLIC	_R_BeginFrame
PUBLIC	_R_RenderFrame
PUBLIC	_R_EndFrame
PUBLIC	_R_WorldToScreen
PUBLIC	_R_ScreenToWorld
PUBLIC	_R_AddEntity
PUBLIC	_R_StaticEntityLegacy
PUBLIC	_R_DrawEntitiesOnList
PUBLIC	_R_DoResetGamma
PUBLIC	??_C@_0BF@HNEHGHKE@draw?5stack?5overflow?6@	; `string'
PUBLIC	??_C@_0BG@IOCCNMCG@draw?5stack?5underflow?6@	; `string'
PUBLIC	?__LINE__Var@?0??R_RecursiveFindWaterTexture@@9@9 ; `R_RecursiveFindWaterTexture'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9	; `R_DrawEntitiesOnList'::`1'::__LINE__Var
PUBLIC	??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0BP@KBAHKDFL@R_RenderView?3?5NULL?5worldmodel?6@ ; `string'
PUBLIC	??_C@_0EP@KKAKMOHG@failed?5to?5swap?5buffers?6Check?5yo@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_RenderGetParm@@9@9		; `GL_RenderGetParm'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@LLNLIDFH@arg?5?$DO?$DN?50?5?$CG?$CG?5arg?5?$DM?56@ ; `string'
PUBLIC	??_C@_03LNHMGGNB@Sky@				; `string'
PUBLIC	??_C@_03EJFNLALG@Env@				; `string'
PUBLIC	??_C@_0DN@PEPBOIAI@?$FO1Error?3?$FO7?5R_?$CFsShot?3?5subsystem?5@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_GetLightStyle@@9@9		; `CL_GetLightStyle'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@NEINIPGH@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_LIG@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_GetDynamicLight@@9@9	; `CL_GetDynamicLight'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@NBLMOECG@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_DLI@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_GetEntityLight@@9@9		; `CL_GetEntityLight'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@BNBGOELI@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_ELI@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnGetFilesList@@9@9		; `pfnGetFilesList'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@LPDJHGLP@CL_LoadProgs?3?5?$FO2initailized?5ext@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@37d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f91df46aaaaaaab
PUBLIC	__real@3f9eb851eb851eb8
PUBLIC	__real@3fdd70a4
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe66666
PUBLIC	__real@3fef0a3d70a3d70a
PUBLIC	__real@3ff07ae147ae147b
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@40490fdb
PUBLIC	__real@4076800000000000
PUBLIC	__real@42b40000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@45000000
PUBLIC	__real@47c35000
PUBLIC	__real@4e6e6b28
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_CL_ExtraUpdate:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_BuildGammaTable:PROC
EXTRN	_atan:PROC
EXTRN	_sin:PROC
EXTRN	_tan:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_Matrix4x4_ConcatTransforms:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_Invert_Full:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_Mod_SampleSizeForFace:PROC
EXTRN	_CL_IsDevOverviewMode:PROC
EXTRN	_CL_GetWaterEntity:PROC
EXTRN	_CL_FxBlend:PROC
EXTRN	_CL_DrawParticles:PROC
EXTRN	_CL_DrawTracers:PROC
EXTRN	_CL_DrawBeams:PROC
EXTRN	_GL_FrustumInitProj:PROC
EXTRN	_GL_FrustumInitOrtho:PROC
EXTRN	_GL_LoadMatrix:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_Set2DMode:PROC
EXTRN	_R_SetTextureParameters:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_R_DrawMirrors:PROC
EXTRN	_R_FindMirrors:PROC
EXTRN	_R_PushDlights:PROC
EXTRN	_Matrix4x4_Concat:PROC
EXTRN	_Matrix4x4_ConcatTranslate:PROC
EXTRN	_Matrix4x4_ConcatRotate:PROC
EXTRN	_Matrix4x4_CreateProjection:PROC
EXTRN	_Matrix4x4_CreateOrtho:PROC
EXTRN	_Matrix4x4_CreateModelview:PROC
EXTRN	_R_MarkLeaves:PROC
EXTRN	_R_DrawWorld:PROC
EXTRN	_R_DrawWaterSurfaces:PROC
EXTRN	_R_DrawBrushModel:PROC
EXTRN	_R_DrawAlphaTextureChains:PROC
EXTRN	_GL_RebuildLightmaps:PROC
EXTRN	_R_DrawSpriteModel:PROC
EXTRN	_R_GetEntityRenderMode:PROC
EXTRN	_R_DrawStudioModel:PROC
EXTRN	_R_GatherPlayerLight:PROC
EXTRN	_R_DrawAliasModel:PROC
EXTRN	_GL_CheckForErrors_:PROC
EXTRN	_GL_UpdateSwapInterval:PROC
EXTRN	_GL_MaxTextureUnits:PROC
EXTRN	_R_InitDownSampleTextures:PROC
EXTRN	_R_DownSampling:PROC
EXTRN	_R_RunViewmodelEvents:PROC
EXTRN	_R_DrawViewModel:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_matrix4x4_identity:ZWORD
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_tr:BYTE
EXTRN	_cl_dlights:BYTE
EXTRN	_cl_elights:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	_gl_texture_anisotropy:DWORD
EXTRN	_gl_texture_lodbias:DWORD
EXTRN	_gl_texture_nearest:DWORD
EXTRN	_gl_lightmap_nearest:DWORD
EXTRN	_gl_allow_mirrors:DWORD
EXTRN	_gl_finish:DWORD
EXTRN	_gl_nosort:DWORD
EXTRN	_gl_clear:DWORD
EXTRN	_gl_msaa:DWORD
EXTRN	_r_norefresh:DWORD
EXTRN	_r_drawentities:DWORD
EXTRN	_r_lockfrustum:DWORD
EXTRN	_vid_brightness:DWORD
EXTRN	_vid_gamma:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?isFogEnabled@?1??R_AllowFog@@9@9 DD 01H DUP (?)	; `R_AllowFog'::`2'::isFogEnabled
?viewPoint@?1??R_EnvShot@@9@9 DD 03H DUP (?)		; `R_EnvShot'::`2'::viewPoint
?t@?1??pfnGetFilesList@@9@9 DD 01H DUP (?)		; `pfnGetFilesList'::`2'::t
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4e6e6b28
CONST	SEGMENT
__real@4e6e6b28 DD 04e6e6b28r			; 1e+09
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff07ae147ae147b
CONST	SEGMENT
__real@3ff07ae147ae147b DQ 03ff07ae147ae147br	; 1.03
CONST	ENDS
;	COMDAT __real@3fef0a3d70a3d70a
CONST	SEGMENT
__real@3fef0a3d70a3d70a DQ 03fef0a3d70a3d70ar	; 0.97
CONST	ENDS
;	COMDAT __real@3fe66666
CONST	SEGMENT
__real@3fe66666 DD 03fe66666r			; 1.8
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdd70a4
CONST	SEGMENT
__real@3fdd70a4 DD 03fdd70a4r			; 1.73
CONST	ENDS
;	COMDAT __real@3f9eb851eb851eb8
CONST	SEGMENT
__real@3f9eb851eb851eb8 DQ 03f9eb851eb851eb8r	; 0.03
CONST	ENDS
;	COMDAT __real@3f91df46aaaaaaab
CONST	SEGMENT
__real@3f91df46aaaaaaab DQ 03f91df46aaaaaaabr	; 0.0174533
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@37d1b717
CONST	SEGMENT
__real@37d1b717 DD 037d1b717r			; 2.5e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DK@LPDJHGLP@CL_LoadProgs?3?5?$FO2initailized?5ext@
CONST	SEGMENT
??_C@_0DK@LPDJHGLP@CL_LoadProgs?3?5?$FO2initailized?5ext@ DB 'CL_LoadProg'
	DB	's: ^2initailized extended RenderAPI ^7ver. %i', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_gRenderAPI DD	FLAT:_GL_RenderGetParm
	DD	FLAT:_R_GetDetailScaleForTexture
	DD	FLAT:_R_GetExtraParmsForTexture
	DD	FLAT:_CL_GetLightStyle
	DD	FLAT:_CL_GetDynamicLight
	DD	FLAT:_CL_GetEntityLight
	DD	FLAT:_LightToTexGamma
	DD	FLAT:_R_GetFrameTime
	DD	FLAT:_R_SetCurrentEntity
	DD	FLAT:_R_SetCurrentModel
	DD	FLAT:_R_FatPVS
	DD	FLAT:_R_StoreEfrags
	DD	FLAT:_GL_FindTexture
	DD	FLAT:_GL_TextureName
	DD	FLAT:_GL_TextureData
	DD	FLAT:_GL_LoadTexture
	DD	FLAT:_GL_CreateTexture
	DD	FLAT:_GL_LoadTextureArray
	DD	FLAT:_GL_CreateTextureArray
	DD	FLAT:_GL_FreeTexture
	DD	FLAT:_DrawSingleDecal
	DD	FLAT:_R_DecalSetupVerts
	DD	FLAT:_R_EntityRemoveDecals
	DD	FLAT:_AVI_LoadVideo
	DD	FLAT:_AVI_GetVideoInfo
	DD	FLAT:_AVI_GetVideoFrameNumber
	DD	FLAT:_AVI_GetVideoFrame
	DD	FLAT:_R_UploadStretchRaw
	DD	FLAT:_AVI_FreeVideo
	DD	FLAT:_AVI_IsActive
	DD	FLAT:_S_StreamAviSamples
	DD	00H
	DD	00H
	DD	FLAT:_GL_Bind
	DD	FLAT:_GL_SelectTexture
	DD	FLAT:_GL_LoadTexMatrixExt
	DD	FLAT:_GL_LoadIdentityTexMatrix
	DD	FLAT:_GL_CleanUpTextureUnits
	DD	FLAT:_GL_TexGen
	DD	FLAT:_GL_TextureTarget
	DD	FLAT:_GL_SetTexCoordArrayMode
	DD	FLAT:_GL_GetProcAddress
	DD	FLAT:_GL_UpdateTexSize
	DD	00H
	DD	00H
	DD	FLAT:_CL_DrawParticlesExternal
	DD	FLAT:_R_EnvShot
	DD	FLAT:_pfnSPR_LoadExt
	DD	FLAT:_R_LightVec
	DD	FLAT:_R_StudioGetTexture
	DD	FLAT:_GL_GetOverviewParms
	DD	FLAT:_CL_GenericHandle
	DD	00H
	DD	00H
	DD	FLAT:_R_Mem_Alloc
	DD	FLAT:_R_Mem_Free
	DD	FLAT:_pfnGetFilesList
	DD	FLAT:_pfnFileBufferCRC32
	DD	FLAT:_COM_CompareFileTime
	DD	FLAT:_Host_Error
	DD	FLAT:_CL_ModelHandle
	DD	FLAT:_pfnTime
	DD	FLAT:_Cvar_Set
	DD	FLAT:_S_FadeMusicVolume
	DD	FLAT:_COM_SetRandomSeed
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetFilesList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetFilesList@@9@9 DD 05bbH		; `pfnGetFilesList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@BNBGOELI@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_ELI@
CONST	SEGMENT
??_C@_0CE@BNBGOELI@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_ELI@ DB 'n'
	DB	'umber >= 0 && number < MAX_ELIGHTS', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_GetEntityLight@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_GetEntityLight@@9@9 DD 058cH	; `CL_GetEntityLight'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@NBLMOECG@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_DLI@
CONST	SEGMENT
??_C@_0CE@NBLMOECG@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_DLI@ DB 'n'
	DB	'umber >= 0 && number < MAX_DLIGHTS', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_GetDynamicLight@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_GetDynamicLight@@9@9 DD 0586H	; `CL_GetDynamicLight'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@NEINIPGH@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_LIG@
CONST	SEGMENT
??_C@_0CI@NEINIPGH@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_LIG@ DB 'n'
	DB	'umber >= 0 && number < MAX_LIGHTSTYLES', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_GetLightStyle@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_GetLightStyle@@9@9 DD 0580H		; `CL_GetLightStyle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@PEPBOIAI@?$FO1Error?3?$FO7?5R_?$CFsShot?3?5subsystem?5@
CONST	SEGMENT
??_C@_0DN@PEPBOIAI@?$FO1Error?3?$FO7?5R_?$CFsShot?3?5subsystem?5@ DB '^1E'
	DB	'rror:^7 R_%sShot: subsystem is busy, try for next frame.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03EJFNLALG@Env@
CONST	SEGMENT
??_C@_03EJFNLALG@Env@ DB 'Env', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LNHMGGNB@Sky@
CONST	SEGMENT
??_C@_03LNHMGGNB@Sky@ DB 'Sky', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LLNLIDFH@arg?5?$DO?$DN?50?5?$CG?$CG?5arg?5?$DM?56@
CONST	SEGMENT
??_C@_0BE@LLNLIDFH@arg?5?$DO?$DN?50?5?$CG?$CG?5arg?5?$DM?56@ DB 'arg >= 0'
	DB	' && arg < 6', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_RenderGetParm@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_RenderGetParm@@9@9 DD 04cbH		; `GL_RenderGetParm'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EP@KKAKMOHG@failed?5to?5swap?5buffers?6Check?5yo@
CONST	SEGMENT
??_C@_0EP@KKAKMOHG@failed?5to?5swap?5buffers?6Check?5yo@ DB 'failed to sw'
	DB	'ap buffers', 0aH, 'Check your video driver and as possible of'
	DB	' reinstall it', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KBAHKDFL@R_RenderView?3?5NULL?5worldmodel?6@
CONST	SEGMENT
??_C@_0BP@KBAHKDFL@R_RenderView?3?5NULL?5worldmodel?6@ DB 'R_RenderView: '
	DB	'NULL worldmodel', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@ DB 'RI.currentmodel '
	DB	'!= NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@ DB 'RI.currententit'
	DB	'y != NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9 DD 0341H	; `R_DrawEntitiesOnList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@ DB 'node != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_rmain.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_RecursiveFindWaterTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_RecursiveFindWaterTexture@@9@9 DD 026aH ; `R_RecursiveFindWaterTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@IOCCNMCG@draw?5stack?5underflow?6@
CONST	SEGMENT
??_C@_0BG@IOCCNMCG@draw?5stack?5underflow?6@ DB 'draw stack underflow', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HNEHGHKE@draw?5stack?5overflow?6@
CONST	SEGMENT
??_C@_0BF@HNEHGHKE@draw?5stack?5overflow?6@ DB 'draw stack overflow', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	05d8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0382H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0314H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0307H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0137H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _CL_GenericHandle
_TEXT	SEGMENT
_fileindex$ = 8						; size = 4
_CL_GenericHandle PROC					; COMDAT

; 1503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1504 : 	if( fileindex < 0 || fileindex >= MAX_CUSTOM )

	cmp	DWORD PTR _fileindex$[ebp], 0
	jl	SHORT $LN3@CL_Generic
	cmp	DWORD PTR _fileindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@CL_Generic
$LN3@CL_Generic:

; 1505 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CL_Generic
$LN2@CL_Generic:

; 1506 : 	return cl.files_precache[fileindex];

	mov	eax, DWORD PTR _fileindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _cl+2831764
$LN1@CL_Generic:

; 1507 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GenericHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _pfnFileBufferCRC32
_TEXT	SEGMENT
_modelCRC$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_pfnFileBufferCRC32 PROC				; COMDAT

; 1485 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1486 : 	uint	modelCRC = 0;

	mov	DWORD PTR _modelCRC$[ebp], 0

; 1487 : 
; 1488 : 	if( !buffer || length <= 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@pfnFileBuf
	cmp	DWORD PTR _length$[ebp], 0
	jg	SHORT $LN2@pfnFileBuf
$LN3@pfnFileBuf:

; 1489 : 		return modelCRC;

	mov	eax, DWORD PTR _modelCRC$[ebp]
	jmp	SHORT $LN1@pfnFileBuf
$LN2@pfnFileBuf:

; 1490 : 
; 1491 : 	CRC32_Init( &modelCRC );

	lea	eax, DWORD PTR _modelCRC$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 1492 : 	CRC32_ProcessBuffer( &modelCRC, buffer, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _modelCRC$[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 1493 : 	return CRC32_Final( modelCRC );

	mov	eax, DWORD PTR _modelCRC$[ebp]
	push	eax
	call	_CRC32_Final
	add	esp, 4
$LN1@pfnFileBuf:

; 1494 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFileBufferCRC32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _pfnGetFilesList
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_numFiles$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_pfnGetFilesList PROC					; COMDAT

; 1467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1468 : 	static search_t	*t = NULL;
; 1469 : 
; 1470 : 	if( t ) Mem_Free( t ); // release prev search

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	je	SHORT $LN2@pfnGetFile
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetFilesList@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@pfnGetFile:

; 1471 : 
; 1472 : 	t = FS_Search( pattern, true, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, eax

; 1473 : 
; 1474 : 	if( !t )

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	jne	SHORT $LN3@pfnGetFile

; 1475 : 	{
; 1476 : 		if( numFiles ) *numFiles = 0;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN4@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@pfnGetFile:

; 1477 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetFile
$LN3@pfnGetFile:

; 1478 : 	}
; 1479 : 
; 1480 : 	if( numFiles ) *numFiles = t->numfilenames;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN5@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@pfnGetFile:

; 1481 : 	return t->filenames;

	mov	eax, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	eax, DWORD PTR [eax+4]
$LN1@pfnGetFile:

; 1482 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetFilesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_Mem_Free
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_R_Mem_Free PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1456 : 	if( !mem ) return;

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN2@R_Mem_Free
	jmp	SHORT $LN1@R_Mem_Free
$LN2@R_Mem_Free:

; 1457 : 	_Mem_Free( mem, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@R_Mem_Free:

; 1458 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Mem_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_Mem_Alloc
_TEXT	SEGMENT
_cb$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_R_Mem_Alloc PROC					; COMDAT

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1451 : 	return _Mem_Alloc( cls.mempool, cb, true, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H

; 1452 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Mem_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _GL_GetOverviewParms
_TEXT	SEGMENT
_GL_GetOverviewParms PROC				; COMDAT

; 1445 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1446 : 	return &clgame.overView;

	mov	eax, OFFSET _clgame+217612

; 1447 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_GetOverviewParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _GL_TextureName
_TEXT	SEGMENT
_texnum$ = 8						; size = 4
_GL_TextureName PROC					; COMDAT

; 1431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1432 : 	return R_GetTexture( texnum )->name;	

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4

; 1433 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_GetFrameTime
_TEXT	SEGMENT
tv66 = -68						; size = 4
_R_GetFrameTime PROC					; COMDAT

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1427 : 	return tr.frametime;

	cvtsd2ss xmm0, QWORD PTR _tr+87584
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetFrameTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _CL_GetEntityLight
_TEXT	SEGMENT
tv71 = -68						; size = 4
_number$ = 8						; size = 4
_CL_GetEntityLight PROC					; COMDAT

; 1420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1421 : 	Assert( number >= 0 && number < MAX_ELIGHTS );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetEnti
	cmp	DWORD PTR _number$[ebp], 64		; 00000040H
	jge	SHORT $LN3@CL_GetEnti
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CL_GetEnti
$LN3@CL_GetEnti:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CL_GetEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_GetEntityLight@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CE@BNBGOELI@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_ELI@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1422 : 	return &cl_elights[number];

	imul	eax, DWORD PTR _number$[ebp], 40
	add	eax, OFFSET _cl_elights

; 1423 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetEntityLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _CL_GetDynamicLight
_TEXT	SEGMENT
tv71 = -68						; size = 4
_number$ = 8						; size = 4
_CL_GetDynamicLight PROC				; COMDAT

; 1414 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1415 : 	Assert( number >= 0 && number < MAX_DLIGHTS );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetDyna
	cmp	DWORD PTR _number$[ebp], 32		; 00000020H
	jge	SHORT $LN3@CL_GetDyna
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CL_GetDyna
$LN3@CL_GetDyna:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CL_GetDyna:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_GetDynamicLight@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CE@NBLMOECG@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_DLI@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1416 : 	return &cl_dlights[number];

	imul	eax, DWORD PTR _number$[ebp], 40
	add	eax, OFFSET _cl_dlights

; 1417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDynamicLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _CL_GetLightStyle
_TEXT	SEGMENT
tv71 = -68						; size = 4
_number$ = 8						; size = 4
_CL_GetLightStyle PROC					; COMDAT

; 1408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1409 : 	Assert( number >= 0 && number < MAX_LIGHTSTYLES );

	cmp	DWORD PTR _number$[ebp], 0
	jl	SHORT $LN3@CL_GetLigh
	cmp	DWORD PTR _number$[ebp], 64		; 00000040H
	jge	SHORT $LN3@CL_GetLigh
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CL_GetLigh
$LN3@CL_GetLigh:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CL_GetLigh:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_GetLightStyle@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CI@NEINIPGH@number?5?$DO?$DN?50?5?$CG?$CG?5number?5?$DM?5MAX_LIG@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1410 : 	return &cl.lightstyles[number];

	imul	eax, DWORD PTR _number$[ebp], 1296
	add	eax, OFFSET _cl+2897300

; 1411 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_FatPVS
_TEXT	SEGMENT
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_visbuffer$ = 16					; size = 4
_merge$ = 20						; size = 4
_fullvis$ = 24						; size = 4
_R_FatPVS PROC						; COMDAT

; 1403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1404 : 	return Mod_FatPVS( org, radius, visbuffer, world.visbytes, merge, fullvis );

	mov	eax, DWORD PTR _fullvis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _merge$[ebp]
	push	ecx
	mov	edx, DWORD PTR _world+2588
	push	edx
	mov	eax, DWORD PTR _visbuffer$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H

; 1405 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FatPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetCurrentModel
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_R_SetCurrentModel PROC					; COMDAT

; 1398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1399 : 	RI.currentmodel = mod;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _RI+32, eax

; 1400 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetCurrentModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetCurrentEntity
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_R_SetCurrentEntity PROC				; COMDAT

; 1387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1388 : 	RI.currententity = ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR _RI+28, eax

; 1389 : 
; 1390 : 	// set model also
; 1391 : 	if( RI.currententity != NULL )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN1@R_SetCurre

; 1392 : 	{
; 1393 : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx
$LN1@R_SetCurre:

; 1394 : 	}
; 1395 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetCurrentEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_EnvShot
_TEXT	SEGMENT
tv92 = -68						; size = 4
tv71 = -68						; size = 4
_vieworg$ = 8						; size = 4
_name$ = 12						; size = 4
_skyshot$ = 16						; size = 4
_shotsize$ = 20						; size = 4
_R_EnvShot PROC						; COMDAT

; 1354 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1355 : 	static vec3_t viewPoint;
; 1356 : 
; 1357 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_EnvShot

; 1358 : 		return; 

	jmp	$LN1@R_EnvShot
$LN2@R_EnvShot:

; 1359 : 
; 1360 : 	if( cls.scrshot_action != scrshot_inactive )

	cmp	DWORD PTR _cls+296308, 0
	je	SHORT $LN3@R_EnvShot

; 1361 : 	{
; 1362 : 		if( cls.scrshot_action != scrshot_skyshot && cls.scrshot_action != scrshot_envshot )

	cmp	DWORD PTR _cls+296308, 6
	je	SHORT $LN4@R_EnvShot
	cmp	DWORD PTR _cls+296308, 5
	je	SHORT $LN4@R_EnvShot

; 1363 : 			Con_Printf( S_ERROR "R_%sShot: subsystem is busy, try for next frame.\n", skyshot ? "Sky" : "Env" );

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN9@R_EnvShot
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_03LNHMGGNB@Sky@
	jmp	SHORT $LN10@R_EnvShot
$LN9@R_EnvShot:
	mov	DWORD PTR tv71[ebp], OFFSET ??_C@_03EJFNLALG@Env@
$LN10@R_EnvShot:
	mov	eax, DWORD PTR tv71[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@PEPBOIAI@?$FO1Error?3?$FO7?5R_?$CFsShot?3?5subsystem?5@
	call	_Con_Printf
	add	esp, 8
$LN4@R_EnvShot:

; 1364 : 		return;

	jmp	$LN1@R_EnvShot
$LN3@R_EnvShot:

; 1365 : 	}
; 1366 : 
; 1367 : 	cls.envshot_vieworg = NULL; // use client view

	mov	DWORD PTR _cls+296312, 0

; 1368 : 	Q_strncpy( cls.shotname, name, sizeof( cls.shotname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET _cls+296324
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1369 : 
; 1370 : 	if( vieworg )

	cmp	DWORD PTR _vieworg$[ebp], 0
	je	SHORT $LN5@R_EnvShot

; 1371 : 	{
; 1372 : 		// make sure what viewpoint don't temporare
; 1373 : 		VectorCopy( vieworg, viewPoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vieworg$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vieworg$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vieworg$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR ?viewPoint@?1??R_EnvShot@@9@9[ecx], eax

; 1374 : 		cls.envshot_vieworg = viewPoint;

	mov	DWORD PTR _cls+296312, OFFSET ?viewPoint@?1??R_EnvShot@@9@9

; 1375 : 		cls.envshot_disable_vis = true;

	mov	DWORD PTR _cls+296320, 1
$LN5@R_EnvShot:

; 1376 : 	}
; 1377 : 
; 1378 : 	// make request for envshot
; 1379 : 	if( skyshot ) cls.scrshot_action = scrshot_skyshot;

	cmp	DWORD PTR _skyshot$[ebp], 0
	je	SHORT $LN6@R_EnvShot
	mov	DWORD PTR _cls+296308, 6
	jmp	SHORT $LN7@R_EnvShot
$LN6@R_EnvShot:

; 1380 : 	else cls.scrshot_action = scrshot_envshot;

	mov	DWORD PTR _cls+296308, 5
$LN7@R_EnvShot:

; 1381 : 
; 1382 : 	// catch negative values
; 1383 : 	cls.envshot_viewsize = max( 0, shotsize );

	cmp	DWORD PTR _shotsize$[ebp], 0
	jge	SHORT $LN11@R_EnvShot
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN12@R_EnvShot
$LN11@R_EnvShot:
	mov	eax, DWORD PTR _shotsize$[ebp]
	mov	DWORD PTR tv92[ebp], eax
$LN12@R_EnvShot:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _cls+296316, ecx
$LN1@R_EnvShot:

; 1384 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_EnvShot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_GetExtraParmsForTexture
_TEXT	SEGMENT
_glt$ = -4						; size = 4
_texture$ = 8						; size = 4
_red$ = 12						; size = 4
_green$ = 16						; size = 4
_blue$ = 20						; size = 4
_density$ = 24						; size = 4
_R_GetExtraParmsForTexture PROC				; COMDAT

; 1338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1339 : 	gl_texture_t *glt = R_GetTexture( texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1340 : 
; 1341 : 	if( red ) *red = glt->fogParams[0];

	cmp	DWORD PTR _red$[ebp], 0
	je	SHORT $LN2@R_GetExtra
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _red$[ebp]
	mov	eax, DWORD PTR _glt$[ebp]
	mov	cl, BYTE PTR [eax+ecx+288]
	mov	BYTE PTR [edx], cl
$LN2@R_GetExtra:

; 1342 : 	if( green ) *green = glt->fogParams[1];

	cmp	DWORD PTR _green$[ebp], 0
	je	SHORT $LN3@R_GetExtra
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _green$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	al, BYTE PTR [edx+eax+288]
	mov	BYTE PTR [ecx], al
$LN3@R_GetExtra:

; 1343 : 	if( blue ) *blue = glt->fogParams[2];

	cmp	DWORD PTR _blue$[ebp], 0
	je	SHORT $LN4@R_GetExtra
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _blue$[ebp]
	mov	edx, DWORD PTR _glt$[ebp]
	mov	al, BYTE PTR [edx+eax+288]
	mov	BYTE PTR [ecx], al
$LN4@R_GetExtra:

; 1344 : 	if( density ) *density = glt->fogParams[3];

	cmp	DWORD PTR _density$[ebp], 0
	je	SHORT $LN1@R_GetExtra
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _density$[ebp]
	mov	eax, DWORD PTR _glt$[ebp]
	mov	cl, BYTE PTR [eax+ecx+288]
	mov	BYTE PTR [edx], cl
$LN1@R_GetExtra:

; 1345 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetExtraParmsForTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_GetDetailScaleForTexture
_TEXT	SEGMENT
_glt$ = -4						; size = 4
_texture$ = 8						; size = 4
_xScale$ = 12						; size = 4
_yScale$ = 16						; size = 4
_R_GetDetailScaleForTexture PROC			; COMDAT

; 1330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1331 : 	gl_texture_t *glt = R_GetTexture( texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1332 : 
; 1333 : 	if( xScale ) *xScale = glt->xscale;

	cmp	DWORD PTR _xScale$[ebp], 0
	je	SHORT $LN2@R_GetDetai
	mov	eax, DWORD PTR _xScale$[ebp]
	mov	ecx, DWORD PTR _glt$[ebp]
	mov	edx, DWORD PTR [ecx+300]
	mov	DWORD PTR [eax], edx
$LN2@R_GetDetai:

; 1334 : 	if( yScale ) *yScale = glt->yscale;

	cmp	DWORD PTR _yScale$[ebp], 0
	je	SHORT $LN3@R_GetDetai
	mov	eax, DWORD PTR _yScale$[ebp]
	mov	ecx, DWORD PTR _glt$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	mov	DWORD PTR [eax], edx
$LN3@R_GetDetai:

; 1335 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetDetailScaleForTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _GL_RenderGetParm
_TEXT	SEGMENT
tv162 = -76						; size = 4
tv141 = -76						; size = 4
tv170 = -72						; size = 4
tv168 = -72						; size = 4
tv161 = -72						; size = 4
tv148 = -72						; size = 4
tv140 = -72						; size = 4
tv134 = -72						; size = 4
tv64 = -72						; size = 4
_glt$ = -4						; size = 4
_parm$ = 8						; size = 4
_arg$ = 12						; size = 4
_GL_RenderGetParm PROC					; COMDAT

; 1227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1228 : 	gl_texture_t *glt;
; 1229 : 
; 1230 : 	switch( parm )

	mov	eax, DWORD PTR _parm$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 37			; 00000025H
	ja	$LN2@GL_RenderG
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN59@GL_RenderG[edx*4]
$LN4@GL_RenderG:

; 1231 : 	{
; 1232 : 	case PARM_TEX_WIDTH:
; 1233 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1234 : 		return glt->width;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+260]
	jmp	$LN1@GL_RenderG
$LN5@GL_RenderG:

; 1235 : 	case PARM_TEX_HEIGHT:
; 1236 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1237 : 		return glt->height;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+262]
	jmp	$LN1@GL_RenderG
$LN6@GL_RenderG:

; 1238 : 	case PARM_TEX_SRC_WIDTH:
; 1239 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1240 : 		return glt->srcWidth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+256]
	jmp	$LN1@GL_RenderG
$LN7@GL_RenderG:

; 1241 : 	case PARM_TEX_SRC_HEIGHT:
; 1242 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1243 : 		return glt->srcHeight;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+258]
	jmp	$LN1@GL_RenderG
$LN8@GL_RenderG:

; 1244 : 	case PARM_TEX_GLFORMAT:
; 1245 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1246 : 		return glt->format;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+276]
	jmp	$LN1@GL_RenderG
$LN9@GL_RenderG:

; 1247 : 	case PARM_TEX_ENCODE:
; 1248 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1249 : 		return glt->encode;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+280]
	jmp	$LN1@GL_RenderG
$LN10@GL_RenderG:

; 1250 : 	case PARM_TEX_MIPCOUNT:
; 1251 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1252 : 		return glt->numMips;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, BYTE PTR [eax+266]
	jmp	$LN1@GL_RenderG
$LN11@GL_RenderG:

; 1253 : 	case PARM_TEX_DEPTH:
; 1254 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1255 : 		return glt->depth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	eax, WORD PTR [eax+264]
	jmp	$LN1@GL_RenderG
$LN12@GL_RenderG:

; 1256 : 	case PARM_BSP2_SUPPORTED:
; 1257 : #ifdef SUPPORT_BSP2_FORMAT
; 1258 : 		return 1;
; 1259 : #endif
; 1260 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_RenderG
$LN13@GL_RenderG:

; 1261 : 	case PARM_TEX_SKYBOX:
; 1262 : 		Assert( arg >= 0 && arg < 6 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN43@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 6
	jge	SHORT $LN43@GL_RenderG
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN44@GL_RenderG
$LN43@GL_RenderG:
	mov	DWORD PTR tv134[ebp], 0
$LN44@GL_RenderG:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_RenderGetParm@@9@9
	add	eax, 35					; 00000023H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BE@LLNLIDFH@arg?5?$DO?$DN?50?5?$CG?$CG?5arg?5?$DM?56@
	mov	ecx, DWORD PTR tv134[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1263 : 		return tr.skyboxTextures[arg];

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[eax*4+1056]
	jmp	$LN1@GL_RenderG
$LN14@GL_RenderG:

; 1264 : 	case PARM_TEX_SKYTEXNUM:
; 1265 : 		return tr.skytexturenum;

	mov	eax, DWORD PTR _tr+1216
	jmp	$LN1@GL_RenderG
$LN15@GL_RenderG:

; 1266 : 	case PARM_TEX_LIGHTMAP:
; 1267 : 		arg = bound( 0, arg, MAX_LIGHTMAPS - 1 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN47@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 255		; 000000ffH
	jge	SHORT $LN45@GL_RenderG
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN46@GL_RenderG
$LN45@GL_RenderG:
	mov	DWORD PTR tv140[ebp], 255		; 000000ffH
$LN46@GL_RenderG:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	jmp	SHORT $LN48@GL_RenderG
$LN47@GL_RenderG:
	mov	DWORD PTR tv141[ebp], 0
$LN48@GL_RenderG:
	mov	edx, DWORD PTR tv141[ebp]
	mov	DWORD PTR _arg$[ebp], edx

; 1268 : 		return tr.lightmapTextures[arg];

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[eax*4+28]
	jmp	$LN1@GL_RenderG
$LN16@GL_RenderG:

; 1269 : 	case PARM_SKY_SPHERE:
; 1270 : 		return FBitSet( world.flags, FWORLD_SKYSPHERE ) && !FBitSet( world.flags, FWORLD_CUSTOM_SKYBOX );

	mov	eax, DWORD PTR _world+8
	and	eax, 1
	je	SHORT $LN49@GL_RenderG
	mov	ecx, DWORD PTR _world+8
	and	ecx, 2
	jne	SHORT $LN49@GL_RenderG
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN50@GL_RenderG
$LN49@GL_RenderG:
	mov	DWORD PTR tv148[ebp], 0
$LN50@GL_RenderG:
	mov	eax, DWORD PTR tv148[ebp]
	jmp	$LN1@GL_RenderG
$LN17@GL_RenderG:

; 1271 : 	case PARAM_GAMEPAUSED:
; 1272 : 		return cl.paused;

	mov	eax, DWORD PTR _cl+24
	jmp	$LN1@GL_RenderG
$LN18@GL_RenderG:

; 1273 : 	case PARM_WIDESCREEN:
; 1274 : 		return glState.wideScreen;

	mov	eax, DWORD PTR _glState+12
	jmp	$LN1@GL_RenderG
$LN19@GL_RenderG:

; 1275 : 	case PARM_FULLSCREEN:
; 1276 : 		return glState.fullScreen;

	mov	eax, DWORD PTR _glState+8
	jmp	$LN1@GL_RenderG
$LN20@GL_RenderG:

; 1277 : 	case PARM_SCREEN_WIDTH:
; 1278 : 		return glState.width;

	mov	eax, DWORD PTR _glState
	jmp	$LN1@GL_RenderG
$LN21@GL_RenderG:

; 1279 : 	case PARM_SCREEN_HEIGHT:
; 1280 : 		return glState.height;

	mov	eax, DWORD PTR _glState+4
	jmp	$LN1@GL_RenderG
$LN22@GL_RenderG:

; 1281 : 	case PARM_CLIENT_INGAME:
; 1282 : 		return CL_IsInGame();

	call	_CL_IsInGame
	jmp	$LN1@GL_RenderG
$LN23@GL_RenderG:

; 1283 : 	case PARM_MAX_ENTITIES:
; 1284 : 		return clgame.maxEntities;

	mov	eax, DWORD PTR _clgame+1008
	jmp	$LN1@GL_RenderG
$LN24@GL_RenderG:

; 1285 : 	case PARM_TEX_TARGET:
; 1286 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1287 : 		return glt->target;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+268]
	jmp	$LN1@GL_RenderG
$LN25@GL_RenderG:

; 1288 : 	case PARM_TEX_TEXNUM:
; 1289 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1290 : 		return glt->texnum;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+272]
	jmp	$LN1@GL_RenderG
$LN26@GL_RenderG:

; 1291 : 	case PARM_TEX_FLAGS:
; 1292 : 		glt = R_GetTexture( arg );

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 1293 : 		return glt->flags;

	mov	eax, DWORD PTR _glt$[ebp]
	mov	eax, DWORD PTR [eax+284]
	jmp	$LN1@GL_RenderG
$LN27@GL_RenderG:

; 1294 : 	case PARM_FEATURES:
; 1295 : 		return host.features;

	mov	eax, DWORD PTR _host+34752
	jmp	$LN1@GL_RenderG
$LN28@GL_RenderG:

; 1296 : 	case PARM_ACTIVE_TMU:
; 1297 : 		return glState.activeTMU;

	mov	eax, DWORD PTR _glState+16
	jmp	$LN1@GL_RenderG
$LN29@GL_RenderG:

; 1298 : 	case PARM_LIGHTSTYLEVALUE:
; 1299 : 		arg = bound( 0, arg, MAX_LIGHTSTYLES - 1 );

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN53@GL_RenderG
	cmp	DWORD PTR _arg$[ebp], 63		; 0000003fH
	jge	SHORT $LN51@GL_RenderG
	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN52@GL_RenderG
$LN51@GL_RenderG:
	mov	DWORD PTR tv161[ebp], 63		; 0000003fH
$LN52@GL_RenderG:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv162[ebp], ecx
	jmp	SHORT $LN54@GL_RenderG
$LN53@GL_RenderG:
	mov	DWORD PTR tv162[ebp], 0
$LN54@GL_RenderG:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR _arg$[ebp], edx

; 1300 : 		return tr.lightstylevalue[arg];

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _tr[eax*4+87324]
	jmp	$LN1@GL_RenderG
$LN30@GL_RenderG:

; 1301 : 	case PARM_MAP_HAS_DELUXE:
; 1302 : 		return FBitSet( world.flags, FWORLD_HAS_DELUXEMAP );

	mov	eax, DWORD PTR _world+8
	and	eax, 8
	jmp	$LN1@GL_RenderG
$LN31@GL_RenderG:

; 1303 : 	case PARM_MAX_IMAGE_UNITS:
; 1304 : 		return GL_MaxTextureUnits();

	call	_GL_MaxTextureUnits
	jmp	$LN1@GL_RenderG
$LN32@GL_RenderG:

; 1305 : 	case PARM_CLIENT_ACTIVE:
; 1306 : 		return (cls.state == ca_active);

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN55@GL_RenderG
	mov	DWORD PTR tv168[ebp], 1
	jmp	SHORT $LN56@GL_RenderG
$LN55@GL_RenderG:
	mov	DWORD PTR tv168[ebp], 0
$LN56@GL_RenderG:
	mov	eax, DWORD PTR tv168[ebp]
	jmp	$LN1@GL_RenderG
$LN33@GL_RenderG:

; 1307 : 	case PARM_REBUILD_GAMMA:
; 1308 : 		return glConfig.softwareGammaUpdate;

	mov	eax, DWORD PTR _glConfig+124
	jmp	SHORT $LN1@GL_RenderG
$LN34@GL_RenderG:

; 1309 : 	case PARM_DEDICATED_SERVER:
; 1310 : 		return (host.type == HOST_DEDICATED);

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN57@GL_RenderG
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN58@GL_RenderG
$LN57@GL_RenderG:
	mov	DWORD PTR tv170[ebp], 0
$LN58@GL_RenderG:
	mov	eax, DWORD PTR tv170[ebp]
	jmp	SHORT $LN1@GL_RenderG
$LN35@GL_RenderG:

; 1311 : 	case PARM_SURF_SAMPLESIZE:
; 1312 : 		if( arg >= 0 && arg < cl.worldmodel->numsurfaces )

	cmp	DWORD PTR _arg$[ebp], 0
	jl	SHORT $LN36@GL_RenderG
	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _arg$[ebp]
	cmp	ecx, DWORD PTR [eax+176]
	jge	SHORT $LN36@GL_RenderG

; 1313 : 			return Mod_SampleSizeForFace( &cl.worldmodel->surfaces[arg] );

	imul	eax, DWORD PTR _arg$[ebp], 92
	mov	ecx, DWORD PTR _cl+4579004
	add	eax, DWORD PTR [ecx+180]
	push	eax
	call	_Mod_SampleSizeForFace
	add	esp, 4
	jmp	SHORT $LN1@GL_RenderG
$LN36@GL_RenderG:

; 1314 : 		return LM_SAMPLE_SIZE;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN1@GL_RenderG
$LN37@GL_RenderG:

; 1315 : 	case PARM_GL_CONTEXT_TYPE:
; 1316 : 		return glConfig.context;

	mov	eax, DWORD PTR _glConfig+116
	jmp	SHORT $LN1@GL_RenderG
$LN38@GL_RenderG:

; 1317 : 	case PARM_GLES_WRAPPER:
; 1318 : 		return glConfig.wrapper;

	mov	eax, DWORD PTR _glConfig+120
	jmp	SHORT $LN1@GL_RenderG
$LN39@GL_RenderG:

; 1319 : 	case PARM_STENCIL_ACTIVE:
; 1320 : 		return glState.stencilEnabled;

	mov	eax, DWORD PTR _glState+568
	jmp	SHORT $LN1@GL_RenderG
$LN40@GL_RenderG:

; 1321 : 	case PARM_WATER_ALPHA:
; 1322 : 		return FBitSet( world.flags, FWORLD_WATERALPHA );

	mov	eax, DWORD PTR _world+8
	and	eax, 4
	jmp	SHORT $LN1@GL_RenderG
$LN41@GL_RenderG:

; 1323 : 	case PARM_MAP_HAS_MIRRORS:
; 1324 : 		return world.has_mirrors;

	mov	eax, DWORD PTR _world+4
	jmp	SHORT $LN1@GL_RenderG
$LN2@GL_RenderG:

; 1325 : 	}
; 1326 : 	return 0;

	xor	eax, eax
$LN1@GL_RenderG:

; 1327 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN59@GL_RenderG:
	DD	$LN4@GL_RenderG
	DD	$LN5@GL_RenderG
	DD	$LN6@GL_RenderG
	DD	$LN7@GL_RenderG
	DD	$LN13@GL_RenderG
	DD	$LN14@GL_RenderG
	DD	$LN15@GL_RenderG
	DD	$LN24@GL_RenderG
	DD	$LN25@GL_RenderG
	DD	$LN26@GL_RenderG
	DD	$LN11@GL_RenderG
	DD	$LN2@GL_RenderG
	DD	$LN8@GL_RenderG
	DD	$LN9@GL_RenderG
	DD	$LN10@GL_RenderG
	DD	$LN12@GL_RenderG
	DD	$LN16@GL_RenderG
	DD	$LN17@GL_RenderG
	DD	$LN30@GL_RenderG
	DD	$LN23@GL_RenderG
	DD	$LN18@GL_RenderG
	DD	$LN19@GL_RenderG
	DD	$LN20@GL_RenderG
	DD	$LN21@GL_RenderG
	DD	$LN22@GL_RenderG
	DD	$LN27@GL_RenderG
	DD	$LN28@GL_RenderG
	DD	$LN29@GL_RenderG
	DD	$LN31@GL_RenderG
	DD	$LN32@GL_RenderG
	DD	$LN33@GL_RenderG
	DD	$LN34@GL_RenderG
	DD	$LN35@GL_RenderG
	DD	$LN37@GL_RenderG
	DD	$LN38@GL_RenderG
	DD	$LN39@GL_RenderG
	DD	$LN40@GL_RenderG
	DD	$LN41@GL_RenderG
_GL_RenderGetParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_DoResetGamma
_TEXT	SEGMENT
tv64 = -68						; size = 4
_R_DoResetGamma PROC					; COMDAT

; 1022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1023 : 	// FIXME: this looks ugly. apply the backward gamma changes to the output image
; 1024 : 	return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_DoResetG

; 1025 : 
; 1026 : 	switch( cls.scrshot_action )

	mov	eax, DWORD PTR _cls+296308
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 6
	ja	SHORT $LN13@R_DoResetG
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN15@R_DoResetG[edx*4]
$LN4@R_DoResetG:

; 1027 : 	{
; 1028 : 	case scrshot_normal:
; 1029 : 		if( CL_IsDevOverviewMode( ))

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN5@R_DoResetG

; 1030 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_DoResetG
$LN5@R_DoResetG:

; 1031 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_DoResetG
$LN6@R_DoResetG:

; 1032 : 	case scrshot_snapshot:
; 1033 : 		if( CL_IsDevOverviewMode( ))

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN7@R_DoResetG

; 1034 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_DoResetG
$LN7@R_DoResetG:

; 1035 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_DoResetG
$LN12@R_DoResetG:

; 1036 : 	case scrshot_plaque:
; 1037 : 	case scrshot_savegame:
; 1038 : 	case scrshot_envshot:
; 1039 : 	case scrshot_skyshot:
; 1040 : 	case scrshot_mapshot:
; 1041 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_DoResetG
$LN13@R_DoResetG:

; 1042 : 	default:
; 1043 : 		return false;

	xor	eax, eax
$LN1@R_DoResetG:

; 1044 : 	}
; 1045 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@R_DoResetG:
	DD	$LN4@R_DoResetG
	DD	$LN6@R_DoResetG
	DD	$LN12@R_DoResetG
	DD	$LN12@R_DoResetG
	DD	$LN12@R_DoResetG
	DD	$LN12@R_DoResetG
	DD	$LN12@R_DoResetG
_R_DoResetGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_DrawEntitiesOnList
_TEXT	SEGMENT
tv209 = -72						; size = 4
tv206 = -72						; size = 4
tv198 = -72						; size = 4
tv162 = -72						; size = 4
tv159 = -72						; size = 4
tv151 = -72						; size = 4
tv92 = -72						; size = 4
tv89 = -72						; size = 4
tv81 = -72						; size = 4
_i$ = -4						; size = 4
_R_DrawEntitiesOnList PROC				; COMDAT

; 833  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 834  : 	int	i;
; 835  : 
; 836  : 	tr.blend = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+87592, xmm0

; 837  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 838  : 
; 839  : 	// first draw solid entities
; 840  : 	for( i = 0; i < tr.draw_list->num_solid_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawEnti
$LN2@R_DrawEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawEnti:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24576]
	jae	$LN3@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN3@R_DrawEnti

; 841  : 	{
; 842  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 843  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 844  : 
; 845  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN36@R_DrawEnti
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN37@R_DrawEnti
$LN36@R_DrawEnti:
	mov	DWORD PTR tv81[ebp], 0
$LN37@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv81[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 846  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN38@R_DrawEnti
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN39@R_DrawEnti
$LN38@R_DrawEnti:
	mov	DWORD PTR tv89[ebp], 0
$LN39@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 847  : 
; 848  : 		switch( RI.currentmodel->type )

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv92[ebp], ecx
	cmp	DWORD PTR tv92[ebp], 0
	je	SHORT $LN17@R_DrawEnti
	cmp	DWORD PTR tv92[ebp], 2
	je	SHORT $LN18@R_DrawEnti
	cmp	DWORD PTR tv92[ebp], 3
	je	SHORT $LN19@R_DrawEnti
	jmp	SHORT $LN20@R_DrawEnti
$LN17@R_DrawEnti:

; 849  : 		{
; 850  : 		case mod_brush:
; 851  : 			R_DrawBrushModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawBrushModel
	add	esp, 4

; 852  : 			break;

	jmp	SHORT $LN5@R_DrawEnti
$LN18@R_DrawEnti:

; 853  : 		case mod_alias:
; 854  : 			R_DrawAliasModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawAliasModel
	add	esp, 4

; 855  : 			break;

	jmp	SHORT $LN5@R_DrawEnti
$LN19@R_DrawEnti:

; 856  : 		case mod_studio:
; 857  : 			R_DrawStudioModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawStudioModel
	add	esp, 4
$LN20@R_DrawEnti:
$LN5@R_DrawEnti:

; 858  : 			break;
; 859  : 		default:
; 860  : 			break;
; 861  : 		}
; 862  : 	}

	jmp	$LN2@R_DrawEnti
$LN3@R_DrawEnti:

; 863  : 
; 864  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 31					; 0000001fH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 865  : 
; 866  : 	// quake-specific feature
; 867  : 	R_DrawAlphaTextureChains();

	call	_R_DrawAlphaTextureChains

; 868  : 
; 869  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 870  : 
; 871  : 	// draw sprites seperately, because of alpha blending
; 872  : 	for( i = 0; i < tr.draw_list->num_solid_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@R_DrawEnti
$LN7@R_DrawEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@R_DrawEnti:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24576]
	jae	$LN8@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN8@R_DrawEnti

; 873  : 	{
; 874  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 875  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 876  : 
; 877  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN40@R_DrawEnti
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN41@R_DrawEnti
$LN40@R_DrawEnti:
	mov	DWORD PTR tv151[ebp], 0
$LN41@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv151[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 878  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN42@R_DrawEnti
	mov	DWORD PTR tv159[ebp], 1
	jmp	SHORT $LN43@R_DrawEnti
$LN42@R_DrawEnti:
	mov	DWORD PTR tv159[ebp], 0
$LN43@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv159[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 879  : 
; 880  : 		switch( RI.currentmodel->type )

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv162[ebp], ecx
	cmp	DWORD PTR tv162[ebp], 1
	je	SHORT $LN21@R_DrawEnti
	jmp	SHORT $LN10@R_DrawEnti
$LN21@R_DrawEnti:

; 881  : 		{
; 882  : 		case mod_sprite:
; 883  : 			R_DrawSpriteModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawSpriteModel
	add	esp, 4
$LN10@R_DrawEnti:

; 884  : 			break;
; 885  : 		}
; 886  : 	}

	jmp	$LN7@R_DrawEnti
$LN8@R_DrawEnti:

; 887  : 
; 888  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 55					; 00000037H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 889  : 
; 890  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN22@R_DrawEnti

; 891  :           {
; 892  : 		CL_DrawBeams( false );

	push	0
	call	_CL_DrawBeams
	add	esp, 4
$LN22@R_DrawEnti:

; 893  : 	}
; 894  : 
; 895  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 62					; 0000003eH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 896  : 
; 897  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN23@R_DrawEnti

; 898  : 		clgame.dllFuncs.pfnDrawNormalTriangles();

	call	DWORD PTR _clgame+92
$LN23@R_DrawEnti:

; 899  : 
; 900  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 67					; 00000043H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 901  : 
; 902  : 	// then draw translucent entities
; 903  : 	for( i = 0; i < tr.draw_list->num_trans_entities && !RI.onlyClientDraw; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@R_DrawEnti
$LN12@R_DrawEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@R_DrawEnti:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24580]
	jae	$LN13@R_DrawEnti
	cmp	DWORD PTR _RI+12, 0
	jne	$LN13@R_DrawEnti

; 904  : 	{
; 905  : 		RI.currententity = tr.draw_list->trans_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4+8192]
	mov	DWORD PTR _RI+28, edx

; 906  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 907  : 
; 908  : 		// handle studiomodels with custom rendermodes on texture
; 909  : 		if( RI.currententity->curstate.rendermode != kRenderNormal )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN24@R_DrawEnti

; 910  : 			tr.blend = CL_FxBlend( RI.currententity ) / 255.0f;

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_CL_FxBlend
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tr+87592, xmm0
	jmp	SHORT $LN25@R_DrawEnti
$LN24@R_DrawEnti:

; 911  : 		else tr.blend = 1.0f; // draw as solid but sorted by distance

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+87592, xmm0
$LN25@R_DrawEnti:

; 912  : 
; 913  : 		if( tr.blend <= 0.0f ) continue;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _tr+87592
	jb	SHORT $LN26@R_DrawEnti
	jmp	$LN12@R_DrawEnti
$LN26@R_DrawEnti:

; 914  : 	
; 915  : 		Assert( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN44@R_DrawEnti
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN45@R_DrawEnti
$LN44@R_DrawEnti:
	mov	DWORD PTR tv198[ebp], 0
$LN45@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 82					; 00000052H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@OIBPMFIH@RI?4currententity?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv198[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 916  : 		Assert( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN46@R_DrawEnti
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN47@R_DrawEnti
$LN46@R_DrawEnti:
	mov	DWORD PTR tv206[ebp], 0
$LN47@R_DrawEnti:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 83					; 00000053H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@LLEPFBGJ@RI?4currentmodel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv206[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 917  : 
; 918  : 		switch( RI.currentmodel->type )

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv209[ebp], ecx
	cmp	DWORD PTR tv209[ebp], 3
	ja	SHORT $LN31@R_DrawEnti
	mov	edx, DWORD PTR tv209[ebp]
	jmp	DWORD PTR $LN48@R_DrawEnti[edx*4]
$LN27@R_DrawEnti:

; 919  : 		{
; 920  : 		case mod_brush:
; 921  : 			R_DrawBrushModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawBrushModel
	add	esp, 4

; 922  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN28@R_DrawEnti:

; 923  : 		case mod_alias:
; 924  : 			R_DrawAliasModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawAliasModel
	add	esp, 4

; 925  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN29@R_DrawEnti:

; 926  : 		case mod_studio:
; 927  : 			R_DrawStudioModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawStudioModel
	add	esp, 4

; 928  : 			break;

	jmp	SHORT $LN15@R_DrawEnti
$LN30@R_DrawEnti:

; 929  : 		case mod_sprite:
; 930  : 			R_DrawSpriteModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawSpriteModel
	add	esp, 4
$LN31@R_DrawEnti:
$LN15@R_DrawEnti:

; 931  : 			break;
; 932  : 		default:
; 933  : 			break;
; 934  : 		}
; 935  : 	}

	jmp	$LN12@R_DrawEnti
$LN13@R_DrawEnti:

; 936  : 
; 937  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 938  : 
; 939  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN32@R_DrawEnti

; 940  : 	{
; 941  : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 942  : 		clgame.dllFuncs.pfnDrawTransparentTriangles ();

	call	DWORD PTR _clgame+96
$LN32@R_DrawEnti:

; 943  : 	}
; 944  : 
; 945  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 112				; 00000070H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 946  : 
; 947  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN33@R_DrawEnti

; 948  : 	{
; 949  : 		R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4

; 950  : 		CL_DrawBeams( true );

	push	1
	call	_CL_DrawBeams
	add	esp, 4

; 951  : 		CL_DrawParticles( tr.frametime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _tr+87584
	movsd	QWORD PTR [esp], xmm0
	call	_CL_DrawParticles
	add	esp, 8

; 952  : 		CL_DrawTracers( tr.frametime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _tr+87584
	movsd	QWORD PTR [esp], xmm0
	call	_CL_DrawTracers
	add	esp, 8

; 953  : 		R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN33@R_DrawEnti:

; 954  : 	}
; 955  : 
; 956  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 123				; 0000007bH
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 957  : 
; 958  : 	pglDisable( GL_BLEND );	// Trinity Render issues

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 959  : 
; 960  : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN34@R_DrawEnti

; 961  : 		R_DrawViewModel();

	call	_R_DrawViewModel
$LN34@R_DrawEnti:

; 962  : 	CL_ExtraUpdate();

	call	_CL_ExtraUpdate

; 963  : 
; 964  : 	GL_CheckForErrors();

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawEntitiesOnList@@9@9
	add	eax, 131				; 00000083H
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	_GL_CheckForErrors_
	add	esp, 8

; 965  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN48@R_DrawEnti:
	DD	$LN27@R_DrawEnti
	DD	$LN30@R_DrawEnti
	DD	$LN28@R_DrawEnti
	DD	$LN29@R_DrawEnti
_R_DrawEntitiesOnList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_CheckGLFog
_TEXT	SEGMENT
_R_CheckGLFog PROC					; COMDAT

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 798  : #ifdef HACKS_RELATED_HLMODS
; 799  : 	if(( !RI.fogEnabled && !RI.fogCustom ) && pglIsEnabled( GL_FOG ) && VectorIsNull( RI.fogColor ))

	cmp	DWORD PTR _RI+316, 0
	jne	$LN2@R_CheckGLF
	cmp	DWORD PTR _RI+312, 0
	jne	$LN2@R_CheckGLF
	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@R_CheckGLF
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+324]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_CheckGLF

; 800  : 	{
; 801  : 		// fill the fog color from GL-state machine
; 802  : 		pglGetFloatv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglGetFloatv

; 803  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1
$LN2@R_CheckGLF:

; 804  : 	}
; 805  : #endif
; 806  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CheckGLFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_CheckFog
_TEXT	SEGMENT
tv272 = -100						; size = 8
tv269 = -92						; size = 4
_surf$1 = -24						; size = 4
_count$ = -20						; size = 4
_cnt$ = -16						; size = 4
_i$ = -12						; size = 4
_tex$ = -8						; size = 4
_ent$ = -4						; size = 4
_R_CheckFog PROC					; COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 691  : 	cl_entity_t	*ent;
; 692  : 	gl_texture_t	*tex;
; 693  : 	int		i, cnt, count;
; 694  : 
; 695  : 	// quake global fog
; 696  : 	if( CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	$LN5@R_CheckFog

; 697  : 	{
; 698  : 		if( !clgame.movevars.fog_settings )

	cmp	DWORD PTR _clgame+1176, 0
	jne	SHORT $LN6@R_CheckFog

; 699  : 		{
; 700  : 			if( pglIsEnabled( GL_FOG ))

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@R_CheckFog

; 701  : 				pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN7@R_CheckFog:

; 702  : 			RI.fogEnabled = false;

	mov	DWORD PTR _RI+316, 0

; 703  : 			return;

	jmp	$LN15@R_CheckFog
$LN6@R_CheckFog:

; 704  : 		}
; 705  : 
; 706  : 		// quake-style global fog
; 707  : 		RI.fogColor[0] = ((clgame.movevars.fog_settings & 0xFF000000) >> 24) / 255.0f;

	mov	eax, DWORD PTR _clgame+1176
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	DWORD PTR tv269[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv269[ebp]
	mov	ecx, DWORD PTR tv269[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv272[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv272[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _RI[eax+324], xmm0

; 708  : 		RI.fogColor[1] = ((clgame.movevars.fog_settings & 0xFF0000) >> 16) / 255.0f;

	mov	eax, DWORD PTR _clgame+1176
	and	eax, 16711680				; 00ff0000H
	sar	eax, 16					; 00000010H
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _RI[ecx+324], xmm0

; 709  : 		RI.fogColor[2] = ((clgame.movevars.fog_settings & 0xFF00) >> 8) / 255.0f;

	mov	eax, DWORD PTR _clgame+1176
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _RI[ecx+324], xmm0

; 710  : 		RI.fogDensity = ((clgame.movevars.fog_settings & 0xFF) / 255.0f) * 0.01f;

	mov	eax, DWORD PTR _clgame+1176
	and	eax, 255				; 000000ffH
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _RI+340, xmm0

; 711  : 		RI.fogStart = RI.fogEnd = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+348, xmm0
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR _RI+344, xmm0

; 712  : 		RI.fogColor[3] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[ecx+324], xmm0

; 713  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 714  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 715  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 716  : 		return;

	jmp	$LN15@R_CheckFog
$LN5@R_CheckFog:

; 717  : 	}
; 718  : 
; 719  : 	RI.fogEnabled = false;

	mov	DWORD PTR _RI+316, 0

; 720  : 
; 721  : 	if( RI.onlyClientDraw || cl.local.waterlevel < 3 || !RI.drawWorld || !RI.viewleaf )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _cl+2212736, 3
	jl	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN9@R_CheckFog
	cmp	DWORD PTR _RI+180, 0
	jne	SHORT $LN8@R_CheckFog
$LN9@R_CheckFog:

; 722  : 	{
; 723  : 		if( RI.cached_waterlevel == 3 )

	cmp	DWORD PTR _RI+356, 3
	jne	SHORT $LN11@R_CheckFog

; 724  :                     {
; 725  : 			// in some cases waterlevel jumps from 3 to 1. Catch it
; 726  : 			RI.cached_waterlevel = cl.local.waterlevel;

	mov	eax, DWORD PTR _cl+2212736
	mov	DWORD PTR _RI+356, eax

; 727  : 			RI.cached_contents = CONTENTS_EMPTY;

	mov	DWORD PTR _RI+352, -1

; 728  : 			if( !RI.fogCustom ) pglDisable( GL_FOG );

	cmp	DWORD PTR _RI+312, 0
	jne	SHORT $LN11@R_CheckFog
	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN11@R_CheckFog:

; 729  : 		}
; 730  : 		return;

	jmp	$LN15@R_CheckFog
$LN8@R_CheckFog:

; 731  : 	}
; 732  : 
; 733  : 	ent = CL_GetWaterEntity( RI.vieworg );

	push	OFFSET _RI+200
	call	_CL_GetWaterEntity
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 734  : 	if( ent && ent->model && ent->model->type == mod_brush && ent->curstate.skin < 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN12@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN12@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN12@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1048], 0
	jge	SHORT $LN12@R_CheckFog

; 735  : 		cnt = ent->curstate.skin;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	mov	DWORD PTR _cnt$[ebp], ecx
	jmp	SHORT $LN13@R_CheckFog
$LN12@R_CheckFog:

; 736  : 	else cnt = RI.viewleaf->contents;

	mov	eax, DWORD PTR _RI+180
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cnt$[ebp], ecx
$LN13@R_CheckFog:

; 737  : 
; 738  : 	RI.cached_waterlevel = cl.local.waterlevel;

	mov	eax, DWORD PTR _cl+2212736
	mov	DWORD PTR _RI+356, eax

; 739  : 
; 740  : 	if( !IsLiquidContents( RI.cached_contents ) && IsLiquidContents( cnt ))

	cmp	DWORD PTR _RI+352, -3			; fffffffdH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _RI+352, -4			; fffffffcH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _RI+352, -5			; fffffffbH
	je	$LN14@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -3		; fffffffdH
	je	SHORT $LN16@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -4		; fffffffcH
	je	SHORT $LN16@R_CheckFog
	cmp	DWORD PTR _cnt$[ebp], -5		; fffffffbH
	jne	$LN14@R_CheckFog
$LN16@R_CheckFog:

; 741  : 	{
; 742  : 		tex = NULL;

	mov	DWORD PTR _tex$[ebp], 0

; 743  : 
; 744  : 		// check for water texture
; 745  : 		if( ent && ent->model && ent->model->type == mod_brush )

	cmp	DWORD PTR _ent$[ebp], 0
	je	$LN17@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	$LN17@R_CheckFog
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	$LN17@R_CheckFog

; 746  : 		{
; 747  : 			msurface_t	*surf;
; 748  : 	
; 749  : 			count = ent->model->nummodelsurfaces;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR _count$[ebp], edx

; 750  : 
; 751  : 			for( i = 0, surf = &ent->model->surfaces[ent->model->firstmodelsurface]; i < count; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+3300]
	imul	edx, DWORD PTR [eax+112], 92
	add	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR _surf$1[ebp], edx
	jmp	SHORT $LN4@R_CheckFog
$LN2@R_CheckFog:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$1[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$1[ebp], ecx
$LN4@R_CheckFog:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@R_CheckFog

; 752  : 			{
; 753  : 				if( surf->flags & SURF_DRAWTURB && surf->texinfo && surf->texinfo->texture )

	mov	eax, DWORD PTR _surf$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	SHORT $LN19@R_CheckFog
	mov	eax, DWORD PTR _surf$1[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN19@R_CheckFog
	mov	eax, DWORD PTR _surf$1[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN19@R_CheckFog

; 754  : 				{
; 755  : 					tex = R_GetTexture( surf->texinfo->texture->gl_texturenum );

	mov	eax, DWORD PTR _surf$1[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax

; 756  : 					RI.cached_contents = ent->curstate.skin;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1048]
	mov	DWORD PTR _RI+352, ecx

; 757  : 					break;

	jmp	SHORT $LN3@R_CheckFog
$LN19@R_CheckFog:

; 758  : 				}
; 759  : 			}

	jmp	SHORT $LN2@R_CheckFog
$LN3@R_CheckFog:

; 760  : 		}

	jmp	SHORT $LN20@R_CheckFog
$LN17@R_CheckFog:

; 761  : 		else
; 762  : 		{
; 763  : 			tex = R_RecursiveFindWaterTexture( RI.viewleaf->parent, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _RI+180
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 764  : 			if( tex ) RI.cached_contents = RI.viewleaf->contents;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN20@R_CheckFog
	mov	eax, DWORD PTR _RI+180
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _RI+352, ecx
$LN20@R_CheckFog:

; 765  : 		}
; 766  : 
; 767  : 		if( !tex ) return;	// no valid fogs

	cmp	DWORD PTR _tex$[ebp], 0
	jne	SHORT $LN21@R_CheckFog
	jmp	$LN15@R_CheckFog
$LN21@R_CheckFog:

; 768  : 
; 769  : 		// copy fog params
; 770  : 		RI.fogColor[0] = tex->fogParams[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+288]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _RI[edx+324], xmm0

; 771  : 		RI.fogColor[1] = tex->fogParams[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+288]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _RI[eax+324], xmm0

; 772  : 		RI.fogColor[2] = tex->fogParams[2] / 255.0f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+288]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _RI[eax+324], xmm0

; 773  : 		RI.fogDensity = tex->fogParams[3] * 0.000025f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+288]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@37d1b717
	movss	DWORD PTR _RI+340, xmm0

; 774  : 		RI.fogStart = RI.fogEnd = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+348, xmm0
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR _RI+344, xmm0

; 775  : 		RI.fogColor[3] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[ecx+324], xmm0

; 776  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 777  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 778  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 779  : 	}

	jmp	SHORT $LN15@R_CheckFog
$LN14@R_CheckFog:

; 780  : 	else
; 781  : 	{
; 782  : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 783  : 		RI.fogEnabled = true;

	mov	DWORD PTR _RI+316, 1

; 784  : 		RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1
$LN15@R_CheckFog:

; 785  : 	}
; 786  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CheckFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_RecursiveFindWaterTexture
_TEXT	SEGMENT
tv70 = -88						; size = 4
_c$1 = -20						; size = 4
_i$2 = -16						; size = 4
_mark$3 = -12						; size = 4
_pleaf$4 = -8						; size = 4
_tex$ = -4						; size = 4
_node$ = 8						; size = 4
_ignore$ = 12						; size = 4
_down$ = 16						; size = 4
_R_RecursiveFindWaterTexture PROC			; COMDAT

; 618  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 619  : 	gl_texture_t *tex = NULL;

	mov	DWORD PTR _tex$[ebp], 0

; 620  : 
; 621  : 	// assure the initial node is not null
; 622  : 	// we could check it here, but we would rather check it 
; 623  : 	// outside the call to get rid of one additional recursion level
; 624  : 	Assert( node != NULL );

	cmp	DWORD PTR _node$[ebp], 0
	je	SHORT $LN16@R_Recursiv
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN17@R_Recursiv
$LN16@R_Recursiv:
	mov	DWORD PTR tv70[ebp], 0
$LN17@R_Recursiv:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_RecursiveFindWaterTexture@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DF@LOADKKNL@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@MOPCPKLO@node?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 625  : 
; 626  : 	// ignore solid nodes
; 627  : 	if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN5@R_Recursiv

; 628  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN5@R_Recursiv:

; 629  : 
; 630  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	$LN6@R_Recursiv

; 631  : 	{
; 632  : 		mleaf_t		*pleaf;
; 633  : 		msurface_t	**mark;
; 634  : 		int		i, c;
; 635  : 
; 636  : 		// ignore non-liquid leaves
; 637  : 		if( node->contents != CONTENTS_WATER && node->contents != CONTENTS_LAVA && node->contents != CONTENTS_SLIME )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -3			; fffffffdH
	je	SHORT $LN7@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -5			; fffffffbH
	je	SHORT $LN7@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -4			; fffffffcH
	je	SHORT $LN7@R_Recursiv

; 638  : 			 return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN7@R_Recursiv:

; 639  : 
; 640  : 		// find texture
; 641  : 		pleaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pleaf$4[ebp], eax

; 642  : 		mark = pleaf->firstmarksurface;

	mov	eax, DWORD PTR _pleaf$4[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mark$3[ebp], ecx

; 643  : 		c = pleaf->nummarksurfaces;	

	mov	eax, DWORD PTR _pleaf$4[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _c$1[ebp], ecx

; 644  : 
; 645  : 		for( i = 0; i < c; i++, mark++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@R_Recursiv
$LN2@R_Recursiv:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
	mov	ecx, DWORD PTR _mark$3[ebp]
	add	ecx, 4
	mov	DWORD PTR _mark$3[ebp], ecx
$LN4@R_Recursiv:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _c$1[ebp]
	jge	SHORT $LN3@R_Recursiv

; 646  : 		{
; 647  : 			if( (*mark)->flags & SURF_DRAWTURB && (*mark)->texinfo && (*mark)->texinfo->texture )

	mov	eax, DWORD PTR _mark$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	SHORT $LN8@R_Recursiv
	mov	eax, DWORD PTR _mark$3[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN8@R_Recursiv
	mov	eax, DWORD PTR _mark$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN8@R_Recursiv

; 648  : 				return R_GetTexture( (*mark)->texinfo->texture->gl_texturenum );

	mov	eax, DWORD PTR _mark$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	jmp	$LN1@R_Recursiv
$LN8@R_Recursiv:

; 649  : 		}

	jmp	SHORT $LN2@R_Recursiv
$LN3@R_Recursiv:

; 650  : 
; 651  : 		// texture not found
; 652  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_Recursiv
$LN6@R_Recursiv:

; 653  : 	}
; 654  : 
; 655  : 	// this is a regular node
; 656  : 	// traverse children
; 657  : 	if( node->children[0] && ( node->children[0] != ignore ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+ecx+40], 0
	je	SHORT $LN9@R_Recursiv
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	cmp	eax, DWORD PTR _ignore$[ebp]
	je	SHORT $LN9@R_Recursiv

; 658  : 	{
; 659  : 		tex = R_RecursiveFindWaterTexture( node->children[0], node, true );

	push	1
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 660  : 		if( tex ) return tex;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN9@R_Recursiv
	mov	eax, DWORD PTR _tex$[ebp]
	jmp	SHORT $LN1@R_Recursiv
$LN9@R_Recursiv:

; 661  : 	}
; 662  : 
; 663  : 	if( node->children[1] && ( node->children[1] != ignore ))

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+eax+40], 0
	je	SHORT $LN11@R_Recursiv
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	cmp	edx, DWORD PTR _ignore$[ebp]
	je	SHORT $LN11@R_Recursiv

; 664  : 	{
; 665  : 		tex = R_RecursiveFindWaterTexture( node->children[1], node, true );

	push	1
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	push	eax
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tex$[ebp], eax

; 666  : 		if( tex )	return tex;

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN11@R_Recursiv
	mov	eax, DWORD PTR _tex$[ebp]
	jmp	SHORT $LN1@R_Recursiv
$LN11@R_Recursiv:

; 667  : 	}
; 668  : 
; 669  : 	// for down recursion, return immediately
; 670  : 	if( down ) return NULL;

	cmp	DWORD PTR _down$[ebp], 0
	je	SHORT $LN13@R_Recursiv
	xor	eax, eax
	jmp	SHORT $LN1@R_Recursiv
$LN13@R_Recursiv:

; 671  : 
; 672  : 	// texture not found, step up if any
; 673  : 	if( node->parent )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN14@R_Recursiv

; 674  : 		return R_RecursiveFindWaterTexture( node->parent, node, false );

	push	0
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_R_RecursiveFindWaterTexture
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@R_Recursiv
$LN14@R_Recursiv:

; 675  : 
; 676  : 	// top-level node, bail out
; 677  : 	return NULL;

	xor	eax, eax
$LN1@R_Recursiv:

; 678  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RecursiveFindWaterTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_EndGL
_TEXT	SEGMENT
_R_EndGL PROC						; COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 605  : 	if( RI.params & RP_CLIPPLANE )

	mov	eax, DWORD PTR _RI
	and	eax, 8
	je	SHORT $LN1@R_EndGL

; 606  : 		pglDisable( GL_CLIP_PLANE0 );

	push	12288					; 00003000H
	call	DWORD PTR _pglDisable
$LN1@R_EndGL:

; 607  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_EndGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupFrame
_TEXT	SEGMENT
_R_SetupFrame PROC					; COMDAT

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 522  : 	// setup viewplane dist
; 523  : 	RI.viewplanedist = DotProduct( RI.vieworg, RI.vforward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	mulss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+200]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+200]
	mulss	xmm1, DWORD PTR _RI[ecx+224]
	addss	xmm0, xmm1
	movss	DWORD PTR _RI+4872, xmm0

; 524  : 
; 525  : 	if( !gl_nosort->value )

	mov	eax, DWORD PTR _gl_nosort
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_SetupFra

; 526  : 	{
; 527  : 		// sort translucents entities by rendermode and distance
; 528  : 		qsort( tr.draw_list->trans_entities, tr.draw_list->num_trans_entities, sizeof( cl_entity_t* ), R_TransEntityCompare );

	push	OFFSET _R_TransEntityCompare
	push	4
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24580]
	push	ecx
	mov	edx, DWORD PTR _tr+66792
	add	edx, 8192				; 00002000H
	push	edx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H
$LN2@R_SetupFra:

; 529  : 	}
; 530  : 
; 531  : 	// current viewleaf
; 532  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_SetupFra

; 533  : 	{
; 534  : 		RI.isSkyVisible = false; // unknown at this moment

	mov	DWORD PTR _RI+8, 0

; 535  : 		R_FindViewLeaf();

	call	_R_FindViewLeaf
$LN3@R_SetupFra:

; 536  : 	}
; 537  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupModelviewMatrix
_TEXT	SEGMENT
_m$ = 8							; size = 4
_R_SetupModelviewMatrix PROC				; COMDAT

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 428  : 	Matrix4x4_CreateModelview( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_CreateModelview
	add	esp, 4

; 429  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[2], 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_ConcatRotate
	add	esp, 20					; 00000014H

; 430  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[0], 0, 1, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	_Matrix4x4_ConcatRotate
	add	esp, 20					; 00000014H

; 431  : 	Matrix4x4_ConcatRotate( m, -RI.viewangles[1], 0, 0, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_ConcatRotate
	add	esp, 20					; 00000014H

; 432  : 	Matrix4x4_ConcatTranslate( m, -RI.vieworg[0], -RI.vieworg[1], -RI.vieworg[2] );

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_ConcatTranslate
	add	esp, 16					; 00000010H

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupModelviewMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupProjectionMatrix
_TEXT	SEGMENT
tv181 = -124						; size = 8
tv173 = -124						; size = 8
tv80 = -120						; size = 4
_ov$1 = -52						; size = 4
_zFar$ = -48						; size = 8
_zNear$ = -40						; size = 8
_yMax$ = -32						; size = 8
_yMin$ = -24						; size = 8
_xMax$ = -16						; size = 8
_xMin$ = -8						; size = 8
_m$ = 8							; size = 4
_R_SetupProjectionMatrix PROC				; COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 398  : 	GLdouble	xMin, xMax, yMin, yMax, zNear, zFar;
; 399  : 
; 400  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN2@R_SetupPro

; 401  : 	{
; 402  : 		ref_overview_t *ov = &clgame.overView;

	mov	DWORD PTR _ov$1[ebp], OFFSET _clgame+217612

; 403  : 		Matrix4x4_CreateOrtho( m, ov->xLeft, ov->xRight, ov->yTop, ov->yBottom, ov->zNear, ov->zFar );

	mov	eax, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$1[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_CreateOrtho
	add	esp, 28					; 0000001cH

; 404  : 		return;

	jmp	$LN1@R_SetupPro
$LN2@R_SetupPro:

; 405  : 	}
; 406  : 
; 407  : 	RI.farClip = R_GetFarClip();

	call	_R_GetFarClip
	fstp	DWORD PTR _RI+308

; 408  : 
; 409  : 	zNear = 4.0f;

	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR _zNear$[ebp], xmm0

; 410  : 	zFar = max( 256.0f, RI.farClip );

	movss	xmm0, DWORD PTR __real@43800000
	comiss	xmm0, DWORD PTR _RI+308
	jbe	SHORT $LN4@R_SetupPro
	movss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN5@R_SetupPro
$LN4@R_SetupPro:
	movss	xmm0, DWORD PTR _RI+308
	movss	DWORD PTR tv80[ebp], xmm0
$LN5@R_SetupPro:
	cvtss2sd xmm0, DWORD PTR tv80[ebp]
	movsd	QWORD PTR _zFar$[ebp], xmm0

; 411  : 
; 412  : 	yMax = zNear * tan( RI.fov_y * M_PI / 360.0 );

	movss	xmm0, DWORD PTR _RI+24
	mulss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4076800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv173[ebp]
	movsd	xmm0, QWORD PTR tv173[ebp]
	mulsd	xmm0, QWORD PTR _zNear$[ebp]
	movsd	QWORD PTR _yMax$[ebp], xmm0

; 413  : 	yMin = -yMax;

	movsd	xmm0, QWORD PTR _yMax$[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _yMin$[ebp], xmm0

; 414  : 
; 415  : 	xMax = zNear * tan( RI.fov_x * M_PI / 360.0 );

	movss	xmm0, DWORD PTR _RI+20
	mulss	xmm0, DWORD PTR __real@40490fdb
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4076800000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv181[ebp]
	movsd	xmm0, QWORD PTR tv181[ebp]
	mulsd	xmm0, QWORD PTR _zNear$[ebp]
	movsd	QWORD PTR _xMax$[ebp], xmm0

; 416  : 	xMin = -xMax;

	movsd	xmm0, QWORD PTR _xMax$[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _xMin$[ebp], xmm0

; 417  : 
; 418  : 	Matrix4x4_CreateProjection( m, xMax, xMin, yMax, yMin, zNear, zFar );

	cvtsd2ss xmm0, QWORD PTR _zFar$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _zNear$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _yMin$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _yMax$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _xMin$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _xMax$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_CreateProjection
	add	esp, 28					; 0000001cH
$LN1@R_SetupPro:

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupProjectionMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_GetFarClip
_TEXT	SEGMENT
tv69 = -68						; size = 4
_R_GetFarClip PROC					; COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 355  : 	if( cl.worldmodel && RI.drawWorld )

	cmp	DWORD PTR _cl+4579004, 0
	je	SHORT $LN2@R_GetFarCl
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_GetFarCl

; 356  : 		return clgame.movevars.zmax * 1.73f;

	movss	xmm0, DWORD PTR _clgame+1080
	mulss	xmm0, DWORD PTR __real@3fdd70a4
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]
	jmp	SHORT $LN1@R_GetFarCl
$LN2@R_GetFarCl:

; 357  : 	return 2048.0f;

	fld	DWORD PTR __real@45000000
$LN1@R_GetFarCl:

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetFarClip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_Clear
_TEXT	SEGMENT
_bits$ = -4						; size = 4
_bitMask$ = 8						; size = 4
_R_Clear PROC						; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 316  : 	int	bits;
; 317  : 
; 318  : 	if( CL_IsDevOverviewMode( ))

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@R_Clear

; 319  : 		pglClearColor( 0.0f, 1.0f, 0.0f, 1.0f ); // green background (Valve rules)

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor
	jmp	SHORT $LN3@R_Clear
$LN2@R_Clear:

; 320  : 	else pglClearColor( 0.5f, 0.5f, 0.5f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor
$LN3@R_Clear:

; 321  : 
; 322  : 	bits = GL_DEPTH_BUFFER_BIT;

	mov	DWORD PTR _bits$[ebp], 256		; 00000100H

; 323  : 
; 324  : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN4@R_Clear

; 325  : 		bits |= GL_STENCIL_BUFFER_BIT;

	mov	eax, DWORD PTR _bits$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _bits$[ebp], eax
$LN4@R_Clear:

; 326  : 
; 327  : 	bits &= bitMask;

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, DWORD PTR _bitMask$[ebp]
	mov	DWORD PTR _bits$[ebp], eax

; 328  : 
; 329  : 	pglClear( bits );

	mov	eax, DWORD PTR _bits$[ebp]
	push	eax
	call	DWORD PTR _pglClear

; 330  : 
; 331  : 	// change ordering for overview
; 332  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN5@R_Clear

; 333  : 	{
; 334  : 		gldepthmin = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gldepthmin, xmm0

; 335  : 		gldepthmax = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _gldepthmax, xmm0

; 336  : 	}

	jmp	SHORT $LN6@R_Clear
$LN5@R_Clear:

; 337  : 	else
; 338  : 	{
; 339  : 		gldepthmin = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _gldepthmin, xmm0

; 340  : 		gldepthmax = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gldepthmax, xmm0
$LN6@R_Clear:

; 341  : 	}
; 342  : 
; 343  : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 344  : 	pglDepthRange( gldepthmin, gldepthmax );

	cvtss2sd xmm0, DWORD PTR _gldepthmax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_TransEntityCompare
_TEXT	SEGMENT
tv305 = -120						; size = 4
tv284 = -120						; size = 4
tv260 = -120						; size = 4
tv193 = -120						; size = 4
tv172 = -120						; size = 4
tv148 = -120						; size = 4
_rendermode2$ = -52					; size = 4
_rendermode1$ = -48					; size = 4
_dist2$ = -44						; size = 4
_dist1$ = -40						; size = 4
_org$ = -36						; size = 12
_vecLen$ = -24						; size = 12
_ent2$ = -12						; size = 4
_ent1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_R_TransEntityCompare PROC				; COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 119  : 	cl_entity_t	*ent1, *ent2;
; 120  : 	vec3_t		vecLen, org;
; 121  : 	float		dist1, dist2;
; 122  : 	int		rendermode1;
; 123  : 	int		rendermode2;
; 124  : 
; 125  : 	ent1 = (cl_entity_t *)*a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ent1$[ebp], ecx

; 126  : 	ent2 = (cl_entity_t *)*b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ent2$[ebp], ecx

; 127  : 	rendermode1 = R_GetEntityRenderMode( ent1 );

	mov	eax, DWORD PTR _ent1$[ebp]
	push	eax
	call	_R_GetEntityRenderMode
	add	esp, 4
	mov	DWORD PTR _rendermode1$[ebp], eax

; 128  : 	rendermode2 = R_GetEntityRenderMode( ent2 );

	mov	eax, DWORD PTR _ent2$[ebp]
	push	eax
	call	_R_GetEntityRenderMode
	add	esp, 4
	mov	DWORD PTR _rendermode2$[ebp], eax

; 129  : 
; 130  : 	// sort by distance
; 131  : 	if( ent1->model->type != mod_brush || rendermode1 != kRenderTransAlpha )

	mov	eax, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN4@R_TransEnt
	cmp	DWORD PTR _rendermode1$[ebp], 4
	je	$LN2@R_TransEnt
$LN4@R_TransEnt:

; 132  : 	{
; 133  : 		VectorAverage( ent1->model->mins, ent1->model->maxs, org );

	mov	eax, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent1$[ebp]
	mov	edx, DWORD PTR [edx+3300]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax+84]
	addss	xmm0, DWORD PTR [edx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _ent1$[ebp]
	mov	eax, DWORD PTR [edx+3300]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent1$[ebp]
	mov	edx, DWORD PTR [edx+3300]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx+84]
	addss	xmm0, DWORD PTR [edx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _ent1$[ebp]
	mov	edx, DWORD PTR [ecx+3300]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent1$[ebp]
	mov	ecx, DWORD PTR [ecx+3300]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR [ecx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv148[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _org$[ebp+edx], xmm0

; 134  : 		VectorAdd( ent1->origin, org, org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent1$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _org$[ebp+eax], xmm0

; 135  : 		VectorSubtract( RI.vieworg, org, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0

; 136  : 		dist1 = DotProduct( vecLen, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecLen$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecLen$[ebp+eax]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist1$[ebp], xmm0

; 137  : 	}

	jmp	SHORT $LN3@R_TransEnt
$LN2@R_TransEnt:

; 138  : 	else dist1 = 1000000000;

	movss	xmm0, DWORD PTR __real@4e6e6b28
	movss	DWORD PTR _dist1$[ebp], xmm0
$LN3@R_TransEnt:

; 139  : 
; 140  : 	if( ent2->model->type != mod_brush || rendermode2 != kRenderTransAlpha )

	mov	eax, DWORD PTR _ent2$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN7@R_TransEnt
	cmp	DWORD PTR _rendermode2$[ebp], 4
	je	$LN5@R_TransEnt
$LN7@R_TransEnt:

; 141  : 	{
; 142  : 		VectorAverage( ent2->model->mins, ent2->model->maxs, org );

	mov	eax, DWORD PTR _ent2$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent2$[ebp]
	mov	edx, DWORD PTR [edx+3300]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax+84]
	addss	xmm0, DWORD PTR [edx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _ent2$[ebp]
	mov	eax, DWORD PTR [edx+3300]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent2$[ebp]
	mov	edx, DWORD PTR [edx+3300]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx+84]
	addss	xmm0, DWORD PTR [edx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _ent2$[ebp]
	mov	edx, DWORD PTR [ecx+3300]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent2$[ebp]
	mov	ecx, DWORD PTR [ecx+3300]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR [ecx+esi+96]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv260[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR _org$[ebp+edx], xmm0

; 143  : 		VectorAdd( ent2->origin, org, org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent2$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv284[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv284[ebp]
	movss	DWORD PTR _org$[ebp+eax], xmm0

; 144  : 		VectorSubtract( RI.vieworg, org, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv305[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR _vecLen$[ebp+edx], xmm0

; 145  : 		dist2 = DotProduct( vecLen, vecLen );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecLen$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecLen$[ebp+eax]
	mulss	xmm1, DWORD PTR _vecLen$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist2$[ebp], xmm0

; 146  : 	}

	jmp	SHORT $LN6@R_TransEnt
$LN5@R_TransEnt:

; 147  : 	else dist2 = 1000000000;

	movss	xmm0, DWORD PTR __real@4e6e6b28
	movss	DWORD PTR _dist2$[ebp], xmm0
$LN6@R_TransEnt:

; 148  : 
; 149  : 	if( dist1 > dist2 )

	movss	xmm0, DWORD PTR _dist1$[ebp]
	comiss	xmm0, DWORD PTR _dist2$[ebp]
	jbe	SHORT $LN8@R_TransEnt

; 150  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_TransEnt
$LN8@R_TransEnt:

; 151  : 	if( dist1 < dist2 )

	movss	xmm0, DWORD PTR _dist2$[ebp]
	comiss	xmm0, DWORD PTR _dist1$[ebp]
	jbe	SHORT $LN9@R_TransEnt

; 152  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_TransEnt
$LN9@R_TransEnt:

; 153  : 
; 154  : 	// then sort by rendermode
; 155  : 	if( R_RankForRenderMode( rendermode1 ) > R_RankForRenderMode( rendermode2 ))

	mov	eax, DWORD PTR _rendermode1$[ebp]
	push	eax
	call	_R_RankForRenderMode
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _rendermode2$[ebp]
	push	ecx
	call	_R_RankForRenderMode
	add	esp, 4
	cmp	esi, eax
	jle	SHORT $LN10@R_TransEnt

; 156  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_TransEnt
$LN10@R_TransEnt:

; 157  : 	if( R_RankForRenderMode( rendermode1 ) < R_RankForRenderMode( rendermode2 ))

	mov	eax, DWORD PTR _rendermode1$[ebp]
	push	eax
	call	_R_RankForRenderMode
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _rendermode2$[ebp]
	push	ecx
	call	_R_RankForRenderMode
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN11@R_TransEnt

; 158  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_TransEnt
$LN11@R_TransEnt:

; 159  : 
; 160  : 	return 0;

	xor	eax, eax
$LN1@R_TransEnt:

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TransEntityCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_OpaqueEntity
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_R_OpaqueEntity PROC					; COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 105  : 	if( R_GetEntityRenderMode( ent ) == kRenderNormal )

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_GetEntityRenderMode
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_OpaqueEn

; 106  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_OpaqueEn
$LN2@R_OpaqueEn:

; 107  : 	return false;

	xor	eax, eax
$LN1@R_OpaqueEn:

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_OpaqueEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_StaticEntityLegacy
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_R_StaticEntityLegacy PROC				; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 72   : 	//if (!gl_allow_static->value)
; 73   : 	//	return false;
; 74   : 
; 75   : 	if (ent->curstate.rendermode != kRenderNormal)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN2@R_StaticEn

; 76   : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StaticEn
$LN2@R_StaticEn:

; 77   : 
; 78   : 	if (ent->model->type != mod_brush)

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN3@R_StaticEn

; 79   : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StaticEn
$LN3@R_StaticEn:

; 80   : 
; 81   : 	if (ent->curstate.effects & (EF_NOREFLECT | EF_REFLECTONLY))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 50331648				; 03000000H
	je	SHORT $LN4@R_StaticEn

; 82   : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StaticEn
$LN4@R_StaticEn:

; 83   : 
; 84   : 	if (ent->curstate.frame || ent->model->flags & MODEL_CONVEYOR)

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+960]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_StaticEn
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 1
	je	SHORT $LN5@R_StaticEn
$LN6@R_StaticEn:

; 85   : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StaticEn
$LN5@R_StaticEn:

; 86   : 
; 87   : 	if (ent->curstate.scale) // waveheight specified

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@R_StaticEn

; 88   : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StaticEn
$LN7@R_StaticEn:

; 89   : 
; 90   : 	if (!VectorIsNull(ent->origin) || !VectorIsNull(ent->angles))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@R_StaticEn
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@R_StaticEn
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_StaticEn
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_StaticEn
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_StaticEn
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@R_StaticEn
$LN10@R_StaticEn:

; 91   : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_StaticEn
$LN8@R_StaticEn:

; 92   : 
; 93   : 	return true;

	mov	eax, 1
$LN1@R_StaticEn:

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StaticEntityLegacy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_RankForRenderMode
_TEXT	SEGMENT
tv64 = -68						; size = 4
_rendermode$ = 8					; size = 4
_R_RankForRenderMode PROC				; COMDAT

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 32   : 	switch( rendermode )

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN4@R_RankForR
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN6@R_RankForR
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN5@R_RankForR
	jmp	SHORT $LN2@R_RankForR
$LN4@R_RankForR:

; 33   : 	{
; 34   : 	case kRenderTransTexture:
; 35   : 		return 1;	// draw second

	mov	eax, 1
	jmp	SHORT $LN1@R_RankForR
$LN5@R_RankForR:

; 36   : 	case kRenderTransAdd:
; 37   : 		return 2;	// draw third

	mov	eax, 2
	jmp	SHORT $LN1@R_RankForR
$LN6@R_RankForR:

; 38   : 	case kRenderGlow:
; 39   : 		return 3;	// must be last!

	mov	eax, 3
	jmp	SHORT $LN1@R_RankForR
$LN2@R_RankForR:

; 40   : 	}
; 41   : 	return 0;

	xor	eax, eax
$LN1@R_RankForR:

; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RankForRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_AddEntity
_TEXT	SEGMENT
_clent$ = 8						; size = 4
_type$ = 12						; size = 4
_R_AddEntity PROC					; COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 272  : 	if( !r_drawentities->value )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_AddEntit

; 273  : 		return false; // not allow to drawing

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN2@R_AddEntit:

; 274  : 
; 275  : 	if( !clent || !clent->model )

	cmp	DWORD PTR _clent$[ebp], 0
	je	SHORT $LN4@R_AddEntit
	mov	eax, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN3@R_AddEntit
$LN4@R_AddEntit:

; 276  : 		return false; // if set to invisible, skip

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN3@R_AddEntit:

; 277  : 
; 278  : 	if( FBitSet( clent->curstate.effects, EF_NODRAW ))

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 128				; 00000080H
	je	SHORT $LN5@R_AddEntit

; 279  : 		return false; // done

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN5@R_AddEntit:

; 280  : 
; 281  : 	if( !R_ModelOpaque( clent->curstate.rendermode ) && CL_FxBlend( clent ) <= 0 )

	mov	eax, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN6@R_AddEntit
	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	_CL_FxBlend
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN6@R_AddEntit

; 282  : 		return true; // invisible

	mov	eax, 1
	jmp	$LN1@R_AddEntit
$LN6@R_AddEntit:

; 283  : 
; 284  : 	if( type == ET_FRAGMENTED )

	cmp	DWORD PTR _type$[ebp], 4
	jne	SHORT $LN7@R_AddEntit

; 285  : 		r_stats.c_client_ents++;

	mov	eax, DWORD PTR _r_stats+44
	add	eax, 1
	mov	DWORD PTR _r_stats+44, eax
$LN7@R_AddEntit:

; 286  : 
; 287  : 	if( R_OpaqueEntity( clent ))

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	_R_OpaqueEntity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_AddEntit

; 288  : 	{
; 289  : 		// opaque moving
; 290  : 		if (tr.draw_list->num_solid_entities >= MAX_VISIBLE_PACKET)

	mov	eax, DWORD PTR _tr+66792
	cmp	DWORD PTR [eax+24576], 2048		; 00000800H
	jb	SHORT $LN10@R_AddEntit

; 291  : 			return false;

	xor	eax, eax
	jmp	$LN1@R_AddEntit
$LN10@R_AddEntit:

; 292  : 
; 293  : 		tr.draw_list->solid_entities[tr.draw_list->num_solid_entities] = clent;

	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24576]
	mov	edx, DWORD PTR _tr+66792
	mov	eax, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 294  : 		tr.draw_list->num_solid_entities++;

	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24576]
	add	ecx, 1
	mov	edx, DWORD PTR _tr+66792
	mov	DWORD PTR [edx+24576], ecx

; 295  : 	}

	jmp	SHORT $LN9@R_AddEntit
$LN8@R_AddEntit:

; 296  : 	else
; 297  : 	{
; 298  : 		// translucent
; 299  : 		if( tr.draw_list->num_trans_entities >= MAX_VISIBLE_PACKET )

	mov	eax, DWORD PTR _tr+66792
	cmp	DWORD PTR [eax+24580], 2048		; 00000800H
	jb	SHORT $LN11@R_AddEntit

; 300  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_AddEntit
$LN11@R_AddEntit:

; 301  : 
; 302  : 		tr.draw_list->trans_entities[tr.draw_list->num_trans_entities] = clent;

	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24580]
	mov	edx, DWORD PTR _tr+66792
	mov	eax, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+ecx*4+8192], eax

; 303  : 		tr.draw_list->num_trans_entities++;

	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR [eax+24580]
	add	ecx, 1
	mov	edx, DWORD PTR _tr+66792
	mov	DWORD PTR [edx+24580], ecx
$LN9@R_AddEntit:

; 304  : 	}
; 305  : 
; 306  : 	return true;

	mov	eax, 1
$LN1@R_AddEntit:

; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_ScreenToWorld
_TEXT	SEGMENT
tv242 = -140						; size = 4
_w$ = -72						; size = 4
_screenToWorld$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_screen$ = 8						; size = 4
_point$ = 12						; size = 4
_R_ScreenToWorld PROC					; COMDAT

; 211  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 212  : 	matrix4x4	screenToWorld;
; 213  : 	float	w;
; 214  : 
; 215  : 	if( !point || !screen )

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN3@R_ScreenTo
	cmp	DWORD PTR _screen$[ebp], 0
	jne	SHORT $LN2@R_ScreenTo
$LN3@R_ScreenTo:

; 216  : 		return;

	jmp	$LN4@R_ScreenTo
$LN2@R_ScreenTo:

; 217  : 
; 218  : 	Matrix4x4_Invert_Full( screenToWorld, RI.worldviewProjectionMatrix );

	push	OFFSET _RI+712
	lea	eax, DWORD PTR _screenToWorld$[ebp]
	push	eax
	call	_Matrix4x4_Invert_Full
	add	esp, 8

; 219  : 
; 220  : 	point[0] = screen[0] * screenToWorld[0][0] + screen[1] * screenToWorld[0][1] + screen[2] * screenToWorld[0][2] + screenToWorld[0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 221  : 	point[1] = screen[0] * screenToWorld[1][0] + screen[1] * screenToWorld[1][1] + screen[2] * screenToWorld[1][2] + screenToWorld[1][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 222  : 	point[2] = screen[0] * screenToWorld[2][0] + screen[1] * screenToWorld[2][1] + screen[2] * screenToWorld[2][2] + screenToWorld[2][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	lea	edx, DWORD PTR _screenToWorld$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _point$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 223  : 	w = screen[0] * screenToWorld[3][0] + screen[1] * screenToWorld[3][1] + screen[2] * screenToWorld[3][2] + screenToWorld[3][3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	edx, DWORD PTR _screenToWorld$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _screen$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _screenToWorld$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR _w$[ebp], xmm0

; 224  : 	if( w != 0.0f ) VectorScale( point, ( 1.0f / w ), point );

	movss	xmm0, DWORD PTR _w$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@R_ScreenTo
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _point$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _point$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _point$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _point$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv242[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN4@R_ScreenTo:

; 225  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ScreenToWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_WorldToScreen
_TEXT	SEGMENT
_invw$1 = -80						; size = 4
_w$ = -76						; size = 4
_behind$ = -72						; size = 4
_worldToScreen$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_point$ = 8						; size = 4
_screen$ = 12						; size = 4
_R_WorldToScreen PROC					; COMDAT

; 172  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 173  : 	matrix4x4	worldToScreen;
; 174  : 	qboolean	behind;
; 175  : 	float	w;
; 176  : 
; 177  : 	if( !point || !screen )

	cmp	DWORD PTR _point$[ebp], 0
	je	SHORT $LN3@R_WorldToS
	cmp	DWORD PTR _screen$[ebp], 0
	jne	SHORT $LN2@R_WorldToS
$LN3@R_WorldToS:

; 178  : 		return true;

	mov	eax, 1
	jmp	$LN1@R_WorldToS
$LN2@R_WorldToS:

; 179  : 
; 180  : 	Matrix4x4_Copy( worldToScreen, RI.worldviewProjectionMatrix );

	push	64					; 00000040H
	push	OFFSET _RI+712
	lea	eax, DWORD PTR _worldToScreen$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 181  : 	screen[0] = worldToScreen[0][0] * point[0] + worldToScreen[0][1] * point[1] + worldToScreen[0][2] * point[2] + worldToScreen[0][3];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 182  : 	screen[1] = worldToScreen[1][0] * point[0] + worldToScreen[1][1] * point[1] + worldToScreen[1][2] * point[2] + worldToScreen[1][3];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 183  : 	w = worldToScreen[3][0] * point[0] + worldToScreen[3][1] * point[1] + worldToScreen[3][2] * point[2] + worldToScreen[3][3];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _worldToScreen$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _worldToScreen$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _point$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _worldToScreen$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR _w$[ebp], xmm0

; 184  : 	screen[2] = 0.0f; // just so we have something valid here

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _screen$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0

; 185  : 
; 186  : 	if( w < 0.001f )

	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm0, DWORD PTR _w$[ebp]
	jbe	SHORT $LN4@R_WorldToS

; 187  : 	{
; 188  : 		screen[0] *= 100000;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR __real@47c35000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 189  : 		screen[1] *= 100000;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@47c35000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 190  : 		behind = true;

	mov	DWORD PTR _behind$[ebp], 1

; 191  : 	}

	jmp	SHORT $LN5@R_WorldToS
$LN4@R_WorldToS:

; 192  : 	else
; 193  : 	{
; 194  : 		float invw = 1.0f / w;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _invw$1[ebp], xmm0

; 195  : 		screen[0] *= invw;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _invw$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 196  : 		screen[1] *= invw;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _invw$1[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 197  : 		behind = false;

	mov	DWORD PTR _behind$[ebp], 0
$LN5@R_WorldToS:

; 198  : 	}
; 199  : 
; 200  : 	return behind;

	mov	eax, DWORD PTR _behind$[ebp]
$LN1@R_WorldToS:

; 201  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_WorldToScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_EndFrame
_TEXT	SEGMENT
_R_EndFrame PROC					; COMDAT

; 1191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1192 : 	// flush any remaining 2D bits
; 1193 : 	R_Set2DMode( false );

	push	0
	call	_R_Set2DMode
	add	esp, 4

; 1194 : 
; 1195 : 	if( !pwglSwapBuffers( glw_state.hDC ))

	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglSwapBuffers
	test	eax, eax
	jne	SHORT $LN1@R_EndFrame

; 1196 : 		Sys_Error( "failed to swap buffers\nCheck your video driver and as possible of reinstall it" );

	push	OFFSET ??_C@_0EP@KKAKMOHG@failed?5to?5swap?5buffers?6Check?5yo@
	call	_Sys_Error
	add	esp, 4
$LN1@R_EndFrame:

; 1197 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_EndFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_RenderFrame
_TEXT	SEGMENT
tv77 = -68						; size = 4
_rvp$ = 8						; size = 4
_R_RenderFrame PROC					; COMDAT

; 1134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1135 : 	if( r_norefresh->value )

	mov	eax, DWORD PTR _r_norefresh
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@R_RenderFr

; 1136 : 		return;

	jmp	$LN1@R_RenderFr
$LN2@R_RenderFr:

; 1137 : 
; 1138 : 	// setup the initial render params
; 1139 : 	R_SetupRefParams( rvp );

	mov	eax, DWORD PTR _rvp$[ebp]
	push	eax
	call	_R_SetupRefParams
	add	esp, 4

; 1140 : 
; 1141 : 	if( gl_finish->value && RI.drawWorld )

	mov	eax, DWORD PTR _gl_finish
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@R_RenderFr
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_RenderFr

; 1142 : 		pglFinish();

	call	DWORD PTR _pglFinish
$LN3@R_RenderFr:

; 1143 : 
; 1144 : 	if( glConfig.max_multisamples > 1 && FBitSet( gl_msaa->flags, FCVAR_CHANGED ))

	cmp	DWORD PTR _glConfig+96, 1
	jle	SHORT $LN4@R_RenderFr
	mov	eax, DWORD PTR _gl_msaa
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN4@R_RenderFr

; 1145 : 	{
; 1146 : 		if( CVAR_TO_BOOL( gl_msaa ))

	cmp	DWORD PTR _gl_msaa, 0
	je	SHORT $LN12@R_RenderFr
	mov	eax, DWORD PTR _gl_msaa
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@R_RenderFr
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN13@R_RenderFr
$LN12@R_RenderFr:
	mov	DWORD PTR tv77[ebp], 0
$LN13@R_RenderFr:
	cmp	DWORD PTR tv77[ebp], 0
	je	SHORT $LN5@R_RenderFr

; 1147 : 			pglEnable( GL_MULTISAMPLE_ARB );

	push	32925					; 0000809dH
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN6@R_RenderFr
$LN5@R_RenderFr:

; 1148 : 		else pglDisable( GL_MULTISAMPLE_ARB );

	push	32925					; 0000809dH
	call	DWORD PTR _pglDisable
$LN6@R_RenderFr:

; 1149 : 		ClearBits( gl_msaa->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_msaa
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_msaa
	mov	DWORD PTR [edx+8], ecx
$LN4@R_RenderFr:

; 1150 : 	}
; 1151 : 
; 1152 : 	// completely override rendering
; 1153 : 	if( clgame.drawFuncs.GL_RenderFrame != NULL )

	cmp	DWORD PTR _clgame+180, 0
	je	SHORT $LN8@R_RenderFr

; 1154 : 	{
; 1155 : 		tr.fCustomRendering = true;

	mov	DWORD PTR _tr+83208, 1

; 1156 : 
; 1157 : 		if( clgame.drawFuncs.GL_RenderFrame( rvp ))

	mov	eax, DWORD PTR _rvp$[ebp]
	push	eax
	call	DWORD PTR _clgame+180
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_RenderFr

; 1158 : 		{
; 1159 : 			R_GatherPlayerLight();

	call	_R_GatherPlayerLight

; 1160 : 			tr.realframecount++;

	mov	eax, DWORD PTR _tr+83196
	add	eax, 1
	mov	DWORD PTR _tr+83196, eax

; 1161 : 			tr.fResetVis = true;

	mov	DWORD PTR _tr+83212, 1

; 1162 : 			return;

	jmp	SHORT $LN1@R_RenderFr
$LN8@R_RenderFr:

; 1163 : 		}
; 1164 : 	}
; 1165 : 
; 1166 : 	tr.fCustomRendering = false;

	mov	DWORD PTR _tr+83208, 0

; 1167 : 	if( !RI.onlyClientDraw )

	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN9@R_RenderFr

; 1168 : 		R_RunViewmodelEvents();

	call	_R_RunViewmodelEvents
$LN9@R_RenderFr:

; 1169 : 
; 1170 : 	// FarEast: Restore once down sampling is implemented
; 1171 : 	if (gl_allow_mirrors->value)

	mov	eax, DWORD PTR _gl_allow_mirrors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_RenderFr

; 1172 : 	{
; 1173 : 		// render mirrors
; 1174 : 		R_FindMirrors();

	call	_R_FindMirrors

; 1175 : 		R_DrawMirrors();

	call	_R_DrawMirrors
$LN10@R_RenderFr:

; 1176 : 	}
; 1177 : 
; 1178 : 	tr.realframecount++; // right called after viewmodel events

	mov	eax, DWORD PTR _tr+83196
	add	eax, 1
	mov	DWORD PTR _tr+83196, eax

; 1179 : 	R_RenderScene();

	call	_R_RenderScene

; 1180 : 
; 1181 : 	// FarEast: Downsampling implementation, thanks to Magic Nipples
; 1182 : 	R_DownSampling();

	call	_R_DownSampling
$LN1@R_RenderFr:

; 1183 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_BeginFrame
_TEXT	SEGMENT
_clearScene$ = 8					; size = 4
_R_BeginFrame PROC					; COMDAT

; 1053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1054 : 	glConfig.softwareGammaUpdate = false;	// in case of possible fails

	mov	DWORD PTR _glConfig+124, 0

; 1055 : 
; 1056 : 	if(( gl_clear->value || CL_IsDevOverviewMode( )) && clearScene && cls.state != ca_cinematic )

	mov	eax, DWORD PTR _gl_clear
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@R_BeginFra
	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@R_BeginFra
$LN3@R_BeginFra:
	cmp	DWORD PTR _clearScene$[ebp], 0
	je	SHORT $LN2@R_BeginFra
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN2@R_BeginFra

; 1057 : 	{
; 1058 : 		pglClear( GL_COLOR_BUFFER_BIT );

	push	16384					; 00004000H
	call	DWORD PTR _pglClear
$LN2@R_BeginFra:

; 1059 : 	}
; 1060 : 
; 1061 : 	if( R_DoResetGamma( ))

	call	_R_DoResetGamma
	test	eax, eax
	je	SHORT $LN4@R_BeginFra

; 1062 : 	{
; 1063 : 		BuildGammaTable( 1.8f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fe66666
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 1064 : 		glConfig.softwareGammaUpdate = true;

	mov	DWORD PTR _glConfig+124, 1

; 1065 : 		GL_RebuildLightmaps();

	call	_GL_RebuildLightmaps

; 1066 : 		glConfig.softwareGammaUpdate = false;

	mov	DWORD PTR _glConfig+124, 0

; 1067 : 
; 1068 : 		// next frame will be restored gamma
; 1069 : 		SetBits( vid_brightness->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_brightness
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _vid_brightness
	mov	DWORD PTR [edx+8], ecx

; 1070 : 		SetBits( vid_gamma->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _vid_gamma
	mov	DWORD PTR [edx+8], ecx

; 1071 : 	}

	jmp	SHORT $LN6@R_BeginFra
$LN4@R_BeginFra:

; 1072 : 	else if( FBitSet( vid_gamma->flags, FCVAR_CHANGED ) || FBitSet( vid_brightness->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN7@R_BeginFra
	mov	eax, DWORD PTR _vid_brightness
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN6@R_BeginFra
$LN7@R_BeginFra:

; 1073 : 	{
; 1074 : 		BuildGammaTable( vid_gamma->value, vid_brightness->value );

	mov	eax, DWORD PTR _vid_brightness
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vid_gamma
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 1075 : 		glConfig.softwareGammaUpdate = true;

	mov	DWORD PTR _glConfig+124, 1

; 1076 : 		GL_RebuildLightmaps();

	call	_GL_RebuildLightmaps

; 1077 : 		glConfig.softwareGammaUpdate = false;

	mov	DWORD PTR _glConfig+124, 0
$LN6@R_BeginFra:

; 1078 : 	}
; 1079 : 
; 1080 : 	R_Set2DMode( true );

	push	1
	call	_R_Set2DMode
	add	esp, 4

; 1081 : 
; 1082 : 	// draw buffer stuff
; 1083 : 	pglDrawBuffer( GL_BACK );

	push	1029					; 00000405H
	call	DWORD PTR _pglDrawBuffer

; 1084 : 
; 1085 : 	// update texture parameters
; 1086 : 	if( FBitSet( gl_texture_nearest->flags|gl_lightmap_nearest->flags|gl_texture_anisotropy->flags|gl_texture_lodbias->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _gl_texture_nearest
	mov	ecx, DWORD PTR _gl_lightmap_nearest
	mov	edx, DWORD PTR [eax+8]
	or	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _gl_texture_anisotropy
	or	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _gl_texture_lodbias
	or	edx, DWORD PTR [ecx+8]
	and	edx, 8192				; 00002000H
	je	SHORT $LN8@R_BeginFra

; 1087 : 		R_SetTextureParameters();

	call	_R_SetTextureParameters
$LN8@R_BeginFra:

; 1088 : 
; 1089 : 	// swapinterval stuff
; 1090 : 	GL_UpdateSwapInterval();

	call	_GL_UpdateSwapInterval

; 1091 : 
; 1092 : 	CL_ExtraUpdate ();

	call	_CL_ExtraUpdate

; 1093 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BeginFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_DrawFog
_TEXT	SEGMENT
_R_DrawFog PROC						; COMDAT

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 816  : 	if( !RI.fogEnabled ) return;

	cmp	DWORD PTR _RI+316, 0
	jne	SHORT $LN2@R_DrawFog
	jmp	SHORT $LN1@R_DrawFog
$LN2@R_DrawFog:

; 817  : 
; 818  : 	pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable

; 819  : 	if( CL_IsQuakeCompatible( ))

	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN3@R_DrawFog

; 820  : 		pglFogi( GL_FOG_MODE, GL_EXP2 );

	push	2049					; 00000801H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi
	jmp	SHORT $LN4@R_DrawFog
$LN3@R_DrawFog:

; 821  : 	else pglFogi( GL_FOG_MODE, GL_EXP );

	push	2048					; 00000800H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi
$LN4@R_DrawFog:

; 822  : 	pglFogf( GL_FOG_DENSITY, RI.fogDensity );

	push	ecx
	movss	xmm0, DWORD PTR _RI+340
	movss	DWORD PTR [esp], xmm0
	push	2914					; 00000b62H
	call	DWORD PTR _pglFogf

; 823  : 	pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv

; 824  : 	pglHint( GL_FOG_HINT, GL_NICEST );

	push	4354					; 00001102H
	push	3156					; 00000c54H
	call	DWORD PTR _pglHint
$LN1@R_DrawFog:

; 825  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_PopScene
_TEXT	SEGMENT
_R_PopScene PROC					; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 247  : 	if( --tr.draw_stack_pos < 0 )

	mov	eax, DWORD PTR _tr+66788
	sub	eax, 1
	mov	DWORD PTR _tr+66788, eax
	jns	SHORT $LN2@R_PopScene

; 248  : 		Host_Error( "draw stack underflow\n" );

	push	OFFSET ??_C@_0BG@IOCCNMCG@draw?5stack?5underflow?6@
	call	_Host_Error
	add	esp, 4
$LN2@R_PopScene:

; 249  : 	tr.draw_list = &tr.draw_stack[tr.draw_stack_pos];

	imul	eax, DWORD PTR _tr+66788, 24588
	add	eax, OFFSET _tr+17612
	mov	DWORD PTR _tr+66792, eax

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PopScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_PushScene
_TEXT	SEGMENT
_R_PushScene PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 234  : 	if( ++tr.draw_stack_pos >= MAX_DRAW_STACK )

	mov	eax, DWORD PTR _tr+66788
	add	eax, 1
	mov	DWORD PTR _tr+66788, eax
	cmp	DWORD PTR _tr+66788, 2
	jl	SHORT $LN2@R_PushScen

; 235  : 		Host_Error( "draw stack overflow\n" );

	push	OFFSET ??_C@_0BF@HNEHGHKE@draw?5stack?5overflow?6@
	call	_Host_Error
	add	esp, 4
$LN2@R_PushScen:

; 236  : 
; 237  : 	tr.draw_list = &tr.draw_stack[tr.draw_stack_pos];

	imul	eax, DWORD PTR _tr+66788, 24588
	add	eax, OFFSET _tr+17612
	mov	DWORD PTR _tr+66792, eax

; 238  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PushScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_FindViewLeaf
_TEXT	SEGMENT
_R_FindViewLeaf PROC					; COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 511  : 	RI.oldviewleaf = RI.viewleaf;

	mov	eax, DWORD PTR _RI+180
	mov	DWORD PTR _RI+184, eax

; 512  : 	RI.viewleaf = Mod_PointInLeaf( RI.pvsorigin, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	push	OFFSET _RI+188
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _RI+180, eax

; 513  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FindViewLeaf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupFrustum
_TEXT	SEGMENT
tv250 = -100						; size = 8
tv232 = -100						; size = 8
tv244 = -92						; size = 8
tv226 = -92						; size = 8
tv354 = -84						; size = 8
tv352 = -84						; size = 8
tv238 = -76						; size = 8
tv220 = -76						; size = 8
_ov$ = -4						; size = 4
_R_SetupFrustum PROC					; COMDAT

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 367  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+217612

; 368  : 
; 369  : 	if( RP_NORMALPASS() && ( cl.local.waterlevel >= 3 ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	$LN2@R_SetupFru
	cmp	DWORD PTR _cl+2212736, 3
	jl	$LN2@R_SetupFru

; 370  : 	{
; 371  : 		RI.fov_x = atan( tan( DEG2RAD( RI.fov_x ) / 2 ) * ( 0.97 + sin( cl.time * 1.5 ) * 0.03 )) * 2 / (M_PI / 180.0);

	movss	xmm0, DWORD PTR _RI+20
	mulss	xmm0, DWORD PTR __real@3c8efa35
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv220[ebp]
	movsd	xmm0, QWORD PTR tv220[ebp]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv352[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv226[ebp]
	movsd	xmm0, QWORD PTR tv226[ebp]
	mulsd	xmm0, QWORD PTR __real@3f9eb851eb851eb8
	addsd	xmm0, QWORD PTR __real@3fef0a3d70a3d70a
	movsd	xmm1, QWORD PTR tv352[ebp]
	mulsd	xmm1, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv232[ebp]
	movsd	xmm0, QWORD PTR tv232[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	divsd	xmm0, QWORD PTR __real@3f91df46aaaaaaab
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _RI+20, xmm0

; 372  : 		RI.fov_y = atan( tan( DEG2RAD( RI.fov_y ) / 2 ) * ( 1.03 - sin( cl.time * 1.5 ) * 0.03 )) * 2 / (M_PI / 180.0);

	movss	xmm0, DWORD PTR _RI+24
	mulss	xmm0, DWORD PTR __real@3c8efa35
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv238[ebp]
	movsd	xmm0, QWORD PTR tv238[ebp]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv354[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv244[ebp]
	movsd	xmm0, QWORD PTR tv244[ebp]
	mulsd	xmm0, QWORD PTR __real@3f9eb851eb851eb8
	movsd	xmm1, QWORD PTR __real@3ff07ae147ae147b
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv354[ebp]
	mulsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv250[ebp]
	movsd	xmm0, QWORD PTR tv250[ebp]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	divsd	xmm0, QWORD PTR __real@3f91df46aaaaaaab
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _RI+24, xmm0
$LN2@R_SetupFru:

; 373  : 	}
; 374  : 
; 375  : 	// build the transformation matrix for the given view angles
; 376  : 	AngleVectors( RI.viewangles, RI.vforward, RI.vright, RI.vup );

	push	OFFSET _RI+248
	push	OFFSET _RI+236
	push	OFFSET _RI+224
	push	OFFSET _RI+212
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 377  : 
; 378  : 	if( !r_lockfrustum->value )

	mov	eax, DWORD PTR _r_lockfrustum
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN3@R_SetupFru

; 379  : 	{
; 380  : 		VectorCopy( RI.vieworg, RI.cullorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR _RI[eax+260], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR _RI[eax+260], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR _RI[eax+260], ecx

; 381  : 		VectorCopy( RI.vforward, RI.cull_vforward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+224]
	mov	DWORD PTR _RI[eax+272], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+224]
	mov	DWORD PTR _RI[eax+272], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+224]
	mov	DWORD PTR _RI[eax+272], ecx

; 382  : 		VectorCopy( RI.vright, RI.cull_vright );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+236]
	mov	DWORD PTR _RI[eax+284], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _RI[eax+284], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR _RI[eax+284], ecx

; 383  : 		VectorCopy( RI.vup, RI.cull_vup );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+248]
	mov	DWORD PTR _RI[eax+296], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+248]
	mov	DWORD PTR _RI[eax+296], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+248]
	mov	DWORD PTR _RI[eax+296], ecx
$LN3@R_SetupFru:

; 384  : 	}
; 385  : 
; 386  : 	if( RI.drawOrtho )

	cmp	DWORD PTR _RI+16, 0
	je	SHORT $LN4@R_SetupFru

; 387  : 		GL_FrustumInitOrtho( &RI.frustum, ov->xLeft, ov->xRight, ov->yTop, ov->yBottom, ov->zNear, ov->zFar );

	mov	eax, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+36]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ov$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+56
	call	_GL_FrustumInitOrtho
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN5@R_SetupFru
$LN4@R_SetupFru:

; 388  : 	else GL_FrustumInitProj( &RI.frustum, 0.0f, R_GetFarClip(), RI.fov_x, RI.fov_y ); // NOTE: we ignore nearplane here (mirrors only)

	push	ecx
	movss	xmm0, DWORD PTR _RI+24
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _RI+20
	movss	DWORD PTR [esp], xmm0
	call	_R_GetFarClip
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+56
	call	_GL_FrustumInitProj
	add	esp, 20					; 00000014H
$LN5@R_SetupFru:

; 389  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupFrustum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_AllowFog
_TEXT	SEGMENT
_allowed$ = 8						; size = 4
_R_AllowFog PROC					; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 46   : 	static int	isFogEnabled;
; 47   : 
; 48   : 	if( allowed )

	cmp	DWORD PTR _allowed$[ebp], 0
	je	SHORT $LN2@R_AllowFog

; 49   : 	{
; 50   : 		if( isFogEnabled )

	cmp	DWORD PTR ?isFogEnabled@?1??R_AllowFog@@9@9, 0
	je	SHORT $LN4@R_AllowFog

; 51   : 			pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable
$LN4@R_AllowFog:

; 52   : 	}

	jmp	SHORT $LN1@R_AllowFog
$LN2@R_AllowFog:

; 53   : 	else
; 54   : 	{
; 55   : 		isFogEnabled = pglIsEnabled( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglIsEnabled
	movzx	eax, al
	mov	DWORD PTR ?isFogEnabled@?1??R_AllowFog@@9@9, eax

; 56   : 
; 57   : 		if( isFogEnabled )

	cmp	DWORD PTR ?isFogEnabled@?1??R_AllowFog@@9@9, 0
	je	SHORT $LN1@R_AllowFog

; 58   : 			pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN1@R_AllowFog:

; 59   : 	}
; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AllowFog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_InitRenderAPI
_TEXT	SEGMENT
_R_InitRenderAPI PROC					; COMDAT

; 1586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1587 : 	// make sure what render functions is cleared
; 1588 : 	memset( &clgame.drawFuncs, 0, sizeof( clgame.drawFuncs ));

	push	48					; 00000030H
	push	0
	push	OFFSET _clgame+176
	call	_memset
	add	esp, 12					; 0000000cH

; 1589 : 
; 1590 : 	if( clgame.dllFuncs.pfnGetRenderInterface )

	cmp	DWORD PTR _clgame+168, 0
	je	SHORT $LN2@R_InitRend

; 1591 : 	{
; 1592 : 		if( clgame.dllFuncs.pfnGetRenderInterface( CL_RENDER_INTERFACE_VERSION, &gRenderAPI, &clgame.drawFuncs ))

	push	OFFSET _clgame+176
	push	OFFSET _gRenderAPI
	push	37					; 00000025H
	call	DWORD PTR _clgame+168
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@R_InitRend

; 1593 : 		{
; 1594 : 			Con_Reportf( "CL_LoadProgs: ^2initailized extended RenderAPI ^7ver. %i\n", CL_RENDER_INTERFACE_VERSION );

	push	37					; 00000025H
	push	OFFSET ??_C@_0DK@LPDJHGLP@CL_LoadProgs?3?5?$FO2initailized?5ext@
	call	_Con_Reportf
	add	esp, 8

; 1595 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_InitRend
$LN3@R_InitRend:

; 1596 : 		}
; 1597 : 
; 1598 : 		// make sure what render functions is cleared
; 1599 : 		memset( &clgame.drawFuncs, 0, sizeof( clgame.drawFuncs ));

	push	48					; 00000030H
	push	0
	push	OFFSET _clgame+176
	call	_memset
	add	esp, 12					; 0000000cH

; 1600 : 
; 1601 : 		return false; // just tell user about problems

	xor	eax, eax
	jmp	SHORT $LN1@R_InitRend
$LN2@R_InitRend:

; 1602 : 	}
; 1603 : 
; 1604 : 	// render interface is missed
; 1605 : 	return true;

	mov	eax, 1
$LN1@R_InitRend:

; 1606 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_InitRenderAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupGL
_TEXT	SEGMENT
_p$1 = -56						; size = 4
_clip$2 = -52						; size = 32
_y2$3 = -20						; size = 4
_y$4 = -16						; size = 4
_x2$5 = -12						; size = 4
_x$6 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_set_gl_state$ = 8					; size = 4
_R_SetupGL PROC						; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 546  : 	R_SetupModelviewMatrix( RI.worldviewMatrix );

	push	OFFSET _RI+520
	call	_R_SetupModelviewMatrix
	add	esp, 4

; 547  : 	R_SetupProjectionMatrix( RI.projectionMatrix );

	push	OFFSET _RI+648
	call	_R_SetupProjectionMatrix
	add	esp, 4

; 548  : 
; 549  : 	Matrix4x4_Concat( RI.worldviewProjectionMatrix, RI.projectionMatrix, RI.worldviewMatrix );

	push	OFFSET _RI+520
	push	OFFSET _RI+648
	push	OFFSET _RI+712
	call	_Matrix4x4_Concat
	add	esp, 12					; 0000000cH

; 550  : 
; 551  : 	if( !set_gl_state ) return;

	cmp	DWORD PTR _set_gl_state$[ebp], 0
	jne	SHORT $LN2@R_SetupGL
	jmp	$LN1@R_SetupGL
$LN2@R_SetupGL:

; 552  : 
; 553  : 	if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	$LN3@R_SetupGL

; 554  : 	{
; 555  : 		int	x, x2, y, y2;
; 556  : 
; 557  : 		// set up viewport (main, playersetup)
; 558  : 		x = floor( RI.viewport[0] * glState.width / glState.width );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _RI[ecx+40]
	imul	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _glState
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _x$6[ebp], eax

; 559  : 		x2 = ceil(( RI.viewport[0] + RI.viewport[2] ) * glState.width / glState.width );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[ecx+40]
	add	eax, DWORD PTR _RI[edx+40]
	imul	eax, DWORD PTR _glState
	cdq
	idiv	DWORD PTR _glState
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _x2$5[ebp], eax

; 560  : 		y = floor( glState.height - RI.viewport[1] * glState.height / glState.height );

	mov	eax, 4
	shl	eax, 0
	mov	eax, DWORD PTR _RI[eax+40]
	imul	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _glState+4
	mov	ecx, DWORD PTR _glState+4
	sub	ecx, eax
	cvtsi2sd xmm0, ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _y$4[ebp], eax

; 561  : 		y2 = ceil( glState.height - ( RI.viewport[1] + RI.viewport[3] ) * glState.height / glState.height );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _RI[eax+40]
	add	eax, DWORD PTR _RI[edx+40]
	imul	eax, DWORD PTR _glState+4
	cdq
	idiv	DWORD PTR _glState+4
	mov	ecx, DWORD PTR _glState+4
	sub	ecx, eax
	cvtsi2sd xmm0, ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _y2$3[ebp], eax

; 562  : 
; 563  : 		pglViewport( x, y2, x2 - x, y - y2 );

	mov	eax, DWORD PTR _y$4[ebp]
	sub	eax, DWORD PTR _y2$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _x2$5[ebp]
	sub	ecx, DWORD PTR _x$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _y2$3[ebp]
	push	edx
	mov	eax, DWORD PTR _x$6[ebp]
	push	eax
	call	DWORD PTR _pglViewport

; 564  : 	}

	jmp	SHORT $LN4@R_SetupGL
$LN3@R_SetupGL:

; 565  : 	else
; 566  : 	{
; 567  : 		// envpass, mirrorpass
; 568  : 		pglViewport( RI.viewport[0], RI.viewport[1], RI.viewport[2], RI.viewport[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _RI[ecx+40]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[eax+40]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _RI[edx+40]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _RI[edx+40]
	push	eax
	call	DWORD PTR _pglViewport
$LN4@R_SetupGL:

; 569  : 	}
; 570  : 
; 571  : 	pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR _pglMatrixMode

; 572  : 	GL_LoadMatrix( RI.projectionMatrix );

	push	OFFSET _RI+648
	call	_GL_LoadMatrix
	add	esp, 4

; 573  : 
; 574  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 575  : 	GL_LoadMatrix( RI.worldviewMatrix );

	push	OFFSET _RI+520
	call	_GL_LoadMatrix
	add	esp, 4

; 576  : 
; 577  : 	if( FBitSet( RI.params, RP_CLIPPLANE ))

	mov	eax, DWORD PTR _RI
	and	eax, 8
	je	$LN5@R_SetupGL

; 578  : 	{
; 579  : 		GLdouble	clip[4];
; 580  : 		mplane_t	*p = &RI.clipPlane;

	mov	DWORD PTR _p$1[ebp], OFFSET _RI+4876

; 581  : 
; 582  : 		clip[0] = p->normal[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 8
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx]
	movsd	QWORD PTR _clip$2[ebp+eax], xmm0

; 583  : 		clip[1] = p->normal[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	movsd	QWORD PTR _clip$2[ebp+ecx], xmm0

; 584  : 		clip[2] = p->normal[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+eax]
	movsd	QWORD PTR _clip$2[ebp+ecx], xmm0

; 585  : 		clip[3] = -p->dist;

	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 8
	imul	edx, ecx, 3
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _clip$2[ebp+edx], xmm0

; 586  : 
; 587  : 		pglClipPlane( GL_CLIP_PLANE0, clip );

	lea	eax, DWORD PTR _clip$2[ebp]
	push	eax
	push	12288					; 00003000H
	call	DWORD PTR _pglClipPlane

; 588  : 		pglEnable( GL_CLIP_PLANE0 );

	push	12288					; 00003000H
	call	DWORD PTR _pglEnable
$LN5@R_SetupGL:

; 589  : 	}
; 590  : 
; 591  : 	GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4

; 592  : 
; 593  : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 594  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 595  : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN1@R_SetupGL:

; 596  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_RotateForEntity
_TEXT	SEGMENT
_scale$ = -4						; size = 4
_e$ = 8							; size = 4
_R_RotateForEntity PROC					; COMDAT

; 458  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 459  : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 460  : 
; 461  : 	if( e == clgame.entities )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _clgame+996
	jne	SHORT $LN2@R_RotateFo

; 462  : 	{
; 463  : 		R_LoadIdentity();

	call	_R_LoadIdentity

; 464  : 		return;

	jmp	$LN1@R_RotateFo
$LN2@R_RotateFo:

; 465  : 	}
; 466  : 
; 467  : 	if( e->model->type != mod_brush && e->curstate.scale > 0.0f )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN3@R_RotateFo
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_RotateFo

; 468  : 		scale = e->curstate.scale;

	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@R_RotateFo:

; 469  : 
; 470  : 	Matrix4x4_CreateFromEntity( RI.objectMatrix, e->angles, e->origin, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 471  : 	Matrix4x4_ConcatTransforms( RI.modelviewMatrix, RI.worldviewMatrix, RI.objectMatrix );

	push	OFFSET _RI+456
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 472  : 
; 473  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 474  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 475  : 	tr.modelviewIdentity = false;

	mov	DWORD PTR _tr+83184, 0
$LN1@R_RotateFo:

; 476  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RotateForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_TranslateForEntity
_TEXT	SEGMENT
_scale$ = -4						; size = 4
_e$ = 8							; size = 4
_R_TranslateForEntity PROC				; COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 485  : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 486  : 
; 487  : 	if( e == clgame.entities )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _clgame+996
	jne	SHORT $LN2@R_Translat

; 488  : 	{
; 489  : 		R_LoadIdentity();

	call	_R_LoadIdentity

; 490  : 		return;

	jmp	$LN1@R_Translat
$LN2@R_Translat:

; 491  : 	}
; 492  : 
; 493  : 	if( e->model->type != mod_brush && e->curstate.scale > 0.0f )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN3@R_Translat
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_Translat

; 494  : 		scale = e->curstate.scale;

	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+976]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@R_Translat:

; 495  : 
; 496  : 	Matrix4x4_CreateFromEntity( RI.objectMatrix, vec3_origin, e->origin, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 497  : 	Matrix4x4_ConcatTransforms( RI.modelviewMatrix, RI.worldviewMatrix, RI.objectMatrix );

	push	OFFSET _RI+456
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 498  : 
; 499  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 500  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 501  : 	tr.modelviewIdentity = false;

	mov	DWORD PTR _tr+83184, 0
$LN1@R_Translat:

; 502  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TranslateForEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_SetupRefParams
_TEXT	SEGMENT
_rvp$ = 8						; size = 4
_R_SetupRefParams PROC					; COMDAT

; 1103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1104 : 	RI.params = RP_NONE;

	mov	DWORD PTR _RI, 0

; 1105 : 	RI.drawWorld = FBitSet( rvp->flags, RF_DRAW_WORLD );

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 1
	mov	DWORD PTR _RI+4, ecx

; 1106 : 	RI.onlyClientDraw = FBitSet( rvp->flags, RF_ONLY_CLIENTDRAW );

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 8
	mov	DWORD PTR _RI+12, ecx

; 1107 : 	RI.farClip = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+308, xmm0

; 1108 : 
; 1109 : 	if( !FBitSet( rvp->flags, RF_DRAW_CUBEMAP ))

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 2
	jne	SHORT $LN2@R_SetupRef

; 1110 : 		RI.drawOrtho = FBitSet( rvp->flags, RF_DRAW_OVERVIEW );

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 4
	mov	DWORD PTR _RI+16, ecx
	jmp	SHORT $LN3@R_SetupRef
$LN2@R_SetupRef:

; 1111 : 	else RI.drawOrtho = false;

	mov	DWORD PTR _RI+16, 0
$LN3@R_SetupRef:

; 1112 : 
; 1113 : 	// setup viewport
; 1114 : 	RI.viewport[0] = rvp->viewport[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _RI[eax+40], ecx

; 1115 : 	RI.viewport[1] = rvp->viewport[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _RI[ecx+40], eax

; 1116 : 	RI.viewport[2] = rvp->viewport[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _RI[ecx+40], eax

; 1117 : 	RI.viewport[3] = rvp->viewport[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _RI[eax+40], ecx

; 1118 : 
; 1119 : 	// calc FOV
; 1120 : 	RI.fov_x = rvp->fov_x;

	mov	eax, DWORD PTR _rvp$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	movss	DWORD PTR _RI+20, xmm0

; 1121 : 	RI.fov_y = rvp->fov_y;

	mov	eax, DWORD PTR _rvp$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	movss	DWORD PTR _RI+24, xmm0

; 1122 : 
; 1123 : 	VectorCopy( rvp->vieworigin, RI.vieworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _RI[eax+200], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _RI[eax+200], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _RI[ecx+200], eax

; 1124 : 	VectorCopy( rvp->viewangles, RI.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+28]
	mov	DWORD PTR _RI[eax+212], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR _RI[eax+212], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR _RI[ecx+212], eax

; 1125 : 	VectorCopy( rvp->vieworigin, RI.pvsorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _RI[eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _RI[eax+188], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _RI[ecx+188], eax

; 1126 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupRefParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_DrawCubemapView
_TEXT	SEGMENT
_rvp$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_size$ = 16						; size = 4
_R_DrawCubemapView PROC					; COMDAT

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1206 : 	ref_viewpass_t rvp;
; 1207 : 
; 1208 : 	// basic params
; 1209 : 	rvp.flags = rvp.viewentity = 0;

	mov	DWORD PTR _rvp$[ebp+40], 0
	mov	eax, DWORD PTR _rvp$[ebp+40]
	mov	DWORD PTR _rvp$[ebp+52], eax

; 1210 : 	SetBits( rvp.flags, RF_DRAW_WORLD );

	mov	eax, DWORD PTR _rvp$[ebp+52]
	or	eax, 1
	mov	DWORD PTR _rvp$[ebp+52], eax

; 1211 : 	SetBits( rvp.flags, RF_DRAW_CUBEMAP );

	mov	eax, DWORD PTR _rvp$[ebp+52]
	or	eax, 2
	mov	DWORD PTR _rvp$[ebp+52], eax

; 1212 : 
; 1213 : 	rvp.viewport[0] = rvp.viewport[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR _rvp$[ebp+eax], 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _rvp$[ebp+edx], 0

; 1214 : 	rvp.viewport[2] = rvp.viewport[3] = size;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _rvp$[ebp+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _rvp$[ebp+eax], ecx

; 1215 : 	rvp.fov_x = rvp.fov_y = 90.0f; // this is a final fov value

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _rvp$[ebp+48], xmm0
	movss	xmm0, DWORD PTR _rvp$[ebp+48]
	movss	DWORD PTR _rvp$[ebp+44], xmm0

; 1216 : 
; 1217 : 	// setup origin & angles
; 1218 : 	VectorCopy( origin, rvp.vieworigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _rvp$[ebp+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _rvp$[ebp+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _rvp$[ebp+ecx+16], eax

; 1219 : 	VectorCopy( angles, rvp.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _rvp$[ebp+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _rvp$[ebp+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _rvp$[ebp+ecx+28], eax

; 1220 : 
; 1221 : 	R_RenderFrame( &rvp );

	lea	eax, DWORD PTR _rvp$[ebp]
	push	eax
	call	_R_RenderFrame
	add	esp, 4

; 1222 : 
; 1223 : 	RI.viewleaf = NULL;		// force markleafs next frame

	mov	DWORD PTR _RI+180, 0

; 1224 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawCubemapView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_RenderScene
_TEXT	SEGMENT
_R_RenderScene PROC					; COMDAT

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 976  : 	if( !cl.worldmodel && RI.drawWorld )

	cmp	DWORD PTR _cl+4579004, 0
	jne	SHORT $LN2@R_RenderSc
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_RenderSc

; 977  : 		Host_Error( "R_RenderView: NULL worldmodel\n" );

	push	OFFSET ??_C@_0BP@KBAHKDFL@R_RenderView?3?5NULL?5worldmodel?6@
	call	_Host_Error
	add	esp, 4
$LN2@R_RenderSc:

; 978  : 
; 979  : 	// frametime is valid only for normal pass
; 980  : 	if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN3@R_RenderSc

; 981  : 		tr.frametime = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	movsd	QWORD PTR _tr+87584, xmm0
	jmp	SHORT $LN4@R_RenderSc
$LN3@R_RenderSc:

; 982  : 	else tr.frametime = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _tr+87584, xmm0
$LN4@R_RenderSc:

; 983  : 
; 984  : 	// begin a new frame
; 985  : 	tr.framecount++;

	mov	eax, DWORD PTR _tr+83200
	add	eax, 1
	mov	DWORD PTR _tr+83200, eax

; 986  : 
; 987  : 	R_PushDlights();

	call	_R_PushDlights

; 988  : 
; 989  : 	R_SetupFrustum();

	call	_R_SetupFrustum

; 990  : 	R_SetupFrame();

	call	_R_SetupFrame

; 991  : 	R_SetupGL( true );

	push	1
	call	_R_SetupGL
	add	esp, 4

; 992  : 	R_Clear( ~0 );

	push	-1
	call	_R_Clear
	add	esp, 4

; 993  : 
; 994  : 	R_MarkLeaves();

	call	_R_MarkLeaves

; 995  : 	R_DrawFog ();

	call	_R_DrawFog

; 996  : 
; 997  : 	R_CheckGLFog();	

	call	_R_CheckGLFog

; 998  : 	R_DrawWorld();

	call	_R_DrawWorld

; 999  : 	R_CheckFog();

	call	_R_CheckFog

; 1000 : 
; 1001 : 	CL_ExtraUpdate ();	// don't let sound get messed up if going slow

	call	_CL_ExtraUpdate

; 1002 : 
; 1003 : 	R_DrawEntitiesOnList();

	call	_R_DrawEntitiesOnList

; 1004 : 
; 1005 : 	R_DrawWaterSurfaces();

	call	_R_DrawWaterSurfaces

; 1006 : 
; 1007 : 	// FarEast: Downsampling implementation, thanks to Magic Nipples
; 1008 : 	R_InitDownSampleTextures();

	call	_R_InitDownSampleTextures

; 1009 : 
; 1010 : 	R_EndGL();

	call	_R_EndGL

; 1011 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_LoadIdentity
_TEXT	SEGMENT
_R_LoadIdentity PROC					; COMDAT

; 441  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 442  : 	if( tr.modelviewIdentity ) return;

	cmp	DWORD PTR _tr+83184, 0
	je	SHORT $LN2@R_LoadIden
	jmp	SHORT $LN1@R_LoadIden
$LN2@R_LoadIden:

; 443  : 
; 444  : 	Matrix4x4_LoadIdentity( RI.objectMatrix );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	push	OFFSET _RI+456
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 	Matrix4x4_Copy( RI.modelviewMatrix, RI.worldviewMatrix );

	push	64					; 00000040H
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_memcpy
	add	esp, 12					; 0000000cH

; 446  : 
; 447  : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 448  : 	GL_LoadMatrix( RI.modelviewMatrix );

	push	OFFSET _RI+584
	call	_GL_LoadMatrix
	add	esp, 4

; 449  : 	tr.modelviewIdentity = true;

	mov	DWORD PTR _tr+83184, 1
$LN1@R_LoadIden:

; 450  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LoadIdentity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _R_ClearScene
_TEXT	SEGMENT
_R_ClearScene PROC					; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 259  : 	tr.draw_list->num_solid_entities = 0;

	mov	eax, DWORD PTR _tr+66792
	mov	DWORD PTR [eax+24576], 0

; 260  : 	tr.draw_list->num_trans_entities = 0;

	mov	eax, DWORD PTR _tr+66792
	mov	DWORD PTR [eax+24580], 0

; 261  : 	tr.draw_list->num_beam_entities = 0;

	mov	eax, DWORD PTR _tr+66792
	mov	DWORD PTR [eax+24584], 0

; 262  : 	tr.num_mirror_entities = 0;

	mov	DWORD PTR _tr+17608, 0

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ClearScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_rmain.c
;	COMDAT _GL_TextureData
_TEXT	SEGMENT
_pic$ = -4						; size = 4
_texnum$ = 8						; size = 4
_GL_TextureData PROC					; COMDAT

; 1436 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1437 : 	rgbdata_t *pic = R_GetTexture( texnum )->original;

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR _pic$[ebp], ecx

; 1438 : 
; 1439 : 	if( pic != NULL )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN2@GL_Texture

; 1440 : 		return pic->buffer;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [eax+24]
	jmp	SHORT $LN1@GL_Texture
$LN2@GL_Texture:

; 1441 : 	return NULL;	

	xor	eax, eax
$LN1@GL_Texture:

; 1442 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureData ENDP
_TEXT	ENDS
END
