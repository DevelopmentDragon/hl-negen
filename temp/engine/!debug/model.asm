; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\model.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_com_studiocache:DWORD
COMM	_loadmodel:DWORD
COMM	_mod_studiocache:DWORD
COMM	_r_wadtextures:DWORD
COMM	_r_showhull:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_Mod_Init
PUBLIC	_Mod_FreeAll
PUBLIC	_Mod_Shutdown
PUBLIC	_Mod_ClearUserData
PUBLIC	_Mod_LoadWorld
PUBLIC	_Mod_Calloc
PUBLIC	_Mod_CacheCheck
PUBLIC	_Mod_LoadCacheFile
PUBLIC	_Mod_AliasExtradata
PUBLIC	_Mod_StudioExtradata
PUBLIC	_Mod_FindName
PUBLIC	_Mod_LoadModel
PUBLIC	_Mod_ForName
PUBLIC	_Mod_ValidateCRC
PUBLIC	_Mod_NeedCRC
PUBLIC	_Mod_FreeUnused
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0CF@MLCIJBNO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BB@IMJBIBMH@?$CFi?5total?5models?6@	; `string'
PUBLIC	?__LINE__Var@?0??Mod_Init@@9@9			; `Mod_Init'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0N@FIALMFCO@Studio?5Cache@		; `string'
PUBLIC	??_C@_0DC@FPKHEELJ@enables?5studio?5cache?5for?5speedu@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0O@OIMKAGJH@r_studiocache@		; `string'
PUBLIC	??_C@_0DG@FGCMJCLN@completely?5ignore?5textures?5in?5t@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0O@NCEBFPNG@r_wadtextures@		; `string'
PUBLIC	??_C@_0BJ@GEGKKLMK@draw?5collision?5hulls?51?93@ ; `string'
PUBLIC	??_C@_0L@KGPGEHEC@r_showhull@			; `string'
PUBLIC	??_C@_0CE@CMPIDHBD@show?5stats?5for?5currently?5loaded@ ; `string'
PUBLIC	??_C@_08BBGHLOBD@mapstats@			; `string'
PUBLIC	??_C@_0BL@ENDKIMCI@display?5loaded?5models?5list@ ; `string'
PUBLIC	??_C@_09EOKHBMCA@modellist@			; `string'
PUBLIC	?__LINE__Var@?0??Mod_Shutdown@@9@9		; `Mod_Shutdown'::`1'::__LINE__Var
PUBLIC	??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadModel@@9@9		; `Mod_LoadModel'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_0BC@HOCLFBPM@?$CFs?5couldn?8t?5load?6@	; `string'
PUBLIC	??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@ ; `string'
PUBLIC	??_C@_0M@KOFNDIEA@loading?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BH@MJMCMJBO@?$CFs?5has?5unknown?5format?6@ ; `string'
PUBLIC	??_C@_0CC@ILDBDGFM@?$FO1Error?3?$FO7?5?$CFs?5has?5unknown?5forma@ ; `string'
PUBLIC	??_C@_0BH@JLHDPLGM@?$CFs?5has?5a?5bad?5checksum?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_PurgeStudioCache@@9@9	; `Mod_PurgeStudioCache'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadWorld@@9@9		; `Mod_LoadWorld'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_Calloc@@9@9		; `Mod_Calloc'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Mod_LoadCacheFile@@9@9		; `Mod_LoadCacheFile'::`1'::__LINE__Var
PUBLIC	??_C@_0L@KEHLMCM@cu?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0CC@GEIPCMCJ@LoadCacheFile?3?5?$FO1can?8t?5load?5?$CFs?$FO@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_EmptyPool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Cache_Check:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_Mod_LoadBrushModel:PROC
EXTRN	_Mod_UnloadBrushModel:PROC
EXTRN	_Mod_PrintWorldStats_f:PROC
EXTRN	_Mod_ReleaseHullPolygons:PROC
EXTRN	_Mod_InitStudioHull:PROC
EXTRN	_Mod_ResetStudioAPI:PROC
EXTRN	_Mod_ClearStudioCache:PROC
EXTRN	_Mod_LoadSpriteModel:PROC
EXTRN	_Mod_LoadStudioModel:PROC
EXTRN	_Mod_LoadAliasModel:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_Mod_UnloadStudioModel:PROC
EXTRN	_Mod_UnloadAliasModel:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_world:BYTE
EXTRN	_clgame:BYTE
EXTRN	_svgame:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_mod_crcinfo DQ	0404H DUP (?)
_mod_known DB	062020H DUP (?)
_mod_numknown DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CC@GEIPCMCJ@LoadCacheFile?3?5?$FO1can?8t?5load?5?$CFs?$FO@
CONST	SEGMENT
??_C@_0CC@GEIPCMCJ@LoadCacheFile?3?5?$FO1can?8t?5load?5?$CFs?$FO@ DB 'Loa'
	DB	'dCacheFile: ^1can''t load %s^7', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEHLMCM@cu?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@KEHLMCM@cu?5?$CB?$DN?5NULL@ DB 'cu != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadCacheFile@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadCacheFile@@9@9 DD 020aH	; `Mod_LoadCacheFile'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_Calloc@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_Calloc@@9@9 DD 01eeH		; `Mod_Calloc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadWorld@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadWorld@@9@9 DD 01b7H		; `Mod_LoadWorld'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_PurgeStudioCache@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_PurgeStudioCache@@9@9 DD 0196H	; `Mod_PurgeStudioCache'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@JLHDPLGM@?$CFs?5has?5a?5bad?5checksum?6@
CONST	SEGMENT
??_C@_0BH@JLHDPLGM@?$CFs?5has?5a?5bad?5checksum?6@ DB '%s has a bad check'
	DB	'sum', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ILDBDGFM@?$FO1Error?3?$FO7?5?$CFs?5has?5unknown?5forma@
CONST	SEGMENT
??_C@_0CC@ILDBDGFM@?$FO1Error?3?$FO7?5?$CFs?5has?5unknown?5forma@ DB '^1E'
	DB	'rror:^7 %s has unknown format', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJMCMJBO@?$CFs?5has?5unknown?5format?6@
CONST	SEGMENT
??_C@_0BH@MJMCMJBO@?$CFs?5has?5unknown?5format?6@ DB '%s has unknown form'
	DB	'at', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOFNDIEA@loading?5?$CFs?6@
CONST	SEGMENT
??_C@_0M@KOFNDIEA@loading?5?$CFs?6@ DB 'loading %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@
CONST	SEGMENT
??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@ DB '^1Err'
	DB	'or:^7 %s couldn''t load', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HOCLFBPM@?$CFs?5couldn?8t?5load?6@
CONST	SEGMENT
??_C@_0BC@HOCLFBPM@?$CFs?5couldn?8t?5load?6@ DB '%s couldn''t load', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadModel@@9@9 DD 0101H		; `Mod_LoadModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@ DB 'MAX_'
	DB	'MODELS limit exceeded (%d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_Shutdown@@9@9 DD 0bcH		; `Mod_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09EOKHBMCA@modellist@
CONST	SEGMENT
??_C@_09EOKHBMCA@modellist@ DB 'modellist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ENDKIMCI@display?5loaded?5models?5list@
CONST	SEGMENT
??_C@_0BL@ENDKIMCI@display?5loaded?5models?5list@ DB 'display loaded mode'
	DB	'ls list', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08BBGHLOBD@mapstats@
CONST	SEGMENT
??_C@_08BBGHLOBD@mapstats@ DB 'mapstats', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CMPIDHBD@show?5stats?5for?5currently?5loaded@
CONST	SEGMENT
??_C@_0CE@CMPIDHBD@show?5stats?5for?5currently?5loaded@ DB 'show stats fo'
	DB	'r currently loaded map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KGPGEHEC@r_showhull@
CONST	SEGMENT
??_C@_0L@KGPGEHEC@r_showhull@ DB 'r_showhull', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GEGKKLMK@draw?5collision?5hulls?51?93@
CONST	SEGMENT
??_C@_0BJ@GEGKKLMK@draw?5collision?5hulls?51?93@ DB 'draw collision hulls'
	DB	' 1-3', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NCEBFPNG@r_wadtextures@
CONST	SEGMENT
??_C@_0O@NCEBFPNG@r_wadtextures@ DB 'r_wadtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FGCMJCLN@completely?5ignore?5textures?5in?5t@
CONST	SEGMENT
??_C@_0DG@FGCMJCLN@completely?5ignore?5textures?5in?5t@ DB 'completely ig'
	DB	'nore textures in the bsp-file if enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OIMKAGJH@r_studiocache@
CONST	SEGMENT
??_C@_0O@OIMKAGJH@r_studiocache@ DB 'r_studiocache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FPKHEELJ@enables?5studio?5cache?5for?5speedu@
CONST	SEGMENT
??_C@_0DC@FPKHEELJ@enables?5studio?5cache?5for?5speedu@ DB 'enables studi'
	DB	'o cache for speedup tracing hitboxes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIALMFCO@Studio?5Cache@
CONST	SEGMENT
??_C@_0N@FIALMFCO@Studio?5Cache@ DB 'Studio Cache', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\model.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_Init@@9@9 DD 08dH			; `Mod_Init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@IMJBIBMH@?$CFi?5total?5models?6@
CONST	SEGMENT
??_C@_0BB@IMJBIBMH@?$CFi?5total?5models?6@ DB '%i total models', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLCIJBNO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0CF@MLCIJBNO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'----------------------------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03b8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	017fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0116H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_PurgeStudioCache
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Mod_PurgeStudioCache PROC				; COMDAT

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 407  : 	int	i;
; 408  : 
; 409  : 	// refresh hull data
; 410  : 	SetBits( r_showhull->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _r_showhull
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _r_showhull
	mov	DWORD PTR [edx+8], ecx

; 411  : 	Mod_ReleaseHullPolygons();

	call	_Mod_ReleaseHullPolygons

; 412  : 
; 413  : 	// release previois map
; 414  : 	Mod_FreeModel( mod_known );	// world is stuck on slot #0 always

	push	OFFSET _mod_known
	call	_Mod_FreeModel
	add	esp, 4

; 415  : 
; 416  : 	// we should release all the world submodels
; 417  : 	// and clear studio sequences
; 418  : 	for( i = 1; i < mod_numknown; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Mod_PurgeS
$LN2@Mod_PurgeS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_PurgeS:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN3@Mod_PurgeS

; 419  : 	{
; 420  : 		if( mod_known[i].type == mod_studio )

	imul	eax, DWORD PTR _i$[ebp], 392
	cmp	DWORD PTR _mod_known[eax+68], 3
	jne	SHORT $LN5@Mod_PurgeS

; 421  : 			mod_known[i].submodels = NULL;

	imul	eax, DWORD PTR _i$[ebp], 392
	mov	DWORD PTR _mod_known[eax+124], 0
$LN5@Mod_PurgeS:

; 422  : 		if( mod_known[i].name[0] == '*' )

	imul	eax, DWORD PTR _i$[ebp], 392
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _mod_known[eax+edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN6@Mod_PurgeS

; 423  : 			Mod_FreeModel( &mod_known[i] );

	imul	eax, DWORD PTR _i$[ebp], 392
	add	eax, OFFSET _mod_known
	push	eax
	call	_Mod_FreeModel
	add	esp, 4
$LN6@Mod_PurgeS:

; 424  : 		mod_known[i].needload = NL_UNREFERENCED;

	imul	eax, DWORD PTR _i$[ebp], 392
	mov	DWORD PTR _mod_known[eax+64], 0

; 425  : 	}

	jmp	SHORT $LN2@Mod_PurgeS
$LN3@Mod_PurgeS:

; 426  : 
; 427  : 	Mem_EmptyPool( com_studiocache );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_PurgeStudioCache@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _com_studiocache
	push	ecx
	call	__Mem_EmptyPool
	add	esp, 12					; 0000000cH

; 428  : 	Mod_ClearStudioCache();

	call	_Mod_ClearStudioCache

; 429  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_PurgeStudioCache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_FreeModel
_TEXT	SEGMENT
tv77 = -68						; size = 4
_mod$ = 8						; size = 4
_Mod_FreeModel PROC					; COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 106  : 	// already freed?
; 107  : 	if( !mod || !mod->name[0] )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN5@Mod_FreeMo
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@Mod_FreeMo
$LN5@Mod_FreeMo:

; 108  : 		return;

	jmp	$LN1@Mod_FreeMo
$LN4@Mod_FreeMo:

; 109  : 
; 110  : 	if( mod->name[0] != '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN6@Mod_FreeMo

; 111  : 		Mod_FreeUserData( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_FreeUserData
	add	esp, 4
$LN6@Mod_FreeMo:

; 112  : 
; 113  : 	// select the properly unloader
; 114  : 	switch( mod->type )

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv77[ebp], ecx
	cmp	DWORD PTR tv77[ebp], 3
	ja	SHORT $LN2@Mod_FreeMo
	mov	edx, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN12@Mod_FreeMo[edx*4]
$LN7@Mod_FreeMo:

; 115  : 	{
; 116  : 	case mod_sprite:
; 117  : 		Mod_UnloadSpriteModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 118  : 		break;

	jmp	SHORT $LN2@Mod_FreeMo
$LN8@Mod_FreeMo:

; 119  : 	case mod_studio:
; 120  : 		Mod_UnloadStudioModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadStudioModel
	add	esp, 4

; 121  : 		break;

	jmp	SHORT $LN2@Mod_FreeMo
$LN9@Mod_FreeMo:

; 122  : 	case mod_brush:
; 123  : 		Mod_UnloadBrushModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadBrushModel
	add	esp, 4

; 124  : 		break;

	jmp	SHORT $LN2@Mod_FreeMo
$LN10@Mod_FreeMo:

; 125  : 	case mod_alias:
; 126  : 		Mod_UnloadAliasModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadAliasModel
	add	esp, 4
$LN2@Mod_FreeMo:

; 127  : 		break;
; 128  : 	}
; 129  : 
; 130  : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_FreeMo:

; 131  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@Mod_FreeMo:
	DD	$LN9@Mod_FreeMo
	DD	$LN7@Mod_FreeMo
	DD	$LN10@Mod_FreeMo
	DD	$LN8@Mod_FreeMo
_Mod_FreeModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_FreeUserData
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_Mod_FreeUserData PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 77   : 	// ignore submodels and freed models
; 78   : 	if( !mod->name[0] || mod->name[0] == '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN3@Mod_FreeUs
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN2@Mod_FreeUs
$LN3@Mod_FreeUs:

; 79   : 		return;

	jmp	SHORT $LN1@Mod_FreeUs
$LN2@Mod_FreeUs:

; 80   : 
; 81   : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN4@Mod_FreeUs

; 82   : 	{
; 83   : 		if( svgame.physFuncs.Mod_ProcessUserData != NULL )

	cmp	DWORD PTR _svgame+19576, 0
	je	SHORT $LN6@Mod_FreeUs

; 84   : 		{
; 85   : 			// let the server.dll free custom data
; 86   : 			svgame.physFuncs.Mod_ProcessUserData( mod, false, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	DWORD PTR _svgame+19576
	add	esp, 12					; 0000000cH
$LN6@Mod_FreeUs:

; 87   : 		}
; 88   : 	}

	jmp	SHORT $LN1@Mod_FreeUs
$LN4@Mod_FreeUs:

; 89   : 	else
; 90   : 	{
; 91   : 		if( clgame.drawFuncs.Mod_ProcessUserData != NULL )

	cmp	DWORD PTR _clgame+204, 0
	je	SHORT $LN1@Mod_FreeUs

; 92   : 		{
; 93   : 			// let the client.dll free custom data
; 94   : 			clgame.drawFuncs.Mod_ProcessUserData( mod, false, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	DWORD PTR _clgame+204
	add	esp, 12					; 0000000cH
$LN1@Mod_FreeUs:

; 95   : 		}
; 96   : 	}
; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FreeUserData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_Modellist_f
_TEXT	SEGMENT
_mod$ = -12						; size = 4
_nummodels$ = -8					; size = 4
_i$ = -4						; size = 4
_Mod_Modellist_f PROC					; COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 51   : 	int	i, nummodels;
; 52   : 	model_t	*mod;
; 53   : 
; 54   : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 55   : 	Con_Printf( "-----------------------------------\n" );

	push	OFFSET ??_C@_0CF@MLCIJBNO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
	call	_Con_Printf
	add	esp, 4

; 56   : 
; 57   : 	for( i = nummodels = 0, mod = mod_known; i < mod_numknown; i++, mod++ )

	mov	DWORD PTR _nummodels$[ebp], 0
	mov	eax, DWORD PTR _nummodels$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _mod$[ebp], OFFSET _mod_known
	jmp	SHORT $LN4@Mod_Modell
$LN2@Mod_Modell:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@Mod_Modell:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN3@Mod_Modell

; 58   : 	{
; 59   : 		if( !mod->name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@Mod_Modell

; 60   : 			continue; // free slot

	jmp	SHORT $LN2@Mod_Modell
$LN5@Mod_Modell:

; 61   : 		Con_Printf( "%s\n", mod->name );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 62   : 		nummodels++;

	mov	eax, DWORD PTR _nummodels$[ebp]
	add	eax, 1
	mov	DWORD PTR _nummodels$[ebp], eax

; 63   : 	}

	jmp	SHORT $LN2@Mod_Modell
$LN3@Mod_Modell:

; 64   : 
; 65   : 	Con_Printf( "-----------------------------------\n" );

	push	OFFSET ??_C@_0CF@MLCIJBNO@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
	call	_Con_Printf
	add	esp, 4

; 66   : 	Con_Printf( "%i total models\n", nummodels );

	mov	eax, DWORD PTR _nummodels$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@IMJBIBMH@?$CFi?5total?5models?6@
	call	_Con_Printf
	add	esp, 8

; 67   : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 68   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_Modellist_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_FreeUnused
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mod$ = -4						; size = 4
_Mod_FreeUnused PROC					; COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 469  : 	model_t	*mod;
; 470  : 	int	i;
; 471  : 
; 472  : 	// never tries to release worldmodel
; 473  : 	for( i = 1, mod = &mod_known[1]; i < mod_numknown; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	eax, 392				; 00000188H
	shl	eax, 0
	add	eax, OFFSET _mod_known
	mov	DWORD PTR _mod$[ebp], eax
	jmp	SHORT $LN4@Mod_FreeUn
$LN2@Mod_FreeUn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@Mod_FreeUn:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN1@Mod_FreeUn

; 474  : 	{
; 475  : 		if( mod->needload == NL_UNREFERENCED && COM_CheckString( mod->name ))

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN5@Mod_FreeUn
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@Mod_FreeUn

; 476  : 			Mod_FreeModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_FreeModel
	add	esp, 4
$LN5@Mod_FreeUn:

; 477  : 	}

	jmp	SHORT $LN2@Mod_FreeUn
$LN1@Mod_FreeUn:

; 478  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FreeUnused ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_NeedCRC
_TEXT	SEGMENT
_p$ = -8						; size = 4
_mod$ = -4						; size = 4
_name$ = 8						; size = 4
_needCRC$ = 12						; size = 4
_Mod_NeedCRC PROC					; COMDAT

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 597  : 	model_t		*mod;
; 598  : 	model_info_t	*p;
; 599  : 
; 600  : 	mod = Mod_FindName( name, true );

	push	1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _mod$[ebp], eax

; 601  : 	p = &mod_crcinfo[mod - mod_known];

	mov	eax, DWORD PTR _mod$[ebp]
	sub	eax, OFFSET _mod_known
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
	lea	edx, DWORD PTR _mod_crcinfo[eax*8]
	mov	DWORD PTR _p$[ebp], edx

; 602  : 
; 603  : 	if( needCRC ) SetBits( p->flags, FCRC_SHOULD_CHECKSUM );

	cmp	DWORD PTR _needCRC$[ebp], 0
	je	SHORT $LN2@Mod_NeedCR
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN1@Mod_NeedCR
$LN2@Mod_NeedCR:

; 604  : 	else ClearBits( p->flags, FCRC_SHOULD_CHECKSUM );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@Mod_NeedCR:

; 605  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_NeedCRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_ValidateCRC
_TEXT	SEGMENT
_mod$ = -8						; size = 4
_p$ = -4						; size = 4
_name$ = 8						; size = 4
_crc$ = 12						; size = 4
_Mod_ValidateCRC PROC					; COMDAT

; 575  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 576  : 	model_info_t	*p;
; 577  : 	model_t		*mod;
; 578  : 
; 579  : 	mod = Mod_FindName( name, true );

	push	1
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _mod$[ebp], eax

; 580  : 	p = &mod_crcinfo[mod - mod_known];

	mov	eax, DWORD PTR _mod$[ebp]
	sub	eax, OFFSET _mod_known
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
	lea	edx, DWORD PTR _mod_crcinfo[eax*8]
	mov	DWORD PTR _p$[ebp], edx

; 581  : 
; 582  : 	if( !FBitSet( p->flags, FCRC_CHECKSUM_DONE ))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	jne	SHORT $LN2@Mod_Valida

; 583  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Valida
$LN2@Mod_Valida:

; 584  : 	if( p->initialCRC == crc )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _crc$[ebp]
	jne	SHORT $LN3@Mod_Valida

; 585  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mod_Valida
$LN3@Mod_Valida:

; 586  : 	return false;

	xor	eax, eax
$LN1@Mod_Valida:

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ValidateCRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_ForName
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_name$ = 8						; size = 4
_crash$ = 12						; size = 4
_trackCRC$ = 16						; size = 4
_Mod_ForName PROC					; COMDAT

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 389  : 	model_t	*mod;
; 390  : 
; 391  : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Mod_ForNam

; 392  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Mod_ForNam
$LN2@Mod_ForNam:

; 393  : 
; 394  : 	mod = Mod_FindName( name, trackCRC );

	mov	eax, DWORD PTR _trackCRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _mod$[ebp], eax

; 395  : 	return Mod_LoadModel( mod, crash );

	mov	eax, DWORD PTR _crash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Mod_LoadModel
	add	esp, 8
$LN1@Mod_ForNam:

; 396  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ForName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_LoadModel
_TEXT	SEGMENT
tv138 = -156						; size = 4
_currentCRC$1 = -88					; size = 4
_p$ = -84						; size = 4
_buf$ = -80						; size = 4
_loaded$ = -76						; size = 4
_length$ = -72						; size = 4
_tempname$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_crash$ = 12						; size = 4
_Mod_LoadModel PROC					; COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 258  : 	char		tempname[MAX_QPATH];
; 259  : 	long		length = 0;

	mov	DWORD PTR _length$[ebp], 0

; 260  : 	qboolean		loaded;
; 261  : 	byte		*buf;
; 262  : 	model_info_t	*p;
; 263  : 
; 264  : 	ASSERT( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN4@Mod_LoadMo
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadModel@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mod_LoadMo:

; 265  : 
; 266  : 	// check if already loaded (or inline bmodel)
; 267  : 	if( mod->mempool || mod->name[0] == '*' )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN6@Mod_LoadMo
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN5@Mod_LoadMo
$LN6@Mod_LoadMo:

; 268  : 	{
; 269  : 		mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2

; 270  : 		return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@Mod_LoadMo
$LN5@Mod_LoadMo:

; 271  : 	}
; 272  : 
; 273  : 	ASSERT( mod->needload == NL_NEEDS_LOADED );

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+64], 1
	je	SHORT $LN7@Mod_LoadMo
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadModel@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN7@Mod_LoadMo:

; 274  : 
; 275  : 	// store modelname to show error
; 276  : 	Q_strncpy( tempname, mod->name, sizeof( tempname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 277  : 	COM_FixSlashes( tempname );

	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 278  : 
; 279  : 	buf = FS_LoadFile( tempname, &length, false );

	push	0
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempname$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 280  : 
; 281  : 	if( !buf )

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN8@Mod_LoadMo

; 282  : 	{
; 283  : 		memset( mod, 0, sizeof( model_t ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 284  : 
; 285  : 		if( crash ) Host_Error( "%s couldn't load\n", tempname );

	cmp	DWORD PTR _crash$[ebp], 0
	je	SHORT $LN9@Mod_LoadMo
	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@HOCLFBPM@?$CFs?5couldn?8t?5load?6@
	call	_Host_Error
	add	esp, 8
	jmp	SHORT $LN10@Mod_LoadMo
$LN9@Mod_LoadMo:

; 286  : 		else Con_Printf( S_ERROR "%s couldn't load\n", tempname );

	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@
	call	_Con_Printf
	add	esp, 8
$LN10@Mod_LoadMo:

; 287  : 
; 288  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Mod_LoadMo
$LN8@Mod_LoadMo:

; 289  : 	}
; 290  : 
; 291  : 	Con_Reportf( "loading %s\n", mod->name );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@KOFNDIEA@loading?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8

; 292  : 	mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2

; 293  : 	mod->type = mod_bad;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+68], -1

; 294  : 	loadmodel = mod;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR _loadmodel, eax

; 295  : 
; 296  : 	// call the apropriate loader
; 297  : 	switch( *(uint *)buf )

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], 1330660425	; 4f504449H
	ja	SHORT $LN34@Mod_LoadMo
	cmp	DWORD PTR tv138[ebp], 1330660425	; 4f504449H
	je	SHORT $LN13@Mod_LoadMo
	cmp	DWORD PTR tv138[ebp], 29		; 0000001dH
	je	SHORT $LN16@Mod_LoadMo
	cmp	DWORD PTR tv138[ebp], 30		; 0000001eH
	je	SHORT $LN16@Mod_LoadMo
	cmp	DWORD PTR tv138[ebp], 844124994		; 32505342H
	je	SHORT $LN16@Mod_LoadMo
	jmp	SHORT $LN17@Mod_LoadMo
$LN34@Mod_LoadMo:
	cmp	DWORD PTR tv138[ebp], 1347634249	; 50534449H
	je	SHORT $LN12@Mod_LoadMo
	cmp	DWORD PTR tv138[ebp], 1414743113	; 54534449H
	je	SHORT $LN11@Mod_LoadMo
	jmp	SHORT $LN17@Mod_LoadMo
$LN11@Mod_LoadMo:

; 298  : 	{
; 299  : 	case IDSTUDIOHEADER:
; 300  : 		Mod_LoadStudioModel( mod, buf, &loaded );

	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_LoadStudioModel
	add	esp, 12					; 0000000cH

; 301  : 		break;

	jmp	$LN2@Mod_LoadMo
$LN12@Mod_LoadMo:

; 302  : 	case IDSPRITEHEADER:
; 303  : 		Mod_LoadSpriteModel( mod, buf, &loaded, 0 );

	push	0
	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_LoadSpriteModel
	add	esp, 16					; 00000010H

; 304  : 		break;

	jmp	SHORT $LN2@Mod_LoadMo
$LN13@Mod_LoadMo:

; 305  : 	case IDALIASHEADER:
; 306  : 		Mod_LoadAliasModel( mod, buf, &loaded );

	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_LoadAliasModel
	add	esp, 12					; 0000000cH

; 307  : 		break;

	jmp	SHORT $LN2@Mod_LoadMo
$LN16@Mod_LoadMo:

; 308  : 	case Q1BSP_VERSION:
; 309  : 	case HLBSP_VERSION:
; 310  : 	case QBSP2_VERSION:
; 311  : 		Mod_LoadBrushModel( mod, buf, &loaded );

	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_Mod_LoadBrushModel
	add	esp, 12					; 0000000cH

; 312  : 		break;

	jmp	SHORT $LN2@Mod_LoadMo
$LN17@Mod_LoadMo:

; 313  : 	default:
; 314  : 		Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadModel@@9@9
	add	eax, 57					; 00000039H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 315  : 		if( crash ) Host_Error( "%s has unknown format\n", tempname );

	cmp	DWORD PTR _crash$[ebp], 0
	je	SHORT $LN18@Mod_LoadMo
	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@MJMCMJBO@?$CFs?5has?5unknown?5format?6@
	call	_Host_Error
	add	esp, 8
	jmp	SHORT $LN19@Mod_LoadMo
$LN18@Mod_LoadMo:

; 316  : 		else Con_Printf( S_ERROR "%s has unknown format\n", tempname );

	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@ILDBDGFM@?$FO1Error?3?$FO7?5?$CFs?5has?5unknown?5forma@
	call	_Con_Printf
	add	esp, 8
$LN19@Mod_LoadMo:

; 317  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Mod_LoadMo
$LN2@Mod_LoadMo:

; 318  : 	}
; 319  : 
; 320  : 	if( !loaded )

	cmp	DWORD PTR _loaded$[ebp], 0
	jne	SHORT $LN20@Mod_LoadMo

; 321  : 	{
; 322  : 		Mod_FreeModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_FreeModel
	add	esp, 4

; 323  : 		Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadModel@@9@9
	add	eax, 66					; 00000042H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 324  : 
; 325  : 		if( crash ) Host_Error( "%s couldn't load\n", tempname );

	cmp	DWORD PTR _crash$[ebp], 0
	je	SHORT $LN22@Mod_LoadMo
	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@HOCLFBPM@?$CFs?5couldn?8t?5load?6@
	call	_Host_Error
	add	esp, 8
	jmp	SHORT $LN23@Mod_LoadMo
$LN22@Mod_LoadMo:

; 326  : 		else Con_Printf( S_ERROR "%s couldn't load\n", tempname );

	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@
	call	_Con_Printf
	add	esp, 8
$LN23@Mod_LoadMo:

; 327  : 
; 328  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Mod_LoadMo

; 329  : 	}

	jmp	SHORT $LN21@Mod_LoadMo
$LN20@Mod_LoadMo:

; 330  : 	else
; 331  : 	{
; 332  : 		if( world.loading )

	cmp	DWORD PTR _world, 0
	je	SHORT $LN24@Mod_LoadMo

; 333  : 			SetBits( mod->flags, MODEL_WORLD ); // mark worldmodel

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN24@Mod_LoadMo:

; 334  : 
; 335  : 		if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN25@Mod_LoadMo

; 336  : 		{
; 337  : 			if( svgame.physFuncs.Mod_ProcessUserData != NULL )

	cmp	DWORD PTR _svgame+19576, 0
	je	SHORT $LN27@Mod_LoadMo

; 338  : 			{
; 339  : 				// let the server.dll load custom data
; 340  : 				svgame.physFuncs.Mod_ProcessUserData( mod, true, buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19576
	add	esp, 12					; 0000000cH
$LN27@Mod_LoadMo:

; 341  : 			}
; 342  : 		}

	jmp	SHORT $LN21@Mod_LoadMo
$LN25@Mod_LoadMo:

; 343  : 		else
; 344  : 		{
; 345  : 			if( clgame.drawFuncs.Mod_ProcessUserData != NULL )

	cmp	DWORD PTR _clgame+204, 0
	je	SHORT $LN21@Mod_LoadMo

; 346  : 			{
; 347  : 				// let the client.dll load custom data
; 348  : 				clgame.drawFuncs.Mod_ProcessUserData( mod, true, buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	DWORD PTR _clgame+204
	add	esp, 12					; 0000000cH
$LN21@Mod_LoadMo:

; 349  : 			}
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	p = &mod_crcinfo[mod - mod_known];

	mov	eax, DWORD PTR _mod$[ebp]
	sub	eax, OFFSET _mod_known
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
	lea	edx, DWORD PTR _mod_crcinfo[eax*8]
	mov	DWORD PTR _p$[ebp], edx

; 354  : 	mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2

; 355  : 
; 356  : 	if( FBitSet( p->flags, FCRC_SHOULD_CHECKSUM ))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $LN29@Mod_LoadMo

; 357  : 	{
; 358  : 		CRC32_t	currentCRC;
; 359  : 
; 360  : 		CRC32_Init( &currentCRC );

	lea	eax, DWORD PTR _currentCRC$1[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 361  : 		CRC32_ProcessBuffer( &currentCRC, buf, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _currentCRC$1[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 362  : 		currentCRC = CRC32_Final( currentCRC );

	mov	eax, DWORD PTR _currentCRC$1[ebp]
	push	eax
	call	_CRC32_Final
	add	esp, 4
	mov	DWORD PTR _currentCRC$1[ebp], eax

; 363  : 
; 364  : 		if( FBitSet( p->flags, FCRC_CHECKSUM_DONE ))

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	je	SHORT $LN30@Mod_LoadMo

; 365  : 		{
; 366  : 			if( currentCRC != p->initialCRC )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _currentCRC$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN32@Mod_LoadMo

; 367  : 				Host_Error( "%s has a bad checksum\n", tempname );

	lea	eax, DWORD PTR _tempname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@JLHDPLGM@?$CFs?5has?5a?5bad?5checksum?6@
	call	_Host_Error
	add	esp, 8
$LN32@Mod_LoadMo:

; 368  : 		}

	jmp	SHORT $LN29@Mod_LoadMo
$LN30@Mod_LoadMo:

; 369  : 		else
; 370  : 		{
; 371  : 			SetBits( p->flags, FCRC_CHECKSUM_DONE );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 372  : 			p->initialCRC = currentCRC;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _currentCRC$1[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN29@Mod_LoadMo:

; 373  : 		}
; 374  : 	}
; 375  : 	Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadModel@@9@9
	add	eax, 118				; 00000076H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 376  : 
; 377  : 	return mod;

	mov	eax, DWORD PTR _mod$[ebp]
$LN1@Mod_LoadMo:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_FindName
_TEXT	SEGMENT
_i$ = -76						; size = 4
_mod$ = -72						; size = 4
_modname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_trackCRC$ = 12						; size = 4
_Mod_FindName PROC					; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 209  : 	char	modname[MAX_QPATH];
; 210  : 	model_t	*mod;
; 211  : 	int	i;
; 212  : 
; 213  : 	Q_strncpy( modname, filename, sizeof( modname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _modname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 214  : 
; 215  : 	// search the currently loaded models
; 216  : 	for( i = 0, mod = mod_known; i < mod_numknown; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _mod$[ebp], OFFSET _mod_known
	jmp	SHORT $LN4@Mod_FindNa
$LN2@Mod_FindNa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@Mod_FindNa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN3@Mod_FindNa

; 217  : 	{
; 218  : 		if( !Q_stricmp( mod->name, modname ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _modname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Mod_FindNa

; 219  : 		{
; 220  : 			if( mod->mempool || mod->name[0] == '*' )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN11@Mod_FindNa
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN9@Mod_FindNa
$LN11@Mod_FindNa:

; 221  : 				mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2
	jmp	SHORT $LN10@Mod_FindNa
$LN9@Mod_FindNa:

; 222  : 			else mod->needload = NL_NEEDS_LOADED;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 1
$LN10@Mod_FindNa:

; 223  : 
; 224  : 			return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@Mod_FindNa
$LN8@Mod_FindNa:

; 225  : 		}
; 226  : 	}

	jmp	SHORT $LN2@Mod_FindNa
$LN3@Mod_FindNa:

; 227  : 
; 228  : 	// find a free model slot spot
; 229  : 	for( i = 0, mod = mod_known; i < mod_numknown; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _mod$[ebp], OFFSET _mod_known
	jmp	SHORT $LN7@Mod_FindNa
$LN5@Mod_FindNa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN7@Mod_FindNa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN6@Mod_FindNa

; 230  : 		if( !mod->name[0] ) break; // this is a valid spot

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN12@Mod_FindNa
	jmp	SHORT $LN6@Mod_FindNa
$LN12@Mod_FindNa:
	jmp	SHORT $LN5@Mod_FindNa
$LN6@Mod_FindNa:

; 231  : 
; 232  : 	if( i == mod_numknown )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jne	SHORT $LN13@Mod_FindNa

; 233  : 	{
; 234  : 		if( mod_numknown == MAX_MODELS )

	cmp	DWORD PTR _mod_numknown, 1024		; 00000400H
	jne	SHORT $LN14@Mod_FindNa

; 235  : 			Host_Error( "MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET ??_C@_0CA@DAAKNEHA@MAX_MODELS?5limit?5exceeded?5?$CI?$CFd?$CJ?6@
	call	_Host_Error
	add	esp, 8
$LN14@Mod_FindNa:

; 236  : 		mod_numknown++;

	mov	eax, DWORD PTR _mod_numknown
	add	eax, 1
	mov	DWORD PTR _mod_numknown, eax
$LN13@Mod_FindNa:

; 237  : 	}
; 238  : 
; 239  : 	// copy name, so model loader can find model file
; 240  : 	Q_strncpy( mod->name, modname, sizeof( mod->name ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _modname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 241  : 	if( trackCRC ) mod_crcinfo[i].flags = FCRC_SHOULD_CHECKSUM;

	cmp	DWORD PTR _trackCRC$[ebp], 0
	je	SHORT $LN15@Mod_FindNa
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _mod_crcinfo[eax*8], 1
	jmp	SHORT $LN16@Mod_FindNa
$LN15@Mod_FindNa:

; 242  : 	else mod_crcinfo[i].flags = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _mod_crcinfo[eax*8], 0
$LN16@Mod_FindNa:

; 243  : 	mod->needload = NL_NEEDS_LOADED;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 1

; 244  : 	mod_crcinfo[i].initialCRC = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _mod_crcinfo[eax*8+4], 0

; 245  : 
; 246  : 	return mod;

	mov	eax, DWORD PTR _mod$[ebp]
$LN1@Mod_FindNa:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FindName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_StudioExtradata
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_Mod_StudioExtradata PROC				; COMDAT

; 562  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 563  : 	if( mod && mod->type == mod_studio )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN2@Mod_Studio
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN2@Mod_Studio

; 564  : 		return mod->cache.data;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [eax+388]
	jmp	SHORT $LN1@Mod_Studio
$LN2@Mod_Studio:

; 565  : 	return NULL;

	xor	eax, eax
$LN1@Mod_Studio:

; 566  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioExtradata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_AliasExtradata
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_Mod_AliasExtradata PROC				; COMDAT

; 549  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 550  : 	if( mod && mod->type == mod_alias )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN2@Mod_AliasE
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 2
	jne	SHORT $LN2@Mod_AliasE

; 551  : 		return mod->cache.data;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [eax+388]
	jmp	SHORT $LN1@Mod_AliasE
$LN2@Mod_AliasE:

; 552  : 	return NULL;

	xor	eax, eax
$LN1@Mod_AliasE:

; 553  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_AliasExtradata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_LoadCacheFile
_TEXT	SEGMENT
tv70 = -144						; size = 4
_buf$ = -76						; size = 4
_size$ = -72						; size = 4
_modname$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_cu$ = 12						; size = 4
_Mod_LoadCacheFile PROC					; COMDAT

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 523  : 	char	modname[MAX_QPATH];
; 524  : 	size_t	size;
; 525  : 	byte	*buf;
; 526  : 
; 527  : 	Assert( cu != NULL );

	cmp	DWORD PTR _cu$[ebp], 0
	je	SHORT $LN6@Mod_LoadCa
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@Mod_LoadCa
$LN6@Mod_LoadCa:
	mov	DWORD PTR tv70[ebp], 0
$LN7@Mod_LoadCa:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadCacheFile@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@KEHLMCM@cu?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 528  : 
; 529  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Mod_LoadCa

; 530  : 		return;

	jmp	$LN1@Mod_LoadCa
$LN2@Mod_LoadCa:

; 531  : 
; 532  : 	Q_strncpy( modname, filename, sizeof( modname ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _modname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 533  : 	COM_FixSlashes( modname );

	lea	eax, DWORD PTR _modname$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 534  : 
; 535  : 	buf = FS_LoadFile( modname, &size, false );

	push	0
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _modname$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 536  : 	if( !buf || !size ) Host_Error( "LoadCacheFile: ^1can't load %s^7\n", filename );

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN4@Mod_LoadCa
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN3@Mod_LoadCa
$LN4@Mod_LoadCa:
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@GEIPCMCJ@LoadCacheFile?3?5?$FO1can?8t?5load?5?$CFs?$FO@
	call	_Host_Error
	add	esp, 8
$LN3@Mod_LoadCa:

; 537  : 	cu->data = Mem_Malloc( com_studiocache, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadCacheFile@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _com_studiocache
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _cu$[ebp]
	mov	DWORD PTR [ecx], eax

; 538  : 	memcpy( cu->data, buf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cu$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 539  : 	Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadCacheFile@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@Mod_LoadCa:

; 540  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadCacheFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_CacheCheck
_TEXT	SEGMENT
_c$ = 8							; size = 4
_Mod_CacheCheck PROC					; COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 512  : 	return Cache_Check( com_studiocache, c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _com_studiocache
	push	ecx
	call	_Cache_Check
	add	esp, 8

; 513  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CacheCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_Calloc
_TEXT	SEGMENT
_cu$ = -4						; size = 4
_number$ = 8						; size = 4
_size$ = 12						; size = 4
_Mod_Calloc PROC					; COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 495  : 	cache_user_t	*cu;
; 496  : 
; 497  : 	if( number <= 0 || size <= 0 ) return NULL;

	cmp	DWORD PTR _number$[ebp], 0
	jle	SHORT $LN3@Mod_Calloc
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN2@Mod_Calloc
$LN3@Mod_Calloc:
	xor	eax, eax
	jmp	SHORT $LN1@Mod_Calloc
$LN2@Mod_Calloc:

; 498  : 	cu = (cache_user_t *)Mem_Calloc( com_studiocache, sizeof( cache_user_t ) + number * size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_Calloc@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _number$[ebp]
	imul	ecx, DWORD PTR _size$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _com_studiocache
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cu$[ebp], eax

; 499  : 	cu->data = (void *)cu; // make sure what cu->data is not NULL

	mov	eax, DWORD PTR _cu$[ebp]
	mov	ecx, DWORD PTR _cu$[ebp]
	mov	DWORD PTR [eax], ecx

; 500  : 
; 501  : 	return cu;

	mov	eax, DWORD PTR _cu$[ebp]
$LN1@Mod_Calloc:

; 502  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_Calloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_LoadWorld
_TEXT	SEGMENT
_pworld$ = -4						; size = 4
_name$ = 8						; size = 4
_preload$ = 12						; size = 4
_Mod_LoadWorld PROC					; COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 440  : 	model_t	*pworld;
; 441  : 
; 442  : 	// already loaded?
; 443  : 	if( !Q_stricmp( mod_known->name, name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET _mod_known
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@Mod_LoadWo

; 444  : 		return mod_known;

	mov	eax, OFFSET _mod_known
	jmp	SHORT $LN1@Mod_LoadWo
$LN2@Mod_LoadWo:

; 445  : 
; 446  : 	// free sequence files on studiomodels
; 447  : 	Mod_PurgeStudioCache();

	call	_Mod_PurgeStudioCache

; 448  : 
; 449  : 	// load the newmap
; 450  : 	world.loading = true;

	mov	DWORD PTR _world, 1

; 451  : 	pworld = Mod_FindName( name, false );

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _pworld$[ebp], eax

; 452  : 	if( preload ) Mod_LoadModel( pworld, true );

	cmp	DWORD PTR _preload$[ebp], 0
	je	SHORT $LN3@Mod_LoadWo
	push	1
	mov	eax, DWORD PTR _pworld$[ebp]
	push	eax
	call	_Mod_LoadModel
	add	esp, 8
$LN3@Mod_LoadWo:

; 453  : 	world.loading = false;

	mov	DWORD PTR _world, 0

; 454  : 
; 455  : 	ASSERT( pworld == mod_known );

	cmp	DWORD PTR _pworld$[ebp], OFFSET _mod_known
	je	SHORT $LN4@Mod_LoadWo
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadWorld@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mod_LoadWo:

; 456  : 
; 457  : 	return pworld;

	mov	eax, DWORD PTR _pworld$[ebp]
$LN1@Mod_LoadWo:

; 458  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_ClearUserData
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Mod_ClearUserData PROC					; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 176  : 	int	i;
; 177  : 
; 178  : 	for( i = 0; i < mod_numknown; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_ClearU
$LN2@Mod_ClearU:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_ClearU:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN1@Mod_ClearU

; 179  : 		Mod_FreeUserData( &mod_known[i] );

	imul	eax, DWORD PTR _i$[ebp], 392
	add	eax, OFFSET _mod_known
	push	eax
	call	_Mod_FreeUserData
	add	esp, 4
	jmp	SHORT $LN2@Mod_ClearU
$LN1@Mod_ClearU:

; 180  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ClearUserData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_Shutdown
_TEXT	SEGMENT
_Mod_Shutdown PROC					; COMDAT

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 189  : 	Mod_FreeAll();

	call	_Mod_FreeAll

; 190  : 	Mem_FreePool( &com_studiocache );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_Shutdown@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _com_studiocache
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 191  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_FreeAll
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Mod_FreeAll PROC					; COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 161  : 	int	i;
; 162  : 
; 163  : 	Mod_ReleaseHullPolygons();

	call	_Mod_ReleaseHullPolygons

; 164  : 	for( i = 0; i < mod_numknown; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_FreeAl
$LN2@Mod_FreeAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_FreeAl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mod_numknown
	jge	SHORT $LN3@Mod_FreeAl

; 165  : 		Mod_FreeModel( &mod_known[i] );

	imul	eax, DWORD PTR _i$[ebp], 392
	add	eax, OFFSET _mod_known
	push	eax
	call	_Mod_FreeModel
	add	esp, 4
	jmp	SHORT $LN2@Mod_FreeAl
$LN3@Mod_FreeAl:

; 166  : 	mod_numknown = 0;

	mov	DWORD PTR _mod_numknown, 0

; 167  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_FreeAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\model.c
;	COMDAT _Mod_Init
_TEXT	SEGMENT
_Mod_Init PROC						; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 142  : 	com_studiocache = Mem_AllocPool( "Studio Cache" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_Init@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DC@DPJBIEHJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@FIALMFCO@Studio?5Cache@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _com_studiocache, eax

; 143  : 	mod_studiocache = Cvar_Get( "r_studiocache", "1", FCVAR_ARCHIVE, "enables studio cache for speedup tracing hitboxes" );

	push	OFFSET ??_C@_0DC@FPKHEELJ@enables?5studio?5cache?5for?5speedu@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0O@OIMKAGJH@r_studiocache@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mod_studiocache, eax

; 144  : 	r_wadtextures = Cvar_Get( "r_wadtextures", "0", 0, "completely ignore textures in the bsp-file if enabled" );

	push	OFFSET ??_C@_0DG@FGCMJCLN@completely?5ignore?5textures?5in?5t@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NCEBFPNG@r_wadtextures@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_wadtextures, eax

; 145  : 	r_showhull = Cvar_Get( "r_showhull", "0", 0, "draw collision hulls 1-3" );

	push	OFFSET ??_C@_0BJ@GEGKKLMK@draw?5collision?5hulls?51?93@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0L@KGPGEHEC@r_showhull@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_showhull, eax

; 146  : 
; 147  : 	Cmd_AddCommand( "mapstats", Mod_PrintWorldStats_f, "show stats for currently loaded map" );

	push	OFFSET ??_C@_0CE@CMPIDHBD@show?5stats?5for?5currently?5loaded@
	push	OFFSET _Mod_PrintWorldStats_f
	push	OFFSET ??_C@_08BBGHLOBD@mapstats@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 148  : 	Cmd_AddCommand( "modellist", Mod_Modellist_f, "display loaded models list" );

	push	OFFSET ??_C@_0BL@ENDKIMCI@display?5loaded?5models?5list@
	push	OFFSET _Mod_Modellist_f
	push	OFFSET ??_C@_09EOKHBMCA@modellist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 149  : 
; 150  : 	Mod_ResetStudioAPI ();

	call	_Mod_ResetStudioAPI

; 151  : 	Mod_InitStudioHull ();

	call	_Mod_InitStudioHull

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_Init ENDP
_TEXT	ENDS
END
