; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_mirror.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_R_BeginDrawMirror
PUBLIC	_R_EndDrawMirror
PUBLIC	_R_DrawMirrors
PUBLIC	_R_FindMirrors
PUBLIC	_R_PlaneForMirror
PUBLIC	_R_AllocateMirrorTexture
PUBLIC	_R_RecursiveMirrorNode
PUBLIC	_R_FindBmodelMirrors
PUBLIC	_R_CheckEntitiesOnList
PUBLIC	?__LINE__Var@?0??R_PlaneForMirror@@9@9		; `R_PlaneForMirror'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_09PABMCPNL@?$CKscreen?$CFi@		; `string'
PUBLIC	?__LINE__Var@?0??R_DrawMirrors@@9@9		; `R_DrawMirrors'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9	; `R_CheckEntitiesOnList'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@c0000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_NearestPOW:PROC
EXTRN	_VectorsAngles:PROC
EXTRN	_Matrix4x4_VectorTransform:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_ConcatTransforms:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_BoxOnPlaneSide:PROC
EXTRN	_GL_FrustumSetPlane:PROC
EXTRN	_GL_CleanUpTextureUnits:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_LoadTexMatrix:PROC
EXTRN	_GL_TexGen:PROC
EXTRN	_R_CullBox:PROC
EXTRN	_R_CullSurface:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_R_RenderScene:PROC
EXTRN	_R_SetupFrustum:PROC
EXTRN	_R_FindViewLeaf:PROC
EXTRN	_Matrix4x4_Concat:PROC
EXTRN	_Matrix4x4_ConcatTranslate:PROC
EXTRN	_Matrix4x4_ConcatScale:PROC
EXTRN	_R_MarkLeaves:PROC
EXTRN	_GL_Support:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_vec3_origin:BYTE
EXTRN	_matrix4x4_identity:ZWORD
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9 DD 0200H	; `R_CheckEntitiesOnList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??R_DrawMirrors@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_DrawMirrors@@9@9 DD 0b3H		; `R_DrawMirrors'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09PABMCPNL@?$CKscreen?$CFi@
CONST	SEGMENT
??_C@_09PABMCPNL@?$CKscreen?$CFi@ DB '*screen%i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_mirror.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_PlaneForMirror@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_PlaneForMirror@@9@9 DD 05eH		; `R_PlaneForMirror'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	05d9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0152H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02ebH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01364H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02e4H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_CheckEntitiesOnList
_TEXT	SEGMENT
tv217 = -72						; size = 4
tv194 = -72						; size = 4
tv139 = -72						; size = 4
_i$ = -4						; size = 4
_R_CheckEntitiesOnList PROC				; COMDAT

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 513  : 	int	i;
; 514  : 
; 515  : 	// check static entities
; 516  : 	for (i = 0; i < tr.draw_list->num_solid_entities; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_CheckEnt
$LN2@R_CheckEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_CheckEnt:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24576]
	jae	$LN3@R_CheckEnt

; 517  : 	{
; 518  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 519  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 520  : 
; 521  : 		ASSERT(RI.currententity != NULL);

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN17@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN17@R_CheckEnt:

; 522  : 		ASSERT(RI.currententity->model != NULL);

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN18@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN18@R_CheckEnt:

; 523  : 
; 524  : 		if (!R_StaticEntity(RI.currententity)) //if (!R_StaticEntityLegacy(RI.currententity))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN21@R_CheckEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN21@R_CheckEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_CheckEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_CheckEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_CheckEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@R_CheckEnt
$LN21@R_CheckEnt:

; 525  : 			continue;

	jmp	$LN2@R_CheckEnt
$LN19@R_CheckEnt:

; 526  : 
; 527  : 		switch (RI.currentmodel->type)

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv139[ebp], ecx
	cmp	DWORD PTR tv139[ebp], 0
	je	SHORT $LN22@R_CheckEnt
	jmp	SHORT $LN5@R_CheckEnt
$LN22@R_CheckEnt:

; 528  : 		{
; 529  : 		case mod_brush:
; 530  : 			R_FindBmodelMirrors(RI.currententity, false);

	push	0
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_FindBmodelMirrors
	add	esp, 8
$LN5@R_CheckEnt:

; 531  : 			break;
; 532  : 		}
; 533  : 	}

	jmp	$LN2@R_CheckEnt
$LN3@R_CheckEnt:

; 534  : 
; 535  : 	// world or static entities has mirror surfaces
; 536  : 	if (tr.mirror_entities[0].chain != NULL)

	mov	eax, 8
	imul	ecx, eax, 0
	cmp	DWORD PTR _tr[ecx+1228], 0
	je	SHORT $LN23@R_CheckEnt

; 537  : 	{
; 538  : 		tr.mirror_entities[0].ent = clgame.entities;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clgame+996
	mov	DWORD PTR _tr[ecx+1224], edx

; 539  : 		tr.num_mirror_entities++;

	mov	eax, DWORD PTR _tr+17608
	add	eax, 1
	mov	DWORD PTR _tr+17608, eax
$LN23@R_CheckEnt:

; 540  : 	}
; 541  : 
; 542  : 	// check solid entities
; 543  : 	for( i = 0; i < tr.draw_list->num_solid_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@R_CheckEnt
$LN7@R_CheckEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@R_CheckEnt:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24576]
	jae	$LN8@R_CheckEnt

; 544  : 	{
; 545  : 		RI.currententity = tr.draw_list->solid_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _RI+28, edx

; 546  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 547  : 	
; 548  : 		ASSERT( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN24@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN24@R_CheckEnt:

; 549  : 		ASSERT( RI.currententity->model != NULL );

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN25@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN25@R_CheckEnt:

; 550  : 
; 551  : 		if (R_StaticEntity(RI.currententity)) //if (!R_StaticEntityLegacy(RI.currententity))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN26@R_CheckEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN26@R_CheckEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@R_CheckEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@R_CheckEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@R_CheckEnt
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@R_CheckEnt

; 552  : 			continue;

	jmp	$LN7@R_CheckEnt
$LN26@R_CheckEnt:

; 553  : 
; 554  : 		switch( RI.currentmodel->type )

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv194[ebp], ecx
	cmp	DWORD PTR tv194[ebp], 0
	je	SHORT $LN27@R_CheckEnt
	jmp	SHORT $LN10@R_CheckEnt
$LN27@R_CheckEnt:

; 555  : 		{
; 556  : 		case mod_brush:
; 557  : 			R_FindBmodelMirrors( RI.currententity, false );

	push	0
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_FindBmodelMirrors
	add	esp, 8
$LN10@R_CheckEnt:

; 558  : 			break;
; 559  : 		}
; 560  : 	}

	jmp	$LN7@R_CheckEnt
$LN8@R_CheckEnt:

; 561  : 
; 562  : 	// check translucent entities
; 563  : 	for( i = 0; i < tr.draw_list->num_trans_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@R_CheckEnt
$LN12@R_CheckEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@R_CheckEnt:
	mov	eax, DWORD PTR _tr+66792
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24580]
	jae	$LN13@R_CheckEnt

; 564  : 	{
; 565  : 		RI.currententity = tr.draw_list->trans_entities[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr+66792
	mov	edx, DWORD PTR [ecx+eax*4+8192]
	mov	DWORD PTR _RI+28, edx

; 566  : 		RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 567  : 	
; 568  : 		ASSERT( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN28@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 56					; 00000038H
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN28@R_CheckEnt:

; 569  : 		ASSERT( RI.currententity->model != NULL );

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN29@R_CheckEnt
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_CheckEntitiesOnList@@9@9
	add	eax, 57					; 00000039H
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN29@R_CheckEnt:

; 570  : 
; 571  : 		switch( RI.currentmodel->type )

	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR tv217[ebp], ecx
	cmp	DWORD PTR tv217[ebp], 0
	je	SHORT $LN30@R_CheckEnt
	jmp	SHORT $LN15@R_CheckEnt
$LN30@R_CheckEnt:

; 572  : 		{
; 573  : 		case mod_brush:
; 574  : 			R_FindBmodelMirrors( RI.currententity, false );

	push	0
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_FindBmodelMirrors
	add	esp, 8
$LN15@R_CheckEnt:

; 575  : 			break;
; 576  : 		}
; 577  : 	}

	jmp	$LN12@R_CheckEnt
$LN13@R_CheckEnt:

; 578  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_CheckEntitiesOnList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_FindBmodelMirrors
_TEXT	SEGMENT
tv276 = -116						; size = 4
tv204 = -116						; size = 4
tv177 = -116						; size = 4
_i$ = -48						; size = 4
_frustum$ = -44						; size = 4
_rotated$ = -40						; size = 4
_clmodel$ = -36						; size = 4
_psurf$ = -32						; size = 4
_maxs$ = -28						; size = 12
_mins$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_static_entity$ = 12					; size = 4
_R_FindBmodelMirrors PROC				; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 425  : 	vec3_t		mins, maxs;
; 426  : 	msurface_t	*psurf;
; 427  : 	model_t		*clmodel;
; 428  : 	qboolean		rotated;
; 429  : 	gl_frustum_t	*frustum = NULL;

	mov	DWORD PTR _frustum$[ebp], 0

; 430  : 	int		i;
; 431  : 
; 432  : 	clmodel = e->model;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _clmodel$[ebp], ecx

; 433  : 
; 434  : 	// don't draw any water reflections if we underwater
; 435  : 	if( cl.local.waterlevel >= 3 && FBitSet( clmodel->flags, MODEL_LIQUID ))

	cmp	DWORD PTR _cl+2212736, 3
	jl	SHORT $LN8@R_FindBmod
	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	je	SHORT $LN8@R_FindBmod

; 436  : 		return;

	jmp	$LN26@R_FindBmod
$LN8@R_FindBmod:

; 437  : 
; 438  : 	if( static_entity )

	cmp	DWORD PTR _static_entity$[ebp], 0
	je	$LN9@R_FindBmod

; 439  : 	{
; 440  : 		Matrix4x4_LoadIdentity( RI.objectMatrix );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	push	OFFSET _RI+456
	call	_memcpy
	add	esp, 12					; 0000000cH

; 441  : 
; 442  : 		if( R_CullBox( clmodel->mins, clmodel->maxs ))

	mov	eax, DWORD PTR _clmodel$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _clmodel$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	_R_CullBox
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@R_FindBmod

; 443  : 			return;

	jmp	$LN26@R_FindBmod
$LN11@R_FindBmod:

; 444  : 
; 445  : 		VectorCopy( RI.cullorigin, tr.modelorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx

; 446  : 		frustum = &RI.frustum;

	mov	DWORD PTR _frustum$[ebp], OFFSET _RI+56

; 447  : 	}

	jmp	$LN23@R_FindBmod
$LN9@R_FindBmod:

; 448  : 	else
; 449  : 	{
; 450  : 		if( !VectorIsNull( e->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@R_FindBmod
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@R_FindBmod
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@R_FindBmod
$LN14@R_FindBmod:

; 451  : 		{
; 452  : 			for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_FindBmod
$LN2@R_FindBmod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_FindBmod:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@R_FindBmod

; 453  : 			{
; 454  : 				mins[i] = e->origin[i] - clmodel->radius;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+3224]
	subss	xmm0, DWORD PTR [edx+108]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _mins$[ebp+eax*4], xmm0

; 455  : 				maxs[i] = e->origin[i] + clmodel->radius;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+3224]
	addss	xmm0, DWORD PTR [edx+108]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _maxs$[ebp+eax*4], xmm0

; 456  : 			}

	jmp	SHORT $LN2@R_FindBmod
$LN3@R_FindBmod:

; 457  : 			rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1

; 458  : 		}

	jmp	$LN13@R_FindBmod
$LN12@R_FindBmod:

; 459  : 		else
; 460  : 		{
; 461  : 			VectorAdd( e->origin, clmodel->mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+84]
	movss	DWORD PTR tv177[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv177[ebp]
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 462  : 			VectorAdd( e->origin, clmodel->maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+96]
	movss	DWORD PTR tv204[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 463  : 			rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN13@R_FindBmod:

; 464  : 		}
; 465  : 
; 466  : 		if( R_CullBox( mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_R_CullBox
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@R_FindBmod

; 467  : 			return;

	jmp	$LN26@R_FindBmod
$LN15@R_FindBmod:

; 468  : 
; 469  : 		if( !VectorIsNull( e->origin ) || !VectorIsNull( e->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@R_FindBmod
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@R_FindBmod
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@R_FindBmod
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@R_FindBmod
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@R_FindBmod
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@R_FindBmod
$LN19@R_FindBmod:

; 470  : 		{
; 471  : 			if( rotated ) Matrix4x4_CreateFromEntity( RI.objectMatrix, e->angles, e->origin, 1.0f );

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN20@R_FindBmod
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN21@R_FindBmod
$LN20@R_FindBmod:

; 472  : 			else Matrix4x4_CreateFromEntity( RI.objectMatrix, vec3_origin, e->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN21@R_FindBmod:

; 473  : 		}

	jmp	SHORT $LN17@R_FindBmod
$LN16@R_FindBmod:

; 474  : 		else Matrix4x4_LoadIdentity( RI.objectMatrix );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	push	OFFSET _RI+456
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN17@R_FindBmod:

; 475  : 
; 476  : 		e->visframe = tr.framecount; // visible

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _tr+83200
	mov	DWORD PTR [eax+3316], ecx

; 477  : 
; 478  : 		if( rotated ) Matrix4x4_VectorITransform( RI.objectMatrix, RI.cullorigin, tr.modelorg );

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN22@R_FindBmod
	push	OFFSET _tr+87596
	push	OFFSET _RI+260
	push	OFFSET _RI+456
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
	jmp	$LN23@R_FindBmod
$LN22@R_FindBmod:

; 479  : 		else VectorSubtract( RI.cullorigin, e->origin, tr.modelorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[ecx+260]
	subss	xmm0, DWORD PTR [edx+eax+3224]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _tr[ecx+87596], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[edx+260]
	subss	xmm0, DWORD PTR [ecx+eax+3224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _tr[edx+87596], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR _RI[eax+260]
	subss	xmm0, DWORD PTR [edx+ecx+3224]
	movss	DWORD PTR tv276[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv276[ebp]
	movss	DWORD PTR _tr[eax+87596], xmm0
$LN23@R_FindBmod:

; 480  : 	}
; 481  : 
; 482  : 	psurf = &clmodel->surfaces[clmodel->firstmodelsurface];

	mov	eax, DWORD PTR _clmodel$[ebp]
	imul	ecx, DWORD PTR [eax+112], 92
	mov	edx, DWORD PTR _clmodel$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _psurf$[ebp], ecx

; 483  : 	for( i = 0; i < clmodel->nummodelsurfaces; i++, psurf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_FindBmod
$LN5@R_FindBmod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], ecx
$LN7@R_FindBmod:
	mov	eax, DWORD PTR _clmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $LN6@R_FindBmod

; 484  : 	{
; 485  : 		if( !FBitSet( psurf->flags, SURF_REFLECT ))

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN24@R_FindBmod

; 486  : 			continue;

	jmp	SHORT $LN5@R_FindBmod
$LN24@R_FindBmod:

; 487  : 
; 488  : 		if( R_CullSurface( psurf, frustum, 0 ))

	push	0
	mov	eax, DWORD PTR _frustum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN25@R_FindBmod

; 489  : 			continue;

	jmp	SHORT $LN5@R_FindBmod
$LN25@R_FindBmod:

; 490  : 
; 491  : 		psurf->info->mirrorchain = tr.mirror_entities[tr.num_mirror_entities].chain;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _tr+17608
	mov	eax, DWORD PTR _tr[edx*8+1228]
	mov	DWORD PTR [ecx+104], eax

; 492  : 		tr.mirror_entities[tr.num_mirror_entities].chain = psurf->info;

	mov	eax, DWORD PTR _tr+17608
	mov	ecx, DWORD PTR _psurf$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR _tr[eax*8+1228], edx

; 493  : 	}

	jmp	SHORT $LN5@R_FindBmod
$LN6@R_FindBmod:

; 494  : 
; 495  : 	// store new mirror entity
; 496  : 	if( !static_entity && tr.mirror_entities[tr.num_mirror_entities].chain != NULL)

	cmp	DWORD PTR _static_entity$[ebp], 0
	jne	SHORT $LN26@R_FindBmod
	mov	eax, DWORD PTR _tr+17608
	cmp	DWORD PTR _tr[eax*8+1228], 0
	je	SHORT $LN26@R_FindBmod

; 497  : 	{
; 498  : 		tr.mirror_entities[tr.num_mirror_entities].ent = RI.currententity;

	mov	eax, DWORD PTR _tr+17608
	mov	ecx, DWORD PTR _RI+28
	mov	DWORD PTR _tr[eax*8+1224], ecx

; 499  : 		tr.num_mirror_entities++;

	mov	eax, DWORD PTR _tr+17608
	add	eax, 1
	mov	DWORD PTR _tr+17608, eax
$LN26@R_FindBmod:

; 500  : 	}
; 501  : 
; 502  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FindBmodelMirrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_RecursiveMirrorNode
_TEXT	SEGMENT
tv204 = -104						; size = 4
tv168 = -104						; size = 4
tv162 = -104						; size = 4
_p$1 = -36						; size = 4
_dot$ = -32						; size = 4
_side$ = -28						; size = 4
_c$ = -24						; size = 4
_pleaf$ = -20						; size = 4
_mark$ = -16						; size = 4
_surf$ = -12						; size = 4
_clipped$ = -8						; size = 4
_i$ = -4						; size = 4
_node$ = 8						; size = 4
_clipflags$ = 12					; size = 4
_R_RecursiveMirrorNode PROC				; COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 344  : 	int		i, clipped;
; 345  : 	msurface_t	*surf, **mark;
; 346  : 	mleaf_t		*pleaf;
; 347  : 	int		c, side;
; 348  : 	float		dot;
; 349  : 
; 350  : 	if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN11@R_Recursiv

; 351  : 		return; // hit a solid leaf

	jmp	$LN1@R_Recursiv
$LN11@R_Recursiv:

; 352  : 
; 353  : 	if( node->visframe != tr.visframecount )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _tr+83188
	je	SHORT $LN12@R_Recursiv

; 354  : 		return;

	jmp	$LN1@R_Recursiv
$LN12@R_Recursiv:

; 355  : 
; 356  : 	if( clipflags )

	cmp	DWORD PTR _clipflags$[ebp], 0
	je	SHORT $LN3@R_Recursiv

; 357  : 	{
; 358  : 		for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Recursiv
$LN2@R_Recursiv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Recursiv:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@R_Recursiv

; 359  : 		{
; 360  : 			const mplane_t	*p = &RI.frustum.planes[i];

	imul	eax, DWORD PTR _i$[ebp], 20
	add	eax, OFFSET _RI+56
	mov	DWORD PTR _p$1[ebp], eax

; 361  : 
; 362  : 			if( !FBitSet( clipflags, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _clipflags$[ebp]
	jne	SHORT $LN14@R_Recursiv

; 363  : 				continue;

	jmp	SHORT $LN2@R_Recursiv
$LN14@R_Recursiv:

; 364  : 
; 365  : 			clipped = BoxOnPlaneSide( node->minmaxs, node->minmaxs + 3, p );

	mov	eax, DWORD PTR _p$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 8
	push	edx
	call	_BoxOnPlaneSide
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clipped$[ebp], eax

; 366  : 			if( clipped == 2 ) return;

	cmp	DWORD PTR _clipped$[ebp], 2
	jne	SHORT $LN15@R_Recursiv
	jmp	$LN1@R_Recursiv
$LN15@R_Recursiv:

; 367  : 			if( clipped == 1 ) ClearBits( clipflags, BIT( i ));

	cmp	DWORD PTR _clipped$[ebp], 1
	jne	SHORT $LN16@R_Recursiv
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR _clipflags$[ebp]
	mov	DWORD PTR _clipflags$[ebp], eax
$LN16@R_Recursiv:

; 368  : 		}

	jmp	SHORT $LN2@R_Recursiv
$LN3@R_Recursiv:

; 369  : 	}
; 370  : 
; 371  : 	// if a leaf node, draw stuff
; 372  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN17@R_Recursiv

; 373  : 	{
; 374  : 		pleaf = (mleaf_t *)node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pleaf$[ebp], eax

; 375  : 
; 376  : 		mark = pleaf->firstmarksurface;

	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _mark$[ebp], ecx

; 377  : 		c = pleaf->nummarksurfaces;

	mov	eax, DWORD PTR _pleaf$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _c$[ebp], ecx

; 378  : 
; 379  : 		if( c )

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN6@R_Recursiv
$LN7@R_Recursiv:

; 380  : 		{
; 381  : 			do
; 382  : 			{
; 383  : 				(*mark)->visframe = tr.framecount;

	mov	eax, DWORD PTR _mark$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _tr+83200
	mov	DWORD PTR [ecx], edx

; 384  : 				mark++;

	mov	eax, DWORD PTR _mark$[ebp]
	add	eax, 4
	mov	DWORD PTR _mark$[ebp], eax

; 385  : 			} while( --c );

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	jne	SHORT $LN7@R_Recursiv
$LN6@R_Recursiv:

; 386  : 		}
; 387  : 		return;

	jmp	$LN1@R_Recursiv
$LN17@R_Recursiv:

; 388  : 	}
; 389  : 
; 390  : 	// node is just a decision point, so go down the apropriate sides
; 391  : 
; 392  : 	// find which side of the node we are on
; 393  : 	dot = PlaneDiff( tr.modelorg, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN22@R_Recursiv
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	movss	xmm0, DWORD PTR _tr[edx*4+87596]
	movss	DWORD PTR tv162[ebp], xmm0
	jmp	SHORT $LN23@R_Recursiv
$LN22@R_Recursiv:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _tr[ecx+87596]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _tr[eax+87596]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _tr[edx+87596]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv162[ebp], xmm0
$LN23@R_Recursiv:
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR tv162[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _dot$[ebp], xmm0

; 394  : 	side = (dot >= 0) ? 0 : 1;

	movss	xmm0, DWORD PTR _dot$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN24@R_Recursiv
	mov	DWORD PTR tv168[ebp], 0
	jmp	SHORT $LN25@R_Recursiv
$LN24@R_Recursiv:
	mov	DWORD PTR tv168[ebp], 1
$LN25@R_Recursiv:
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 395  : 
; 396  : 	// recurse down the children, front side first
; 397  : 	R_RecursiveMirrorNode( node->children[side], clipflags );

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _side$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	call	_R_RecursiveMirrorNode
	add	esp, 8

; 398  : 
; 399  : 	// draw stuff
; 400  : 	for( c = node->numsurfaces, surf = cl.worldmodel->surfaces + node->firstsurface; c; c--, surf++ )

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movzx	eax, WORD PTR [edx+48]
	imul	ecx, eax, 92
	mov	edx, DWORD PTR _cl+4579004
	add	ecx, DWORD PTR [edx+180]
	mov	DWORD PTR _surf$[ebp], ecx
	jmp	SHORT $LN10@R_Recursiv
$LN8@R_Recursiv:
	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN10@R_Recursiv:
	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN9@R_Recursiv

; 401  : 	{
; 402  : 		if( !FBitSet( surf->flags, SURF_REFLECT ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN19@R_Recursiv

; 403  : 			continue;

	jmp	SHORT $LN8@R_Recursiv
$LN19@R_Recursiv:

; 404  : 
; 405  : 		if( R_CullSurface( surf, &RI.frustum, clipflags ))

	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	push	OFFSET _RI+56
	mov	ecx, DWORD PTR _surf$[ebp]
	push	ecx
	call	_R_CullSurface
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@R_Recursiv

; 406  : 			continue;

	jmp	SHORT $LN8@R_Recursiv
$LN20@R_Recursiv:

; 407  : 
; 408  : 		surf->info->mirrorchain = tr.mirror_entities[0].chain;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _tr[ecx+1228]
	mov	DWORD PTR [eax+104], ecx

; 409  : 		tr.mirror_entities[0].chain = surf->info;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _tr[ecx+1228], eax

; 410  : 	}

	jmp	SHORT $LN8@R_Recursiv
$LN9@R_Recursiv:

; 411  : 
; 412  : 	// recurse down the back side
; 413  : 	R_RecursiveMirrorNode( node->children[!side], clipflags );

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN26@R_Recursiv
	mov	DWORD PTR tv204[ebp], 1
	jmp	SHORT $LN27@R_Recursiv
$LN26@R_Recursiv:
	mov	DWORD PTR tv204[ebp], 0
$LN27@R_Recursiv:
	mov	eax, DWORD PTR _clipflags$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv204[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	push	eax
	call	_R_RecursiveMirrorNode
	add	esp, 8
$LN1@R_Recursiv:

; 414  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RecursiveMirrorNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_AllocateMirrorTexture
_TEXT	SEGMENT
_txName$ = -64						; size = 16
_texture$ = -48						; size = 4
_i$ = -44						; size = 4
_r_screen$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
_R_AllocateMirrorTexture PROC				; COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 134  : 	rgbdata_t	r_screen;
; 135  : 	int	i, texture;
; 136  : 	char	txName[16];
; 137  : 
; 138  : 	i = tr.num_mirrors_used;

	mov	eax, DWORD PTR _tr+1212
	mov	DWORD PTR _i$[ebp], eax

; 139  : 	if( i >= MAX_MIRRORS )

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jl	SHORT $LN2@R_Allocate

; 140  : 	{
; 141  : 		//MsgDev( D_ERROR, "R_AllocateMirrorTexture: mirror textures limit exceeded!\n" );
; 142  : 		return 0;	// disable

	xor	eax, eax
	jmp	$LN1@R_Allocate
$LN2@R_Allocate:

; 143  : 	}
; 144  : 
; 145  : 	texture = tr.mirrorTextures[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+1084]
	mov	DWORD PTR _texture$[ebp], ecx

; 146  : 	tr.num_mirrors_used++;

	mov	eax, DWORD PTR _tr+1212
	add	eax, 1
	mov	DWORD PTR _tr+1212, eax

; 147  : 
; 148  : 	if( !texture )

	cmp	DWORD PTR _texture$[ebp], 0
	jne	$LN3@R_Allocate

; 149  : 	{
; 150  : 		// not initialized ?
; 151  : 		memset( &r_screen, 0, sizeof( r_screen ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _r_screen$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 152  : 		Q_snprintf( txName, sizeof( txName ), "*screen%i", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_09PABMCPNL@?$CKscreen?$CFi@
	push	16					; 00000010H
	lea	ecx, DWORD PTR _txName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 153  : 
; 154  : 		r_screen.width = RI.viewport[2];

	mov	eax, 4
	shl	eax, 1
	mov	cx, WORD PTR _RI[eax+40]
	mov	WORD PTR _r_screen$[ebp], cx

; 155  : 		r_screen.height = RI.viewport[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	dx, WORD PTR _RI[ecx+40]
	mov	WORD PTR _r_screen$[ebp+2], dx

; 156  : 		r_screen.type = PF_RGBA_32;

	mov	DWORD PTR _r_screen$[ebp+8], 3

; 157  : 		r_screen.size = r_screen.width * r_screen.height * 4;

	movzx	eax, WORD PTR _r_screen$[ebp]
	movzx	ecx, WORD PTR _r_screen$[ebp+2]
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _r_screen$[ebp+32], eax

; 158  : 		r_screen.flags = IMAGE_HAS_COLOR;

	mov	DWORD PTR _r_screen$[ebp+12], 4

; 159  : 		r_screen.buffer = NULL; // create empty texture for now

	mov	DWORD PTR _r_screen$[ebp+24], 0

; 160  : 		tr.mirrorTextures[i] = GL_LoadTextureInternal( txName, &r_screen, TF_IMAGE, false );

	push	0
	push	6144					; 00001800H
	lea	eax, DWORD PTR _r_screen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _txName$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[edx*4+1084], eax

; 161  : 		texture = tr.mirrorTextures[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*4+1084]
	mov	DWORD PTR _texture$[ebp], ecx
$LN3@R_Allocate:

; 162  : 	}
; 163  : 
; 164  : 	GL_Bind( GL_TEXTURE0, texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 165  : 	pglCopyTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, RI.viewport[0], RI.viewport[1], RI.viewport[2], RI.viewport[3], 0 );

	push	0
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _RI[ecx+40]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[eax+40]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _RI[edx+40]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _RI[edx+40]
	push	eax
	push	6407					; 00001907H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglCopyTexImage2D

; 166  : 
; 167  : 	return texture;

	mov	eax, DWORD PTR _texture$[ebp]
$LN1@R_Allocate:

; 168  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AllocateMirrorTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_PlaneForMirror
_TEXT	SEGMENT
tv95 = -96						; size = 4
_tmp$1 = -28						; size = 20
_ent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_surf$ = 8						; size = 4
_out$ = 12						; size = 4
_m$ = 16						; size = 4
_R_PlaneForMirror PROC					; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 95   : 	cl_entity_t	*ent;
; 96   : 
; 97   : 	ASSERT( out != NULL );

	cmp	DWORD PTR _out$[ebp], 0
	jne	SHORT $LN2@R_PlaneFor
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_PlaneForMirror@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@R_PlaneFor:

; 98   : 
; 99   : 	ent = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _ent$[ebp], eax

; 100  : 
; 101  : 	// setup mirror plane
; 102  : 	*out = *surf->plane;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx

; 103  : 
; 104  : 	if( surf->flags & SURF_PLANEBACK )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	$LN3@R_PlaneFor

; 105  : 	{
; 106  : 		VectorNegate( out->normal, out->normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv95[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 107  : 		out->dist = -out->dist;

	mov	eax, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
$LN3@R_PlaneFor:

; 108  : 	}
; 109  : 
; 110  : 	if( !VectorIsNull( ent->origin ) || !VectorIsNull( ent->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN7@R_PlaneFor
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN7@R_PlaneFor
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@R_PlaneFor
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@R_PlaneFor
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@R_PlaneFor
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@R_PlaneFor
$LN7@R_PlaneFor:

; 111  : 	{
; 112  : 		mplane_t	tmp;
; 113  : 
; 114  : 		if( !VectorIsNull( ent->angles )) Matrix4x4_CreateFromEntity( m, ent->angles, ent->origin, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_PlaneFor
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_PlaneFor
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@R_PlaneFor
$LN10@R_PlaneFor:
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN9@R_PlaneFor
$LN8@R_PlaneFor:

; 115  : 		else Matrix4x4_CreateFromEntity( m, vec3_origin, ent->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	push	OFFSET _vec3_origin
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN9@R_PlaneFor:

; 116  : 
; 117  : 		tmp = *out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tmp$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmp$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _tmp$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _tmp$1[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _tmp$1[ebp+16], eax

; 118  : 
; 119  : 		// transform mirror plane by entity matrix
; 120  : 		Matrix4x4_TransformPositivePlane( m, tmp.normal, tmp.dist, out->normal, &out->dist );

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _tmp$1[ebp+12]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _tmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H

; 121  : 	}

	jmp	SHORT $LN5@R_PlaneFor
$LN4@R_PlaneFor:

; 122  : 	else Matrix4x4_LoadIdentity( m );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@R_PlaneFor:

; 123  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PlaneForMirror ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_FindMirrors
_TEXT	SEGMENT
_R_FindMirrors PROC					; COMDAT

; 588  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 589  : 	if( !world.has_mirrors || RI.drawOrtho || !RI.drawWorld || RI.onlyClientDraw || !cl.worldmodel )

	cmp	DWORD PTR _world+4, 0
	je	SHORT $LN3@R_FindMirr
	cmp	DWORD PTR _RI+16, 0
	jne	SHORT $LN3@R_FindMirr
	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN3@R_FindMirr
	cmp	DWORD PTR _RI+12, 0
	jne	SHORT $LN3@R_FindMirr
	cmp	DWORD PTR _cl+4579004, 0
	jne	SHORT $LN2@R_FindMirr
$LN3@R_FindMirr:

; 590  : 		return;

	jmp	$LN1@R_FindMirr
$LN2@R_FindMirr:

; 591  : 
; 592  : 	// NOTE: we already has initial params at this point like vieworg, viewangles
; 593  : 	// all other will be sets into R_SetupFrustum
; 594  : 	R_FindViewLeaf ();

	call	_R_FindViewLeaf

; 595  : 
; 596  : 	// player is outside world. Don't update mirrors for speedup reasons
; 597  : 	if(( RI.viewleaf - cl.worldmodel->leafs - 1 ) == -1 )

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR _RI+180
	sub	ecx, DWORD PTR [eax+140]
	mov	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	sub	eax, 1
	cmp	eax, -1
	jne	SHORT $LN4@R_FindMirr

; 598  : 		return;

	jmp	$LN1@R_FindMirr
$LN4@R_FindMirr:

; 599  : 
; 600  : 	R_SetupFrustum ();

	call	_R_SetupFrustum

; 601  : 	R_MarkLeaves ();

	call	_R_MarkLeaves

; 602  : 
; 603  : 	VectorCopy( RI.cullorigin, tr.modelorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+260]
	mov	DWORD PTR _tr[eax+87596], ecx

; 604  : 	RI.currententity = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _RI+28, eax

; 605  : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 606  : 
; 607  : 	R_RecursiveMirrorNode( cl.worldmodel->nodes, RI.frustum.clipFlags );

	mov	eax, DWORD PTR _RI+176
	push	eax
	mov	ecx, DWORD PTR _cl+4579004
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	_R_RecursiveMirrorNode
	add	esp, 8

; 608  : 
; 609  : 	R_CheckEntitiesOnList();

	call	_R_CheckEntitiesOnList
$LN1@R_FindMirr:

; 610  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FindMirrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_DrawMirrors
_TEXT	SEGMENT
tv654 = -5616						; size = 4
tv642 = -5616						; size = 4
tv616 = -5616						; size = 4
tv604 = -5616						; size = 4
tv653 = -5612						; size = 4
tv641 = -5612						; size = 4
tv615 = -5612						; size = 4
tv603 = -5612						; size = 4
tv577 = -5612						; size = 4
tv549 = -5612						; size = 4
tv427 = -5612						; size = 4
tv345 = -5612						; size = 4
tv263 = -5612						; size = 4
tv220 = -5612						; size = 4
_ilength$1 = -5096					; size = 4
_ilength$2 = -5092					; size = 4
_ilength$3 = -5088					; size = 4
_d$ = -5084						; size = 4
_m$ = -5080						; size = 4
_e$ = -5076						; size = 4
_mirrormatrix$ = -5072					; size = 64
_angles$ = -5008					; size = 12
_origin$ = -4996					; size = 12
_up$ = -4984						; size = 12
_right$ = -4972						; size = 12
_forward$ = -4960					; size = 12
_mirrorchain$ = -4948					; size = 4
_tmp$ = -4944						; size = 4
_es$ = -4940						; size = 4
_oldframecount$ = -4936					; size = 4
_i$ = -4932						; size = 4
_surf2$ = -4928						; size = 4
_surf$ = -4924						; size = 4
_plane$ = -4920						; size = 20
_oldRI$ = -4900						; size = 4896
__$ArrayPad$ = -4					; size = 4
_R_DrawMirrors PROC					; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5616				; 000015f0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 180  : 	ref_instance_t	oldRI;
; 181  : 	mplane_t		plane;
; 182  : 	msurface_t	*surf, *surf2;
; 183  : 	int		i, oldframecount;
; 184  : 	mextrasurf_t	*es, *tmp, *mirrorchain;
; 185  : 	vec3_t		forward, right, up;
; 186  : 	vec3_t		origin, angles;
; 187  : 	matrix4x4		mirrormatrix;
; 188  : 	cl_entity_t	*e;
; 189  : 	model_t		*m;
; 190  : 	float		d;
; 191  : 
; 192  : 	if( !tr.num_mirror_entities ) return; // mo mirrors for this frame

	cmp	DWORD PTR _tr+17608, 0
	jne	SHORT $LN14@R_DrawMirr
	jmp	$LN1@R_DrawMirr
$LN14@R_DrawMirr:

; 193  : 
; 194  : 	oldRI = RI; // make refinst backup

	push	4896					; 00001320H
	push	OFFSET _RI
	lea	eax, DWORD PTR _oldRI$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 195  : 	oldframecount = tr.framecount;

	mov	eax, DWORD PTR _tr+83200
	mov	DWORD PTR _oldframecount$[ebp], eax

; 196  : 
; 197  : 	for( i = 0; i < tr.num_mirror_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawMirr
$LN2@R_DrawMirr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawMirr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tr+17608
	jae	$LN3@R_DrawMirr

; 198  : 	{
; 199  : 		mirrorchain = tr.mirror_entities[i].chain;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*8+1228]
	mov	DWORD PTR _mirrorchain$[ebp], ecx

; 200  : 
; 201  : 		for( es = mirrorchain; es != NULL; es = es->mirrorchain )

	mov	eax, DWORD PTR _mirrorchain$[ebp]
	mov	DWORD PTR _es$[ebp], eax
	jmp	SHORT $LN7@R_DrawMirr
$LN5@R_DrawMirr:
	mov	eax, DWORD PTR _es$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _es$[ebp], ecx
$LN7@R_DrawMirr:
	cmp	DWORD PTR _es$[ebp], 0
	je	$LN6@R_DrawMirr

; 202  : 		{
; 203  : 			RI.currententity = e = tr.mirror_entities[i].ent;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _tr[eax*8+1224]
	mov	DWORD PTR _e$[ebp], ecx
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _RI+28, edx

; 204  : 			RI.currentmodel = m = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _m$[ebp], ecx
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR _RI+32, edx

; 205  : 
; 206  : 			surf = es->surf;

	mov	eax, DWORD PTR _es$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _surf$[ebp], ecx

; 207  : 
; 208  : 			ASSERT( RI.currententity != NULL );

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN15@R_DrawMirr
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawMirrors@@9@9
	add	eax, 29					; 0000001dH
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN15@R_DrawMirr:

; 209  : 			ASSERT( RI.currentmodel != NULL );

	cmp	DWORD PTR _RI+32, 0
	jne	SHORT $LN16@R_DrawMirr
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_DrawMirrors@@9@9
	add	eax, 30					; 0000001eH
	push	eax
	push	OFFSET ??_C@_0DG@FDICEAPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN16@R_DrawMirr:

; 210  : 
; 211  : 			// NOTE: copy mirrortexture and mirrormatrix from another surfaces
; 212  : 			// from this entity\world that has same planes and reduce number of viewpasses
; 213  : 
; 214  : 			// make sure what we have one pass at least
; 215  : 			if( es != mirrorchain )

	mov	eax, DWORD PTR _es$[ebp]
	cmp	eax, DWORD PTR _mirrorchain$[ebp]
	je	$LN22@R_DrawMirr

; 216  : 			{
; 217  : 				for( tmp = mirrorchain; tmp != es; tmp = tmp->mirrorchain )

	mov	eax, DWORD PTR _mirrorchain$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax
	jmp	SHORT $LN10@R_DrawMirr
$LN8@R_DrawMirr:
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _tmp$[ebp], ecx
$LN10@R_DrawMirr:
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _es$[ebp]
	je	$LN9@R_DrawMirr

; 218  : 				{
; 219  : 					surf2 = tmp->surf;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _surf2$[ebp], ecx

; 220  : 
; 221  : 					if( !tmp->mirrortexturenum )

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jne	SHORT $LN18@R_DrawMirr

; 222  : 						continue;	// not filled?

	jmp	SHORT $LN8@R_DrawMirr
$LN18@R_DrawMirr:

; 223  : 
; 224  : 					if( surf->plane->dist != surf2->plane->dist )

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _surf2$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR [eax+12]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@R_DrawMirr

; 225  : 						continue;

	jmp	SHORT $LN8@R_DrawMirr
$LN19@R_DrawMirr:

; 226  : 
; 227  : 					if( !VectorCompare( surf->plane->normal, surf2->plane->normal ))

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _surf2$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR [edx+esi]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_DrawMirr
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _surf2$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	ucomiss	xmm0, DWORD PTR [eax+esi]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_DrawMirr
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf2$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	ucomiss	xmm0, DWORD PTR [eax+esi]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@R_DrawMirr
$LN21@R_DrawMirr:

; 228  : 						continue;

	jmp	$LN8@R_DrawMirr
$LN20@R_DrawMirr:

; 229  : 
; 230  : 					// found surface with same plane!
; 231  : 					break;

	jmp	SHORT $LN9@R_DrawMirr

; 232  : 				}

	jmp	$LN8@R_DrawMirr
$LN9@R_DrawMirr:

; 233  : 
; 234  : 				if( tmp != es && tmp && tmp->mirrortexturenum )

	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	eax, DWORD PTR _es$[ebp]
	je	SHORT $LN22@R_DrawMirr
	cmp	DWORD PTR _tmp$[ebp], 0
	je	SHORT $LN22@R_DrawMirr
	mov	eax, DWORD PTR _tmp$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $LN22@R_DrawMirr

; 235  : 				{
; 236  : 					// just copy reflection texture from surface with same plane
; 237  : 					Matrix4x4_Copy( es->mirrormatrix, tmp->mirrormatrix );

	push	64					; 00000040H
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	mov	ecx, DWORD PTR _es$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 238  : 					es->mirrortexturenum = tmp->mirrortexturenum;

	mov	eax, DWORD PTR _es$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [eax+116], edx

; 239  : 					continue;	// pass skiped

	jmp	$LN5@R_DrawMirr
$LN22@R_DrawMirr:

; 240  : 				}
; 241  : 			} 
; 242  : 
; 243  : 			R_PlaneForMirror( surf, &plane, mirrormatrix );

	lea	eax, DWORD PTR _mirrormatrix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _plane$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surf$[ebp]
	push	edx
	call	_R_PlaneForMirror
	add	esp, 12					; 0000000cH

; 244  : 
; 245  : 			d = -2.0f * ( DotProduct( RI.vieworg, plane.normal ) - plane.dist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+200]
	mulss	xmm1, DWORD PTR _plane$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+200]
	mulss	xmm1, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _plane$[ebp+12]
	mulss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _d$[ebp], xmm0

; 246  : 			VectorMA( RI.vieworg, d, plane.normal, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	addss	xmm0, DWORD PTR _RI[ecx+200]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, DWORD PTR _RI[eax+200]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	movss	xmm1, DWORD PTR _RI[eax+200]
	addss	xmm1, xmm0
	movss	DWORD PTR tv220[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 247  : 
; 248  : 			d = -2.0f * DotProduct( RI.vforward, plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+224]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+224]
	mulss	xmm1, DWORD PTR _plane$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+224]
	mulss	xmm1, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _d$[ebp], xmm0

; 249  : 			VectorMA( RI.vforward, d, plane.normal, forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	addss	xmm0, DWORD PTR _RI[ecx+224]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _forward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, DWORD PTR _RI[eax+224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _forward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	movss	xmm1, DWORD PTR _RI[eax+224]
	addss	xmm1, xmm0
	movss	DWORD PTR tv263[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv263[ebp]
	movss	DWORD PTR _forward$[ebp+edx], xmm0

; 250  : 			VectorNormalize( forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR _forward$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm1, DWORD PTR _forward$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _forward$[ebp+eax]
	mulss	xmm1, DWORD PTR _forward$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@R_DrawMirr
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN23@R_DrawMirr:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _forward$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _forward$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _forward$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _forward$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _forward$[ebp+ecx], xmm0

; 251  : 
; 252  : 			d = -2.0f * DotProduct( RI.vright, plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+236]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+236]
	mulss	xmm1, DWORD PTR _plane$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+236]
	mulss	xmm1, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _d$[ebp], xmm0

; 253  : 			VectorMA( RI.vright, d, plane.normal, right );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	addss	xmm0, DWORD PTR _RI[ecx+236]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _right$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, DWORD PTR _RI[eax+236]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _right$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	movss	xmm1, DWORD PTR _RI[eax+236]
	addss	xmm1, xmm0
	movss	DWORD PTR tv345[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv345[ebp]
	movss	DWORD PTR _right$[ebp+edx], xmm0

; 254  : 			VectorNormalize( right );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _right$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _right$[ebp+ecx]
	mulss	xmm1, DWORD PTR _right$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _right$[ebp+eax]
	mulss	xmm1, DWORD PTR _right$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@R_DrawMirr
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN24@R_DrawMirr:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _right$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _right$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _right$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _right$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _right$[ebp+ecx], xmm0

; 255  : 
; 256  : 			d = -2.0f * DotProduct( RI.vup, plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+248]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+248]
	mulss	xmm1, DWORD PTR _plane$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+248]
	mulss	xmm1, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR _d$[ebp], xmm0

; 257  : 			VectorMA( RI.vup, d, plane.normal, up );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	addss	xmm0, DWORD PTR _RI[ecx+248]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _up$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, DWORD PTR _RI[eax+248]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _up$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _d$[ebp]
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	movss	xmm1, DWORD PTR _RI[eax+248]
	addss	xmm1, xmm0
	movss	DWORD PTR tv427[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv427[ebp]
	movss	DWORD PTR _up$[ebp+edx], xmm0

; 258  : 			VectorNormalize( up );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _up$[ebp+ecx]
	mulss	xmm0, DWORD PTR _up$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _up$[ebp+ecx]
	mulss	xmm1, DWORD PTR _up$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _up$[ebp+eax]
	mulss	xmm1, DWORD PTR _up$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@R_DrawMirr
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN25@R_DrawMirr:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _up$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _up$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _up$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _up$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _up$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _up$[ebp+ecx], xmm0

; 259  : 
; 260  : 			VectorsAngles( forward, right, up, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _up$[ebp]
	push	ecx
	lea	edx, DWORD PTR _right$[ebp]
	push	edx
	lea	eax, DWORD PTR _forward$[ebp]
	push	eax
	call	_VectorsAngles
	add	esp, 16					; 00000010H

; 261  : 			angles[ROLL] = -angles[ROLL];

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _angles$[ebp+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _angles$[ebp+ecx], xmm0

; 262  : 
; 263  : 			RI.params = RP_MIRRORVIEW|RP_CLIPPLANE|RP_OLDVIEWLEAF;

	mov	DWORD PTR _RI, 13			; 0000000dH

; 264  : 			RI.clipPlane = plane;

	mov	eax, DWORD PTR _plane$[ebp]
	mov	DWORD PTR _RI+4876, eax
	mov	ecx, DWORD PTR _plane$[ebp+4]
	mov	DWORD PTR _RI+4880, ecx
	mov	edx, DWORD PTR _plane$[ebp+8]
	mov	DWORD PTR _RI+4884, edx
	mov	eax, DWORD PTR _plane$[ebp+12]
	mov	DWORD PTR _RI+4888, eax
	mov	ecx, DWORD PTR _plane$[ebp+16]
	mov	DWORD PTR _RI+4892, ecx

; 265  : 
; 266  : 			GL_FrustumSetPlane( &RI.frustum, FRUSTUM_NEAR, plane.normal, plane.dist );

	push	ecx
	movss	xmm0, DWORD PTR _plane$[ebp+12]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _plane$[ebp]
	push	eax
	push	5
	push	OFFSET _RI+56
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 267  : 
; 268  : 			RI.viewangles[0] = anglemod( angles[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _angles$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	edx, 4
	imul	eax, edx, 0
	fstp	DWORD PTR _RI[eax+212]

; 269  : 			RI.viewangles[1] = anglemod( angles[1] );

	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _angles$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _RI[ecx+212]

; 270  : 			RI.viewangles[2] = anglemod( angles[2] );

	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _angles$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _RI[ecx+212]

; 271  : 			VectorCopy( origin, RI.vieworg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR _RI[eax+200], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+200], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+200], ecx

; 272  : 			VectorCopy( origin, RI.cullorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR _RI[eax+260], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+260], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+260], ecx

; 273  : 
; 274  : 			// put pvsorigin before the mirror plane to avoid get full visibility on world mirrors
; 275  : 			if( RI.currententity == clgame.entities )

	mov	eax, DWORD PTR _RI+28
	cmp	eax, DWORD PTR _clgame+996
	jne	$LN26@R_DrawMirr

; 276  : 			{
; 277  : 				VectorMA( es->origin, 1.0f, plane.normal, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	edx, DWORD PTR _es$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+24]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	mov	ecx, DWORD PTR _es$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx+24]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	mov	edx, DWORD PTR _es$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+24]
	addss	xmm1, xmm0
	movss	DWORD PTR tv549[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv549[ebp]
	movss	DWORD PTR _origin$[ebp+eax], xmm0

; 278  : 			}

	jmp	$LN27@R_DrawMirr
$LN26@R_DrawMirr:

; 279  : 			else
; 280  : 			{
; 281  : 				Matrix4x4_VectorTransform( mirrormatrix, es->origin, origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _es$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	lea	edx, DWORD PTR _mirrormatrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorTransform
	add	esp, 12					; 0000000cH

; 282  : 				VectorMA( origin, 1.0f, plane.normal, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+eax]
	addss	xmm0, DWORD PTR _origin$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	addss	xmm0, DWORD PTR _origin$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR _plane$[ebp+ecx]
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv577[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv577[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0
$LN27@R_DrawMirr:

; 283  : 			}
; 284  : 
; 285  : 			VectorCopy( origin, RI.pvsorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR _RI[eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+188], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR _RI[eax+188], ecx

; 286  : 
; 287  : 			if( GL_Support( GL_ARB_TEXTURE_NPOT_EXT ))

	push	14					; 0000000eH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	$LN28@R_DrawMirr

; 288  : 			{
; 289  : 				// allow screen size
; 290  : 				RI.viewport[2] = bound( 96, RI.viewport[2], 1024 );

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _RI[eax+40], 96		; 00000060H
	jl	SHORT $LN35@R_DrawMirr
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR _RI[ecx+40], 1024		; 00000400H
	jge	SHORT $LN33@R_DrawMirr
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[edx+40]
	mov	DWORD PTR tv603[ebp], eax
	jmp	SHORT $LN34@R_DrawMirr
$LN33@R_DrawMirr:
	mov	DWORD PTR tv603[ebp], 1024		; 00000400H
$LN34@R_DrawMirr:
	mov	ecx, DWORD PTR tv603[ebp]
	mov	DWORD PTR tv604[ebp], ecx
	jmp	SHORT $LN36@R_DrawMirr
$LN35@R_DrawMirr:
	mov	DWORD PTR tv604[ebp], 96		; 00000060H
$LN36@R_DrawMirr:
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR tv604[ebp]
	mov	DWORD PTR _RI[edx+40], eax

; 291  : 				RI.viewport[3] = bound( 72, RI.viewport[3], 768 );

	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _RI[ecx+40], 72		; 00000048H
	jl	SHORT $LN39@R_DrawMirr
	mov	edx, 4
	imul	eax, edx, 3
	cmp	DWORD PTR _RI[eax+40], 768		; 00000300H
	jge	SHORT $LN37@R_DrawMirr
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _RI[edx+40]
	mov	DWORD PTR tv615[ebp], eax
	jmp	SHORT $LN38@R_DrawMirr
$LN37@R_DrawMirr:
	mov	DWORD PTR tv615[ebp], 768		; 00000300H
$LN38@R_DrawMirr:
	mov	ecx, DWORD PTR tv615[ebp]
	mov	DWORD PTR tv616[ebp], ecx
	jmp	SHORT $LN40@R_DrawMirr
$LN39@R_DrawMirr:
	mov	DWORD PTR tv616[ebp], 72		; 00000048H
$LN40@R_DrawMirr:
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR tv616[ebp]
	mov	DWORD PTR _RI[eax+40], ecx

; 292  : 			}

	jmp	$LN29@R_DrawMirr
$LN28@R_DrawMirr:

; 293  : 			else
; 294  : 			{
; 295  : 				RI.viewport[2] = NearestPOW( RI.viewport[2], true );

	push	1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[eax+40]
	push	ecx
	call	_NearestPOW
	add	esp, 8
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _RI[edx+40], eax

; 296  : 				RI.viewport[3] = NearestPOW( RI.viewport[3], true );

	push	1
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _RI[ecx+40]
	push	edx
	call	_NearestPOW
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	DWORD PTR _RI[edx+40], eax

; 297  : 				RI.viewport[2] = bound( 128, RI.viewport[2], 1024 );

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _RI[eax+40], 128		; 00000080H
	jl	SHORT $LN43@R_DrawMirr
	mov	ecx, 4
	shl	ecx, 1
	cmp	DWORD PTR _RI[ecx+40], 1024		; 00000400H
	jge	SHORT $LN41@R_DrawMirr
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _RI[edx+40]
	mov	DWORD PTR tv641[ebp], eax
	jmp	SHORT $LN42@R_DrawMirr
$LN41@R_DrawMirr:
	mov	DWORD PTR tv641[ebp], 1024		; 00000400H
$LN42@R_DrawMirr:
	mov	ecx, DWORD PTR tv641[ebp]
	mov	DWORD PTR tv642[ebp], ecx
	jmp	SHORT $LN44@R_DrawMirr
$LN43@R_DrawMirr:
	mov	DWORD PTR tv642[ebp], 128		; 00000080H
$LN44@R_DrawMirr:
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR tv642[ebp]
	mov	DWORD PTR _RI[edx+40], eax

; 298  : 				RI.viewport[3] = bound( 64, RI.viewport[3], 512 );

	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _RI[ecx+40], 64		; 00000040H
	jl	SHORT $LN47@R_DrawMirr
	mov	edx, 4
	imul	eax, edx, 3
	cmp	DWORD PTR _RI[eax+40], 512		; 00000200H
	jge	SHORT $LN45@R_DrawMirr
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _RI[edx+40]
	mov	DWORD PTR tv653[ebp], eax
	jmp	SHORT $LN46@R_DrawMirr
$LN45@R_DrawMirr:
	mov	DWORD PTR tv653[ebp], 512		; 00000200H
$LN46@R_DrawMirr:
	mov	ecx, DWORD PTR tv653[ebp]
	mov	DWORD PTR tv654[ebp], ecx
	jmp	SHORT $LN48@R_DrawMirr
$LN47@R_DrawMirr:
	mov	DWORD PTR tv654[ebp], 64		; 00000040H
$LN48@R_DrawMirr:
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR tv654[ebp]
	mov	DWORD PTR _RI[eax+40], ecx
$LN29@R_DrawMirr:

; 299  : 			}
; 300  : 
; 301  : 			R_RenderScene();

	call	_R_RenderScene

; 302  : 			r_stats.c_mirror_passes++;

	mov	eax, DWORD PTR _r_stats+64
	add	eax, 1
	mov	DWORD PTR _r_stats+64, eax

; 303  : 
; 304  : 			es->mirrortexturenum = R_AllocateMirrorTexture();

	call	_R_AllocateMirrorTexture
	mov	ecx, DWORD PTR _es$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 305  : 
; 306  : 			// create personal projection matrix for mirror
; 307  : 			if( VectorIsNull( e->origin ) && VectorIsNull( e->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN30@R_DrawMirr
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN30@R_DrawMirr
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3224]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN30@R_DrawMirr
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@R_DrawMirr
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@R_DrawMirr
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@R_DrawMirr

; 308  : 			{
; 309  : 				Matrix4x4_Copy( es->mirrormatrix, RI.worldviewProjectionMatrix );

	push	64					; 00000040H
	push	OFFSET _RI+712
	mov	eax, DWORD PTR _es$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 310  : 			}

	jmp	SHORT $LN31@R_DrawMirr
$LN30@R_DrawMirr:

; 311  : 			else
; 312  : 			{
; 313  : 				Matrix4x4_ConcatTransforms( RI.modelviewMatrix, RI.worldviewMatrix, mirrormatrix );

	lea	eax, DWORD PTR _mirrormatrix$[ebp]
	push	eax
	push	OFFSET _RI+520
	push	OFFSET _RI+584
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 314  : 				Matrix4x4_Concat( es->mirrormatrix, RI.projectionMatrix, RI.modelviewMatrix );

	push	OFFSET _RI+584
	push	OFFSET _RI+648
	mov	eax, DWORD PTR _es$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	call	_Matrix4x4_Concat
	add	esp, 12					; 0000000cH
$LN31@R_DrawMirr:

; 315  : 			}			
; 316  : 
; 317  : 			RI = oldRI; // restore ref instance

	push	4896					; 00001320H
	lea	eax, DWORD PTR _oldRI$[ebp]
	push	eax
	push	OFFSET _RI
	call	_memcpy
	add	esp, 12					; 0000000cH

; 318  : 		}

	jmp	$LN5@R_DrawMirr
$LN6@R_DrawMirr:

; 319  : 
; 320  : 		// clear chain for this entity
; 321  : 		for( es = mirrorchain; es != NULL; )

	mov	eax, DWORD PTR _mirrorchain$[ebp]
	mov	DWORD PTR _es$[ebp], eax
$LN11@R_DrawMirr:
	cmp	DWORD PTR _es$[ebp], 0
	je	SHORT $LN12@R_DrawMirr

; 322  : 		{
; 323  : 			tmp = es->mirrorchain;

	mov	eax, DWORD PTR _es$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _tmp$[ebp], ecx

; 324  : 			es->mirrorchain = NULL;

	mov	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR [eax+104], 0

; 325  : 			es = tmp;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR _es$[ebp], eax

; 326  : 		}

	jmp	SHORT $LN11@R_DrawMirr
$LN12@R_DrawMirr:

; 327  : 
; 328  : 		tr.mirror_entities[i].chain = NULL; // done

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[eax*8+1228], 0

; 329  : 		tr.mirror_entities[i].ent = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _tr[eax*8+1224], 0

; 330  : 	}

	jmp	$LN2@R_DrawMirr
$LN3@R_DrawMirr:

; 331  : 
; 332  : 	RI.viewleaf = NULL;		// force markleafs next frame

	mov	DWORD PTR _RI+180, 0

; 333  : 	tr.num_mirror_entities = 0;

	mov	DWORD PTR _tr+17608, 0

; 334  : 	tr.num_mirrors_used = 0;

	mov	DWORD PTR _tr+1212, 0
$LN1@R_DrawMirr:

; 335  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawMirrors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_EndDrawMirror
_TEXT	SEGMENT
_R_EndDrawMirror PROC					; COMDAT

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 75   : 	GL_CleanUpTextureUnits( 0 );

	push	0
	call	_GL_CleanUpTextureUnits
	add	esp, 4

; 76   : 	pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_EndDrawMirror ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_mirror.c
;	COMDAT _R_BeginDrawMirror
_TEXT	SEGMENT
tv147 = -332						; size = 4
tv140 = -332						; size = 4
tv133 = -332						; size = 4
tv94 = -332						; size = 4
_i$ = -264						; size = 4
_genVector$ = -260					; size = 64
_matrix$ = -196						; size = 64
_m2$ = -132						; size = 64
_m1$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_fa$ = 8						; size = 4
_R_BeginDrawMirror PROC					; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 31   : 	matrix4x4		m1, m2, matrix;
; 32   : 	GLfloat		genVector[4][4];
; 33   : 	int		i;
; 34   : 
; 35   : 	Matrix4x4_Copy( matrix, fa->info->mirrormatrix );

	push	64					; 00000040H
	mov	eax, DWORD PTR _fa$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 120				; 00000078H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 36   : 
; 37   : 	Matrix4x4_LoadIdentity( m1 );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	lea	eax, DWORD PTR _m1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 38   : 	Matrix4x4_ConcatScale( m1, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _m1$[ebp]
	push	eax
	call	_Matrix4x4_ConcatScale
	add	esp, 8

; 39   : 	Matrix4x4_Concat( m2, m1, matrix );

	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _m2$[ebp]
	push	edx
	call	_Matrix4x4_Concat
	add	esp, 12					; 0000000cH

; 40   : 
; 41   : 	Matrix4x4_LoadIdentity( m1 );

	push	64					; 00000040H
	push	OFFSET _matrix4x4_identity
	lea	eax, DWORD PTR _m1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 42   : 	Matrix4x4_ConcatTranslate( m1, 0.5f, 0.5f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _m1$[ebp]
	push	eax
	call	_Matrix4x4_ConcatTranslate
	add	esp, 16					; 00000010H

; 43   : 	Matrix4x4_Concat( matrix, m1, m2 );

	lea	eax, DWORD PTR _m2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_Concat
	add	esp, 12					; 0000000cH

; 44   : 
; 45   : 	for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BeginDra
$LN2@R_BeginDra:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_BeginDra:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@R_BeginDra

; 46   : 	{
; 47   : 		genVector[0][i] = i == 0 ? 1 : 0;

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN6@R_BeginDra
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN7@R_BeginDra
$LN6@R_BeginDra:
	mov	DWORD PTR tv94[ebp], 0
$LN7@R_BeginDra:
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _genVector$[ebp+ecx]
	cvtsi2ss xmm0, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR [edx+eax*4], xmm0

; 48   : 		genVector[1][i] = i == 1 ? 1 : 0;

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN8@R_BeginDra
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN9@R_BeginDra
$LN8@R_BeginDra:
	mov	DWORD PTR tv133[ebp], 0
$LN9@R_BeginDra:
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _genVector$[ebp+eax]
	cvtsi2ss xmm0, DWORD PTR tv133[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR [ecx+edx*4], xmm0

; 49   : 		genVector[2][i] = i == 2 ? 1 : 0;

	cmp	DWORD PTR _i$[ebp], 2
	jne	SHORT $LN10@R_BeginDra
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN11@R_BeginDra
$LN10@R_BeginDra:
	mov	DWORD PTR tv140[ebp], 0
$LN11@R_BeginDra:
	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _genVector$[ebp+eax]
	cvtsi2ss xmm0, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR [ecx+edx*4], xmm0

; 50   : 		genVector[3][i] = i == 3 ? 1 : 0;

	cmp	DWORD PTR _i$[ebp], 3
	jne	SHORT $LN12@R_BeginDra
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN13@R_BeginDra
$LN12@R_BeginDra:
	mov	DWORD PTR tv147[ebp], 0
$LN13@R_BeginDra:
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _genVector$[ebp+ecx]
	cvtsi2ss xmm0, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR [edx+eax*4], xmm0

; 51   : 	}

	jmp	$LN2@R_BeginDra
$LN3@R_BeginDra:

; 52   : 
; 53   : 	GL_TexGen( GL_S, GL_OBJECT_LINEAR );

	push	9217					; 00002401H
	push	8192					; 00002000H
	call	_GL_TexGen
	add	esp, 8

; 54   : 	GL_TexGen( GL_T, GL_OBJECT_LINEAR );

	push	9217					; 00002401H
	push	8193					; 00002001H
	call	_GL_TexGen
	add	esp, 8

; 55   : 	GL_TexGen( GL_R, GL_OBJECT_LINEAR );

	push	9217					; 00002401H
	push	8194					; 00002002H
	call	_GL_TexGen
	add	esp, 8

; 56   : 	GL_TexGen( GL_Q, GL_OBJECT_LINEAR );

	push	9217					; 00002401H
	push	8195					; 00002003H
	call	_GL_TexGen
	add	esp, 8

; 57   : 
; 58   : 	pglTexGenfv( GL_S, GL_OBJECT_PLANE, genVector[0] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _genVector$[ebp+ecx]
	push	edx
	push	9473					; 00002501H
	push	8192					; 00002000H
	call	DWORD PTR _pglTexGenfv

; 59   : 	pglTexGenfv( GL_T, GL_OBJECT_PLANE, genVector[1] );

	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR _genVector$[ebp+eax]
	push	ecx
	push	9473					; 00002501H
	push	8193					; 00002001H
	call	DWORD PTR _pglTexGenfv

; 60   : 	pglTexGenfv( GL_R, GL_OBJECT_PLANE, genVector[2] );

	mov	eax, 16					; 00000010H
	shl	eax, 1
	lea	ecx, DWORD PTR _genVector$[ebp+eax]
	push	ecx
	push	9473					; 00002501H
	push	8194					; 00002002H
	call	DWORD PTR _pglTexGenfv

; 61   : 	pglTexGenfv( GL_Q, GL_OBJECT_PLANE, genVector[3] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _genVector$[ebp+ecx]
	push	edx
	push	9473					; 00002501H
	push	8195					; 00002003H
	call	DWORD PTR _pglTexGenfv

; 62   : 
; 63   : 	GL_LoadTexMatrix( matrix );

	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_GL_LoadTexMatrix
	add	esp, 4

; 64   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BeginDrawMirror ENDP
_TEXT	ENDS
END
