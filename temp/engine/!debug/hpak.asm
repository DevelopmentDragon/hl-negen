; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\hpak.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_gp_hpak_queue
_DATA	SEGMENT
COMM	_hpk_maxsize:DWORD
_DATA	ENDS
_BSS	SEGMENT
_gp_hpak_queue DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_hash_pack_header:BYTE:0cH
COMM	_hash_pack_info:QWORD
_DATA	ENDS
PUBLIC	_HPAK_Init
PUBLIC	_HPAK_GetDataPointer
PUBLIC	_HPAK_ResourceForHash
PUBLIC	_HPAK_AddLump
PUBLIC	_HPAK_RemoveLump
PUBLIC	_HPAK_CheckIntegrity
PUBLIC	_HPAK_CheckSize
PUBLIC	_HPAK_FlushHostQueue
PUBLIC	_HPAK_TypeFromIndex
PUBLIC	_HPAK_CreatePak
PUBLIC	_HPAK_ValidatePak
PUBLIC	_HPAK_List_f
PUBLIC	_HPAK_Extract_f
PUBLIC	_HPAK_Remove_f
PUBLIC	_HPAK_Validate_f
PUBLIC	??_C@_05CFEEDGHM@decal@				; `string'
PUBLIC	??_C@_04NHPAFEHJ@skin@				; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_C@_05GFHEIIDD@event@				; `string'
PUBLIC	??_C@_03HBNNNHNM@map@				; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP@				; `string'
PUBLIC	?__LINE__Var@?0??HPAK_AddToQueue@@9@9		; `HPAK_AddToQueue'::`1'::__LINE__Var
PUBLIC	??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CA@MGGIIEOF@HPAK_AddToQueue?3?5data?5?$DN?$DN?5NULL?4?6@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9	; `HPAK_FlushHostQueue'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??HPAK_CreatePak@@9@9		; `HPAK_CreatePak'::`1'::__LINE__Var
PUBLIC	??_C@_04GLEGJMFH@?4hpk@				; `string'
PUBLIC	??_C@_0BD@FCCEKNMA@creating?5HPAK?5?$CFs?4?6@	; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0CM@LOINMBBE@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5can?8@ ; `string'
PUBLIC	??_C@_0DJ@CCEPPLGB@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5bad?5@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_AddLump@@9@9		; `HPAK_AddLump'::`1'::__LINE__Var
PUBLIC	??_C@_0CA@OOGCCJKF@?$FO1Error?3?$FO7?5?$CFs?3?5invalid?5size?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DH@FHINOHLO@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5bad?5ch@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_04DPHKEK@?4hp2@				; `string'
PUBLIC	??_C@_0CM@NCAMNJLL@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5couldn@ ; `string'
PUBLIC	??_C@_0DL@EONNLEF@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5doe@ ; `string'
PUBLIC	??_C@_0DF@ICGFJJEG@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5con@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_Validate@@9@9		; `HPAK_Validate'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@FALHFFBF@?$FO1Error?3?$FO7?5Couldn?8t?5find?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0P@DMOBHCNH@Validating?5?$CFs?6@		; `string'
PUBLIC	??_C@_0EE@HECCAGDG@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0DI@EIKFINKI@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@ODLODENF@?$CD?5of?5Entries?3?5?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0CB@HICGIPAC@?$CD?5Type?5Size?5FileName?5?3?5MD5?5Hash@ ; `string'
PUBLIC	??_C@_0DK@OHECJMHA@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5lu@ ; `string'
PUBLIC	??_C@_0BG@PDHNCGMA@?$CFi?3?5?5?5?5?5?5?$CFs?5?$CFs?5?$CFs?3?5?5?5@ ; `string'
PUBLIC	??_C@_0DH@HOALPJLO@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@BNPLGJD@?$FO1Error?3?$FO7?5failed?6@	; `string'
PUBLIC	??_C@_03JLOMOCCD@OK?6@				; `string'
PUBLIC	??_C@_0CH@BBAGCCLG@Server?3?5Size?5of?5?$CFs?5?$DO?5?$CFf?5MB?0?5del@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_ResourceForHash@@9@9	; `HPAK_ResourceForHash'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??HPAK_ResourceForIndex@@9@9	; `HPAK_ResourceForIndex'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@ ; `string'
PUBLIC	??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@ ; `string'
PUBLIC	??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@ ; `string'
PUBLIC	??_C@_0DC@BNHAELEA@?$FO1Error?3?$FO7?5?$CFs?0?5lump?5with?5index?5@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_GetDataPointer@@9@9	; `HPAK_GetDataPointer'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@GBNIDNEA@?$FO1Error?3?$FO7?5?$CFs?5it?8s?5not?5a?5HPK?5fi@ ; `string'
PUBLIC	??_C@_0DL@NBCLJLCG@?$FO1Error?3?$FO7?5HPAK_GetDataPointer?3@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_RemoveLump@@9@9		; `HPAK_RemoveLump'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@GFBLFEBE@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5open?4?6@ ; `string'
PUBLIC	??_C@_0CD@IJNAGBLD@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5heade@ ; `string'
PUBLIC	??_C@_0CM@DAIBBNDL@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5numbe@ ; `string'
PUBLIC	??_C@_0DP@LDMMCIJC@?$FO3Warning?3?$FO7?5?$CFs?5only?5has?5one?5el@ ; `string'
PUBLIC	??_C@_0DE@MMJKOPBA@?$FO1Error?3?$FO7?5HPAK?5doesn?8t?5contain@ ; `string'
PUBLIC	??_C@_0BL@FHFHEJBB@Removing?5?$CFs?5from?5HPAK?5?$CFs?4?6@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_List_f@@9@9		; `HPAK_List_f'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@NDNLLOHH@Usage?3?5hpklist?5?$DMhpk?$DO?6@ ; `string'
PUBLIC	??_C@_0BC@PJKPCFOA@Contents?5for?5?$CFs?4?6@	; `string'
PUBLIC	??_C@_0BI@JDDENNFE@?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6?5?5?3?5?5?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??HPAK_Extract_f@@9@9		; `HPAK_Extract_f'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@DLGJOOLJ@Usage?3?5hpkextract?5hpkname?5?$FLall?5@ ; `string'
PUBLIC	??_C@_03NFKEKGGK@all@				; `string'
PUBLIC	??_C@_0BP@CKDGLHOF@Extracting?5all?5lumps?5from?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0BM@CBKGMEPD@Extracting?5lump?5?$CFi?5from?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@LPIMAFCF@Extracting?5?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DI@EJEFNAAG@?$FO3Warning?3?$FO7?5Unable?5to?5extract?5@ ; `string'
PUBLIC	??_C@_0BE@LHANBOI@hpklmps?2lmp?$CF04i?4bmp@	; `string'
PUBLIC	??_C@_0CA@PKIIIHAA@Usage?3?5hpkremove?5?$DMhpk?$DO?5?$DMindex?$DO?6@ ; `string'
PUBLIC	??_C@_0CP@OGEFJPNE@?$FO1Error?3?$FO7?5Could?5not?5locate?5res@ ; `string'
PUBLIC	??_C@_0BK@LLCPCGIK@Usage?3?5hpkval?5?$DMfilename?$DO?6@ ; `string'
PUBLIC	??_C@_0CF@DBBBACOF@list?5all?5files?5in?5specified?5HPK@ ; `string'
PUBLIC	??_C@_07BAIAPMBE@hpklist@			; `string'
PUBLIC	??_C@_0CE@MKDFGPML@remove?5specified?5file?5from?5HPK?9@ ; `string'
PUBLIC	??_C@_09MKLICMHH@hpkremove@			; `string'
PUBLIC	??_C@_0BM@FJFCFND@validate?5specified?5HPK?9file@ ; `string'
PUBLIC	??_C@_06PBADBDGC@hpkval@			; `string'
PUBLIC	??_C@_0CK@POANFOFL@extract?5all?5lumps?5from?5specifie@ ; `string'
PUBLIC	??_C@_0L@IAGFDGIJ@hpkextract@			; `string'
PUBLIC	??_C@_0DG@GIDNHDCE@set?5limit?5by?5size?5for?5all?5HPK?9f@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0M@OIFECNNA@hpk_maxsize@			; `string'
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ReplaceExtension:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_Rename:PROC
EXTRN	_FS_FileCopy:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_Log_Printf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0M@OIFECNNA@hpk_maxsize@
CONST	SEGMENT
??_C@_0M@OIFECNNA@hpk_maxsize@ DB 'hpk_maxsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GIDNHDCE@set?5limit?5by?5size?5for?5all?5HPK?9f@
CONST	SEGMENT
??_C@_0DG@GIDNHDCE@set?5limit?5by?5size?5for?5all?5HPK?9f@ DB 'set limit '
	DB	'by size for all HPK-files ( 0 - unlimited )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAGFDGIJ@hpkextract@
CONST	SEGMENT
??_C@_0L@IAGFDGIJ@hpkextract@ DB 'hpkextract', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@POANFOFL@extract?5all?5lumps?5from?5specifie@
CONST	SEGMENT
??_C@_0CK@POANFOFL@extract?5all?5lumps?5from?5specifie@ DB 'extract all l'
	DB	'umps from specified HPK-file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBADBDGC@hpkval@
CONST	SEGMENT
??_C@_06PBADBDGC@hpkval@ DB 'hpkval', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FJFCFND@validate?5specified?5HPK?9file@
CONST	SEGMENT
??_C@_0BM@FJFCFND@validate?5specified?5HPK?9file@ DB 'validate specified '
	DB	'HPK-file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MKLICMHH@hpkremove@
CONST	SEGMENT
??_C@_09MKLICMHH@hpkremove@ DB 'hpkremove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MKDFGPML@remove?5specified?5file?5from?5HPK?9@
CONST	SEGMENT
??_C@_0CE@MKDFGPML@remove?5specified?5file?5from?5HPK?9@ DB 'remove speci'
	DB	'fied file from HPK-file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BAIAPMBE@hpklist@
CONST	SEGMENT
??_C@_07BAIAPMBE@hpklist@ DB 'hpklist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DBBBACOF@list?5all?5files?5in?5specified?5HPK@
CONST	SEGMENT
??_C@_0CF@DBBBACOF@list?5all?5files?5in?5specified?5HPK@ DB 'list all fil'
	DB	'es in specified HPK-file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LLCPCGIK@Usage?3?5hpkval?5?$DMfilename?$DO?6@
CONST	SEGMENT
??_C@_0BK@LLCPCGIK@Usage?3?5hpkval?5?$DMfilename?$DO?6@ DB 'Usage: hpkval'
	DB	' <filename>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OGEFJPNE@?$FO1Error?3?$FO7?5Could?5not?5locate?5res@
CONST	SEGMENT
??_C@_0CP@OGEFJPNE@?$FO1Error?3?$FO7?5Could?5not?5locate?5res@ DB '^1Erro'
	DB	'r:^7 Could not locate resource %i in %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PKIIIHAA@Usage?3?5hpkremove?5?$DMhpk?$DO?5?$DMindex?$DO?6@
CONST	SEGMENT
??_C@_0CA@PKIIIHAA@Usage?3?5hpkremove?5?$DMhpk?$DO?5?$DMindex?$DO?6@ DB 'U'
	DB	'sage: hpkremove <hpk> <index>', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHANBOI@hpklmps?2lmp?$CF04i?4bmp@
CONST	SEGMENT
??_C@_0BE@LHANBOI@hpklmps?2lmp?$CF04i?4bmp@ DB 'hpklmps\lmp%04i.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EJEFNAAG@?$FO3Warning?3?$FO7?5Unable?5to?5extract?5@
CONST	SEGMENT
??_C@_0DI@EJEFNAAG@?$FO3Warning?3?$FO7?5Unable?5to?5extract?5@ DB '^3Warn'
	DB	'ing:^7 Unable to extract data, size invalid:  %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LPIMAFCF@Extracting?5?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6@
CONST	SEGMENT
??_C@_0BL@LPIMAFCF@Extracting?5?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6@ DB 'Extr'
	DB	'acting %i: %10s %s %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CBKGMEPD@Extracting?5lump?5?$CFi?5from?5?$CFs?6@
CONST	SEGMENT
??_C@_0BM@CBKGMEPD@Extracting?5lump?5?$CFi?5from?5?$CFs?6@ DB 'Extracting'
	DB	' lump %i from %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CKDGLHOF@Extracting?5all?5lumps?5from?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BP@CKDGLHOF@Extracting?5all?5lumps?5from?5?$CFs?4?6@ DB 'Extractin'
	DB	'g all lumps from %s.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NFKEKGGK@all@
CONST	SEGMENT
??_C@_03NFKEKGGK@all@ DB 'all', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DLGJOOLJ@Usage?3?5hpkextract?5hpkname?5?$FLall?5@
CONST	SEGMENT
??_C@_0DA@DLGJOOLJ@Usage?3?5hpkextract?5hpkname?5?$FLall?5@ DB 'Usage: hp'
	DB	'kextract hpkname [all | single index]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_Extract_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_Extract_f@@9@9 DD 03a2H		; `HPAK_Extract_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@JDDENNFE@?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6?5?5?3?5?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@JDDENNFE@?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6?5?5?3?5?5?$CFs?6@ DB '%'
	DB	'i: %10s %s %s', 0aH, '  :  %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PJKPCFOA@Contents?5for?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BC@PJKPCFOA@Contents?5for?5?$CFs?4?6@ DB 'Contents for %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NDNLLOHH@Usage?3?5hpklist?5?$DMhpk?$DO?6@
CONST	SEGMENT
??_C@_0BG@NDNLLOHH@Usage?3?5hpklist?5?$DMhpk?$DO?6@ DB 'Usage: hpklist <h'
	DB	'pk>', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_List_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_List_f@@9@9 DD 0354H		; `HPAK_List_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@FHFHEJBB@Removing?5?$CFs?5from?5HPAK?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BL@FHFHEJBB@Removing?5?$CFs?5from?5HPAK?5?$CFs?4?6@ DB 'Removing %'
	DB	's from HPAK %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MMJKOPBA@?$FO1Error?3?$FO7?5HPAK?5doesn?8t?5contain@
CONST	SEGMENT
??_C@_0DE@MMJKOPBA@?$FO1Error?3?$FO7?5HPAK?5doesn?8t?5contain@ DB '^1Erro'
	DB	'r:^7 HPAK doesn''t contain specified lump: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LDMMCIJC@?$FO3Warning?3?$FO7?5?$CFs?5only?5has?5one?5el@
CONST	SEGMENT
??_C@_0DP@LDMMCIJC@?$FO3Warning?3?$FO7?5?$CFs?5only?5has?5one?5el@ DB '^3'
	DB	'Warning:^7 %s only has one element, so HPAK will be removed', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DAIBBNDL@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5numbe@
CONST	SEGMENT
??_C@_0CM@DAIBBNDL@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5numbe@ DB '^1E'
	DB	'rror:^7 %s has invalid number of lumps.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IJNAGBLD@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5heade@
CONST	SEGMENT
??_C@_0CD@IJNAGBLD@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5heade@ DB '^1E'
	DB	'rror:^7 %s has invalid header.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GFBLFEBE@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5open?4?6@
CONST	SEGMENT
??_C@_0BO@GFBLFEBE@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5open?4?6@ DB '^1E'
	DB	'rror:^7 %s couldn''t open.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_RemoveLump@@9@9 DD 02d8H		; `HPAK_RemoveLump'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DL@NBCLJLCG@?$FO1Error?3?$FO7?5HPAK_GetDataPointer?3@
CONST	SEGMENT
??_C@_0DL@NBCLJLCG@?$FO1Error?3?$FO7?5HPAK_GetDataPointer?3@ DB '^1Error:'
	DB	'^7 HPAK_GetDataPointer: %s has too many lumps %u.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GBNIDNEA@?$FO1Error?3?$FO7?5?$CFs?5it?8s?5not?5a?5HPK?5fi@
CONST	SEGMENT
??_C@_0CE@GBNIDNEA@?$FO1Error?3?$FO7?5?$CFs?5it?8s?5not?5a?5HPK?5fi@ DB '^'
	DB	'1Error:^7 %s it''s not a HPK file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_GetDataPointer@@9@9 DD 0273H	; `HPAK_GetDataPointer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@BNHAELEA@?$FO1Error?3?$FO7?5?$CFs?0?5lump?5with?5index?5@
CONST	SEGMENT
??_C@_0DC@BNHAELEA@?$FO1Error?3?$FO7?5?$CFs?0?5lump?5with?5index?5@ DB '^'
	DB	'1Error:^7 %s, lump with index %i doesn''t exist.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@
CONST	SEGMENT
??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@ DB '^1'
	DB	'Error:^7 %s has too many lumps %u.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@
CONST	SEGMENT
??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@ DB '^1E'
	DB	'rror:^7 %s has invalid version (%i should be %i).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@
CONST	SEGMENT
??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@ DB '^'
	DB	'1Error:^7 %s is not an HPAK file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@ DB '^1E'
	DB	'rror:^7 couldn''t open %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_ResourceForIndex@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_ResourceForIndex@@9@9 DD 0236H	; `HPAK_ResourceForIndex'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_ResourceForHash@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_ResourceForHash@@9@9 DD 01faH	; `HPAK_ResourceForHash'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@BBAGCCLG@Server?3?5Size?5of?5?$CFs?5?$DO?5?$CFf?5MB?0?5del@
CONST	SEGMENT
??_C@_0CH@BBAGCCLG@Server?3?5Size?5of?5?$CFs?5?$DO?5?$CFf?5MB?0?5del@ DB 'S'
	DB	'erver: Size of %s > %f MB, deleting.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JLOMOCCD@OK?6@
CONST	SEGMENT
??_C@_03JLOMOCCD@OK?6@ DB 'OK', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BNPLGJD@?$FO1Error?3?$FO7?5failed?6@
CONST	SEGMENT
??_C@_0BD@BNPLGJD@?$FO1Error?3?$FO7?5failed?6@ DB '^1Error:^7 failed', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HOALPJLO@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
CONST	SEGMENT
??_C@_0DH@HOALPJLO@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ DB '^1Er'
	DB	'ror:^7 HPAK_ValidatePak: %s has invalid checksum.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PDHNCGMA@?$CFi?3?5?5?5?5?5?5?$CFs?5?$CFs?5?$CFs?3?5?5?5@
CONST	SEGMENT
??_C@_0BG@PDHNCGMA@?$CFi?3?5?5?5?5?5?5?$CFs?5?$CFs?5?$CFs?3?5?5?5@ DB '%i'
	DB	':      %s %s %s:   ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OHECJMHA@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5lu@
CONST	SEGMENT
??_C@_0DK@OHECJMHA@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5lu@ DB '^1Error'
	DB	':^7 HPAK_ValidatePak: lump %i has invalid size %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HICGIPAC@?$CD?5Type?5Size?5FileName?5?3?5MD5?5Hash@
CONST	SEGMENT
??_C@_0CB@HICGIPAC@?$CD?5Type?5Size?5FileName?5?3?5MD5?5Hash@ DB '# Type '
	DB	'Size FileName : MD5 Hash', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ODLODENF@?$CD?5of?5Entries?3?5?5?$CFi?6@
CONST	SEGMENT
??_C@_0BD@ODLODENF@?$CD?5of?5Entries?3?5?5?$CFi?6@ DB '# of Entries:  %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EIKFINKI@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
CONST	SEGMENT
??_C@_0DI@EIKFINKI@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ DB '^1Er'
	DB	'ror:^7 HPAK_ValidatePak: %s has too many lumps %u.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@HECCAGDG@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
CONST	SEGMENT
??_C@_0EE@HECCAGDG@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@ DB '^1Er'
	DB	'ror:^7 HPAK_ValidatePak: %s does not have a valid HPAK header'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMOBHCNH@Validating?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@DMOBHCNH@Validating?5?$CFs?6@ DB 'Validating %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FALHFFBF@?$FO1Error?3?$FO7?5Couldn?8t?5find?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BO@FALHFFBF@?$FO1Error?3?$FO7?5Couldn?8t?5find?5?$CFs?4?6@ DB '^1E'
	DB	'rror:^7 Couldn''t find %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_Validate@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_Validate@@9@9 DD 0168H		; `HPAK_Validate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@ICGFJJEG@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5con@
CONST	SEGMENT
??_C@_0DF@ICGFJJEG@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5con@ DB '^1E'
	DB	'rror:^7 HPAK_AddLump: %s contain too many lumps.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EONNLEF@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5doe@
CONST	SEGMENT
??_C@_0DL@EONNLEF@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5doe@ DB '^1Er'
	DB	'ror:^7 HPAK_AddLump: %s does not have a valid header.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NCAMNJLL@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5couldn@
CONST	SEGMENT
??_C@_0CM@NCAMNJLL@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5couldn@ DB '^1Error'
	DB	':^7 HPAK_AddLump: couldn''t open %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DPHKEK@?4hp2@
CONST	SEGMENT
??_C@_04DPHKEK@?4hp2@ DB '.hp2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FHINOHLO@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5bad?5ch@
CONST	SEGMENT
??_C@_0DH@FHINOHLO@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5bad?5ch@ DB '^1Erro'
	DB	'r:^7 HPAK_AddLump: bad checksum for %s. Ignored', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OOGCCJKF@?$FO1Error?3?$FO7?5?$CFs?3?5invalid?5size?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@OOGCCJKF@?$FO1Error?3?$FO7?5?$CFs?3?5invalid?5size?5?$CFs?6@ DB '^'
	DB	'1Error:^7 %s: invalid size %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_AddLump@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_AddLump@@9@9 DD 0c0H		; `HPAK_AddLump'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DJ@CCEPPLGB@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5bad?5@
CONST	SEGMENT
??_C@_0DJ@CCEPPLGB@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5bad?5@ DB '^1Erro'
	DB	'r:^7 HPAK_CreatePak: bad checksum for %s. Ignored', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LOINMBBE@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5can?8@
CONST	SEGMENT
??_C@_0CM@LOINMBBE@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5can?8@ DB '^1Erro'
	DB	'r:^7 HPAK_CreatePak: can''t write %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FCCEKNMA@creating?5HPAK?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BD@FCCEKNMA@creating?5HPAK?5?$CFs?4?6@ DB 'creating HPAK %s.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04GLEGJMFH@?4hpk@
CONST	SEGMENT
??_C@_04GLEGJMFH@?4hpk@ DB '.hpk', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_CreatePak@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_CreatePak@@9@9 DD 056H		; `HPAK_CreatePak'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9 DD 047H	; `HPAK_FlushHostQueue'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CA@MGGIIEOF@HPAK_AddToQueue?3?5data?5?$DN?$DN?5NULL?4?6@
CONST	SEGMENT
??_C@_0CA@MGGIIEOF@HPAK_AddToQueue?3?5data?5?$DN?$DN?5NULL?4?6@ DB 'HPAK_'
	DB	'AddToQueue: data == NULL.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\hpak.c', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??HPAK_AddToQueue@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??HPAK_AddToQueue@@9@9 DD 035H		; `HPAK_AddToQueue'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map@
CONST	SEGMENT
??_C@_03HBNNNHNM@map@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFHEIIDD@event@
CONST	SEGMENT
??_C@_05GFHEIIDD@event@ DB 'event', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHPAFEHJ@skin@
CONST	SEGMENT
??_C@_04NHPAFEHJ@skin@ DB 'skin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFEEDGHM@decal@
CONST	SEGMENT
??_C@_05CFEEDGHM@decal@ DB 'decal', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0466H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02dfH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0258H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0487H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03d6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	06fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	063dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	075dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	023cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0459H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_Validate_f
_TEXT	SEGMENT
_HPAK_Validate_f PROC					; COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1064 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@HPAK_Valid

; 1065 : 	{
; 1066 : 		Con_Printf( S_USAGE "hpkval <filename>\n" );

	push	OFFSET ??_C@_0BK@LLCPCGIK@Usage?3?5hpkval?5?$DMfilename?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1067 : 		return;

	jmp	SHORT $LN1@HPAK_Valid
$LN2@HPAK_Valid:

; 1068 : 	}
; 1069 : 
; 1070 : 	HPAK_Validate( Cmd_Argv( 1 ), false );

	push	0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_Validate
	add	esp, 8
$LN1@HPAK_Valid:

; 1071 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Validate_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_Remove_f
_TEXT	SEGMENT
_resource$ = -140					; size = 136
__$ArrayPad$ = -4					; size = 4
_HPAK_Remove_f PROC					; COMDAT

; 1041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1042 : 	resource_t	resource;
; 1043 : 
; 1044 : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 1045 : 
; 1046 : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN2@HPAK_Remov

; 1047 : 	{
; 1048 : 		Con_Printf( S_USAGE "hpkremove <hpk> <index>\n" );

	push	OFFSET ??_C@_0CA@PKIIIHAA@Usage?3?5hpkremove?5?$DMhpk?$DO?5?$DMindex?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1049 : 		return;

	jmp	SHORT $LN1@HPAK_Remov
$LN2@HPAK_Remov:

; 1050 : 	}
; 1051 : 
; 1052 : 	if( HPAK_ResourceForIndex( Cmd_Argv( 1 ), Q_atoi( Cmd_Argv( 2 )), &resource ))

	lea	eax, DWORD PTR _resource$[ebp]
	push	eax
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_ResourceForIndex
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@HPAK_Remov

; 1053 : 	{
; 1054 : 		HPAK_RemoveLump( Cmd_Argv( 1 ), &resource );

	lea	eax, DWORD PTR _resource$[ebp]
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_HPAK_RemoveLump
	add	esp, 8

; 1055 : 	}

	jmp	SHORT $LN1@HPAK_Remov
$LN3@HPAK_Remov:

; 1056 : 	else
; 1057 : 	{
; 1058 : 		Con_DPrintf( S_ERROR "Could not locate resource %i in %s\n", Q_atoi( Cmd_Argv( 2 )), Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@OGEFJPNE@?$FO1Error?3?$FO7?5Could?5not?5locate?5res@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN1@HPAK_Remov:

; 1059 : 	}
; 1060 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Remove_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_Extract_f
_TEXT	SEGMENT
_f$ = -824						; size = 4
_size$ = -820						; size = 4
_type$ = -816						; size = 4
_nDataSize$ = -812					; size = 4
_pData$ = -808						; size = 4
_nIndex$ = -804						; size = 4
_szFileOut$ = -800					; size = 256
_pakname$ = -544					; size = 256
_lumpname$ = -288					; size = 256
_entry$ = -32						; size = 4
_directory$ = -28					; size = 8
_header$ = -20						; size = 12
_nCurrent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_HPAK_Extract_f PROC					; COMDAT

; 930  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 952				; 000003b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 931  : 	int		nCurrent;
; 932  : 	hpak_header_t	header;
; 933  : 	hpak_info_t	directory;
; 934  : 	hpak_lump_t	*entry;
; 935  : 	string		lumpname;
; 936  : 	string		pakname;
; 937  : 	string		szFileOut;
; 938  : 	int		nIndex;
; 939  : 	byte		*pData;
; 940  : 	int		nDataSize;
; 941  : 	const char	*type;
; 942  : 	const char	*size;
; 943  : 	file_t		*f;
; 944  : 
; 945  : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN5@HPAK_Extra

; 946  : 	{
; 947  : 		Con_Printf( S_USAGE "hpkextract hpkname [all | single index]\n" );

	push	OFFSET ??_C@_0DA@DLGJOOLJ@Usage?3?5hpkextract?5hpkname?5?$FLall?5@
	call	_Con_Printf
	add	esp, 4

; 948  : 		return;

	jmp	$LN1@HPAK_Extra
$LN5@HPAK_Extra:

; 949  : 	}
; 950  : 
; 951  : 	if( !Q_stricmp( Cmd_Argv( 2 ), "all" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03NFKEKGGK@all@
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Extra

; 952  : 	{
; 953  : 		nIndex = -1;

	mov	DWORD PTR _nIndex$[ebp], -1

; 954  : 	}

	jmp	SHORT $LN7@HPAK_Extra
$LN6@HPAK_Extra:

; 955  : 	else
; 956  : 	{
; 957  : 		nIndex = Q_atoi( Cmd_Argv( 2 ) );

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _nIndex$[ebp], eax
$LN7@HPAK_Extra:

; 958  : 	}
; 959  : 
; 960  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 961  : 
; 962  : 	Q_strncpy( pakname, Cmd_Argv( 1 ), sizeof( pakname ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 963  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 964  : 	Con_Printf( "Contents for %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@PJKPCFOA@Contents?5for?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8

; 965  : 
; 966  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 967  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Extra

; 968  : 	{
; 969  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 970  : 		return;

	jmp	$LN1@HPAK_Extra
$LN8@HPAK_Extra:

; 971  : 	}
; 972  : 
; 973  : 	FS_Read( f, &header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 974  : 
; 975  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN9@HPAK_Extra

; 976  : 	{
; 977  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@
	call	_Con_DPrintf
	add	esp, 8

; 978  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 979  : 		return;

	jmp	$LN1@HPAK_Extra
$LN9@HPAK_Extra:

; 980  : 	}
; 981  : 
; 982  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN10@HPAK_Extra

; 983  : 	{
; 984  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 985  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 986  : 		return;

	jmp	$LN1@HPAK_Extra
$LN10@HPAK_Extra:

; 987  : 	}
; 988  : 
; 989  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 990  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 991  : 
; 992  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN12@HPAK_Extra
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN11@HPAK_Extra
$LN12@HPAK_Extra:

; 993  : 	{
; 994  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 995  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 996  : 		return;

	jmp	$LN1@HPAK_Extra
$LN11@HPAK_Extra:

; 997  : 	}
; 998  : 
; 999  : 	if( nIndex == -1 ) Con_Printf( "Extracting all lumps from %s.\n", pakname );

	cmp	DWORD PTR _nIndex$[ebp], -1
	jne	SHORT $LN13@HPAK_Extra
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@CKDGLHOF@Extracting?5all?5lumps?5from?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN14@HPAK_Extra
$LN13@HPAK_Extra:

; 1000 : 	else Con_Printf( "Extracting lump %i from %s\n", nIndex, pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BM@CBKGMEPD@Extracting?5lump?5?$CFi?5from?5?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN14@HPAK_Extra:

; 1001 : 
; 1002 : 	directory.entries = Z_Malloc( directory.count * sizeof( hpak_lump_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Extract_f@@9@9
	add	eax, 72					; 00000048H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 1003 : 	FS_Read( f, directory.entries, directory.count * sizeof( hpak_lump_t ));

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1004 : 
; 1005 : 	for( nCurrent = 0; nCurrent < directory.count; nCurrent++ )

	mov	DWORD PTR _nCurrent$[ebp], 0
	jmp	SHORT $LN4@HPAK_Extra
$LN2@HPAK_Extra:
	mov	eax, DWORD PTR _nCurrent$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurrent$[ebp], eax
$LN4@HPAK_Extra:
	mov	eax, DWORD PTR _nCurrent$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp]
	jge	$LN3@HPAK_Extra

; 1006 : 	{
; 1007 : 		entry = &directory.entries[nCurrent];

	imul	eax, DWORD PTR _nCurrent$[ebp], 144
	add	eax, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], eax

; 1008 : 
; 1009 : 		if( nIndex != -1 && nIndex != nCurrent )

	cmp	DWORD PTR _nIndex$[ebp], -1
	je	SHORT $LN15@HPAK_Extra
	mov	eax, DWORD PTR _nIndex$[ebp]
	cmp	eax, DWORD PTR _nCurrent$[ebp]
	je	SHORT $LN15@HPAK_Extra

; 1010 : 			continue;

	jmp	SHORT $LN2@HPAK_Extra
$LN15@HPAK_Extra:

; 1011 : 
; 1012 : 		COM_FileBase( entry->resource.szFileName, lumpname );

	lea	eax, DWORD PTR _lumpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1013 : 		type = HPAK_TypeFromIndex( entry->resource.type );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_HPAK_TypeFromIndex
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 1014 : 		size = Q_memprint( entry->resource.nDownloadSize );

	push	2
	mov	eax, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 1015 : 
; 1016 : 		Con_Printf( "Extracting %i: %10s %s %s\n", nCurrent + 1, type, size, lumpname );

	lea	eax, DWORD PTR _lumpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _nCurrent$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0BL@LPIMAFCF@Extracting?5?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6@
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 1017 : 
; 1018 : 		if( entry->disksize <= 0 || entry->disksize >= HPAK_MAX_SIZE )

	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+140], 0
	jle	SHORT $LN17@HPAK_Extra
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+140], 131072		; 00020000H
	jl	SHORT $LN16@HPAK_Extra
$LN17@HPAK_Extra:

; 1019 : 		{
; 1020 : 			Con_DPrintf( S_WARN "Unable to extract data, size invalid:  %s\n", Q_memprint( entry->disksize ));

	push	2
	mov	eax, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+140]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0DI@EJEFNAAG@?$FO3Warning?3?$FO7?5Unable?5to?5extract?5@
	call	_Con_DPrintf
	add	esp, 8

; 1021 : 			continue;

	jmp	$LN2@HPAK_Extra
$LN16@HPAK_Extra:

; 1022 : 		}
; 1023 : 
; 1024 : 		nDataSize = entry->disksize;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _nDataSize$[ebp], ecx

; 1025 : 		pData = Z_Malloc( nDataSize + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Extract_f@@9@9
	add	eax, 95					; 0000005fH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _nDataSize$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pData$[ebp], eax

; 1026 : 		FS_Seek( f, entry->filepos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1027 : 		FS_Read( f, pData, nDataSize );

	mov	eax, DWORD PTR _nDataSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1028 : 
; 1029 : 		Q_snprintf( szFileOut, sizeof( szFileOut ), "hpklmps\\lmp%04i.bmp", nCurrent );

	mov	eax, DWORD PTR _nCurrent$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@LHANBOI@hpklmps?2lmp?$CF04i?4bmp@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _szFileOut$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1030 : 		FS_WriteFile( szFileOut, pData, nDataSize );

	mov	eax, DWORD PTR _nDataSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileOut$[ebp]
	push	edx
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 1031 : 		if( pData ) Mem_Free( pData );

	cmp	DWORD PTR _pData$[ebp], 0
	je	SHORT $LN18@HPAK_Extra
	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Extract_f@@9@9
	add	eax, 101				; 00000065H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN18@HPAK_Extra:

; 1032 : 	}

	jmp	$LN2@HPAK_Extra
$LN3@HPAK_Extra:

; 1033 : 
; 1034 : 	if( directory.entries )

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN19@HPAK_Extra

; 1035 : 		Mem_Free( directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Extract_f@@9@9
	add	eax, 105				; 00000069H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN19@HPAK_Extra:

; 1036 : 
; 1037 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_Extra:

; 1038 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Extract_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_List_f
_TEXT	SEGMENT
_f$ = -556						; size = 4
_size$ = -552						; size = 4
_type$ = -548						; size = 4
_pakname$ = -544					; size = 256
_lumpname$ = -288					; size = 256
_entry$ = -32						; size = 4
_directory$ = -28					; size = 8
_header$ = -20						; size = 12
_nCurrent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_HPAK_List_f PROC					; COMDAT

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 853  : 	int		nCurrent;
; 854  : 	hpak_header_t	header;
; 855  : 	hpak_info_t	directory;
; 856  : 	hpak_lump_t	*entry;
; 857  : 	string		lumpname;
; 858  : 	string		pakname;
; 859  : 	const char	*type;
; 860  : 	const char	*size;
; 861  : 	file_t		*f;
; 862  : 
; 863  : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN5@HPAK_List_

; 864  : 	{
; 865  : 		Con_Printf( S_USAGE "hpklist <hpk>\n" );

	push	OFFSET ??_C@_0BG@NDNLLOHH@Usage?3?5hpklist?5?$DMhpk?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 866  : 		return;

	jmp	$LN1@HPAK_List_
$LN5@HPAK_List_:

; 867  : 	}
; 868  : 
; 869  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 870  : 
; 871  : 	Q_strncpy( pakname, Cmd_Argv( 1 ), sizeof( pakname ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 872  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 873  : 	Con_Printf( "Contents for %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@PJKPCFOA@Contents?5for?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8

; 874  : 
; 875  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 876  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN6@HPAK_List_

; 877  : 	{
; 878  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 879  : 		return;

	jmp	$LN1@HPAK_List_
$LN6@HPAK_List_:

; 880  : 	}
; 881  : 
; 882  : 	FS_Read( f, &header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 883  : 
; 884  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN7@HPAK_List_

; 885  : 	{
; 886  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@
	call	_Con_DPrintf
	add	esp, 8

; 887  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 888  : 		return;

	jmp	$LN1@HPAK_List_
$LN7@HPAK_List_:

; 889  : 	}
; 890  : 
; 891  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN8@HPAK_List_

; 892  : 	{
; 893  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 894  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 895  : 		return;

	jmp	$LN1@HPAK_List_
$LN8@HPAK_List_:

; 896  : 	}
; 897  : 
; 898  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 899  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 900  : 
; 901  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN10@HPAK_List_
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN9@HPAK_List_
$LN10@HPAK_List_:

; 902  : 	{
; 903  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 904  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 905  : 		return;

	jmp	$LN1@HPAK_List_
$LN9@HPAK_List_:

; 906  : 	}
; 907  : 
; 908  : 	Con_Printf( "# of Entries:  %i\n", directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@ODLODENF@?$CD?5of?5Entries?3?5?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8

; 909  : 	Con_Printf( "# Type Size FileName : MD5 Hash\n" );

	push	OFFSET ??_C@_0CB@HICGIPAC@?$CD?5Type?5Size?5FileName?5?3?5MD5?5Hash@
	call	_Con_Printf
	add	esp, 4

; 910  : 
; 911  : 	directory.entries = Z_Malloc( directory.count * sizeof( hpak_lump_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_List_f@@9@9
	add	eax, 59					; 0000003bH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 912  : 	FS_Read( f, directory.entries, directory.count * sizeof( hpak_lump_t ));

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 913  : 
; 914  : 	for( nCurrent = 0; nCurrent < directory.count; nCurrent++ )

	mov	DWORD PTR _nCurrent$[ebp], 0
	jmp	SHORT $LN4@HPAK_List_
$LN2@HPAK_List_:
	mov	eax, DWORD PTR _nCurrent$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurrent$[ebp], eax
$LN4@HPAK_List_:
	mov	eax, DWORD PTR _nCurrent$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp]
	jge	$LN3@HPAK_List_

; 915  : 	{
; 916  : 		entry = &directory.entries[nCurrent];

	imul	eax, DWORD PTR _nCurrent$[ebp], 144
	add	eax, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], eax

; 917  : 		COM_FileBase( entry->resource.szFileName, lumpname );

	lea	eax, DWORD PTR _lumpname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 918  : 		type = HPAK_TypeFromIndex( entry->resource.type );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_HPAK_TypeFromIndex
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 919  : 		size = Q_memprint( entry->resource.nDownloadSize );

	push	2
	mov	eax, DWORD PTR _entry$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	mov	DWORD PTR _size$[ebp], eax

; 920  : 
; 921  : 		Con_Printf( "%i: %10s %s %s\n  :  %s\n", nCurrent + 1, type, size, lumpname, MD5_Print( entry->resource.rgucMD5_hash ));

	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _lumpname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nCurrent$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0BI@JDDENNFE@?$CFi?3?5?$CF10s?5?$CFs?5?$CFs?6?5?5?3?5?5?$CFs?6@
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 922  : 	}

	jmp	$LN2@HPAK_List_
$LN3@HPAK_List_:

; 923  : 
; 924  : 	if( directory.entries )

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN11@HPAK_List_

; 925  : 		Mem_Free( directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_List_f@@9@9
	add	eax, 73					; 00000049H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@HPAK_List_:

; 926  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_List_:

; 927  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_List_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_ResourceForIndex
_TEXT	SEGMENT
_f$ = -284						; size = 4
_pakname$ = -280					; size = 256
_directory$ = -24					; size = 8
_header$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_index$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_ResourceForIndex PROC				; COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 567  : 	hpak_header_t	header;
; 568  : 	hpak_info_t	directory;
; 569  : 	string		pakname;
; 570  : 	file_t		*f;
; 571  : 
; 572  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@HPAK_Resou
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@HPAK_Resou
$LN3@HPAK_Resou:

; 573  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN2@HPAK_Resou:

; 574  : 
; 575  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 576  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 577  : 
; 578  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 579  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN4@HPAK_Resou

; 580  : 	{
; 581  : 		Con_DPrintf( S_ERROR "couldn't open %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 582  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN4@HPAK_Resou:

; 583  : 	}
; 584  : 
; 585  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 586  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN5@HPAK_Resou

; 587  : 	{
; 588  : 		Con_DPrintf( S_ERROR "%s is not an HPAK file\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@KIMHJLOI@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5an?5HPAK?5fi@
	call	_Con_DPrintf
	add	esp, 8

; 589  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 590  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN5@HPAK_Resou:

; 591  : 	}
; 592  : 
; 593  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN6@HPAK_Resou

; 594  : 	{
; 595  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 596  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 597  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN6@HPAK_Resou:

; 598  : 	}
; 599  : 
; 600  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 601  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 602  : 
; 603  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN8@HPAK_Resou
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN7@HPAK_Resou
$LN8@HPAK_Resou:

; 604  : 	{
; 605  : 		Con_DPrintf( S_ERROR "%s has too many lumps %u.\n", pakname, directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@DNHPODKG@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5lump@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 606  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 607  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN7@HPAK_Resou:

; 608  : 	}
; 609  : 
; 610  : 	if( index < 1 || index > directory.count )

	cmp	DWORD PTR _index$[ebp], 1
	jl	SHORT $LN10@HPAK_Resou
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp]
	jle	SHORT $LN9@HPAK_Resou
$LN10@HPAK_Resou:

; 611  : 	{
; 612  : 		Con_DPrintf( S_ERROR "%s, lump with index %i doesn't exist.\n", pakname, index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DC@BNHAELEA@?$FO1Error?3?$FO7?5?$CFs?0?5lump?5with?5index?5@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 613  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 614  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN9@HPAK_Resou:

; 615  : 	}
; 616  : 
; 617  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_ResourceForIndex@@9@9
	add	eax, 51					; 00000033H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 618  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 619  : 	*pResource = directory.entries[index-1].resource;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	imul	esi, eax, 144
	add	esi, DWORD PTR _directory$[ebp+4]
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd

; 620  : 	Z_Free( directory.entries );

	cmp	DWORD PTR _directory$[ebp+4], 0
	je	SHORT $LN11@HPAK_Resou
	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_ResourceForIndex@@9@9
	add	eax, 54					; 00000036H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@HPAK_Resou:

; 621  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 622  : 
; 623  : 	return true;

	mov	eax, 1
$LN1@HPAK_Resou:

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_ResourceForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_ValidatePak
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_HPAK_ValidatePak PROC					; COMDAT

; 466  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 467  : 	HPAK_Validate( filename, true );

	push	1
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_HPAK_Validate
	add	esp, 8

; 468  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_ValidatePak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_Validate
_TEXT	SEGMENT
_md5$ = -400						; size = 16
_pRes$ = -384						; size = 4
_pakname$ = -380					; size = 256
_MD5_Hash$ = -124					; size = 88
_num_lumps$ = -36					; size = 4
_i$ = -32						; size = 4
_dataPak$ = -28						; size = 4
_hdr$ = -24						; size = 12
_dataDir$ = -12						; size = 4
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_quiet$ = 12						; size = 4
_HPAK_Validate PROC					; COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 361  : 	file_t		*f;
; 362  : 	hpak_lump_t	*dataDir;
; 363  : 	hpak_header_t	hdr;
; 364  : 	byte		*dataPak;
; 365  : 	int		i, num_lumps;
; 366  : 	MD5Context_t	MD5_Hash;
; 367  : 	string		pakname;
; 368  : 	resource_t	*pRes;
; 369  : 	char		md5[16];
; 370  : 
; 371  : 	if( quiet ) HPAK_FlushHostQueue();

	cmp	DWORD PTR _quiet$[ebp], 0
	je	SHORT $LN5@HPAK_Valid
	call	_HPAK_FlushHostQueue
$LN5@HPAK_Valid:

; 372  : 
; 373  : 	// not an error - just flush queue
; 374  : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN7@HPAK_Valid
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@HPAK_Valid
$LN7@HPAK_Valid:

; 375  : 		return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Valid
$LN6@HPAK_Valid:

; 376  : 
; 377  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 378  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 379  : 
; 380  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 381  : 	if( !f )

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Valid

; 382  : 	{
; 383  : 		Con_DPrintf( S_ERROR "Couldn't find %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@FALHFFBF@?$FO1Error?3?$FO7?5Couldn?8t?5find?5?$CFs?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 384  : 		return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Valid
$LN8@HPAK_Valid:

; 385  : 	}
; 386  : 
; 387  : 	if( !quiet ) Con_Printf( "Validating %s\n", pakname );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN9@HPAK_Valid
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@DMOBHCNH@Validating?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN9@HPAK_Valid:

; 388  : 
; 389  : 	FS_Read( f, &hdr, sizeof( hdr ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _hdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 390  : 	if( hdr.ident != IDHPAKHEADER || hdr.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hdr$[ebp], 1262571592	; 4b415048H
	jne	SHORT $LN11@HPAK_Valid
	cmp	DWORD PTR _hdr$[ebp+4], 1
	je	SHORT $LN10@HPAK_Valid
$LN11@HPAK_Valid:

; 391  : 	{
; 392  : 		Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s does not have a valid HPAK header.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0EE@HECCAGDG@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
	call	_Con_DPrintf
	add	esp, 8

; 393  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 394  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN10@HPAK_Valid:

; 395  : 	}
; 396  : 
; 397  : 	FS_Seek( f, hdr.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hdr$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 398  : 	FS_Read( f, &num_lumps, sizeof( num_lumps ));

	push	4
	lea	eax, DWORD PTR _num_lumps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 399  : 
; 400  : 	if( num_lumps < 1 || num_lumps > MAX_FILES_IN_WAD )

	cmp	DWORD PTR _num_lumps$[ebp], 1
	jl	SHORT $LN13@HPAK_Valid
	cmp	DWORD PTR _num_lumps$[ebp], 65535	; 0000ffffH
	jle	SHORT $LN12@HPAK_Valid
$LN13@HPAK_Valid:

; 401  : 	{
; 402  : 		Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s has too many lumps %u.\n", pakname, num_lumps );

	mov	eax, DWORD PTR _num_lumps$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DI@EIKFINKI@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 403  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 404  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN12@HPAK_Valid:

; 405  : 	}
; 406  : 
; 407  : 	if( !quiet ) Con_Printf( "# of Entries:  %i\n", num_lumps );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN14@HPAK_Valid
	mov	eax, DWORD PTR _num_lumps$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@ODLODENF@?$CD?5of?5Entries?3?5?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8
$LN14@HPAK_Valid:

; 408  : 
; 409  : 	dataDir = Z_Malloc( sizeof( hpak_lump_t ) * num_lumps );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 49					; 00000031H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _num_lumps$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dataDir$[ebp], eax

; 410  : 	FS_Read( f, dataDir, sizeof( hpak_lump_t ) * num_lumps );

	imul	eax, DWORD PTR _num_lumps$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _dataDir$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 411  : 
; 412  : 	if( !quiet ) Con_Printf( "# Type Size FileName : MD5 Hash\n" );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN15@HPAK_Valid
	push	OFFSET ??_C@_0CB@HICGIPAC@?$CD?5Type?5Size?5FileName?5?3?5MD5?5Hash@
	call	_Con_Printf
	add	esp, 4
$LN15@HPAK_Valid:

; 413  : 
; 414  : 	for( i = 0; i < num_lumps; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_Valid
$LN2@HPAK_Valid:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_Valid:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_lumps$[ebp]
	jge	$LN3@HPAK_Valid

; 415  : 	{
; 416  : 		if( dataDir[i].disksize < 1 || dataDir[i].disksize > 131071 )

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	cmp	DWORD PTR [ecx+eax+140], 1
	jl	SHORT $LN17@HPAK_Valid
	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	cmp	DWORD PTR [ecx+eax+140], 131071		; 0001ffffH
	jle	SHORT $LN16@HPAK_Valid
$LN17@HPAK_Valid:

; 417  : 		{
; 418  : 			// odd max size
; 419  : 			Con_DPrintf( S_ERROR "HPAK_ValidatePak: lump %i has invalid size %s\n", i, Q_pretifymem( dataDir[i].disksize, 2 ));

	push	2
	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax+140]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@OHECJMHA@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5lu@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 420  : 			Mem_Free( dataDir );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dataDir$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 421  : 			FS_Close(f);

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 422  : 			return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Valid
$LN16@HPAK_Valid:

; 423  : 		}
; 424  : 
; 425  : 		dataPak = Z_Malloc( dataDir[i].disksize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 65					; 00000041H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _dataDir$[ebp]
	mov	eax, DWORD PTR [edx+ecx+140]
	push	eax
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dataPak$[ebp], eax

; 426  : 		FS_Seek( f, dataDir[i].filepos, SEEK_SET );

	push	0
	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	mov	edx, DWORD PTR [ecx+eax+136]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 427  : 		FS_Read( f, dataPak, dataDir[i].disksize );

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _dataPak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 428  : 
; 429  : 		memset( &MD5_Hash, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 430  : 		MD5Init( &MD5_Hash );

	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 431  : 		MD5Update( &MD5_Hash, dataPak, dataDir[i].disksize );

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _dataDir$[ebp]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _dataPak$[ebp]
	push	eax
	lea	ecx, DWORD PTR _MD5_Hash$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 432  : 		MD5Final( md5, &MD5_Hash );

	lea	eax, DWORD PTR _MD5_Hash$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 433  : 
; 434  : 		pRes = &dataDir[i].resource;

	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _dataDir$[ebp]
	mov	DWORD PTR _pRes$[ebp], eax

; 435  : 
; 436  : 		Con_Printf( "%i:      %s %s %s:   ", i, HPAK_TypeFromIndex( pRes->type ),

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _pRes$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_HPAK_TypeFromIndex
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@PDHNCGMA@?$CFi?3?5?5?5?5?5?5?$CFs?5?$CFs?5?$CFs?3?5?5?5@
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 437  : 		Q_pretifymem( pRes->nDownloadSize, 2 ), pRes->szFileName );  
; 438  : 
; 439  : 		if( memcmp( md5, pRes->rgucMD5_hash, 0x10 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pRes$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@HPAK_Valid

; 440  : 		{
; 441  : 			if( quiet )

	cmp	DWORD PTR _quiet$[ebp], 0
	je	SHORT $LN20@HPAK_Valid

; 442  : 			{
; 443  : 				Con_DPrintf( S_ERROR "HPAK_ValidatePak: %s has invalid checksum.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@HOALPJLO@?$FO1Error?3?$FO7?5HPAK_ValidatePak?3?5?$CFs@
	call	_Con_DPrintf
	add	esp, 8

; 444  : 				Mem_Free( dataPak );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 84					; 00000054H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dataPak$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 445  : 				Mem_Free( dataDir );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 85					; 00000055H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dataDir$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 446  : 				FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 447  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@HPAK_Valid

; 448  : 			}

	jmp	SHORT $LN21@HPAK_Valid
$LN20@HPAK_Valid:

; 449  : 			else Con_DPrintf( S_ERROR "failed\n" );

	push	OFFSET ??_C@_0BD@BNPLGJD@?$FO1Error?3?$FO7?5failed?6@
	call	_Con_DPrintf
	add	esp, 4
$LN21@HPAK_Valid:

; 450  : 		}

	jmp	SHORT $LN22@HPAK_Valid
$LN18@HPAK_Valid:

; 451  : 		else
; 452  : 		{
; 453  : 			if( !quiet ) Con_Printf( "OK\n" );

	cmp	DWORD PTR _quiet$[ebp], 0
	jne	SHORT $LN22@HPAK_Valid
	push	OFFSET ??_C@_03JLOMOCCD@OK?6@
	call	_Con_Printf
	add	esp, 4
$LN22@HPAK_Valid:

; 454  : 		}
; 455  : 
; 456  : 		// at this point, it's passed our checks.
; 457  : 		Mem_Free( dataPak );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 97					; 00000061H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dataPak$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 458  : 	}

	jmp	$LN2@HPAK_Valid
$LN3@HPAK_Valid:

; 459  : 
; 460  : 	Mem_Free( dataDir );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_Validate@@9@9
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dataDir$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 461  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 462  : 	return true;

	mov	eax, 1
$LN1@HPAK_Valid:

; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_FindResource
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hpk$ = 8						; size = 4
_hash$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_FindResource PROC					; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 176  : 	int	i;
; 177  : 
; 178  : 	for( i = 0; i < hpk->count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_FindR
$LN2@HPAK_FindR:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_FindR:
	mov	eax, DWORD PTR _hpk$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@HPAK_FindR

; 179  : 	{
; 180  : 		if( !memcmp( hpk->entries[i].resource.rgucMD5_hash, hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _hash$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _hpk$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx+77]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@HPAK_FindR

; 181  : 		{
; 182  : 			if( pResource )

	cmp	DWORD PTR _pResource$[ebp], 0
	je	SHORT $LN6@HPAK_FindR

; 183  : 				*pResource = hpk->entries[i].resource;

	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _hpk$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	add	esi, eax
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd
$LN6@HPAK_FindR:

; 184  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@HPAK_FindR
$LN5@HPAK_FindR:

; 185  : 		}
; 186  : 	}

	jmp	SHORT $LN2@HPAK_FindR
$LN3@HPAK_FindR:

; 187  : 
; 188  : 	return false;

	xor	eax, eax
$LN1@HPAK_FindR:

; 189  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_FindResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_CreatePak
_TEXT	SEGMENT
_ctx$ = -376						; size = 88
_fout$ = -288						; size = 4
_temp$ = -284						; size = 4
_md5$ = -280						; size = 16
_pakname$ = -264					; size = 256
_filelocation$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pResource$ = 12					; size = 4
_pData$ = 16						; size = 4
_fin$ = 20						; size = 4
_HPAK_CreatePak PROC					; COMDAT

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 440				; 000001b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 87   : 	int		filelocation;
; 88   : 	string		pakname;
; 89   : 	char		md5[16];
; 90   : 	char		*temp;
; 91   : 	file_t		*fout;
; 92   : 	MD5Context_t	ctx;
; 93   : 
; 94   : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@HPAK_Creat

; 95   : 		return;

	jmp	$LN1@HPAK_Creat
$LN2@HPAK_Creat:

; 96   : 
; 97   : 	if(( fin != NULL && pData != NULL ) || ( fin == NULL && pData == NULL ))

	cmp	DWORD PTR _fin$[ebp], 0
	je	SHORT $LN5@HPAK_Creat
	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN4@HPAK_Creat
$LN5@HPAK_Creat:
	cmp	DWORD PTR _fin$[ebp], 0
	jne	SHORT $LN3@HPAK_Creat
	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN3@HPAK_Creat
$LN4@HPAK_Creat:

; 98   : 		return;

	jmp	$LN1@HPAK_Creat
$LN3@HPAK_Creat:

; 99   : 
; 100  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 101  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 102  : 
; 103  : 	Con_Printf( "creating HPAK %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@FCCEKNMA@creating?5HPAK?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8

; 104  : 
; 105  : 	fout = FS_Open( pakname, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fout$[ebp], eax

; 106  : 	if( !fout )

	cmp	DWORD PTR _fout$[ebp], 0
	jne	SHORT $LN6@HPAK_Creat

; 107  : 	{
; 108  : 		Con_DPrintf( S_ERROR "HPAK_CreatePak: can't write %s.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@LOINMBBE@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5can?8@
	call	_Con_DPrintf
	add	esp, 8

; 109  : 		return;

	jmp	$LN1@HPAK_Creat
$LN6@HPAK_Creat:

; 110  : 	}
; 111  : 
; 112  : 	// let's hash it.
; 113  : 	memset( &ctx, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 114  : 	MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 115  : 
; 116  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	$LN7@HPAK_Creat

; 117  : 	{
; 118  : 		// there are better ways
; 119  : 		filelocation = FS_Tell( fin );

	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _filelocation$[ebp], eax

; 120  : 		temp = Z_Malloc( pResource->nDownloadSize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_CreatePak@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 121  : 		FS_Read( fin, temp, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 122  : 		FS_Seek( fin, filelocation, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _filelocation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 123  : 		MD5Update( &ctx, temp, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 124  : 		Mem_Free( temp );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_CreatePak@@9@9
	add	eax, 38					; 00000026H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 125  : 	}

	jmp	SHORT $LN8@HPAK_Creat
$LN7@HPAK_Creat:

; 126  : 	else
; 127  : 	{
; 128  : 		MD5Update( &ctx, pData, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN8@HPAK_Creat:

; 129  : 	}
; 130  : 
; 131  : 	MD5Final( md5, &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 132  : 
; 133  : 	if( memcmp( md5, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@HPAK_Creat

; 134  : 	{
; 135  : 		Con_DPrintf( S_ERROR "HPAK_CreatePak: bad checksum for %s. Ignored\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@CCEPPLGB@?$FO1Error?3?$FO7?5HPAK_CreatePak?3?5bad?5@
	call	_Con_DPrintf
	add	esp, 8

; 136  : 		return;

	jmp	$LN1@HPAK_Creat
$LN9@HPAK_Creat:

; 137  : 	}
; 138  : 
; 139  : 	hash_pack_header.ident = IDHPAKHEADER;

	mov	DWORD PTR _hash_pack_header, 1262571592	; 4b415048H

; 140  : 	hash_pack_header.version = IDHPAK_VERSION;

	mov	DWORD PTR _hash_pack_header+4, 1

; 141  : 	hash_pack_header.infotableofs = 0;

	mov	DWORD PTR _hash_pack_header+8, 0

; 142  : 
; 143  : 	FS_Write( fout, &hash_pack_header, sizeof( hash_pack_header ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 144  : 
; 145  : 	hash_pack_info.count = 1;

	mov	DWORD PTR _hash_pack_info, 1

; 146  : 	hash_pack_info.entries = Z_Malloc( sizeof( hpak_lump_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_CreatePak@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	144					; 00000090H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hash_pack_info+4, eax

; 147  : 	hash_pack_info.entries[0].resource = *pResource;

	mov	eax, 144				; 00000090H
	imul	edi, eax, 0
	add	edi, DWORD PTR _hash_pack_info+4
	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	rep movsd

; 148  : 	hash_pack_info.entries[0].filepos = FS_Tell( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, 144				; 00000090H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _hash_pack_info+4
	mov	DWORD PTR [ecx+edx+136], eax

; 149  : 	hash_pack_info.entries[0].disksize = pResource->nDownloadSize;

	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hash_pack_info+4
	mov	eax, DWORD PTR _pResource$[ebp]
	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+ecx+140], eax

; 150  : 
; 151  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN10@HPAK_Creat

; 152  : 	{
; 153  : 		FS_FileCopy( fout, fin, hash_pack_info.entries[0].disksize );

	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hash_pack_info+4
	mov	eax, DWORD PTR [edx+ecx+140]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 154  : 	}

	jmp	SHORT $LN11@HPAK_Creat
$LN10@HPAK_Creat:

; 155  : 	else
; 156  : 	{
; 157  : 		FS_Write( fout, pData, hash_pack_info.entries[0].disksize );

	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _hash_pack_info+4
	mov	eax, DWORD PTR [edx+ecx+140]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN11@HPAK_Creat:

; 158  : 	}
; 159  : 
; 160  : 	filelocation = FS_Tell( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _filelocation$[ebp], eax

; 161  : 	FS_Write( fout, &hash_pack_info.count, sizeof( hash_pack_info.count ));

	push	4
	push	OFFSET _hash_pack_info
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 162  : 	FS_Write( fout, &hash_pack_info.entries[0], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	mov	eax, 144				; 00000090H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _hash_pack_info+4
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 163  : 
; 164  : 	if( hash_pack_info.entries )

	cmp	DWORD PTR _hash_pack_info+4, 0
	je	SHORT $LN12@HPAK_Creat

; 165  : 		Mem_Free( hash_pack_info.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_CreatePak@@9@9
	add	eax, 79					; 0000004fH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _hash_pack_info+4
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN12@HPAK_Creat:

; 166  : 	memset( &hash_pack_info, 0, sizeof( hpak_info_t ));

	push	8
	push	0
	push	OFFSET _hash_pack_info
	call	_memset
	add	esp, 12					; 0000000cH

; 167  : 
; 168  : 	hash_pack_header.infotableofs = filelocation;

	mov	eax, DWORD PTR _filelocation$[ebp]
	mov	DWORD PTR _hash_pack_header+8, eax

; 169  : 	FS_Seek( fout, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 170  : 	FS_Write( fout, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 171  : 	FS_Close( fout );

	mov	eax, DWORD PTR _fout$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@HPAK_Creat:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CreatePak ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_AddToQueue
_TEXT	SEGMENT
_p$ = -4						; size = 4
_name$ = 8						; size = 4
_pResource$ = 12					; size = 4
_data$ = 16						; size = 4
_f$ = 20						; size = 4
_HPAK_AddToQueue PROC					; COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 54   : 	hash_pack_queue_t	*p;
; 55   : 
; 56   : 	p = Z_Malloc( sizeof( hash_pack_queue_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddToQueue@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	152					; 00000098H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _p$[ebp], eax

; 57   : 	p->name = copystring( name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddToQueue@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], eax

; 58   : 	p->resource = *pResource;

	mov	edi, DWORD PTR _p$[ebp]
	add	edi, 4
	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	rep movsd

; 59   : 	p->size = pResource->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+140], edx

; 60   : 	p->data = Z_Malloc( p->size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddToQueue@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+144], eax

; 61   : 
; 62   : 	if( data != NULL ) memcpy( p->data, data, p->size );

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN2@HPAK_AddTo
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@HPAK_AddTo
$LN2@HPAK_AddTo:

; 63   : 	else if( f != NULL ) FS_Read( f, p->data, p->size );

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN4@HPAK_AddTo
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@HPAK_AddTo
$LN4@HPAK_AddTo:

; 64   : 	else Host_Error( "HPAK_AddToQueue: data == NULL.\n" );

	push	OFFSET ??_C@_0CA@MGGIIEOF@HPAK_AddToQueue?3?5data?5?$DN?$DN?5NULL?4?6@
	call	_Host_Error
	add	esp, 4
$LN3@HPAK_AddTo:

; 65   : 
; 66   : 	p->next = gp_hpak_queue;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR [eax+148], ecx

; 67   : 	gp_hpak_queue = p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _gp_hpak_queue, eax

; 68   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_AddToQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_TypeFromIndex
_TEXT	SEGMENT
tv64 = -68						; size = 4
_type$ = 8						; size = 4
_HPAK_TypeFromIndex PROC				; COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 39   : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 6
	ja	SHORT $LN2@HPAK_TypeF
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@HPAK_TypeF[ecx*4]
$LN4@HPAK_TypeF:

; 40   : 	{
; 41   : 	case t_sound: return "decal";

	mov	eax, OFFSET ??_C@_05CFEEDGHM@decal@
	jmp	SHORT $LN1@HPAK_TypeF
$LN5@HPAK_TypeF:

; 42   : 	case t_skin: return "skin";

	mov	eax, OFFSET ??_C@_04NHPAFEHJ@skin@
	jmp	SHORT $LN1@HPAK_TypeF
$LN6@HPAK_TypeF:

; 43   : 	case t_model: return "model";

	mov	eax, OFFSET ??_C@_05NCCFOPHA@model@
	jmp	SHORT $LN1@HPAK_TypeF
$LN7@HPAK_TypeF:

; 44   : 	case t_decal: return "decal";

	mov	eax, OFFSET ??_C@_05CFEEDGHM@decal@
	jmp	SHORT $LN1@HPAK_TypeF
$LN8@HPAK_TypeF:

; 45   : 	case t_generic: return "generic";

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic@
	jmp	SHORT $LN1@HPAK_TypeF
$LN9@HPAK_TypeF:

; 46   : 	case t_eventscript: return "event";

	mov	eax, OFFSET ??_C@_05GFHEIIDD@event@
	jmp	SHORT $LN1@HPAK_TypeF
$LN10@HPAK_TypeF:

; 47   : 	case t_world: return "map";	

	mov	eax, OFFSET ??_C@_03HBNNNHNM@map@
	jmp	SHORT $LN1@HPAK_TypeF
$LN2@HPAK_TypeF:

; 48   : 	}
; 49   : 	return "?";

	mov	eax, OFFSET ??_C@_01OGPIMHDM@?$DP@
$LN1@HPAK_TypeF:

; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@HPAK_TypeF:
	DD	$LN4@HPAK_TypeF
	DD	$LN5@HPAK_TypeF
	DD	$LN6@HPAK_TypeF
	DD	$LN7@HPAK_TypeF
	DD	$LN8@HPAK_TypeF
	DD	$LN9@HPAK_TypeF
	DD	$LN10@HPAK_TypeF
_HPAK_TypeFromIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_FlushHostQueue
_TEXT	SEGMENT
_p$ = -4						; size = 4
_HPAK_FlushHostQueue PROC				; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 72   : 	hash_pack_queue_t	*p;
; 73   : 
; 74   : 	for( p = gp_hpak_queue; p != NULL; p = gp_hpak_queue )

	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@HPAK_Flush
$LN2@HPAK_Flush:
	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
$LN4@HPAK_Flush:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@HPAK_Flush

; 75   : 	{
; 76   : 		gp_hpak_queue = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _gp_hpak_queue, ecx

; 77   : 		HPAK_AddLump( false, p->name, &p->resource, p->data, NULL );

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H

; 78   : 		freestring( p->name );

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@HPAK_Flush
	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@HPAK_Flush:

; 79   : 		Mem_Free( p->data );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 80   : 		Mem_Free( p );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_FlushHostQueue@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 81   : 	}

	jmp	$LN2@HPAK_Flush
$LN3@HPAK_Flush:

; 82   : 	gp_hpak_queue = NULL;

	mov	DWORD PTR _gp_hpak_queue, 0

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_FlushHostQueue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_CheckSize
_TEXT	SEGMENT
_maxsize$ = -264					; size = 4
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_HPAK_CheckSize PROC					; COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 485  : 	string	pakname;
; 486  : 	int	maxsize;
; 487  : 
; 488  : 	maxsize = hpk_maxsize->value;

	mov	eax, DWORD PTR _hpk_maxsize
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _maxsize$[ebp], ecx

; 489  : 	if( maxsize <= 0 ) return;

	cmp	DWORD PTR _maxsize$[ebp], 0
	jg	SHORT $LN2@HPAK_Check
	jmp	$LN5@HPAK_Check
$LN2@HPAK_Check:

; 490  : 
; 491  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN4@HPAK_Check
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN3@HPAK_Check
$LN4@HPAK_Check:

; 492  : 		return;

	jmp	$LN5@HPAK_Check
$LN3@HPAK_Check:

; 493  : 
; 494  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 495  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 496  : 
; 497  : 	if( FS_FileSize( pakname, false ) > ( maxsize * 1000000 ))

	push	0
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	imul	ecx, DWORD PTR _maxsize$[ebp], 1000000
	cmp	eax, ecx
	jle	SHORT $LN5@HPAK_Check

; 498  : 	{
; 499  : 		Con_Printf( "Server: Size of %s > %f MB, deleting.\n", filename, hpk_maxsize->value );

	mov	eax, DWORD PTR _hpk_maxsize
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@BBAGCCLG@Server?3?5Size?5of?5?$CFs?5?$DO?5?$CFf?5MB?0?5del@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 500  : 		Log_Printf( "Server: Size of %s > %f MB, deleting.\n", filename, hpk_maxsize->value );

	mov	eax, DWORD PTR _hpk_maxsize
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CH@BBAGCCLG@Server?3?5Size?5of?5?$CFs?5?$DO?5?$CFf?5MB?0?5del@
	call	_Log_Printf
	add	esp, 16					; 00000010H

; 501  : 		FS_Delete( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4
$LN5@HPAK_Check:

; 502  : 	}
; 503  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CheckSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_CheckIntegrity
_TEXT	SEGMENT
_pakname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_HPAK_CheckIntegrity PROC				; COMDAT

; 471  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 472  : 	string	pakname;
; 473  : 
; 474  : 	if( !filename || !filename[0] )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@HPAK_Check
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@HPAK_Check
$LN3@HPAK_Check:

; 475  : 		return;

	jmp	SHORT $LN1@HPAK_Check
$LN2@HPAK_Check:

; 476  : 
; 477  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 478  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 479  : 
; 480  : 	HPAK_ValidatePak( pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_HPAK_ValidatePak
	add	esp, 4
$LN1@HPAK_Check:

; 481  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_CheckIntegrity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_RemoveLump
_TEXT	SEGMENT
_j$ = -548						; size = 4
_i$ = -544						; size = 4
_hpak_save$ = -540					; size = 8
_hpak_read$ = -532					; size = 8
_file_dst$ = -524					; size = 4
_file_src$ = -520					; size = 4
_save_path$ = -516					; size = 256
_read_path$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_pResource$ = 12					; size = 4
_HPAK_RemoveLump PROC					; COMDAT

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 676				; 000002a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 729  : 	string		read_path;
; 730  : 	string		save_path;
; 731  : 	file_t		*file_src;
; 732  : 	file_t		*file_dst;
; 733  : 	hpak_info_t	hpak_read;
; 734  : 	hpak_info_t	hpak_save;
; 735  : 	int		i, j;
; 736  : 
; 737  : 	if( !COM_CheckString( name ) || !pResource )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@HPAK_Remov
	cmp	DWORD PTR _pResource$[ebp], 0
	jne	SHORT $LN8@HPAK_Remov
$LN9@HPAK_Remov:

; 738  : 		return;

	jmp	$LN1@HPAK_Remov
$LN8@HPAK_Remov:

; 739  : 
; 740  : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 741  : 
; 742  : 	Q_strncpy( read_path, name, sizeof( read_path ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _read_path$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 743  : 	COM_ReplaceExtension( read_path, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 744  : 
; 745  : 	file_src = FS_Open( read_path, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_src$[ebp], eax

; 746  : 	if( !file_src )

	cmp	DWORD PTR _file_src$[ebp], 0
	jne	SHORT $LN10@HPAK_Remov

; 747  : 	{
; 748  : 		Con_DPrintf( S_ERROR "%s couldn't open.\n", read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@GFBLFEBE@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5open?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 749  : 		return;

	jmp	$LN1@HPAK_Remov
$LN10@HPAK_Remov:

; 750  : 	}
; 751  : 
; 752  : 	Q_strncpy( save_path, read_path, sizeof( save_path ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 753  : 	COM_ReplaceExtension( save_path, ".hp2" );

	push	OFFSET ??_C@_04DPHKEK@?4hp2@
	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 754  : 	file_dst = FS_Open( save_path, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_dst$[ebp], eax

; 755  : 
; 756  : 	if( !file_dst )

	cmp	DWORD PTR _file_dst$[ebp], 0
	jne	SHORT $LN11@HPAK_Remov

; 757  : 	{
; 758  : 		Con_DPrintf( S_ERROR "%s couldn't open.\n", save_path );

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@GFBLFEBE@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5open?4?6@
	call	_Con_DPrintf
	add	esp, 8

; 759  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 760  : 		return;

	jmp	$LN1@HPAK_Remov
$LN11@HPAK_Remov:

; 761  : 	}
; 762  : 
; 763  : 	FS_Seek( file_src, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 764  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 765  : 
; 766  : 	// header copy
; 767  : 	FS_Read( file_src, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 768  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 769  : 
; 770  : 	if( hash_pack_header.ident != IDHPAKHEADER || hash_pack_header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hash_pack_header, 1262571592	; 4b415048H
	jne	SHORT $LN13@HPAK_Remov
	cmp	DWORD PTR _hash_pack_header+4, 1
	je	SHORT $LN12@HPAK_Remov
$LN13@HPAK_Remov:

; 771  : 	{
; 772  : 		Con_DPrintf( S_ERROR "%s has invalid header.\n", read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@IJNAGBLD@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5heade@
	call	_Con_DPrintf
	add	esp, 8

; 773  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 774  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 775  : 		FS_Delete( save_path ); // delete temp file

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 776  : 		return;

	jmp	$LN1@HPAK_Remov
$LN12@HPAK_Remov:

; 777  : 	}
; 778  : 
; 779  : 	FS_Seek( file_src, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hash_pack_header+8
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 780  : 	FS_Read( file_src, &hpak_read.count, sizeof( hpak_read.count ));

	push	4
	lea	eax, DWORD PTR _hpak_read$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 781  : 
; 782  : 	if( hpak_read.count < 1 || hpak_read.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _hpak_read$[ebp], 1
	jl	SHORT $LN15@HPAK_Remov
	cmp	DWORD PTR _hpak_read$[ebp], 32768	; 00008000H
	jle	SHORT $LN14@HPAK_Remov
$LN15@HPAK_Remov:

; 783  : 	{
; 784  : 		Con_DPrintf( S_ERROR "%s has invalid number of lumps.\n", read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@DAIBBNDL@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5numbe@
	call	_Con_DPrintf
	add	esp, 8

; 785  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 786  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 787  : 		FS_Delete( save_path ); // delete temp file

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 788  : 		return;

	jmp	$LN1@HPAK_Remov
$LN14@HPAK_Remov:

; 789  : 	}
; 790  : 
; 791  : 	if( hpak_read.count == 1 )

	cmp	DWORD PTR _hpak_read$[ebp], 1
	jne	SHORT $LN16@HPAK_Remov

; 792  : 	{
; 793  : 		Con_DPrintf( S_WARN "%s only has one element, so HPAK will be removed\n", read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@LDMMCIJC@?$FO3Warning?3?$FO7?5?$CFs?5only?5has?5one?5el@
	call	_Con_DPrintf
	add	esp, 8

; 794  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 795  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 796  : 		FS_Delete( read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 797  : 		FS_Delete( save_path );

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 798  : 		return;

	jmp	$LN1@HPAK_Remov
$LN16@HPAK_Remov:

; 799  : 	}
; 800  : 
; 801  : 	hpak_save.count = hpak_read.count - 1;

	mov	eax, DWORD PTR _hpak_read$[ebp]
	sub	eax, 1
	mov	DWORD PTR _hpak_save$[ebp], eax

; 802  : 	hpak_read.entries = Z_Malloc( sizeof( hpak_lump_t ) * hpak_read.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 74					; 0000004aH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _hpak_read$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hpak_read$[ebp+4], eax

; 803  : 	hpak_save.entries = Z_Malloc( sizeof( hpak_lump_t ) * hpak_save.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 75					; 0000004bH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _hpak_save$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hpak_save$[ebp+4], eax

; 804  : 
; 805  : 	FS_Read( file_src, hpak_read.entries, sizeof( hpak_lump_t ) * hpak_read.count );

	imul	eax, DWORD PTR _hpak_read$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _hpak_read$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 806  : 
; 807  : 	if( !HPAK_FindResource( &hpak_read, pResource->rgucMD5_hash, NULL ))

	push	0
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _hpak_read$[ebp]
	push	ecx
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN17@HPAK_Remov

; 808  : 	{
; 809  : 		Con_DPrintf( S_ERROR "HPAK doesn't contain specified lump: %s\n", pResource->szFileName, read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@MMJKOPBA@?$FO1Error?3?$FO7?5HPAK?5doesn?8t?5contain@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 810  : 		Mem_Free( hpak_read.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 82					; 00000052H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _hpak_read$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 811  : 		Mem_Free( hpak_save.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 83					; 00000053H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 812  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 813  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 814  : 		FS_Delete( save_path );

	lea	eax, DWORD PTR _save_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 815  : 		return;

	jmp	$LN1@HPAK_Remov
$LN17@HPAK_Remov:

; 816  : 	}
; 817  : 
; 818  : 	Con_Printf( "Removing %s from HPAK %s.\n", pResource->szFileName, read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BL@FHFHEJBB@Removing?5?$CFs?5from?5HPAK?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 819  : 
; 820  : 	// If there's a collision, we've just corrupted this hpak.
; 821  : 	for( i = 0, j = 0; i < hpak_read.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@HPAK_Remov
$LN2@HPAK_Remov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_Remov:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _hpak_read$[ebp]
	jge	$LN3@HPAK_Remov

; 822  : 	{
; 823  : 		if( !memcmp( hpak_read.entries[i].resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 144
	mov	edx, DWORD PTR _hpak_read$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx+77]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@HPAK_Remov

; 824  : 			continue;

	jmp	SHORT $LN2@HPAK_Remov
$LN18@HPAK_Remov:

; 825  : 
; 826  : 		hpak_save.entries[j] = hpak_read.entries[i];

	imul	esi, DWORD PTR _i$[ebp], 144
	add	esi, DWORD PTR _hpak_read$[ebp+4]
	imul	edi, DWORD PTR _j$[ebp], 144
	add	edi, DWORD PTR _hpak_save$[ebp+4]
	mov	ecx, 36					; 00000024H
	rep movsd

; 827  : 		hpak_save.entries[j].filepos = FS_Tell( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	imul	ecx, DWORD PTR _j$[ebp], 144
	mov	edx, DWORD PTR _hpak_save$[ebp+4]
	mov	DWORD PTR [edx+ecx+136], eax

; 828  : 		FS_Seek( file_src, hpak_read.entries[j].filepos, SEEK_SET );

	push	0
	imul	eax, DWORD PTR _j$[ebp], 144
	mov	ecx, DWORD PTR _hpak_read$[ebp+4]
	mov	edx, DWORD PTR [ecx+eax+136]
	push	edx
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 829  : 		FS_FileCopy( file_dst, file_src, hpak_save.entries[j].disksize );

	imul	eax, DWORD PTR _j$[ebp], 144
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	mov	edx, DWORD PTR [ecx+eax+140]
	push	edx
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 830  : 		j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 831  : 	}

	jmp	$LN2@HPAK_Remov
$LN3@HPAK_Remov:

; 832  : 
; 833  : 	hash_pack_header.infotableofs = FS_Tell( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _hash_pack_header+8, eax

; 834  : 	FS_Write( file_dst, &hpak_save.count, sizeof( hpak_save.count ));

	push	4
	lea	eax, DWORD PTR _hpak_save$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 835  : 
; 836  : 	for( i = 0; i < hpak_save.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@HPAK_Remov
$LN5@HPAK_Remov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@HPAK_Remov:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _hpak_save$[ebp]
	jge	SHORT $LN6@HPAK_Remov

; 837  : 		FS_Write( file_dst, &hpak_save.entries[i], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _hpak_save$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@HPAK_Remov
$LN6@HPAK_Remov:

; 838  : 
; 839  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 840  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 841  : 
; 842  : 	Mem_Free( hpak_read.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 114				; 00000072H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _hpak_read$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 843  : 	Mem_Free( hpak_save.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_RemoveLump@@9@9
	add	eax, 115				; 00000073H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _hpak_save$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 844  : 	FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 845  : 	FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 846  : 
; 847  : 	FS_Delete( read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 848  : 	FS_Rename( save_path, read_path );

	lea	eax, DWORD PTR _read_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _save_path$[ebp]
	push	ecx
	call	_FS_Rename
	add	esp, 8
$LN1@HPAK_Remov:

; 849  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_RemoveLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_AddLump
_TEXT	SEGMENT
_ctx$ = -668						; size = 88
_temp$ = -580						; size = 4
_md5$ = -576						; size = 16
_file_dst$ = -560					; size = 4
_file_src$ = -556					; size = 4
_dstpak$ = -552						; size = 8
_srcpak$ = -544						; size = 8
_dstname$ = -536					; size = 256
_srcname$ = -280					; size = 256
_pCurrentEntry$ = -24					; size = 4
_length$ = -20						; size = 4
_position$ = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bUseQueue$ = 8						; size = 4
_name$ = 12						; size = 4
_pResource$ = 16					; size = 4
_pData$ = 20						; size = 4
_pFile$ = 24						; size = 4
_HPAK_AddLump PROC					; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 796				; 0000031cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 193  : 	int		i, j, position, length;
; 194  : 	hpak_lump_t	*pCurrentEntry = NULL;

	mov	DWORD PTR _pCurrentEntry$[ebp], 0

; 195  : 	string		srcname, dstname;
; 196  : 	hpak_info_t	srcpak, dstpak;
; 197  : 	file_t		*file_src;
; 198  : 	file_t		*file_dst;
; 199  : 	char		md5[16];
; 200  : 	byte		*temp;
; 201  : 	MD5Context_t	ctx;
; 202  : 
; 203  : 	if( pData == NULL && pFile == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN11@HPAK_AddLu
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN11@HPAK_AddLu

; 204  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN11@HPAK_AddLu:

; 205  : 
; 206  : 	if( pResource->nDownloadSize < HPAK_MIN_SIZE || pResource->nDownloadSize > HPAK_MAX_SIZE )

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+72], 1024		; 00000400H
	jl	SHORT $LN13@HPAK_AddLu
	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+72], 131072		; 00020000H
	jle	SHORT $LN12@HPAK_AddLu
$LN13@HPAK_AddLu:

; 207  : 	{
; 208  : 		Con_Printf( S_ERROR "%s: invalid size %s\n", name, Q_pretifymem( pResource->nDownloadSize, 2 ));

	push	2
	mov	eax, DWORD PTR _pResource$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+72]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@OOGCCJKF@?$FO1Error?3?$FO7?5?$CFs?3?5invalid?5size?5?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 209  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN12@HPAK_AddLu:

; 210  : 	}
; 211  : 
; 212  : 	// hash it
; 213  : 	memset( &ctx, 0, sizeof( MD5Context_t ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 214  : 	MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 215  : 
; 216  : 	if( pData == NULL )

	cmp	DWORD PTR _pData$[ebp], 0
	jne	$LN14@HPAK_AddLu

; 217  : 	{
; 218  : 		// there are better ways
; 219  : 		position = FS_Tell( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _position$[ebp], eax

; 220  : 		temp = Z_Malloc( pResource->nDownloadSize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _temp$[ebp], eax

; 221  : 		FS_Read( pFile, temp, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 222  : 		FS_Seek( pFile, position, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 223  : 		MD5Update( &ctx, temp, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 224  : 		Mem_Free( temp );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 225  : 	}

	jmp	SHORT $LN15@HPAK_AddLu
$LN14@HPAK_AddLu:

; 226  : 	else
; 227  : 	{
; 228  : 		MD5Update( &ctx, pData, pResource->nDownloadSize );

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Update
	add	esp, 12					; 0000000cH
$LN15@HPAK_AddLu:

; 229  : 	}
; 230  : 
; 231  : 	MD5Final( md5, &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 232  : 
; 233  : 	if( memcmp( md5, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@HPAK_AddLu

; 234  : 	{
; 235  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: bad checksum for %s. Ignored\n", pResource->szFileName );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@FHINOHLO@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5bad?5ch@
	call	_Con_DPrintf
	add	esp, 8

; 236  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN16@HPAK_AddLu:

; 237  : 	}
; 238  : 
; 239  : 	if( bUseQueue )

	cmp	DWORD PTR _bUseQueue$[ebp], 0
	je	SHORT $LN17@HPAK_AddLu

; 240  : 	{
; 241  : 		HPAK_AddToQueue( name, pResource, pData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_HPAK_AddToQueue
	add	esp, 16					; 00000010H

; 242  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN17@HPAK_AddLu:

; 243  : 	}
; 244  : 
; 245  : 	Q_strncpy( srcname, name, sizeof( srcname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _srcname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 246  : 	COM_ReplaceExtension( srcname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 247  : 
; 248  : 	file_src = FS_Open( srcname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_src$[ebp], eax

; 249  : 
; 250  : 	if( !file_src )

	cmp	DWORD PTR _file_src$[ebp], 0
	jne	SHORT $LN18@HPAK_AddLu

; 251  : 	{
; 252  : 		// just create new pack
; 253  : 		HPAK_CreatePak( name, pResource, pData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_HPAK_CreatePak
	add	esp, 16					; 00000010H

; 254  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN18@HPAK_AddLu:

; 255  : 	}
; 256  : 
; 257  : 	Q_strncpy( dstname, srcname, sizeof( dstname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dstname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 258  : 	COM_ReplaceExtension( dstname, ".hp2" );

	push	OFFSET ??_C@_04DPHKEK@?4hp2@
	lea	eax, DWORD PTR _dstname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 259  : 
; 260  : 	file_dst = FS_Open( dstname, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _dstname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file_dst$[ebp], eax

; 261  : 
; 262  : 	if( !file_dst )

	cmp	DWORD PTR _file_dst$[ebp], 0
	jne	SHORT $LN19@HPAK_AddLu

; 263  : 	{
; 264  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: couldn't open %s.\n", srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@NCAMNJLL@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5couldn@
	call	_Con_DPrintf
	add	esp, 8

; 265  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 266  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN19@HPAK_AddLu:

; 267  : 	}
; 268  : 
; 269  : 	// load headers
; 270  : 	FS_Read( file_src, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 271  : 
; 272  : 	if( hash_pack_header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _hash_pack_header+4, 1
	je	SHORT $LN20@HPAK_AddLu

; 273  : 	{
; 274  : 		// we don't check the HPAK bit for some reason.
; 275  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: %s does not have a valid header.\n", srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@EONNLEF@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5doe@
	call	_Con_DPrintf
	add	esp, 8

; 276  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 277  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN20@HPAK_AddLu:

; 278  : 	}
; 279  : 
; 280  : 	length = FS_FileLength( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 281  : 	FS_Seek( file_src, 0, SEEK_SET ); // rewind to start of file

	push	0
	push	0
	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 282  : 	FS_FileCopy( file_dst, file_src, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file_dst$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 283  : 
; 284  : 	FS_Seek( file_src, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hash_pack_header+8
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 285  : 	FS_Read( file_src, &srcpak.count, sizeof( srcpak.count ));

	push	4
	lea	eax, DWORD PTR _srcpak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_src$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 286  : 
; 287  : 	if( srcpak.count < 1 || srcpak.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _srcpak$[ebp], 1
	jl	SHORT $LN22@HPAK_AddLu
	cmp	DWORD PTR _srcpak$[ebp], 32768		; 00008000H
	jle	SHORT $LN21@HPAK_AddLu
$LN22@HPAK_AddLu:

; 288  : 	{
; 289  : 		Con_DPrintf( S_ERROR "HPAK_AddLump: %s contain too many lumps.\n", srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@ICGFJJEG@?$FO1Error?3?$FO7?5HPAK_AddLump?3?5?$CFs?5con@
	call	_Con_DPrintf
	add	esp, 8

; 290  : 		FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 291  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 292  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN21@HPAK_AddLu:

; 293  : 	}
; 294  : 
; 295  : 	// load the data
; 296  : 	srcpak.entries = Z_Malloc( sizeof( hpak_lump_t ) * srcpak.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _srcpak$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _srcpak$[ebp+4], eax

; 297  : 	FS_Read( file_src, srcpak.entries, sizeof( hpak_lump_t ) * srcpak.count );

	imul	eax, DWORD PTR _srcpak$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 298  : 	FS_Close( file_src );

	mov	eax, DWORD PTR _file_src$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 299  : 
; 300  : 	// check if already exists
; 301  : 	if( HPAK_FindResource( &srcpak, pResource->rgucMD5_hash, NULL ))

	push	0
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	lea	ecx, DWORD PTR _srcpak$[ebp]
	push	ecx
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@HPAK_AddLu

; 302  : 	{
; 303  : 		Z_Free( srcpak.entries );

	cmp	DWORD PTR _srcpak$[ebp+4], 0
	je	SHORT $LN24@HPAK_AddLu
	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 111				; 0000006fH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN24@HPAK_AddLu:

; 304  : 		FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 305  : 		FS_Delete( dstname );

	lea	eax, DWORD PTR _dstname$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 306  : 		return;

	jmp	$LN1@HPAK_AddLu
$LN23@HPAK_AddLu:

; 307  : 	}
; 308  : 
; 309  : 	// make a new container
; 310  : 	dstpak.count = srcpak.count + 1;

	mov	eax, DWORD PTR _srcpak$[ebp]
	add	eax, 1
	mov	DWORD PTR _dstpak$[ebp], eax

; 311  : 	dstpak.entries = Z_Malloc( sizeof( hpak_lump_t ) * dstpak.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 119				; 00000077H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _dstpak$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _dstpak$[ebp+4], eax

; 312  : 	memcpy( dstpak.entries, srcpak.entries, srcpak.count );

	mov	eax, DWORD PTR _srcpak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _dstpak$[ebp+4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 313  : 
; 314  : 	for( i = 0; i < srcpak.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@HPAK_AddLu
$LN2@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _srcpak$[ebp]
	jge	$LN3@HPAK_AddLu

; 315  : 	{
; 316  : 		if( memcmp( md5, srcpak.entries[i].resource.rgucMD5_hash, 16 ))

	push	16					; 00000010H
	imul	eax, DWORD PTR _i$[ebp], 144
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax+77]
	push	edx
	lea	eax, DWORD PTR _md5$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@HPAK_AddLu

; 317  : 		{
; 318  : 			pCurrentEntry = &dstpak.entries[i];

	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _dstpak$[ebp+4]
	mov	DWORD PTR _pCurrentEntry$[ebp], eax

; 319  : 
; 320  : 			for( j = i; j < srcpak.count; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@HPAK_AddLu
$LN5@HPAK_AddLu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@HPAK_AddLu:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _srcpak$[ebp]
	jge	SHORT $LN6@HPAK_AddLu

; 321  : 				dstpak.entries[j + 1] = srcpak.entries[j];

	imul	esi, DWORD PTR _j$[ebp], 144
	add	esi, DWORD PTR _srcpak$[ebp+4]
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	imul	edi, eax, 144
	add	edi, DWORD PTR _dstpak$[ebp+4]
	mov	ecx, 36					; 00000024H
	rep movsd
	jmp	SHORT $LN5@HPAK_AddLu
$LN6@HPAK_AddLu:

; 322  : 		}
; 323  : 	}

	jmp	$LN2@HPAK_AddLu
$LN3@HPAK_AddLu:

; 324  : 
; 325  : 	if( !pCurrentEntry )

	cmp	DWORD PTR _pCurrentEntry$[ebp], 0
	jne	SHORT $LN26@HPAK_AddLu

; 326  : 		pCurrentEntry = &dstpak.entries[dstpak.count-1];

	mov	eax, DWORD PTR _dstpak$[ebp]
	sub	eax, 1
	imul	ecx, eax, 144
	add	ecx, DWORD PTR _dstpak$[ebp+4]
	mov	DWORD PTR _pCurrentEntry$[ebp], ecx
$LN26@HPAK_AddLu:

; 327  : 
; 328  : 	memset( pCurrentEntry, 0, sizeof( hpak_lump_t ));

	push	144					; 00000090H
	push	0
	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 329  : 	FS_Seek( file_dst, hash_pack_header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _hash_pack_header+8
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 330  : 	pCurrentEntry->resource = *pResource;

	mov	ecx, 34					; 00000022H
	mov	esi, DWORD PTR _pResource$[ebp]
	mov	edi, DWORD PTR _pCurrentEntry$[ebp]
	rep movsd

; 331  : 	pCurrentEntry->filepos = FS_Tell( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _pCurrentEntry$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 332  : 	pCurrentEntry->disksize = pResource->nDownloadSize;

	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+140], edx

; 333  : 
; 334  : 	if( !pData ) FS_FileCopy( file_dst, file_src, pCurrentEntry->disksize );

	cmp	DWORD PTR _pData$[ebp], 0
	jne	SHORT $LN27@HPAK_AddLu
	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _file_src$[ebp]
	push	edx
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN28@HPAK_AddLu
$LN27@HPAK_AddLu:

; 335  : 	else FS_Write( file_dst, pData, pCurrentEntry->disksize );

	mov	eax, DWORD PTR _pCurrentEntry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN28@HPAK_AddLu:

; 336  : 
; 337  : 	hash_pack_header.infotableofs = FS_Tell( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _hash_pack_header+8, eax

; 338  : 	FS_Write( file_dst, &dstpak.count, sizeof( dstpak.count ));

	push	4
	lea	eax, DWORD PTR _dstpak$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 339  : 
; 340  : 	for( i = 0; i < dstpak.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@HPAK_AddLu
$LN8@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@HPAK_AddLu:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dstpak$[ebp]
	jge	SHORT $LN9@HPAK_AddLu

; 341  : 	{
; 342  : 		FS_Write( file_dst, &dstpak.entries[i], sizeof( hpak_lump_t ));

	push	144					; 00000090H
	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _dstpak$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _file_dst$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 343  : 	}

	jmp	SHORT $LN8@HPAK_AddLu
$LN9@HPAK_AddLu:

; 344  : 
; 345  : 	// finalize
; 346  : 	if( srcpak.entries )

	cmp	DWORD PTR _srcpak$[ebp+4], 0
	je	SHORT $LN29@HPAK_AddLu

; 347  : 		Mem_Free( srcpak.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 155				; 0000009bH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _srcpak$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN29@HPAK_AddLu:

; 348  : 	if( dstpak.entries )

	cmp	DWORD PTR _dstpak$[ebp+4], 0
	je	SHORT $LN30@HPAK_AddLu

; 349  : 		Mem_Free( dstpak.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_AddLump@@9@9
	add	eax, 157				; 0000009dH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _dstpak$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN30@HPAK_AddLu:

; 350  : 
; 351  : 	FS_Seek( file_dst, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 352  : 	FS_Write( file_dst, &hash_pack_header, sizeof( hpak_header_t ));

	push	12					; 0000000cH
	push	OFFSET _hash_pack_header
	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 353  : 	FS_Close( file_dst );

	mov	eax, DWORD PTR _file_dst$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 354  : 
; 355  : 	FS_Delete( srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 356  : 	FS_Rename( dstname, srcname );

	lea	eax, DWORD PTR _srcname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dstname$[ebp]
	push	ecx
	call	_FS_Rename
	add	esp, 8
$LN1@HPAK_AddLu:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_AddLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_ResourceForHash
_TEXT	SEGMENT
_p$ = -292						; size = 4
_f$ = -288						; size = 4
_bFound$ = -284						; size = 4
_pakname$ = -280					; size = 256
_header$ = -24						; size = 12
_directory$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_hash$ = 12						; size = 4
_pResource$ = 16					; size = 4
_HPAK_ResourceForHash PROC				; COMDAT

; 506  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 507  : 	hpak_info_t	directory;
; 508  : 	hpak_header_t	header;
; 509  : 	string		pakname;
; 510  : 	qboolean		bFound;
; 511  : 	file_t		*f;
; 512  : 	hash_pack_queue_t	*p;
; 513  : 
; 514  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@HPAK_Resou

; 515  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN5@HPAK_Resou:

; 516  : 	
; 517  : 	for( p = gp_hpak_queue; p != NULL; p = p->next )

	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@HPAK_Resou
$LN2@HPAK_Resou:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@HPAK_Resou:
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@HPAK_Resou

; 518  : 	{
; 519  : 		if( !Q_stricmp( p->name, filename ) && !memcmp( p->resource.rgucMD5_hash, hash, 16 ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Resou
	push	16					; 00000010H
	mov	eax, DWORD PTR _hash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@HPAK_Resou

; 520  : 		{
; 521  : 			if( pResource != NULL )

	cmp	DWORD PTR _pResource$[ebp], 0
	je	SHORT $LN7@HPAK_Resou

; 522  : 				*pResource = p->resource;

	mov	esi, DWORD PTR _p$[ebp]
	add	esi, 4
	mov	ecx, 34					; 00000022H
	mov	edi, DWORD PTR _pResource$[ebp]
	rep movsd
$LN7@HPAK_Resou:

; 523  : 			return true;

	mov	eax, 1
	jmp	$LN1@HPAK_Resou
$LN6@HPAK_Resou:

; 524  : 		}
; 525  : 	}

	jmp	SHORT $LN2@HPAK_Resou
$LN3@HPAK_Resou:

; 526  : 
; 527  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 528  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 529  : 
; 530  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 531  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN8@HPAK_Resou
	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN8@HPAK_Resou:

; 532  : 
; 533  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 534  : 
; 535  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN9@HPAK_Resou

; 536  : 	{
; 537  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 538  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN9@HPAK_Resou:

; 539  : 	}
; 540  : 
; 541  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN10@HPAK_Resou

; 542  : 	{
; 543  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 544  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN10@HPAK_Resou:

; 545  : 	}
; 546  : 
; 547  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 548  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 549  : 
; 550  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN12@HPAK_Resou
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN11@HPAK_Resou
$LN12@HPAK_Resou:

; 551  : 	{
; 552  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 553  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_Resou
$LN11@HPAK_Resou:

; 554  : 	}
; 555  : 
; 556  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_ResourceForHash@@9@9
	add	eax, 50					; 00000032H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 557  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 558  : 	bFound = HPAK_FindResource( &directory, hash, pResource );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	lea	edx, DWORD PTR _directory$[ebp]
	push	edx
	call	_HPAK_FindResource
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bFound$[ebp], eax

; 559  : 	Mem_Free( directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_ResourceForHash@@9@9
	add	eax, 53					; 00000035H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 560  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 561  : 
; 562  : 	return bFound;

	mov	eax, DWORD PTR _bFound$[ebp]
$LN1@HPAK_Resou:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_ResourceForHash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_GetDataPointer
_TEXT	SEGMENT
_i$ = -300						; size = 4
_f$ = -296						; size = 4
_p$ = -292						; size = 4
_entry$ = -288						; size = 4
_directory$ = -284					; size = 8
_header$ = -276						; size = 12
_pakname$ = -264					; size = 256
_tmpbuf$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pResource$ = 12					; size = 4
_buffer$ = 16						; size = 4
_bufsize$ = 20						; size = 4
_HPAK_GetDataPointer PROC				; COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 628  : 	byte		*tmpbuf;
; 629  : 	string		pakname;
; 630  : 	hpak_header_t	header;
; 631  : 	hpak_info_t	directory;
; 632  : 	hpak_lump_t	*entry;
; 633  : 	hash_pack_queue_t	*p;
; 634  : 	file_t		*f;
; 635  : 	int		i;
; 636  : 
; 637  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@HPAK_GetDa

; 638  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN8@HPAK_GetDa:

; 639  : 
; 640  : 	if( buffer ) *buffer = NULL;

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN9@HPAK_GetDa
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [eax], 0
$LN9@HPAK_GetDa:

; 641  : 	if( bufsize ) *bufsize = 0;

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN10@HPAK_GetDa
	mov	eax, DWORD PTR _bufsize$[ebp]
	mov	DWORD PTR [eax], 0
$LN10@HPAK_GetDa:

; 642  : 
; 643  : 	for( p = gp_hpak_queue; p != NULL; p = p->next )

	mov	eax, DWORD PTR _gp_hpak_queue
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@HPAK_GetDa
$LN2@HPAK_GetDa:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@HPAK_GetDa:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@HPAK_GetDa

; 644  : 	{
; 645  : 		if( !Q_stricmp(p->name, filename ) && !memcmp( p->resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@HPAK_GetDa
	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@HPAK_GetDa

; 646  : 		{
; 647  : 			if( buffer )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN12@HPAK_GetDa

; 648  : 			{
; 649  : 				tmpbuf = Z_Malloc( p->size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmpbuf$[ebp], eax

; 650  : 				memcpy( tmpbuf, p->data, p->size );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	mov	ecx, DWORD PTR _tmpbuf$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 651  : 				*buffer = tmpbuf;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, DWORD PTR _tmpbuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@HPAK_GetDa:

; 652  : 			}
; 653  : 
; 654  : 			if( bufsize )

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN13@HPAK_GetDa

; 655  : 				*bufsize = p->size;

	mov	eax, DWORD PTR _bufsize$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax], edx
$LN13@HPAK_GetDa:

; 656  : 
; 657  : 			return true;

	mov	eax, 1
	jmp	$LN1@HPAK_GetDa
$LN11@HPAK_GetDa:

; 658  : 		}
; 659  : 	}

	jmp	$LN2@HPAK_GetDa
$LN3@HPAK_GetDa:

; 660  : 
; 661  : 	Q_strncpy( pakname, filename, sizeof( pakname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 662  : 	COM_ReplaceExtension( pakname, ".hpk" );

	push	OFFSET ??_C@_04GLEGJMFH@?4hpk@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_COM_ReplaceExtension
	add	esp, 8

; 663  : 
; 664  : 	f = FS_Open( pakname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 665  : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN14@HPAK_GetDa
	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN14@HPAK_GetDa:

; 666  : 
; 667  : 	FS_Read( f, &header, sizeof( header ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 668  : 
; 669  : 	if( header.ident != IDHPAKHEADER )

	cmp	DWORD PTR _header$[ebp], 1262571592	; 4b415048H
	je	SHORT $LN15@HPAK_GetDa

; 670  : 	{
; 671  : 		Con_DPrintf( S_ERROR "%s it's not a HPK file.\n", pakname );

	lea	eax, DWORD PTR _pakname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@GBNIDNEA@?$FO1Error?3?$FO7?5?$CFs?5it?8s?5not?5a?5HPK?5fi@
	call	_Con_DPrintf
	add	esp, 8

; 672  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 673  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN15@HPAK_GetDa:

; 674  : 	}
; 675  : 
; 676  : 	if( header.version != IDHPAK_VERSION )

	cmp	DWORD PTR _header$[ebp+4], 1
	je	SHORT $LN16@HPAK_GetDa

; 677  : 	{
; 678  : 		Con_DPrintf( S_ERROR "%s has invalid version (%i should be %i).\n", pakname, header.version, IDHPAK_VERSION );

	push	1
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _pakname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DG@MMPDDPIN@?$FO1Error?3?$FO7?5?$CFs?5has?5invalid?5versi@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 679  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 680  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN16@HPAK_GetDa:

; 681  : 	}
; 682  : 
; 683  : 	FS_Seek( f, header.infotableofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 684  : 	FS_Read( f, &directory.count, sizeof( directory.count ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 685  : 
; 686  : 	if( directory.count < 1 || directory.count > HPAK_MAX_ENTRIES )

	cmp	DWORD PTR _directory$[ebp], 1
	jl	SHORT $LN18@HPAK_GetDa
	cmp	DWORD PTR _directory$[ebp], 32768	; 00008000H
	jle	SHORT $LN17@HPAK_GetDa
$LN18@HPAK_GetDa:

; 687  : 	{
; 688  : 		Con_DPrintf( S_ERROR "HPAK_GetDataPointer: %s has too many lumps %u.\n", filename, directory.count );

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DL@NBCLJLCG@?$FO1Error?3?$FO7?5HPAK_GetDataPointer?3@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 689  : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 690  : 		return false;

	xor	eax, eax
	jmp	$LN1@HPAK_GetDa
$LN17@HPAK_GetDa:

; 691  : 	}
; 692  : 
; 693  : 	directory.entries = Z_Malloc( sizeof( hpak_lump_t ) * directory.count );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
	add	eax, 66					; 00000042H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _directory$[ebp], 144
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _directory$[ebp+4], eax

; 694  : 	FS_Read( f, directory.entries, sizeof( hpak_lump_t ) * directory.count );

	imul	eax, DWORD PTR _directory$[ebp], 144
	push	eax
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 695  : 
; 696  : 	for( i = 0; i < directory.count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@HPAK_GetDa
$LN5@HPAK_GetDa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@HPAK_GetDa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp]
	jge	$LN6@HPAK_GetDa

; 697  : 	{
; 698  : 		entry = &directory.entries[i];

	imul	eax, DWORD PTR _i$[ebp], 144
	add	eax, DWORD PTR _directory$[ebp+4]
	mov	DWORD PTR _entry$[ebp], eax

; 699  : 
; 700  : 		if( !memcmp( entry->resource.rgucMD5_hash, pResource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _entry$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN19@HPAK_GetDa

; 701  : 		{
; 702  : 			FS_Seek( f, entry->filepos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 703  : 
; 704  : 			if( buffer && entry->disksize > 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN20@HPAK_GetDa
	mov	eax, DWORD PTR _entry$[ebp]
	cmp	DWORD PTR [eax+140], 0
	jle	SHORT $LN20@HPAK_GetDa

; 705  : 			{
; 706  : 				tmpbuf = Z_Malloc( entry->disksize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
	add	eax, 79					; 0000004fH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tmpbuf$[ebp], eax

; 707  : 				FS_Read( f, tmpbuf, entry->disksize );

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	mov	edx, DWORD PTR _tmpbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 708  : 				*buffer = tmpbuf;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, DWORD PTR _tmpbuf$[ebp]
	mov	DWORD PTR [eax], ecx
$LN20@HPAK_GetDa:

; 709  : 			}
; 710  : 
; 711  : 			if( bufsize )

	cmp	DWORD PTR _bufsize$[ebp], 0
	je	SHORT $LN21@HPAK_GetDa

; 712  : 				*bufsize = entry->disksize;

	mov	eax, DWORD PTR _bufsize$[ebp]
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR [eax], edx
$LN21@HPAK_GetDa:

; 713  : 
; 714  : 			Mem_Free( directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
	add	eax, 87					; 00000057H
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 715  : 			FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 716  : 
; 717  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@HPAK_GetDa
$LN19@HPAK_GetDa:

; 718  : 		}
; 719  : 	}

	jmp	$LN5@HPAK_GetDa
$LN6@HPAK_GetDa:

; 720  : 
; 721  : 	Mem_Free( directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??HPAK_GetDataPointer@@9@9
	add	eax, 94					; 0000005eH
	push	eax
	push	OFFSET ??_C@_0DB@EOHHJLAI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _directory$[ebp+4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 722  : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 723  : 
; 724  : 	return false;

	xor	eax, eax
$LN1@HPAK_GetDa:

; 725  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_GetDataPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\hpak.c
;	COMDAT _HPAK_Init
_TEXT	SEGMENT
_HPAK_Init PROC						; COMDAT

; 1074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1075 : 	Cmd_AddCommand( "hpklist", HPAK_List_f, "list all files in specified HPK-file" );

	push	OFFSET ??_C@_0CF@DBBBACOF@list?5all?5files?5in?5specified?5HPK@
	push	OFFSET _HPAK_List_f
	push	OFFSET ??_C@_07BAIAPMBE@hpklist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1076 : 	Cmd_AddCommand( "hpkremove", HPAK_Remove_f, "remove specified file from HPK-file" );

	push	OFFSET ??_C@_0CE@MKDFGPML@remove?5specified?5file?5from?5HPK?9@
	push	OFFSET _HPAK_Remove_f
	push	OFFSET ??_C@_09MKLICMHH@hpkremove@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1077 : 	Cmd_AddCommand( "hpkval", HPAK_Validate_f, "validate specified HPK-file" );

	push	OFFSET ??_C@_0BM@FJFCFND@validate?5specified?5HPK?9file@
	push	OFFSET _HPAK_Validate_f
	push	OFFSET ??_C@_06PBADBDGC@hpkval@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1078 : 	Cmd_AddCommand( "hpkextract", HPAK_Extract_f, "extract all lumps from specified HPK-file" );

	push	OFFSET ??_C@_0CK@POANFOFL@extract?5all?5lumps?5from?5specifie@
	push	OFFSET _HPAK_Extract_f
	push	OFFSET ??_C@_0L@IAGFDGIJ@hpkextract@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1079 : 	hpk_maxsize = Cvar_Get( "hpk_maxsize", "0", FCVAR_ARCHIVE, "set limit by size for all HPK-files ( 0 - unlimited )" );

	push	OFFSET ??_C@_0DG@GIDNHDCE@set?5limit?5by?5size?5for?5all?5HPK?9f@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@OIFECNNA@hpk_maxsize@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hpk_maxsize, eax

; 1080 : 
; 1081 : 	gp_hpak_queue = NULL;

	mov	DWORD PTR _gp_hpak_queue, 0

; 1082 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HPAK_Init ENDP
_TEXT	ENDS
END
