; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_parse.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_UPDATE_BACKUP
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_DATA	SEGMENT
_CL_UPDATE_BACKUP DD 010H
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_CL_BatchResourceRequest
PUBLIC	_CL_EstimateNeededResources
PUBLIC	_CL_ParseUserMessage
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParseServerMessage
PUBLIC	_CL_StartResourceDownloading
PUBLIC	_CL_DispatchUserMessage
PUBLIC	_CL_RequestMissingResources
PUBLIC	_CL_RegisterResources
PUBLIC	_CL_ParseViewEntity
PUBLIC	_CL_ParseServerTime
PUBLIC	_CL_WeaponAnim
PUBLIC	_CL_UserMsgStub
PUBLIC	_CL_ParseSoundPacket
PUBLIC	_CL_ParseRestoreSoundPacket
PUBLIC	_CL_ParseSignon
PUBLIC	_CL_ParseMovevars
PUBLIC	_CL_ParseParticles
PUBLIC	_CL_ParseStaticEntity
PUBLIC	_CL_ParseStaticDecal
PUBLIC	_CL_ParseSoundFade
PUBLIC	_CL_PlayerHasCustomization
PUBLIC	_CL_RemoveCustomization
PUBLIC	_CL_ParseCustomization
PUBLIC	_CL_ParseResourceRequest
PUBLIC	_CL_CreateCustomizationList
PUBLIC	_CL_ParseFileTransferFailed
PUBLIC	_CL_ParseServerData
PUBLIC	_CL_ParseClientData
PUBLIC	_CL_ParseBaseline
PUBLIC	_CL_ParseLightStyle
PUBLIC	_CL_ParseSetAngle
PUBLIC	_CL_ParseAddAngle
PUBLIC	_CL_ParseCrosshairAngle
PUBLIC	_CL_ParseRestore
PUBLIC	_CL_RegisterUserMessage
PUBLIC	_CL_UpdateUserinfo
PUBLIC	_CL_ParseResource
PUBLIC	_CL_UpdateUserPings
PUBLIC	_CL_SendConsistencyInfo
PUBLIC	_CL_ParseConsistencyInfo
PUBLIC	_CL_ParseResourceList
PUBLIC	_CL_ParseVoiceInit
PUBLIC	_CL_ParseVoiceData
PUBLIC	_CL_ParseResLocation
PUBLIC	_CL_ParseHLTV
PUBLIC	_CL_ParseDirector
PUBLIC	_CL_ParseScreenShake
PUBLIC	_CL_ParseScreenFade
PUBLIC	_CL_ParseCvarValue
PUBLIC	_CL_ParseCvarValue2
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	??_C@_04PNECFKGD@?$CB?$CD?$CFi@			; `string'
PUBLIC	??_C@_03EMIMLMFN@?$CB?$CFi@			; `string'
PUBLIC	??_C@_0CK@FAALJMMG@?$FO1Error?3?$FO7?5received?5signon?5?$CFi?5w@ ; `string'
PUBLIC	??_C@_0DA@DJCKFABC@?$FO1Error?3?$FO7?5MAX_STATIC_ENTITIES?5@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_BatchResourceRequest@@9@9	; `CL_BatchResourceRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0P@PBAOHMHN@Resource?5Batch@		; `string'
PUBLIC	??_C@_0CB@DIKFALJD@skipping?5in?5game?5download?5of?5?$CFs@ ; `string'
PUBLIC	??_C@_0L@DHBFCELB@custom?4hpk@			; `string'
PUBLIC	??_C@_06OIINFDDP@?$CBMD5?$CFs@			; `string'
PUBLIC	??_C@_09MCMGNHCF@dlfile?5?$CFs@			; `string'
PUBLIC	??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_06PBLIODKG@sound?1@			; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	?__LINE__Var@?0??CL_RemoveCustomization@@9@9	; `CL_RemoveCustomization'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CL_ParseCustomization@@9@9	; `CL_ParseCustomization'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@PPFGOFIF@Bogus?5player?5index?5during?5custo@ ; `string'
PUBLIC	??_C@_0DD@HIGAHDMA@Refusing?5new?5resource?0?5cl_allow@ ; `string'
PUBLIC	??_C@_0DE@DCAOBOII@Refusing?5new?5resource?0?5cl_downl@ ; `string'
PUBLIC	??_C@_0CN@PIGKFMHO@Duplicate?5resource?5ignored?5for?5@ ; `string'
PUBLIC	??_C@_0BN@FNDBGDPC@Error?5loading?5customization?6@ ; `string'
PUBLIC	??_C@_0BL@FBLPINIB@Requesting?5?$CFs?5from?5server?6@ ; `string'
PUBLIC	??_C@_0CA@FNPNCIJB@Custom?5resource?5propagation?4?4?4?6@ ; `string'
PUBLIC	??_C@_0O@JDFFKBEB@ResourceBlock@		; `string'
PUBLIC	??_C@_0DC@BNJLCICG@problem?5with?5client?5customizati@ ; `string'
PUBLIC	??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@ ; `string'
PUBLIC	??_C@_0CP@HFLGMBDE@Server?5use?5invalid?5protocol?5?$CI?$CFi@ ; `string'
PUBLIC	??_C@_0EF@NIEABAID@?$FO3Warning?3?$FO7?5server?5model?5limit@ ; `string'
PUBLIC	??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@ ; `string'
PUBLIC	??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@		; `string'
PUBLIC	??_C@_08EOJKMECK@user?4scr@			; `string'
PUBLIC	??_C@_08HELCJCPN@r_decals@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_04CELKIKPL@16x9@				; `string'
PUBLIC	??_C@_03PHLBDMN@4x3@				; `string'
PUBLIC	??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@	; `string'
PUBLIC	??_C@_0BC@CBJAHLIN@cl_levelshot_name@		; `string'
PUBLIC	??_C@_0M@DKOEGGOG@scr_loading@			; `string'
PUBLIC	??_C@_06PCEOMGLN@?$CFs?4bmp@			; `string'
PUBLIC	??_C@_06FPKCCFDN@?$CKblack@			; `string'
PUBLIC	??_C@_0M@GJFFFGGI@sendres?5?$CFi?6@		; `string'
PUBLIC	??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@ ; `string'
PUBLIC	??_C@_0BI@NMNIPOFK@Loading?5decals?5from?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DK@EBNIKKOK@CL_ParseServerMessage?3?5svc_upda@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_08OLGKFJAO@topcolor@			; `string'
PUBLIC	??_C@_0M@IIFIMDEK@bottomcolor@			; `string'
PUBLIC	??_C@_05BKCFBCMH@?$CKhltv@			; `string'
PUBLIC	?__LINE__Var@?0??CL_ParseResource@@9@9		; `CL_ParseResource'::`1'::__LINE__Var
PUBLIC	??_C@_0DA@DNJCFMMH@CL_ParseServerMessage?3?5svc_ping@ ; `string'
PUBLIC	??_C@_07FLCBLKFO@models?1@			; `string'
PUBLIC	??_C@_0BD@JCEFBOLO@unable?5to?5find?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BN@OHBAENKB@Unknown?5consistency?5type?5?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_RegisterResources@@9@9	; `CL_RegisterResources'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_0BI@DBOGADI@Setting?5up?5renderer?4?4?4?6@ ; `string'
PUBLIC	??_C@_08ELOHMNAO@spawn?5?$CFi@			; `string'
PUBLIC	??_C@_0CH@PNJNFGNI@?$FO1Error?3?$FO7?5client?5world?5model?5i@ ; `string'
PUBLIC	??_C@_0DF@HMJJDGBG@CL_CheckConsistency?3?5MAX_MODELS@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_ParseResourceList@@9@9	; `CL_ParseResourceList'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@PCFEBNGI@Verifying?5and?5downloading?5resou@ ; `string'
PUBLIC	??_C@_07FGAOOBMN@http?3?1?1@			; `string'
PUBLIC	??_C@_08MFLLBFBE@https?3?1?1@			; `string'
PUBLIC	??_C@_03NPMJBIL@?$CFs?1@			; `string'
PUBLIC	??_C@_0CH@FAFMLCKJ@Using?5?$CFs?5as?5primary?5download?5lo@ ; `string'
PUBLIC	??_C@_09CFCBFJND@Not?5Found@			; `string'
PUBLIC	??_C@_07JOOEPKKD@?$CFs?5?$CI?$CFg?$CJ@		; `string'
PUBLIC	??_C@_0CE@GAELJHHC@?$FO1Error?3?$FO7?5UserMsg?3?5bad?5message@ ; `string'
PUBLIC	??_C@_0CC@OJAEEBDK@?$FO1Error?3?$FO7?5UserMsg?3?5No?5pfn?5?$CFs?5?$CF@ ; `string'
PUBLIC	??_C@_0DC@NEHPOEGF@CL_ParseUserMessage?3?5illegible?5@ ; `string'
PUBLIC	??_C@_0M@FNPJCEOM@ScreenShake@			; `string'
PUBLIC	??_C@_0L@OBKHMDDA@ScreenFade@			; `string'
PUBLIC	??_C@_07JNEKKACO@HudText@			; `string'
PUBLIC	??_C@_07CINOGAJB@fareast@			; `string'
PUBLIC	??_C@_04FBPNLAPJ@END3@				; `string'
PUBLIC	??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@ ; `string'
PUBLIC	??_C@_08CIDIFPDB@svc_bad?6@			; `string'
PUBLIC	??_C@_0BP@LJOKNLCP@Server?5changing?0?5reconnecting?6@ ; `string'
PUBLIC	??_C@_0CD@HKBNHCMP@Server?5disconnected?0?5reconnecti@ ; `string'
PUBLIC	??_C@_0L@KKPFIJOL@disconnect@			; `string'
PUBLIC	??_C@_09CFHPPHOC@room_type@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@39800000
PUBLIC	__real@3a83126f
PUBLIC	__real@3b800000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3d800000
PUBLIC	__real@3e000000
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@42800000
PUBLIC	__real@437f0000
PUBLIC	__real@45800000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c000000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strrchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Host_AbortCurrentFrame:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Host_Credits:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_Init:PROC
EXTRN	_CRC32_Final:PROC
EXTRN	_CRC32_File:PROC
EXTRN	_MD5_HashFile:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_COM_SizeofResourceList:PROC
EXTRN	_CSCR_LoadDefaultCVars:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_R_DecalRemoveAll:PROC
EXTRN	_CL_ServerCommand:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_CL_Disconnect:PROC
EXTRN	_CL_Drop:PROC
EXTRN	_SCR_BeginLoadingPlaque:PROC
EXTRN	_Con_Print:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_fabs:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_Mod_ValidateCRC:PROC
EXTRN	_Mod_NeedCRC:PROC
EXTRN	_Mod_FreeUnused:PROC
EXTRN	_Mod_GetStudioBounds:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteShort:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadOneBit:PROC
EXTRN	_MSG_ReadBitAngle:PROC
EXTRN	_MSG_ReadSBitLong:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadFloat:PROC
EXTRN	_MSG_ReadVec3Coord:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_CL_SetLightstyle:PROC
EXTRN	_CL_CheckFile:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_RemoveFromResourceList:PROC
EXTRN	_CL_MoveToOnHandList:PROC
EXTRN	_CL_Parse_Debug:PROC
EXTRN	_CL_Parse_RecordCommand:PROC
EXTRN	_CL_ResetFrame:PROC
EXTRN	_CL_ProcessFile:PROC
EXTRN	_CL_PrecacheResources:PROC
EXTRN	_CL_SetupOverviewParams:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_ClearState:PROC
EXTRN	_CL_WriteDemoMessage:PROC
EXTRN	_CL_ParseEvent:PROC
EXTRN	_CL_ParseReliableEvent:PROC
EXTRN	_CL_LinkUserMessage:PROC
EXTRN	_CL_ParseFinaleCutscene:PROC
EXTRN	_CL_InitEdicts:PROC
EXTRN	_CL_ClearWorld:PROC
EXTRN	_CL_CenterPrint:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_ParseTempEntity:PROC
EXTRN	_SCR_EndLoadingPlaque:PROC
EXTRN	_CL_ParsePacketEntities:PROC
EXTRN	_CL_ResetLatchedVars:PROC
EXTRN	_CL_IsPlayerIndex:PROC
EXTRN	_CL_FireCustomDecal:PROC
EXTRN	_CL_AddClientResources:PROC
EXTRN	_CL_LoadClientSprites:PROC
EXTRN	_Con_FixedFont:PROC
EXTRN	_Con_ClearNotify:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_RestoreSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_S_AmbientSound:PROC
EXTRN	_S_FadeClientVolume:PROC
EXTRN	_Delta_InitClient:PROC
EXTRN	_Delta_ParseTableField:PROC
EXTRN	_MSG_ReadDeltaMovevars:PROC
EXTRN	_MSG_ReadClientData:PROC
EXTRN	_MSG_ReadWeaponData:PROC
EXTRN	_MSG_ReadDeltaEntity:PROC
EXTRN	_R_SetupSky:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_R_AddEfrags:PROC
EXTRN	_R_NewMap:PROC
EXTRN	_R_AllocParticle:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_CL_DecalIndex:PROC
EXTRN	_IN_MouseRestorePos:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_mp_decals:BYTE
EXTRN	_cl_allow_download:BYTE
EXTRN	_cl_download_ingame:BYTE
EXTRN	_cl_levelshot_name:DWORD
EXTRN	_cl_clockreset:DWORD
EXTRN	_glState:BYTE
EXTRN	_r_decals:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b800000
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@39800000
CONST	SEGMENT
__real@39800000 DD 039800000r			; 0.000244141
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_09CFHPPHOC@room_type@
CONST	SEGMENT
??_C@_09CFHPPHOC@room_type@ DB 'room_type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKPFIJOL@disconnect@
CONST	SEGMENT
??_C@_0L@KKPFIJOL@disconnect@ DB 'disconnect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HKBNHCMP@Server?5disconnected?0?5reconnecti@
CONST	SEGMENT
??_C@_0CD@HKBNHCMP@Server?5disconnected?0?5reconnecti@ DB 'Server disconn'
	DB	'ected, reconnecting', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJOKNLCP@Server?5changing?0?5reconnecting?6@
CONST	SEGMENT
??_C@_0BP@LJOKNLCP@Server?5changing?0?5reconnecting?6@ DB 'Server changin'
	DB	'g, reconnecting', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIDIFPDB@svc_bad?6@
CONST	SEGMENT
??_C@_08CIDIFPDB@svc_bad?6@ DB 'svc_bad', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@
CONST	SEGMENT
??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@ DB 'CL_ParseServerM'
	DB	'essage: overflow!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FBPNLAPJ@END3@
CONST	SEGMENT
??_C@_04FBPNLAPJ@END3@ DB 'END3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CINOGAJB@fareast@
CONST	SEGMENT
??_C@_07CINOGAJB@fareast@ DB 'fareast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNEKKACO@HudText@
CONST	SEGMENT
??_C@_07JNEKKACO@HudText@ DB 'HudText', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OBKHMDDA@ScreenFade@
CONST	SEGMENT
??_C@_0L@OBKHMDDA@ScreenFade@ DB 'ScreenFade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNPJCEOM@ScreenShake@
CONST	SEGMENT
??_C@_0M@FNPJCEOM@ScreenShake@ DB 'ScreenShake', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NEHPOEGF@CL_ParseUserMessage?3?5illegible?5@
CONST	SEGMENT
??_C@_0DC@NEHPOEGF@CL_ParseUserMessage?3?5illegible?5@ DB 'CL_ParseUserMe'
	DB	'ssage: illegible server message %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OJAEEBDK@?$FO1Error?3?$FO7?5UserMsg?3?5No?5pfn?5?$CFs?5?$CF@
CONST	SEGMENT
??_C@_0CC@OJAEEBDK@?$FO1Error?3?$FO7?5UserMsg?3?5No?5pfn?5?$CFs?5?$CF@ DB '^'
	DB	'1Error:^7 UserMsg: No pfn %s %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GAELJHHC@?$FO1Error?3?$FO7?5UserMsg?3?5bad?5message@
CONST	SEGMENT
??_C@_0CE@GAELJHHC@?$FO1Error?3?$FO7?5UserMsg?3?5bad?5message@ DB '^1Erro'
	DB	'r:^7 UserMsg: bad message %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JOOEPKKD@?$CFs?5?$CI?$CFg?$CJ@
CONST	SEGMENT
??_C@_07JOOEPKKD@?$CFs?5?$CI?$CFg?$CJ@ DB '%s (%g)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFCBFJND@Not?5Found@
CONST	SEGMENT
??_C@_09CFCBFJND@Not?5Found@ DB 'Not Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FAFMLCKJ@Using?5?$CFs?5as?5primary?5download?5lo@
CONST	SEGMENT
??_C@_0CH@FAFMLCKJ@Using?5?$CFs?5as?5primary?5download?5lo@ DB 'Using %s '
	DB	'as primary download location', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03NPMJBIL@?$CFs?1@
CONST	SEGMENT
??_C@_03NPMJBIL@?$CFs?1@ DB '%s/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFLLBFBE@https?3?1?1@
CONST	SEGMENT
??_C@_08MFLLBFBE@https?3?1?1@ DB 'https://', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAOOBMN@http?3?1?1@
CONST	SEGMENT
??_C@_07FGAOOBMN@http?3?1?1@ DB 'http://', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PCFEBNGI@Verifying?5and?5downloading?5resou@
CONST	SEGMENT
??_C@_0CI@PCFEBNGI@Verifying?5and?5downloading?5resou@ DB 'Verifying and '
	DB	'downloading resources...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ParseResourceList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ParseResourceList@@9@9 DD 0649H	; `CL_ParseResourceList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@HMJJDGBG@CL_CheckConsistency?3?5MAX_MODELS@
CONST	SEGMENT
??_C@_0DF@HMJJDGBG@CL_CheckConsistency?3?5MAX_MODELS@ DB 'CL_CheckConsist'
	DB	'ency: MAX_MODELS limit exceeded (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PNJNFGNI@?$FO1Error?3?$FO7?5client?5world?5model?5i@
CONST	SEGMENT
??_C@_0CH@PNJNFGNI@?$FO1Error?3?$FO7?5client?5world?5model?5i@ DB '^1Erro'
	DB	'r:^7 client world model is NULL', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ELOHMNAO@spawn?5?$CFi@
CONST	SEGMENT
??_C@_08ELOHMNAO@spawn?5?$CFi@ DB 'spawn %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DBOGADI@Setting?5up?5renderer?4?4?4?6@
CONST	SEGMENT
??_C@_0BI@DBOGADI@Setting?5up?5renderer?4?4?4?6@ DB 'Setting up renderer.'
	DB	'..', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_RegisterResources@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_RegisterResources@@9@9 DD 05c3H	; `CL_RegisterResources'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@OHBAENKB@Unknown?5consistency?5type?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@OHBAENKB@Unknown?5consistency?5type?5?$CFi?6@ DB 'Unknown consi'
	DB	'stency type %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JCEFBOLO@unable?5to?5find?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@JCEFBOLO@unable?5to?5find?5?$CFs?6@ DB 'unable to find %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLCBLKFO@models?1@
CONST	SEGMENT
??_C@_07FLCBLKFO@models?1@ DB 'models/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNJCFMMH@CL_ParseServerMessage?3?5svc_ping@
CONST	SEGMENT
??_C@_0DA@DNJCFMMH@CL_ParseServerMessage?3?5svc_ping@ DB 'CL_ParseServerM'
	DB	'essage: svc_pings > MAX_CLIENTS', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ParseResource@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ParseResource@@9@9 DD 054cH		; `CL_ParseResource'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05BKCFBCMH@?$CKhltv@
CONST	SEGMENT
??_C@_05BKCFBCMH@?$CKhltv@ DB '*hltv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIFIMDEK@bottomcolor@
CONST	SEGMENT
??_C@_0M@IIFIMDEK@bottomcolor@ DB 'bottomcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLGKFJAO@topcolor@
CONST	SEGMENT
??_C@_08OLGKFJAO@topcolor@ DB 'topcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EBNIKKOK@CL_ParseServerMessage?3?5svc_upda@
CONST	SEGMENT
??_C@_0DK@EBNIKKOK@CL_ParseServerMessage?3?5svc_upda@ DB 'CL_ParseServerM'
	DB	'essage: svc_updateuserinfo >= MAX_CLIENTS', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMNIPOFK@Loading?5decals?5from?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@NMNIPOFK@Loading?5decals?5from?5?$CFs?6@ DB 'Loading decals fro'
	DB	'm %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@
CONST	SEGMENT
??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@ DB 'CL_AllocEdict'
	DB	': no free edicts', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GJFFFGGI@sendres?5?$CFi?6@
CONST	SEGMENT
??_C@_0M@GJFFFGGI@sendres?5?$CFi?6@ DB 'sendres %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPKCCFDN@?$CKblack@
CONST	SEGMENT
??_C@_06FPKCCFDN@?$CKblack@ DB '*black', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCEOMGLN@?$CFs?4bmp@
CONST	SEGMENT
??_C@_06PCEOMGLN@?$CFs?4bmp@ DB '%s.bmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKOEGGOG@scr_loading@
CONST	SEGMENT
??_C@_0M@DKOEGGOG@scr_loading@ DB 'scr_loading', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
CONST	SEGMENT
??_C@_0BC@CBJAHLIN@cl_levelshot_name@ DB 'cl_levelshot_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
CONST	SEGMENT
??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@ DB 'levelshots/%s_%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHLBDMN@4x3@
CONST	SEGMENT
??_C@_03PHLBDMN@4x3@ DB '4x3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CELKIKPL@16x9@
CONST	SEGMENT
??_C@_04CELKIKPL@16x9@ DB '16x9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08HELCJCPN@r_decals@
CONST	SEGMENT
??_C@_08HELCJCPN@r_decals@ DB 'r_decals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOJKMECK@user?4scr@
CONST	SEGMENT
??_C@_08EOJKMECK@user?4scr@ DB 'user.scr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@
CONST	SEGMENT
??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@ DB '%c%s', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@
CONST	SEGMENT
??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@ DB 0aH
	DB	01dH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01fH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NIEABAID@?$FO3Warning?3?$FO7?5server?5model?5limit@
CONST	SEGMENT
??_C@_0EF@NIEABAID@?$FO3Warning?3?$FO7?5server?5model?5limit@ DB '^3Warni'
	DB	'ng:^7 server model limit is above client model limit %i > %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HFLGMBDE@Server?5use?5invalid?5protocol?5?$CI?$CFi@
CONST	SEGMENT
??_C@_0CP@HFLGMBDE@Server?5use?5invalid?5protocol?5?$CI?$CFi@ DB 'Server '
	DB	'use invalid protocol (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@
CONST	SEGMENT
??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@ DB 'Serverdata packe'
	DB	't received.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BNJLCICG@problem?5with?5client?5customizati@
CONST	SEGMENT
??_C@_0DC@BNJLCICG@problem?5with?5client?5customizati@ DB 'problem with c'
	DB	'lient customization %s, ignoring...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDFFKBEB@ResourceBlock@
CONST	SEGMENT
??_C@_0O@JDFFKBEB@ResourceBlock@ DB 'ResourceBlock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FNPNCIJB@Custom?5resource?5propagation?4?4?4?6@
CONST	SEGMENT
??_C@_0CA@FNPNCIJB@Custom?5resource?5propagation?4?4?4?6@ DB 'Custom reso'
	DB	'urce propagation...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FBLPINIB@Requesting?5?$CFs?5from?5server?6@
CONST	SEGMENT
??_C@_0BL@FBLPINIB@Requesting?5?$CFs?5from?5server?6@ DB 'Requesting %s f'
	DB	'rom server', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FNDBGDPC@Error?5loading?5customization?6@
CONST	SEGMENT
??_C@_0BN@FNDBGDPC@Error?5loading?5customization?6@ DB 'Error loading cus'
	DB	'tomization', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PIGKFMHO@Duplicate?5resource?5ignored?5for?5@
CONST	SEGMENT
??_C@_0CN@PIGKFMHO@Duplicate?5resource?5ignored?5for?5@ DB 'Duplicate res'
	DB	'ource ignored for local client', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DCAOBOII@Refusing?5new?5resource?0?5cl_downl@
CONST	SEGMENT
??_C@_0DE@DCAOBOII@Refusing?5new?5resource?0?5cl_downl@ DB 'Refusing new '
	DB	'resource, cl_download_ingame set to 0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HIGAHDMA@Refusing?5new?5resource?0?5cl_allow@
CONST	SEGMENT
??_C@_0DD@HIGAHDMA@Refusing?5new?5resource?0?5cl_allow@ DB 'Refusing new '
	DB	'resource, cl_allow_download set to 0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PPFGOFIF@Bogus?5player?5index?5during?5custo@
CONST	SEGMENT
??_C@_0DC@PPFGOFIF@Bogus?5player?5index?5during?5custo@ DB 'Bogus player '
	DB	'index during customization parsing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ParseCustomization@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ParseCustomization@@9@9 DD 02a2H	; `CL_ParseCustomization'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CL_RemoveCustomization@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_RemoveCustomization@@9@9 DD 027dH	; `CL_RemoveCustomization'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBLIODKG@sound?1@
CONST	SEGMENT
??_C@_06PBLIODKG@sound?1@ DB 'sound/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_parse.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCMGNHCF@dlfile?5?$CFs@
CONST	SEGMENT
??_C@_09MCMGNHCF@dlfile?5?$CFs@ DB 'dlfile %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIINFDDP@?$CBMD5?$CFs@
CONST	SEGMENT
??_C@_06OIINFDDP@?$CBMD5?$CFs@ DB '!MD5%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBFCELB@custom?4hpk@
CONST	SEGMENT
??_C@_0L@DHBFCELB@custom?4hpk@ DB 'custom.hpk', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DIKFALJD@skipping?5in?5game?5download?5of?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DIKFALJD@skipping?5in?5game?5download?5of?5?$CFs@ DB 'skipping '
	DB	'in game download of %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PBAOHMHN@Resource?5Batch@
CONST	SEGMENT
??_C@_0P@PBAOHMHN@Resource?5Batch@ DB 'Resource Batch', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_BatchResourceRequest@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_BatchResourceRequest@@9@9 DD 01c9H	; `CL_BatchResourceRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DA@DJCKFABC@?$FO1Error?3?$FO7?5MAX_STATIC_ENTITIES?5@
CONST	SEGMENT
??_C@_0DA@DJCKFABC@?$FO1Error?3?$FO7?5MAX_STATIC_ENTITIES?5@ DB '^1Error:'
	DB	'^7 MAX_STATIC_ENTITIES limit exceeded!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FAALJMMG@?$FO1Error?3?$FO7?5received?5signon?5?$CFi?5w@
CONST	SEGMENT
??_C@_0CK@FAALJMMG@?$FO1Error?3?$FO7?5received?5signon?5?$CFi?5w@ DB '^1E'
	DB	'rror:^7 received signon %i when at %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMLMFN@?$CB?$CFi@
CONST	SEGMENT
??_C@_03EMIMLMFN@?$CB?$CFi@ DB '!%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNECFKGD@?$CB?$CD?$CFi@
CONST	SEGMENT
??_C@_04PNECFKGD@?$CB?$CD?$CFi@ DB '!#%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	053H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02acH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0a1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	017aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	052aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05aeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01faH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0c5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02d1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01c3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01edH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01d6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0deH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0229H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0351H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseCvarValue2
_TEXT	SEGMENT
tv145 = -80						; size = 4
_cvar$ = -12						; size = 4
_cvarName$ = -8						; size = 4
_requestID$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseCvarValue2 PROC				; COMDAT

; 1830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1831 : 	int requestID = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _requestID$[ebp], eax

; 1832 : 	const char *cvarName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _cvarName$[ebp], eax

; 1833 : 	convar_t *cvar = Cvar_FindVar( cvarName );

	push	0
	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cvar$[ebp], eax

; 1834 : 
; 1835 : 	// build the answer
; 1836 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_requestcvarvalue2 );

	push	0
	push	0
	push	10					; 0000000aH
	push	OFFSET _cls+26900
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1837 : 	MSG_WriteLong( &cls.netchan.message, requestID );

	mov	eax, DWORD PTR _requestID$[ebp]
	push	eax
	push	OFFSET _cls+26900
	call	_MSG_WriteLong
	add	esp, 8

; 1838 : 	MSG_WriteString( &cls.netchan.message, cvarName );

	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8

; 1839 : 
; 1840 : 	if( cvar )

	cmp	DWORD PTR _cvar$[ebp], 0
	je	SHORT $LN2@CL_ParseCv

; 1841 : 	{
; 1842 : 		// cheater can change value ignoring Cvar_Set so we responce incorrect value
; 1843 : 		if( cvar->value != Q_atof( cvar->string ))

	mov	eax, DWORD PTR _cvar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR _cvar$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	ucomiss	xmm0, DWORD PTR tv145[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@CL_ParseCv

; 1844 : 			MSG_WriteString( &cls.netchan.message, va( "%s (%g)", cvar->string, cvar->value ));

	mov	eax, DWORD PTR _cvar$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cvar$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_07JOOEPKKD@?$CFs?5?$CI?$CFg?$CJ@
	call	_va
	add	esp, 16					; 00000010H
	push	eax
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN5@CL_ParseCv
$LN4@CL_ParseCv:

; 1845 : 		else MSG_WriteString( &cls.netchan.message, cvar->string );

	mov	eax, DWORD PTR _cvar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8
$LN5@CL_ParseCv:

; 1846 : 	}	

	jmp	SHORT $LN3@CL_ParseCv
$LN2@CL_ParseCv:

; 1847 : 	else
; 1848 : 	{
; 1849 : 		MSG_WriteString( &cls.netchan.message, "Not Found" );

	push	OFFSET ??_C@_09CFCBFJND@Not?5Found@
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8
$LN3@CL_ParseCv:

; 1850 : 	}
; 1851 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseCvarValue
_TEXT	SEGMENT
tv77 = -76						; size = 4
_cvar$ = -8						; size = 4
_cvarName$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseCvarValue PROC					; COMDAT

; 1812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1813 : 	const char *cvarName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _cvarName$[ebp], eax

; 1814 : 	convar_t *cvar = Cvar_FindVar( cvarName );

	push	0
	mov	eax, DWORD PTR _cvarName$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cvar$[ebp], eax

; 1815 : 
; 1816 : 	// build the answer
; 1817 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_requestcvarvalue );

	push	0
	push	0
	push	9
	push	OFFSET _cls+26900
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1818 : 	MSG_WriteString( &cls.netchan.message, cvar ? cvar->string : "Not Found" );

	cmp	DWORD PTR _cvar$[ebp], 0
	je	SHORT $LN3@CL_ParseCv
	mov	eax, DWORD PTR _cvar$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN4@CL_ParseCv
$LN3@CL_ParseCv:
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_09CFCBFJND@Not?5Found@
$LN4@CL_ParseCv:
	mov	edx, DWORD PTR tv77[ebp]
	push	edx
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8

; 1819 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseScreenFade
_TEXT	SEGMENT
tv76 = -84						; size = 4
_flScale$ = -16						; size = 4
_sf$ = -12						; size = 4
_holdTime$ = -8						; size = 4
_duration$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseScreenFade PROC				; COMDAT

; 1759 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1760 : 	float		duration, holdTime;
; 1761 : 	screenfade_t	*sf = &clgame.fade;

	mov	DWORD PTR _sf$[ebp], OFFSET _clgame+214928

; 1762 : 	float		flScale;
; 1763 : 
; 1764 : 	duration = (float)MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _duration$[ebp], xmm0

; 1765 : 	holdTime = (float)MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _holdTime$[ebp], xmm0

; 1766 : 	sf->fadeFlags = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1767 : 	flScale = ( sf->fadeFlags & FFADE_LONGFADE ) ? (1.0f / 256.0f) : (1.0f / 4096.0f);

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 8
	je	SHORT $LN8@CL_ParseSc
	movss	xmm0, DWORD PTR __real@3b800000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN9@CL_ParseSc
$LN8@CL_ParseSc:
	movss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR tv76[ebp], xmm0
$LN9@CL_ParseSc:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _flScale$[ebp], xmm0

; 1768 : 
; 1769 : 	sf->fader = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+16], al

; 1770 : 	sf->fadeg = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+17], al

; 1771 : 	sf->fadeb = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+18], al

; 1772 : 	sf->fadealpha = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _sf$[ebp]
	mov	BYTE PTR [ecx+19], al

; 1773 : 	sf->fadeSpeed = 0.0f;

	mov	eax, DWORD PTR _sf$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 1774 : 	sf->fadeEnd = duration * flScale;

	movss	xmm0, DWORD PTR _duration$[ebp]
	mulss	xmm0, DWORD PTR _flScale$[ebp]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1775 : 	sf->fadeReset = holdTime * flScale;

	movss	xmm0, DWORD PTR _holdTime$[ebp]
	mulss	xmm0, DWORD PTR _flScale$[ebp]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 1776 : 
; 1777 : 	// calc fade speed
; 1778 : 	if( duration > 0 )

	movss	xmm0, DWORD PTR _duration$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN4@CL_ParseSc

; 1779 : 	{
; 1780 : 		if( sf->fadeFlags & FFADE_OUT )

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 1
	je	SHORT $LN3@CL_ParseSc

; 1781 : 		{
; 1782 : 			if( sf->fadeEnd )

	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@CL_ParseSc

; 1783 : 			{
; 1784 : 				sf->fadeSpeed = -(float)sf->fadealpha / sf->fadeEnd;

	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	cvtsi2ss xmm0, ecx
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _sf$[ebp]
	divss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN5@CL_ParseSc:

; 1785 : 			}
; 1786 : 
; 1787 : 			sf->fadeEnd += cl.time;

	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1788 : 			sf->fadeReset += sf->fadeEnd;

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx+12], xmm0

; 1789 : 		}

	jmp	SHORT $LN4@CL_ParseSc
$LN3@CL_ParseSc:

; 1790 : 		else
; 1791 : 		{
; 1792 : 			if( sf->fadeEnd )

	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseSc

; 1793 : 			{
; 1794 : 				sf->fadeSpeed = (float)sf->fadealpha / sf->fadeEnd;

	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _sf$[ebp]
	divss	xmm0, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN6@CL_ParseSc:

; 1795 : 			}
; 1796 : 
; 1797 : 			sf->fadeReset += cl.time;

	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+12]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 1798 : 			sf->fadeEnd += sf->fadeReset;

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [edx+4], xmm0
$LN4@CL_ParseSc:

; 1799 : 		}
; 1800 : 	}
; 1801 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseScreenShake
_TEXT	SEGMENT
tv83 = -68						; size = 4
_msg$ = 8						; size = 4
_CL_ParseScreenShake PROC				; COMDAT

; 1743 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1744 : 	clgame.shake.amplitude = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<12));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR _clgame+214960, xmm0

; 1745 : 	clgame.shake.duration = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<12));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@39800000
	movss	DWORD PTR _clgame+214956, xmm0

; 1746 : 	clgame.shake.frequency = (float)(word)MSG_ReadShort( msg ) * (1.0f / (float)(1<<8));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	movzx	ecx, ax
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3b800000
	movss	DWORD PTR _clgame+214964, xmm0

; 1747 : 	clgame.shake.time = cl.time + max( clgame.shake.duration, 0.01f );

	movss	xmm0, DWORD PTR _clgame+214956
	comiss	xmm0, DWORD PTR __real@3c23d70a
	jbe	SHORT $LN3@CL_ParseSc
	movss	xmm0, DWORD PTR _clgame+214956
	movss	DWORD PTR tv83[ebp], xmm0
	jmp	SHORT $LN4@CL_ParseSc
$LN3@CL_ParseSc:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv83[ebp], xmm0
$LN4@CL_ParseSc:
	cvtss2sd xmm0, DWORD PTR tv83[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _clgame+214952, xmm0

; 1748 : 	clgame.shake.next_shake = 0.0f; // apply immediately

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+214968, xmm0

; 1749 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseScreenShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseDirector
_TEXT	SEGMENT
_pbuf$ = -264						; size = 256
_iSize$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseDirector PROC					; COMDAT

; 1726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1727 : 	int	iSize = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax

; 1728 : 	byte	pbuf[256];
; 1729 : 
; 1730 : 	// parse user message into buffer
; 1731 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1732 : 	clgame.dllFuncs.pfnDirectorMessage( iSize, pbuf );

	lea	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	call	DWORD PTR _clgame+156
	add	esp, 8

; 1733 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseDirector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseHLTV
_TEXT	SEGMENT
tv66 = -68						; size = 4
_msg$ = 8						; size = 4
_CL_ParseHLTV PROC					; COMDAT

; 1691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1692 : 	switch( MSG_ReadByte( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@CL_ParseHL
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@CL_ParseHL
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN6@CL_ParseHL
	jmp	$LN1@CL_ParseHL
$LN4@CL_ParseHL:

; 1693 : 	{
; 1694 : 	case HLTV_ACTIVE:
; 1695 : 		cl.proxy_redirect = true;

	mov	DWORD PTR _cl+72, 1

; 1696 : 		cls.spectator = true;

	mov	DWORD PTR _cls+152, 1

; 1697 : 		break;

	jmp	SHORT $LN1@CL_ParseHL
$LN5@CL_ParseHL:

; 1698 : 	case HLTV_STATUS:
; 1699 : 			MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4

; 1700 : 			MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4

; 1701 : 			MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4

; 1702 : 			MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4

; 1703 : 			MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4

; 1704 : 			MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4

; 1705 : 		break;

	jmp	SHORT $LN1@CL_ParseHL
$LN6@CL_ParseHL:

; 1706 : 	case HLTV_LISTEN:
; 1707 : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 1708 : 		NET_StringToAdr( MSG_ReadString( msg ), &cls.hltv_listen_address );

	push	OFFSET _cls+44
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_NET_StringToAdr
	add	esp, 8

; 1709 : //		NET_JoinGroup( cls.netchan.sock, cls.hltv_listen_address );
; 1710 : 		SCR_EndLoadingPlaque();

	call	_SCR_EndLoadingPlaque
$LN1@CL_ParseHL:

; 1711 : 		break;
; 1712 : 	default:
; 1713 : 		break;
; 1714 : 	}
; 1715 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseHLTV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseResLocation
_TEXT	SEGMENT
_lastSlash$1 = -8					; size = 4
_url$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseResLocation PROC				; COMDAT

; 1668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1669 : 	const char	*url = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _url$[ebp], eax

; 1670 : 
; 1671 : 	if( url && ( !Q_strnicmp( "http://", url, 7 ) || !Q_strnicmp( "https://", url, 8 )))

	cmp	DWORD PTR _url$[ebp], 0
	je	$LN1@CL_ParseRe
	push	7
	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	push	OFFSET ??_C@_07FGAOOBMN@http?3?1?1@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@CL_ParseRe
	push	8
	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	push	OFFSET ??_C@_08MFLLBFBE@https?3?1?1@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@CL_ParseRe
$LN3@CL_ParseRe:

; 1672 : 	{
; 1673 : 		const char	*lastSlash = Q_strrchr( url, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _lastSlash$1[ebp], eax

; 1674 : 
; 1675 : 		if( lastSlash && lastSlash[1] == '\0' )

	cmp	DWORD PTR _lastSlash$1[ebp], 0
	je	SHORT $LN4@CL_ParseRe
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _lastSlash$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN4@CL_ParseRe

; 1676 : 			Q_strncpy( cl.downloadUrl, url, sizeof( cl.downloadUrl ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	push	OFFSET _cl+2203640
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@CL_ParseRe
$LN4@CL_ParseRe:

; 1677 : 		else Q_snprintf( cl.downloadUrl, sizeof( cl.downloadUrl ), "%s/", url );

	mov	eax, DWORD PTR _url$[ebp]
	push	eax
	push	OFFSET ??_C@_03NPMJBIL@?$CFs?1@
	push	256					; 00000100H
	push	OFFSET _cl+2203640
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN5@CL_ParseRe:

; 1678 : 		Con_Reportf( "Using %s as primary download location\n", cl.downloadUrl );

	push	OFFSET _cl+2203640
	push	OFFSET ??_C@_0CH@FAFMLCKJ@Using?5?$CFs?5as?5primary?5download?5lo@
	call	_Con_Reportf
	add	esp, 8
$LN1@CL_ParseRe:

; 1679 : 	}
; 1680 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseVoiceData
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseVoiceData PROC					; COMDAT

; 1657 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1658 : 	// TODO: ???
; 1659 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseVoiceData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseVoiceInit
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseVoiceInit PROC					; COMDAT

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1647 : 	// TODO: ???
; 1648 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseVoiceInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseResourceList
_TEXT	SEGMENT
_total$ = -12						; size = 4
_i$ = -8						; size = 4
_pResource$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResourceList PROC				; COMDAT

; 1609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1610 : 	resource_t	*pResource;
; 1611 : 	int		i, total;
; 1612 : 
; 1613 : 	total = MSG_ReadUBitLong( msg, MAX_RESOURCE_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _total$[ebp], eax

; 1614 : 
; 1615 : 	for( i = 0; i < total; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total$[ebp]
	jge	$LN3@CL_ParseRe

; 1616 : 	{
; 1617 : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseResourceList@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 1618 : 		pResource->type = MSG_ReadUBitLong( msg, 4 );

	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1619 : 
; 1620 : 		Q_strncpy( pResource->szFileName, MSG_ReadString( msg ), sizeof( pResource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1621 : 		pResource->nIndex = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 1622 : 		pResource->nDownloadSize = MSG_ReadSBitLong( msg, 24 );

	push	24					; 00000018H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 1623 : 		pResource->ucFlags = MSG_ReadUBitLong( msg, 3 ) & ~RES_WASMISSING;

	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 1624 : 
; 1625 : 		if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _pResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN5@CL_ParseRe

; 1626 : 			MSG_ReadBytes( msg, pResource->rgucMD5_hash, sizeof( pResource->rgucMD5_hash ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN5@CL_ParseRe:

; 1627 : 
; 1628 : 		if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@CL_ParseRe

; 1629 : 			MSG_ReadBytes( msg, pResource->rguc_reserved, sizeof( pResource->rguc_reserved ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 94					; 0000005eH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN6@CL_ParseRe:

; 1630 : 
; 1631 : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 1632 : 	}

	jmp	$LN2@CL_ParseRe
$LN3@CL_ParseRe:

; 1633 : 
; 1634 : 	CL_ParseConsistencyInfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseConsistencyInfo
	add	esp, 4

; 1635 : 
; 1636 : 	CL_StartResourceDownloading( "Verifying and downloading resources...\n", false );

	push	0
	push	OFFSET ??_C@_0CI@PCFEBNGI@Verifying?5and?5downloading?5resou@
	call	_CL_StartResourceDownloading
	add	esp, 8

; 1637 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseConsistencyInfo
_TEXT	SEGMENT
tv142 = -136						; size = 4
_nullbuffer$ = -68					; size = 32
_pc$ = -36						; size = 4
_skip$ = -32						; size = 4
_skip_crc_change$ = -28					; size = 4
_pResource$ = -24					; size = 4
_isdelta$ = -20						; size = 4
_i$ = -16						; size = 4
_delta$ = -12						; size = 4
_lastcheck$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseConsistencyInfo PROC				; COMDAT

; 1544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1545 : 	int		lastcheck;
; 1546 : 	int		delta;
; 1547 : 	int		i;
; 1548 : 	int		isdelta;
; 1549 : 	resource_t	*pResource;
; 1550 : 	resource_t	*skip_crc_change;
; 1551 : 	int		skip;
; 1552 : 	consistency_t	*pc;
; 1553 : 	byte		nullbuffer[32];
; 1554 : 
; 1555 : 	memset( nullbuffer, 0, 32 );

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _nullbuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1556 : 
; 1557 : 	cl.need_force_consistency_response = MSG_ReadOneBit( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _cl+3029412, eax

; 1558 : 	pResource = cl.resourcesneeded.pNext;

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _pResource$[ebp], eax

; 1559 : 
; 1560 : 	if( !cl.need_force_consistency_response )

	cmp	DWORD PTR _cl+3029412, 0
	jne	SHORT $LN7@CL_ParseCo

; 1561 : 		return;

	jmp	$LN1@CL_ParseCo
$LN7@CL_ParseCo:

; 1562 : 
; 1563 : 	skip_crc_change = NULL;

	mov	DWORD PTR _skip_crc_change$[ebp], 0

; 1564 : 	lastcheck = 0;

	mov	DWORD PTR _lastcheck$[ebp], 0
$LN2@CL_ParseCo:

; 1565 : 
; 1566 : 	while( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	$LN1@CL_ParseCo

; 1567 : 	{
; 1568 : 		isdelta = MSG_ReadOneBit( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _isdelta$[ebp], eax

; 1569 : 
; 1570 : 		if( isdelta ) delta = MSG_ReadUBitLong( msg, 5 ) + lastcheck;

	cmp	DWORD PTR _isdelta$[ebp], 0
	je	SHORT $LN8@CL_ParseCo
	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	add	eax, DWORD PTR _lastcheck$[ebp]
	mov	DWORD PTR _delta$[ebp], eax
	jmp	SHORT $LN9@CL_ParseCo
$LN8@CL_ParseCo:

; 1571 : 		else delta = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _delta$[ebp], eax
$LN9@CL_ParseCo:

; 1572 : 
; 1573 : 		skip = delta - lastcheck;

	mov	eax, DWORD PTR _delta$[ebp]
	sub	eax, DWORD PTR _lastcheck$[ebp]
	mov	DWORD PTR _skip$[ebp], eax

; 1574 : 
; 1575 : 		for( i = 0; i < skip; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseCo
$LN4@CL_ParseCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_ParseCo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _skip$[ebp]
	jge	SHORT $LN5@CL_ParseCo

; 1576 : 		{
; 1577 : 			if( pResource != skip_crc_change && Q_strstr( pResource->szFileName, "models/" ))

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	eax, DWORD PTR _skip_crc_change$[ebp]
	je	SHORT $LN10@CL_ParseCo
	push	OFFSET ??_C@_07FLCBLKFO@models?1@
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@CL_ParseCo

; 1578 : 				Mod_NeedCRC( pResource->szFileName, false );

	push	0
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_Mod_NeedCRC
	add	esp, 8
$LN10@CL_ParseCo:

; 1579 : 			pResource = pResource->pNext;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pResource$[ebp], ecx

; 1580 : 		}

	jmp	SHORT $LN4@CL_ParseCo
$LN5@CL_ParseCo:

; 1581 : 
; 1582 : 		if( cl.num_consistency >= MAX_MODELS )

	cmp	DWORD PTR _cl+3029408, 1024		; 00000400H
	jl	SHORT $LN11@CL_ParseCo

; 1583 : 			Host_Error( "CL_CheckConsistency: MAX_MODELS limit exceeded (%d)\n", MAX_MODELS );

	push	1024					; 00000400H
	push	OFFSET ??_C@_0DF@HMJJDGBG@CL_CheckConsistency?3?5MAX_MODELS@
	call	_Host_Error
	add	esp, 8
$LN11@CL_ParseCo:

; 1584 : 
; 1585 : 		pc = &cl.consistency_list[cl.num_consistency];

	imul	eax, DWORD PTR _cl+3029408, 44
	add	eax, OFFSET _cl+2984352
	mov	DWORD PTR _pc$[ebp], eax

; 1586 : 		cl.num_consistency++;

	mov	eax, DWORD PTR _cl+3029408
	add	eax, 1
	mov	DWORD PTR _cl+3029408, eax

; 1587 : 
; 1588 : 		memset( pc, 0, sizeof( consistency_t ));

	push	44					; 0000002cH
	push	0
	mov	eax, DWORD PTR _pc$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1589 : 		pc->filename = pResource->szFileName;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [ecx], eax

; 1590 : 		pc->issound = (pResource->type == t_sound);

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN14@CL_ParseCo
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN15@CL_ParseCo
$LN14@CL_ParseCo:
	mov	DWORD PTR tv142[ebp], 0
$LN15@CL_ParseCo:
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1591 : 		pc->orig_index = delta;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1592 : 		pc->value = 0;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1593 : 
; 1594 : 		if( pResource->type == t_model && memcmp( nullbuffer, pResource->rguc_reserved, 32 ))

	mov	eax, DWORD PTR _pResource$[ebp]
	cmp	DWORD PTR [eax+64], 2
	jne	SHORT $LN12@CL_ParseCo
	push	32					; 00000020H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 94					; 0000005eH
	push	eax
	lea	ecx, DWORD PTR _nullbuffer$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@CL_ParseCo

; 1595 : 			pc->check_type = pResource->rguc_reserved[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pResource$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+94]
	mov	ecx, DWORD PTR _pc$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN12@CL_ParseCo:

; 1596 : 
; 1597 : 		skip_crc_change = pResource;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR _skip_crc_change$[ebp], eax

; 1598 : 		lastcheck = delta;

	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _lastcheck$[ebp], eax

; 1599 : 	}

	jmp	$LN2@CL_ParseCo
$LN1@CL_ParseCo:

; 1600 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseConsistencyInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_SendConsistencyInfo
_TEXT	SEGMENT
tv138 = -384						; size = 4
tv136 = -384						; size = 4
_i$ = -316						; size = 4
_pc$ = -312						; size = 4
_md5$ = -308						; size = 16
_crcFile$ = -292					; size = 4
_filename$ = -288					; size = 256
_maxs$ = -32						; size = 12
_mins$ = -20						; size = 12
_user_changed_diskfile$ = -8				; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_SendConsistencyInfo PROC				; COMDAT

; 1404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1405 : 	qboolean		user_changed_diskfile;
; 1406 : 	vec3_t		mins, maxs;
; 1407 : 	string		filename;
; 1408 : 	CRC32_t		crcFile;
; 1409 : 	byte		md5[16];
; 1410 : 	consistency_t	*pc;
; 1411 : 	int		i;
; 1412 : 
; 1413 : 	if( !cl.need_force_consistency_response )

	cmp	DWORD PTR _cl+3029412, 0
	jne	SHORT $LN7@CL_SendCon

; 1414 : 		return;

	jmp	$LN1@CL_SendCon
$LN7@CL_SendCon:

; 1415 : 	cl.need_force_consistency_response = false;

	mov	DWORD PTR _cl+3029412, 0

; 1416 : 
; 1417 : 	MSG_BeginClientCmd( msg, clc_fileconsistency );

	push	0
	push	0
	push	7
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1418 : 
; 1419 : 	for( i = 0; i < cl.num_consistency; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SendCon
$LN2@CL_SendCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SendCon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+3029408
	jge	$LN3@CL_SendCon

; 1420 : 	{
; 1421 : 		pc = &cl.consistency_list[i];

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _cl+2984352
	mov	DWORD PTR _pc$[ebp], eax

; 1422 : 
; 1423 : 		user_changed_diskfile = false;

	mov	DWORD PTR _user_changed_diskfile$[ebp], 0

; 1424 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 1425 : 		MSG_WriteUBitLong( msg, pc->orig_index, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1426 : 
; 1427 : 		if( pc->issound )

	mov	eax, DWORD PTR _pc$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@CL_SendCon

; 1428 : 			Q_snprintf( filename, sizeof( filename ), "%s%s", DEFAULT_SOUNDPATH, pc->filename );

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	256					; 00000100H
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN9@CL_SendCon
$LN8@CL_SendCon:

; 1429 : 		else Q_strncpy( filename, pc->filename, sizeof( filename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN9@CL_SendCon:

; 1430 : 
; 1431 : 		if( Q_strstr( filename, "models/" ))

	push	OFFSET ??_C@_07FLCBLKFO@models?1@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@CL_SendCon

; 1432 : 		{
; 1433 : 			CRC32_Init( &crcFile );

	lea	eax, DWORD PTR _crcFile$[ebp]
	push	eax
	call	_CRC32_Init
	add	esp, 4

; 1434 : 			CRC32_File( &crcFile, filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _crcFile$[ebp]
	push	ecx
	call	_CRC32_File
	add	esp, 8

; 1435 : 			crcFile = CRC32_Final( crcFile );

	mov	eax, DWORD PTR _crcFile$[ebp]
	push	eax
	call	_CRC32_Final
	add	esp, 4
	mov	DWORD PTR _crcFile$[ebp], eax

; 1436 : 			user_changed_diskfile = !Mod_ValidateCRC( filename, crcFile );

	mov	eax, DWORD PTR _crcFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Mod_ValidateCRC
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@CL_SendCon
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN21@CL_SendCon
$LN20@CL_SendCon:
	mov	DWORD PTR tv136[ebp], 0
$LN21@CL_SendCon:
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR _user_changed_diskfile$[ebp], edx
$LN10@CL_SendCon:

; 1437 : 		}
; 1438 : 
; 1439 : 		switch( pc->check_type )

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN11@CL_SendCon
	cmp	DWORD PTR tv138[ebp], 1
	je	SHORT $LN15@CL_SendCon
	cmp	DWORD PTR tv138[ebp], 2
	je	SHORT $LN15@CL_SendCon
	jmp	$LN18@CL_SendCon
$LN11@CL_SendCon:

; 1440 : 		{
; 1441 : 		case force_exactfile:
; 1442 : 			MD5_HashFile( md5, filename, NULL );

	push	0
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_MD5_HashFile
	add	esp, 12					; 0000000cH

; 1443 : 			pc->value = *(int *)md5;

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR _md5$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1444 : 
; 1445 : 			if( user_changed_diskfile )

	cmp	DWORD PTR _user_changed_diskfile$[ebp], 0
	je	SHORT $LN12@CL_SendCon

; 1446 : 				MSG_WriteUBitLong( msg, 0, 32 );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN13@CL_SendCon
$LN12@CL_SendCon:

; 1447 : 			else MSG_WriteUBitLong( msg, pc->value, 32 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN13@CL_SendCon:

; 1448 : 			break;

	jmp	$LN5@CL_SendCon
$LN15@CL_SendCon:

; 1449 : 		case force_model_samebounds:
; 1450 : 		case force_model_specifybounds:
; 1451 : 			if( !Mod_GetStudioBounds( filename, mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_Mod_GetStudioBounds
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@CL_SendCon

; 1452 : 				Host_Error( "unable to find %s\n", filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@JCEFBOLO@unable?5to?5find?5?$CFs?6@
	call	_Host_Error
	add	esp, 8
$LN16@CL_SendCon:

; 1453 : 			if( user_changed_diskfile )

	cmp	DWORD PTR _user_changed_diskfile$[ebp], 0
	je	SHORT $LN17@CL_SendCon

; 1454 : 				ClearBounds( maxs, mins ); // g-cont. especially swapped

	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8
$LN17@CL_SendCon:

; 1455 : 			MSG_WriteBytes( msg, mins, 12 );

	push	12					; 0000000cH
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1456 : 			MSG_WriteBytes( msg, maxs, 12 );

	push	12					; 0000000cH
	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1457 : 			break;

	jmp	SHORT $LN5@CL_SendCon
$LN18@CL_SendCon:

; 1458 : 		default:
; 1459 : 			Host_Error( "Unknown consistency type %i\n", pc->check_type );

	mov	eax, DWORD PTR _pc$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0BN@OHBAENKB@Unknown?5consistency?5type?5?$CFi?6@
	call	_Host_Error
	add	esp, 8
$LN5@CL_SendCon:

; 1460 : 			break;
; 1461 : 		}
; 1462 : 	}

	jmp	$LN2@CL_SendCon
$LN3@CL_SendCon:

; 1463 : 
; 1464 : 	MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@CL_SendCon:

; 1465 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendConsistencyInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_UpdateUserPings
_TEXT	SEGMENT
_player$ = -12						; size = 4
_slot$ = -8						; size = 4
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_UpdateUserPings PROC				; COMDAT

; 1384 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1385 : 	int		i, slot;
; 1386 : 	player_info_t	*player;
; 1387 : 	
; 1388 : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_UpdateU
$LN2@CL_UpdateU:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_UpdateU:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN1@CL_UpdateU

; 1389 : 	{
; 1390 : 		if( !MSG_ReadOneBit( msg )) break; // end of message

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_UpdateU
	jmp	SHORT $LN1@CL_UpdateU
$LN5@CL_UpdateU:

; 1391 : 
; 1392 : 		slot = MSG_ReadUBitLong( msg, MAX_CLIENT_BITS );

	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _slot$[ebp], eax

; 1393 : 
; 1394 : 		if( slot >= MAX_CLIENTS )

	cmp	DWORD PTR _slot$[ebp], 32		; 00000020H
	jl	SHORT $LN6@CL_UpdateU

; 1395 : 			Host_Error( "CL_ParseServerMessage: svc_pings > MAX_CLIENTS\n" );

	push	OFFSET ??_C@_0DA@DNJCFMMH@CL_ParseServerMessage?3?5svc_ping@
	call	_Host_Error
	add	esp, 4
$LN6@CL_UpdateU:

; 1396 : 
; 1397 : 		player = &cl.players[slot];

	imul	eax, DWORD PTR _slot$[ebp], 584
	add	eax, OFFSET _cl+2184940
	mov	DWORD PTR _player$[ebp], eax

; 1398 : 		player->ping = MSG_ReadUBitLong( msg, 12 );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 1399 : 		player->packet_loss = MSG_ReadUBitLong( msg, 7 );

	push	7
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 1400 : 	}

	jmp	$LN2@CL_UpdateU
$LN1@CL_UpdateU:

; 1401 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateUserPings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseResource
_TEXT	SEGMENT
_pResource$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResource PROC					; COMDAT

; 1356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1357 : 	resource_t	*pResource;
; 1358 : 
; 1359 : 	pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseResource@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 1360 : 	pResource->type = MSG_ReadUBitLong( msg, 4 );

	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1361 : 
; 1362 : 	Q_strncpy( pResource->szFileName, MSG_ReadString( msg ), sizeof( pResource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1363 : 	pResource->nIndex = MSG_ReadUBitLong( msg, MAX_MODEL_BITS );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 1364 : 	pResource->nDownloadSize = MSG_ReadSBitLong( msg, 24 );

	push	24					; 00000018H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 1365 : 	pResource->ucFlags = MSG_ReadUBitLong( msg, 3 ) & ~RES_WASMISSING;

	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 1366 : 
; 1367 : 	if( FBitSet( pResource->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _pResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN2@CL_ParseRe

; 1368 : 		MSG_ReadBytes( msg, pResource->rgucMD5_hash, sizeof( pResource->rgucMD5_hash ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN2@CL_ParseRe:

; 1369 : 
; 1370 : 	if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@CL_ParseRe

; 1371 : 		MSG_ReadBytes( msg, pResource->rguc_reserved, sizeof( pResource->rguc_reserved ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pResource$[ebp]
	add	eax, 94					; 0000005eH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN3@CL_ParseRe:

; 1372 : 
; 1373 : 	CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 1374 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_UpdateUserinfo
_TEXT	SEGMENT
tv76 = -84						; size = 4
_player$ = -16						; size = 4
_active$ = -12						; size = 4
_id$ = -8						; size = 4
_slot$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_UpdateUserinfo PROC					; COMDAT

; 1319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1320 : 	int		slot, id;
; 1321 : 	qboolean		active;
; 1322 : 	player_info_t	*player;
; 1323 : 
; 1324 : 	slot = MSG_ReadUBitLong( msg, MAX_CLIENT_BITS );

	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _slot$[ebp], eax

; 1325 : 
; 1326 : 	if( slot >= MAX_CLIENTS )

	cmp	DWORD PTR _slot$[ebp], 32		; 00000020H
	jl	SHORT $LN2@CL_UpdateU

; 1327 : 		Host_Error( "CL_ParseServerMessage: svc_updateuserinfo >= MAX_CLIENTS\n" );

	push	OFFSET ??_C@_0DK@EBNIKKOK@CL_ParseServerMessage?3?5svc_upda@
	call	_Host_Error
	add	esp, 4
$LN2@CL_UpdateU:

; 1328 : 
; 1329 : 	id = MSG_ReadLong( msg );	// unique user ID

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _id$[ebp], eax

; 1330 : 	player = &cl.players[slot];

	imul	eax, DWORD PTR _slot$[ebp], 584
	add	eax, OFFSET _cl+2184940
	mov	DWORD PTR _player$[ebp], eax

; 1331 : 	active = MSG_ReadOneBit( msg ) ? true : false;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@CL_UpdateU
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN8@CL_UpdateU
$LN7@CL_UpdateU:
	mov	DWORD PTR tv76[ebp], 0
$LN8@CL_UpdateU:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _active$[ebp], ecx

; 1332 : 
; 1333 : 	if( active )

	cmp	DWORD PTR _active$[ebp], 0
	je	$LN3@CL_UpdateU

; 1334 : 	{
; 1335 : 		Q_strncpy( player->userinfo, MSG_ReadString( msg ), sizeof( player->userinfo ));

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 4
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1336 : 		Q_strncpy( player->name, Info_ValueForKey( player->userinfo, "name" ), sizeof( player->name ));

	push	32					; 00000020H
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1337 : 		Q_strncpy( player->model, Info_ValueForKey( player->userinfo, "model" ), sizeof( player->model ));

	push	64					; 00000040H
	push	OFFSET ??_C@_05NCCFOPHA@model@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1338 : 		player->topcolor = Q_atoi( Info_ValueForKey( player->userinfo, "topcolor" ));

	push	OFFSET ??_C@_08OLGKFJAO@topcolor@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+368], eax

; 1339 : 		player->bottomcolor = Q_atoi( Info_ValueForKey( player->userinfo, "bottomcolor" ));

	push	OFFSET ??_C@_0M@IIFIMDEK@bottomcolor@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 1340 : 		player->spectator = Q_atoi( Info_ValueForKey( player->userinfo, "*hltv" ));

	push	OFFSET ??_C@_05BKCFBCMH@?$CKhltv@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 1341 : 		MSG_ReadBytes( msg, player->hashedcdkey, sizeof( player->hashedcdkey ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 568				; 00000238H
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1342 : 
; 1343 : 		if( slot == cl.playernum ) memcpy( &gameui.playerinfo, player, sizeof( player_info_t ));

	mov	eax, DWORD PTR _slot$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	jne	SHORT $LN5@CL_UpdateU
	push	584					; 00000248H
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	push	OFFSET _gameui+3408
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@CL_UpdateU:

; 1344 : 	}

	jmp	SHORT $LN1@CL_UpdateU
$LN3@CL_UpdateU:

; 1345 : 	else memset( player, 0, sizeof( *player ));

	push	584					; 00000248H
	push	0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@CL_UpdateU:

; 1346 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateUserinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_RegisterUserMessage
_TEXT	SEGMENT
tv75 = -84						; size = 4
tv74 = -80						; size = 4
_size$ = -12						; size = 4
_svc_num$ = -8						; size = 4
_pszName$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_RegisterUserMessage PROC				; COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1297 : 	char	*pszName;
; 1298 : 	int	svc_num, size;
; 1299 : 	
; 1300 : 	svc_num = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _svc_num$[ebp], eax

; 1301 : 	size = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 1302 : 	pszName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pszName$[ebp], eax

; 1303 : 
; 1304 : 	// important stuff
; 1305 : 	if( size == 0xFFFF ) size = -1;

	cmp	DWORD PTR _size$[ebp], 65535		; 0000ffffH
	jne	SHORT $LN2@CL_Registe
	mov	DWORD PTR _size$[ebp], -1
$LN2@CL_Registe:

; 1306 : 	svc_num = bound( 0, svc_num, 255 );

	cmp	DWORD PTR _svc_num$[ebp], 0
	jl	SHORT $LN6@CL_Registe
	cmp	DWORD PTR _svc_num$[ebp], 255		; 000000ffH
	jge	SHORT $LN4@CL_Registe
	mov	eax, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN5@CL_Registe
$LN4@CL_Registe:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN5@CL_Registe:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN7@CL_Registe
$LN6@CL_Registe:
	mov	DWORD PTR tv75[ebp], 0
$LN7@CL_Registe:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _svc_num$[ebp], edx

; 1307 : 
; 1308 : 	CL_LinkUserMessage( pszName, svc_num, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svc_num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	call	_CL_LinkUserMessage
	add	esp, 12					; 0000000cH

; 1309 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseRestore
_TEXT	SEGMENT
_pMapName$ = -272					; size = 4
_mapCount$ = -268					; size = 4
_i$ = -264						; size = 4
_filename$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseRestore PROC					; COMDAT

; 1269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1270 : 	string		filename;
; 1271 : 	int		i, mapCount;
; 1272 : 	char		*pMapName;
; 1273 : 
; 1274 : 	// mapname.HL2
; 1275 : 	Q_strncpy( filename, MSG_ReadString( msg ), sizeof( filename ));

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1276 : 	mapCount = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _mapCount$[ebp], eax

; 1277 : 
; 1278 : 	// g-cont. acutally in Xash3D this does nothing.
; 1279 : 	// decals already restored on a server, and correctly transferred through levels
; 1280 : 	// but i'm leave this message for backward compatibility
; 1281 : 	for( i = 0; i < mapCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _mapCount$[ebp]
	jge	SHORT $LN1@CL_ParseRe

; 1282 : 	{
; 1283 : 		pMapName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pMapName$[ebp], eax

; 1284 : 		Con_Printf( "Loading decals from %s\n", pMapName );

	mov	eax, DWORD PTR _pMapName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@NMNIPOFK@Loading?5decals?5from?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1285 : 	}

	jmp	SHORT $LN2@CL_ParseRe
$LN1@CL_ParseRe:

; 1286 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseRestore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseCrosshairAngle
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseCrosshairAngle PROC				; COMDAT

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1256 : 	cl.crosshairangle[0] = MSG_ReadChar( msg ) * 0.2f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+2212824], xmm0

; 1257 : 	cl.crosshairangle[1] = MSG_ReadChar( msg ) * 0.2f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cl[ecx+2212824], xmm0

; 1258 : 	cl.crosshairangle[2] = 0.0f; // not used for screen space

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _cl[eax+2212824], xmm0

; 1259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCrosshairAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseAddAngle
_TEXT	SEGMENT
_delta_yaw$ = -8					; size = 4
_a$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseAddAngle PROC					; COMDAT

; 1226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1227 : 	pred_viewangle_t	*a;
; 1228 : 	float		delta_yaw;
; 1229 : 	
; 1230 : 	delta_yaw = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	fstp	DWORD PTR _delta_yaw$[ebp]

; 1231 : #if 0
; 1232 : 	cl.viewangles[YAW] += delta_yaw;
; 1233 : 	return;
; 1234 : #endif
; 1235 : 	// update running counter	
; 1236 : 	cl.addangletotal += delta_yaw;

	movss	xmm0, DWORD PTR _cl+2212968
	addss	xmm0, DWORD PTR _delta_yaw$[ebp]
	movss	DWORD PTR _cl+2212968, xmm0

; 1237 : 
; 1238 : 	// select entry into circular buffer
; 1239 : 	cl.angle_position = (cl.angle_position + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _cl+2212964
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _cl+2212964, eax

; 1240 : 	a = &cl.predicted_angle[cl.angle_position];

	mov	eax, DWORD PTR _cl+2212964
	lea	ecx, DWORD PTR _cl[eax*8+2212836]
	mov	DWORD PTR _a$[ebp], ecx

; 1241 : 
; 1242 : 	// record update
; 1243 : 	a->starttime = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	mov	edx, DWORD PTR _a$[ebp]
	movss	DWORD PTR [edx], xmm0

; 1244 : 	a->total = cl.addangletotal;

	mov	eax, DWORD PTR _a$[ebp]
	movss	xmm0, DWORD PTR _cl+2212968
	movss	DWORD PTR [eax+4], xmm0

; 1245 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseSetAngle
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseSetAngle PROC					; COMDAT

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1213 : 	cl.viewangles[0] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _cl[edx+2212784]

; 1214 : 	cl.viewangles[1] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _cl[ecx+2212784]

; 1215 : 	cl.viewangles[2] = MSG_ReadBitAngle( msg, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _cl[ecx+2212784]

; 1216 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSetAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseLightStyle
_TEXT	SEGMENT
_f$ = -12						; size = 4
_s$ = -8						; size = 4
_style$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseLightStyle PROC				; COMDAT

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1193 : 	int		style;
; 1194 : 	const char	*s;
; 1195 : 	float		f;
; 1196 : 
; 1197 : 	style = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _style$[ebp], eax

; 1198 : 	s = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 1199 : 	f = MSG_ReadFloat( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR _f$[ebp]

; 1200 : 
; 1201 : 	CL_SetLightstyle( style, s, f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _style$[ebp]
	push	ecx
	call	_CL_SetLightstyle
	add	esp, 12					; 0000000cH

; 1202 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseLightStyle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseBaseline
_TEXT	SEGMENT
_ent$ = -472						; size = 4
_player$ = -468						; size = 4
_nullstate$ = -464					; size = 452
_newnum$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseBaseline PROC					; COMDAT

; 1151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1152 : 	int		i, newnum;
; 1153 : 	entity_state_t	nullstate;
; 1154 : 	qboolean		player;
; 1155 : 	cl_entity_t	*ent;
; 1156 : 
; 1157 : 	Delta_InitClient ();	// finalize client delta's

	call	_Delta_InitClient

; 1158 : 
; 1159 : 	memset( &nullstate, 0, sizeof( nullstate ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _nullstate$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@CL_ParseBa:

; 1160 : 
; 1161 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@CL_ParseBa

; 1162 : 	{
; 1163 : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 1164 : 		if( newnum == LAST_EDICT ) break; // end of baselines

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN7@CL_ParseBa
	jmp	$LN3@CL_ParseBa
$LN7@CL_ParseBa:

; 1165 : 		player = CL_IsPlayerIndex( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax

; 1166 : 
; 1167 : 		if( newnum >= clgame.maxEntities )

	mov	eax, DWORD PTR _newnum$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jl	SHORT $LN8@CL_ParseBa

; 1168 : 			Host_Error( "CL_AllocEdict: no free edicts\n" );

	push	OFFSET ??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@
	call	_Host_Error
	add	esp, 4
$LN8@CL_ParseBa:

; 1169 : 
; 1170 : 		ent = CL_EDICT_NUM( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1171 : 		memset( &ent->prevstate, 0, sizeof( ent->prevstate ));

	push	452					; 000001c4H
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1172 : 		ent->index = newnum;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 1173 : 
; 1174 : 		MSG_ReadDeltaEntity( msg, &ent->prevstate, &ent->baseline, newnum, player, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 1175 : 	}

	jmp	$LN2@CL_ParseBa
$LN3@CL_ParseBa:

; 1176 : 
; 1177 : 	cl.instanced_baseline_count = MSG_ReadUBitLong( msg, 6 );

	push	6
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _cl+2241936, eax

; 1178 : 
; 1179 : 	for( i = 0; i < cl.instanced_baseline_count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseBa
$LN4@CL_ParseBa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_ParseBa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2241936
	jge	SHORT $LN5@CL_ParseBa

; 1180 : 	{
; 1181 : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 1182 : 		MSG_ReadDeltaEntity( msg, &nullstate, &cl.instanced_baseline[i], newnum, false, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 452
	add	ecx, OFFSET _cl+2213008
	push	ecx
	lea	edx, DWORD PTR _nullstate$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 1183 : 	}

	jmp	SHORT $LN4@CL_ParseBa
$LN5@CL_ParseBa:

; 1184 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseClientData
_TEXT	SEGMENT
_delta_sequence$1 = -9352				; size = 4
_latency$2 = -9348					; size = 4
_pwd$3 = -9344						; size = 4
_wd$4 = -9340						; size = 4
_pps$5 = -9336						; size = 4
_ps$6 = -9332						; size = 4
_ppcd$7 = -9328						; size = 4
_pcd$8 = -9324						; size = 4
_last_predicted$9 = -9320				; size = 4
_idx$ = -9316						; size = 4
_frame$ = -9312						; size = 4
_nullcd$ = -9308					; size = 2616
_nullwd$ = -6692					; size = 6656
_to_wd$ = -36						; size = 4
_from_wd$ = -32						; size = 4
_to_cd$ = -28						; size = 4
_from_cd$ = -24						; size = 4
_command_ack$ = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_parsecounttime$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseClientData PROC				; COMDAT

; 989  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 9864				; 00002688H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 990  : 	float		parsecounttime;
; 991  : 	int		i, j, command_ack;
; 992  : 	clientdata_t	*from_cd, *to_cd;
; 993  : 	weapon_data_t	*from_wd, *to_wd;
; 994  : 	weapon_data_t	nullwd[64];
; 995  : 	clientdata_t	nullcd;
; 996  : 	frame_t		*frame;
; 997  : 	int		idx;
; 998  : 
; 999  : 	// This is the last movement that the server ack'd
; 1000 : 	command_ack = cls.netchan.incoming_acknowledged;

	mov	eax, DWORD PTR _cls+26868
	mov	DWORD PTR _command_ack$[ebp], eax

; 1001 : 
; 1002 : 	// this is the frame update that this message corresponds to
; 1003 : 	i = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _i$[ebp], eax

; 1004 : 
; 1005 : 	// did we drop some frames?
; 1006 : 	if( i > cl.last_incoming_sequence + 1 )

	mov	eax, DWORD PTR _cl+56
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	$LN3@CL_ParseCl

; 1007 : 	{
; 1008 : 		// mark as dropped
; 1009 : 		for( j = cl.last_incoming_sequence + 1; j < i; j++ )

	mov	eax, DWORD PTR _cl+56
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN4@CL_ParseCl
$LN2@CL_ParseCl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@CL_ParseCl:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN3@CL_ParseCl

; 1010 : 		{
; 1011 : 			if( cl.frames[j & CL_UPDATE_MASK].receivedtime >= 0.0 )

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _j$[ebp]
	imul	ecx, eax, 24056
	movsd	xmm0, QWORD PTR _cl[ecx+88]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN9@CL_ParseCl

; 1012 : 			{
; 1013 : 				cl.frames[j & CL_UPDATE_MASK].receivedtime = -1.0f;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _j$[ebp]
	imul	ecx, eax, 24056
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR _cl[ecx+88], xmm0

; 1014 : 				cl.frames[j & CL_UPDATE_MASK].latency = 0;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _j$[ebp]
	imul	ecx, eax, 24056
	xorps	xmm0, xmm0
	movsd	QWORD PTR _cl[ecx+96], xmm0
$LN9@CL_ParseCl:

; 1015 : 			}
; 1016 : 		}

	jmp	SHORT $LN2@CL_ParseCl
$LN3@CL_ParseCl:

; 1017 : 	}
; 1018 : 
; 1019 : 	cl.parsecount = i;					// ack'd incoming messages.  

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cl+8, eax

; 1020 : 	cl.parsecountmod = cl.parsecount & CL_UPDATE_MASK;	// index into window.     

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cl+8
	mov	DWORD PTR _cl+12, eax

; 1021 : 	frame = &cl.frames[cl.parsecountmod];			// frame at index.

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], eax

; 1022 : 
; 1023 : 	frame->time = cl.mtime[0];				// mark network received time

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR [edx+16], xmm0

; 1024 : 	frame->receivedtime = host.realtime;			// time now that we are parsing.  

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax], xmm0

; 1025 : 
; 1026 : 	memset( &frame->graphdata, 0, sizeof( netbandwidthgraph_t ));

	push	18					; 00000012H
	push	0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 23768				; 00005cd8H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1027 : 
; 1028 : 	// send time for that frame.
; 1029 : 	parsecounttime = cl.commands[command_ack & CL_UPDATE_MASK].senttime;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _command_ack$[ebp]
	imul	ecx, eax, 88
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+1539672]
	movss	DWORD PTR _parsecounttime$[ebp], xmm0

; 1030 : 
; 1031 : 	// current time that we got a response to the command packet.
; 1032 : 	cl.commands[command_ack & CL_UPDATE_MASK].receivedtime = host.realtime;    

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _command_ack$[ebp]
	imul	ecx, eax, 88
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cl[ecx+1539680], xmm0

; 1033 : 
; 1034 : 	if( cl.last_command_ack != -1 )

	cmp	DWORD PTR _cl+52, -1
	je	$LN10@CL_ParseCl

; 1035 : 	{
; 1036 : 		int		last_predicted;
; 1037 : 		clientdata_t	*pcd, *ppcd;
; 1038 : 		entity_state_t	*ps, *pps;
; 1039 : 		weapon_data_t	*wd, *pwd;
; 1040 : 
; 1041 : 		if( !cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	jne	$LN11@CL_ParseCl

; 1042 : 		{
; 1043 : 			last_predicted = ( cl.last_incoming_sequence + ( command_ack - cl.last_command_ack )) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _command_ack$[ebp]
	sub	eax, DWORD PTR _cl+52
	add	eax, DWORD PTR _cl+56
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	mov	DWORD PTR _last_predicted$9[ebp], eax

; 1044 : 
; 1045 : 			pps = &cl.predicted_frames[last_predicted].playerstate;

	imul	eax, DWORD PTR _last_predicted$9[ebp], 9724
	add	eax, OFFSET _cl+1545304
	mov	DWORD PTR _pps$5[ebp], eax

; 1046 : 			pwd = cl.predicted_frames[last_predicted].weapondata;

	imul	eax, DWORD PTR _last_predicted$9[ebp], 9724
	add	eax, OFFSET _cl+1548372
	mov	DWORD PTR _pwd$3[ebp], eax

; 1047 : 			ppcd = &cl.predicted_frames[last_predicted].client;

	imul	eax, DWORD PTR _last_predicted$9[ebp], 9724
	add	eax, OFFSET _cl+1545756
	mov	DWORD PTR _ppcd$7[ebp], eax

; 1048 : 
; 1049 : 			ps = &frame->playerstate[cl.playernum];

	imul	eax, DWORD PTR _cl+2213000, 452
	mov	ecx, DWORD PTR _frame$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2648]
	mov	DWORD PTR _ps$6[ebp], edx

; 1050 : 			wd = frame->weapondata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 17112				; 000042d8H
	mov	DWORD PTR _wd$4[ebp], eax

; 1051 : 			pcd = &frame->clientdata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pcd$8[ebp], eax

; 1052 : 		}

	jmp	SHORT $LN12@CL_ParseCl
$LN11@CL_ParseCl:

; 1053 : 		else
; 1054 : 		{
; 1055 : 			ps = &cls.spectator_state.playerstate;

	mov	DWORD PTR _ps$6[ebp], OFFSET _cls+156

; 1056 : 			pps = &cls.spectator_state.playerstate;

	mov	DWORD PTR _pps$5[ebp], OFFSET _cls+156

; 1057 : 			pcd = &cls.spectator_state.client;

	mov	DWORD PTR _pcd$8[ebp], OFFSET _cls+608

; 1058 : 			ppcd = &cls.spectator_state.client;

	mov	DWORD PTR _ppcd$7[ebp], OFFSET _cls+608

; 1059 : 			wd = cls.spectator_state.weapondata;

	mov	DWORD PTR _wd$4[ebp], OFFSET _cls+3224

; 1060 : 			pwd = cls.spectator_state.weapondata;

	mov	DWORD PTR _pwd$3[ebp], OFFSET _cls+3224
$LN12@CL_ParseCl:

; 1061 : 		}
; 1062 : 
; 1063 : 		clgame.dllFuncs.pfnTxferPredictionData( ps, pps, pcd, ppcd, wd, pwd );

	mov	eax, DWORD PTR _pwd$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _wd$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppcd$7[ebp]
	push	edx
	mov	eax, DWORD PTR _pcd$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _pps$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _ps$6[ebp]
	push	edx
	call	DWORD PTR _clgame+120
	add	esp, 24					; 00000018H
$LN10@CL_ParseCl:

; 1064 : 	}
; 1065 : 
; 1066 : 	// do this after all packets read for this frame?
; 1067 : 	cl.last_command_ack = cls.netchan.incoming_acknowledged;

	mov	eax, DWORD PTR _cls+26868
	mov	DWORD PTR _cl+52, eax

; 1068 : 	cl.last_incoming_sequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _cl+56, eax

; 1069 : 
; 1070 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	$LN13@CL_ParseCl

; 1071 : 	{
; 1072 : 		// calculate latency of this frame.
; 1073 : 		// sent time is set when usercmd is sent to server in CL_Move
; 1074 : 		// this is the # of seconds the round trip took.
; 1075 : 		float	latency = host.realtime - parsecounttime;

	cvtss2sd xmm0, DWORD PTR _parsecounttime$[ebp]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _latency$2[ebp], xmm0

; 1076 : 
; 1077 : 		// fill into frame latency
; 1078 : 		frame->latency = latency;

	cvtss2sd xmm0, DWORD PTR _latency$2[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	movsd	QWORD PTR [eax+8], xmm0

; 1079 : 
; 1080 : 		// negative latency makes no sense.  Huge latency is a problem.
; 1081 : 		if( latency >= 0.0f && latency <= 2.0f )

	movss	xmm0, DWORD PTR _latency$2[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN17@CL_ParseCl
	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _latency$2[ebp]
	jb	SHORT $LN17@CL_ParseCl

; 1082 : 		{
; 1083 : 			// drift the average latency towards the observed latency
; 1084 : 			// if round trip was fastest so far, just use that for latency value
; 1085 : 			// otherwise, move in 1 ms steps toward observed channel latency.
; 1086 : 			if( latency < cls.latency )

	movss	xmm0, DWORD PTR _cls+295000
	comiss	xmm0, DWORD PTR _latency$2[ebp]
	jbe	SHORT $LN16@CL_ParseCl

; 1087 : 				cls.latency = latency;

	movss	xmm0, DWORD PTR _latency$2[ebp]
	movss	DWORD PTR _cls+295000, xmm0
	jmp	SHORT $LN17@CL_ParseCl
$LN16@CL_ParseCl:

; 1088 : 			else cls.latency += 0.001f; // drift up, so corrections are needed	

	movss	xmm0, DWORD PTR _cls+295000
	addss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _cls+295000, xmm0
$LN17@CL_ParseCl:

; 1089 : 		}	
; 1090 : 	}

	jmp	SHORT $LN14@CL_ParseCl
$LN13@CL_ParseCl:

; 1091 : 	else
; 1092 : 	{
; 1093 : 		frame->latency = 0.0f;

	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+8], xmm0
$LN14@CL_ParseCl:

; 1094 : 	}
; 1095 : 
; 1096 : 	// clientdata for spectators ends here
; 1097 : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN18@CL_ParseCl

; 1098 : 	{
; 1099 : 		cl.local.health = 1;

	mov	DWORD PTR _cl+2212656, 1

; 1100 : 		return;

	jmp	$LN1@CL_ParseCl
$LN18@CL_ParseCl:

; 1101 : 	}	
; 1102 : 
; 1103 : 	to_cd = &frame->clientdata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _to_cd$[ebp], eax

; 1104 : 	to_wd = frame->weapondata;

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 17112				; 000042d8H
	mov	DWORD PTR _to_wd$[ebp], eax

; 1105 : 
; 1106 : 	// clear to old value before delta parsing
; 1107 : 	if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@CL_ParseCl

; 1108 : 	{
; 1109 : 		int	delta_sequence = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _delta_sequence$1[ebp], eax

; 1110 : 
; 1111 : 		from_cd = &cl.frames[delta_sequence & CL_UPDATE_MASK].clientdata;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _delta_sequence$1[ebp]
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+120
	mov	DWORD PTR _from_cd$[ebp], ecx

; 1112 : 		from_wd = cl.frames[delta_sequence & CL_UPDATE_MASK].weapondata;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _delta_sequence$1[ebp]
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+17200
	mov	DWORD PTR _from_wd$[ebp], ecx

; 1113 : 	}

	jmp	SHORT $LN20@CL_ParseCl
$LN19@CL_ParseCl:

; 1114 : 	else
; 1115 : 	{
; 1116 : 		memset( &nullcd, 0, sizeof( nullcd ));

	push	2616					; 00000a38H
	push	0
	lea	eax, DWORD PTR _nullcd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1117 : 		memset( nullwd, 0, sizeof( nullwd ));

	push	6656					; 00001a00H
	push	0
	lea	eax, DWORD PTR _nullwd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1118 : 		from_cd = &nullcd;

	lea	eax, DWORD PTR _nullcd$[ebp]
	mov	DWORD PTR _from_cd$[ebp], eax

; 1119 : 		from_wd = nullwd;

	lea	eax, DWORD PTR _nullwd$[ebp]
	mov	DWORD PTR _from_wd$[ebp], eax
$LN20@CL_ParseCl:

; 1120 : 	}
; 1121 : 
; 1122 : 	MSG_ReadClientData( msg, from_cd, to_cd, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _to_cd$[ebp]
	push	edx
	mov	eax, DWORD PTR _from_cd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadClientData
	add	esp, 16					; 00000010H

; 1123 : 
; 1124 : 	for( i = 0; i < 64; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_ParseCl
$LN5@CL_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_ParseCl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@CL_ParseCl

; 1125 : 	{
; 1126 : 		// check for end of weapondata (and clientdata_t message)
; 1127 : 		if( !MSG_ReadOneBit( msg )) break;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@CL_ParseCl
	jmp	SHORT $LN6@CL_ParseCl
$LN21@CL_ParseCl:

; 1128 : 
; 1129 : 		// read the weapon idx
; 1130 : 		idx = MSG_ReadUBitLong( msg, MAX_WEAPON_BITS );

	push	6
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _idx$[ebp], eax

; 1131 : 
; 1132 : 		MSG_ReadWeaponData( msg, &from_wd[idx], &to_wd[idx], cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _idx$[ebp], 104
	add	edx, DWORD PTR _to_wd$[ebp]
	push	edx
	imul	eax, DWORD PTR _idx$[ebp], 104
	add	eax, DWORD PTR _from_wd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadWeaponData
	add	esp, 16					; 00000010H

; 1133 : 	}

	jmp	SHORT $LN5@CL_ParseCl
$LN6@CL_ParseCl:

; 1134 : 
; 1135 : 	// make a local copy of physinfo
; 1136 : 	Q_strncpy( cls.physinfo, frame->clientdata.physinfo, sizeof( cls.physinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 264				; 00000108H
	push	eax
	push	OFFSET _cls+10136
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1137 : 
; 1138 : 	cl.local.maxspeed = frame->clientdata.maxspeed;

	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+196]
	movss	DWORD PTR _cl+2212756, xmm0

; 1139 : 	cl.local.pushmsec = frame->clientdata.pushmsec;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	DWORD PTR _cl+2212748, ecx

; 1140 : 	cl.local.weapons = frame->clientdata.weapons;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	DWORD PTR _cl+2212752, ecx

; 1141 : 
; 1142 : 	cl.local.health = frame->clientdata.health;

	mov	eax, DWORD PTR _frame$[ebp]
	cvttss2si ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _cl+2212656, ecx
$LN1@CL_ParseCl:

; 1143 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseServerData
_TEXT	SEGMENT
tv87 = -148						; size = 4
tv250 = -144						; size = 4
tv242 = -144						; size = 4
tv86 = -144						; size = 4
_i$ = -76						; size = 4
_background$ = -72					; size = 4
_gamefolder$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseServerData PROC				; COMDAT

; 852  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 853  : 	char	gamefolder[MAX_QPATH];
; 854  : 	qboolean	background;
; 855  : 	int	i;
; 856  : 
; 857  : 	Con_Reportf( "Serverdata packet received.\n" );

	push	OFFSET ??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@
	call	_Con_Reportf
	add	esp, 4

; 858  : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16

; 859  : 
; 860  : 	cls.demowaiting = false;	// server is changed

	mov	DWORD PTR _cls+300832, 0

; 861  : 
; 862  : 	// wipe the client_t struct
; 863  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN8@CL_ParseSe
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN8@CL_ParseSe

; 864  : 		CL_ClearState ();

	call	_CL_ClearState
$LN8@CL_ParseSe:

; 865  : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 866  : 
; 867  : 	// parse protocol version number
; 868  : 	i = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 869  : 
; 870  : 	if( i != PROTOCOL_VERSION )

	cmp	DWORD PTR _i$[ebp], 49			; 00000031H
	je	SHORT $LN9@CL_ParseSe

; 871  : 		Host_Error( "Server use invalid protocol (%i should be %i)\n", i, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@HFLGMBDE@Server?5use?5invalid?5protocol?5?$CI?$CFi@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN9@CL_ParseSe:

; 872  : 
; 873  : 	cl.servercount = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _cl, eax

; 874  : 	cl.checksum = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _cl+80, eax

; 875  : 	cl.playernum = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+2213000, eax

; 876  : 	cl.maxclients = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+2213004, eax

; 877  : 	clgame.maxEntities = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _clgame+1008, eax

; 878  : 	clgame.maxEntities = bound( 600, clgame.maxEntities, MAX_EDICTS );

	cmp	DWORD PTR _clgame+1008, 600		; 00000258H
	jl	SHORT $LN34@CL_ParseSe
	cmp	DWORD PTR _clgame+1008, 8192		; 00002000H
	jge	SHORT $LN32@CL_ParseSe
	mov	eax, DWORD PTR _clgame+1008
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN33@CL_ParseSe
$LN32@CL_ParseSe:
	mov	DWORD PTR tv86[ebp], 8192		; 00002000H
$LN33@CL_ParseSe:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], ecx
	jmp	SHORT $LN35@CL_ParseSe
$LN34@CL_ParseSe:
	mov	DWORD PTR tv87[ebp], 600		; 00000258H
$LN35@CL_ParseSe:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _clgame+1008, edx

; 879  : 	clgame.maxModels = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _clgame+1020, eax

; 880  : 	Q_strncpy( clgame.mapname, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+228
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 881  : 	Q_strncpy( clgame.maptitle, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+484
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 882  : 	background = MSG_ReadOneBit( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _background$[ebp], eax

; 883  : 	Q_strncpy( gamefolder, MSG_ReadString( msg ), MAX_QPATH );

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _gamefolder$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 884  : 	host.features = (uint)MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _host+34752, eax

; 885  : 
; 886  : 	// receive the player hulls
; 887  : 	for( i = 0; i < MAX_MAP_HULLS * 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseSe
$LN2@CL_ParseSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseSe:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN3@CL_ParseSe

; 888  : 	{
; 889  : 		host.player_mins[i/3][i%3] = MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	imul	esi, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	edi, 3
	idiv	edi
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _host[esi+edx*4+34236], xmm0

; 890  : 		host.player_maxs[i/3][i%3] = MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	mov	ecx, eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	imul	esi, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	edi, 3
	idiv	edi
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _host[esi+edx*4+34284], xmm0

; 891  : 	}

	jmp	SHORT $LN2@CL_ParseSe
$LN3@CL_ParseSe:

; 892  : 
; 893  : 	if( clgame.maxModels > MAX_MODELS )

	cmp	DWORD PTR _clgame+1020, 1024		; 00000400H
	jle	SHORT $LN10@CL_ParseSe

; 894  : 		Con_Printf( S_WARN "server model limit is above client model limit %i > %i\n", clgame.maxModels, MAX_MODELS );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _clgame+1020
	push	eax
	push	OFFSET ??_C@_0EF@NIEABAID@?$FO3Warning?3?$FO7?5server?5model?5limit@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN10@CL_ParseSe:

; 895  : 
; 896  : 	// Re-init hud video, especially if we changed game directories
; 897  : 	clgame.dllFuncs.pfnVidInit();

	call	DWORD PTR _clgame+12

; 898  : 
; 899  : 	if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN11@CL_ParseSe

; 900  : 	{
; 901  : 		// seperate the printfs so the server message can have a color
; 902  : 		Con_Print( "\n\35\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\37\n" );

	push	OFFSET ??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@
	call	_Con_Print
	add	esp, 4

; 903  : 		Con_Print( va( "%c%s\n\n", 2, clgame.maptitle ));

	push	OFFSET _clgame+484
	push	2
	push	OFFSET ??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_Con_Print
	add	esp, 4
$LN11@CL_ParseSe:

; 904  : 	}
; 905  : 
; 906  : 	// multiplayer game?
; 907  : 	if( cl.maxclients > 1 )	

	cmp	DWORD PTR _cl+2213004, 1
	jle	SHORT $LN12@CL_ParseSe

; 908  : 	{
; 909  : 		// allow console in multiplayer games
; 910  : 		host.allow_console = true;

	mov	DWORD PTR _host+34336, 1

; 911  : 
; 912  : 		// loading user settings
; 913  : 		CSCR_LoadDefaultCVars( "user.scr" );

	push	OFFSET ??_C@_08EOJKMECK@user?4scr@
	call	_CSCR_LoadDefaultCVars
	add	esp, 4

; 914  : 
; 915  : 		if( r_decals->value > mp_decals.value )

	mov	eax, DWORD PTR _r_decals
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _mp_decals+12
	jbe	SHORT $LN14@CL_ParseSe

; 916  : 			Cvar_SetValue( "r_decals", mp_decals.value );

	push	ecx
	movss	xmm0, DWORD PTR _mp_decals+12
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08HELCJCPN@r_decals@
	call	_Cvar_SetValue
	add	esp, 8
$LN14@CL_ParseSe:

; 917  : 	}

	jmp	SHORT $LN13@CL_ParseSe
$LN12@CL_ParseSe:

; 918  : 	else Cvar_Reset( "r_decals" );

	push	OFFSET ??_C@_08HELCJCPN@r_decals@
	call	_Cvar_Reset
	add	esp, 4
$LN13@CL_ParseSe:

; 919  : 
; 920  : 	// set the background state
; 921  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN15@CL_ParseSe
	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN15@CL_ParseSe

; 922  : 	{
; 923  : 		// re-init mouse
; 924  : 		host.mouse_visible = false;

	mov	DWORD PTR _host+34372, 0

; 925  : 		cl.background = true;

	mov	DWORD PTR _cl+64, 1

; 926  : 	}

	jmp	SHORT $LN16@CL_ParseSe
$LN15@CL_ParseSe:

; 927  : 	else cl.background = background;

	mov	eax, DWORD PTR _background$[ebp]
	mov	DWORD PTR _cl+64, eax
$LN16@CL_ParseSe:

; 928  : 
; 929  : 	if( cl.background )	// tell the game parts about background state

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN17@CL_ParseSe

; 930  : 		Cvar_FullSet( "cl_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@CL_ParseSe
$LN17@CL_ParseSe:

; 931  : 	else Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN18@CL_ParseSe:

; 932  : 
; 933  : 	if( !cls.changelevel ) 

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN19@CL_ParseSe

; 934  : 	{
; 935  : 		// continue playing if we are changing level
; 936  : 		S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack
$LN19@CL_ParseSe:

; 937  : 	}
; 938  : 
; 939  : 	if( !cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN20@CL_ParseSe

; 940  : 		UI_SetActiveMenu( cl.background );

	mov	eax, DWORD PTR _cl+64
	push	eax
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN22@CL_ParseSe
$LN20@CL_ParseSe:

; 941  : 	else if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN22@CL_ParseSe

; 942  : 		Key_SetKeyDest( key_menu );

	push	2
	call	_Key_SetKeyDest
	add	esp, 4
$LN22@CL_ParseSe:

; 943  : 
; 944  : 	// don't reset cursor in background mode
; 945  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN23@CL_ParseSe

; 946  : 		IN_MouseRestorePos();

	call	_IN_MouseRestorePos
$LN23@CL_ParseSe:

; 947  : 
; 948  : 	// will be changed later
; 949  : 	cl.viewentity = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	DWORD PTR _cl+2212780, eax

; 950  : 	gameui.globals->maxClients = cl.maxclients;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _cl+2213004
	mov	DWORD PTR [eax+16], ecx

; 951  : 	Q_strncpy( gameui.globals->maptitle, clgame.maptitle, sizeof( gameui.globals->maptitle ));

	push	64					; 00000040H
	push	OFFSET _clgame+484
	mov	eax, DWORD PTR _gameui+7048
	add	eax, 96					; 00000060H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 952  : 
; 953  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN24@CL_ParseSe
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN24@CL_ParseSe

; 954  : 		CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts
$LN24@CL_ParseSe:

; 955  : 
; 956  : 	// get splash name
; 957  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN25@CL_ParseSe
	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN25@CL_ParseSe

; 958  : 		Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", cls.demoname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN36@CL_ParseSe
	mov	DWORD PTR tv242[ebp], OFFSET ??_C@_04CELKIKPL@16x9@
	jmp	SHORT $LN37@CL_ParseSe
$LN36@CL_ParseSe:
	mov	DWORD PTR tv242[ebp], OFFSET ??_C@_03PHLBDMN@4x3@
$LN37@CL_ParseSe:
	mov	eax, DWORD PTR tv242[ebp]
	push	eax
	push	OFFSET _cls+300840
	push	OFFSET ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
	jmp	SHORT $LN26@CL_ParseSe
$LN25@CL_ParseSe:

; 959  : 	else Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", clgame.mapname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN38@CL_ParseSe
	mov	DWORD PTR tv250[ebp], OFFSET ??_C@_04CELKIKPL@16x9@
	jmp	SHORT $LN39@CL_ParseSe
$LN38@CL_ParseSe:
	mov	DWORD PTR tv250[ebp], OFFSET ??_C@_03PHLBDMN@4x3@
$LN39@CL_ParseSe:
	mov	eax, DWORD PTR tv250[ebp]
	push	eax
	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
$LN26@CL_ParseSe:

; 960  : 	Cvar_SetValue( "scr_loading", 0.0f ); // reset progress bar

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@DKOEGGOG@scr_loading@
	call	_Cvar_SetValue
	add	esp, 8

; 961  : 
; 962  : 	if(( cl_allow_levelshots->value && !cls.changelevel ) || cl.background )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@CL_ParseSe
	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN28@CL_ParseSe
$LN29@CL_ParseSe:
	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN27@CL_ParseSe
$LN28@CL_ParseSe:

; 963  : 	{
; 964  : 		if( !FS_FileExists( va( "%s.bmp", cl_levelshot_name->string ), true )) 

	push	1
	mov	eax, DWORD PTR _cl_levelshot_name
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_06PCEOMGLN@?$CFs?4bmp@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@CL_ParseSe

; 965  : 			Cvar_Set( "cl_levelshot_name", "*black" ); // render a black screen

	push	OFFSET ??_C@_06FPKCCFDN@?$CKblack@
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
$LN30@CL_ParseSe:

; 966  : 		cls.scrshot_request = scrshot_plaque; // request levelshot even if exist (check filetime)

	mov	DWORD PTR _cls+296304, 3
$LN27@CL_ParseSe:

; 967  : 	}
; 968  : 
; 969  : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_ParseSe
$LN5@CL_ParseSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_ParseSe:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@CL_ParseSe

; 970  : 		COM_ClearCustomizationList( &cl.players[i].customdata, true );

	push	1
	imul	eax, DWORD PTR _i$[ebp], 584
	add	eax, OFFSET _cl+2185344
	push	eax
	call	_COM_ClearCustomizationList
	add	esp, 8
	jmp	SHORT $LN5@CL_ParseSe
$LN6@CL_ParseSe:

; 971  : 	CL_CreateCustomizationList();

	call	_CL_CreateCustomizationList

; 972  : 
; 973  : 	// request resources from server
; 974  : 	CL_ServerCommand( true, "sendres %i\n", cl.servercount );

	mov	eax, DWORD PTR _cl
	push	eax
	push	OFFSET ??_C@_0M@GJFFFGGI@sendres?5?$CFi?6@
	push	1
	call	_CL_ServerCommand
	add	esp, 12					; 0000000cH

; 975  : 
; 976  : 	memset( &clgame.movevars, 0, sizeof( clgame.movevars ));

	push	160					; 000000a0H
	push	0
	push	OFFSET _clgame+1024
	call	_memset
	add	esp, 12					; 0000000cH

; 977  : 	memset( &clgame.oldmovevars, 0, sizeof( clgame.oldmovevars ));

	push	160					; 000000a0H
	push	0
	push	OFFSET _clgame+1184
	call	_memset
	add	esp, 12					; 0000000cH

; 978  : 	memset( &clgame.centerPrint, 0, sizeof( clgame.centerPrint ));

	push	2068					; 00000814H
	push	0
	push	OFFSET _clgame+215004
	call	_memset
	add	esp, 12					; 0000000cH

; 979  : 	cl.video_prepped = false;

	mov	DWORD PTR _cl+16, 0

; 980  : 	cl.audio_prepped = false;

	mov	DWORD PTR _cl+20, 0

; 981  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseServerData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseFileTransferFailed
_TEXT	SEGMENT
_name$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseFileTransferFailed PROC			; COMDAT

; 832  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 833  : 	const char	*name = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _name$[ebp], eax

; 834  : 
; 835  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN1@CL_ParseFi

; 836  : 		CL_ProcessFile( false, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	0
	call	_CL_ProcessFile
	add	esp, 8
$LN1@CL_ParseFi:

; 837  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseFileTransferFailed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_CreateCustomizationList
_TEXT	SEGMENT
_i$ = -12						; size = 4
_pPlayer$ = -8						; size = 4
_pResource$ = -4					; size = 4
_CL_CreateCustomizationList PROC			; COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 809  : 	resource_t	*pResource;
; 810  : 	player_info_t	*pPlayer;
; 811  : 	int		i;
; 812  : 
; 813  : 	pPlayer = &cl.players[cl.playernum];

	imul	eax, DWORD PTR _cl+2213000, 584
	add	eax, OFFSET _cl+2184940
	mov	DWORD PTR _pPlayer$[ebp], eax

; 814  : 	pPlayer->customdata.pNext = NULL;

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+564], 0

; 815  : 
; 816  : 	for( i = 0; i < cl.num_resources; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_CreateC
$LN2@CL_CreateC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_CreateC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+4561592
	jge	SHORT $LN1@CL_CreateC

; 817  : 	{
; 818  : 		pResource = &cl.resourcelist[i];

	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, OFFSET _cl+3029688
	mov	DWORD PTR _pResource$[ebp], eax

; 819  : 
; 820  : 		if( !COM_CreateCustomization( &pPlayer->customdata, pResource, cl.playernum, 0, NULL, NULL ))

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _cl+2213000
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	add	edx, 404				; 00000194H
	push	edx
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN5@CL_CreateC

; 821  : 			Con_Printf( "problem with client customization %s, ignoring...", pResource->szFileName );

	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@BNJLCICG@problem?5with?5client?5customizati@
	call	_Con_Printf
	add	esp, 8
$LN5@CL_CreateC:

; 822  : 	}

	jmp	SHORT $LN2@CL_CreateC
$LN1@CL_CreateC:

; 823  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateCustomizationList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseResourceRequest
_TEXT	SEGMENT
_sbuf$ = -131108					; size = 20
_nStartIndex$ = -131088					; size = 4
_arg$ = -131084						; size = 4
_i$ = -131080						; size = 4
_buffer$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseResourceRequest PROC				; COMDAT

; 762  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131620				; 00020224H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 763  : 	byte	buffer[MAX_INIT_MSG];
; 764  : 	int	i, arg, nStartIndex;
; 765  : 	sizebuf_t	sbuf;
; 766  : 
; 767  : 	MSG_Init( &sbuf, "ResourceBlock", buffer, sizeof( buffer ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@JDFFKBEB@ResourceBlock@
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 768  : 
; 769  : 	arg = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _arg$[ebp], eax

; 770  : 	nStartIndex = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _nStartIndex$[ebp], eax

; 771  : 
; 772  : 	if( cl.servercount != arg )

	mov	eax, DWORD PTR _cl
	cmp	eax, DWORD PTR _arg$[ebp]
	je	SHORT $LN5@CL_ParseRe

; 773  : 		return;

	jmp	$LN1@CL_ParseRe
$LN5@CL_ParseRe:

; 774  : 
; 775  : 	if( nStartIndex < 0 && nStartIndex > cl.num_resources )

	cmp	DWORD PTR _nStartIndex$[ebp], 0
	jge	SHORT $LN6@CL_ParseRe
	mov	eax, DWORD PTR _nStartIndex$[ebp]
	cmp	eax, DWORD PTR _cl+4561592
	jle	SHORT $LN6@CL_ParseRe

; 776  : 		return;

	jmp	$LN1@CL_ParseRe
$LN6@CL_ParseRe:

; 777  : 
; 778  : 	MSG_BeginClientCmd( &sbuf, clc_resourcelist );

	push	0
	push	0
	push	5
	lea	eax, DWORD PTR _sbuf$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 779  : 	MSG_WriteShort( &sbuf, cl.num_resources );

	mov	eax, DWORD PTR _cl+4561592
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8

; 780  : 
; 781  : 	for( i = nStartIndex; i < cl.num_resources; i++ )

	mov	eax, DWORD PTR _nStartIndex$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_ParseRe
$LN2@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+4561592
	jge	$LN3@CL_ParseRe

; 782  : 	{
; 783  : 		MSG_WriteString( &sbuf, cl.resourcelist[i].szFileName );

	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, OFFSET _cl+3029688
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 784  : 		MSG_WriteByte( &sbuf, cl.resourcelist[i].type );

	imul	eax, DWORD PTR _i$[ebp], 136
	mov	ecx, DWORD PTR _cl[eax+3029752]
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 785  : 		MSG_WriteShort( &sbuf, cl.resourcelist[i].nIndex );

	imul	eax, DWORD PTR _i$[ebp], 136
	mov	ecx, DWORD PTR _cl[eax+3029756]
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteShort
	add	esp, 8

; 786  : 		MSG_WriteLong( &sbuf, cl.resourcelist[i].nDownloadSize );

	imul	eax, DWORD PTR _i$[ebp], 136
	mov	ecx, DWORD PTR _cl[eax+3029760]
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 787  : 		MSG_WriteByte( &sbuf, cl.resourcelist[i].ucFlags );

	imul	eax, DWORD PTR _i$[ebp], 136
	movzx	ecx, BYTE PTR _cl[eax+3029764]
	push	ecx
	lea	edx, DWORD PTR _sbuf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 788  : 
; 789  : 		if( FBitSet( cl.resourcelist[i].ucFlags, RES_CUSTOM ))

	imul	eax, DWORD PTR _i$[ebp], 136
	movzx	ecx, BYTE PTR _cl[eax+3029764]
	and	ecx, 4
	je	SHORT $LN7@CL_ParseRe

; 790  : 			MSG_WriteBytes( &sbuf, cl.resourcelist[i].rgucMD5_hash, 16 );

	push	16					; 00000010H
	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, OFFSET _cl+3029765
	push	eax
	lea	ecx, DWORD PTR _sbuf$[ebp]
	push	ecx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN7@CL_ParseRe:

; 791  : 	}

	jmp	$LN2@CL_ParseRe
$LN3@CL_ParseRe:

; 792  : 
; 793  : 	if( MSG_GetNumBytesWritten( &sbuf ) > 0 )

	lea	eax, DWORD PTR _sbuf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN1@CL_ParseRe

; 794  : 	{
; 795  : 		Netchan_CreateFragments( &cls.netchan, &sbuf );

	lea	eax, DWORD PTR _sbuf$[ebp]
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_CreateFragments
	add	esp, 8

; 796  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_FragSend
	add	esp, 4
$LN1@CL_ParseRe:

; 797  : 	}
; 798  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseResourceRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseCustomization
_TEXT	SEGMENT
_bError$1 = -24						; size = 4
_i$ = -20						; size = 4
_pRes$ = -16						; size = 4
_bFound$ = -12						; size = 4
_pList$ = -8						; size = 4
_pExistingCustomization$ = -4				; size = 4
_msg$ = 8						; size = 4
_CL_ParseCustomization PROC				; COMDAT

; 674  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 675  : 	customization_t	*pExistingCustomization;
; 676  : 	customization_t	*pList;
; 677  : 	qboolean		bFound;
; 678  : 	resource_t	*pRes;
; 679  : 	int		i;
; 680  : 
; 681  : 	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 682  : 	if( i >= MAX_CLIENTS )

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jl	SHORT $LN5@CL_ParseCu

; 683  : 		Host_Error( "Bogus player index during customization parsing.\n" );

	push	OFFSET ??_C@_0DC@PPFGOFIF@Bogus?5player?5index?5during?5custo@
	call	_Host_Error
	add	esp, 4
$LN5@CL_ParseCu:

; 684  : 
; 685  : 	pRes = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseCustomization@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pRes$[ebp], eax

; 686  : 	pRes->type = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 687  : 
; 688  : 	Q_strncpy( pRes->szFileName, MSG_ReadString( msg ), sizeof( pRes->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 689  : 	pRes->nIndex = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 690  : 	pRes->nDownloadSize = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 691  : 	pRes->ucFlags = MSG_ReadByte( msg ) & ~RES_WASMISSING;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [ecx+76], al

; 692  : 	pRes->pNext = pRes->pPrev = NULL;

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [eax+132], 0
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 693  : 
; 694  : 	if( FBitSet( pRes->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN6@CL_ParseCu

; 695  : 		MSG_ReadBytes( msg, pRes->rgucMD5_hash, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pRes$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN6@CL_ParseCu:

; 696  : 	pRes->playernum = i;

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	cl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [eax+93], cl

; 697  : 
; 698  : 	if( !cl_allow_download.value )

	movss	xmm0, DWORD PTR _cl_allow_download+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_ParseCu

; 699  : 	{
; 700  : 		Con_DPrintf( "Refusing new resource, cl_allow_download set to 0\n" );

	push	OFFSET ??_C@_0DD@HIGAHDMA@Refusing?5new?5resource?0?5cl_allow@
	call	_Con_DPrintf
	add	esp, 4

; 701  : 		Mem_Free( pRes );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseCustomization@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 702  : 		return;

	jmp	$LN12@CL_ParseCu
$LN7@CL_ParseCu:

; 703  : 	}
; 704  : 
; 705  : 	if( cls.state == ca_active && !cl_download_ingame.value )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN8@CL_ParseCu
	movss	xmm0, DWORD PTR _cl_download_ingame+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_ParseCu

; 706  : 	{
; 707  : 		Con_DPrintf( "Refusing new resource, cl_download_ingame set to 0\n" );

	push	OFFSET ??_C@_0DE@DCAOBOII@Refusing?5new?5resource?0?5cl_downl@
	call	_Con_DPrintf
	add	esp, 4

; 708  : 		Mem_Free( pRes );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseCustomization@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 709  : 		return;

	jmp	$LN12@CL_ParseCu
$LN8@CL_ParseCu:

; 710  : 	}
; 711  : 
; 712  : 	pExistingCustomization = CL_PlayerHasCustomization( i, pRes->type );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_CL_PlayerHasCustomization
	add	esp, 8
	mov	DWORD PTR _pExistingCustomization$[ebp], eax

; 713  : 
; 714  : 	if( pExistingCustomization )

	cmp	DWORD PTR _pExistingCustomization$[ebp], 0
	je	SHORT $LN9@CL_ParseCu

; 715  : 		CL_RemoveCustomization( i, pExistingCustomization );

	mov	eax, DWORD PTR _pExistingCustomization$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_CL_RemoveCustomization
	add	esp, 8
$LN9@CL_ParseCu:

; 716  : 	bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 717  : 
; 718  : 	for( pList = cl.players[pRes->playernum].customdata.pNext; pList; pList = pList->pNext )

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	imul	edx, ecx, 584
	mov	eax, DWORD PTR _cl[edx+2185504]
	mov	DWORD PTR _pList$[ebp], eax
	jmp	SHORT $LN4@CL_ParseCu
$LN2@CL_ParseCu:
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pList$[ebp], ecx
$LN4@CL_ParseCu:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_ParseCu

; 719  : 	{
; 720  : 		if( !memcmp( pList->resource.rgucMD5_hash, pRes->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _pRes$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@CL_ParseCu

; 721  : 		{
; 722  : 			bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 723  : 			break;

	jmp	SHORT $LN3@CL_ParseCu
$LN10@CL_ParseCu:

; 724  : 		}
; 725  : 	}

	jmp	SHORT $LN2@CL_ParseCu
$LN3@CL_ParseCu:

; 726  : 
; 727  : 	if( HPAK_GetDataPointer( CUSTOM_RES_PATH, pRes, NULL, NULL ))

	push	0
	push	0
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN11@CL_ParseCu

; 728  : 	{
; 729  : 		qboolean	bError = false;

	mov	DWORD PTR _bError$1[ebp], 0

; 730  : 
; 731  : 		if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	SHORT $LN13@CL_ParseCu

; 732  : 		{
; 733  : 			pList = &cl.players[pRes->playernum].customdata;

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	imul	edx, ecx, 584
	add	edx, OFFSET _cl+2185344
	mov	DWORD PTR _pList$[ebp], edx

; 734  : 
; 735  : 			if( !COM_CreateCustomization( pList, pRes, pRes->playernum, FCUST_FROMHPAK, NULL, NULL ))

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	mov	edx, DWORD PTR _pRes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pList$[ebp]
	push	eax
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN15@CL_ParseCu

; 736  : 				bError = true;

	mov	DWORD PTR _bError$1[ebp], 1
$LN15@CL_ParseCu:

; 737  : 		}

	jmp	SHORT $LN14@CL_ParseCu
$LN13@CL_ParseCu:

; 738  : 		else
; 739  : 		{
; 740  : 			Con_DPrintf( "Duplicate resource ignored for local client\n" );

	push	OFFSET ??_C@_0CN@PIGKFMHO@Duplicate?5resource?5ignored?5for?5@
	call	_Con_DPrintf
	add	esp, 4
$LN14@CL_ParseCu:

; 741  : 		}
; 742  : 
; 743  : 		if( bError ) Con_DPrintf( "Error loading customization\n" );

	cmp	DWORD PTR _bError$1[ebp], 0
	je	SHORT $LN16@CL_ParseCu
	push	OFFSET ??_C@_0BN@FNDBGDPC@Error?5loading?5customization?6@
	call	_Con_DPrintf
	add	esp, 4
$LN16@CL_ParseCu:

; 744  : 		Mem_Free( pRes );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseCustomization@@9@9
	add	eax, 70					; 00000046H
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pRes$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 745  : 	}

	jmp	SHORT $LN12@CL_ParseCu
$LN11@CL_ParseCu:

; 746  : 	else
; 747  : 	{
; 748  : 		SetBits( pRes->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [edx+76], cl

; 749  : 		CL_AddToResourceList( pRes, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 750  : 		Con_Printf( "Requesting %s from server\n", pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@FBLPINIB@Requesting?5?$CFs?5from?5server?6@
	call	_Con_Printf
	add	esp, 8

; 751  : 		CL_StartResourceDownloading( "Custom resource propagation...\n", true );

	push	1
	push	OFFSET ??_C@_0CA@FNPNCIJB@Custom?5resource?5propagation?4?4?4?6@
	call	_CL_StartResourceDownloading
	add	esp, 8
$LN12@CL_ParseCu:

; 752  : 	}
; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_RemoveCustomization
_TEXT	SEGMENT
_pNext$ = -8						; size = 4
_pList$ = -4						; size = 4
_nPlayerNum$ = 8					; size = 4
_pRemove$ = 12						; size = 4
_CL_RemoveCustomization PROC				; COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 638  : 	customization_t	*pList;
; 639  : 	customization_t	*pNext;
; 640  : 
; 641  : 	for( pList = cl.players[nPlayerNum].customdata.pNext; pList; pList = pNext )

	imul	eax, DWORD PTR _nPlayerNum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+2185504]
	mov	DWORD PTR _pList$[ebp], ecx
	jmp	SHORT $LN4@CL_RemoveC
$LN2@CL_RemoveC:
	mov	eax, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pList$[ebp], eax
$LN4@CL_RemoveC:
	cmp	DWORD PTR _pList$[ebp], 0
	je	$LN1@CL_RemoveC

; 642  : 	{
; 643  : 		pNext = pList->pNext;

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pNext$[ebp], ecx

; 644  : 
; 645  : 		if( pRemove != pList )

	mov	eax, DWORD PTR _pRemove$[ebp]
	cmp	eax, DWORD PTR _pList$[ebp]
	je	SHORT $LN5@CL_RemoveC

; 646  : 			continue;

	jmp	SHORT $LN2@CL_RemoveC
$LN5@CL_RemoveC:

; 647  : 
; 648  : 		if( pList->bInUse && pList->pBuffer )

	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@CL_RemoveC
	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax+156], 0
	je	SHORT $LN6@CL_RemoveC

; 649  : 			Mem_Free( pList->pBuffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_RemoveCustomization@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pList$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN6@CL_RemoveC:

; 650  : 
; 651  : 		if( pList->bInUse && pList->pInfo )

	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@CL_RemoveC
	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN7@CL_RemoveC

; 652  : 		{
; 653  : 			if( pList->resource.type == t_decal )

	mov	eax, DWORD PTR _pList$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN7@CL_RemoveC

; 654  : 			{
; 655  : 				if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_RemoveC

; 656  : 					R_DecalRemoveAll( pList->nUserData1 );

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	_R_DecalRemoveAll
	add	esp, 4
$LN9@CL_RemoveC:

; 657  : 				FS_FreeImage( pList->pInfo );

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	call	_FS_FreeImage
	add	esp, 4
$LN7@CL_RemoveC:

; 658  : 			}
; 659  : 		}
; 660  : 
; 661  : 		cl.players[nPlayerNum].customdata.pNext = pNext;

	imul	eax, DWORD PTR _nPlayerNum$[ebp], 584
	mov	ecx, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _cl[eax+2185504], ecx

; 662  : 		Mem_Free( pList );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_RemoveCustomization@@9@9
	add	eax, 25					; 00000019H
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 663  : 		break;

	jmp	SHORT $LN1@CL_RemoveC

; 664  : 	}

	jmp	$LN2@CL_RemoveC
$LN1@CL_RemoveC:

; 665  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RemoveCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_PlayerHasCustomization
_TEXT	SEGMENT
_pList$ = -4						; size = 4
_nPlayerNum$ = 8					; size = 4
_type$ = 12						; size = 4
_CL_PlayerHasCustomization PROC				; COMDAT

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 626  : 	customization_t	*pList;
; 627  : 
; 628  : 	for( pList = cl.players[nPlayerNum].customdata.pNext; pList; pList = pList->pNext )

	imul	eax, DWORD PTR _nPlayerNum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+2185504]
	mov	DWORD PTR _pList$[ebp], ecx
	jmp	SHORT $LN4@CL_PlayerH
$LN2@CL_PlayerH:
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pList$[ebp], ecx
$LN4@CL_PlayerH:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_PlayerH

; 629  : 	{
; 630  : 		if( pList->resource.type == type )

	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	SHORT $LN5@CL_PlayerH

; 631  : 			return pList;

	mov	eax, DWORD PTR _pList$[ebp]
	jmp	SHORT $LN1@CL_PlayerH
$LN5@CL_PlayerH:

; 632  : 	}

	jmp	SHORT $LN2@CL_PlayerH
$LN3@CL_PlayerH:

; 633  : 	return NULL;

	xor	eax, eax
$LN1@CL_PlayerH:

; 634  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerHasCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseSoundFade
_TEXT	SEGMENT
_fadeInSeconds$ = -16					; size = 4
_holdTime$ = -12					; size = 4
_fadeOutSeconds$ = -8					; size = 4
_fadePercent$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseSoundFade PROC					; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 416  : 	float	fadePercent, fadeOutSeconds;
; 417  : 	float	holdTime, fadeInSeconds;
; 418  : 
; 419  : 	fadePercent = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadePercent$[ebp], xmm0

; 420  : 	holdTime = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _holdTime$[ebp], xmm0

; 421  : 	fadeOutSeconds = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadeOutSeconds$[ebp], xmm0

; 422  : 	fadeInSeconds = (float)MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fadeInSeconds$[ebp], xmm0

; 423  : 
; 424  : 	S_FadeClientVolume( fadePercent, fadeOutSeconds, holdTime, fadeInSeconds );

	push	ecx
	movss	xmm0, DWORD PTR _fadeInSeconds$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _holdTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadeOutSeconds$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeClientVolume
	add	esp, 16					; 00000010H

; 425  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSoundFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseStaticDecal
_TEXT	SEGMENT
_flags$ = -40						; size = 4
_scale$ = -36						; size = 4
_ent$ = -32						; size = 4
_modelIndex$ = -28					; size = 4
_entityIndex$ = -24					; size = 4
_decalIndex$ = -20					; size = 4
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseStaticDecal PROC				; COMDAT

; 388  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 389  : 	vec3_t		origin;
; 390  : 	int		decalIndex, entityIndex, modelIndex;
; 391  : 	cl_entity_t	*ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 392  : 	float		scale;
; 393  : 	int		flags;
; 394  : 
; 395  : 	MSG_ReadVec3Coord( msg, origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 396  : 	decalIndex = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 397  : 	entityIndex = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 398  : 
; 399  : 	if( entityIndex > 0 )

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN2@CL_ParseSt

; 400  : 		modelIndex = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax
	jmp	SHORT $LN3@CL_ParseSt
$LN2@CL_ParseSt:

; 401  : 	else modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0
$LN3@CL_ParseSt:

; 402  : 	flags = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 403  : 	scale = (float)MSG_ReadWord( msg ) / 4096.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@45800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 404  : 
; 405  : 	CL_FireCustomDecal( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, origin, flags, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_FireCustomDecal
	add	esp, 24					; 00000018H

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStaticDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseStaticEntity
_TEXT	SEGMENT
_ent$ = -920						; size = 4
_to$ = -916						; size = 452
_from$ = -464						; size = 452
_newnum$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseStaticEntity PROC				; COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1048				; 00000418H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 310  : 	int		i, newnum;
; 311  : 	entity_state_t	from, to;
; 312  : 	cl_entity_t	*ent;
; 313  : 
; 314  : 	memset( &from, 0, sizeof( from ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 315  : 	newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 316  : 	MSG_ReadDeltaEntity( msg, &from, &to, 0, DELTA_STATIC, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	push	0
	lea	edx, DWORD PTR _to$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 317  : 
; 318  : 	i = clgame.numStatics;

	mov	eax, DWORD PTR _clgame+1016
	mov	DWORD PTR _i$[ebp], eax

; 319  : 	if( i >= MAX_STATIC_ENTITIES )

	cmp	DWORD PTR _i$[ebp], 3096		; 00000c18H
	jl	SHORT $LN2@CL_ParseSt

; 320  : 	{
; 321  : 		Con_Printf( S_ERROR "MAX_STATIC_ENTITIES limit exceeded!\n" );

	push	OFFSET ??_C@_0DA@DJCKFABC@?$FO1Error?3?$FO7?5MAX_STATIC_ENTITIES?5@
	call	_Con_Printf
	add	esp, 4

; 322  : 		return;

	jmp	$LN1@CL_ParseSt
$LN2@CL_ParseSt:

; 323  : 	}
; 324  : 
; 325  : 	ent = &clgame.static_entities[i];

	imul	eax, DWORD PTR _i$[ebp], 3336
	add	eax, DWORD PTR _clgame+1000
	mov	DWORD PTR _ent$[ebp], eax

; 326  : 	clgame.numStatics++;

	mov	eax, DWORD PTR _clgame+1016
	add	eax, 1
	mov	DWORD PTR _clgame+1016, eax

; 327  : 
; 328  : 	// all states are same
; 329  : 	ent->baseline = ent->curstate = ent->prevstate = to;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 460				; 000001ccH
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 912				; 00000390H
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 8
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _to$[ebp]
	rep movsd

; 330  : 	ent->index = 0; // static entities doesn't has the numbers

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax], 0

; 331  : 
; 332  : 	// statics may be respawned in game e.g. for demo recording
; 333  : 	if( cls.state == ca_connected || cls.state == ca_validate )

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN4@CL_ParseSt
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN3@CL_ParseSt
$LN4@CL_ParseSt:

; 334  : 		ent->trivial_accept = INVALID_HANDLE;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+3296], 65535		; 0000ffffH
$LN3@CL_ParseSt:

; 335  : 
; 336  : 	// setup the new static entity
; 337  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 338  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 339  : 	ent->model = CL_ModelHandle( to.modelindex );

	mov	eax, DWORD PTR _to$[ebp+40]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+3300], eax

; 340  : 	ent->curstate.framerate = 1.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1008], xmm0

; 341  : 	CL_ResetLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8

; 342  : 
; 343  : 	if( ent->curstate.rendermode == kRenderNormal && ent->model != NULL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN6@CL_ParseSt
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN6@CL_ParseSt

; 344  : 	{
; 345  : 		// auto 'solid' faces
; 346  : 		if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN6@CL_ParseSt
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN6@CL_ParseSt

; 347  : 		{
; 348  : 			ent->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+984], 4

; 349  : 			ent->curstate.renderamt = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN6@CL_ParseSt:

; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	R_AddEfrags( ent );	// add link

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_AddEfrags
	add	esp, 4
$LN1@CL_ParseSt:

; 354  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseParticles
_TEXT	SEGMENT
_p$1 = -48						; size = 4
_life$ = -44						; size = 4
_color$ = -40						; size = 4
_count$ = -36						; size = 4
_i$ = -32						; size = 4
_dir$ = -28						; size = 12
_org$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseParticles PROC					; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 270  : 	vec3_t		org, dir;
; 271  : 	int		i, count, color;
; 272  : 	float		life;
; 273  : 	
; 274  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 275  : 
; 276  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParsePa
$LN2@CL_ParsePa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParsePa:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@CL_ParsePa

; 277  : 		dir[i] = MSG_ReadChar( msg ) * 0.0625f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _dir$[ebp+ecx*4], xmm0
	jmp	SHORT $LN2@CL_ParsePa
$LN3@CL_ParsePa:

; 278  : 
; 279  : 	count = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 280  : 	color = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 281  : 	if( count == 255 ) count = 1024;

	cmp	DWORD PTR _count$[ebp], 255		; 000000ffH
	jne	SHORT $LN5@CL_ParsePa
	mov	DWORD PTR _count$[ebp], 1024		; 00000400H
$LN5@CL_ParsePa:

; 282  : 	life = MSG_ReadByte( msg ) * 0.125f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e000000
	movss	DWORD PTR _life$[ebp], xmm0

; 283  : 
; 284  : 	if( life != 0.0f && count == 1 )

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@CL_ParsePa
	cmp	DWORD PTR _count$[ebp], 1
	jne	$LN6@CL_ParsePa

; 285  : 	{
; 286  : 		particle_t	*p;
; 287  : 
; 288  : 		p = R_AllocParticle( NULL );

	push	0
	call	_R_AllocParticle
	add	esp, 4
	mov	DWORD PTR _p$1[ebp], eax

; 289  : 		if( !p ) return;

	cmp	DWORD PTR _p$1[ebp], 0
	jne	SHORT $LN8@CL_ParsePa
	jmp	$LN7@CL_ParsePa
$LN8@CL_ParsePa:

; 290  : 
; 291  : 		p->die += life;

	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR _life$[ebp]
	mov	ecx, DWORD PTR _p$1[ebp]
	movss	DWORD PTR [ecx+36], xmm0

; 292  : 		p->color = color;

	mov	eax, DWORD PTR _p$1[ebp]
	mov	cx, WORD PTR _color$[ebp]
	mov	WORD PTR [eax+12], cx

; 293  : 		p->type = pt_static;

	mov	eax, DWORD PTR _p$1[ebp]
	mov	DWORD PTR [eax+40], 0

; 294  : 
; 295  : 		VectorCopy( org, p->org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	ecx, DWORD PTR _org$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	edx, DWORD PTR _org$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	eax, DWORD PTR _org$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax

; 296  : 		VectorCopy( dir, p->vel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	ecx, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$1[ebp]
	mov	edx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	eax, DWORD PTR _dir$[ebp+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 297  : 	}

	jmp	SHORT $LN7@CL_ParsePa
$LN6@CL_ParsePa:

; 298  : 	else R_RunParticleEffect( org, dir, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H
$LN7@CL_ParsePa:

; 299  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseParticles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseMovevars
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseMovevars PROC					; COMDAT

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 243  : 	Delta_InitClient ();	// finalize client delta's

	call	_Delta_InitClient

; 244  : 
; 245  : 	MSG_ReadDeltaMovevars( msg, &clgame.oldmovevars, &clgame.movevars );

	push	OFFSET _clgame+1024
	push	OFFSET _clgame+1184
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaMovevars
	add	esp, 12					; 0000000cH

; 246  : 
; 247  : 	// water alpha is not allowed
; 248  : 	if( !FBitSet( world.flags, FWORLD_WATERALPHA ))

	mov	eax, DWORD PTR _world+8
	and	eax, 4
	jne	SHORT $LN2@CL_ParseMo

; 249  : 		clgame.movevars.wateralpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clgame+1180, xmm0
$LN2@CL_ParseMo:

; 250  : 
; 251  : 	// update sky if changed
; 252  : 	if( Q_strcmp( clgame.oldmovevars.skyName, clgame.movevars.skyName ) && cl.video_prepped )

	push	99999					; 0001869fH
	push	OFFSET _clgame+1092
	push	OFFSET _clgame+1252
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@CL_ParseMo
	cmp	DWORD PTR _cl+16, 0
	je	SHORT $LN3@CL_ParseMo

; 253  : 		R_SetupSky( clgame.movevars.skyName );

	push	OFFSET _clgame+1092
	call	_R_SetupSky
	add	esp, 4
$LN3@CL_ParseMo:

; 254  : 
; 255  : 	memcpy( &clgame.oldmovevars, &clgame.movevars, sizeof( movevars_t ));

	push	160					; 000000a0H
	push	OFFSET _clgame+1024
	push	OFFSET _clgame+1184
	call	_memcpy
	add	esp, 12					; 0000000cH

; 256  : 	clgame.entities->curstate.scale = clgame.movevars.waveHeight;

	mov	eax, DWORD PTR _clgame+996
	movss	xmm0, DWORD PTR _clgame+1084
	movss	DWORD PTR [eax+976], xmm0

; 257  : 
; 258  : 	// keep features an actual!
; 259  : 	clgame.oldmovevars.features = clgame.movevars.features = host.features;

	mov	eax, DWORD PTR _host+34752
	mov	DWORD PTR _clgame+1172, eax
	mov	ecx, DWORD PTR _clgame+1172
	mov	DWORD PTR _clgame+1332, ecx

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseMovevars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseSignon
_TEXT	SEGMENT
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseSignon PROC					; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 222  : 	int	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 223  : 
; 224  : 	if( i <= cls.signon )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cls+64
	jg	SHORT $LN2@CL_ParseSi

; 225  : 	{
; 226  : 		Con_Reportf( S_ERROR "received signon %i when at %i\n", i, cls.signon );

	mov	eax, DWORD PTR _cls+64
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CK@FAALJMMG@?$FO1Error?3?$FO7?5received?5signon?5?$CFi?5w@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 227  : 		CL_Disconnect();

	call	_CL_Disconnect

; 228  : 		return;

	jmp	SHORT $LN1@CL_ParseSi
$LN2@CL_ParseSi:

; 229  : 	}
; 230  : 
; 231  : 	cls.signon = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cls+64, eax

; 232  : 	CL_SignonReply();

	call	_CL_SignonReply
$LN1@CL_ParseSi:

; 233  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSignon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseRestoreSoundPacket
_TEXT	SEGMENT
_sentenceName$1 = -100					; size = 32
_handle$ = -68						; size = 4
_wordIndex$ = -64					; size = 4
_forcedEnd$ = -60					; size = 8
_samplePos$ = -52					; size = 8
_entnum$ = -44						; size = 4
_pitch$ = -40						; size = 4
_flags$ = -36						; size = 4
_attn$ = -32						; size = 4
_volume$ = -28						; size = 4
_sound$ = -24						; size = 4
_chan$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseRestoreSoundPacket PROC			; COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 125  : 	vec3_t	pos;
; 126  : 	int 	chan, sound;
; 127  : 	float 	volume, attn;  
; 128  : 	int	flags, pitch, entnum;
; 129  : 	double	samplePos, forcedEnd;
; 130  : 	int	wordIndex;
; 131  : 	sound_t	handle = 0;

	mov	DWORD PTR _handle$[ebp], 0

; 132  : 
; 133  : 	flags = MSG_ReadUBitLong( msg, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _flags$[ebp], eax

; 134  : 	sound = MSG_ReadUBitLong( msg, MAX_SOUND_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _sound$[ebp], eax

; 135  : 	chan = MSG_ReadUBitLong( msg, MAX_SND_CHAN_BITS );

	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _chan$[ebp], eax

; 136  : 
; 137  : 	if( flags & SND_VOLUME )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@CL_ParseRe

; 138  : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseRe
$LN2@CL_ParseRe:

; 139  : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseRe:

; 140  : 
; 141  : 	if( flags & SND_ATTENUATION )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@CL_ParseRe

; 142  : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseRe
$LN4@CL_ParseRe:

; 143  : 	else attn = ATTN_NONE;	

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseRe:

; 144  : 
; 145  : 	if( flags & SND_PITCH )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN6@CL_ParseRe

; 146  : 		pitch = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _pitch$[ebp], eax
	jmp	SHORT $LN7@CL_ParseRe
$LN6@CL_ParseRe:

; 147  : 	else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@CL_ParseRe:

; 148  : 
; 149  : 	// entity reletive
; 150  : 	entnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _entnum$[ebp], eax

; 151  : 
; 152  : 	// positioned in space
; 153  : 	MSG_ReadVec3Coord( msg, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 154  : 
; 155  : 	if( flags & SND_SENTENCE )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN8@CL_ParseRe

; 156  : 	{
; 157  : 		char	sentenceName[32];
; 158  : 
; 159  : 		if( flags & SND_SEQUENCE )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN10@CL_ParseRe

; 160  : 			Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound + MAX_SOUNDS );

	mov	eax, DWORD PTR _sound$[ebp]
	add	eax, 8192				; 00002000H
	push	eax
	push	OFFSET ??_C@_03EMIMLMFN@?$CB?$CFi@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _sentenceName$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@CL_ParseRe
$LN10@CL_ParseRe:

; 161  : 		else Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound );

	mov	eax, DWORD PTR _sound$[ebp]
	push	eax
	push	OFFSET ??_C@_03EMIMLMFN@?$CB?$CFi@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _sentenceName$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN11@CL_ParseRe:

; 162  : 
; 163  : 		handle = S_RegisterSound( sentenceName );

	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 164  : 	}

	jmp	SHORT $LN9@CL_ParseRe
$LN8@CL_ParseRe:

; 165  : 	else handle = cl.sound_index[sound]; // see precached sound

	mov	eax, DWORD PTR _sound$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	mov	DWORD PTR _handle$[ebp], ecx
$LN9@CL_ParseRe:

; 166  : 
; 167  : 	wordIndex = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _wordIndex$[ebp], eax

; 168  : 
; 169  : 	// 16 bytes here
; 170  : 	MSG_ReadBytes( msg, &samplePos, sizeof( samplePos ));

	push	8
	lea	eax, DWORD PTR _samplePos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 171  : 	MSG_ReadBytes( msg, &forcedEnd, sizeof( forcedEnd ));

	push	8
	lea	eax, DWORD PTR _forcedEnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 172  : 
; 173  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN12@CL_ParseRe

; 174  : 		return; // too early

	jmp	SHORT $LN1@CL_ParseRe
$LN12@CL_ParseRe:

; 175  : 
; 176  : 	S_RestoreSound( pos, entnum, chan, handle, volume, attn, pitch, flags, samplePos, forcedEnd, wordIndex );

	mov	eax, DWORD PTR _wordIndex$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _forcedEnd$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _samplePos$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pitch$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entnum$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_S_RestoreSound
	add	esp, 52					; 00000034H
$LN1@CL_ParseRe:

; 177  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseRestoreSoundPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseSoundPacket
_TEXT	SEGMENT
_sentenceName$1 = -80					; size = 32
_handle$ = -48						; size = 4
_entnum$ = -44						; size = 4
_pitch$ = -40						; size = 4
_flags$ = -36						; size = 4
_attn$ = -32						; size = 4
_volume$ = -28						; size = 4
_sound$ = -24						; size = 4
_chan$ = -20						; size = 4
_pos$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseSoundPacket PROC				; COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 63   : 	vec3_t	pos;
; 64   : 	int 	chan, sound;
; 65   : 	float 	volume, attn;  
; 66   : 	int	flags, pitch, entnum;
; 67   : 	sound_t	handle = 0;

	mov	DWORD PTR _handle$[ebp], 0

; 68   : 
; 69   : 	flags = MSG_ReadUBitLong( msg, MAX_SND_FLAGS_BITS );

	push	14					; 0000000eH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _flags$[ebp], eax

; 70   : 	sound = MSG_ReadUBitLong( msg, MAX_SOUND_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _sound$[ebp], eax

; 71   : 	chan = MSG_ReadUBitLong( msg, MAX_SND_CHAN_BITS );

	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _chan$[ebp], eax

; 72   : 
; 73   : 	if( FBitSet( flags, SND_VOLUME ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@CL_ParseSo

; 74   : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseSo
$LN2@CL_ParseSo:

; 75   : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseSo:

; 76   : 
; 77   : 	if( FBitSet( flags, SND_ATTENUATION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@CL_ParseSo

; 78   : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseSo
$LN4@CL_ParseSo:

; 79   : 	else attn = ATTN_NONE;	

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseSo:

; 80   : 
; 81   : 	if( FBitSet( flags, SND_PITCH ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN6@CL_ParseSo

; 82   : 		pitch = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _pitch$[ebp], eax
	jmp	SHORT $LN7@CL_ParseSo
$LN6@CL_ParseSo:

; 83   : 	else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@CL_ParseSo:

; 84   : 
; 85   : 	// entity reletive
; 86   : 	entnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS ); 

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _entnum$[ebp], eax

; 87   : 
; 88   : 	// positioned in space
; 89   : 	MSG_ReadVec3Coord( msg, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 90   : 
; 91   : 	if( FBitSet( flags, SND_SENTENCE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN8@CL_ParseSo

; 92   : 	{
; 93   : 		char	sentenceName[32];
; 94   : 
; 95   : 		if( FBitSet( flags, SND_SEQUENCE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN10@CL_ParseSo

; 96   : 			Q_snprintf( sentenceName, sizeof( sentenceName ), "!#%i", sound + MAX_SOUNDS );

	mov	eax, DWORD PTR _sound$[ebp]
	add	eax, 8192				; 00002000H
	push	eax
	push	OFFSET ??_C@_04PNECFKGD@?$CB?$CD?$CFi@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _sentenceName$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@CL_ParseSo
$LN10@CL_ParseSo:

; 97   : 		else Q_snprintf( sentenceName, sizeof( sentenceName ), "!%i", sound );

	mov	eax, DWORD PTR _sound$[ebp]
	push	eax
	push	OFFSET ??_C@_03EMIMLMFN@?$CB?$CFi@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _sentenceName$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN11@CL_ParseSo:

; 98   : 
; 99   : 		handle = S_RegisterSound( sentenceName );

	lea	eax, DWORD PTR _sentenceName$1[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 100  : 	}

	jmp	SHORT $LN9@CL_ParseSo
$LN8@CL_ParseSo:

; 101  : 	else handle = cl.sound_index[sound];	// see precached sound

	mov	eax, DWORD PTR _sound$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	mov	DWORD PTR _handle$[ebp], ecx
$LN9@CL_ParseSo:

; 102  : 
; 103  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN12@CL_ParseSo

; 104  : 		return; // too early

	jmp	SHORT $LN14@CL_ParseSo
$LN12@CL_ParseSo:

; 105  : 
; 106  : 	// g-cont. sound and ambient sound have only difference with channel
; 107  : 	if( chan == CHAN_STATIC )

	cmp	DWORD PTR _chan$[ebp], 7
	jne	SHORT $LN13@CL_ParseSo

; 108  : 	{
; 109  : 		S_AmbientSound( pos, entnum, handle, volume, attn, pitch, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_S_AmbientSound
	add	esp, 28					; 0000001cH

; 110  : 	}

	jmp	SHORT $LN14@CL_ParseSo
$LN13@CL_ParseSo:

; 111  : 	else
; 112  : 	{
; 113  : 		S_StartSound( pos, entnum, chan, handle, volume, attn, pitch, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entnum$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN14@CL_ParseSo:

; 114  : 	}
; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseSoundPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_UserMsgStub
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pbuf$ = 16						; size = 4
_CL_UserMsgStub PROC					; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	return 1;

	mov	eax, 1

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UserMsgStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_WeaponAnim
_TEXT	SEGMENT
_view$ = -4						; size = 4
_iAnim$ = 8						; size = 4
_flFramerate$ = 12					; size = 4
_byFrame$ = 16						; size = 1
_CL_WeaponAnim PROC					; COMDAT

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 365  : 	cl_entity_t	*view = &clgame.viewent;

	mov	DWORD PTR _view$[ebp], OFFSET _clgame+260432

; 366  : 
; 367  : 	cl.local.weaponstarttime = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+2212768, xmm0

; 368  : 	cl.local.weaponstartframe = byFrame;

	movzx	eax, BYTE PTR _byFrame$[ebp]
	mov	BYTE PTR _cl+2212772, al

; 369  : 	cl.local.weaponsequence = iAnim;

	mov	eax, DWORD PTR _iAnim$[ebp]
	mov	DWORD PTR _cl+2212764, eax

; 370  : 	view->curstate.framerate = flFramerate;

	mov	eax, DWORD PTR _view$[ebp]
	movss	xmm0, DWORD PTR _flFramerate$[ebp]
	movss	DWORD PTR [eax+1008], xmm0

; 371  : 
; 372  : #if 0	// g-cont. for GlowShell testing
; 373  : 	view->curstate.renderfx = kRenderFxGlowShell;
; 374  : 	view->curstate.rendercolor.r = 255;
; 375  : 	view->curstate.rendercolor.g = 128;
; 376  : 	view->curstate.rendercolor.b = 0;
; 377  : 	view->curstate.renderamt = 150;
; 378  : #endif
; 379  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WeaponAnim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseServerTime
_TEXT	SEGMENT
tv139 = -80						; size = 8
_dt$ = -8						; size = 8
_msg$ = 8						; size = 4
_CL_ParseServerTime PROC				; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 187  : 	double	dt;
; 188  : 
; 189  : 	cl.mtime[1] = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl[edx+32], xmm0

; 190  : 	cl.mtime[0] = MSG_ReadFloat( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	mov	ecx, 8
	imul	edx, ecx, 0
	fstp	QWORD PTR _cl[edx+32]

; 191  : 
; 192  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN2@CL_ParseSe

; 193  : 		return; // don't mess the time

	jmp	$LN7@CL_ParseSe
$LN2@CL_ParseSe:

; 194  : 
; 195  : 	if( cl.maxclients == 1 )

	cmp	DWORD PTR _cl+2213004, 1
	jne	SHORT $LN3@CL_ParseSe

; 196  : 		cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+2167640, xmm0
$LN3@CL_ParseSe:

; 197  : 
; 198  : 	dt = cl.time - cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _dt$[ebp], xmm0

; 199  : 
; 200  : 	if( fabs( dt ) > cl_clockreset->value )	// 0.1 by default

	sub	esp, 8
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv139[ebp]
	movsd	xmm0, QWORD PTR tv139[ebp]
	mov	eax, DWORD PTR _cl_clockreset
	cvtss2sd xmm1, DWORD PTR [eax+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN4@CL_ParseSe

; 201  : 	{
; 202  : 		cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+2167640, xmm0

; 203  : 		cl.timedelta = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+2167656, xmm0

; 204  : 	}

	jmp	SHORT $LN6@CL_ParseSe
$LN4@CL_ParseSe:

; 205  : 	else if( dt != 0.0 )

	movsd	xmm0, QWORD PTR _dt$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseSe

; 206  : 	{
; 207  : 		cl.timedelta = dt;

	cvtsd2ss xmm0, QWORD PTR _dt$[ebp]
	movss	DWORD PTR _cl+2167656, xmm0
$LN6@CL_ParseSe:

; 208  : 	}
; 209  : 
; 210  : 	if( cl.oldtime > cl.time )

	movsd	xmm0, QWORD PTR _cl+2167648
	comisd	xmm0, QWORD PTR _cl+2167640
	jbe	SHORT $LN7@CL_ParseSe

; 211  : 		cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _cl+2167648, xmm0
$LN7@CL_ParseSe:

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseServerTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseViewEntity
_TEXT	SEGMENT
tv71 = -72						; size = 4
tv70 = -68						; size = 4
_msg$ = 8						; size = 4
_CL_ParseViewEntity PROC				; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 48   : 	cl.viewentity = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _cl+2212780, eax

; 49   : 
; 50   : 	// check entity bounds in case we want
; 51   : 	// to use this directly in clgame.entities[] array
; 52   : 	cl.viewentity = bound( 0, cl.viewentity, clgame.maxEntities - 1 );

	cmp	DWORD PTR _cl+2212780, 0
	jl	SHORT $LN5@CL_ParseVi
	mov	eax, DWORD PTR _clgame+1008
	sub	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	jge	SHORT $LN3@CL_ParseVi
	mov	ecx, DWORD PTR _cl+2212780
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@CL_ParseVi
$LN3@CL_ParseVi:
	mov	edx, DWORD PTR _clgame+1008
	sub	edx, 1
	mov	DWORD PTR tv70[ebp], edx
$LN4@CL_ParseVi:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN6@CL_ParseVi
$LN5@CL_ParseVi:
	mov	DWORD PTR tv71[ebp], 0
$LN6@CL_ParseVi:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _cl+2212780, ecx

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseViewEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_RegisterResources
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mod$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_RegisterResources PROC				; COMDAT

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1476 : 	model_t	*mod;
; 1477 : 	int	i;
; 1478 : 
; 1479 : 	if( cls.dl.custom || cls.signon == SIGNONS && cls.state == ca_active )

	cmp	DWORD PTR _cls+296708, 0
	jne	SHORT $LN6@CL_Registe
	cmp	DWORD PTR _cls+64, 2
	jne	SHORT $LN5@CL_Registe
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN5@CL_Registe
$LN6@CL_Registe:

; 1480 : 	{
; 1481 : 		cls.dl.custom = false;

	mov	DWORD PTR _cls+296708, 0

; 1482 : 		return;

	jmp	$LN9@CL_Registe
$LN5@CL_Registe:

; 1483 : 	}
; 1484 : 
; 1485 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN7@CL_Registe

; 1486 : 		CL_SendConsistencyInfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_SendConsistencyInfo
	add	esp, 4
$LN7@CL_Registe:

; 1487 : 
; 1488 : 	// All done precaching.
; 1489 : 	cl.worldmodel = CL_ModelHandle( 1 ); // get world pointer

	push	1
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _cl+4579004, eax

; 1490 : 
; 1491 : 	if( cl.worldmodel && cl.maxclients > 0 )

	cmp	DWORD PTR _cl+4579004, 0
	je	$LN8@CL_Registe
	cmp	DWORD PTR _cl+2213004, 0
	jle	$LN8@CL_Registe

; 1492 : 	{
; 1493 : 		ASSERT( clgame.entities != NULL );

	cmp	DWORD PTR _clgame+996, 0
	jne	SHORT $LN10@CL_Registe
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_RegisterResources@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN10@CL_Registe:

; 1494 : 		clgame.entities->model = cl.worldmodel;

	mov	eax, DWORD PTR _clgame+996
	mov	ecx, DWORD PTR _cl+4579004
	mov	DWORD PTR [eax+3300], ecx

; 1495 : 
; 1496 : 		if( cls.state != ca_disconnected )

	cmp	DWORD PTR _cls, 0
	je	$LN11@CL_Registe

; 1497 : 		{
; 1498 : 			Con_Printf( "Setting up renderer...\n" );

	push	OFFSET ??_C@_0BI@DBOGADI@Setting?5up?5renderer?4?4?4?6@
	call	_Con_Printf
	add	esp, 4

; 1499 : 
; 1500 : 			// load tempent sprites (glowshell, muzzleflashes etc)
; 1501 : 			CL_LoadClientSprites ();

	call	_CL_LoadClientSprites

; 1502 : 
; 1503 : 			// invalidate all decal indexes
; 1504 : 			memset( cl.decal_index, 0, sizeof( cl.decal_index ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _cl+4577980
	call	_memset
	add	esp, 12					; 0000000cH

; 1505 : 			cl.video_prepped = true;

	mov	DWORD PTR _cl+16, 1

; 1506 : 			cl.audio_prepped = true;

	mov	DWORD PTR _cl+20, 1

; 1507 : 
; 1508 : 			CL_ClearWorld ();

	call	_CL_ClearWorld

; 1509 : 
; 1510 : 			// tell rendering system we have a new set of models.
; 1511 : 			R_NewMap ();

	call	_R_NewMap

; 1512 : 
; 1513 : 			CL_SetupOverviewParams();

	call	_CL_SetupOverviewParams

; 1514 : 
; 1515 : 			if( clgame.drawFuncs.R_NewMap != NULL )

	cmp	DWORD PTR _clgame+216, 0
	je	SHORT $LN12@CL_Registe

; 1516 : 				clgame.drawFuncs.R_NewMap();

	call	DWORD PTR _clgame+216
$LN12@CL_Registe:

; 1517 : 
; 1518 : 			// release unused SpriteTextures
; 1519 : 			for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+14124
	jmp	SHORT $LN4@CL_Registe
$LN2@CL_Registe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@CL_Registe:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@CL_Registe

; 1520 : 			{
; 1521 : 				if( mod->needload == NL_UNREFERENCED && COM_CheckString( mod->name ))

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN13@CL_Registe
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CL_Registe

; 1522 : 					Mod_UnloadSpriteModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4
$LN13@CL_Registe:

; 1523 : 			}

	jmp	SHORT $LN2@CL_Registe
$LN3@CL_Registe:

; 1524 : 
; 1525 : 			Mod_FreeUnused ();

	call	_Mod_FreeUnused

; 1526 : 
; 1527 : 			if( host_developer.value <= DEV_NONE )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _host_developer+12
	jb	SHORT $LN14@CL_Registe

; 1528 : 				Con_ClearNotify(); // clear any lines of console text

	call	_Con_ClearNotify
$LN14@CL_Registe:

; 1529 : 
; 1530 : 			// done with all resources, issue prespawn command.
; 1531 : 			// Include server count in case server disconnects and changes level during d/l
; 1532 : 			MSG_BeginClientCmd( msg, clc_stringcmd );

	push	0
	push	0
	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1533 : 			MSG_WriteString( msg, va( "spawn %i", cl.servercount ));

	mov	eax, DWORD PTR _cl
	push	eax
	push	OFFSET ??_C@_08ELOHMNAO@spawn?5?$CFi@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
$LN11@CL_Registe:

; 1534 : 		}
; 1535 : 	}

	jmp	SHORT $LN9@CL_Registe
$LN8@CL_Registe:

; 1536 : 	else
; 1537 : 	{
; 1538 : 		Con_Printf( S_ERROR "client world model is NULL\n" );

	push	OFFSET ??_C@_0CH@PNJNFGNI@?$FO1Error?3?$FO7?5client?5world?5model?5i@
	call	_Con_Printf
	add	esp, 4

; 1539 : 		CL_Disconnect();

	call	_CL_Disconnect
$LN9@CL_Registe:

; 1540 : 	}
; 1541 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_RequestMissingResources
_TEXT	SEGMENT
_p$ = -4						; size = 4
_CL_RequestMissingResources PROC			; COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 435  : 	resource_t	*p;
; 436  : 
; 437  : 	if( !cls.dl.doneregistering && ( cls.dl.custom || cls.state == ca_validate ))

	cmp	DWORD PTR _cls+296580, 0
	jne	SHORT $LN2@CL_Request
	cmp	DWORD PTR _cls+296708, 0
	jne	SHORT $LN3@CL_Request
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN2@CL_Request
$LN3@CL_Request:

; 438  : 	{
; 439  : 		p = cl.resourcesneeded.pNext;

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax

; 440  : 
; 441  : 		if( p == &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	jne	SHORT $LN4@CL_Request

; 442  : 		{
; 443  : 			cls.dl.doneregistering = true;

	mov	DWORD PTR _cls+296580, 1

; 444  : 			host.downloadcount = 0;

	mov	DWORD PTR _host+752, 0

; 445  : 			cls.dl.custom = false;

	mov	DWORD PTR _cls+296708, 0

; 446  : 		}

	jmp	SHORT $LN2@CL_Request
$LN4@CL_Request:

; 447  : 		else if( !FBitSet( p->ucFlags, RES_WASMISSING ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 2
	jne	SHORT $LN2@CL_Request

; 448  : 		{
; 449  : 			CL_MoveToOnHandList( cl.resourcesneeded.pNext );

	mov	eax, DWORD PTR _cl+3029680
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 450  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_Request
$LN2@CL_Request:

; 451  : 		}
; 452  : 	}
; 453  : 	return false;

	xor	eax, eax
$LN1@CL_Request:

; 454  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RequestMissingResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_DispatchUserMessage
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_iSize$ = 12						; size = 4
_pbuf$ = 16						; size = 4
_CL_DispatchUserMessage PROC				; COMDAT

; 1861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1862 : 	int	i;
; 1863 : 
; 1864 : 	if( !COM_CheckString( pszName ))

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_Dispatc

; 1865 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Dispatc
$LN5@CL_Dispatc:

; 1866 : 
; 1867 : 	for( i = 0; i < MAX_USER_MESSAGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_Dispatc
$LN2@CL_Dispatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Dispatc:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_Dispatc

; 1868 : 	{
; 1869 : 		// search for user message
; 1870 : 		if( !Q_strcmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1360
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_Dispatc

; 1871 : 			break;

	jmp	SHORT $LN3@CL_Dispatc
$LN6@CL_Dispatc:

; 1872 : 	}

	jmp	SHORT $LN2@CL_Dispatc
$LN3@CL_Dispatc:

; 1873 : 
; 1874 : 	if( i == MAX_USER_MESSAGES )

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN7@CL_Dispatc

; 1875 : 	{
; 1876 : 		Con_DPrintf( S_ERROR "UserMsg: bad message %s\n", pszName );

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@GAELJHHC@?$FO1Error?3?$FO7?5UserMsg?3?5bad?5message@
	call	_Con_DPrintf
	add	esp, 8

; 1877 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_Dispatc
$LN7@CL_Dispatc:

; 1878 : 	}
; 1879 : 
; 1880 : 	if( clgame.msg[i].func )

	imul	eax, DWORD PTR _i$[ebp], 44
	cmp	DWORD PTR _clgame[eax+1400], 0
	je	SHORT $LN8@CL_Dispatc

; 1881 : 	{
; 1882 : 		clgame.msg[i].func( pszName, iSize, pbuf );

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszName$[ebp]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1400]
	call	ecx
	add	esp, 12					; 0000000cH

; 1883 : 	}

	jmp	SHORT $LN9@CL_Dispatc
$LN8@CL_Dispatc:

; 1884 : 	else
; 1885 : 	{
; 1886 : 		Con_DPrintf( S_ERROR "UserMsg: No pfn %s %d\n", clgame.msg[i].name, clgame.msg[i].number );

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1392]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1360
	push	edx
	push	OFFSET ??_C@_0CC@OJAEEBDK@?$FO1Error?3?$FO7?5UserMsg?3?5No?5pfn?5?$CFs?5?$CF@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1887 : 		clgame.msg[i].func = CL_UserMsgStub; // throw warning only once

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _clgame[eax+1400], OFFSET _CL_UserMsgStub
$LN9@CL_Dispatc:

; 1888 : 	}
; 1889 : 	return true;

	mov	eax, 1
$LN1@CL_Dispatc:

; 1890 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DispatchUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_StartResourceDownloading
_TEXT	SEGMENT
tv79 = -104						; size = 4
_ri$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pszMessage$ = 8					; size = 4
_bCustom$ = 12						; size = 4
_CL_StartResourceDownloading PROC			; COMDAT

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 597  : 	resourceinfo_t	ri;
; 598  : 
; 599  : 	if( COM_CheckString( pszMessage ))

	mov	eax, DWORD PTR _pszMessage$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_StartRe

; 600  : 		Con_DPrintf( "%s", pszMessage );

	mov	eax, DWORD PTR _pszMessage$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_DPrintf
	add	esp, 8
$LN2@CL_StartRe:

; 601  : 
; 602  : 	cls.dl.nTotalSize = COM_SizeofResourceList( &cl.resourcesneeded, &ri );

	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	push	OFFSET _cl+3029552
	call	_COM_SizeofResourceList
	add	esp, 8
	mov	DWORD PTR _cls+296692, eax

; 603  : 	cls.dl.nTotalToTransfer = CL_EstimateNeededResources();

	call	_CL_EstimateNeededResources
	mov	DWORD PTR _cls+296696, eax

; 604  : 
; 605  : 	if( bCustom )

	cmp	DWORD PTR _bCustom$[ebp], 0
	je	SHORT $LN3@CL_StartRe

; 606  : 	{
; 607  : 		cls.dl.custom = true;

	mov	DWORD PTR _cls+296708, 1

; 608  : 	}

	jmp	SHORT $LN4@CL_StartRe
$LN3@CL_StartRe:

; 609  : 	else
; 610  : 	{
; 611  : 		cls.state = ca_validate;

	mov	DWORD PTR _cls, 3

; 612  : 		cls.dl.custom = false;

	mov	DWORD PTR _cls+296708, 0
$LN4@CL_StartRe:

; 613  : 	}
; 614  : 
; 615  : 	cls.dl.doneregistering = false;

	mov	DWORD PTR _cls+296580, 0

; 616  : 	cls.dl.fLastStatusUpdate = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+296704, xmm0

; 617  : 	cls.dl.nRemainingToTransfer = cls.dl.nTotalToTransfer;

	mov	eax, DWORD PTR _cls+296696
	mov	DWORD PTR _cls+296700, eax

; 618  : 	memset( cls.dl.rgStats, 0, sizeof( cls.dl.rgStats ));

	push	96					; 00000060H
	push	0
	push	OFFSET _cls+296592
	call	_memset
	add	esp, 12					; 0000000cH

; 619  : 	cls.dl.nCurStat = 0;

	mov	DWORD PTR _cls+296688, 0

; 620  : 
; 621  : 	CL_BatchResourceRequest( !bCustom );

	cmp	DWORD PTR _bCustom$[ebp], 0
	jne	SHORT $LN6@CL_StartRe
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN7@CL_StartRe
$LN6@CL_StartRe:
	mov	DWORD PTR tv79[ebp], 0
$LN7@CL_StartRe:
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	call	_CL_BatchResourceRequest
	add	esp, 4

; 622  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StartResourceDownloading ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseServerMessage
_TEXT	SEGMENT
tv254 = -108						; size = 4
tv156 = -108						; size = 4
tv131 = -108						; size = 4
_s$ = -40						; size = 4
_old_background$ = -36					; size = 4
_flParam1$ = -28					; size = 4
_byParam1$ = -21					; size = 1
_param1$ = -16						; size = 4
_cmd$ = -12						; size = 4
_playerbytes$ = -8					; size = 4
_bufStart$ = -4						; size = 4
_msg$ = 8						; size = 4
_normal_message$ = 12					; size = 4
_CL_ParseServerMessage PROC				; COMDAT

; 1978 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 1979 : 	size_t		bufStart, playerbytes;
; 1980 : 	int		cmd, param1, param2;
; 1981 : 	byte byParam1, byParam2;
; 1982 : 	float flParam1, flParam2;
; 1983 : 	int		old_background;
; 1984 : 	const char	*s;
; 1985 : 
; 1986 : 	cls.starting_count = MSG_GetNumBytesRead( msg );	// updates each frame

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _cls+290584, eax

; 1987 : 	CL_Parse_Debug( true );			// begin parsing

	push	1
	call	_CL_Parse_Debug
	add	esp, 4

; 1988 : 
; 1989 : 	if( normal_message )

	cmp	DWORD PTR _normal_message$[ebp], 0
	je	SHORT $LN8@CL_ParseSe

; 1990 : 	{
; 1991 : 		// assume no entity/player update this packet
; 1992 : 		if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN7@CL_ParseSe

; 1993 : 		{
; 1994 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].valid = false;   

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	mov	DWORD PTR _cl[ecx+112], 0

; 1995 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	mov	DWORD PTR _cl[ecx+116], 0

; 1996 : 		}

	jmp	SHORT $LN8@CL_ParseSe
$LN7@CL_ParseSe:

; 1997 : 		else
; 1998 : 		{
; 1999 : 			CL_ResetFrame( &cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK] );

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+88
	push	ecx
	call	_CL_ResetFrame
	add	esp, 4
$LN8@CL_ParseSe:

; 2000 : 		}
; 2001 : 	}
; 2002 : 	
; 2003 : 	// parse the message
; 2004 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@CL_ParseSe

; 2005 : 	{
; 2006 : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@CL_ParseSe

; 2007 : 		{
; 2008 : 			Host_Error( "CL_ParseServerMessage: overflow!\n" );

	push	OFFSET ??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@
	call	_Host_Error
	add	esp, 4

; 2009 : 			return;

	jmp	$LN77@CL_ParseSe
$LN9@CL_ParseSe:

; 2010 : 		}
; 2011 : 
; 2012 : 		// mark start position
; 2013 : 		bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 2014 : 
; 2015 : 		// end of message (align bits)
; 2016 : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@CL_ParseSe

; 2017 : 			break;		

	jmp	$LN3@CL_ParseSe
$LN10@CL_ParseSe:

; 2018 : 
; 2019 : 		cmd = MSG_ReadServerCmd( msg );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 2020 : 
; 2021 : 		// record command for debugging spew on parse problem
; 2022 : 		CL_Parse_RecordCommand( cmd, bufStart );

	mov	eax, DWORD PTR _bufStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_CL_Parse_RecordCommand
	add	esp, 8

; 2023 : 
; 2024 : 		// other commands
; 2025 : 		switch( cmd )

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	cmp	DWORD PTR tv131[ebp], 58		; 0000003aH
	ja	$LN73@CL_ParseSe
	mov	ecx, DWORD PTR tv131[ebp]
	jmp	DWORD PTR $LN83@CL_ParseSe[ecx*4]
$LN11@CL_ParseSe:

; 2026 : 		{
; 2027 : 		case svc_bad:
; 2028 : 			Host_Error( "svc_bad\n" );

	push	OFFSET ??_C@_08CIDIFPDB@svc_bad?6@
	call	_Host_Error
	add	esp, 4

; 2029 : 			break;

	jmp	$LN4@CL_ParseSe
$LN12@CL_ParseSe:

; 2030 : 		case svc_nop:
; 2031 : 			// this does nothing
; 2032 : 			break;

	jmp	$LN4@CL_ParseSe
$LN13@CL_ParseSe:

; 2033 : 		case svc_disconnect:
; 2034 : 			CL_Drop ();

	call	_CL_Drop

; 2035 : 			Host_AbortCurrentFrame ();

	call	_Host_AbortCurrentFrame

; 2036 : 			break;

	jmp	$LN4@CL_ParseSe
$LN14@CL_ParseSe:

; 2037 : 		case svc_event:
; 2038 : 			CL_ParseEvent( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseEvent
	add	esp, 4

; 2039 : 			cl.frames[cl.parsecountmod].graphdata.event += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23866]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23866], cx

; 2040 : 			break;

	jmp	$LN4@CL_ParseSe
$LN15@CL_ParseSe:

; 2041 : 		case svc_changing:
; 2042 : 			old_background = cl.background;

	mov	eax, DWORD PTR _cl+64
	mov	DWORD PTR _old_background$[ebp], eax

; 2043 : 			if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@CL_ParseSe

; 2044 : 			{
; 2045 : 				cls.changelevel = true;

	mov	DWORD PTR _cls+8, 1

; 2046 : 				S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2047 : 
; 2048 : 				Con_Printf( "Server changing, reconnecting\n" );

	push	OFFSET ??_C@_0BP@LJOKNLCP@Server?5changing?0?5reconnecting?6@
	call	_Con_Printf
	add	esp, 4

; 2049 : 
; 2050 : 				if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN18@CL_ParseSe

; 2051 : 				{
; 2052 : 					SCR_BeginLoadingPlaque( cl.background );

	mov	eax, DWORD PTR _cl+64
	push	eax
	call	_SCR_BeginLoadingPlaque
	add	esp, 4

; 2053 : 					cls.changedemo = true;

	mov	DWORD PTR _cls+12, 1
$LN18@CL_ParseSe:

; 2054 : 				}
; 2055 : 
; 2056 : 				CL_ClearState ();

	call	_CL_ClearState

; 2057 : 				CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts

; 2058 : 			}

	jmp	SHORT $LN17@CL_ParseSe
$LN16@CL_ParseSe:

; 2059 : 			else Con_Printf( "Server disconnected, reconnecting\n" );

	push	OFFSET ??_C@_0CD@HKBNHCMP@Server?5disconnected?0?5reconnecti@
	call	_Con_Printf
	add	esp, 4
$LN17@CL_ParseSe:

; 2060 : 
; 2061 : 			if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN19@CL_ParseSe

; 2062 : 			{
; 2063 : 				cl.background = (cls.demonum != -1) ? true : false;

	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN79@CL_ParseSe
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN80@CL_ParseSe
$LN79@CL_ParseSe:
	mov	DWORD PTR tv156[ebp], 0
$LN80@CL_ParseSe:
	mov	eax, DWORD PTR tv156[ebp]
	mov	DWORD PTR _cl+64, eax

; 2064 : 				cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 2065 : 			}

	jmp	SHORT $LN20@CL_ParseSe
$LN19@CL_ParseSe:

; 2066 : 			else
; 2067 : 			{
; 2068 : 				// g-cont. local client skip the challenge
; 2069 : 				if( SV_Active( ))

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN21@CL_ParseSe

; 2070 : 					cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0
	jmp	SHORT $LN22@CL_ParseSe
$LN21@CL_ParseSe:

; 2071 : 				else cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1
$LN22@CL_ParseSe:

; 2072 : 				cl.background = old_background;

	mov	eax, DWORD PTR _old_background$[ebp]
	mov	DWORD PTR _cl+64, eax

; 2073 : 				cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0
$LN20@CL_ParseSe:

; 2074 : 			}
; 2075 : 			break;

	jmp	$LN4@CL_ParseSe
$LN23@CL_ParseSe:

; 2076 : 		case svc_setview:
; 2077 : 			CL_ParseViewEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseViewEntity
	add	esp, 4

; 2078 : 			break;

	jmp	$LN4@CL_ParseSe
$LN24@CL_ParseSe:

; 2079 : 		case svc_sound:
; 2080 : 			CL_ParseSoundPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSoundPacket
	add	esp, 4

; 2081 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23864]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23864], cx

; 2082 : 			break;

	jmp	$LN4@CL_ParseSe
$LN25@CL_ParseSe:

; 2083 : 		case svc_time:
; 2084 : 			CL_ParseServerTime( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseServerTime
	add	esp, 4

; 2085 : 			break;

	jmp	$LN4@CL_ParseSe
$LN26@CL_ParseSe:

; 2086 : 		case svc_print:
; 2087 : 			Con_Printf( "%s", MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2088 : 			break;

	jmp	$LN4@CL_ParseSe
$LN27@CL_ParseSe:

; 2089 : 		case svc_stufftext:
; 2090 : 			s = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 2091 : #ifdef HACKS_RELATED_HLMODS
; 2092 : 			// dsiable Cry Of Fear antisave protection
; 2093 : 			if( !Q_strnicmp( s, "disconnect", 10 ) && cls.signon != SIGNONS )

	push	10					; 0000000aH
	push	OFFSET ??_C@_0L@KKPFIJOL@disconnect@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@CL_ParseSe
	cmp	DWORD PTR _cls+64, 2
	je	SHORT $LN28@CL_ParseSe

; 2094 : 				break; // too early

	jmp	$LN4@CL_ParseSe
$LN28@CL_ParseSe:

; 2095 : #endif
; 2096 : 			Cbuf_AddText( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 2097 : 			break;

	jmp	$LN4@CL_ParseSe
$LN29@CL_ParseSe:

; 2098 : 		case svc_setangle:
; 2099 : 			CL_ParseSetAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSetAngle
	add	esp, 4

; 2100 : 			break;

	jmp	$LN4@CL_ParseSe
$LN30@CL_ParseSe:

; 2101 : 		case svc_serverdata:
; 2102 : 			Cbuf_Execute(); // make sure any stuffed commands are done

	call	_Cbuf_Execute

; 2103 : 			CL_ParseServerData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseServerData
	add	esp, 4

; 2104 : 			break;

	jmp	$LN4@CL_ParseSe
$LN31@CL_ParseSe:

; 2105 : 		case svc_lightstyle:
; 2106 : 			CL_ParseLightStyle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseLightStyle
	add	esp, 4

; 2107 : 			break;

	jmp	$LN4@CL_ParseSe
$LN32@CL_ParseSe:

; 2108 : 		case svc_updateuserinfo:
; 2109 : 			CL_UpdateUserinfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateUserinfo
	add	esp, 4

; 2110 : 			break;

	jmp	$LN4@CL_ParseSe
$LN33@CL_ParseSe:

; 2111 : 		case svc_deltatable:
; 2112 : 			Delta_ParseTableField( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_Delta_ParseTableField
	add	esp, 4

; 2113 : 			break;

	jmp	$LN4@CL_ParseSe
$LN34@CL_ParseSe:

; 2114 : 		case svc_clientdata:
; 2115 : 			CL_ParseClientData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseClientData
	add	esp, 4

; 2116 : 			cl.frames[cl.parsecountmod].graphdata.client += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23856]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23856], cx

; 2117 : 			break;

	jmp	$LN4@CL_ParseSe
$LN35@CL_ParseSe:

; 2118 : 		case svc_resource:
; 2119 : 			CL_ParseResource( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseResource
	add	esp, 4

; 2120 : 			break;

	jmp	$LN4@CL_ParseSe
$LN36@CL_ParseSe:

; 2121 : 		case svc_pings:
; 2122 : 			CL_UpdateUserPings( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateUserPings
	add	esp, 4

; 2123 : 			break;

	jmp	$LN4@CL_ParseSe
$LN37@CL_ParseSe:

; 2124 : 		case svc_particle:
; 2125 : 			CL_ParseParticles( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseParticles
	add	esp, 4

; 2126 : 			break;

	jmp	$LN4@CL_ParseSe
$LN38@CL_ParseSe:

; 2127 : 		case svc_restoresound:
; 2128 : 			CL_ParseRestoreSoundPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseRestoreSoundPacket
	add	esp, 4

; 2129 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23864]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23864], cx

; 2130 : 			break;

	jmp	$LN4@CL_ParseSe
$LN39@CL_ParseSe:

; 2131 : 		case svc_spawnstatic:
; 2132 : 			CL_ParseStaticEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseStaticEntity
	add	esp, 4

; 2133 : 			break;

	jmp	$LN4@CL_ParseSe
$LN40@CL_ParseSe:

; 2134 : 		case svc_event_reliable:
; 2135 : 			CL_ParseReliableEvent( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseReliableEvent
	add	esp, 4

; 2136 : 			cl.frames[cl.parsecountmod].graphdata.event += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23866]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23866], cx

; 2137 : 			break;

	jmp	$LN4@CL_ParseSe
$LN41@CL_ParseSe:

; 2138 : 		case svc_spawnbaseline:
; 2139 : 			CL_ParseBaseline( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseBaseline
	add	esp, 4

; 2140 : 			break;

	jmp	$LN4@CL_ParseSe
$LN42@CL_ParseSe:

; 2141 : 		case svc_temp_entity:
; 2142 : 			CL_ParseTempEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseTempEntity
	add	esp, 4

; 2143 : 			cl.frames[cl.parsecountmod].graphdata.tentities += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23862]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23862], cx

; 2144 : 			break;

	jmp	$LN4@CL_ParseSe
$LN43@CL_ParseSe:

; 2145 : 		case svc_setpause:
; 2146 : 			cl.paused = ( MSG_ReadOneBit( msg ) != 0 );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN81@CL_ParseSe
	mov	DWORD PTR tv254[ebp], 1
	jmp	SHORT $LN82@CL_ParseSe
$LN81@CL_ParseSe:
	mov	DWORD PTR tv254[ebp], 0
$LN82@CL_ParseSe:
	mov	ecx, DWORD PTR tv254[ebp]
	mov	DWORD PTR _cl+24, ecx

; 2147 : 			break;

	jmp	$LN4@CL_ParseSe
$LN44@CL_ParseSe:

; 2148 : 		case svc_signonnum:
; 2149 : 			CL_ParseSignon( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSignon
	add	esp, 4

; 2150 : 			break;

	jmp	$LN4@CL_ParseSe
$LN45@CL_ParseSe:

; 2151 : 		case svc_centerprint:
; 2152 : 			CL_CenterPrint( MSG_ReadString( msg ), 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_CL_CenterPrint
	add	esp, 8

; 2153 : 			break;

	jmp	$LN4@CL_ParseSe
$LN46@CL_ParseSe:

; 2154 : 		case svc_intermission:
; 2155 : 			cl.intermission = 1;

	mov	DWORD PTR _cl+2212820, 1

; 2156 : 			break;

	jmp	$LN4@CL_ParseSe
$LN47@CL_ParseSe:

; 2157 : 		case svc_finale:
; 2158 : 			CL_ParseFinaleCutscene( msg, 2 );

	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 2159 : 			break;

	jmp	$LN4@CL_ParseSe
$LN48@CL_ParseSe:

; 2160 : 		case svc_cdtrack:
; 2161 : 			S_StartBackgroundTrack(MSG_ReadString(msg), MSG_ReadString(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), true );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_S_StartBackgroundTrack
	add	esp, 28					; 0000001cH

; 2162 : 			break;

	jmp	$LN4@CL_ParseSe
$LN49@CL_ParseSe:

; 2163 : 		case svc_restore:
; 2164 : 			CL_ParseRestore( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseRestore
	add	esp, 4

; 2165 : 			break;

	jmp	$LN4@CL_ParseSe
$LN50@CL_ParseSe:

; 2166 : 		case svc_cutscene:
; 2167 : 			CL_ParseFinaleCutscene( msg, 3 );

	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 2168 : 			break;

	jmp	$LN4@CL_ParseSe
$LN51@CL_ParseSe:

; 2169 : 		case svc_weaponanim:
; 2170 : 			param1 = MSG_ReadLong( msg );	// iAnim

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 2171 : 			flParam1 = MSG_ReadFloat( msg );	// flFramerate

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR _flParam1$[ebp]

; 2172 : 			byParam1 = MSG_ReadByte(msg); // byFrame

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	BYTE PTR _byParam1$[ebp], al

; 2173 : 			CL_WeaponAnim( param1, flParam1, byParam1 );

	movzx	eax, BYTE PTR _byParam1$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _flParam1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _param1$[ebp]
	push	ecx
	call	_CL_WeaponAnim
	add	esp, 12					; 0000000cH

; 2174 : 			break;

	jmp	$LN4@CL_ParseSe
$LN52@CL_ParseSe:

; 2175 : 		case svc_bspdecal:
; 2176 : 			CL_ParseStaticDecal( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseStaticDecal
	add	esp, 4

; 2177 : 			break;

	jmp	$LN4@CL_ParseSe
$LN53@CL_ParseSe:

; 2178 : 		case svc_roomtype:
; 2179 : 			param1 = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 2180 : 			Cvar_SetValue( "room_type", param1 );

	cvtsi2ss xmm0, DWORD PTR _param1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09CFHPPHOC@room_type@
	call	_Cvar_SetValue
	add	esp, 8

; 2181 : 			break;

	jmp	$LN4@CL_ParseSe
$LN54@CL_ParseSe:

; 2182 : 		case svc_addangle:
; 2183 : 			CL_ParseAddAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseAddAngle
	add	esp, 4

; 2184 : 			break;

	jmp	$LN4@CL_ParseSe
$LN55@CL_ParseSe:

; 2185 : 		case svc_usermessage:
; 2186 : 			CL_RegisterUserMessage( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_RegisterUserMessage
	add	esp, 4

; 2187 : 			break;

	jmp	$LN4@CL_ParseSe
$LN56@CL_ParseSe:

; 2188 : 		case svc_packetentities:
; 2189 : 			playerbytes = CL_ParsePacketEntities( msg, false );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParsePacketEntities
	add	esp, 8
	mov	DWORD PTR _playerbytes$[ebp], eax

; 2190 : 			cl.frames[cl.parsecountmod].graphdata.players += playerbytes;

	imul	eax, DWORD PTR _cl+12, 24056
	movzx	ecx, WORD PTR _cl[eax+23858]
	add	ecx, DWORD PTR _playerbytes$[ebp]
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23858], cx

; 2191 : 			cl.frames[cl.parsecountmod].graphdata.entities += MSG_GetNumBytesRead( msg ) - bufStart - playerbytes;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	sub	eax, DWORD PTR _playerbytes$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23860]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23860], cx

; 2192 : 			break;

	jmp	$LN4@CL_ParseSe
$LN57@CL_ParseSe:

; 2193 : 		case svc_deltapacketentities:
; 2194 : 			playerbytes = CL_ParsePacketEntities( msg, true );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParsePacketEntities
	add	esp, 8
	mov	DWORD PTR _playerbytes$[ebp], eax

; 2195 : 			cl.frames[cl.parsecountmod].graphdata.players += playerbytes;

	imul	eax, DWORD PTR _cl+12, 24056
	movzx	ecx, WORD PTR _cl[eax+23858]
	add	ecx, DWORD PTR _playerbytes$[ebp]
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23858], cx

; 2196 : 			cl.frames[cl.parsecountmod].graphdata.entities += MSG_GetNumBytesRead( msg ) - bufStart - playerbytes;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	sub	eax, DWORD PTR _playerbytes$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23860]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23860], cx

; 2197 : 			break;

	jmp	$LN4@CL_ParseSe
$LN58@CL_ParseSe:

; 2198 : 		case svc_choke:
; 2199 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = true;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	mov	DWORD PTR _cl[ecx+116], 1

; 2200 : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].receivedtime = -2.0;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	movsd	xmm0, QWORD PTR __real@c000000000000000
	movsd	QWORD PTR _cl[ecx+88], xmm0

; 2201 : 			break;

	jmp	$LN4@CL_ParseSe
$LN59@CL_ParseSe:

; 2202 : 		case svc_resourcelist:
; 2203 : 			CL_ParseResourceList( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseResourceList
	add	esp, 4

; 2204 : 			break;

	jmp	$LN4@CL_ParseSe
$LN60@CL_ParseSe:

; 2205 : 		case svc_deltamovevars:
; 2206 : 			CL_ParseMovevars( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseMovevars
	add	esp, 4

; 2207 : 			break;

	jmp	$LN4@CL_ParseSe
$LN61@CL_ParseSe:

; 2208 : 		case svc_resourcerequest:
; 2209 : 			CL_ParseResourceRequest( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseResourceRequest
	add	esp, 4

; 2210 : 			break;

	jmp	$LN4@CL_ParseSe
$LN62@CL_ParseSe:

; 2211 : 		case svc_customization:
; 2212 : 			CL_ParseCustomization( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCustomization
	add	esp, 4

; 2213 : 			break;

	jmp	$LN4@CL_ParseSe
$LN63@CL_ParseSe:

; 2214 : 		case svc_crosshairangle:
; 2215 : 			CL_ParseCrosshairAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCrosshairAngle
	add	esp, 4

; 2216 : 			break;

	jmp	$LN4@CL_ParseSe
$LN64@CL_ParseSe:

; 2217 : 		case svc_soundfade:
; 2218 : 			CL_ParseSoundFade( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseSoundFade
	add	esp, 4

; 2219 : 			break;

	jmp	$LN4@CL_ParseSe
$LN65@CL_ParseSe:

; 2220 : 		case svc_filetxferfailed:
; 2221 : 			CL_ParseFileTransferFailed( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFileTransferFailed
	add	esp, 4

; 2222 : 			break;

	jmp	$LN4@CL_ParseSe
$LN66@CL_ParseSe:

; 2223 : 		case svc_hltv:
; 2224 : 			CL_ParseHLTV( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseHLTV
	add	esp, 4

; 2225 : 			break;

	jmp	$LN4@CL_ParseSe
$LN67@CL_ParseSe:

; 2226 : 		case svc_director:
; 2227 : 			CL_ParseDirector( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseDirector
	add	esp, 4

; 2228 : 			break;

	jmp	$LN4@CL_ParseSe
$LN68@CL_ParseSe:

; 2229 : 		case svc_voiceinit:
; 2230 : 			CL_ParseVoiceInit( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseVoiceInit
	add	esp, 4

; 2231 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN69@CL_ParseSe:

; 2232 : 		case svc_voicedata:
; 2233 : 			CL_ParseVoiceData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseVoiceData
	add	esp, 4

; 2234 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN70@CL_ParseSe:

; 2235 : 		case svc_resourcelocation:
; 2236 : 			CL_ParseResLocation( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseResLocation
	add	esp, 4

; 2237 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN71@CL_ParseSe:

; 2238 : 		case svc_querycvarvalue:
; 2239 : 			CL_ParseCvarValue( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCvarValue
	add	esp, 4

; 2240 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN72@CL_ParseSe:

; 2241 : 		case svc_querycvarvalue2:
; 2242 : 			CL_ParseCvarValue2( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseCvarValue2
	add	esp, 4

; 2243 : 			break;

	jmp	SHORT $LN4@CL_ParseSe
$LN73@CL_ParseSe:

; 2244 : 		default:
; 2245 : 			CL_ParseUserMessage( msg, cmd );

	mov	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseUserMessage
	add	esp, 8

; 2246 : 			cl.frames[cl.parsecountmod].graphdata.usr += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23868]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23868], cx
$LN4@CL_ParseSe:

; 2247 : 			break;
; 2248 : 		}
; 2249 : 	}

	jmp	$LN8@CL_ParseSe
$LN3@CL_ParseSe:

; 2250 : 
; 2251 : 	cl.frames[cl.parsecountmod].graphdata.msgbytes += MSG_GetNumBytesRead( msg ) - cls.starting_count;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _cls+290584
	movzx	ecx, WORD PTR _cl[esi+23870]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23870], cx

; 2252 : 	CL_Parse_Debug( false ); // done

	push	0
	call	_CL_Parse_Debug
	add	esp, 4

; 2253 : 
; 2254 : 	// we don't know if it is ok to save a demo message until
; 2255 : 	// after we have parsed the frame
; 2256 : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN77@CL_ParseSe

; 2257 : 	{
; 2258 : 		if( cls.demorecording && !cls.demowaiting )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN75@CL_ParseSe
	cmp	DWORD PTR _cls+300832, 0
	jne	SHORT $LN75@CL_ParseSe

; 2259 : 		{
; 2260 : 			CL_WriteDemoMessage( false, cls.starting_count, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+290584
	push	ecx
	push	0
	call	_CL_WriteDemoMessage
	add	esp, 12					; 0000000cH

; 2261 : 		}

	jmp	SHORT $LN77@CL_ParseSe
$LN75@CL_ParseSe:

; 2262 : 		else if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN77@CL_ParseSe

; 2263 : 		{
; 2264 : 			CL_WriteDemoMessage( true, cls.starting_count, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+290584
	push	ecx
	push	1
	call	_CL_WriteDemoMessage
	add	esp, 12					; 0000000cH
$LN77@CL_ParseSe:

; 2265 : 		}
; 2266 : 	}
; 2267 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN83@CL_ParseSe:
	DD	$LN11@CL_ParseSe
	DD	$LN12@CL_ParseSe
	DD	$LN13@CL_ParseSe
	DD	$LN14@CL_ParseSe
	DD	$LN15@CL_ParseSe
	DD	$LN23@CL_ParseSe
	DD	$LN24@CL_ParseSe
	DD	$LN25@CL_ParseSe
	DD	$LN26@CL_ParseSe
	DD	$LN27@CL_ParseSe
	DD	$LN29@CL_ParseSe
	DD	$LN30@CL_ParseSe
	DD	$LN31@CL_ParseSe
	DD	$LN32@CL_ParseSe
	DD	$LN33@CL_ParseSe
	DD	$LN34@CL_ParseSe
	DD	$LN35@CL_ParseSe
	DD	$LN36@CL_ParseSe
	DD	$LN37@CL_ParseSe
	DD	$LN38@CL_ParseSe
	DD	$LN39@CL_ParseSe
	DD	$LN40@CL_ParseSe
	DD	$LN41@CL_ParseSe
	DD	$LN42@CL_ParseSe
	DD	$LN43@CL_ParseSe
	DD	$LN44@CL_ParseSe
	DD	$LN45@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN46@CL_ParseSe
	DD	$LN47@CL_ParseSe
	DD	$LN48@CL_ParseSe
	DD	$LN49@CL_ParseSe
	DD	$LN50@CL_ParseSe
	DD	$LN51@CL_ParseSe
	DD	$LN52@CL_ParseSe
	DD	$LN53@CL_ParseSe
	DD	$LN54@CL_ParseSe
	DD	$LN55@CL_ParseSe
	DD	$LN56@CL_ParseSe
	DD	$LN57@CL_ParseSe
	DD	$LN58@CL_ParseSe
	DD	$LN59@CL_ParseSe
	DD	$LN60@CL_ParseSe
	DD	$LN61@CL_ParseSe
	DD	$LN62@CL_ParseSe
	DD	$LN63@CL_ParseSe
	DD	$LN64@CL_ParseSe
	DD	$LN65@CL_ParseSe
	DD	$LN66@CL_ParseSe
	DD	$LN67@CL_ParseSe
	DD	$LN68@CL_ParseSe
	DD	$LN69@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN73@CL_ParseSe
	DD	$LN70@CL_ParseSe
	DD	$LN71@CL_ParseSe
	DD	$LN72@CL_ParseSe
_CL_ParseServerMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 876  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jge	SHORT $LN2@CL_EDICT_N

; 877  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 878  : 
; 879  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 880  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_ParseUserMessage
_TEXT	SEGMENT
_iSize$ = -2060						; size = 4
_i$ = -2056						; size = 4
_pbuf$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_svc_num$ = 12						; size = 4
_CL_ParseUserMessage PROC				; COMDAT

; 1900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2380				; 0000094cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1901 : 	byte	pbuf[MAX_USERMSG_LENGTH];
; 1902 : 	int	i, iSize;
; 1903 : 
; 1904 : 	// NOTE: any user message is really parse at engine, not in client.dll
; 1905 : 	if( svc_num <= svc_lastmsg || svc_num > ( MAX_USER_MESSAGES + svc_lastmsg ))

	cmp	DWORD PTR _svc_num$[ebp], 58		; 0000003aH
	jle	SHORT $LN6@CL_ParseUs
	cmp	DWORD PTR _svc_num$[ebp], 255		; 000000ffH
	jle	SHORT $LN5@CL_ParseUs
$LN6@CL_ParseUs:

; 1906 : 	{
; 1907 : 		// out or range
; 1908 : 		Host_Error( "CL_ParseUserMessage: illegible server message %d\n", svc_num );

	mov	eax, DWORD PTR _svc_num$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@NEHPOEGF@CL_ParseUserMessage?3?5illegible?5@
	call	_Host_Error
	add	esp, 8

; 1909 : 		return;

	jmp	$LN1@CL_ParseUs
$LN5@CL_ParseUs:

; 1910 : 	}
; 1911 : 
; 1912 : 	for( i = 0; i < MAX_USER_MESSAGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseUs
$LN2@CL_ParseUs:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseUs:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_ParseUs

; 1913 : 	{
; 1914 : 		// search for user message
; 1915 : 		if( clgame.msg[i].number == svc_num )

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1392]
	cmp	ecx, DWORD PTR _svc_num$[ebp]
	jne	SHORT $LN7@CL_ParseUs

; 1916 : 			break;

	jmp	SHORT $LN3@CL_ParseUs
$LN7@CL_ParseUs:

; 1917 : 	}

	jmp	SHORT $LN2@CL_ParseUs
$LN3@CL_ParseUs:

; 1918 : 
; 1919 : 	if( i == MAX_USER_MESSAGES ) // probably unregistered

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN8@CL_ParseUs

; 1920 : 		Host_Error( "CL_ParseUserMessage: illegible server message %d\n", svc_num );

	mov	eax, DWORD PTR _svc_num$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@NEHPOEGF@CL_ParseUserMessage?3?5illegible?5@
	call	_Host_Error
	add	esp, 8
$LN8@CL_ParseUs:

; 1921 : 
; 1922 : 	// NOTE: some user messages handled into engine
; 1923 : 	if( !Q_strcmp( clgame.msg[i].name, "ScreenShake" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0M@FNPJCEOM@ScreenShake@
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1360
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_ParseUs

; 1924 : 	{
; 1925 : 		CL_ParseScreenShake( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseScreenShake
	add	esp, 4

; 1926 : 		return;

	jmp	$LN1@CL_ParseUs

; 1927 : 	}

	jmp	SHORT $LN10@CL_ParseUs
$LN9@CL_ParseUs:

; 1928 : 	else if( !Q_strcmp( clgame.msg[i].name, "ScreenFade" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@OBKHMDDA@ScreenFade@
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1360
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@CL_ParseUs

; 1929 : 	{
; 1930 : 		CL_ParseScreenFade( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseScreenFade
	add	esp, 4

; 1931 : 		return;

	jmp	$LN1@CL_ParseUs
$LN10@CL_ParseUs:

; 1932 : 	}
; 1933 : 
; 1934 : 	iSize = clgame.msg[i].size;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1396]
	mov	DWORD PTR _iSize$[ebp], ecx

; 1935 : 
; 1936 : 	// message with variable sizes receive an actual size as first byte
; 1937 : 	if( iSize == -1 ) iSize = MSG_ReadWord( msg );

	cmp	DWORD PTR _iSize$[ebp], -1
	jne	SHORT $LN12@CL_ParseUs
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax
$LN12@CL_ParseUs:

; 1938 : 
; 1939 : 	// parse user message into buffer
; 1940 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1941 : 
; 1942 : 	if( clgame.msg[i].func )

	imul	eax, DWORD PTR _i$[ebp], 44
	cmp	DWORD PTR _clgame[eax+1400], 0
	je	$LN13@CL_ParseUs

; 1943 : 	{
; 1944 : 		clgame.msg[i].func( clgame.msg[i].name, iSize, pbuf );

	lea	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1360
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1400]
	call	ecx
	add	esp, 12					; 0000000cH

; 1945 : 
; 1946 : #ifdef HACKS_RELATED_HLMODS
; 1947 : 		// run final credits for Half-Life because hl1 doesn't have call END_SECTION
; 1948 : 		if( !Q_stricmp( clgame.msg[i].name, "HudText" ) && !Q_stricmp( GI->gamefolder, "fareast" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07JNEKKACO@HudText@
	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _clgame+1360
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs
	push	99999					; 0001869fH
	push	OFFSET ??_C@_07CINOGAJB@fareast@
	mov	eax, DWORD PTR _SI+768
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs

; 1949 : 		{
; 1950 : 			// it's a end, so we should run credits
; 1951 : 			if( !Q_strcmp( (char *)pbuf, "END3" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04FBPNLAPJ@END3@
	lea	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_ParseUs

; 1952 : 				Host_Credits();

	call	_Host_Credits
$LN15@CL_ParseUs:

; 1953 : 		}
; 1954 : #endif
; 1955 : 	}

	jmp	SHORT $LN1@CL_ParseUs
$LN13@CL_ParseUs:

; 1956 : 	else
; 1957 : 	{
; 1958 : 		Con_DPrintf( S_ERROR "UserMsg: No pfn %s %d\n", clgame.msg[i].name, clgame.msg[i].number );

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame[eax+1392]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 44
	add	edx, OFFSET _clgame+1360
	push	edx
	push	OFFSET ??_C@_0CC@OJAEEBDK@?$FO1Error?3?$FO7?5UserMsg?3?5No?5pfn?5?$CFs?5?$CF@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1959 : 		clgame.msg[i].func = CL_UserMsgStub; // throw warning only once

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _clgame[eax+1400], OFFSET _CL_UserMsgStub
$LN1@CL_ParseUs:

; 1960 : 	}
; 1961 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_EstimateNeededResources
_TEXT	SEGMENT
tv67 = -80						; size = 4
_nSize$ = -12						; size = 4
_nTotalSize$ = -8					; size = 4
_p$ = -4						; size = 4
_CL_EstimateNeededResources PROC			; COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 548  : 	resource_t	*p;
; 549  : 	int		nTotalSize = 0;

	mov	DWORD PTR _nTotalSize$[ebp], 0

; 550  : 	int		nSize;
; 551  : 
; 552  : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_Estimat
$LN2@CL_Estimat:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@CL_Estimat:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	$LN3@CL_Estimat

; 553  : 	{
; 554  : 		switch( p->type )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 5
	ja	$LN5@CL_Estimat
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN18@CL_Estimat[edx*4]
$LN7@CL_Estimat:

; 555  : 		{
; 556  : 		case t_sound:
; 557  : 			nSize = FS_FileSize( va( "%s%s", DEFAULT_SOUNDPATH, p->szFileName ), false );

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 558  : 			if( p->szFileName[0] != '*' && nSize == -1 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN8@CL_Estimat
	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN8@CL_Estimat

; 559  : 			{
; 560  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 561  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN8@CL_Estimat:

; 562  : 			}
; 563  : 			break;

	jmp	$LN5@CL_Estimat
$LN9@CL_Estimat:

; 564  : 		case t_model:
; 565  : 			nSize = FS_FileSize( p->szFileName, false );

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 566  : 			if( p->szFileName[0] != '*' && nSize == -1 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN10@CL_Estimat
	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN10@CL_Estimat

; 567  : 			{
; 568  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 569  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN10@CL_Estimat:

; 570  : 			}
; 571  : 			break;

	jmp	SHORT $LN5@CL_Estimat
$LN13@CL_Estimat:

; 572  : 		case t_skin:
; 573  : 		case t_generic:
; 574  : 		case t_eventscript:
; 575  : 			nSize = FS_FileSize( p->szFileName, false );

	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	mov	DWORD PTR _nSize$[ebp], eax

; 576  : 			if( nSize == -1 )

	cmp	DWORD PTR _nSize$[ebp], -1
	jne	SHORT $LN14@CL_Estimat

; 577  : 			{
; 578  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 579  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN14@CL_Estimat:

; 580  : 			}
; 581  : 			break;

	jmp	SHORT $LN5@CL_Estimat
$LN15@CL_Estimat:

; 582  : 		case t_decal:
; 583  : 			if( FBitSet( p->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN5@CL_Estimat

; 584  : 			{
; 585  : 				SetBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl

; 586  : 				nTotalSize += p->nDownloadSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _nTotalSize$[ebp]
	add	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _nTotalSize$[ebp], ecx
$LN5@CL_Estimat:

; 587  : 			}
; 588  : 			break;
; 589  : 		}		
; 590  : 	}

	jmp	$LN2@CL_Estimat
$LN3@CL_Estimat:

; 591  : 
; 592  : 	return nTotalSize;

	mov	eax, DWORD PTR _nTotalSize$[ebp]

; 593  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@CL_Estimat:
	DD	$LN7@CL_Estimat
	DD	$LN13@CL_Estimat
	DD	$LN9@CL_Estimat
	DD	$LN15@CL_Estimat
	DD	$LN13@CL_Estimat
	DD	$LN13@CL_Estimat
_CL_EstimateNeededResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_parse.c
;	COMDAT _CL_BatchResourceRequest
_TEXT	SEGMENT
tv85 = -131876						; size = 4
_filename$1 = -131360					; size = 256
_msg$ = -131104						; size = 20
_n$ = -131084						; size = 4
_p$ = -131080						; size = 4
_data$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_initialize$ = 8					; size = 4
_CL_BatchResourceRequest PROC				; COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131876				; 00020324H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 458  : 	byte		data[MAX_INIT_MSG];
; 459  : 	resource_t	*p, *n;
; 460  : 	sizebuf_t		msg;
; 461  : 
; 462  : 	MSG_Init( &msg, "Resource Batch", data, sizeof( data ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@PBAOHMHN@Resource?5Batch@
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 463  : 
; 464  : 	// client resources is not precached by server
; 465  : 	if( initialize ) CL_AddClientResources();

	cmp	DWORD PTR _initialize$[ebp], 0
	je	SHORT $LN7@CL_BatchRe
	call	_CL_AddClientResources
$LN7@CL_BatchRe:

; 466  : 
; 467  : 	for( p = cl.resourcesneeded.pNext; p && p != &cl.resourcesneeded; p = n )

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_BatchRe
$LN2@CL_BatchRe:
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN4@CL_BatchRe:
	cmp	DWORD PTR _p$[ebp], 0
	je	$LN3@CL_BatchRe
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	$LN3@CL_BatchRe

; 468  : 	{
; 469  : 		n = p->pNext;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _n$[ebp], ecx

; 470  : 
; 471  : 		if( !FBitSet( p->ucFlags, RES_WASMISSING ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 2
	jne	SHORT $LN8@CL_BatchRe

; 472  : 		{
; 473  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 474  : 			continue;

	jmp	SHORT $LN2@CL_BatchRe
$LN8@CL_BatchRe:

; 475  : 		}
; 476  : 
; 477  : 		if( cls.state == ca_active && !cl_download_ingame.value )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN9@CL_BatchRe
	movss	xmm0, DWORD PTR _cl_download_ingame+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_BatchRe

; 478  : 		{
; 479  : 			Con_Printf( "skipping in game download of %s\n", p->szFileName );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@DIKFALJD@skipping?5in?5game?5download?5of?5?$CFs@
	call	_Con_Printf
	add	esp, 8

; 480  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 481  : 			continue;

	jmp	$LN2@CL_BatchRe
$LN9@CL_BatchRe:

; 482  : 		}
; 483  : 
; 484  : 		switch( p->type )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR tv85[ebp], ecx
	cmp	DWORD PTR tv85[ebp], 5
	ja	$LN5@CL_BatchRe
	mov	edx, DWORD PTR tv85[ebp]
	jmp	DWORD PTR $LN26@CL_BatchRe[edx*4]
$LN10@CL_BatchRe:

; 485  : 		{
; 486  : 		case t_sound:
; 487  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@CL_BatchRe

; 488  : 				break;

	jmp	$LN5@CL_BatchRe
$LN11@CL_BatchRe:

; 489  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 490  : 			break;

	jmp	$LN5@CL_BatchRe
$LN12@CL_BatchRe:

; 491  : 		case t_skin:
; 492  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 493  : 			break;

	jmp	$LN5@CL_BatchRe
$LN13@CL_BatchRe:

; 494  : 		case t_model:
; 495  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@CL_BatchRe

; 496  : 				break;

	jmp	$LN5@CL_BatchRe
$LN14@CL_BatchRe:

; 497  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 498  : 			break;

	jmp	$LN5@CL_BatchRe
$LN15@CL_BatchRe:

; 499  : 		case t_decal:
; 500  : 			if( !HPAK_GetDataPointer( CUSTOM_RES_PATH, p, NULL, NULL ))

	push	0
	push	0
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN16@CL_BatchRe

; 501  : 			{
; 502  : 				if( !FBitSet( p->ucFlags, RES_REQUESTED ))

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 8
	jne	SHORT $LN17@CL_BatchRe

; 503  : 				{
; 504  : 					string	filename;
; 505  : 
; 506  : 					Q_snprintf( filename, sizeof( filename ), "!MD5%s", MD5_Print( p->rgucMD5_hash ));

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_06OIINFDDP@?$CBMD5?$CFs@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _filename$1[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 507  : 					MSG_BeginClientCmd( &msg, clc_stringcmd );

	push	0
	push	0
	push	3
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 508  : 					MSG_WriteString( &msg, va( "dlfile %s", filename ));

	lea	eax, DWORD PTR _filename$1[ebp]
	push	eax
	push	OFFSET ??_C@_09MCMGNHCF@dlfile?5?$CFs@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 509  : 					SetBits( p->ucFlags, RES_REQUESTED );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 8
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl
$LN17@CL_BatchRe:

; 510  : 				}
; 511  : 				break;

	jmp	$LN5@CL_BatchRe
$LN16@CL_BatchRe:

; 512  : 			}
; 513  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 514  : 			break;

	jmp	$LN5@CL_BatchRe
$LN18@CL_BatchRe:

; 515  : 		case t_generic:
; 516  : 			if( !COM_IsSafeFileToDownload( p->szFileName ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@CL_BatchRe

; 517  : 			{
; 518  : 				CL_RemoveFromResourceList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_RemoveFromResourceList
	add	esp, 4

; 519  : 				Mem_Free( p );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_BatchResourceRequest@@9@9
	add	eax, 62					; 0000003eH
	push	eax
	push	OFFSET ??_C@_0DF@PDEMMMEH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 520  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN19@CL_BatchRe:

; 521  : 			}
; 522  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@CL_BatchRe

; 523  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN20@CL_BatchRe:

; 524  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4

; 525  : 			break;

	jmp	SHORT $LN5@CL_BatchRe
$LN21@CL_BatchRe:

; 526  : 		case t_eventscript:
; 527  : 			if( !CL_CheckFile( &msg, p ))

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_CheckFile
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@CL_BatchRe

; 528  : 				break;

	jmp	SHORT $LN5@CL_BatchRe
$LN22@CL_BatchRe:

; 529  : 			CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4
$LN5@CL_BatchRe:

; 530  : 			break;
; 531  : 		}
; 532  : 	}

	jmp	$LN2@CL_BatchRe
$LN3@CL_BatchRe:

; 533  : 
; 534  : 	if( cls.state != ca_disconnected )

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN23@CL_BatchRe

; 535  : 	{
; 536  : 		if( !MSG_GetNumBytesWritten( &msg ) && CL_PrecacheResources( ))

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@CL_BatchRe
	call	_CL_PrecacheResources
	test	eax, eax
	je	SHORT $LN24@CL_BatchRe

; 537  : 		{
; 538  : 			CL_RegisterResources( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_RegisterResources
	add	esp, 4
$LN24@CL_BatchRe:

; 539  : 		}
; 540  : 
; 541  : 		Netchan_CreateFragments( &cls.netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_CreateFragments
	add	esp, 8

; 542  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_FragSend
	add	esp, 4
$LN23@CL_BatchRe:

; 543  : 	}
; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN26@CL_BatchRe:
	DD	$LN10@CL_BatchRe
	DD	$LN12@CL_BatchRe
	DD	$LN13@CL_BatchRe
	DD	$LN15@CL_BatchRe
	DD	$LN18@CL_BatchRe
	DD	$LN21@CL_BatchRe
_CL_BatchResourceRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
