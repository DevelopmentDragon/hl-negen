; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_save.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnSaveGameComment
PUBLIC	??_C@_07MLAMGOLD@mapName@			; `string'
PUBLIC	??_C@_07GJGNEJFD@comment@			; `string'
PUBLIC	??_C@_08IDKGGPIE@mapCount@			; `string'
PUBLIC	??_C@_0L@BGFMBPG@skillLevel@			; `string'
PUBLIC	??_C@_0M@KPKEBFBB@entityCount@			; `string'
PUBLIC	??_C@_0BA@MFJKOJFN@connectionCount@		; `string'
PUBLIC	??_C@_0BA@PIKGIBOP@lightStyleCount@		; `string'
PUBLIC	??_C@_04CLCEDBPF@time@				; `string'
PUBLIC	??_C@_07CBECEDCM@skyName@			; `string'
PUBLIC	??_C@_0L@IDNIDMLJ@skyColor_r@			; `string'
PUBLIC	??_C@_0L@LEGNNKKN@skyColor_g@			; `string'
PUBLIC	??_C@_0L@MJBKCOOI@skyColor_b@			; `string'
PUBLIC	??_C@_08GDJOMBN@skyVec_x@			; `string'
PUBLIC	??_C@_08BPCCNNFM@skyVec_y@			; `string'
PUBLIC	??_C@_08DEAPIOJP@skyVec_z@			; `string'
PUBLIC	??_C@_08GFHCJCHG@skyDir_x@			; `string'
PUBLIC	??_C@_08HMGJKDDH@skyDir_y@			; `string'
PUBLIC	??_C@_08FHEEPAPE@skyDir_z@			; `string'
PUBLIC	??_C@_08DJBJEPKN@skyAngle@			; `string'
PUBLIC	??_C@_08BEBEAHJL@skySpeed@			; `string'
PUBLIC	??_C@_0N@JJOOKKBJ@landmarkName@			; `string'
PUBLIC	??_C@_0N@FIMBEBDH@pentLandmark@			; `string'
PUBLIC	??_C@_0BC@FBMIBEC@vecLandmarkOrigin@		; `string'
PUBLIC	??_C@_05FKHKFDID@index@				; `string'
PUBLIC	??_C@_05IAKJCFIM@style@				; `string'
PUBLIC	??_C@_02EGCJHIOB@id@				; `string'
PUBLIC	??_C@_08CBBFJFMD@location@			; `string'
PUBLIC	??_C@_04IAGNFIBA@size@				; `string'
PUBLIC	??_C@_05GECEPKB@flags@				; `string'
PUBLIC	??_C@_09CNJINBGN@classname@			; `string'
PUBLIC	??_C@_0L@LBFHMNGA@decalCount@			; `string'
PUBLIC	??_C@_0L@BEKNOLNB@soundCount@			; `string'
PUBLIC	??_C@_0O@FIHJLNBI@tempEntsCount@		; `string'
PUBLIC	??_C@_0L@BFAEEEGI@introTrack@			; `string'
PUBLIC	??_C@_09DMFGKPLL@mainTrack@			; `string'
PUBLIC	??_C@_0O@CPICAPIH@trackPosition@		; `string'
PUBLIC	??_C@_07JJLFGEHB@loopNum@			; `string'
PUBLIC	??_C@_06LPGBNFFB@onLoop@			; `string'
PUBLIC	??_C@_0L@BDHFFEKG@viewentity@			; `string'
PUBLIC	??_C@_0L@PNIALNHI@wateralpha@			; `string'
PUBLIC	??_C@_08LONDINPF@wateramp@			; `string'
PUBLIC	??_C@_08OAGMDKAF@position@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0M@HLBKIPNA@entityIndex@			; `string'
PUBLIC	??_C@_05BJGJGKJC@depth@				; `string'
PUBLIC	??_C@_05MHMEBBGO@scale@				; `string'
PUBLIC	??_C@_0BC@DLIKOKND@impactPlaneNormal@		; `string'
PUBLIC	??_C@_0N@OCBKKDNJ@studio_state@			; `string'
PUBLIC	??_C@_0L@ODHFIMJE@messagenum@			; `string'
PUBLIC	??_C@_06NHCMNMEH@origin@			; `string'
PUBLIC	??_C@_06GNEAMJOC@angles@			; `string'
PUBLIC	??_C@_08IBBDGPOF@sequence@			; `string'
PUBLIC	??_C@_05MIJNFGED@frame@				; `string'
PUBLIC	??_C@_08OMBDDLKJ@colormap@			; `string'
PUBLIC	??_C@_04NHPAFEHJ@skin@				; `string'
PUBLIC	??_C@_04IEJGKNJ@body@				; `string'
PUBLIC	??_C@_07BLLGFBLI@effects@			; `string'
PUBLIC	??_C@_09PLDKGHKD@framerate@			; `string'
PUBLIC	??_C@_04FIAKMPII@mins@				; `string'
PUBLIC	??_C@_04IFBFDIKF@maxs@				; `string'
PUBLIC	??_C@_0L@PCPPJFN@rendermode@			; `string'
PUBLIC	??_C@_09BBEIIFBJ@renderamt@			; `string'
PUBLIC	??_C@_0M@PKPFNFIN@rendercolor@			; `string'
PUBLIC	??_C@_08CMBMAAGP@renderfx@			; `string'
PUBLIC	??_C@_0L@DNGLJIEO@controller@			; `string'
PUBLIC	??_C@_08EFDOIIKB@blending@			; `string'
PUBLIC	??_C@_05OPIONHBI@solid@				; `string'
PUBLIC	??_C@_08CPDCOAJK@animtime@			; `string'
PUBLIC	??_C@_08DMIOBKOG@movetype@			; `string'
PUBLIC	??_C@_06JFGGHPEA@vuser1@			; `string'
PUBLIC	??_C@_06LOELCMID@vuser2@			; `string'
PUBLIC	??_C@_06KHFABNMC@vuser3@			; `string'
PUBLIC	??_C@_06OIBBILAF@vuser4@			; `string'
PUBLIC	??_C@_06EPAJDGH@iuser1@				; `string'
PUBLIC	??_C@_06CPNNMAKE@iuser2@			; `string'
PUBLIC	??_C@_06DGMGPBOF@iuser3@			; `string'
PUBLIC	??_C@_06HJIHGHCC@iuser4@			; `string'
PUBLIC	??_C@_06PCLIODIO@fuser1@			; `string'
PUBLIC	??_C@_06NJJFLAEN@fuser2@			; `string'
PUBLIC	??_C@_06MAIOIBAM@fuser3@			; `string'
PUBLIC	??_C@_06IPMPBHML@fuser4@			; `string'
PUBLIC	??_C@_06NMCBFEIH@entnum@			; `string'
PUBLIC	??_C@_06EMCPHFGM@volume@			; `string'
PUBLIC	??_C@_0M@NKGAHMMH@attenuation@			; `string'
PUBLIC	??_C@_07EOMMFHON@looping@			; `string'
PUBLIC	??_C@_07MFOHDNMP@channel@			; `string'
PUBLIC	??_C@_05NCNFOFLM@pitch@				; `string'
PUBLIC	??_C@_09JFNLBOP@wordIndex@			; `string'
PUBLIC	??_C@_09EPOFMHCC@samplePos@			; `string'
PUBLIC	??_C@_09MMOEMCLM@forcedEnd@			; `string'
PUBLIC	??_C@_0L@JILCNGEO@globalname@			; `string'
_BSS	SEGMENT
_pfnSaveGameComment DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@JILCNGEO@globalname@
CONST	SEGMENT
??_C@_0L@JILCNGEO@globalname@ DB 'globalname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMOEMCLM@forcedEnd@
CONST	SEGMENT
??_C@_09MMOEMCLM@forcedEnd@ DB 'forcedEnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPOFMHCC@samplePos@
CONST	SEGMENT
??_C@_09EPOFMHCC@samplePos@ DB 'samplePos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFNLBOP@wordIndex@
CONST	SEGMENT
??_C@_09JFNLBOP@wordIndex@ DB 'wordIndex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCNFOFLM@pitch@
CONST	SEGMENT
??_C@_05NCNFOFLM@pitch@ DB 'pitch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFOHDNMP@channel@
CONST	SEGMENT
??_C@_07MFOHDNMP@channel@ DB 'channel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOMMFHON@looping@
CONST	SEGMENT
??_C@_07EOMMFHON@looping@ DB 'looping', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKGAHMMH@attenuation@
CONST	SEGMENT
??_C@_0M@NKGAHMMH@attenuation@ DB 'attenuation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EMCPHFGM@volume@
CONST	SEGMENT
??_C@_06EMCPHFGM@volume@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMCBFEIH@entnum@
CONST	SEGMENT
??_C@_06NMCBFEIH@entnum@ DB 'entnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPMPBHML@fuser4@
CONST	SEGMENT
??_C@_06IPMPBHML@fuser4@ DB 'fuser4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MAIOIBAM@fuser3@
CONST	SEGMENT
??_C@_06MAIOIBAM@fuser3@ DB 'fuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NJJFLAEN@fuser2@
CONST	SEGMENT
??_C@_06NJJFLAEN@fuser2@ DB 'fuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCLIODIO@fuser1@
CONST	SEGMENT
??_C@_06PCLIODIO@fuser1@ DB 'fuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HJIHGHCC@iuser4@
CONST	SEGMENT
??_C@_06HJIHGHCC@iuser4@ DB 'iuser4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DGMGPBOF@iuser3@
CONST	SEGMENT
??_C@_06DGMGPBOF@iuser3@ DB 'iuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPNNMAKE@iuser2@
CONST	SEGMENT
??_C@_06CPNNMAKE@iuser2@ DB 'iuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPAJDGH@iuser1@
CONST	SEGMENT
??_C@_06EPAJDGH@iuser1@ DB 'iuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIBBILAF@vuser4@
CONST	SEGMENT
??_C@_06OIBBILAF@vuser4@ DB 'vuser4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KHFABNMC@vuser3@
CONST	SEGMENT
??_C@_06KHFABNMC@vuser3@ DB 'vuser3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LOELCMID@vuser2@
CONST	SEGMENT
??_C@_06LOELCMID@vuser2@ DB 'vuser2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JFGGHPEA@vuser1@
CONST	SEGMENT
??_C@_06JFGGHPEA@vuser1@ DB 'vuser1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMIOBKOG@movetype@
CONST	SEGMENT
??_C@_08DMIOBKOG@movetype@ DB 'movetype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPDCOAJK@animtime@
CONST	SEGMENT
??_C@_08CPDCOAJK@animtime@ DB 'animtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OPIONHBI@solid@
CONST	SEGMENT
??_C@_05OPIONHBI@solid@ DB 'solid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFDOIIKB@blending@
CONST	SEGMENT
??_C@_08EFDOIIKB@blending@ DB 'blending', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DNGLJIEO@controller@
CONST	SEGMENT
??_C@_0L@DNGLJIEO@controller@ DB 'controller', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMBMAAGP@renderfx@
CONST	SEGMENT
??_C@_08CMBMAAGP@renderfx@ DB 'renderfx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKPFNFIN@rendercolor@
CONST	SEGMENT
??_C@_0M@PKPFNFIN@rendercolor@ DB 'rendercolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBEIIFBJ@renderamt@
CONST	SEGMENT
??_C@_09BBEIIFBJ@renderamt@ DB 'renderamt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCPPJFN@rendermode@
CONST	SEGMENT
??_C@_0L@PCPPJFN@rendermode@ DB 'rendermode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFBFDIKF@maxs@
CONST	SEGMENT
??_C@_04IFBFDIKF@maxs@ DB 'maxs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIAKMPII@mins@
CONST	SEGMENT
??_C@_04FIAKMPII@mins@ DB 'mins', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLDKGHKD@framerate@
CONST	SEGMENT
??_C@_09PLDKGHKD@framerate@ DB 'framerate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BLLGFBLI@effects@
CONST	SEGMENT
??_C@_07BLLGFBLI@effects@ DB 'effects', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body@
CONST	SEGMENT
??_C@_04IEJGKNJ@body@ DB 'body', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHPAFEHJ@skin@
CONST	SEGMENT
??_C@_04NHPAFEHJ@skin@ DB 'skin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMBDDLKJ@colormap@
CONST	SEGMENT
??_C@_08OMBDDLKJ@colormap@ DB 'colormap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIJNFGED@frame@
CONST	SEGMENT
??_C@_05MIJNFGED@frame@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBBDGPOF@sequence@
CONST	SEGMENT
??_C@_08IBBDGPOF@sequence@ DB 'sequence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GNEAMJOC@angles@
CONST	SEGMENT
??_C@_06GNEAMJOC@angles@ DB 'angles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHCMNMEH@origin@
CONST	SEGMENT
??_C@_06NHCMNMEH@origin@ DB 'origin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODHFIMJE@messagenum@
CONST	SEGMENT
??_C@_0L@ODHFIMJE@messagenum@ DB 'messagenum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OCBKKDNJ@studio_state@
CONST	SEGMENT
??_C@_0N@OCBKKDNJ@studio_state@ DB 'studio_state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DLIKOKND@impactPlaneNormal@
CONST	SEGMENT
??_C@_0BC@DLIKOKND@impactPlaneNormal@ DB 'impactPlaneNormal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHMEBBGO@scale@
CONST	SEGMENT
??_C@_05MHMEBBGO@scale@ DB 'scale', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BJGJGKJC@depth@
CONST	SEGMENT
??_C@_05BJGJGKJC@depth@ DB 'depth', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HLBKIPNA@entityIndex@
CONST	SEGMENT
??_C@_0M@HLBKIPNA@entityIndex@ DB 'entityIndex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAGMDKAF@position@
CONST	SEGMENT
??_C@_08OAGMDKAF@position@ DB 'position', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LONDINPF@wateramp@
CONST	SEGMENT
??_C@_08LONDINPF@wateramp@ DB 'wateramp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PNIALNHI@wateralpha@
CONST	SEGMENT
??_C@_0L@PNIALNHI@wateralpha@ DB 'wateralpha', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BDHFFEKG@viewentity@
CONST	SEGMENT
??_C@_0L@BDHFFEKG@viewentity@ DB 'viewentity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPGBNFFB@onLoop@
CONST	SEGMENT
??_C@_06LPGBNFFB@onLoop@ DB 'onLoop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JJLFGEHB@loopNum@
CONST	SEGMENT
??_C@_07JJLFGEHB@loopNum@ DB 'loopNum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPICAPIH@trackPosition@
CONST	SEGMENT
??_C@_0O@CPICAPIH@trackPosition@ DB 'trackPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMFGKPLL@mainTrack@
CONST	SEGMENT
??_C@_09DMFGKPLL@mainTrack@ DB 'mainTrack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFAEEEGI@introTrack@
CONST	SEGMENT
??_C@_0L@BFAEEEGI@introTrack@ DB 'introTrack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIHJLNBI@tempEntsCount@
CONST	SEGMENT
??_C@_0O@FIHJLNBI@tempEntsCount@ DB 'tempEntsCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEKNOLNB@soundCount@
CONST	SEGMENT
??_C@_0L@BEKNOLNB@soundCount@ DB 'soundCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LBFHMNGA@decalCount@
CONST	SEGMENT
??_C@_0L@LBFHMNGA@decalCount@ DB 'decalCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNJINBGN@classname@
CONST	SEGMENT
??_C@_09CNJINBGN@classname@ DB 'classname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GECEPKB@flags@
CONST	SEGMENT
??_C@_05GECEPKB@flags@ DB 'flags', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size@
CONST	SEGMENT
??_C@_04IAGNFIBA@size@ DB 'size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CBBFJFMD@location@
CONST	SEGMENT
??_C@_08CBBFJFMD@location@ DB 'location', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id@
CONST	SEGMENT
??_C@_02EGCJHIOB@id@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IAKJCFIM@style@
CONST	SEGMENT
??_C@_05IAKJCFIM@style@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index@
CONST	SEGMENT
??_C@_05FKHKFDID@index@ DB 'index', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FBMIBEC@vecLandmarkOrigin@
CONST	SEGMENT
??_C@_0BC@FBMIBEC@vecLandmarkOrigin@ DB 'vecLandmarkOrigin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIMBEBDH@pentLandmark@
CONST	SEGMENT
??_C@_0N@FIMBEBDH@pentLandmark@ DB 'pentLandmark', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJOOKKBJ@landmarkName@
CONST	SEGMENT
??_C@_0N@JJOOKKBJ@landmarkName@ DB 'landmarkName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEBEAHJL@skySpeed@
CONST	SEGMENT
??_C@_08BEBEAHJL@skySpeed@ DB 'skySpeed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DJBJEPKN@skyAngle@
CONST	SEGMENT
??_C@_08DJBJEPKN@skyAngle@ DB 'skyAngle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHEEPAPE@skyDir_z@
CONST	SEGMENT
??_C@_08FHEEPAPE@skyDir_z@ DB 'skyDir_z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMGJKDDH@skyDir_y@
CONST	SEGMENT
??_C@_08HMGJKDDH@skyDir_y@ DB 'skyDir_y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFHCJCHG@skyDir_x@
CONST	SEGMENT
??_C@_08GFHCJCHG@skyDir_x@ DB 'skyDir_x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEAPIOJP@skyVec_z@
CONST	SEGMENT
??_C@_08DEAPIOJP@skyVec_z@ DB 'skyVec_z', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPCCNNFM@skyVec_y@
CONST	SEGMENT
??_C@_08BPCCNNFM@skyVec_y@ DB 'skyVec_y', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDJOMBN@skyVec_x@
CONST	SEGMENT
??_C@_08GDJOMBN@skyVec_x@ DB 'skyVec_x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJBKCOOI@skyColor_b@
CONST	SEGMENT
??_C@_0L@MJBKCOOI@skyColor_b@ DB 'skyColor_b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LEGNNKKN@skyColor_g@
CONST	SEGMENT
??_C@_0L@LEGNNKKN@skyColor_g@ DB 'skyColor_g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IDNIDMLJ@skyColor_r@
CONST	SEGMENT
??_C@_0L@IDNIDMLJ@skyColor_r@ DB 'skyColor_r', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CBECEDCM@skyName@
CONST	SEGMENT
??_C@_07CBECEDCM@skyName@ DB 'skyName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time@
CONST	SEGMENT
??_C@_04CLCEDBPF@time@ DB 'time', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIKGIBOP@lightStyleCount@
CONST	SEGMENT
??_C@_0BA@PIKGIBOP@lightStyleCount@ DB 'lightStyleCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MFJKOJFN@connectionCount@
CONST	SEGMENT
??_C@_0BA@MFJKOJFN@connectionCount@ DB 'connectionCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KPKEBFBB@entityCount@
CONST	SEGMENT
??_C@_0M@KPKEBFBB@entityCount@ DB 'entityCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGFMBPG@skillLevel@
CONST	SEGMENT
??_C@_0L@BGFMBPG@skillLevel@ DB 'skillLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDKGGPIE@mapCount@
CONST	SEGMENT
??_C@_08IDKGGPIE@mapCount@ DB 'mapCount', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJGNEJFD@comment@
CONST	SEGMENT
??_C@_07GJGNEJFD@comment@ DB 'comment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MLAMGOLD@mapName@
CONST	SEGMENT
??_C@_07MLAMGOLD@mapName@ DB 'mapName', 00H		; `string'
CONST	ENDS
PUBLIC	_SV_GetSaveComment
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetNumBytesLeft
PUBLIC	_SV_SaveGame
PUBLIC	_SV_LoadGame
PUBLIC	_SV_LoadGameState
PUBLIC	_SV_ChangeLevel
PUBLIC	_SV_GetLatestSave
PUBLIC	_SV_InitSaveRestore
PUBLIC	_SV_ClearGameState
PUBLIC	??_C@_0BD@EJBAAKHO@?$CF?964?464s?5?$CF02d?3?$CF02d@ ; `string'
PUBLIC	?__LINE__Var@?0??DirectoryCount@@9@9		; `DirectoryCount'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??InitEntityTable@@9@9		; `InitEntityTable'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??EntityInSolid@@9@9		; `EntityInSolid'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ClearSaveDir@@9@9		; `ClearSaveDir'::`1'::__LINE__Var
PUBLIC	??_C@_05HFINLBCI@save?1@			; `string'
PUBLIC	??_C@_07FBPDBPGN@?$CFs?$CK?4HL?$DP@		; `string'
PUBLIC	??_C@_0BL@KICGGNOK@Not?5playing?5a?5local?5game?4?6@ ; `string'
PUBLIC	??_C@_0BK@EFJOCHLD@Savegame?5is?5not?5allowed?4?6@ ; `string'
PUBLIC	??_C@_0BL@PCAKHPIK@Can?8t?5save?5if?5not?5active?4?6@ ; `string'
PUBLIC	??_C@_0CB@MHEJFOP@Can?8t?5save?5during?5intermission?4@ ; `string'
PUBLIC	??_C@_0BP@OJOGGEDC@Can?8t?5save?5multiplayer?5games?4?6@ ; `string'
PUBLIC	??_C@_0CC@LHOAAJLL@Can?8t?5savegame?5without?5a?5player@ ; `string'
PUBLIC	??_C@_0CD@KOPDJNFI@Can?8t?5savegame?5with?5a?5dead?5play@ ; `string'
PUBLIC	??_C@_0CC@DHONJFEF@Can?8t?5savegame?5without?5a?5client@ ; `string'
PUBLIC	??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@	; `string'
PUBLIC	??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@	; `string'
PUBLIC	??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@		; `string'
PUBLIC	??_C@_08GDJCFMPC@?$CFs?$CFs?4bmp@		; `string'
PUBLIC	??_C@_0L@KBOHAFJO@save?$CFi?$CFi?$CFi@		; `string'
PUBLIC	?__LINE__Var@?0??DirectoryCopy@@9@9		; `DirectoryCopy'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	?__LINE__Var@?0??SaveInit@@9@9			; `SaveInit'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SaveFinish@@9@9		; `SaveFinish'::`1'::__LINE__Var
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@		; `string'
PUBLIC	??_C@_08HMPAEBDL@?$CFs?$CFs?4HL1@		; `string'
PUBLIC	??_C@_0BJ@GCHLOBJE@Loading?5game?5from?5?$CFs?4?4?4?6@ ; `string'
PUBLIC	??_C@_0BL@EEJEIAEE@?$FO1Error?3?$FO7?5couldn?8t?5open?4?6@ ; `string'
PUBLIC	?__LINE__Var@?0??ParseSaveTables@@9@9		; `ParseSaveTables'::`1'::__LINE__Var
PUBLIC	??_C@_06EDLPBOBF@ETABLE@			; `string'
PUBLIC	??_C@_0M@CGJOCCBH@Save?5Header@			; `string'
PUBLIC	??_C@_09MPODFMIF@ADJACENCY@			; `string'
PUBLIC	??_C@_0L@LIJGAPPN@LIGHTSTYLE@			; `string'
PUBLIC	??_C@_08EOMGCDLJ@?$CFs?$CFs?4HL3@		; `string'
PUBLIC	?__LINE__Var@?0??RestoreDecal@@9@9		; `RestoreDecal'::`1'::__LINE__Var
PUBLIC	??_C@_0DL@NIPAKAPI@?$FO1Error?3?$FO7?5RestoreDecal?3?5couldn@ ; `string'
PUBLIC	?__LINE__Var@?0??SaveClientState@@9@9		; `SaveClientState'::`1'::__LINE__Var
PUBLIC	??_C@_0BH@JDHPMEGE@saveMusic?3?5onLoop?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0N@BBKGEOKF@ClientHeader@			; `string'
PUBLIC	??_C@_09OJOHKNIJ@DECALLIST@			; `string'
PUBLIC	??_C@_0N@BIODMPB@STATICENTITY@			; `string'
PUBLIC	??_C@_09BJHEHHKO@SOUNDLIST@			; `string'
PUBLIC	?__LINE__Var@?0??LoadClientState@@9@9		; `LoadClientState'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_0BK@DAEJBELJ@RestoreMusic?3?5onLoop?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_07HPJIJIBE@?5onloop@			; `string'
PUBLIC	??_C@_0CL@NAIDCDGI@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@ ; `string'
PUBLIC	??_C@_0CD@JJPJBDAA@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?5restor@ ; `string'
PUBLIC	??_C@_0O@IFEMIFOJ@sv_wateralpha@		; `string'
PUBLIC	??_C@_0M@COFDEJEF@sv_wateramp@			; `string'
PUBLIC	?__LINE__Var@?0??CreateEntitiesInRestoreList@@9@9 ; `CreateEntitiesInRestoreList'::`1'::__LINE__Var
PUBLIC	??_C@_0CH@BMENADOI@?$FO1Error?3?$FO7?5ENTITY?5IS?5NOT?5A?5PLAY@ ; `string'
PUBLIC	?__LINE__Var@?0??SaveGameState@@9@9		; `SaveGameState'::`1'::__LINE__Var
PUBLIC	??_C@_05ODMCMJAJ@skill@				; `string'
PUBLIC	??_C@_0L@NPFKENCH@sv_skyname@			; `string'
PUBLIC	??_C@_0O@CGCGGHO@sv_skycolor_r@			; `string'
PUBLIC	??_C@_0O@DFNHIAGK@sv_skycolor_g@		; `string'
PUBLIC	??_C@_0O@EIKAHECP@sv_skycolor_b@		; `string'
PUBLIC	??_C@_0M@JBBFCNJL@sv_skyvec_x@			; `string'
PUBLIC	??_C@_0M@IIAOBMNK@sv_skyvec_y@			; `string'
PUBLIC	??_C@_0M@KDCDEPBJ@sv_skyvec_z@			; `string'
PUBLIC	??_C@_0M@PCFOFDPA@sv_skydir_x@			; `string'
PUBLIC	??_C@_0M@OLEFGCLB@sv_skydir_y@			; `string'
PUBLIC	??_C@_0M@MAGIDBHC@sv_skydir_z@			; `string'
PUBLIC	??_C@_0M@KODFIOCL@sv_skyangle@			; `string'
PUBLIC	??_C@_0M@IDDIMGBN@sv_skyspeed@			; `string'
PUBLIC	??_C@_0L@MNHGMPM@GameHeader@			; `string'
PUBLIC	??_C@_05DFMHJABL@quick@				; `string'
PUBLIC	??_C@_08CCMFCJIM@autosave@			; `string'
PUBLIC	??_C@_0P@LOFLHDBJ@saveshot?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BG@GBCGIKFH@Saving?5game?5to?5?$CFs?4?4?4?6@ ; `string'
PUBLIC	?__LINE__Var@?0??CreateEntityTransitionList@@9@9 ; `CreateEntityTransitionList'::`1'::__LINE__Var
PUBLIC	??_C@_07BCNOFJKA@ENTVARS@			; `string'
PUBLIC	??_C@_0CA@BBKDNKFK@Merging?5changes?5for?5global?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BG@MAPDDIOO@Transferring?5?$CFs?5?$CI?$CFd?$CJ?6@ ; `string'
PUBLIC	??_C@_0BA@FBJOHKAB@Suppressing?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DM@BNDMNODN@Level?5transition?5ERROR?6Can?8t?5fi@ ; `string'
PUBLIC	??_C@_0BP@DMLDFIPP@?$FO1Error?3?$FO7?5server?5not?5running?6@ ; `string'
PUBLIC	??_C@_0CP@BJKGLKEH@?$FO1Error?3?$FO7?5map?5?$CFs?5is?5invalid?5or@ ; `string'
PUBLIC	??_C@_0CB@PJOLFLJM@?$FO1Error?3?$FO7?5map?5?$CFs?5doesn?8t?5exist@ ; `string'
PUBLIC	??_C@_0BN@GBANCDI@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?6@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0L@PCNFODNF@maxplayers@			; `string'
PUBLIC	??_C@_0L@ILDAINPG@deathmatch@			; `string'
PUBLIC	??_C@_04OILOBHMB@coop@				; `string'
PUBLIC	??_C@_03CLCAEGCJ@new@				; `string'
PUBLIC	??_C@_0CH@JBIKANLA@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5sa@ ; `string'
PUBLIC	??_C@_09OOPKIPAC@GAMESAVED@			; `string'
PUBLIC	?__LINE__Var@?0??SV_GetLatestSave@@9@9		; `SV_GetLatestSave'::`1'::__LINE__Var
PUBLIC	??_C@_07GHPHEBDC@?$CFs?$CK?4sav@		; `string'
PUBLIC	?__LINE__Var@?0??SV_GetSaveComment@@9@9		; `SV_GetSaveComment'::`1'::__LINE__Var
PUBLIC	??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@		; `string'
PUBLIC	??_C@_0CB@HLDIHCLB@old?5version?5Xash3D?5?$DMunsupported@ ; `string'
PUBLIC	??_C@_0O@BNPEDOPK@?$DMold?5version?$DO@		; `string'
PUBLIC	??_C@_0BC@FOOGBDOL@?$DMinvalid?5version?$DO@	; `string'
PUBLIC	??_C@_0BG@FNCJLPPA@?$DMcorrupted?5hashtable?$DO@ ; `string'
PUBLIC	??_C@_0BF@NHHNGGE@?$DMmissing?5GameHeader?$DO@	; `string'
PUBLIC	??_C@_0BM@FPHEPIAN@?$DMmap?5?$CFs?5has?5invalid?5format?$DO@ ; `string'
PUBLIC	??_C@_0BD@MBEBJCIG@?$DMmap?5?$CFs?5is?5missed?$DO@ ; `string'
PUBLIC	??_C@_07HFEHMCOC@?$FLquick?$FN@			; `string'
PUBLIC	??_C@_0L@DIKLKKMB@?$FLautosave?$FN@		; `string'
PUBLIC	??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@		; `string'
PUBLIC	??_C@_05JFBIHENH@?$CFH?3?$CFM@			; `string'
PUBLIC	??_C@_0BC@IIBLLBNK@?$DMunknown?5version?$DO@	; `string'
PUBLIC	??_C@_0BD@DIIDBMKG@SV_SaveGameComment@		; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f733333
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@437f0000
PUBLIC	__real@c0a00000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp__strftime:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_COM_FileWithoutPath:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_FS_Rename:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_FileCopy:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_CompareFileTime:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_LoadGame:PROC
EXTRN	_CL_Active:PROC
EXTRN	_pfnDecalIndex:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_IsIntermission:PROC
EXTRN	_SV_CreateDecal:PROC
EXTRN	_SV_RestoreCustomDecal:PROC
EXTRN	_R_CreateDecalList:PROC
EXTRN	_S_StreamGetCurrentState:PROC
EXTRN	_CL_HudMessage:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_GL_FreeImage:PROC
EXTRN	_fmod:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_SV_FinalMessage:PROC
EXTRN	_SV_InitGame:PROC
EXTRN	_SV_ActivateServer:PROC
EXTRN	_SV_SpawnServer:PROC
EXTRN	_SV_DeactivateServer:PROC
EXTRN	_SV_FreeOldEntities:PROC
EXTRN	_SV_InactivateClients:PROC
EXTRN	_SV_InitEdict:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_BuildSoundMsg:PROC
EXTRN	_SV_SpawnEntities:PROC
EXTRN	_SV_CreateNamedEntity:PROC
EXTRN	_SV_MakeString:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_MapIsValid:PROC
EXTRN	_SV_FindGlobalEntity:PROC
EXTRN	_SV_CreateStaticEntity:PROC
EXTRN	_pfnIndexOfEdict:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	_SV_SetLightStyle:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_S_GetCurrentDynamicSounds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_newunit:BYTE
EXTRN	_sv_wateralpha:BYTE
EXTRN	_sv_wateramp:BYTE
EXTRN	_sv_skyname:BYTE
EXTRN	_sv_skycolor_r:BYTE
EXTRN	_sv_skycolor_g:BYTE
EXTRN	_sv_skycolor_b:BYTE
EXTRN	_sv_skyvec_x:BYTE
EXTRN	_sv_skyvec_y:BYTE
EXTRN	_sv_skyvec_z:BYTE
EXTRN	_sv_skyspeed:BYTE
EXTRN	_sv_skyangle:BYTE
EXTRN	_sv_skydir_x:BYTE
EXTRN	_sv_skydir_y:BYTE
EXTRN	_sv_skydir_z:BYTE
EXTRN	_skill:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?savename@?1??SV_GetLatestSave@@9@9 DB 040H DUP (?)	; `SV_GetLatestSave'::`2'::savename
_BSS	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BD@DIIDBMKG@SV_SaveGameComment@
CONST	SEGMENT
??_C@_0BD@DIIDBMKG@SV_SaveGameComment@ DB 'SV_SaveGameComment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IIBLLBNK@?$DMunknown?5version?$DO@
CONST	SEGMENT
??_C@_0BC@IIBLLBNK@?$DMunknown?5version?$DO@ DB '<unknown version>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFBIHENH@?$CFH?3?$CFM@
CONST	SEGMENT
??_C@_05JFBIHENH@?$CFH?3?$CFM@ DB '%H:%M', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@
CONST	SEGMENT
??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@ DB '%b%d %Y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DIKLKKMB@?$FLautosave?$FN@
CONST	SEGMENT
??_C@_0L@DIKLKKMB@?$FLautosave?$FN@ DB '[autosave]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HFEHMCOC@?$FLquick?$FN@
CONST	SEGMENT
??_C@_07HFEHMCOC@?$FLquick?$FN@ DB '[quick]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MBEBJCIG@?$DMmap?5?$CFs?5is?5missed?$DO@
CONST	SEGMENT
??_C@_0BD@MBEBJCIG@?$DMmap?5?$CFs?5is?5missed?$DO@ DB '<map %s is missed>'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FPHEPIAN@?$DMmap?5?$CFs?5has?5invalid?5format?$DO@
CONST	SEGMENT
??_C@_0BM@FPHEPIAN@?$DMmap?5?$CFs?5has?5invalid?5format?$DO@ DB '<map %s '
	DB	'has invalid format>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NHHNGGE@?$DMmissing?5GameHeader?$DO@
CONST	SEGMENT
??_C@_0BF@NHHNGGE@?$DMmissing?5GameHeader?$DO@ DB '<missing GameHeader>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FNCJLPPA@?$DMcorrupted?5hashtable?$DO@
CONST	SEGMENT
??_C@_0BG@FNCJLPPA@?$DMcorrupted?5hashtable?$DO@ DB '<corrupted hashtable'
	DB	'>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FOOGBDOL@?$DMinvalid?5version?$DO@
CONST	SEGMENT
??_C@_0BC@FOOGBDOL@?$DMinvalid?5version?$DO@ DB '<invalid version>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNPEDOPK@?$DMold?5version?$DO@
CONST	SEGMENT
??_C@_0O@BNPEDOPK@?$DMold?5version?$DO@ DB '<old version>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HLDIHCLB@old?5version?5Xash3D?5?$DMunsupported@
CONST	SEGMENT
??_C@_0CB@HLDIHCLB@old?5version?5Xash3D?5?$DMunsupported@ DB 'old version'
	DB	' Xash3D <unsupported>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@
CONST	SEGMENT
??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@ DB '<corrupted>', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_GetSaveComment@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_GetSaveComment@@9@9 DD 08a1H	; `SV_GetSaveComment'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07GHPHEBDC@?$CFs?$CK?4sav@
CONST	SEGMENT
??_C@_07GHPHEBDC@?$CFs?$CK?4sav@ DB '%s*.sav', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_GetLatestSave@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_GetLatestSave@@9@9 DD 0878H		; `SV_GetLatestSave'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09OOPKIPAC@GAMESAVED@
CONST	SEGMENT
??_C@_09OOPKIPAC@GAMESAVED@ DB 'GAMESAVED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JBIKANLA@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5sa@
CONST	SEGMENT
??_C@_0CH@JBIKANLA@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5sa@ DB '^1Err'
	DB	'or:^7 no free slots for savegame', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLCAEGCJ@new@
CONST	SEGMENT
??_C@_03CLCAEGCJ@new@ DB 'new', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OILOBHMB@coop@
CONST	SEGMENT
??_C@_04OILOBHMB@coop@ DB 'coop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILDAINPG@deathmatch@
CONST	SEGMENT
??_C@_0L@ILDAINPG@deathmatch@ DB 'deathmatch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCNFODNF@maxplayers@
CONST	SEGMENT
??_C@_0L@PCNFODNF@maxplayers@ DB 'maxplayers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GBANCDI@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?6@
CONST	SEGMENT
??_C@_0BN@GBANCDI@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?6@ DB '^1Erro'
	DB	'r:^7 Couldn''t load %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJOLFLJM@?$FO1Error?3?$FO7?5map?5?$CFs?5doesn?8t?5exist@
CONST	SEGMENT
??_C@_0CB@PJOLFLJM@?$FO1Error?3?$FO7?5map?5?$CFs?5doesn?8t?5exist@ DB '^1'
	DB	'Error:^7 map %s doesn''t exist', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BJKGLKEH@?$FO1Error?3?$FO7?5map?5?$CFs?5is?5invalid?5or@
CONST	SEGMENT
??_C@_0CP@BJKGLKEH@?$FO1Error?3?$FO7?5map?5?$CFs?5is?5invalid?5or@ DB '^1'
	DB	'Error:^7 map %s is invalid or not supported', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMLDFIPP@?$FO1Error?3?$FO7?5server?5not?5running?6@
CONST	SEGMENT
??_C@_0BP@DMLDFIPP@?$FO1Error?3?$FO7?5server?5not?5running?6@ DB '^1Error'
	DB	':^7 server not running', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BNDMNODN@Level?5transition?5ERROR?6Can?8t?5fi@
CONST	SEGMENT
??_C@_0DM@BNDMNODN@Level?5transition?5ERROR?6Can?8t?5fi@ DB 'Level transi'
	DB	'tion ERROR', 0aH, 'Can''t find connection to %s from %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FBJOHKAB@Suppressing?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@FBJOHKAB@Suppressing?5?$CFs?6@ DB 'Suppressing %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAPDDIOO@Transferring?5?$CFs?5?$CI?$CFd?$CJ?6@
CONST	SEGMENT
??_C@_0BG@MAPDDIOO@Transferring?5?$CFs?5?$CI?$CFd?$CJ?6@ DB 'Transferring'
	DB	' %s (%d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BBKDNKFK@Merging?5changes?5for?5global?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0CA@BBKDNKFK@Merging?5changes?5for?5global?3?5?$CFs?6@ DB 'Merging '
	DB	'changes for global: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCNOFJKA@ENTVARS@
CONST	SEGMENT
??_C@_07BCNOFJKA@ENTVARS@ DB 'ENTVARS', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CreateEntityTransitionList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CreateEntityTransitionList@@9@9 DD 06edH ; `CreateEntityTransitionList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@GBCGIKFH@Saving?5game?5to?5?$CFs?4?4?4?6@
CONST	SEGMENT
??_C@_0BG@GBCGIKFH@Saving?5game?5to?5?$CFs?4?4?4?6@ DB 'Saving game to %s'
	DB	'...', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LOFLHDBJ@saveshot?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@LOFLHDBJ@saveshot?5?$CC?$CFs?$CC?6@ DB 'saveshot "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCMFCJIM@autosave@
CONST	SEGMENT
??_C@_08CCMFCJIM@autosave@ DB 'autosave', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFMHJABL@quick@
CONST	SEGMENT
??_C@_05DFMHJABL@quick@ DB 'quick', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNHGMPM@GameHeader@
CONST	SEGMENT
??_C@_0L@MNHGMPM@GameHeader@ DB 'GameHeader', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDDIMGBN@sv_skyspeed@
CONST	SEGMENT
??_C@_0M@IDDIMGBN@sv_skyspeed@ DB 'sv_skyspeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KODFIOCL@sv_skyangle@
CONST	SEGMENT
??_C@_0M@KODFIOCL@sv_skyangle@ DB 'sv_skyangle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MAGIDBHC@sv_skydir_z@
CONST	SEGMENT
??_C@_0M@MAGIDBHC@sv_skydir_z@ DB 'sv_skydir_z', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OLEFGCLB@sv_skydir_y@
CONST	SEGMENT
??_C@_0M@OLEFGCLB@sv_skydir_y@ DB 'sv_skydir_y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCFOFDPA@sv_skydir_x@
CONST	SEGMENT
??_C@_0M@PCFOFDPA@sv_skydir_x@ DB 'sv_skydir_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KDCDEPBJ@sv_skyvec_z@
CONST	SEGMENT
??_C@_0M@KDCDEPBJ@sv_skyvec_z@ DB 'sv_skyvec_z', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIAOBMNK@sv_skyvec_y@
CONST	SEGMENT
??_C@_0M@IIAOBMNK@sv_skyvec_y@ DB 'sv_skyvec_y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBBFCNJL@sv_skyvec_x@
CONST	SEGMENT
??_C@_0M@JBBFCNJL@sv_skyvec_x@ DB 'sv_skyvec_x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EIKAHECP@sv_skycolor_b@
CONST	SEGMENT
??_C@_0O@EIKAHECP@sv_skycolor_b@ DB 'sv_skycolor_b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFNHIAGK@sv_skycolor_g@
CONST	SEGMENT
??_C@_0O@DFNHIAGK@sv_skycolor_g@ DB 'sv_skycolor_g', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGCGGHO@sv_skycolor_r@
CONST	SEGMENT
??_C@_0O@CGCGGHO@sv_skycolor_r@ DB 'sv_skycolor_r', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPFKENCH@sv_skyname@
CONST	SEGMENT
??_C@_0L@NPFKENCH@sv_skyname@ DB 'sv_skyname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODMCMJAJ@skill@
CONST	SEGMENT
??_C@_05ODMCMJAJ@skill@ DB 'skill', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SaveGameState@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SaveGameState@@9@9 DD 0581H		; `SaveGameState'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@BMENADOI@?$FO1Error?3?$FO7?5ENTITY?5IS?5NOT?5A?5PLAY@
CONST	SEGMENT
??_C@_0CH@BMENADOI@?$FO1Error?3?$FO7?5ENTITY?5IS?5NOT?5A?5PLAY@ DB '^1Err'
	DB	'or:^7 ENTITY IS NOT A PLAYER: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CreateEntitiesInRestoreList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CreateEntitiesInRestoreList@@9@9 DD 0546H ; `CreateEntitiesInRestoreList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@COFDEJEF@sv_wateramp@
CONST	SEGMENT
??_C@_0M@COFDEJEF@sv_wateramp@ DB 'sv_wateramp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFEMIFOJ@sv_wateralpha@
CONST	SEGMENT
??_C@_0O@IFEMIFOJ@sv_wateralpha@ DB 'sv_wateralpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JJPJBDAA@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?5restor@
CONST	SEGMENT
??_C@_0CD@JJPJBDAA@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?5restor@ DB 'm'
	DB	'usic "%s" "%s" pos %i%s restored', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NAIDCDGI@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@
CONST	SEGMENT
??_C@_0CL@NAIDCDGI@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@ DB 'm'
	DB	'usic "%s" "%s" loop %d pos %i%s restored', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPJIJIBE@?5onloop@
CONST	SEGMENT
??_C@_07HPJIJIBE@?5onloop@ DB ' onloop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DAEJBELJ@RestoreMusic?3?5onLoop?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BK@DAEJBELJ@RestoreMusic?3?5onLoop?3?5?$CFd?6@ DB 'RestoreMusic: o'
	DB	'nLoop: %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??LoadClientState@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??LoadClientState@@9@9 DD 04ccH		; `LoadClientState'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09BJHEHHKO@SOUNDLIST@
CONST	SEGMENT
??_C@_09BJHEHHKO@SOUNDLIST@ DB 'SOUNDLIST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIODMPB@STATICENTITY@
CONST	SEGMENT
??_C@_0N@BIODMPB@STATICENTITY@ DB 'STATICENTITY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJOHKNIJ@DECALLIST@
CONST	SEGMENT
??_C@_09OJOHKNIJ@DECALLIST@ DB 'DECALLIST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBKGEOKF@ClientHeader@
CONST	SEGMENT
??_C@_0N@BBKGEOKF@ClientHeader@ DB 'ClientHeader', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDHPMEGE@saveMusic?3?5onLoop?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BH@JDHPMEGE@saveMusic?3?5onLoop?3?5?$CFd?6@ DB 'saveMusic: onLoop:'
	DB	' %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SaveClientState@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SaveClientState@@9@9 DD 046fH		; `SaveClientState'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DL@NIPAKAPI@?$FO1Error?3?$FO7?5RestoreDecal?3?5couldn@
CONST	SEGMENT
??_C@_0DL@NIPAKAPI@?$FO1Error?3?$FO7?5RestoreDecal?3?5couldn@ DB '^1Error'
	DB	':^7 RestoreDecal: couldn''t restore entity index %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??RestoreDecal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??RestoreDecal@@9@9 DD 040aH		; `RestoreDecal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08EOMGCDLJ@?$CFs?$CFs?4HL3@
CONST	SEGMENT
??_C@_08EOMGCDLJ@?$CFs?$CFs?4HL3@ DB '%s%s.HL3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIJGAPPN@LIGHTSTYLE@
CONST	SEGMENT
??_C@_0L@LIJGAPPN@LIGHTSTYLE@ DB 'LIGHTSTYLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MPODFMIF@ADJACENCY@
CONST	SEGMENT
??_C@_09MPODFMIF@ADJACENCY@ DB 'ADJACENCY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGJOCCBH@Save?5Header@
CONST	SEGMENT
??_C@_0M@CGJOCCBH@Save?5Header@ DB 'Save Header', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDLPBOBF@ETABLE@
CONST	SEGMENT
??_C@_06EDLPBOBF@ETABLE@ DB 'ETABLE', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ParseSaveTables@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??ParseSaveTables@@9@9 DD 0393H		; `ParseSaveTables'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@EEJEIAEE@?$FO1Error?3?$FO7?5couldn?8t?5open?4?6@
CONST	SEGMENT
??_C@_0BL@EEJEIAEE@?$FO1Error?3?$FO7?5couldn?8t?5open?4?6@ DB '^1Error:^7'
	DB	' couldn''t open.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHLOBJE@Loading?5game?5from?5?$CFs?4?4?4?6@
CONST	SEGMENT
??_C@_0BJ@GCHLOBJE@Loading?5game?5from?5?$CFs?4?4?4?6@ DB 'Loading game f'
	DB	'rom %s...', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMPAEBDL@?$CFs?$CFs?4HL1@
CONST	SEGMENT
??_C@_08HMPAEBDL@?$CFs?$CFs?4HL1@ DB '%s%s.HL1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
CONST	SEGMENT
??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@ DB '%s%s.HL2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SaveFinish@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SaveFinish@@9@9 DD 02acH		; `SaveFinish'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SaveInit@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SaveInit@@9@9 DD 027cH			; `SaveInit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DirectoryCopy@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??DirectoryCopy@@9@9 DD 0240H		; `DirectoryCopy'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@KBOHAFJO@save?$CFi?$CFi?$CFi@
CONST	SEGMENT
??_C@_0L@KBOHAFJO@save?$CFi?$CFi?$CFi@ DB 'save%i%i%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDJCFMPC@?$CFs?$CFs?4bmp@
CONST	SEGMENT
??_C@_08GDJCFMPC@?$CFs?$CFs?4bmp@ DB '%s%s.bmp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@
CONST	SEGMENT
??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@ DB '%s%s.sav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@
CONST	SEGMENT
??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@ DB '%s%s%02d.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@
CONST	SEGMENT
??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@ DB '%s%s%02d.sav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DHONJFEF@Can?8t?5savegame?5without?5a?5client@
CONST	SEGMENT
??_C@_0CC@DHONJFEF@Can?8t?5savegame?5without?5a?5client@ DB 'Can''t saveg'
	DB	'ame without a client!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KOPDJNFI@Can?8t?5savegame?5with?5a?5dead?5play@
CONST	SEGMENT
??_C@_0CD@KOPDJNFI@Can?8t?5savegame?5with?5a?5dead?5play@ DB 'Can''t save'
	DB	'game with a dead player', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LHOAAJLL@Can?8t?5savegame?5without?5a?5player@
CONST	SEGMENT
??_C@_0CC@LHOAAJLL@Can?8t?5savegame?5without?5a?5player@ DB 'Can''t saveg'
	DB	'ame without a player!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OJOGGEDC@Can?8t?5save?5multiplayer?5games?4?6@
CONST	SEGMENT
??_C@_0BP@OJOGGEDC@Can?8t?5save?5multiplayer?5games?4?6@ DB 'Can''t save '
	DB	'multiplayer games.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MHEJFOP@Can?8t?5save?5during?5intermission?4@
CONST	SEGMENT
??_C@_0CB@MHEJFOP@Can?8t?5save?5during?5intermission?4@ DB 'Can''t save d'
	DB	'uring intermission.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PCAKHPIK@Can?8t?5save?5if?5not?5active?4?6@
CONST	SEGMENT
??_C@_0BL@PCAKHPIK@Can?8t?5save?5if?5not?5active?4?6@ DB 'Can''t save if '
	DB	'not active.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EFJOCHLD@Savegame?5is?5not?5allowed?4?6@
CONST	SEGMENT
??_C@_0BK@EFJOCHLD@Savegame?5is?5not?5allowed?4?6@ DB 'Savegame is not al'
	DB	'lowed.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KICGGNOK@Not?5playing?5a?5local?5game?4?6@
CONST	SEGMENT
??_C@_0BL@KICGGNOK@Not?5playing?5a?5local?5game?4?6@ DB 'Not playing a lo'
	DB	'cal game.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBPDBPGN@?$CFs?$CK?4HL?$DP@
CONST	SEGMENT
??_C@_07FBPDBPGN@?$CFs?$CK?4HL?$DP@ DB '%s*.HL?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFINLBCI@save?1@
CONST	SEGMENT
??_C@_05HFINLBCI@save?1@ DB 'save/', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??ClearSaveDir@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??ClearSaveDir@@9@9 DD 0199H		; `ClearSaveDir'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??EntityInSolid@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??EntityInSolid@@9@9 DD 0182H		; `EntityInSolid'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??InitEntityTable@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??InitEntityTable@@9@9 DD 012cH		; `InitEntityTable'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_save.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??DirectoryCount@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??DirectoryCount@@9@9 DD 0117H		; `DirectoryCount'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@EJBAAKHO@?$CF?964?464s?5?$CF02d?3?$CF02d@
CONST	SEGMENT
??_C@_0BD@EJBAAKHO@?$CF?964?464s?5?$CF02d?3?$CF02d@ DB '%-64.64s %02d:%02'
	DB	'd', 00H					; `string'
CONST	ENDS
_DATA	SEGMENT
_gGameHeader DD	0fH
	DD	FLAT:??_C@_07MLAMGOLD@mapName@
	DD	00H
	DW	020H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_07GJGNEJFD@comment@
	DD	020H
	DW	050H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08IDKGGPIE@mapCount@
	DD	070H
	DW	01H
	DW	00H
_gSaveHeader DD	0aH
	DD	FLAT:??_C@_0L@BGFMBPG@skillLevel@
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0M@KPKEBFBB@entityCount@
	DD	04H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@MFJKOJFN@connectionCount@
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@PIKGIBOP@lightStyleCount@
	DD	0cH
	DW	01H
	DW	00H
	DD	010H
	DD	FLAT:??_C@_04CLCEDBPF@time@
	DD	010H
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_07MLAMGOLD@mapName@
	DD	014H
	DW	020H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_07CBECEDCM@skyName@
	DD	034H
	DW	020H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@IDNIDMLJ@skyColor_r@
	DD	054H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@LEGNNKKN@skyColor_g@
	DD	058H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@MJBKCOOI@skyColor_b@
	DD	05cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08GDJOMBN@skyVec_x@
	DD	060H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08BPCCNNFM@skyVec_y@
	DD	064H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08DEAPIOJP@skyVec_z@
	DD	068H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08GFHCJCHG@skyDir_x@
	DD	06cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08HMGJKDDH@skyDir_y@
	DD	070H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08FHEEPAPE@skyDir_z@
	DD	074H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08DJBJEPKN@skyAngle@
	DD	078H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08BEBEAHJL@skySpeed@
	DD	07cH
	DW	01H
	DW	00H
_gAdjacency DD	0fH
	DD	FLAT:??_C@_07MLAMGOLD@mapName@
	DD	00H
	DW	020H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_0N@JJOOKKBJ@landmarkName@
	DD	020H
	DW	020H
	DW	00H
	DD	06H
	DD	FLAT:??_C@_0N@FIMBEBDH@pentLandmark@
	DD	040H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_0BC@FBMIBEC@vecLandmarkOrigin@
	DD	044H
	DW	01H
	DW	00H
_gLightStyle DD	0aH
	DD	FLAT:??_C@_05FKHKFDID@index@
	DD	00H
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_05IAKJCFIM@style@
	DD	04H
	DW	0100H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_04CLCEDBPF@time@
	DD	0104H
	DW	01H
	DW	00H
_gEntityTable DD 0aH
	DD	FLAT:??_C@_02EGCJHIOB@id@
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08CBBFJFMD@location@
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_04IAGNFIBA@size@
	DD	0cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_05GECEPKB@flags@
	DD	010H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_09CNJINBGN@classname@
	DD	014H
	DW	01H
	DW	00H
_gSaveClient DD	0aH
	DD	FLAT:??_C@_0L@LBFHMNGA@decalCount@
	DD	00H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0M@KPKEBFBB@entityCount@
	DD	04H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@BEKNOLNB@soundCount@
	DD	08H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0O@FIHJLNBI@tempEntsCount@
	DD	0cH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_0L@BFAEEEGI@introTrack@
	DD	010H
	DW	040H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_09DMFGKPLL@mainTrack@
	DD	050H
	DW	040H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0O@CPICAPIH@trackPosition@
	DD	090H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_07JJLFGEHB@loopNum@
	DD	094H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_06LPGBNFFB@onLoop@
	DD	098H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:??_C@_0L@BDHFFEKG@viewentity@
	DD	09cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_0L@PNIALNHI@wateralpha@
	DD	0a0H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_08LONDINPF@wateramp@
	DD	0a4H
	DW	01H
	DW	00H
_gDecalEntry DD	07H
	DD	FLAT:??_C@_08OAGMDKAF@position@
	DD	00H
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_04MEMAJGDJ@name@
	DD	0cH
	DW	040H
	DW	00H
	DD	0eH
	DD	FLAT:??_C@_0M@HLBKIPNA@entityIndex@
	DD	04cH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_05BJGJGKJC@depth@
	DD	04eH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_05GECEPKB@flags@
	DD	04fH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_05MHMEBBGO@scale@
	DD	050H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_0BC@DLIKOKND@impactPlaneNormal@
	DD	054H
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_0N@OCBKKDNJ@studio_state@
	DD	060H
	DW	028H
	DW	00H
_gStaticEntry DD 011H
	DD	FLAT:??_C@_0L@ODHFIMJE@messagenum@
	DD	0cH
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06NHCMNMEH@origin@
	DD	010H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06GNEAMJOC@angles@
	DD	01cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08IBBDGPOF@sequence@
	DD	02cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_05MIJNFGED@frame@
	DD	030H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08OMBDDLKJ@colormap@
	DD	034H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:??_C@_04NHPAFEHJ@skin@
	DD	088H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_04IEJGKNJ@body@
	DD	078H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_05MHMEBBGO@scale@
	DD	040H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_07BLLGFBLI@effects@
	DD	03cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_09PLDKGHKD@framerate@
	DD	060H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_04FIAKMPII@mins@
	DD	0a4H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_04IFBFDIKF@maxs@
	DD	0b0H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@PCPPJFN@rendermode@
	DD	048H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_09BBEIIFBJ@renderamt@
	DD	04cH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_0M@PKPFNFIN@rendercolor@
	DD	050H
	DW	03H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08CMBMAAGP@renderfx@
	DD	054H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_0L@DNGLJIEO@controller@
	DD	064H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08EFDOIIKB@blending@
	DD	068H
	DW	01H
	DW	00H
	DD	0eH
	DD	FLAT:??_C@_05OPIONHBI@solid@
	DD	038H
	DW	01H
	DW	00H
	DD	010H
	DD	FLAT:??_C@_08CPDCOAJK@animtime@
	DD	05cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_08DMIOBKOG@movetype@
	DD	058H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06JFGGHPEA@vuser1@
	DD	0194H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06LOELCMID@vuser2@
	DD	01a0H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06KHFABNMC@vuser3@
	DD	01acH
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06OIBBILAF@vuser4@
	DD	01b8H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_06EPAJDGH@iuser1@
	DD	0174H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_06CPNNMAKE@iuser2@
	DD	0178H
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_06DGMGPBOF@iuser3@
	DD	017cH
	DW	01H
	DW	00H
	DD	0aH
	DD	FLAT:??_C@_06HJIHGHCC@iuser4@
	DD	0180H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_06PCLIODIO@fuser1@
	DD	0184H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_06NJJFLAEN@fuser2@
	DD	0188H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_06MAIOIBAM@fuser3@
	DD	018cH
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_06IPMPBHML@fuser4@
	DD	0190H
	DW	01H
	DW	00H
_gSoundEntry DD	0fH
	DD	FLAT:??_C@_04MEMAJGDJ@name@
	DD	00H
	DW	040H
	DW	00H
	DD	0eH
	DD	FLAT:??_C@_06NMCBFEIH@entnum@
	DD	040H
	DW	01H
	DW	00H
	DD	07H
	DD	FLAT:??_C@_06NHCMNMEH@origin@
	DD	044H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_06EMCPHFGM@volume@
	DD	050H
	DW	01H
	DW	00H
	DD	00H
	DD	FLAT:??_C@_0M@NKGAHMMH@attenuation@
	DD	054H
	DW	01H
	DW	00H
	DD	0dH
	DD	FLAT:??_C@_07EOMMFHON@looping@
	DD	058H
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_07MFOHDNMP@channel@
	DD	05cH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_05NCNFOFLM@pitch@
	DD	05dH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_09JFNLBOP@wordIndex@
	DD	05eH
	DW	01H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_09EPOFMHCC@samplePos@
	DD	060H
	DW	08H
	DW	00H
	DD	0fH
	DD	FLAT:??_C@_09MMOEMCLM@forcedEnd@
	DD	068H
	DW	08H
	DW	00H
_gTempEntvars DD 01H
	DD	FLAT:??_C@_09CNJINBGN@classname@
	DD	00H
	DW	01H
	DW	00H
	DD	01H
	DD	FLAT:??_C@_0L@JILCNGEO@globalname@
	DD	04H
	DW	01H
	DW	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0417H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0289H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02e3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02d1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0558H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05a9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0513H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0485H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0248H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	023dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0167H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01cfH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	016dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0189H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	014eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	06eaH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _LoadAdjacentEnts
_TEXT	SEGMENT
tv174 = -1828						; size = 4
_landmarkOrigin$ = -1568				; size = 12
_foundprevious$ = -1556					; size = 4
_movedCount$ = -1552					; size = 4
_index$ = -1548						; size = 4
_flags$ = -1544						; size = 4
_test$ = -1540						; size = 4
_i$ = -1536						; size = 4
_pSaveData$ = -1532					; size = 4
_currentLevelData$ = -1528				; size = 1396
_header$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_pOldLevel$ = 8						; size = 4
_pLandmarkName$ = 12					; size = 4
_LoadAdjacentEnts PROC					; COMDAT

; 1868 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1828				; 00000724H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1869 : 	SAVE_HEADER	header;
; 1870 : 	SAVERESTOREDATA	currentLevelData, *pSaveData;
; 1871 : 	int		i, test, flags, index, movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0

; 1872 : 	qboolean		foundprevious = false;

	mov	DWORD PTR _foundprevious$[ebp], 0

; 1873 : 	vec3_t		landmarkOrigin;
; 1874 : 	
; 1875 : 	memset( &currentLevelData, 0, sizeof( SAVERESTOREDATA ));

	push	1396					; 00000574H
	push	0
	lea	eax, DWORD PTR _currentLevelData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1876 : 	svgame.globals->pSaveData = &currentLevelData;

	mov	eax, DWORD PTR _svgame+19268
	lea	ecx, DWORD PTR _currentLevelData$[ebp]
	mov	DWORD PTR [eax+160], ecx

; 1877 : 	sv.loadgame = sv.paused = true;

	mov	DWORD PTR _sv+2595656, 1
	mov	eax, DWORD PTR _sv+2595656
	mov	DWORD PTR _sv+8, eax

; 1878 : 
; 1879 : 	// build the adjacent map list
; 1880 : 	svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19380

; 1881 : 
; 1882 : 	for( i = 0; i < currentLevelData.connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadAdjace
$LN2@LoadAdjace:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LoadAdjace:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _currentLevelData$[ebp+36]
	jge	$LN3@LoadAdjace

; 1883 : 	{
; 1884 : 		// make sure the previous level is in the connection list so we can
; 1885 : 		// bring over the player.
; 1886 : 		if( !Q_stricmp( currentLevelData.levelList[i].mapName, pOldLevel ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pOldLevel$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@LoadAdjace

; 1887 : 			foundprevious = true;

	mov	DWORD PTR _foundprevious$[ebp], 1
$LN10@LoadAdjace:

; 1888 : 
; 1889 : 		for( test = 0; test < i; test++ )

	mov	DWORD PTR _test$[ebp], 0
	jmp	SHORT $LN7@LoadAdjace
$LN5@LoadAdjace:
	mov	eax, DWORD PTR _test$[ebp]
	add	eax, 1
	mov	DWORD PTR _test$[ebp], eax
$LN7@LoadAdjace:
	mov	eax, DWORD PTR _test$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN6@LoadAdjace

; 1890 : 		{
; 1891 : 			// only do maps once
; 1892 : 			if( !Q_stricmp( currentLevelData.levelList[i].mapName, currentLevelData.levelList[test].mapName ))

	push	99999					; 0001869fH
	imul	eax, DWORD PTR _test$[ebp], 80
	lea	ecx, DWORD PTR _currentLevelData$[ebp+eax+44]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	lea	eax, DWORD PTR _currentLevelData$[ebp+edx+44]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@LoadAdjace

; 1893 : 				break;

	jmp	SHORT $LN6@LoadAdjace
$LN11@LoadAdjace:

; 1894 : 		}

	jmp	SHORT $LN5@LoadAdjace
$LN6@LoadAdjace:

; 1895 : 
; 1896 : 		// map was already in the list
; 1897 : 		if( test < i ) continue;

	mov	eax, DWORD PTR _test$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN12@LoadAdjace
	jmp	$LN2@LoadAdjace
$LN12@LoadAdjace:

; 1898 : 
; 1899 : 		pSaveData = LoadSaveData( currentLevelData.levelList[i].mapName );

	imul	eax, DWORD PTR _i$[ebp], 80
	lea	ecx, DWORD PTR _currentLevelData$[ebp+eax+44]
	push	ecx
	call	_LoadSaveData
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1900 : 
; 1901 : 		if( pSaveData )

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	$LN13@LoadAdjace

; 1902 : 		{
; 1903 : 			ParseSaveTables( pSaveData, &header, false );

	push	0
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_ParseSaveTables
	add	esp, 12					; 0000000cH

; 1904 : 			EntityPatchRead( pSaveData, currentLevelData.levelList[i].mapName );

	imul	eax, DWORD PTR _i$[ebp], 80
	lea	ecx, DWORD PTR _currentLevelData$[ebp+eax+44]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EntityPatchRead
	add	esp, 8

; 1905 : 
; 1906 : 			pSaveData->time = sv.time; // - header.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [eax+1360], xmm0

; 1907 : 			pSaveData->fUseLandmark = true;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+1324], 1

; 1908 : 			flags = movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0
	mov	eax, DWORD PTR _movedCount$[ebp]
	mov	DWORD PTR _flags$[ebp], eax

; 1909 : 			index = -1;

	mov	DWORD PTR _index$[ebp], -1

; 1910 : 
; 1911 : 			// calculate landmark offset
; 1912 : 			LandmarkOrigin( &currentLevelData, landmarkOrigin, pLandmarkName );

	mov	eax, DWORD PTR _pLandmarkName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _landmarkOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _currentLevelData$[ebp]
	push	edx
	call	_LandmarkOrigin
	add	esp, 12					; 0000000cH

; 1913 : 			LandmarkOrigin( pSaveData, pSaveData->vecLandmarkOffset, pLandmarkName );

	mov	eax, DWORD PTR _pLandmarkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1348				; 00000544H
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_LandmarkOrigin
	add	esp, 12					; 0000000cH

; 1914 : 			VectorSubtract( landmarkOrigin, pSaveData->vecLandmarkOffset, pSaveData->vecLandmarkOffset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+1348]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [edx+ecx+1348], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+1348]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	DWORD PTR [ecx+eax+1348], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _landmarkOrigin$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+1348]
	movss	DWORD PTR tv174[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR [eax+edx+1348], xmm0

; 1915 : 
; 1916 : 			if( !Q_stricmp( currentLevelData.levelList[i].mapName, pOldLevel ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pOldLevel$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	lea	edx, DWORD PTR _currentLevelData$[ebp+ecx+44]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@LoadAdjace

; 1917 : 				SetBits( flags, FENTTABLE_PLAYER );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, -2147483648			; 80000000H
	mov	DWORD PTR _flags$[ebp], eax
$LN14@LoadAdjace:

; 1918 : 
; 1919 : 			while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@LoadAdjace

; 1920 : 			{
; 1921 : 				index = EntryInTable( pSaveData, sv.name, index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	push	OFFSET _sv+56
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_EntryInTable
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _index$[ebp], eax

; 1922 : 				if( index < 0 ) break;

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $LN15@LoadAdjace
	jmp	SHORT $LN9@LoadAdjace
$LN15@LoadAdjace:

; 1923 : 				SetBits( flags, BIT( index ));

	mov	eax, 1
	mov	ecx, DWORD PTR _index$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _flags$[ebp], eax

; 1924 : 			}

	jmp	SHORT $LN14@LoadAdjace
$LN9@LoadAdjace:

; 1925 : 
; 1926 : 			if( flags ) movedCount = CreateEntityTransitionList( pSaveData, flags );

	cmp	DWORD PTR _flags$[ebp], 0
	je	SHORT $LN16@LoadAdjace
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_CreateEntityTransitionList
	add	esp, 8
	mov	DWORD PTR _movedCount$[ebp], eax
$LN16@LoadAdjace:

; 1927 : 
; 1928 : 			// if ents were moved, rewrite entity table to save file
; 1929 : 			if( movedCount ) EntityPatchWrite( pSaveData, currentLevelData.levelList[i].mapName );

	cmp	DWORD PTR _movedCount$[ebp], 0
	je	SHORT $LN17@LoadAdjace
	imul	eax, DWORD PTR _i$[ebp], 80
	lea	ecx, DWORD PTR _currentLevelData$[ebp+eax+44]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EntityPatchWrite
	add	esp, 8
$LN17@LoadAdjace:

; 1930 : 
; 1931 : 			// move the decals from another level
; 1932 : 			LoadClientState( pSaveData, currentLevelData.levelList[i].mapName, true, true );

	push	1
	push	1
	imul	eax, DWORD PTR _i$[ebp], 80
	lea	ecx, DWORD PTR _currentLevelData$[ebp+eax+44]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_LoadClientState
	add	esp, 16					; 00000010H

; 1933 : 
; 1934 : 			SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4
$LN13@LoadAdjace:

; 1935 : 		}
; 1936 : 	}

	jmp	$LN2@LoadAdjace
$LN3@LoadAdjace:

; 1937 : 
; 1938 : 	svgame.globals->pSaveData = NULL;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+160], 0

; 1939 : 
; 1940 : 	if( !foundprevious )

	cmp	DWORD PTR _foundprevious$[ebp], 0
	jne	SHORT $LN18@LoadAdjace

; 1941 : 		Host_Error( "Level transition ERROR\nCan't find connection to %s from %s\n", pOldLevel, sv.name );

	push	OFFSET _sv+56
	mov	eax, DWORD PTR _pOldLevel$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@BNDMNODN@Level?5transition?5ERROR?6Can?8t?5fi@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN18@LoadAdjace:

; 1942 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadAdjacentEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _CreateEntityTransitionList
_TEXT	SEGMENT
_pNewEnt$1 = -796					; size = 4
_tmpVars$2 = -792					; size = 772
_pent$ = -20						; size = 4
_pTable$ = -16						; size = 4
_movedCount$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_levelMask$ = 12					; size = 4
_CreateEntityTransitionList PROC			; COMDAT

; 1773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 924				; 0000039cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1774 : 	int		i, movedCount;
; 1775 : 	ENTITYTABLE	*pTable;
; 1776 : 	edict_t		*pent;
; 1777 : 
; 1778 : 	movedCount = 0;

	mov	DWORD PTR _movedCount$[ebp], 0

; 1779 : 
; 1780 : 	// create entity list
; 1781 : 	CreateEntitiesInRestoreList( pSaveData, levelMask, false );

	push	0
	mov	eax, DWORD PTR _levelMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_CreateEntitiesInRestoreList
	add	esp, 12					; 0000000cH

; 1782 : 
; 1783 : 	// now spawn entities
; 1784 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CreateEnti
$LN2@CreateEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CreateEnti:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN3@CreateEnti

; 1785 : 	{
; 1786 : 		pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 1787 : 		pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pTable$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1788 : 		pSaveData->size = pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1789 : 		pSaveData->currentIndex = i;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1790 : 		pent = pTable->pent;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pent$[ebp], ecx

; 1791 : 
; 1792 : 		if( SV_IsValidEdict( pent ) && FBitSet( pTable->flags, levelMask )) // screen out the player if he's not to be spawned

	mov	eax, DWORD PTR ?__LINE__Var@?0??CreateEntityTransitionList@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@CreateEnti
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, DWORD PTR _levelMask$[ebp]
	je	$LN5@CreateEnti

; 1793 : 		{
; 1794 : 			if( FBitSet( pTable->flags, FENTTABLE_GLOBAL ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 268435456				; 10000000H
	je	$LN6@CreateEnti

; 1795 : 			{
; 1796 : 				entvars_t	tmpVars;
; 1797 : 				edict_t	*pNewEnt;
; 1798 : 
; 1799 : 				// NOTE: we need to update table pointer so decals on the global entities with brush models can be
; 1800 : 				// correctly moved. found the classname and the globalname for our globalentity
; 1801 : 				svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ENTVARS", &tmpVars, gTempEntvars, ARRAYSIZE( gTempEntvars ));

	push	2
	push	OFFSET _gTempEntvars
	lea	eax, DWORD PTR _tmpVars$2[ebp]
	push	eax
	push	OFFSET ??_C@_07BCNOFJKA@ENTVARS@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1802 : 
; 1803 : 				// reset the save pointers, so dll can read this too
; 1804 : 				pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pTable$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1805 : 				pSaveData->size = pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1806 : 
; 1807 : 				// IMPORTANT: we should find the already spawned or local restored global entity
; 1808 : 				pNewEnt = SV_FindGlobalEntity( tmpVars.classname, tmpVars.globalname );

	mov	eax, DWORD PTR _tmpVars$2[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _tmpVars$2[ebp]
	push	ecx
	call	_SV_FindGlobalEntity
	add	esp, 8
	mov	DWORD PTR _pNewEnt$1[ebp], eax

; 1809 : 
; 1810 : 				Con_DPrintf( "Merging changes for global: %s\n", STRING( pTable->classname ));

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CA@BBKDNKFK@Merging?5changes?5for?5global?3?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8

; 1811 : 
; 1812 : 				// -------------------------------------------------------------------------
; 1813 : 				// Pass the "global" flag to the DLL to indicate this entity should only override
; 1814 : 				// a matching entity, not be spawned
; 1815 : 				if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 1 ) > 0 )

	push	1
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19304
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN8@CreateEnti

; 1816 : 				{
; 1817 : 					movedCount++;

	mov	eax, DWORD PTR _movedCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _movedCount$[ebp], eax

; 1818 : 				}

	jmp	SHORT $LN9@CreateEnti
$LN8@CreateEnti:

; 1819 : 				else
; 1820 : 				{
; 1821 : 					if( SV_IsValidEdict( pNewEnt )) // update the table so decals can find parent entity

	mov	eax, DWORD PTR ?__LINE__Var@?0??CreateEntityTransitionList@@9@9
	add	eax, 48					; 00000030H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pNewEnt$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@CreateEnti

; 1822 : 						pTable->pent = pNewEnt;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR _pNewEnt$1[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN10@CreateEnti:

; 1823 : 					SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN9@CreateEnti:

; 1824 : 				}
; 1825 : 			}

	jmp	$LN7@CreateEnti
$LN6@CreateEnti:

; 1826 : 			else 
; 1827 : 			{
; 1828 : 				Con_Reportf( "Transferring %s (%d)\n", STRING( pTable->classname ), NUM_FOR_EDICT( pent ));

	mov	eax, DWORD PTR _pent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _pTable$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BG@MAPDDIOO@Transferring?5?$CFs?5?$CI?$CFd?$CJ?6@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 1829 : 
; 1830 : 				if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 0 ) < 0 )

	push	0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19304
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN11@CreateEnti

; 1831 : 				{
; 1832 : 					SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1833 : 				}

	jmp	SHORT $LN7@CreateEnti
$LN11@CreateEnti:

; 1834 : 				else
; 1835 : 				{
; 1836 : 					if( !FBitSet( pTable->flags, FENTTABLE_PLAYER ) && EntityInSolid( pent ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN13@CreateEnti
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_EntityInSolid
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CreateEnti

; 1837 : 					{
; 1838 : 						// this can happen during normal processing - PVS is just a guess,
; 1839 : 						// some map areas won't exist in the new map
; 1840 : 						Con_Reportf( "Suppressing %s\n", STRING( pTable->classname ));

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BA@FBJOHKAB@Suppressing?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8

; 1841 : 						SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1842 : 					}

	jmp	SHORT $LN7@CreateEnti
$LN13@CreateEnti:

; 1843 : 					else
; 1844 : 					{
; 1845 : 						pTable->flags = FENTTABLE_REMOVED;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [eax+16], 1073741824		; 40000000H

; 1846 : 						movedCount++;

	mov	eax, DWORD PTR _movedCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _movedCount$[ebp], eax
$LN7@CreateEnti:

; 1847 : 					}
; 1848 : 				}
; 1849 : 			}
; 1850 : 
; 1851 : 			// remove any entities that were removed using UTIL_Remove()
; 1852 : 			// as a result of the above calls to UTIL_RemoveImmediate()
; 1853 : 			SV_FreeOldEntities ();

	call	_SV_FreeOldEntities
$LN5@CreateEnti:

; 1854 : 		}
; 1855 : 	}

	jmp	$LN2@CreateEnti
$LN3@CreateEnti:

; 1856 : 
; 1857 : 	return movedCount;

	mov	eax, DWORD PTR _movedCount$[ebp]

; 1858 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateEntityTransitionList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveReadHeader
_TEXT	SEGMENT
_pSaveData$ = -24					; size = 4
_version$ = -20						; size = 4
_id$ = -16						; size = 4
_size$ = -12						; size = 4
_tokenSize$ = -8					; size = 4
_tokenCount$ = -4					; size = 4
_pFile$ = 8						; size = 4
_pHeader$ = 12						; size = 4
_SaveReadHeader PROC					; COMDAT

; 1720 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1721 : 	int		tokenCount, tokenSize;
; 1722 : 	int		size, id, version;
; 1723 : 	SAVERESTOREDATA	*pSaveData;
; 1724 : 
; 1725 : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1726 : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN2@SaveReadHe

; 1727 : 	{
; 1728 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1729 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveReadHe
$LN2@SaveReadHe:

; 1730 : 	}
; 1731 : 		
; 1732 : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1733 : 	if( version != SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 113		; 00000071H
	je	SHORT $LN3@SaveReadHe

; 1734 : 	{
; 1735 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1736 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveReadHe
$LN3@SaveReadHe:

; 1737 : 	}
; 1738 : 
; 1739 : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1740 : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1741 : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1742 : 
; 1743 : 	pSaveData = SaveInit( size + tokenSize, tokenCount );

	mov	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR _tokenSize$[ebp]
	push	ecx
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1744 : 	pSaveData->tokenCount = tokenCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1745 : 	pSaveData->tokenSize = tokenSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1746 : 
; 1747 : 	// Parse the symbol table
; 1748 : 	BuildHashTable( pSaveData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_BuildHashTable
	add	esp, 8

; 1749 : 
; 1750 : 	// Set up the restore basis
; 1751 : 	pSaveData->fUseLandmark = false;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+1324], 0

; 1752 : 	pSaveData->time = 0.0f;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1360], xmm0

; 1753 : 
; 1754 : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1755 : 
; 1756 : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "GameHeader", pHeader, gGameHeader, ARRAYSIZE( gGameHeader ));	

	push	3
	push	OFFSET _gGameHeader
	mov	eax, DWORD PTR _pHeader$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@MNHGMPM@GameHeader@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1757 : 
; 1758 : 	svgame.dllFuncs.pfnRestoreGlobalState( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19324
	add	esp, 4

; 1759 : 
; 1760 : 	SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1761 : 
; 1762 : 	return 1;

	mov	eax, 1
$LN1@SaveReadHe:

; 1763 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveReadHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveGameSlot
_TEXT	SEGMENT
_pFile$ = -268						; size = 4
_gameHeader$ = -264					; size = 116
_pSaveData$ = -148					; size = 4
_pTokenData$ = -144					; size = 4
_version$ = -140					; size = 4
_id$ = -136						; size = 4
_name$ = -132						; size = 64
_hlPath$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveName$ = 8						; size = 4
_pSaveComment$ = 12					; size = 4
_SaveGameSlot PROC					; COMDAT

; 1644 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1645 : 	char		hlPath[MAX_QPATH];
; 1646 : 	char		name[MAX_QPATH];
; 1647 : 	int		id, version;
; 1648 : 	char		*pTokenData;
; 1649 : 	SAVERESTOREDATA	*pSaveData;
; 1650 : 	GAME_HEADER	gameHeader;
; 1651 : 	file_t		*pFile;
; 1652 : 
; 1653 : 	pSaveData = SaveGameState( false );

	push	0
	call	_SaveGameState
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1654 : 	if( !pSaveData ) return 0;

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN2@SaveGameSl
	xor	eax, eax
	jmp	$LN1@SaveGameSl
$LN2@SaveGameSl:

; 1655 : 
; 1656 : 	SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1657 : 	pSaveData = SaveInit( SAVE_HEAPSIZE, SAVE_HASHSTRINGS ); // re-init the buffer

	push	4095					; 00000fffH
	push	4194304					; 00400000H
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1658 : 
; 1659 : 	Q_snprintf( hlPath, sizeof( hlPath ), "%s*.HL?", DEFAULT_SAVE_DIRECTORY );

	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_07FBPDBPGN@?$CFs?$CK?4HL?$DP@
	push	64					; 00000040H
	lea	eax, DWORD PTR _hlPath$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1660 : 	Q_strncpy( gameHeader.mapName, sv.name, sizeof( gameHeader.mapName )); // get the name of level where a player

	push	32					; 00000020H
	push	OFFSET _sv+56
	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1661 : 	Q_strncpy( gameHeader.comment, pSaveComment, sizeof( gameHeader.comment ));

	push	80					; 00000050H
	mov	eax, DWORD PTR _pSaveComment$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gameHeader$[ebp+32]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1662 : 	gameHeader.mapCount = DirectoryCount( hlPath ); // counting all the adjacency maps

	lea	eax, DWORD PTR _hlPath$[ebp]
	push	eax
	call	_DirectoryCount
	add	esp, 4
	mov	DWORD PTR _gameHeader$[ebp+112], eax

; 1663 : 
; 1664 : 	// Store the game header
; 1665 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "GameHeader", &gameHeader, gGameHeader, ARRAYSIZE( gGameHeader ));

	push	3
	push	OFFSET _gGameHeader
	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@MNHGMPM@GameHeader@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H

; 1666 : 
; 1667 : 	// Write the game globals
; 1668 : 	svgame.dllFuncs.pfnSaveGlobalState( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19320
	add	esp, 4

; 1669 : 
; 1670 : 	// Write entity string token table
; 1671 : 	pTokenData = StoreHashTable( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1672 : 
; 1673 : 	Q_snprintf( name, sizeof( name ), "%s%s.sav", DEFAULT_SAVE_DIRECTORY, pSaveName );

	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1674 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1675 : 
; 1676 : 	// output to disk
; 1677 : 	if( !Q_stricmp( pSaveName, "quick" ) || !Q_stricmp( pSaveName, "autosave" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05DFMHJABL@quick@
	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@SaveGameSl
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08CCMFCJIM@autosave@
	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SaveGameSl
$LN4@SaveGameSl:

; 1678 : 		AgeSaveList( pSaveName, SAVE_AGED_COUNT );

	push	2
	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	call	_AgeSaveList
	add	esp, 8
$LN3@SaveGameSl:

; 1679 : 
; 1680 : 	// output to disk
; 1681 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN5@SaveGameSl

; 1682 : 	{
; 1683 : 		// something bad is happens
; 1684 : 		SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1685 : 		return 0;

	xor	eax, eax
	jmp	$LN1@SaveGameSl
$LN5@SaveGameSl:

; 1686 : 	}
; 1687 : 
; 1688 : 	// pending the preview image for savegame
; 1689 : 	Cbuf_AddText( va( "saveshot \"%s\"\n", pSaveName ));

	mov	eax, DWORD PTR _pSaveName$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@LOFLHDBJ@saveshot?5?$CC?$CFs?$CC?6@
	call	_va
	add	esp, 8
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1690 : 	Con_Printf( "Saving game to %s...\n", name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@GBCGIKFH@Saving?5game?5to?5?$CFs?4?4?4?6@
	call	_Con_Printf
	add	esp, 8

; 1691 : 
; 1692 : 	version = SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 113		; 00000071H

; 1693 : 	id = SAVEGAME_HEADER;

	mov	DWORD PTR _id$[ebp], 1447121738		; 5641534aH

; 1694 : 
; 1695 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1696 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1697 : 	FS_Write( pFile, &pSaveData->size, sizeof( int )); // does not include token table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1698 : 
; 1699 : 	// write out the tokens first so we can load them before we load the entities
; 1700 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1701 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1702 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pTokenData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1703 : 	FS_Write( pFile, pSaveData->pBaseData, pSaveData->size ); // header and globals

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1704 : 
; 1705 : 	DirectoryCopy( hlPath, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _hlPath$[ebp]
	push	ecx
	call	_DirectoryCopy
	add	esp, 8

; 1706 : 	SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1707 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1708 : 
; 1709 : 	return 1;

	mov	eax, 1
$LN1@SaveGameSl:

; 1710 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGameSlot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _LoadGameState
_TEXT	SEGMENT
_i$ = -148						; size = 4
_pent$ = -144						; size = 4
_header$ = -140						; size = 128
_pTable$ = -12						; size = 4
_pSaveData$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_changelevel$ = 12					; size = 4
_LoadGameState PROC					; COMDAT

; 1565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1566 : 	SAVERESTOREDATA	*pSaveData;
; 1567 : 	ENTITYTABLE	*pTable;
; 1568 : 	SAVE_HEADER	header;
; 1569 : 	edict_t		*pent;
; 1570 : 	int		i;
; 1571 : 
; 1572 : 	pSaveData = LoadSaveData( level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_LoadSaveData
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1573 : 	if( !pSaveData ) return 0; // couldn't load the file

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN5@LoadGameSt
	xor	eax, eax
	jmp	$LN1@LoadGameSt
$LN5@LoadGameSt:

; 1574 : 
; 1575 : 	ParseSaveTables( pSaveData, &header, true );

	push	1
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_ParseSaveTables
	add	esp, 12					; 0000000cH

; 1576 : 	EntityPatchRead( pSaveData, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_EntityPatchRead
	add	esp, 8

; 1577 : 
; 1578 : 	// pause until all clients connect
; 1579 : 	sv.loadgame = sv.paused = true;

	mov	DWORD PTR _sv+2595656, 1
	mov	eax, DWORD PTR _sv+2595656
	mov	DWORD PTR _sv+8, eax

; 1580 : 
; 1581 : 	Cvar_SetValue( "skill", header.skillLevel );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05ODMCMJAJ@skill@
	call	_Cvar_SetValue
	add	esp, 8

; 1582 : 	Q_strncpy( sv.name, header.mapName, sizeof( sv.name ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _header$[ebp+20]
	push	eax
	push	OFFSET _sv+56
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1583 : 	svgame.globals->mapname = MAKE_STRING( sv.name );

	push	OFFSET _sv+56
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _svgame+19268
	mov	DWORD PTR [ecx+12], eax

; 1584 : 	Cvar_Set( "sv_skyname", header.skyName );

	lea	eax, DWORD PTR _header$[ebp+52]
	push	eax
	push	OFFSET ??_C@_0L@NPFKENCH@sv_skyname@
	call	_Cvar_Set
	add	esp, 8

; 1585 : 
; 1586 : 	// restore sky parms
; 1587 : 	Cvar_SetValue( "sv_skycolor_r", header.skyColor_r );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+84]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@CGCGGHO@sv_skycolor_r@
	call	_Cvar_SetValue
	add	esp, 8

; 1588 : 	Cvar_SetValue( "sv_skycolor_g", header.skyColor_g );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+88]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@DFNHIAGK@sv_skycolor_g@
	call	_Cvar_SetValue
	add	esp, 8

; 1589 : 	Cvar_SetValue( "sv_skycolor_b", header.skyColor_b );

	cvtsi2ss xmm0, DWORD PTR _header$[ebp+92]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@EIKAHECP@sv_skycolor_b@
	call	_Cvar_SetValue
	add	esp, 8

; 1590 : 	Cvar_SetValue( "sv_skyvec_x", header.skyVec_x );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+96]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@JBBFCNJL@sv_skyvec_x@
	call	_Cvar_SetValue
	add	esp, 8

; 1591 : 	Cvar_SetValue( "sv_skyvec_y", header.skyVec_y );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+100]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@IIAOBMNK@sv_skyvec_y@
	call	_Cvar_SetValue
	add	esp, 8

; 1592 : 	Cvar_SetValue( "sv_skyvec_z", header.skyVec_z );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+104]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@KDCDEPBJ@sv_skyvec_z@
	call	_Cvar_SetValue
	add	esp, 8

; 1593 : 	Cvar_SetValue("sv_skydir_x", header.skyDir_x);

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+108]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@PCFOFDPA@sv_skydir_x@
	call	_Cvar_SetValue
	add	esp, 8

; 1594 : 	Cvar_SetValue("sv_skydir_y", header.skyDir_y);

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+112]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@OLEFGCLB@sv_skydir_y@
	call	_Cvar_SetValue
	add	esp, 8

; 1595 : 	Cvar_SetValue("sv_skydir_z", header.skyDir_z);

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+116]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@MAGIDBHC@sv_skydir_z@
	call	_Cvar_SetValue
	add	esp, 8

; 1596 : 	Cvar_SetValue("sv_skyangle", header.skyAngle);

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+120]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@KODFIOCL@sv_skyangle@
	call	_Cvar_SetValue
	add	esp, 8

; 1597 : 	Cvar_SetValue("sv_skyspeed", header.skySpeed);

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+124]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@IDDIMGBN@sv_skyspeed@
	call	_Cvar_SetValue
	add	esp, 8

; 1598 : 
; 1599 : 	// create entity list
; 1600 : 	CreateEntitiesInRestoreList( pSaveData, 0, true );

	push	1
	push	0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_CreateEntitiesInRestoreList
	add	esp, 12					; 0000000cH

; 1601 : 
; 1602 : 	// now spawn entities
; 1603 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadGameSt
$LN2@LoadGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LoadGameSt:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN3@LoadGameSt

; 1604 : 	{
; 1605 : 		pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 1606 : 		pSaveData->pCurrentData = pSaveData->pBaseData + pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pTable$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1607 : 		pSaveData->size = pTable->location;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1608 : 		pSaveData->currentIndex = i;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1609 : 		pent = pTable->pent;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pent$[ebp], ecx

; 1610 : 
; 1611 : 		if( pent != NULL )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN7@LoadGameSt

; 1612 : 		{
; 1613 : 			if( svgame.dllFuncs.pfnRestore( pent, pSaveData, 0 ) < 0 )

	push	0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19304
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN7@LoadGameSt

; 1614 : 			{
; 1615 : 				SetBits( pent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1616 : 				pTable->pent = NULL;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN7@LoadGameSt:

; 1617 : 			}
; 1618 : 			else
; 1619 : 			{
; 1620 : 				// force the entity to be relinked
; 1621 : //				SV_LinkEdict( pent, false );
; 1622 : 			}
; 1623 : 		}
; 1624 : 	}

	jmp	$LN2@LoadGameSt
$LN3@LoadGameSt:

; 1625 : 
; 1626 : 	LoadClientState( pSaveData, level, changelevel, false );

	push	0
	mov	eax, DWORD PTR _changelevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_LoadClientState
	add	esp, 16					; 00000010H

; 1627 : 
; 1628 : 	SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1629 : 
; 1630 : 	// restore server time
; 1631 : 	sv.time = header.time;

	cvtss2sd xmm0, DWORD PTR _header$[ebp+16]
	movsd	QWORD PTR _sv+16, xmm0

; 1632 : 	
; 1633 : 	return 1;

	mov	eax, 1
$LN1@LoadGameSt:

; 1634 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveGameState
_TEXT	SEGMENT
_pFile$ = -500						; size = 4
_light$ = -496						; size = 264
_header$ = -232						; size = 128
_pTable$ = -104						; size = 4
_dataSize$ = -100					; size = 4
_tableSize$ = -96					; size = 4
_pSaveData$ = -92					; size = 4
_pTokenData$ = -88					; size = 4
_pTableData$ = -84					; size = 4
_version$ = -80						; size = 4
_id$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_changelevel$ = 8					; size = 4
_SaveGameState PROC					; COMDAT

; 1409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 564				; 00000234H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1410 : 	char		name[MAX_QPATH];
; 1411 : 	int		i, id, version;
; 1412 : 	char		*pTableData;
; 1413 : 	char		*pTokenData;
; 1414 : 	SAVERESTOREDATA	*pSaveData;
; 1415 : 	int		tableSize;
; 1416 : 	int		dataSize;
; 1417 : 	ENTITYTABLE	*pTable;
; 1418 : 	SAVE_HEADER	header;
; 1419 : 	SAVE_LIGHTSTYLE	light;
; 1420 : 	file_t		*pFile;
; 1421 : 
; 1422 : 	if( !svgame.dllFuncs.pfnParmsChangeLevel )

	cmp	DWORD PTR _svgame+19380, 0
	jne	SHORT $LN17@SaveGameSt

; 1423 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SaveGameSt
$LN17@SaveGameSt:

; 1424 : 
; 1425 : 	pSaveData = SaveInit( SAVE_HEAPSIZE, SAVE_HASHSTRINGS );

	push	4095					; 00000fffH
	push	4194304					; 00400000H
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 1426 : 
; 1427 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL1", DEFAULT_SAVE_DIRECTORY, sv.name );

	push	OFFSET _sv+56
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08HMPAEBDL@?$CFs?$CFs?4HL1@
	push	64					; 00000040H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1428 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1429 : 
; 1430 : 	// initialize entity table to count moved entities
; 1431 : 	InitEntityTable( pSaveData, svgame.numEntities );

	mov	eax, DWORD PTR _svgame+7932
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_InitEntityTable
	add	esp, 8

; 1432 : 
; 1433 : 	// Build the adjacent map list
; 1434 : 	svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19380

; 1435 : 
; 1436 : 	// Write the global data
; 1437 : 	header.skillLevel = (int)skill.value;	// this is created from an int even though it's a float

	cvttss2si eax, DWORD PTR _skill+12
	mov	DWORD PTR _header$[ebp], eax

; 1438 : 	header.entityCount = pSaveData->tableCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _header$[ebp+4], ecx

; 1439 : 	header.connectionCount = pSaveData->connectionCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _header$[ebp+8], ecx

; 1440 : 	header.time = svgame.globals->time;	// use DLL time

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _header$[ebp+16], xmm0

; 1441 : 	Q_strncpy( header.mapName, sv.name, sizeof( header.mapName ));

	push	32					; 00000020H
	push	OFFSET _sv+56
	lea	eax, DWORD PTR _header$[ebp+20]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1442 : 	Q_strncpy( header.skyName, sv_skyname.string, sizeof( header.skyName ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _sv_skyname+4
	push	eax
	lea	ecx, DWORD PTR _header$[ebp+52]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1443 : 	header.skyColor_r = sv_skycolor_r.value;

	cvttss2si eax, DWORD PTR _sv_skycolor_r+12
	mov	DWORD PTR _header$[ebp+84], eax

; 1444 : 	header.skyColor_g = sv_skycolor_g.value;

	cvttss2si eax, DWORD PTR _sv_skycolor_g+12
	mov	DWORD PTR _header$[ebp+88], eax

; 1445 : 	header.skyColor_b = sv_skycolor_b.value;

	cvttss2si eax, DWORD PTR _sv_skycolor_b+12
	mov	DWORD PTR _header$[ebp+92], eax

; 1446 : 	header.skyVec_x = sv_skyvec_x.value;

	movss	xmm0, DWORD PTR _sv_skyvec_x+12
	movss	DWORD PTR _header$[ebp+96], xmm0

; 1447 : 	header.skyVec_y = sv_skyvec_y.value;

	movss	xmm0, DWORD PTR _sv_skyvec_y+12
	movss	DWORD PTR _header$[ebp+100], xmm0

; 1448 : 	header.skyVec_z = sv_skyvec_z.value;

	movss	xmm0, DWORD PTR _sv_skyvec_z+12
	movss	DWORD PTR _header$[ebp+104], xmm0

; 1449 : 	header.skyDir_x = sv_skydir_x.value;

	movss	xmm0, DWORD PTR _sv_skydir_x+12
	movss	DWORD PTR _header$[ebp+108], xmm0

; 1450 : 	header.skyDir_y = sv_skydir_y.value;

	movss	xmm0, DWORD PTR _sv_skydir_y+12
	movss	DWORD PTR _header$[ebp+112], xmm0

; 1451 : 	header.skyDir_z = sv_skydir_z.value;

	movss	xmm0, DWORD PTR _sv_skydir_z+12
	movss	DWORD PTR _header$[ebp+116], xmm0

; 1452 : 	header.skyAngle = sv_skyangle.value;

	movss	xmm0, DWORD PTR _sv_skyangle+12
	movss	DWORD PTR _header$[ebp+120], xmm0

; 1453 : 	header.skySpeed = sv_skyspeed.value;

	movss	xmm0, DWORD PTR _sv_skyspeed+12
	movss	DWORD PTR _header$[ebp+124], xmm0

; 1454 : 	header.lightStyleCount = 0;

	mov	DWORD PTR _header$[ebp+12], 0

; 1455 : 
; 1456 : 	// counting the lightstyles
; 1457 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SaveGameSt
$LN2@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SaveGameSt:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@SaveGameSt

; 1458 : 	{
; 1459 : 		if( sv.lightstyles[i].pattern[0] )

	imul	eax, DWORD PTR _i$[ebp], 1296
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+726216]
	test	eax, eax
	je	SHORT $LN18@SaveGameSt

; 1460 : 			header.lightStyleCount++;

	mov	eax, DWORD PTR _header$[ebp+12]
	add	eax, 1
	mov	DWORD PTR _header$[ebp+12], eax
$LN18@SaveGameSt:

; 1461 : 	}

	jmp	SHORT $LN2@SaveGameSt
$LN3@SaveGameSt:

; 1462 : 
; 1463 : 	// Write the main header
; 1464 : 	pSaveData->time = 0.0f; // prohibits rebase of header.time (keep compatibility with old saves)

	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1360], xmm0

; 1465 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "Save Header", &header, gSaveHeader, ARRAYSIZE( gSaveHeader ));

	push	18					; 00000012H
	push	OFFSET _gSaveHeader
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@CGJOCCBH@Save?5Header@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H

; 1466 : 	pSaveData->time = header.time;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _header$[ebp+16]
	movss	DWORD PTR [eax+1360], xmm0

; 1467 : 
; 1468 : 	// Write the adjacency list
; 1469 : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SaveGameSt
$LN5@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SaveGameSt:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN6@SaveGameSt

; 1470 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ADJACENCY", &pSaveData->levelList[i], gAdjacency, ARRAYSIZE( gAdjacency ));

	push	4
	push	OFFSET _gAdjacency
	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	push	edx
	push	OFFSET ??_C@_09MPODFMIF@ADJACENCY@
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@SaveGameSt
$LN6@SaveGameSt:

; 1471 : 
; 1472 : 	// Write the lightstyles
; 1473 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SaveGameSt
$LN8@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SaveGameSt:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN9@SaveGameSt

; 1474 : 	{
; 1475 : 		if( !sv.lightstyles[i].pattern[0] )

	imul	eax, DWORD PTR _i$[ebp], 1296
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+726216]
	test	eax, eax
	jne	SHORT $LN19@SaveGameSt

; 1476 : 			continue;

	jmp	SHORT $LN8@SaveGameSt
$LN19@SaveGameSt:

; 1477 : 
; 1478 : 		Q_strncpy( light.style, sv.lightstyles[i].pattern, sizeof( light.style ));

	push	256					; 00000100H
	imul	eax, DWORD PTR _i$[ebp], 1296
	add	eax, OFFSET _sv+726216
	push	eax
	lea	ecx, DWORD PTR _light$[ebp+4]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1479 : 		light.time = sv.lightstyles[i].time;

	imul	eax, DWORD PTR _i$[ebp], 1296
	movss	xmm0, DWORD PTR _sv[eax+727508]
	movss	DWORD PTR _light$[ebp+260], xmm0

; 1480 : 		light.index = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _light$[ebp], eax

; 1481 : 
; 1482 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "LIGHTSTYLE", &light, gLightStyle, ARRAYSIZE( gLightStyle ));

	push	3
	push	OFFSET _gLightStyle
	lea	eax, DWORD PTR _light$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIJGAPPN@LIGHTSTYLE@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H

; 1483 : 	}

	jmp	$LN8@SaveGameSt
$LN9@SaveGameSt:

; 1484 : 
; 1485 : 	// build the table of entities
; 1486 : 	// this is used to turn pointers into savable indices
; 1487 : 	// build up ID numbers for each entity, for use in pointer conversions
; 1488 : 	// if an entity requires a certain edict number upon restore, save that as well
; 1489 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SaveGameSt
$LN11@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN12@SaveGameSt

; 1490 : 	{
; 1491 : 		pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 1492 : 		pTable->location = pSaveData->size;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 1493 : 		pSaveData->currentIndex = i;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1494 : 		pTable->size = 0;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1495 : 
; 1496 : 		if( !SV_IsValidEdict( pTable->pent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveGameState@@9@9
	add	eax, 87					; 00000057H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@SaveGameSt

; 1497 : 			continue;

	jmp	SHORT $LN11@SaveGameSt
$LN20@SaveGameSt:

; 1498 : 
; 1499 : 		svgame.dllFuncs.pfnSave( pTable->pent, pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _svgame+19300
	add	esp, 8

; 1500 : 
; 1501 : 		if( FBitSet( pTable->pent->v.flags, FL_CLIENT ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+656]
	and	edx, 8
	je	SHORT $LN21@SaveGameSt

; 1502 : 			SetBits( pTable->flags, FENTTABLE_PLAYER );

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN21@SaveGameSt:

; 1503 : 	}

	jmp	$LN11@SaveGameSt
$LN12@SaveGameSt:

; 1504 : 
; 1505 : 	// total data what includes:
; 1506 : 	// 1. save header
; 1507 : 	// 2. adjacency list
; 1508 : 	// 3. lightstyles
; 1509 : 	// 4. all the entity data
; 1510 : 	dataSize = pSaveData->size;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dataSize$[ebp], ecx

; 1511 : 
; 1512 : 	// Write entity table
; 1513 : 	pTableData = pSaveData->pCurrentData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pTableData$[ebp], ecx

; 1514 : 
; 1515 : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@SaveGameSt
$LN14@SaveGameSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@SaveGameSt:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN15@SaveGameSt

; 1516 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ETABLE", &pSaveData->pTable[i], gEntityTable, ARRAYSIZE( gEntityTable ));

	push	5
	push	OFFSET _gEntityTable
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	push	eax
	push	OFFSET ??_C@_06EDLPBOBF@ETABLE@
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H
	jmp	SHORT $LN14@SaveGameSt
$LN15@SaveGameSt:

; 1517 : 
; 1518 : 	tableSize = pSaveData->size - dataSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _dataSize$[ebp]
	mov	DWORD PTR _tableSize$[ebp], ecx

; 1519 : 	
; 1520 : 	// Write entity string token table
; 1521 : 	pTokenData = StoreHashTable( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1522 : 
; 1523 : 	// output to disk
; 1524 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN22@SaveGameSt

; 1525 : 	{
; 1526 : 		// something bad is happens
; 1527 : 		SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 1528 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SaveGameSt
$LN22@SaveGameSt:

; 1529 : 	}
; 1530 : 
; 1531 : 	// Write the header -- THIS SHOULD NEVER CHANGE STRUCTURE, USE SAVE_HEADER FOR NEW HEADER INFORMATION
; 1532 : 	// THIS IS ONLY HERE TO IDENTIFY THE FILE AND GET IT'S SIZE.
; 1533 : 	version = SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 113		; 00000071H

; 1534 : 	id = SAVEFILE_HEADER;

	mov	DWORD PTR _id$[ebp], 1447838038		; 564c4156H

; 1535 : 
; 1536 : 	// write the header
; 1537 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1538 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1539 : 
; 1540 : 	// Write out the tokens and table FIRST so they are loaded in the right order, then write out the rest of the data in the file.
; 1541 : 	FS_Write( pFile, &pSaveData->size, sizeof( int ));	// total size of all data to initialize read buffer

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1542 : 	FS_Write( pFile, &pSaveData->tableCount, sizeof( int ));	// entities count to right initialize entity table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1543 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));	// num hash tokens to prepare token table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1544 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));	// total size of hash tokens

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1545 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );	// write tokens into the file

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pTokenData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1546 : 	FS_Write( pFile, pTableData, tableSize );		// dump ETABLE structures

	mov	eax, DWORD PTR _tableSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTableData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1547 : 	FS_Write( pFile, pSaveData->pBaseData, dataSize );	// and finally store all the other data

	mov	eax, DWORD PTR _dataSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1548 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1549 : 
; 1550 : 	EntityPatchWrite( pSaveData, sv.name );

	push	OFFSET _sv+56
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_EntityPatchWrite
	add	esp, 8

; 1551 : 
; 1552 : 	SaveClientState( pSaveData, sv.name, changelevel );

	mov	eax, DWORD PTR _changelevel$[ebp]
	push	eax
	push	OFFSET _sv+56
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_SaveClientState
	add	esp, 12					; 0000000cH

; 1553 : 
; 1554 : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
$LN1@SaveGameSt:

; 1555 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _CreateEntitiesInRestoreList
_TEXT	SEGMENT
tv86 = -88						; size = 4
_ed$1 = -20						; size = 4
_pent$ = -16						; size = 4
_pTable$ = -12						; size = 4
_active$ = -8						; size = 4
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_levelMask$ = 12					; size = 4
_create_world$ = 16					; size = 4
_CreateEntitiesInRestoreList PROC			; COMDAT

; 1350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1351 : 	int		i, active;
; 1352 : 	ENTITYTABLE	*pTable;
; 1353 : 	edict_t		*pent;
; 1354 : 
; 1355 : 	// create entity list
; 1356 : 	if( svgame.physFuncs.pfnCreateEntitiesInRestoreList != NULL )

	cmp	DWORD PTR _svgame+19552, 0
	je	SHORT $LN5@CreateEnti

; 1357 : 	{
; 1358 : 		svgame.physFuncs.pfnCreateEntitiesInRestoreList( pSaveData, levelMask, create_world );

	mov	eax, DWORD PTR _create_world$[ebp]
	push	eax
	mov	ecx, DWORD PTR _levelMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19552
	add	esp, 12					; 0000000cH

; 1359 : 	}

	jmp	$LN1@CreateEnti
$LN5@CreateEnti:

; 1360 : 	else
; 1361 : 	{
; 1362 : 		for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CreateEnti
$LN2@CreateEnti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CreateEnti:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN1@CreateEnti

; 1363 : 		{
; 1364 : 			pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 1365 : 			pent = NULL;

	mov	DWORD PTR _pent$[ebp], 0

; 1366 : 
; 1367 : 			if( pTable->classname && pTable->size && ( !FBitSet( pTable->flags, FENTTABLE_REMOVED ) || !create_world ))

	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	$LN7@CreateEnti
	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN7@CreateEnti
	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN8@CreateEnti
	cmp	DWORD PTR _create_world$[ebp], 0
	jne	$LN7@CreateEnti
$LN8@CreateEnti:

; 1368 : 			{
; 1369 : 				if( !create_world )

	cmp	DWORD PTR _create_world$[ebp], 0
	jne	SHORT $LN9@CreateEnti

; 1370 : 					active = FBitSet( pTable->flags, levelMask ) ? 1 : 0;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, DWORD PTR _levelMask$[ebp]
	je	SHORT $LN19@CreateEnti
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN20@CreateEnti
$LN19@CreateEnti:
	mov	DWORD PTR tv86[ebp], 0
$LN20@CreateEnti:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _active$[ebp], edx
	jmp	SHORT $LN10@CreateEnti
$LN9@CreateEnti:

; 1371 : 				else active = 1;

	mov	DWORD PTR _active$[ebp], 1
$LN10@CreateEnti:

; 1372 : 
; 1373 : 				if( pTable->id == 0 && create_world ) // worldspawn

	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN11@CreateEnti
	cmp	DWORD PTR _create_world$[ebp], 0
	je	SHORT $LN11@CreateEnti

; 1374 : 				{
; 1375 : 					pent = EDICT_NUM( 0 );

	push	0
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax

; 1376 : 					SV_InitEdict( pent );

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4

; 1377 : 					pent = SV_CreateNamedEntity( pent, pTable->classname );

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _pent$[ebp]
	push	edx
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax

; 1378 : 				}

	jmp	$LN7@CreateEnti
$LN11@CreateEnti:

; 1379 : 				else if(( pTable->id > 0 ) && ( pTable->id < svs.maxclients + 1 ))

	mov	eax, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN13@CreateEnti
	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	ecx, DWORD PTR _pTable$[ebp]
	cmp	DWORD PTR [ecx], eax
	jge	SHORT $LN13@CreateEnti

; 1380 : 				{
; 1381 : 					edict_t	*ed = EDICT_NUM( pTable->id );

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ed$1[ebp], eax

; 1382 : 
; 1383 : 					if( !FBitSet( pTable->flags, FENTTABLE_PLAYER ))

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2147483648			; 80000000H
	jne	SHORT $LN15@CreateEnti

; 1384 : 						Con_Printf( S_ERROR "ENTITY IS NOT A PLAYER: %d\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@BMENADOI@?$FO1Error?3?$FO7?5ENTITY?5IS?5NOT?5A?5PLAY@
	call	_Con_Printf
	add	esp, 8
$LN15@CreateEnti:

; 1385 : 
; 1386 : 					// create the player
; 1387 : 					if( active && SV_IsValidEdict( ed ))

	cmp	DWORD PTR _active$[ebp], 0
	je	SHORT $LN16@CreateEnti
	mov	eax, DWORD PTR ?__LINE__Var@?0??CreateEntitiesInRestoreList@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ed$1[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@CreateEnti

; 1388 : 						pent = SV_CreateNamedEntity( ed, pTable->classname );

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ed$1[ebp]
	push	edx
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax
$LN16@CreateEnti:

; 1389 : 				}

	jmp	SHORT $LN7@CreateEnti
$LN13@CreateEnti:

; 1390 : 				else if( active )

	cmp	DWORD PTR _active$[ebp], 0
	je	SHORT $LN7@CreateEnti

; 1391 : 				{
; 1392 : 					pent = SV_CreateNamedEntity( NULL, pTable->classname );

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	call	_SV_CreateNamedEntity
	add	esp, 8
	mov	DWORD PTR _pent$[ebp], eax
$LN7@CreateEnti:

; 1393 : 				}
; 1394 : 			}
; 1395 : 
; 1396 : 			pTable->pent = pent;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1397 : 		}

	jmp	$LN2@CreateEnti
$LN1@CreateEnti:

; 1398 : 	}
; 1399 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateEntitiesInRestoreList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _LoadClientState
_TEXT	SEGMENT
tv225 = -656						; size = 4
tv289 = -652						; size = 4
tv246 = -652						; size = 4
tv224 = -652						; size = 4
tv182 = -652						; size = 4
_pent$1 = -520						; size = 4
_pFile$ = -516						; size = 4
_header$ = -512						; size = 168
_decalEntry$ = -344					; size = 136
_soundEntry$ = -208					; size = 112
_name$ = -96						; size = 64
_cl$ = -32						; size = 4
_version$ = -28						; size = 4
_id$ = -24						; size = 4
_size$ = -20						; size = 4
_i$ = -16						; size = 4
_tokenSize$ = -12					; size = 4
_tokenCount$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_changelevel$ = 16					; size = 4
_adjacent$ = 20						; size = 4
_LoadClientState PROC					; COMDAT

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1229 : 	int		tokenCount, tokenSize;
; 1230 : 	int		i, size, id, version;
; 1231 : 	sv_client_t	*cl = svs.clients;

	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax

; 1232 : 	char		name[MAX_QPATH];
; 1233 : 	soundlist_t	soundEntry;
; 1234 : 	decallist_t	decalEntry;
; 1235 : 	SAVE_CLIENT	header;
; 1236 : 	file_t		*pFile;
; 1237 : 
; 1238 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1239 : 
; 1240 : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN11@LoadClient

; 1241 : 		return; // something bad is happens

	jmp	$LN20@LoadClient
$LN11@LoadClient:

; 1242 : 
; 1243 : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1244 : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN12@LoadClient

; 1245 : 	{
; 1246 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1247 : 		return;

	jmp	$LN20@LoadClient
$LN12@LoadClient:

; 1248 : 	}
; 1249 : 		
; 1250 : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1251 : 	if( version != CLIENT_SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 103		; 00000067H
	je	SHORT $LN13@LoadClient

; 1252 : 	{
; 1253 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1254 : 		return;

	jmp	$LN20@LoadClient
$LN13@LoadClient:

; 1255 : 	}
; 1256 : 
; 1257 : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1258 : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1259 : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1260 : 
; 1261 : 	// sanity check
; 1262 : 	ASSERT( pSaveData->bufferSize >= ( size + tokenSize ));

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jge	SHORT $LN14@LoadClient
	mov	eax, DWORD PTR ?__LINE__Var@?0??LoadClientState@@9@9
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN14@LoadClient:

; 1263 : 
; 1264 : 	// clearing the restore buffer to reuse
; 1265 : 	SaveClear( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveClear
	add	esp, 4

; 1266 : 	pSaveData->tokenCount = tokenCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 1267 : 	pSaveData->tokenSize = tokenSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1268 : 
; 1269 : 	// Parse the symbol table
; 1270 : 	BuildHashTable( pSaveData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_BuildHashTable
	add	esp, 8

; 1271 : 
; 1272 : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1273 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1274 : 
; 1275 : 	// Read the client header
; 1276 : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ClientHeader", &header, gSaveClient, ARRAYSIZE( gSaveClient ));

	push	12					; 0000000cH
	push	OFFSET _gSaveClient
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@BBKGEOKF@ClientHeader@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1277 : 
; 1278 : 	// restore decals
; 1279 : 	for( i = 0; i < header.decalCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LoadClient
$LN2@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp]
	jge	$LN3@LoadClient

; 1280 : 	{
; 1281 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "DECALLIST", &decalEntry, gDecalEntry, ARRAYSIZE( gDecalEntry ));

	push	8
	push	OFFSET _gDecalEntry
	lea	eax, DWORD PTR _decalEntry$[ebp]
	push	eax
	push	OFFSET ??_C@_09OJOHKNIJ@DECALLIST@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1282 : 
; 1283 : 		// NOTE: apply landmark offset only for brush entities without origin brushes
; 1284 : 		if( pSaveData->fUseLandmark && FBitSet( decalEntry.flags, FDECAL_USE_LANDMARK ))

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+1324], 0
	je	$LN15@LoadClient
	movzx	eax, BYTE PTR _decalEntry$[ebp+79]
	and	eax, 2
	je	$LN15@LoadClient

; 1285 : 			VectorAdd( decalEntry.position, pSaveData->vecLandmarkOffset, decalEntry.position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+1348]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _decalEntry$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+1348]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _decalEntry$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR _decalEntry$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+1348]
	movss	DWORD PTR tv182[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv182[ebp]
	movss	DWORD PTR _decalEntry$[ebp+eax], xmm0
$LN15@LoadClient:

; 1286 : 		RestoreDecal( pSaveData, &decalEntry, adjacent );

	mov	eax, DWORD PTR _adjacent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _decalEntry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_RestoreDecal
	add	esp, 12					; 0000000cH

; 1287 : 	}

	jmp	$LN2@LoadClient
$LN3@LoadClient:

; 1288 : 
; 1289 : 	// clear old entities
; 1290 : 	if( !adjacent )

	cmp	DWORD PTR _adjacent$[ebp], 0
	jne	SHORT $LN16@LoadClient

; 1291 : 	{
; 1292 : 		memset( svs.static_entities, 0, sizeof( entity_state_t ) * MAX_STATIC_ENTITIES );

	push	1399392					; 00155a60H
	push	0
	mov	eax, DWORD PTR _svs+33364
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1293 : 		sv.num_static_entities = 0;		

	mov	DWORD PTR _sv+726212, 0
$LN16@LoadClient:

; 1294 : 	}
; 1295 : 
; 1296 : 	// restore client entities
; 1297 : 	for( i = 0; i < header.entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@LoadClient
$LN5@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+4]
	jge	SHORT $LN6@LoadClient

; 1298 : 	{
; 1299 : 		id = sv.num_static_entities;

	mov	eax, DWORD PTR _sv+726212
	mov	DWORD PTR _id$[ebp], eax

; 1300 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "STATICENTITY", &svs.static_entities[id], gStaticEntry, ARRAYSIZE( gStaticEntry ));

	push	34					; 00000022H
	push	OFFSET _gStaticEntry
	imul	eax, DWORD PTR _id$[ebp], 452
	add	eax, DWORD PTR _svs+33364
	push	eax
	push	OFFSET ??_C@_0N@BIODMPB@STATICENTITY@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1301 : 		if( adjacent ) continue; // static entities won't loading from adjacent levels

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN17@LoadClient
	jmp	SHORT $LN5@LoadClient
$LN17@LoadClient:

; 1302 : 
; 1303 : 		if( SV_CreateStaticEntity( &sv.signon, id ))

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	push	OFFSET _sv+2456340
	call	_SV_CreateStaticEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@LoadClient

; 1304 : 			sv.num_static_entities++;

	mov	eax, DWORD PTR _sv+726212
	add	eax, 1
	mov	DWORD PTR _sv+726212, eax
$LN18@LoadClient:

; 1305 : 	}

	jmp	SHORT $LN5@LoadClient
$LN6@LoadClient:

; 1306 : 
; 1307 : 	// restore sounds
; 1308 : 	for( i = 0; i < header.soundCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@LoadClient
$LN8@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@LoadClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+8]
	jge	SHORT $LN9@LoadClient

; 1309 : 	{
; 1310 : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "SOUNDLIST", &soundEntry, gSoundEntry, ARRAYSIZE( gSoundEntry ));

	push	11					; 0000000bH
	push	OFFSET _gSoundEntry
	lea	eax, DWORD PTR _soundEntry$[ebp]
	push	eax
	push	OFFSET ??_C@_09BJHEHHKO@SOUNDLIST@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 1311 : 		if( adjacent ) continue; // sounds don't going across the levels

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN19@LoadClient
	jmp	SHORT $LN8@LoadClient
$LN19@LoadClient:

; 1312 : 
; 1313 : 		RestoreSound( pSaveData, &soundEntry );

	lea	eax, DWORD PTR _soundEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_RestoreSound
	add	esp, 8

; 1314 : 	}

	jmp	SHORT $LN8@LoadClient
$LN9@LoadClient:

; 1315 : 
; 1316 : 	if( !adjacent )

	cmp	DWORD PTR _adjacent$[ebp], 0
	jne	$LN20@LoadClient

; 1317 : 	{
; 1318 : 		// restore camera view here
; 1319 : 		edict_t	*pent = pSaveData->pTable[bound( 0, (word)header.viewentity, pSaveData->tableCount )].pent;

	movzx	eax, WORD PTR _header$[ebp+156]
	test	eax, eax
	jl	SHORT $LN30@LoadClient
	movzx	ecx, WORD PTR _header$[ebp+156]
	mov	edx, DWORD PTR _pSaveData$[ebp]
	cmp	ecx, DWORD PTR [edx+32]
	jge	SHORT $LN28@LoadClient
	movzx	eax, WORD PTR _header$[ebp+156]
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN29@LoadClient
$LN28@LoadClient:
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv224[ebp], edx
$LN29@LoadClient:
	mov	eax, DWORD PTR tv224[ebp]
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN31@LoadClient
$LN30@LoadClient:
	mov	DWORD PTR tv225[ebp], 0
$LN31@LoadClient:
	imul	ecx, DWORD PTR tv225[ebp], 24
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _pent$1[ebp], ecx

; 1320 : 
; 1321 : 		if( Q_strlen( header.introTrack ) || Q_strlen(header.mainTrack))

	lea	eax, DWORD PTR _header$[ebp+16]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@LoadClient
	lea	eax, DWORD PTR _header$[ebp+80]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	$LN24@LoadClient
$LN22@LoadClient:

; 1322 : 		{
; 1323 : 			// NOTE: music automatically goes across transition, never restore it on changelevel
; 1324 : 			Con_Printf("RestoreMusic: onLoop: %d\n", header.onLoop);

	mov	eax, DWORD PTR _header$[ebp+152]
	push	eax
	push	OFFSET ??_C@_0BK@DAEJBELJ@RestoreMusic?3?5onLoop?3?5?$CFd?6@
	call	_Con_Printf
	add	esp, 8

; 1325 : 			MSG_BeginServerCmd( &sv.signon, svc_stufftext );

	push	0
	push	1
	push	9
	push	OFFSET _sv+2456340
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1326 : 			if (header.loopNum < 0 || header.loopNum > 1)

	cmp	DWORD PTR _header$[ebp+148], 0
	jl	SHORT $LN25@LoadClient
	cmp	DWORD PTR _header$[ebp+148], 1
	jle	SHORT $LN23@LoadClient
$LN25@LoadClient:

; 1327 : 				MSG_WriteString( &sv.signon, va( "music \"%s\" \"%s\" loop %d pos %i%s restored\n", header.introTrack, header.mainTrack, header.loopNum, header.trackPosition, (header.onLoop) ? " onloop" : ""));

	cmp	DWORD PTR _header$[ebp+152], 0
	je	SHORT $LN32@LoadClient
	mov	DWORD PTR tv246[ebp], OFFSET ??_C@_07HPJIJIBE@?5onloop@
	jmp	SHORT $LN33@LoadClient
$LN32@LoadClient:
	mov	DWORD PTR tv246[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN33@LoadClient:
	mov	eax, DWORD PTR tv246[ebp]
	push	eax
	mov	ecx, DWORD PTR _header$[ebp+144]
	push	ecx
	mov	edx, DWORD PTR _header$[ebp+148]
	push	edx
	lea	eax, DWORD PTR _header$[ebp+80]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp+16]
	push	ecx
	push	OFFSET ??_C@_0CL@NAIDCDGI@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5loop?5?$CFd?5pos?5?$CFi?$CF@
	call	_va
	add	esp, 24					; 00000018H
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN24@LoadClient
$LN23@LoadClient:

; 1328 : 			else
; 1329 : 				MSG_WriteString(&sv.signon, va("music \"%s\" \"%s\" pos %i%s restored\n", header.introTrack, header.mainTrack, header.trackPosition, (header.onLoop) ? " onloop" : ""));

	cmp	DWORD PTR _header$[ebp+152], 0
	je	SHORT $LN34@LoadClient
	mov	DWORD PTR tv289[ebp], OFFSET ??_C@_07HPJIJIBE@?5onloop@
	jmp	SHORT $LN35@LoadClient
$LN34@LoadClient:
	mov	DWORD PTR tv289[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN35@LoadClient:
	mov	eax, DWORD PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR _header$[ebp+144]
	push	ecx
	lea	edx, DWORD PTR _header$[ebp+80]
	push	edx
	lea	eax, DWORD PTR _header$[ebp+16]
	push	eax
	push	OFFSET ??_C@_0CD@JJPJBDAA@music?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?5pos?5?$CFi?$CFs?5restor@
	call	_va
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_WriteString
	add	esp, 8
$LN24@LoadClient:

; 1330 : 		}
; 1331 : 
; 1332 : 		// don't go camera across the levels
; 1333 : 		if( header.viewentity > svs.maxclients && !changelevel )

	movsx	eax, WORD PTR _header$[ebp+156]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN26@LoadClient
	cmp	DWORD PTR _changelevel$[ebp], 0
	jne	SHORT $LN26@LoadClient

; 1334 : 			cl->pViewEntity = pent;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _pent$1[ebp]
	mov	DWORD PTR [eax+264952], ecx
$LN26@LoadClient:

; 1335 : 
; 1336 : 		// restore some client cvars
; 1337 : 		Cvar_SetValue( "sv_wateralpha", header.wateralpha );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+160]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@IFEMIFOJ@sv_wateralpha@
	call	_Cvar_SetValue
	add	esp, 8

; 1338 : 		Cvar_SetValue( "sv_wateramp", header.wateramp );

	push	ecx
	movss	xmm0, DWORD PTR _header$[ebp+164]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@COFDEJEF@sv_wateramp@
	call	_Cvar_SetValue
	add	esp, 8
$LN20@LoadClient:

; 1339 : 	}
; 1340 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveClientState
_TEXT	SEGMENT
tv190 = -36620						; size = 4
_pFile$ = -36104					; size = 4
_header$ = -36100					; size = 168
_decalList$ = -35932					; size = 4
_pTokenData$ = -35928					; size = 4
_version$ = -35924					; size = 4
_id$ = -35920						; size = 4
_i$ = -35916						; size = 4
_name$ = -35912						; size = 64
_cl$ = -35848						; size = 4
_soundInfo$ = -35844					; size = 35840
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_changelevel$ = 16					; size = 4
_SaveClientState PROC					; COMDAT

; 1135 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 36620				; 00008f0cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1136 : 	soundlist_t	soundInfo[MAX_CHANNELS];
; 1137 : 	sv_client_t	*cl = svs.clients;

	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax

; 1138 : 	char		name[MAX_QPATH];
; 1139 : 	int		i, id, version;
; 1140 : 	char		*pTokenData;
; 1141 : 	decallist_t	*decalList;
; 1142 : 	SAVE_CLIENT	header;
; 1143 : 	file_t		*pFile;
; 1144 : 
; 1145 : 	// clearing the saving buffer to reuse
; 1146 : 	SaveClear( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveClear
	add	esp, 4

; 1147 : 
; 1148 : 	memset( &header, 0, sizeof( header ));

	push	168					; 000000a8H
	push	0
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1149 : 
; 1150 : 	// g-cont. add space for studiodecals if present
; 1151 : 	decalList = (decallist_t *)Z_Calloc( sizeof( decallist_t ) * MAX_RENDER_DECALS * 2 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveClientState@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	1114112					; 00110000H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _decalList$[ebp], eax

; 1152 : 
; 1153 : 	// initialize client header
; 1154 : 	header.decalCount = R_CreateDecalList( decalList );

	mov	eax, DWORD PTR _decalList$[ebp]
	push	eax
	call	_R_CreateDecalList
	add	esp, 4
	mov	DWORD PTR _header$[ebp], eax

; 1155 : 	header.entityCount = sv.num_static_entities;

	mov	eax, DWORD PTR _sv+726212
	mov	DWORD PTR _header$[ebp+4], eax

; 1156 : 
; 1157 : 	if( !changelevel )

	cmp	DWORD PTR _changelevel$[ebp], 0
	jne	SHORT $LN11@SaveClient

; 1158 : 	{
; 1159 : 	 	// sounds won't going across transition
; 1160 : 		header.soundCount = S_GetCurrentDynamicSounds( soundInfo, MAX_CHANNELS );

	push	320					; 00000140H
	lea	eax, DWORD PTR _soundInfo$[ebp]
	push	eax
	call	_S_GetCurrentDynamicSounds
	add	esp, 8
	mov	DWORD PTR _header$[ebp+8], eax

; 1161 : 
; 1162 : 		// music not reqiured to save position: it's just continue playing on a next level
; 1163 : 		S_StreamGetCurrentState(header.introTrack, header.mainTrack, &header.trackPosition, &header.loopNum, &header.onLoop);

	lea	eax, DWORD PTR _header$[ebp+152]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp+148]
	push	ecx
	lea	edx, DWORD PTR _header$[ebp+144]
	push	edx
	lea	eax, DWORD PTR _header$[ebp+80]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp+16]
	push	ecx
	call	_S_StreamGetCurrentState
	add	esp, 20					; 00000014H

; 1164 : 		Con_Printf("saveMusic: onLoop: %d\n", header.onLoop);

	mov	eax, DWORD PTR _header$[ebp+152]
	push	eax
	push	OFFSET ??_C@_0BH@JDHPMEGE@saveMusic?3?5onLoop?3?5?$CFd?6@
	call	_Con_Printf
	add	esp, 8
$LN11@SaveClient:

; 1165 : 	}
; 1166 : 
; 1167 : 	// save viewentity to allow camera works after save\restore
; 1168 : 	if( SV_IsValidEdict( cl->pViewEntity ) && cl->pViewEntity != cl->edict )

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveClientState@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264952]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@SaveClient
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [eax+264952]
	cmp	edx, DWORD PTR [ecx+264948]
	je	SHORT $LN12@SaveClient

; 1169 : 		header.viewentity = NUM_FOR_EDICT( cl->pViewEntity );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264952]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	WORD PTR _header$[ebp+156], ax
$LN12@SaveClient:

; 1170 : 
; 1171 : 	header.wateralpha = sv_wateralpha.value;

	movss	xmm0, DWORD PTR _sv_wateralpha+12
	movss	DWORD PTR _header$[ebp+160], xmm0

; 1172 : 	header.wateramp = sv_wateramp.value;

	movss	xmm0, DWORD PTR _sv_wateramp+12
	movss	DWORD PTR _header$[ebp+164], xmm0

; 1173 : 
; 1174 : 	// Store the client header
; 1175 : 	svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "ClientHeader", &header, gSaveClient, ARRAYSIZE( gSaveClient ));

	push	12					; 0000000cH
	push	OFFSET _gSaveClient
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@BBKGEOKF@ClientHeader@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H

; 1176 : 
; 1177 : 	// store decals
; 1178 : 	for( i = 0; i < header.decalCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SaveClient
$LN2@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp]
	jge	$LN3@SaveClient

; 1179 : 	{
; 1180 : 		// NOTE: apply landmark offset only for brush entities without origin brushes
; 1181 : 		if( pSaveData->fUseLandmark && FBitSet( decalList[i].flags, FDECAL_USE_LANDMARK ))

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+1324], 0
	je	$LN13@SaveClient
	imul	eax, DWORD PTR _i$[ebp], 136
	mov	ecx, DWORD PTR _decalList$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+79]
	and	edx, 2
	je	$LN13@SaveClient

; 1182 : 			VectorSubtract( decalList[i].position, pSaveData->vecLandmarkOffset, decalList[i].position );

	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, DWORD PTR _decalList$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [esi+ecx+1348]
	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, DWORD PTR _decalList$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, DWORD PTR _decalList$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+1348]
	imul	edx, DWORD PTR _i$[ebp], 136
	add	edx, DWORD PTR _decalList$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 136
	add	ecx, DWORD PTR _decalList$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pSaveData$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+1348]
	movss	DWORD PTR tv190[ebp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 136
	add	ecx, DWORD PTR _decalList$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv190[ebp]
	movss	DWORD PTR [ecx+edx], xmm0
$LN13@SaveClient:

; 1183 : 
; 1184 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "DECALLIST", &decalList[i], gDecalEntry, ARRAYSIZE( gDecalEntry ));

	push	8
	push	OFFSET _gDecalEntry
	imul	eax, DWORD PTR _i$[ebp], 136
	add	eax, DWORD PTR _decalList$[ebp]
	push	eax
	push	OFFSET ??_C@_09OJOHKNIJ@DECALLIST@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H

; 1185 : 	}

	jmp	$LN2@SaveClient
$LN3@SaveClient:

; 1186 : 	Z_Free( decalList );

	cmp	DWORD PTR _decalList$[ebp], 0
	je	SHORT $LN14@SaveClient
	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveClientState@@9@9
	add	eax, 51					; 00000033H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _decalList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@SaveClient:

; 1187 : 
; 1188 : 	// write client entities
; 1189 : 	for( i = 0; i < header.entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SaveClient
$LN5@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+4]
	jge	SHORT $LN6@SaveClient

; 1190 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "STATICENTITY", &svs.static_entities[i], gStaticEntry, ARRAYSIZE( gStaticEntry ));

	push	34					; 00000022H
	push	OFFSET _gStaticEntry
	imul	eax, DWORD PTR _i$[ebp], 452
	add	eax, DWORD PTR _svs+33364
	push	eax
	push	OFFSET ??_C@_0N@BIODMPB@STATICENTITY@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@SaveClient
$LN6@SaveClient:

; 1191 : 
; 1192 : 	// write sounds
; 1193 : 	for( i = 0; i < header.soundCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SaveClient
$LN8@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SaveClient:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _header$[ebp+8]
	jge	SHORT $LN9@SaveClient

; 1194 : 		svgame.dllFuncs.pfnSaveWriteFields( pSaveData, "SOUNDLIST", &soundInfo[i], gSoundEntry, ARRAYSIZE( gSoundEntry ));

	push	11					; 0000000bH
	push	OFFSET _gSoundEntry
	imul	eax, DWORD PTR _i$[ebp], 112
	lea	ecx, DWORD PTR _soundInfo$[ebp+eax]
	push	ecx
	push	OFFSET ??_C@_09BJHEHHKO@SOUNDLIST@
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19312
	add	esp, 20					; 00000014H
	jmp	SHORT $LN8@SaveClient
$LN9@SaveClient:

; 1195 : 
; 1196 : 	// Write entity string token table
; 1197 : 	pTokenData = StoreHashTable( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_StoreHashTable
	add	esp, 4
	mov	DWORD PTR _pTokenData$[ebp], eax

; 1198 : 
; 1199 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1200 : 
; 1201 : 	// output to disk
; 1202 : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN15@SaveClient

; 1203 : 		return; // something bad is happens

	jmp	$LN1@SaveClient
$LN15@SaveClient:

; 1204 : 
; 1205 : 	version = CLIENT_SAVEGAME_VERSION;

	mov	DWORD PTR _version$[ebp], 103		; 00000067H

; 1206 : 	id = SAVEGAME_HEADER;

	mov	DWORD PTR _id$[ebp], 1447121738		; 5641534aH

; 1207 : 
; 1208 : 	FS_Write( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1209 : 	FS_Write( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1210 : 	FS_Write( pFile, &pSaveData->size, sizeof( int )); // does not include token table

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1211 : 
; 1212 : 	// write out the tokens first so we can load them before we load the entities
; 1213 : 	FS_Write( pFile, &pSaveData->tokenCount, sizeof( int ));

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1214 : 	FS_Write( pFile, &pSaveData->tokenSize, sizeof( int ));

	push	4
	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1215 : 	FS_Write( pFile, pTokenData, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pTokenData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1216 : 	FS_Write( pFile, pSaveData->pBaseData, pSaveData->size ); // header and globals

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1217 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@SaveClient:

; 1218 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _RestoreSound
_TEXT	SEGMENT
_flags$ = -8						; size = 4
_ent$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_snd$ = 12						; size = 4
_RestoreSound PROC					; COMDAT

; 1107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1108 : 	edict_t	*ent = EdictFromTable( pSaveData, snd->entnum );

	mov	eax, DWORD PTR _snd$[ebp]
	movsx	ecx, WORD PTR [eax+64]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EdictFromTable
	add	esp, 8
	mov	DWORD PTR _ent$[ebp], eax

; 1109 : 	int	flags = SND_RESTORE_POSITION;

	mov	DWORD PTR _flags$[ebp], 4096		; 00001000H

; 1110 : 
; 1111 : 	// this can happens if serialized map contain 4096 static decals...
; 1112 : 	if( MSG_GetNumBytesLeft( &sv.signon ) < 36 )

	push	OFFSET _sv+2456340
	call	_MSG_GetNumBytesLeft
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jge	SHORT $LN2@RestoreSou

; 1113 : 		return;

	jmp	$LN4@RestoreSou
$LN2@RestoreSou:

; 1114 : 
; 1115 : 	if( !snd->looping )

	mov	eax, DWORD PTR _snd$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $LN3@RestoreSou

; 1116 : 		SetBits( flags, SND_STOP_LOOPING );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _flags$[ebp], eax
$LN3@RestoreSou:

; 1117 : 
; 1118 : 	if( SV_BuildSoundMsg( &sv.signon, ent, snd->channel, snd->name, snd->volume * 255, snd->attenuation, flags, snd->pitch, snd->origin ))

	mov	eax, DWORD PTR _snd$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _snd$[ebp]
	movzx	edx, BYTE PTR [ecx+93]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _snd$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+84]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _snd$[ebp]
	movss	xmm0, DWORD PTR [edx+80]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _snd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _snd$[ebp]
	movzx	eax, BYTE PTR [edx+92]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	OFFSET _sv+2456340
	call	_SV_BuildSoundMsg
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN4@RestoreSou

; 1119 : 	{
; 1120 : 		// write extradata for svc_restoresound
; 1121 : 		MSG_WriteByte( &sv.signon, snd->wordIndex );

	mov	eax, DWORD PTR _snd$[ebp]
	movzx	ecx, BYTE PTR [eax+94]
	push	ecx
	push	OFFSET _sv+2456340
	call	_MSG_WriteByte
	add	esp, 8

; 1122 : 		MSG_WriteBytes( &sv.signon, &snd->samplePos, sizeof( snd->samplePos ));

	push	8
	mov	eax, DWORD PTR _snd$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1123 : 		MSG_WriteBytes( &sv.signon, &snd->forcedEnd, sizeof( snd->forcedEnd ));

	push	8
	mov	eax, DWORD PTR _snd$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH
$LN4@RestoreSou:

; 1124 : 	}
; 1125 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_RestoreSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _RestoreDecal
_TEXT	SEGMENT
tv228 = -232						; size = 4
tv186 = -232						; size = 4
$T1 = -228						; size = 56
_dot$2 = -108						; size = 4
_tr$3 = -104						; size = 56
_testend$4 = -48					; size = 12
_testspot$5 = -36					; size = 12
_pEdict$ = -24						; size = 4
_modelIndex$ = -20					; size = 4
_flags$ = -16						; size = 4
_entityIndex$ = -12					; size = 4
_decalIndex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_entry$ = 12						; size = 4
_adjacent$ = 16						; size = 4
_RestoreDecal PROC					; COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1035 : 	int	decalIndex, entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0

; 1036 : 	int	flags = entry->flags;

	mov	eax, DWORD PTR _entry$[ebp]
	movzx	ecx, BYTE PTR [eax+79]
	mov	DWORD PTR _flags$[ebp], ecx

; 1037 : 	int	modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0

; 1038 : 	edict_t	*pEdict;
; 1039 : 
; 1040 : 	// never move permanent decals
; 1041 : 	if( adjacent && FBitSet( flags, FDECAL_PERMANENT ))

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	SHORT $LN2@RestoreDec
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@RestoreDec

; 1042 : 		return;

	jmp	$LN8@RestoreDec
$LN2@RestoreDec:

; 1043 : 
; 1044 : 	// restore entity and model index
; 1045 : 	pEdict = EdictFromTable( pSaveData, entry->entityIndex );

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_EdictFromTable
	add	esp, 8
	mov	DWORD PTR _pEdict$[ebp], eax

; 1046 : 
; 1047 : 	if( SV_RestoreCustomDecal( entry, pEdict, adjacent ))

	mov	eax, DWORD PTR _adjacent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	call	_SV_RestoreCustomDecal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@RestoreDec

; 1048 : 		return; // decal was sucessfully restored at the game-side

	jmp	$LN8@RestoreDec
$LN3@RestoreDec:

; 1049 : 
; 1050 : 	// studio decals are handled at game-side
; 1051 : 	if( FBitSet( flags, FDECAL_STUDIO ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN4@RestoreDec

; 1052 : 		return;

	jmp	$LN8@RestoreDec
$LN4@RestoreDec:

; 1053 : 
; 1054 : 	if( SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??RestoreDecal@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@RestoreDec

; 1055 : 		modelIndex = pEdict->v.modelindex;

	mov	eax, DWORD PTR _pEdict$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	mov	DWORD PTR _modelIndex$[ebp], ecx
$LN5@RestoreDec:

; 1056 : 
; 1057 : 	if( SV_IsValidEdict( pEdict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??RestoreDecal@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@RestoreDec

; 1058 : 		entityIndex = NUM_FOR_EDICT( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _entityIndex$[ebp], eax
$LN6@RestoreDec:

; 1059 : 
; 1060 : 	decalIndex = pfnDecalIndex( entry->name );

	mov	eax, DWORD PTR _entry$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_pfnDecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 1061 : 
; 1062 : 	// this can happens if brush entity from previous level was turned into world geometry
; 1063 : 	if( adjacent && entry->entityIndex != 0 && !SV_IsValidEdict( pEdict ))

	cmp	DWORD PTR _adjacent$[ebp], 0
	je	$LN7@RestoreDec
	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	test	ecx, ecx
	je	$LN7@RestoreDec
	mov	eax, DWORD PTR ?__LINE__Var@?0??RestoreDecal@@9@9
	add	eax, 29					; 0000001dH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@RestoreDec

; 1064 : 	{
; 1065 : 		vec3_t	testspot, testend;
; 1066 : 		trace_t	tr;
; 1067 : 
; 1068 : 		Con_Printf( S_ERROR "RestoreDecal: couldn't restore entity index %i\n", entry->entityIndex );

	mov	eax, DWORD PTR _entry$[ebp]
	movsx	ecx, WORD PTR [eax+76]
	push	ecx
	push	OFFSET ??_C@_0DL@NIPAKAPI@?$FO1Error?3?$FO7?5RestoreDecal?3?5couldn@
	call	_Con_Printf
	add	esp, 8

; 1069 : 
; 1070 : 		VectorCopy( entry->position, testspot );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _testspot$5[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _testspot$5[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _testspot$5[ebp+ecx], eax

; 1071 : 		VectorMA( testspot, 5.0f, entry->impactPlaneNormal, testspot );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR _testspot$5[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _testspot$5[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [ecx+eax+84]
	addss	xmm0, DWORD PTR _testspot$5[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _testspot$5[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@40a00000
	mulss	xmm0, DWORD PTR [edx+ecx+84]
	movss	xmm1, DWORD PTR _testspot$5[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv186[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv186[ebp]
	movss	DWORD PTR _testspot$5[ebp+eax], xmm0

; 1072 : 
; 1073 : 		VectorCopy( entry->position, testend );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _testend$4[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _testend$4[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _testend$4[ebp+ecx], eax

; 1074 : 		VectorMA( testend, -5.0f, entry->impactPlaneNormal, testend );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [edx+eax+84]
	addss	xmm0, DWORD PTR _testend$4[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _testend$4[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [ecx+eax+84]
	addss	xmm0, DWORD PTR _testend$4[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _testend$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR __real@c0a00000
	mulss	xmm0, DWORD PTR [edx+ecx+84]
	movss	xmm1, DWORD PTR _testend$4[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv228[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv228[ebp]
	movss	DWORD PTR _testend$4[ebp+eax], xmm0

; 1075 : 
; 1076 : 		tr = SV_Move( testspot, vec3_origin, vec3_origin, testend, MOVE_NOMONSTERS, NULL, false );

	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _testend$4[ebp]
	push	eax
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	ecx, DWORD PTR _testspot$5[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _tr$3[ebp]
	rep movsd

; 1077 : 
; 1078 : 		// NOTE: this code may does wrong result on moving brushes e.g. func_tracktrain
; 1079 : 		if( tr.fraction != 1.0f && !tr.allsolid )

	movss	xmm0, DWORD PTR _tr$3[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN10@RestoreDec
	cmp	DWORD PTR _tr$3[ebp], 0
	jne	$LN10@RestoreDec

; 1080 : 		{
; 1081 : 			// check impact plane normal
; 1082 : 			float	dot = DotProduct( entry->impactPlaneNormal, tr.plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	mulss	xmm0, DWORD PTR _tr$3[ebp+eax+32]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+84]
	mulss	xmm1, DWORD PTR _tr$3[ebp+ecx+32]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _entry$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+84]
	mulss	xmm1, DWORD PTR _tr$3[ebp+ecx+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$2[ebp], xmm0

; 1083 : 
; 1084 : 			if( dot >= 0.95f )

	movss	xmm0, DWORD PTR _dot$2[ebp]
	comiss	xmm0, DWORD PTR __real@3f733333
	jb	SHORT $LN10@RestoreDec

; 1085 : 			{
; 1086 : 				entityIndex = pfnIndexOfEdict( tr.ent );

	mov	eax, DWORD PTR _tr$3[ebp+48]
	push	eax
	call	_pfnIndexOfEdict
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 1087 : 				if( entityIndex > 0 ) modelIndex = tr.ent->v.modelindex;

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jle	SHORT $LN11@RestoreDec
	mov	eax, DWORD PTR _tr$3[ebp+48]
	mov	ecx, DWORD PTR [eax+308]
	mov	DWORD PTR _modelIndex$[ebp], ecx
$LN11@RestoreDec:

; 1088 : 				SV_CreateDecal( &sv.signon, tr.endpos, decalIndex, entityIndex, modelIndex, flags, entry->scale );

	mov	eax, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tr$3[ebp+20]
	push	edx
	push	OFFSET _sv+2456340
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN10@RestoreDec:

; 1089 : 			}
; 1090 : 		}
; 1091 : 	}

	jmp	SHORT $LN8@RestoreDec
$LN7@RestoreDec:

; 1092 : 	else
; 1093 : 	{
; 1094 : 		// global entity is exist on new level so we can apply decal in local space
; 1095 : 		SV_CreateDecal( &sv.signon, entry->position, decalIndex, entityIndex, modelIndex, flags, entry->scale );

	mov	eax, DWORD PTR _entry$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decalIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$[ebp]
	push	edx
	push	OFFSET _sv+2456340
	call	_SV_CreateDecal
	add	esp, 28					; 0000001cH
$LN8@RestoreDec:

; 1096 : 	}
; 1097 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_RestoreDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _EntityPatchRead
_TEXT	SEGMENT
_pFile$ = -84						; size = 4
_entityId$ = -80					; size = 4
_size$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_EntityPatchRead PROC					; COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1005 : 	char	name[MAX_QPATH];
; 1006 : 	int	i, size, entityId;
; 1007 : 	file_t	*pFile;
; 1008 : 
; 1009 : 	Q_snprintf( name, sizeof( name ), "%s%s.HL3", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08EOMGCDLJ@?$CFs?$CFs?4HL3@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1010 : 
; 1011 : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN5@EntityPatc

; 1012 : 		return;

	jmp	SHORT $LN1@EntityPatc
$LN5@EntityPatc:

; 1013 : 
; 1014 : 	// patch count
; 1015 : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1016 : 
; 1017 : 	for( i = 0; i < size; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityPatc
$LN2@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN3@EntityPatc

; 1018 : 	{
; 1019 : 		FS_Read( pFile, &entityId, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _entityId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1020 : 		pSaveData->pTable[entityId].flags = FENTTABLE_REMOVED;

	imul	eax, DWORD PTR _entityId$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+eax+16], 1073741824	; 40000000H

; 1021 : 	}

	jmp	SHORT $LN2@EntityPatc
$LN3@EntityPatc:

; 1022 : 
; 1023 : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@EntityPatc:

; 1024 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityPatchRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _EntityPatchWrite
_TEXT	SEGMENT
_pFile$ = -80						; size = 4
_size$ = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_level$ = 12						; size = 4
_EntityPatchWrite PROC					; COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 968  : 	char	name[MAX_QPATH];
; 969  : 	int	i, size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 970  : 	file_t	*pFile;
; 971  : 
; 972  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL3", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08EOMGCDLJ@?$CFs?$CFs?4HL3@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 973  : 
; 974  : 	if(( pFile = FS_Open( name, "wb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN8@EntityPatc

; 975  : 		return;

	jmp	$LN1@EntityPatc
$LN8@EntityPatc:

; 976  : 
; 977  : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@EntityPatc
$LN2@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@EntityPatc:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN3@EntityPatc

; 978  : 	{
; 979  : 		if( FBitSet( pSaveData->pTable[i].flags, FENTTABLE_REMOVED ))

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+16]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN9@EntityPatc

; 980  : 			size++;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	mov	DWORD PTR _size$[ebp], eax
$LN9@EntityPatc:

; 981  : 	}

	jmp	SHORT $LN2@EntityPatc
$LN3@EntityPatc:

; 982  : 
; 983  : 	// patch count
; 984  : 	FS_Write( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 985  : 
; 986  : 	for( i = 0; i < pSaveData->tableCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@EntityPatc
$LN5@EntityPatc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@EntityPatc:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN6@EntityPatc

; 987  : 	{
; 988  : 		if( FBitSet( pSaveData->pTable[i].flags, FENTTABLE_REMOVED ))

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+16]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN10@EntityPatc

; 989  : 			FS_Write( pFile, &i, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN10@EntityPatc:

; 990  : 	}

	jmp	SHORT $LN5@EntityPatc
$LN6@EntityPatc:

; 991  : 
; 992  : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@EntityPatc:

; 993  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityPatchWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _ParseSaveTables
_TEXT	SEGMENT
_i$ = -272						; size = 4
_light$ = -268						; size = 264
__$ArrayPad$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_pHeader$ = 12						; size = 4
_updateGlobals$ = 16					; size = 4
_ParseSaveTables PROC					; COMDAT

; 915  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 916  : 	SAVE_LIGHTSTYLE	light;
; 917  : 	int		i;
; 918  : 
; 919  : 	// Re-base the savedata since we re-ordered the entity/table / restore fields
; 920  : 	InitEntityTable( pSaveData, pSaveData->tableCount );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	_InitEntityTable
	add	esp, 8

; 921  : 
; 922  : 	// START: Changes implemented thanks to Nikita Butorin
; 923  : 	pSaveData->pTable = Mem_Calloc(host.mempool, sizeof(ENTITYTABLE) * pSaveData->tableCount);

	mov	eax, DWORD PTR ?__LINE__Var@?0??ParseSaveTables@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	imul	edx, DWORD PTR [ecx+32], 24
	push	edx
	mov	eax, DWORD PTR _host+236
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 924  : 	pSaveData->tableCount = pSaveData->tableCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 925  : 
; 926  : 	for (i = 0; i < pSaveData->tableCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ParseSaveT
$LN2@ParseSaveT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@ParseSaveT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $LN3@ParseSaveT

; 927  : 	{
; 928  : 		svgame.dllFuncs.pfnSaveReadFields(pSaveData, "ETABLE", &pSaveData->pTable[i], gEntityTable, ARRAYSIZE(gEntityTable));

	push	5
	push	OFFSET _gEntityTable
	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	push	eax
	push	OFFSET ??_C@_06EDLPBOBF@ETABLE@
	mov	edx, DWORD PTR _pSaveData$[ebp]
	push	edx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 929  : 		pSaveData->pTable[i].pent = NULL;

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+eax+4], 0

; 930  : 	}

	jmp	SHORT $LN2@ParseSaveT
$LN3@ParseSaveT:

; 931  : 	// END: Changes implemented thanks to Nikita Butorin
; 932  : 
; 933  : 	pSaveData->pBaseData = pSaveData->pCurrentData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 934  : 	pSaveData->size = 0;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+8], 0

; 935  : 
; 936  : 	// process SAVE_HEADER
; 937  : 	svgame.dllFuncs.pfnSaveReadFields( pSaveData, "Save Header", pHeader, gSaveHeader, ARRAYSIZE( gSaveHeader ));

	push	18					; 00000012H
	push	OFFSET _gSaveHeader
	mov	eax, DWORD PTR _pHeader$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@CGJOCCBH@Save?5Header@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 938  : 
; 939  : 	pSaveData->connectionCount = pHeader->connectionCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pHeader$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+36], edx

; 940  : 	VectorClear( pSaveData->vecLandmarkOffset );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+1348], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+1348], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+1348], xmm0

; 941  : 	pSaveData->time = pHeader->time;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pHeader$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+1360], edx

; 942  : 	pSaveData->fUseLandmark = true;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+1324], 1

; 943  : 
; 944  : 	// read adjacency list
; 945  : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ParseSaveT
$LN5@ParseSaveT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ParseSaveT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN6@ParseSaveT

; 946  : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "ADJACENCY", &pSaveData->levelList[i], gAdjacency, ARRAYSIZE( gAdjacency ));

	push	4
	push	OFFSET _gAdjacency
	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	push	edx
	push	OFFSET ??_C@_09MPODFMIF@ADJACENCY@
	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H
	jmp	SHORT $LN5@ParseSaveT
$LN6@ParseSaveT:

; 947  : 
; 948  : 	if( updateGlobals )

	cmp	DWORD PTR _updateGlobals$[ebp], 0
	je	SHORT $LN11@ParseSaveT

; 949  : 		memset( sv.lightstyles, 0, sizeof( sv.lightstyles ));

	push	82944					; 00014400H
	push	0
	push	OFFSET _sv+726216
	call	_memset
	add	esp, 12					; 0000000cH
$LN11@ParseSaveT:

; 950  : 
; 951  : 	for( i = 0; i < pHeader->lightStyleCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@ParseSaveT
$LN8@ParseSaveT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@ParseSaveT:
	mov	eax, DWORD PTR _pHeader$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN9@ParseSaveT

; 952  : 	{
; 953  : 		svgame.dllFuncs.pfnSaveReadFields( pSaveData, "LIGHTSTYLE", &light, gLightStyle, ARRAYSIZE( gLightStyle ));

	push	3
	push	OFFSET _gLightStyle
	lea	eax, DWORD PTR _light$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIJGAPPN@LIGHTSTYLE@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19316
	add	esp, 20					; 00000014H

; 954  : 		if( updateGlobals ) SV_SetLightStyle( light.index, light.style, light.time );

	cmp	DWORD PTR _updateGlobals$[ebp], 0
	je	SHORT $LN12@ParseSaveT
	push	ecx
	movss	xmm0, DWORD PTR _light$[ebp+260]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _light$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _light$[ebp]
	push	ecx
	call	_SV_SetLightStyle
	add	esp, 12					; 0000000cH
$LN12@ParseSaveT:

; 955  : 	}

	jmp	SHORT $LN8@ParseSaveT
$LN9@ParseSaveT:

; 956  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseSaveTables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _LoadSaveData
_TEXT	SEGMENT
tv135 = -372						; size = 4
_pFile$ = -304						; size = 4
_totalSize$ = -300					; size = 4
_pSaveData$ = -296					; size = 4
_clientSize$ = -292					; size = 4
_version$ = -288					; size = 4
_id$ = -284						; size = 4
_name$ = -280						; size = 260
_tokenCount$ = -20					; size = 4
_size$ = -16						; size = 4
_tableCount$ = -12					; size = 4
_tokenSize$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_LoadSaveData PROC					; COMDAT

; 844  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 845  : 	int		tokenSize, tableCount;
; 846  : 	int		size, tokenCount;
; 847  : 	char		name[MAX_OSPATH];
; 848  : 	int		id, version;
; 849  : 	int		clientSize;
; 850  : 	SAVERESTOREDATA	*pSaveData;
; 851  : 	int		totalSize;
; 852  : 	file_t		*pFile;
; 853  : 	
; 854  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL1", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08HMPAEBDL@?$CFs?$CFs?4HL1@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 855  : 	Con_Printf( "Loading game from %s...\n", name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@GCHLOBJE@Loading?5game?5from?5?$CFs?4?4?4?6@
	call	_Con_Printf
	add	esp, 8

; 856  : 
; 857  : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN2@LoadSaveDa

; 858  : 	{
; 859  : 		Con_Printf( S_ERROR "couldn't open.\n" );

	push	OFFSET ??_C@_0BL@EEJEIAEE@?$FO1Error?3?$FO7?5couldn?8t?5open?4?6@
	call	_Con_Printf
	add	esp, 4

; 860  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@LoadSaveDa
$LN2@LoadSaveDa:

; 861  : 	}
; 862  : 
; 863  : 	// Read the header
; 864  : 	FS_Read( pFile, &id, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 865  : 	FS_Read( pFile, &version, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 866  : 
; 867  : 	// is this a valid save?
; 868  : 	if( id != SAVEFILE_HEADER || version != SAVEGAME_VERSION )

	cmp	DWORD PTR _id$[ebp], 1447838038		; 564c4156H
	jne	SHORT $LN4@LoadSaveDa
	cmp	DWORD PTR _version$[ebp], 113		; 00000071H
	je	SHORT $LN3@LoadSaveDa
$LN4@LoadSaveDa:

; 869  : 	{
; 870  : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 871  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@LoadSaveDa
$LN3@LoadSaveDa:

; 872  : 	}
; 873  : 
; 874  : 	// Read the sections info and the data
; 875  : 	FS_Read( pFile, &size, sizeof( int ));		// total size of all data to initialize read buffer

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 876  : 	FS_Read( pFile, &tableCount, sizeof( int ));	// entities count to right initialize entity table

	push	4
	lea	eax, DWORD PTR _tableCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 877  : 	FS_Read( pFile, &tokenCount, sizeof( int ));	// num hash tokens to prepare token table

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 878  : 	FS_Read( pFile, &tokenSize, sizeof( int ));	// total size of hash tokens

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 879  : 
; 880  : 	// determine highest size of seve-restore buffer
; 881  : 	// because it's used twice: for HL1 and HL2 restore
; 882  : 	clientSize = GetClientDataSize( level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_GetClientDataSize
	add	esp, 4
	mov	DWORD PTR _clientSize$[ebp], eax

; 883  : 	totalSize = Q_max( clientSize, ( size + tokenSize ));

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
	cmp	DWORD PTR _clientSize$[ebp], eax
	jle	SHORT $LN6@LoadSaveDa
	mov	ecx, DWORD PTR _clientSize$[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN7@LoadSaveDa
$LN6@LoadSaveDa:
	mov	edx, DWORD PTR _size$[ebp]
	add	edx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR tv135[ebp], edx
$LN7@LoadSaveDa:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _totalSize$[ebp], eax

; 884  : 
; 885  : 	// init the read buffer
; 886  : 	pSaveData = SaveInit( totalSize, tokenCount );

	mov	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _totalSize$[ebp]
	push	ecx
	call	_SaveInit
	add	esp, 8
	mov	DWORD PTR _pSaveData$[ebp], eax

; 887  : 
; 888  : 	Q_strncpy( pSaveData->szCurrentMapName, level, sizeof( pSaveData->szCurrentMapName ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1364				; 00000554H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 889  : 	pSaveData->tableCount = tableCount;		// count ETABLE entries

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tableCount$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 890  : 	pSaveData->tokenCount = tokenCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 891  : 	pSaveData->tokenSize = tokenSize;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 892  : 
; 893  : 	// Parse the symbol table
; 894  : 	BuildHashTable( pSaveData, pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	_BuildHashTable
	add	esp, 8

; 895  : 
; 896  : 	// Set up the restore basis
; 897  : 	pSaveData->fUseLandmark = true;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+1324], 1

; 898  : 	pSaveData->time = 0.0f;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1360], xmm0

; 899  : 
; 900  : 	// now reading all the rest of data
; 901  : 	FS_Read( pFile, pSaveData->pBaseData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 902  : 	FS_Close( pFile ); // data is sucessfully moved into SaveRestore buffer (ETABLE will be init later)

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 903  : 
; 904  : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
$LN1@LoadSaveDa:

; 905  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadSaveData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _GetClientDataSize
_TEXT	SEGMENT
_pFile$ = -92						; size = 4
_name$ = -88						; size = 64
_version$ = -24						; size = 4
_id$ = -20						; size = 4
_size$ = -16						; size = 4
_tokenSize$ = -12					; size = 4
_tokenCount$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_level$ = 8						; size = 4
_GetClientDataSize PROC					; COMDAT

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 803  : 	int	tokenCount, tokenSize;
; 804  : 	int	size, id, version;
; 805  : 	char	name[MAX_QPATH];
; 806  : 	file_t	*pFile;
; 807  : 
; 808  : 	Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, level );

	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 809  : 
; 810  : 	if(( pFile = FS_Open( name, "rb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax
	cmp	DWORD PTR _pFile$[ebp], 0
	jne	SHORT $LN2@GetClientD

; 811  : 		return 0;

	xor	eax, eax
	jmp	$LN1@GetClientD
$LN2@GetClientD:

; 812  : 
; 813  : 	FS_Read( pFile, &id, sizeof( id ));

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 814  : 	if( id != SAVEGAME_HEADER )

	cmp	DWORD PTR _id$[ebp], 1447121738		; 5641534aH
	je	SHORT $LN3@GetClientD

; 815  : 	{
; 816  : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 817  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetClientD
$LN3@GetClientD:

; 818  : 	}
; 819  : 		
; 820  : 	FS_Read( pFile, &version, sizeof( version ));

	push	4
	lea	eax, DWORD PTR _version$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 821  : 	if( version != CLIENT_SAVEGAME_VERSION )

	cmp	DWORD PTR _version$[ebp], 103		; 00000067H
	je	SHORT $LN4@GetClientD

; 822  : 	{
; 823  : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 824  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetClientD
$LN4@GetClientD:

; 825  : 	}
; 826  : 
; 827  : 	FS_Read( pFile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 828  : 	FS_Read( pFile, &tokenCount, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 829  : 	FS_Read( pFile, &tokenSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 830  : 	FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 831  : 
; 832  : 	return ( size + tokenSize );

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
$LN1@GetClientD:

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GetClientDataSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _BuildHashTable
_TEXT	SEGMENT
tv83 = -76						; size = 4
tv79 = -76						; size = 4
_i$ = -8						; size = 4
_pszTokenList$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_pFile$ = 12						; size = 4
_BuildHashTable PROC					; COMDAT

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 772  : 	char	*pszTokenList = pSaveData->pBaseData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pszTokenList$[ebp], ecx

; 773  : 	int	i;
; 774  : 
; 775  : 	// Parse the symbol table
; 776  : 	if( pSaveData->tokenSize > 0 )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN7@BuildHashT

; 777  : 	{
; 778  : 		FS_Read( pFile, pszTokenList, pSaveData->tokenSize );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pszTokenList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 779  : 
; 780  : 		// make sure the token strings pointed to by the pToken hashtable.
; 781  : 		for( i = 0; i < pSaveData->tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@BuildHashT
$LN2@BuildHashT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@BuildHashT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN7@BuildHashT

; 782  : 		{
; 783  : 			pSaveData->pTokens[i] = *pszTokenList ? pszTokenList : NULL;

	mov	eax, DWORD PTR _pszTokenList$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@BuildHashT
	mov	edx, DWORD PTR _pszTokenList$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN10@BuildHashT
$LN9@BuildHashT:
	mov	DWORD PTR tv79[ebp], 0
$LN10@BuildHashT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN5@BuildHashT:

; 784  : 			while( *pszTokenList++ );	// Find next token (after next null)

	mov	eax, DWORD PTR _pszTokenList$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv83[ebp], ecx
	mov	edx, DWORD PTR _pszTokenList$[ebp]
	add	edx, 1
	mov	DWORD PTR _pszTokenList$[ebp], edx
	cmp	DWORD PTR tv83[ebp], 0
	je	SHORT $LN6@BuildHashT
	jmp	SHORT $LN5@BuildHashT
$LN6@BuildHashT:

; 785  : 		}

	jmp	SHORT $LN2@BuildHashT
$LN7@BuildHashT:

; 786  : 	}
; 787  : 
; 788  : 	// rebase the data pointer
; 789  : 	pSaveData->pBaseData = pszTokenList;	// pszTokenList now points after token data

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pszTokenList$[ebp]
	mov	DWORD PTR [eax], ecx

; 790  : 	pSaveData->pCurrentData = pSaveData->pBaseData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 791  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _StoreHashTable
_TEXT	SEGMENT
tv77 = -80						; size = 4
_pszToken$1 = -12					; size = 4
_i$ = -8						; size = 4
_pTokenData$ = -4					; size = 4
_pSaveData$ = 8						; size = 4
_StoreHashTable PROC					; COMDAT

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 741  : 	char	*pTokenData = pSaveData->pCurrentData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pTokenData$[ebp], ecx

; 742  : 	int	i;
; 743  : 
; 744  : 	// Write entity string token table
; 745  : 	if( pSaveData->pTokens )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN7@StoreHashT

; 746  : 	{
; 747  : 		for( i = 0; i < pSaveData->tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@StoreHashT
$LN2@StoreHashT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@StoreHashT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jge	SHORT $LN7@StoreHashT

; 748  : 		{
; 749  : 			char *pszToken = pSaveData->pTokens[i] ? pSaveData->pTokens[i] : "";

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN9@StoreHashT
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN10@StoreHashT
$LN9@StoreHashT:
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN10@StoreHashT:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _pszToken$1[ebp], ecx
$LN5@StoreHashT:

; 750  : 
; 751  : 			// just copy the token byte-by-byte
; 752  : 			while( *pszToken )

	mov	eax, DWORD PTR _pszToken$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@StoreHashT

; 753  : 				*pSaveData->pCurrentData++ = *pszToken++;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pszToken$1[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _pszToken$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _pszToken$1[ebp], ecx
	jmp	SHORT $LN5@StoreHashT
$LN6@StoreHashT:

; 754  : 			*pSaveData->pCurrentData++ = 0; // Write the term

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 755  : 		}

	jmp	$LN2@StoreHashT
$LN7@StoreHashT:

; 756  : 	}
; 757  : 
; 758  : 	pSaveData->tokenSize = pSaveData->pCurrentData - pTokenData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _pTokenData$[ebp]
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 759  : 
; 760  : 	return pTokenData;

	mov	eax, DWORD PTR _pTokenData$[ebp]

; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_StoreHashTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveFinish
_TEXT	SEGMENT
_pSaveData$ = 8						; size = 4
_SaveFinish PROC					; COMDAT

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 685  : 	if( !pSaveData ) return;

	cmp	DWORD PTR _pSaveData$[ebp], 0
	jne	SHORT $LN2@SaveFinish
	jmp	$LN1@SaveFinish
$LN2@SaveFinish:

; 686  : 
; 687  : 	if( pSaveData->pTokens )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN3@SaveFinish

; 688  : 	{
; 689  : 		Mem_Free( pSaveData->pTokens );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveFinish@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 690  : 		pSaveData->pTokens = NULL;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+24], 0

; 691  : 		pSaveData->tokenCount = 0;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+20], 0
$LN3@SaveFinish:

; 692  : 	}
; 693  : 
; 694  : 	if( pSaveData->pTable )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN4@SaveFinish

; 695  : 	{
; 696  : 		Mem_Free( pSaveData->pTable );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveFinish@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 697  : 		pSaveData->pTable = NULL;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+40], 0

; 698  : 		pSaveData->tableCount = 0;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+32], 0
$LN4@SaveFinish:

; 699  : 	}
; 700  : 
; 701  : 	svgame.globals->pSaveData = NULL;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+160], 0

; 702  : 	Mem_Free( pSaveData );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveFinish@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@SaveFinish:

; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveFinish ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveClear
_TEXT	SEGMENT
_pSaveData$ = 8						; size = 4
_SaveClear PROC						; COMDAT

; 663  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 664  : 	memset( pSaveData->pTokens, 0, pSaveData->tokenCount * sizeof( char* ));

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _pSaveData$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 665  : 
; 666  : 	pSaveData->pBaseData = (char *)(pSaveData + 1); // skip the save structure);

	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 1396				; 00000574H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx], eax

; 667  : 	pSaveData->pCurrentData = pSaveData->pBaseData; // reset the pointer

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 668  : 	pSaveData->time = svgame.globals->time;	// Use DLL time

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _svgame+19268
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1360], edx

; 669  : 	pSaveData->tokenSize = 0;	// reset the hashtable

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+16], 0

; 670  : 	pSaveData->size = 0;	// reset the pointer

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+8], 0

; 671  : 
; 672  : 	// shared with dlls	
; 673  : 	svgame.globals->pSaveData = pSaveData;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+160], ecx

; 674  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveInit
_TEXT	SEGMENT
_pSaveData$ = -4					; size = 4
_size$ = 8						; size = 4
_tokenCount$ = 12					; size = 4
_SaveInit PROC						; COMDAT

; 636  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 637  : 	SAVERESTOREDATA	*pSaveData;
; 638  : 
; 639  : 	pSaveData = Mem_Calloc( host.mempool, sizeof( SAVERESTOREDATA ) + size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveInit@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, 1396				; 00000574H
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pSaveData$[ebp], eax

; 640  : 	pSaveData->pTokens = (char **)Mem_Calloc( host.mempool, tokenCount * sizeof( char* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SaveInit@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 641  : 	pSaveData->tokenCount = tokenCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 642  : 
; 643  : 	pSaveData->pBaseData = (char *)(pSaveData + 1); // skip the save structure);

	mov	eax, DWORD PTR _pSaveData$[ebp]
	add	eax, 1396				; 00000574H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx], eax

; 644  : 	pSaveData->pCurrentData = pSaveData->pBaseData; // reset the pointer

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 645  : 	pSaveData->bufferSize = size;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 646  : 
; 647  : 	pSaveData->time = svgame.globals->time;	// Use DLL time

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _svgame+19268
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+1360], edx

; 648  : 
; 649  : 	// shared with dlls	
; 650  : 	svgame.globals->pSaveData = pSaveData;

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [eax+160], ecx

; 651  : 
; 652  : 	return pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _DirectoryExtract
_TEXT	SEGMENT
_pCopy$ = -536						; size = 4
_fileSize$ = -532					; size = 4
_i$ = -528						; size = 4
_fileName$ = -524					; size = 260
_szName$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_pFile$ = 8						; size = 4
_fileCount$ = 12					; size = 4
_DirectoryExtract PROC					; COMDAT

; 608  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 664				; 00000298H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 609  : 	char	szName[MAX_OSPATH];
; 610  : 	char	fileName[MAX_OSPATH];
; 611  : 	int	i, fileSize;
; 612  : 	file_t	*pCopy;
; 613  : 
; 614  : 	for( i = 0; i < fileCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DirectoryE
$LN2@DirectoryE:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DirectoryE:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fileCount$[ebp]
	jge	$LN1@DirectoryE

; 615  : 	{
; 616  : 		// filename can only be as long as a map name + extension
; 617  : 		FS_Read( pFile, szName, MAX_OSPATH );

	push	260					; 00000104H
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 618  : 		FS_Read( pFile, &fileSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 619  : 		Q_snprintf( fileName, sizeof( fileName ), "%s%s", DEFAULT_SAVE_DIRECTORY, szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 620  : 		COM_FixSlashes( fileName );

	lea	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 621  : 
; 622  : 		pCopy = FS_Open( fileName, "wb", true );

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	lea	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pCopy$[ebp], eax

; 623  : 		FS_FileCopy( pCopy, pFile, fileSize );

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCopy$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 624  : 		FS_Close( pCopy );

	mov	eax, DWORD PTR _pCopy$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 625  : 	}

	jmp	$LN2@DirectoryE
$LN1@DirectoryE:

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryExtract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _DirectoryCopy
_TEXT	SEGMENT
_t$ = -280						; size = 4
_pCopy$ = -276						; size = 4
_fileSize$ = -272					; size = 4
_i$ = -268						; size = 4
_szName$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_pPath$ = 8						; size = 4
_pFile$ = 12						; size = 4
_DirectoryCopy PROC					; COMDAT

; 576  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 577  : 	char	szName[MAX_OSPATH];
; 578  : 	int	i, fileSize;
; 579  : 	file_t	*pCopy;
; 580  : 	search_t	*t;
; 581  : 
; 582  : 	t = FS_Search( pPath, true, true );

	push	1
	push	1
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 583  : 	if( !t ) return; // nothing to copy ?

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@DirectoryC
	jmp	$LN1@DirectoryC
$LN5@DirectoryC:

; 584  : 
; 585  : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DirectoryC
$LN2@DirectoryC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DirectoryC:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN3@DirectoryC

; 586  : 	{
; 587  : 		pCopy = FS_Open( t->filenames[i], "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pCopy$[ebp], eax

; 588  : 		fileSize = FS_FileLength( pCopy );

	mov	eax, DWORD PTR _pCopy$[ebp]
	push	eax
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _fileSize$[ebp], eax

; 589  : 
; 590  : 		memset( szName, 0, sizeof( szName )); // clearing the string to prevent garbage in output file

	push	260					; 00000104H
	push	0
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 591  : 		Q_strncpy( szName, COM_FileWithoutPath( t->filenames[i] ), MAX_OSPATH );		

	push	260					; 00000104H
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_COM_FileWithoutPath
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 592  : 		FS_Write( pFile, szName, MAX_OSPATH );

	push	260					; 00000104H
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 593  : 		FS_Write( pFile, &fileSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 594  : 		FS_FileCopy( pFile, pCopy, fileSize );

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCopy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFile$[ebp]
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 595  : 		FS_Close( pCopy );

	mov	eax, DWORD PTR _pCopy$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 596  : 	}

	jmp	$LN2@DirectoryC
$LN3@DirectoryC:

; 597  : 	Mem_Free( t );

	mov	eax, DWORD PTR ?__LINE__Var@?0??DirectoryCopy@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@DirectoryC:

; 598  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveGetName
_TEXT	SEGMENT
_c$ = -12						; size = 4
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_lastnum$ = 8						; size = 4
_filename$ = 12						; size = 4
_SaveGetName PROC					; COMDAT

; 553  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 554  : 	int	a, b, c;
; 555  : 
; 556  : 	if( lastnum < 0 || lastnum > 999 )

	cmp	DWORD PTR _lastnum$[ebp], 0
	jl	SHORT $LN3@SaveGetNam
	cmp	DWORD PTR _lastnum$[ebp], 999		; 000003e7H
	jle	SHORT $LN2@SaveGetNam
$LN3@SaveGetNam:

; 557  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SaveGetNam
$LN2@SaveGetNam:

; 558  : 
; 559  : 	a = lastnum / 100;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _a$[ebp], eax

; 560  : 	lastnum -= a * 100;

	imul	eax, DWORD PTR _a$[ebp], 100
	mov	ecx, DWORD PTR _lastnum$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lastnum$[ebp], ecx

; 561  : 	b = lastnum / 10;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _b$[ebp], eax

; 562  : 	c = lastnum % 10;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _c$[ebp], edx

; 563  : 
; 564  : 	Q_sprintf( filename, "save%i%i%i", a, b, c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@KBOHAFJO@save?$CFi?$CFi?$CFi@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 565  : 	return true;

	mov	eax, 1
$LN1@SaveGetNam:

; 566  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveGetName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _AgeSaveList
_TEXT	SEGMENT
_oldShot$ = -1044					; size = 260
_newShot$ = -784					; size = 260
_oldName$ = -524					; size = 260
_newName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_pName$ = 8						; size = 4
_count$ = 12						; size = 4
_AgeSaveList PROC					; COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1236				; 000004d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 503  : 	char	newName[MAX_OSPATH], oldName[MAX_OSPATH];
; 504  : 	char	newShot[MAX_OSPATH], oldShot[MAX_OSPATH];
; 505  : 
; 506  : 	// delete last quick/autosave (e.g. quick05.sav)
; 507  : 	Q_snprintf( newName, sizeof( newName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@
	push	260					; 00000104H
	lea	edx, DWORD PTR _newName$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 508  : 	Q_snprintf( newShot, sizeof( newShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@
	push	260					; 00000104H
	lea	edx, DWORD PTR _newShot$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 509  : 
; 510  : 	// only delete from game directory, basedir is read-only
; 511  : 	FS_Delete( newName );

	lea	eax, DWORD PTR _newName$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 512  : 	FS_Delete( newShot );

	lea	eax, DWORD PTR _newShot$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4

; 513  : 
; 514  : 	// unloading the shot footprint
; 515  : 	GL_FreeImage( newShot );

	lea	eax, DWORD PTR _newShot$[ebp]
	push	eax
	call	_GL_FreeImage
	add	esp, 4
$LN2@AgeSaveLis:

; 516  : 
; 517  : 	while( count > 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jle	$LN1@AgeSaveLis

; 518  : 	{
; 519  : 		if( count == 1 )

	cmp	DWORD PTR _count$[ebp], 1
	jne	SHORT $LN4@AgeSaveLis

; 520  : 		{	
; 521  : 			// quick.sav
; 522  : 			Q_snprintf( oldName, sizeof( oldName ), "%s%s.sav", DEFAULT_SAVE_DIRECTORY, pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _oldName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 523  : 			Q_snprintf( oldShot, sizeof( oldShot ), "%s%s.bmp", DEFAULT_SAVE_DIRECTORY, pName );

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08GDJCFMPC@?$CFs?$CFs?4bmp@
	push	260					; 00000104H
	lea	ecx, DWORD PTR _oldShot$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 524  : 		}

	jmp	SHORT $LN5@AgeSaveLis
$LN4@AgeSaveLis:

; 525  : 		else
; 526  : 		{	
; 527  : 			// quick04.sav, etc.
; 528  : 			Q_snprintf( oldName, sizeof( oldName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count - 1 );

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@
	push	260					; 00000104H
	lea	edx, DWORD PTR _oldName$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 529  : 			Q_snprintf( oldShot, sizeof( oldShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count - 1 );

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@
	push	260					; 00000104H
	lea	edx, DWORD PTR _oldShot$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN5@AgeSaveLis:

; 530  : 		}
; 531  : 
; 532  : 		Q_snprintf( newName, sizeof( newName ), "%s%s%02d.sav", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@DBICIDEH@?$CFs?$CFs?$CF02d?4sav@
	push	260					; 00000104H
	lea	edx, DWORD PTR _newName$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 533  : 		Q_snprintf( newShot, sizeof( newShot ), "%s%s%02d.bmp", DEFAULT_SAVE_DIRECTORY, pName, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_0N@IGGHONFP@?$CFs?$CFs?$CF02d?4bmp@
	push	260					; 00000104H
	lea	edx, DWORD PTR _newShot$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 534  : 
; 535  : 		// unloading the oldshot footprint too
; 536  : 		GL_FreeImage( oldShot );

	lea	eax, DWORD PTR _oldShot$[ebp]
	push	eax
	call	_GL_FreeImage
	add	esp, 4

; 537  : 
; 538  : 		// scroll the name list down (e.g. rename quick04.sav to quick05.sav)
; 539  : 		FS_Rename( oldName, newName );

	lea	eax, DWORD PTR _newName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldName$[ebp]
	push	ecx
	call	_FS_Rename
	add	esp, 8

; 540  : 		FS_Rename( oldShot, newShot );

	lea	eax, DWORD PTR _newShot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldShot$[ebp]
	push	ecx
	call	_FS_Rename
	add	esp, 8

; 541  : 		count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 542  : 	}

	jmp	$LN2@AgeSaveLis
$LN1@AgeSaveLis:

; 543  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AgeSaveList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _IsValidSave
_TEXT	SEGMENT
_pl$1 = -4						; size = 4
_IsValidSave PROC					; COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 432  : 	if( !svs.initialized || sv.state != ss_active )

	cmp	DWORD PTR _svs, 0
	je	SHORT $LN3@IsValidSav
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@IsValidSav
$LN3@IsValidSav:

; 433  : 	{
; 434  : 		Con_Printf( "Not playing a local game.\n" );

	push	OFFSET ??_C@_0BL@KICGGNOK@Not?5playing?5a?5local?5game?4?6@
	call	_Con_Printf
	add	esp, 4

; 435  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN2@IsValidSav:

; 436  : 	}
; 437  : 
; 438  : 	// ignore autosave during background
; 439  : 	if( sv.background || UI_CreditsActive( ))

	cmp	DWORD PTR _sv+4, 0
	jne	SHORT $LN5@IsValidSav
	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN4@IsValidSav
$LN5@IsValidSav:

; 440  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN4@IsValidSav:

; 441  : 
; 442  : 	if( svgame.physFuncs.SV_AllowSaveGame != NULL )

	cmp	DWORD PTR _svgame+19512, 0
	je	SHORT $LN7@IsValidSav

; 443  : 	{
; 444  : 		if( !svgame.physFuncs.SV_AllowSaveGame( ))

	call	DWORD PTR _svgame+19512
	test	eax, eax
	jne	SHORT $LN7@IsValidSav

; 445  : 		{
; 446  : 			Con_Printf( "Savegame is not allowed.\n" );

	push	OFFSET ??_C@_0BK@EFJOCHLD@Savegame?5is?5not?5allowed?4?6@
	call	_Con_Printf
	add	esp, 4

; 447  : 			return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN7@IsValidSav:

; 448  : 		}
; 449  : 	}
; 450  : 
; 451  : 	if( !CL_Active( ))

	call	_CL_Active
	test	eax, eax
	jne	SHORT $LN8@IsValidSav

; 452  : 	{
; 453  : 		Con_Printf( "Can't save if not active.\n" );

	push	OFFSET ??_C@_0BL@PCAKHPIK@Can?8t?5save?5if?5not?5active?4?6@
	call	_Con_Printf
	add	esp, 4

; 454  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN8@IsValidSav:

; 455  : 	}
; 456  : 
; 457  : 	if( CL_IsIntermission( ))

	call	_CL_IsIntermission
	test	eax, eax
	je	SHORT $LN9@IsValidSav

; 458  : 	{
; 459  : 		Con_Printf( "Can't save during intermission.\n" );

	push	OFFSET ??_C@_0CB@MHEJFOP@Can?8t?5save?5during?5intermission?4@
	call	_Con_Printf
	add	esp, 4

; 460  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN9@IsValidSav:

; 461  : 	}
; 462  : 
; 463  : 	if( svs.maxclients != 1 )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN10@IsValidSav

; 464  : 	{
; 465  : 		Con_Printf( "Can't save multiplayer games.\n" );

	push	OFFSET ??_C@_0BP@OJOGGEDC@Can?8t?5save?5multiplayer?5games?4?6@
	call	_Con_Printf
	add	esp, 4

; 466  : 		return 0;

	xor	eax, eax
	jmp	$LN1@IsValidSav
$LN10@IsValidSav:

; 467  : 	}
; 468  : 
; 469  : 	if( svs.clients && svs.clients[0].state == cs_spawned )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN11@IsValidSav
	mov	eax, 289832				; 00046c28H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svs+33344
	cmp	DWORD PTR [edx+ecx], 3
	jne	SHORT $LN11@IsValidSav

; 470  : 	{
; 471  : 		edict_t	*pl = svs.clients[0].edict;

	mov	eax, 289832				; 00046c28H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svs+33344
	mov	eax, DWORD PTR [edx+ecx+264948]
	mov	DWORD PTR _pl$1[ebp], eax

; 472  : 		
; 473  : 		if( !pl )

	cmp	DWORD PTR _pl$1[ebp], 0
	jne	SHORT $LN12@IsValidSav

; 474  : 		{
; 475  : 			Con_Printf( "Can't savegame without a player!\n" );

	push	OFFSET ??_C@_0CC@LHOAAJLL@Can?8t?5savegame?5without?5a?5player@
	call	_Con_Printf
	add	esp, 4

; 476  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsValidSav
$LN12@IsValidSav:

; 477  : 		}
; 478  : 			
; 479  : 		if( pl->v.deadflag || pl->v.health <= 0.0f )

	mov	eax, DWORD PTR _pl$1[ebp]
	cmp	DWORD PTR [eax+604], 0
	jne	SHORT $LN14@IsValidSav
	mov	eax, DWORD PTR _pl$1[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+520]
	jb	SHORT $LN13@IsValidSav
$LN14@IsValidSav:

; 480  : 		{
; 481  : 			Con_Printf( "Can't savegame with a dead player\n" );

	push	OFFSET ??_C@_0CD@KOPDJNFI@Can?8t?5savegame?5with?5a?5dead?5play@
	call	_Con_Printf
	add	esp, 4

; 482  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsValidSav
$LN13@IsValidSav:

; 483  : 		}
; 484  : 
; 485  : 		// Passed all checks, it's ok to save
; 486  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsValidSav
$LN11@IsValidSav:

; 487  : 	}
; 488  : 
; 489  : 	Con_Printf( "Can't savegame without a client!\n" );

	push	OFFSET ??_C@_0CC@DHONJFEF@Can?8t?5savegame?5without?5a?5client@
	call	_Con_Printf
	add	esp, 4

; 490  : 
; 491  : 	return 0;

	xor	eax, eax
$LN1@IsValidSav:

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsValidSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _ClearSaveDir
_TEXT	SEGMENT
_i$ = -8						; size = 4
_t$ = -4						; size = 4
_ClearSaveDir PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 410  : 	search_t	*t;
; 411  : 	int	i;
; 412  : 
; 413  : 	// just delete all HL? files
; 414  : 	t = FS_Search( va( "%s*.HL?", DEFAULT_SAVE_DIRECTORY ), true, true );

	push	1
	push	1
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_07FBPDBPGN@?$CFs?$CK?4HL?$DP@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 415  : 	if( !t ) return; // already empty

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@ClearSaveD
	jmp	SHORT $LN1@ClearSaveD
$LN5@ClearSaveD:

; 416  : 
; 417  : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ClearSaveD
$LN2@ClearSaveD:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@ClearSaveD:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@ClearSaveD

; 418  : 		FS_Delete( t->filenames[i] );

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_Delete
	add	esp, 4
	jmp	SHORT $LN2@ClearSaveD
$LN3@ClearSaveD:

; 419  : 
; 420  : 	Mem_Free( t );

	mov	eax, DWORD PTR ?__LINE__Var@?0??ClearSaveDir@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@ClearSaveD:

; 421  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ClearSaveDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _EntityInSolid
_TEXT	SEGMENT
tv151 = -88						; size = 4
tv146 = -88						; size = 4
_point$ = -20						; size = 12
_aiment$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_EntityInSolid PROC					; COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 387  : 	edict_t	*aiment = pent->v.aiment;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	DWORD PTR _aiment$[ebp], ecx

; 388  : 	vec3_t	point;
; 389  : 
; 390  : 	// if you're attached to a client, always go through
; 391  : 	if( pent->v.movetype == MOVETYPE_FOLLOW && SV_IsValidEdict( aiment ) && FBitSet( aiment->v.flags, FL_CLIENT ))

	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+396], 12			; 0000000cH
	jne	SHORT $LN2@EntityInSo
	mov	eax, DWORD PTR ?__LINE__Var@?0??EntityInSolid@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _aiment$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@EntityInSo
	mov	eax, DWORD PTR _aiment$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN2@EntityInSo

; 392  : 		return 0;

	xor	eax, eax
	jmp	$LN1@EntityInSo
$LN2@EntityInSo:

; 393  : 
; 394  : 	VectorAverage( pent->v.absmin, pent->v.absmax, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pent$[ebp]
	mov	esi, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	addss	xmm0, DWORD PTR [esi+ecx+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv146[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 395  : 	svs.groupmask = pent->v.groupinfo;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 396  : 
; 397  : 	return (SV_PointContents( point ) == CONTENTS_SOLID);

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN4@EntityInSo
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN5@EntityInSo
$LN4@EntityInSo:
	mov	DWORD PTR tv151[ebp], 0
$LN5@EntityInSo:
	mov	eax, DWORD PTR tv151[ebp]
$LN1@EntityInSo:

; 398  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_EntityInSolid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _LandmarkOrigin
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_output$ = 12						; size = 4
_pLandmarkName$ = 16					; size = 4
_LandmarkOrigin PROC					; COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 363  : 	int	i;
; 364  : 
; 365  : 	for( i = 0; i < pSaveData->connectionCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@LandmarkOr
$LN2@LandmarkOr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@LandmarkOr:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	$LN3@LandmarkOr

; 366  : 	{
; 367  : 		if( !Q_strcmp( pSaveData->levelList[i].landmarkName, pLandmarkName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pLandmarkName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	mov	edx, DWORD PTR _pSaveData$[ebp]
	lea	eax, DWORD PTR [edx+ecx+76]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@LandmarkOr

; 368  : 		{
; 369  : 			VectorCopy( pSaveData->levelList[i].vecLandmarkOrigin, output );

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	lea	edx, DWORD PTR [ecx+eax+44]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+68]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _pSaveData$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+68]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _i$[ebp], 80
	mov	eax, DWORD PTR _pSaveData$[ebp]
	lea	ecx, DWORD PTR [eax+edx+44]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+68]
	mov	DWORD PTR [esi+eax], ecx

; 370  : 			return;

	jmp	SHORT $LN1@LandmarkOr
$LN5@LandmarkOr:

; 371  : 		}
; 372  : 	}

	jmp	$LN2@LandmarkOr
$LN3@LandmarkOr:

; 373  : 
; 374  : 	VectorClear( output );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _output$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN1@LandmarkOr:

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LandmarkOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _EdictFromTable
_TEXT	SEGMENT
tv74 = -72						; size = 4
tv73 = -68						; size = 4
_pSaveData$ = 8						; size = 4
_entityIndex$ = 12					; size = 4
_EdictFromTable PROC					; COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 345  : 	if( pSaveData && pSaveData->pTable )

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN2@EdictFromT
	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN2@EdictFromT

; 346  : 	{
; 347  : 		entityIndex = bound( 0, entityIndex, pSaveData->tableCount - 1 );

	cmp	DWORD PTR _entityIndex$[ebp], 0
	jl	SHORT $LN6@EdictFromT
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sub	ecx, 1
	cmp	DWORD PTR _entityIndex$[ebp], ecx
	jge	SHORT $LN4@EdictFromT
	mov	edx, DWORD PTR _entityIndex$[ebp]
	mov	DWORD PTR tv73[ebp], edx
	jmp	SHORT $LN5@EdictFromT
$LN4@EdictFromT:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sub	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
$LN5@EdictFromT:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN7@EdictFromT
$LN6@EdictFromT:
	mov	DWORD PTR tv74[ebp], 0
$LN7@EdictFromT:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _entityIndex$[ebp], eax

; 348  : 		return pSaveData->pTable[entityIndex].pent;

	imul	eax, DWORD PTR _entityIndex$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN1@EdictFromT
$LN2@EdictFromT:

; 349  : 	}
; 350  : 
; 351  : 	return NULL;

	xor	eax, eax
$LN1@EdictFromT:

; 352  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_EdictFromTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _EntryInTable
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_pMapName$ = 12						; size = 4
_index$ = 16						; size = 4
_EntryInTable PROC					; COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 325  : 	int	i;
; 326  : 
; 327  : 	for( i = index + 1; i < pSaveData->connectionCount; i++ )

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@EntryInTab
$LN2@EntryInTab:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@EntryInTab:
	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	SHORT $LN3@EntryInTab

; 328  : 	{
; 329  : 		if ( !Q_stricmp( pSaveData->levelList[i].mapName, pMapName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pMapName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 80
	mov	edx, DWORD PTR _pSaveData$[ebp]
	lea	eax, DWORD PTR [edx+ecx+44]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@EntryInTab

; 330  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@EntryInTab
$LN5@EntryInTab:

; 331  : 	}

	jmp	SHORT $LN2@EntryInTab
$LN3@EntryInTab:

; 332  : 
; 333  : 	return -1;

	or	eax, -1
$LN1@EntryInTab:

; 334  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_EntryInTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _InitEntityTable
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pTable$ = -4						; size = 4
_pSaveData$ = 8						; size = 4
_entityCount$ = 12					; size = 4
_InitEntityTable PROC					; COMDAT

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 301  : 	ENTITYTABLE	*pTable;
; 302  : 	int		i;
; 303  : 
; 304  : 	pSaveData->pTable = Mem_Calloc( host.mempool, sizeof( ENTITYTABLE ) * entityCount );

	mov	eax, DWORD PTR ?__LINE__Var@?0??InitEntityTable@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _entityCount$[ebp], 24
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 305  : 	pSaveData->tableCount = entityCount;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	ecx, DWORD PTR _entityCount$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 306  : 
; 307  : 	// setup entitytable
; 308  : 	for( i = 0; i < entityCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@InitEntity
$LN2@InitEntity:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@InitEntity:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _entityCount$[ebp]
	jge	SHORT $LN1@InitEntity

; 309  : 	{
; 310  : 		pTable = &pSaveData->pTable[i];

	imul	eax, DWORD PTR _i$[ebp], 24
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _pTable$[ebp], eax

; 311  : 		pTable->pent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	ecx, DWORD PTR _pTable$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 312  : 		pTable->id = i;

	mov	eax, DWORD PTR _pTable$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 313  : 	}

	jmp	SHORT $LN2@InitEntity
$LN1@InitEntity:

; 314  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_InitEntityTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _DirectoryCount
_TEXT	SEGMENT
_t$ = -8						; size = 4
_count$ = -4						; size = 4
_pPath$ = 8						; size = 4
_DirectoryCount PROC					; COMDAT

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 280  : 	int	count;
; 281  : 	search_t	*t;
; 282  : 
; 283  : 	t = FS_Search( pPath, true, true );	// lookup only in gamedir

	push	1
	push	1
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax

; 284  : 	if( !t ) return 0; // empty

	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN2@DirectoryC
	xor	eax, eax
	jmp	SHORT $LN1@DirectoryC
$LN2@DirectoryC:

; 285  : 
; 286  : 	count = t->numfilenames;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _count$[ebp], ecx

; 287  : 	Mem_Free( t );

	mov	eax, DWORD PTR ?__LINE__Var@?0??DirectoryCount@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 288  : 
; 289  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@DirectoryC:

; 290  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DirectoryCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SaveBuildComment
_TEXT	SEGMENT
_pName$ = -4						; size = 4
_text$ = 8						; size = 4
_maxlength$ = 12					; size = 4
_SaveBuildComment PROC					; COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 244  : 	const char	*pName;
; 245  : 
; 246  : 	text[0] = '\0'; // clear

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 247  : 
; 248  : 	if( pfnSaveGameComment != NULL )

	cmp	DWORD PTR _pfnSaveGameComment, 0
	je	SHORT $LN2@SaveBuildC

; 249  : 	{
; 250  : 		// get save comment from gamedll
; 251  : 		pfnSaveGameComment( text, maxlength );

	mov	eax, DWORD PTR _maxlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR _pfnSaveGameComment
	add	esp, 8

; 252  : 	}

	jmp	$LN3@SaveBuildC
$LN2@SaveBuildC:

; 253  : 	else
; 254  : 	{
; 255  : 		if( svgame.edicts->v.message != 0 )

	mov	eax, DWORD PTR _svgame+7928
	cmp	DWORD PTR [eax+692], 0
	je	SHORT $LN4@SaveBuildC

; 256  : 		{
; 257  : 			// trying to extract message from the world
; 258  : 			pName = STRING( svgame.edicts->v.message );

	mov	eax, DWORD PTR _svgame+7928
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pName$[ebp], eax

; 259  : 		}

	jmp	SHORT $LN5@SaveBuildC
$LN4@SaveBuildC:

; 260  : 		else
; 261  : 		{
; 262  : 			// or use mapname
; 263  : 			pName = STRING( svgame.globals->mapname );

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	mov	DWORD PTR _pName$[ebp], eax
$LN5@SaveBuildC:

; 264  : 		}
; 265  : 
; 266  : 		Q_snprintf( text, maxlength, "%-64.64s %02d:%02d", pName, (int)(sv.time / 60.0 ), (int)fmod( sv.time, 60.0 ));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _sv+16
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	push	eax
	movsd	xmm0, QWORD PTR _sv+16
	divsd	xmm0, QWORD PTR __real@404e000000000000
	cvttsd2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@EJBAAKHO@?$CF?964?464s?5?$CF02d?3?$CF02d@
	mov	edx, DWORD PTR _maxlength$[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H
$LN3@SaveBuildC:

; 267  : 	}
; 268  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SaveBuildComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_ClearGameState
_TEXT	SEGMENT
_SV_ClearGameState PROC					; COMDAT

; 1964 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1965 : 	ClearSaveDir();

	call	_ClearSaveDir

; 1966 : 
; 1967 : 	if( svgame.dllFuncs.pfnResetGlobalState != NULL )

	cmp	DWORD PTR _svgame+19328, 0
	je	SHORT $LN1@SV_ClearGa

; 1968 : 		svgame.dllFuncs.pfnResetGlobalState();

	call	DWORD PTR _svgame+19328
$LN1@SV_ClearGa:

; 1969 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClearGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_InitSaveRestore
_TEXT	SEGMENT
_SV_InitSaveRestore PROC				; COMDAT

; 2393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2394 : 	pfnSaveGameComment = COM_GetProcAddress( svgame.hInstance, "SV_SaveGameComment" );

	push	OFFSET ??_C@_0BD@DIIDBMKG@SV_SaveGameComment@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _pfnSaveGameComment, eax

; 2395 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitSaveRestore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_GetLatestSave
_TEXT	SEGMENT
_t$ = -20						; size = 4
_found$ = -16						; size = 4
_i$ = -12						; size = 4
_ft$ = -8						; size = 4
_newest$ = -4						; size = 4
_SV_GetLatestSave PROC					; COMDAT

; 2168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2169 : 	static char	savename[MAX_QPATH];
; 2170 : 	long		newest = 0, ft;

	mov	DWORD PTR _newest$[ebp], 0

; 2171 : 	int		i, found = 0;

	mov	DWORD PTR _found$[ebp], 0

; 2172 : 	search_t		*t;
; 2173 : 
; 2174 : 	if(( t = FS_Search( va( "%s*.sav", DEFAULT_SAVE_DIRECTORY ), true, true )) == NULL )

	push	1
	push	1
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_07GHPHEBDC@?$CFs?$CK?4sav@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t$[ebp], eax
	cmp	DWORD PTR _t$[ebp], 0
	jne	SHORT $LN5@SV_GetLate

; 2175 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_GetLate
$LN5@SV_GetLate:

; 2176 : 
; 2177 : 	for( i = 0; i < t->numfilenames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetLate
$LN2@SV_GetLate:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetLate:
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@SV_GetLate

; 2178 : 	{
; 2179 : 		ft = FS_FileTime( t->filenames[i], true );

	push	1
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft$[ebp], eax

; 2180 : 		
; 2181 : 		// found a match?
; 2182 : 		if( ft > 0 )

	cmp	DWORD PTR _ft$[ebp], 0
	jle	SHORT $LN6@SV_GetLate

; 2183 : 		{
; 2184 : 			// should we use the matched?
; 2185 : 			if( !found || Host_CompareFileTime( newest, ft ) < 0 )

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN8@SV_GetLate
	mov	eax, DWORD PTR _ft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newest$[ebp]
	push	ecx
	call	_Host_CompareFileTime
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN6@SV_GetLate
$LN8@SV_GetLate:

; 2186 : 			{
; 2187 : 				Q_strncpy( savename, t->filenames[i], sizeof( savename ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	OFFSET ?savename@?1??SV_GetLatestSave@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2188 : 				newest = ft;

	mov	eax, DWORD PTR _ft$[ebp]
	mov	DWORD PTR _newest$[ebp], eax

; 2189 : 				found = 1;

	mov	DWORD PTR _found$[ebp], 1
$LN6@SV_GetLate:

; 2190 : 			}
; 2191 : 		}
; 2192 : 	}

	jmp	SHORT $LN2@SV_GetLate
$LN3@SV_GetLate:

; 2193 : 
; 2194 : 	Mem_Free( t ); // release search

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetLatestSave@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2195 : 
; 2196 : 	if( found )

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $LN9@SV_GetLate

; 2197 : 		return savename;

	mov	eax, OFFSET ?savename@?1??SV_GetLatestSave@@9@9
	jmp	SHORT $LN1@SV_GetLate
$LN9@SV_GetLate:

; 2198 : 	return NULL; 

	xor	eax, eax
$LN1@SV_GetLate:

; 2199 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetLatestSave ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_ChangeLevel
_TEXT	SEGMENT
_pSaveData$ = -204					; size = 4
_startspot$ = -200					; size = 4
__startspot$ = -196					; size = 64
_oldlevel$ = -132					; size = 64
_level$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_loadfromsavedgame$ = 8					; size = 4
_mapname$ = 12						; size = 4
_start$ = 16						; size = 4
_background$ = 20					; size = 4
_SV_ChangeLevel PROC					; COMDAT

; 1977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1978 : 	char		level[MAX_QPATH];
; 1979 : 	char		oldlevel[MAX_QPATH];
; 1980 : 	char		_startspot[MAX_QPATH];
; 1981 : 	char		*startspot = NULL;

	mov	DWORD PTR _startspot$[ebp], 0

; 1982 : 	SAVERESTOREDATA	*pSaveData = NULL;

	mov	DWORD PTR _pSaveData$[ebp], 0

; 1983 : 	
; 1984 : 	if( sv.state != ss_active )

	cmp	DWORD PTR _sv, 2
	je	SHORT $LN2@SV_ChangeL

; 1985 : 	{
; 1986 : 		Con_Printf( S_ERROR "server not running\n");

	push	OFFSET ??_C@_0BP@DMLDFIPP@?$FO1Error?3?$FO7?5server?5not?5running?6@
	call	_Con_Printf
	add	esp, 4

; 1987 : 		return;

	jmp	$LN7@SV_ChangeL
$LN2@SV_ChangeL:

; 1988 : 	}
; 1989 : 
; 1990 : 	if( start )

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN3@SV_ChangeL

; 1991 : 	{
; 1992 : 		Q_strncpy( _startspot, start, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR __startspot$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1993 : 		startspot = _startspot;

	lea	eax, DWORD PTR __startspot$[ebp]
	mov	DWORD PTR _startspot$[ebp], eax
$LN3@SV_ChangeL:

; 1994 : 	}
; 1995 : 
; 1996 : 	Q_strncpy( level, mapname, MAX_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _mapname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _level$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1997 : 	Q_strncpy( oldlevel, sv.name, MAX_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	lea	eax, DWORD PTR _oldlevel$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1998 : 
; 1999 : 	if( loadfromsavedgame )

	cmp	DWORD PTR _loadfromsavedgame$[ebp], 0
	je	SHORT $LN4@SV_ChangeL

; 2000 : 	{
; 2001 : 		// smooth transition in-progress
; 2002 : 		svgame.globals->changelevel = true;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+136], 1

; 2003 : 
; 2004 : 		// save the current level's state
; 2005 : 		pSaveData = SaveGameState( true );

	push	1
	call	_SaveGameState
	add	esp, 4
	mov	DWORD PTR _pSaveData$[ebp], eax
$LN4@SV_ChangeL:

; 2006 : 	}
; 2007 : 
; 2008 : 	SV_InactivateClients ();

	call	_SV_InactivateClients

; 2009 : 	SV_FinalMessage( "", true );

	push	1
	push	OFFSET ??_C@_00CNPNBAHC@@
	call	_SV_FinalMessage
	add	esp, 8

; 2010 : 	SV_DeactivateServer ();

	call	_SV_DeactivateServer

; 2011 : 
; 2012 : 	if( !SV_SpawnServer( level, startspot, background ))

	mov	eax, DWORD PTR _background$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startspot$[ebp]
	push	ecx
	lea	edx, DWORD PTR _level$[ebp]
	push	edx
	call	_SV_SpawnServer
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_ChangeL

; 2013 : 		return;	// ???

	jmp	$LN7@SV_ChangeL
$LN5@SV_ChangeL:

; 2014 : 
; 2015 : 	if( loadfromsavedgame )

	cmp	DWORD PTR _loadfromsavedgame$[ebp], 0
	je	SHORT $LN6@SV_ChangeL

; 2016 : 	{
; 2017 : 		// finish saving gamestate
; 2018 : 		SaveFinish( pSaveData );

	mov	eax, DWORD PTR _pSaveData$[ebp]
	push	eax
	call	_SaveFinish
	add	esp, 4

; 2019 : 
; 2020 : 		if( !LoadGameState( level, true ))

	push	1
	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_LoadGameState
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@SV_ChangeL

; 2021 : 			SV_SpawnEntities( level );

	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_SV_SpawnEntities
	add	esp, 4
$LN8@SV_ChangeL:

; 2022 : 		LoadAdjacentEnts( oldlevel, startspot );

	mov	eax, DWORD PTR _startspot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldlevel$[ebp]
	push	ecx
	call	_LoadAdjacentEnts
	add	esp, 8

; 2023 : 
; 2024 : 		if( sv_newunit.value )

	movss	xmm0, DWORD PTR _sv_newunit+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@SV_ChangeL

; 2025 : 			ClearSaveDir();

	call	_ClearSaveDir
$LN9@SV_ChangeL:

; 2026 : 		SV_ActivateServer( false );

	push	0
	call	_SV_ActivateServer
	add	esp, 4

; 2027 : 	}

	jmp	SHORT $LN7@SV_ChangeL
$LN6@SV_ChangeL:

; 2028 : 	else
; 2029 : 	{
; 2030 : 		// classic quake changelevel
; 2031 : 		svgame.dllFuncs.pfnResetGlobalState();

	call	DWORD PTR _svgame+19328

; 2032 : 		SV_SpawnEntities( level );

	lea	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_SV_SpawnEntities
	add	esp, 4

; 2033 : 		SV_ActivateServer( true );

	push	1
	call	_SV_ActivateServer
	add	esp, 4
$LN7@SV_ChangeL:

; 2034 : 	}
; 2035 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ChangeLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_LoadGameState
_TEXT	SEGMENT
_level$ = 8						; size = 4
_SV_LoadGameState PROC					; COMDAT

; 1952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1953 : 	return LoadGameState( level, false );

	push	0
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	call	_LoadGameState
	add	esp, 8

; 1954 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadGameState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_LoadGame
_TEXT	SEGMENT
_flags$ = -132						; size = 4
_pFile$ = -128						; size = 4
_gameHeader$ = -124					; size = 116
_validload$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pPath$ = 8						; size = 4
_SV_LoadGame PROC					; COMDAT

; 2043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2044 : 	qboolean		validload = false;

	mov	DWORD PTR _validload$[ebp], 0

; 2045 : 	GAME_HEADER	gameHeader;
; 2046 : 	file_t		*pFile;
; 2047 : 	int		flags;
; 2048 : 
; 2049 : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@SV_LoadGam

; 2050 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN2@SV_LoadGam:

; 2051 : 
; 2052 : 	if( UI_CreditsActive( ))

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN3@SV_LoadGam

; 2053 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN3@SV_LoadGam:

; 2054 : 
; 2055 : 	if( !COM_CheckString( pPath ))

	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@SV_LoadGam

; 2056 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN4@SV_LoadGam:

; 2057 : 
; 2058 : 	// silently ignore if missed
; 2059 : 	if( !FS_FileExists( pPath, true ))

	push	1
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@SV_LoadGam

; 2060 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN5@SV_LoadGam:

; 2061 : 
; 2062 : 	// initialize game if needs
; 2063 : 	if( !SV_InitGame( ))

	call	_SV_InitGame
	test	eax, eax
	jne	SHORT $LN6@SV_LoadGam

; 2064 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_LoadGam
$LN6@SV_LoadGam:

; 2065 : 
; 2066 : 	pFile = FS_Open( pPath, "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFile$[ebp], eax

; 2067 : 
; 2068 : 	if( pFile )

	cmp	DWORD PTR _pFile$[ebp], 0
	je	$LN11@SV_LoadGam

; 2069 : 	{
; 2070 : 		SV_ClearGameState();

	call	_SV_ClearGameState

; 2071 : 
; 2072 : 		if( SaveReadHeader( pFile, &gameHeader ))

	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_SaveReadHeader
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@SV_LoadGam

; 2073 : 		{
; 2074 : 			DirectoryExtract( pFile, gameHeader.mapCount );

	mov	eax, DWORD PTR _gameHeader$[ebp+112]
	push	eax
	mov	ecx, DWORD PTR _pFile$[ebp]
	push	ecx
	call	_DirectoryExtract
	add	esp, 8

; 2075 : 			validload = true;

	mov	DWORD PTR _validload$[ebp], 1
$LN8@SV_LoadGam:

; 2076 : 		}
; 2077 : 		FS_Close( pFile );

	mov	eax, DWORD PTR _pFile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2078 : 
; 2079 : 		if( validload )

	cmp	DWORD PTR _validload$[ebp], 0
	je	SHORT $LN11@SV_LoadGam

; 2080 : 		{
; 2081 : 			// now check for map problems
; 2082 : 			flags = SV_MapIsValid( gameHeader.mapName, GI->sp_entity, NULL );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 1304				; 00000518H
	push	eax
	lea	ecx, DWORD PTR _gameHeader$[ebp]
	push	ecx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$[ebp], eax

; 2083 : 
; 2084 : 			if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN10@SV_LoadGam

; 2085 : 			{
; 2086 : 				Con_Printf( S_ERROR "map %s is invalid or not supported\n", gameHeader.mapName );

	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@BJKGLKEH@?$FO1Error?3?$FO7?5map?5?$CFs?5is?5invalid?5or@
	call	_Con_Printf
	add	esp, 8

; 2087 : 				validload = false;

	mov	DWORD PTR _validload$[ebp], 0
$LN10@SV_LoadGam:

; 2088 : 			}
; 2089 : 	
; 2090 : 			if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	jne	SHORT $LN11@SV_LoadGam

; 2091 : 			{
; 2092 : 				Con_Printf( S_ERROR "map %s doesn't exist\n", gameHeader.mapName );

	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@PJOLFLJM@?$FO1Error?3?$FO7?5map?5?$CFs?5doesn?8t?5exist@
	call	_Con_Printf
	add	esp, 8

; 2093 : 				validload = false;

	mov	DWORD PTR _validload$[ebp], 0
$LN11@SV_LoadGam:

; 2094 : 			}
; 2095 : 		}
; 2096 : 	}
; 2097 : 
; 2098 : 	if( !validload )

	cmp	DWORD PTR _validload$[ebp], 0
	jne	SHORT $LN12@SV_LoadGam

; 2099 : 	{
; 2100 : 		Con_Printf( S_ERROR "Couldn't load %s\n", pPath );

	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@GBANCDI@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 2101 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_LoadGam
$LN12@SV_LoadGam:

; 2102 : 	}
; 2103 : 
; 2104 : 	Con_Printf( "Loading game from %s...\n", pPath );

	mov	eax, DWORD PTR _pPath$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@GCHLOBJE@Loading?5game?5from?5?$CFs?4?4?4?6@
	call	_Con_Printf
	add	esp, 8

; 2105 : 	Cvar_FullSet( "maxplayers", "1", FCVAR_LATCH );

	push	2048					; 00000800H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0L@PCNFODNF@maxplayers@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 2106 : 	Cvar_SetValue( "deathmatch", 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@ILDAINPG@deathmatch@
	call	_Cvar_SetValue
	add	esp, 8

; 2107 : 	Cvar_SetValue( "coop", 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_04OILOBHMB@coop@
	call	_Cvar_SetValue
	add	esp, 8

; 2108 : 	COM_LoadGame( gameHeader.mapName );

	lea	eax, DWORD PTR _gameHeader$[ebp]
	push	eax
	call	_COM_LoadGame
	add	esp, 4

; 2109 : 
; 2110 : 	return true;

	mov	eax, 1
$LN1@SV_LoadGam:

; 2111 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LoadGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_SaveGame
_TEXT	SEGMENT
_savename$ = -348					; size = 256
_result$ = -92						; size = 4
_n$ = -88						; size = 4
_comment$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_pName$ = 8						; size = 4
_SV_SaveGame PROC					; COMDAT

; 2119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2120 : 	char	comment[80];
; 2121 : 	int	n, result;
; 2122 : 	string	savename;
; 2123 : 
; 2124 : 	if( !COM_CheckString( pName ))

	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@SV_SaveGam

; 2125 : 		return;

	jmp	$LN1@SV_SaveGam
$LN5@SV_SaveGam:

; 2126 : 
; 2127 : 	// can we save at this point?
; 2128 : 	if( !IsValidSave( )) return;

	call	_IsValidSave
	test	eax, eax
	jne	SHORT $LN6@SV_SaveGam
	jmp	$LN1@SV_SaveGam
$LN6@SV_SaveGam:

; 2129 : 
; 2130 : 	if( !Q_stricmp( pName, "new" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03CLCAEGCJ@new@
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SV_SaveGam

; 2131 : 	{
; 2132 : 		// scan for a free filename
; 2133 : 		for( n = 0; n < 1000; n++ )

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@SV_SaveGam
$LN2@SV_SaveGam:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN4@SV_SaveGam:
	cmp	DWORD PTR _n$[ebp], 1000		; 000003e8H
	jge	SHORT $LN3@SV_SaveGam

; 2134 : 		{
; 2135 : 			if( !SaveGetName( n, savename ))

	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_SaveGetName
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SV_SaveGam

; 2136 : 				return;

	jmp	$LN1@SV_SaveGam
$LN9@SV_SaveGam:

; 2137 : 
; 2138 : 			if( !FS_FileExists( va( "%s%s.sav", DEFAULT_SAVE_DIRECTORY, savename ), true ))

	push	1
	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08NEHHDCOK@?$CFs?$CFs?4sav@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@SV_SaveGam

; 2139 : 				break;

	jmp	SHORT $LN3@SV_SaveGam
$LN10@SV_SaveGam:

; 2140 : 		}

	jmp	SHORT $LN2@SV_SaveGam
$LN3@SV_SaveGam:

; 2141 : 
; 2142 : 		if( n == 1000 )

	cmp	DWORD PTR _n$[ebp], 1000		; 000003e8H
	jne	SHORT $LN11@SV_SaveGam

; 2143 : 		{
; 2144 : 			Con_Printf( S_ERROR "no free slots for savegame\n" );

	push	OFFSET ??_C@_0CH@JBIKANLA@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5sa@
	call	_Con_Printf
	add	esp, 4

; 2145 : 			return;

	jmp	SHORT $LN1@SV_SaveGam
$LN11@SV_SaveGam:

; 2146 : 		}
; 2147 : 	}

	jmp	SHORT $LN8@SV_SaveGam
$LN7@SV_SaveGam:

; 2148 : 	else Q_strncpy( savename, pName, sizeof( savename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _savename$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@SV_SaveGam:

; 2149 : 
; 2150 : 	// unload previous image from memory (it's will be overwritten)
; 2151 : 	GL_FreeImage( va( "%s%s.bmp", DEFAULT_SAVE_DIRECTORY, savename ));

	lea	eax, DWORD PTR _savename$[ebp]
	push	eax
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08GDJCFMPC@?$CFs?$CFs?4bmp@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_GL_FreeImage
	add	esp, 4

; 2152 : 
; 2153 : 	SaveBuildComment( comment, sizeof( comment ));

	push	80					; 00000050H
	lea	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_SaveBuildComment
	add	esp, 8

; 2154 : 	result = SaveGameSlot( savename, comment );

	lea	eax, DWORD PTR _comment$[ebp]
	push	eax
	lea	ecx, DWORD PTR _savename$[ebp]
	push	ecx
	call	_SaveGameSlot
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax

; 2155 : 
; 2156 : 	if( result && !FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN1@SV_SaveGam
	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	jne	SHORT $LN1@SV_SaveGam

; 2157 : 		CL_HudMessage( "GAMESAVED" ); // defined in titles.txt

	push	OFFSET ??_C@_09OOPKIPAC@GAMESAVED@
	call	_CL_HudMessage
	add	esp, 4
$LN1@SV_SaveGam:

; 2158 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SaveGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesLeft PROC				; COMDAT

; 108  : _inline int MSG_GetNumBytesLeft( sizebuf_t *sb ) { return MSG_GetNumBitsLeft( sb ) >> 3; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_save.c
;	COMDAT _SV_GetSaveComment
_TEXT	SEGMENT
tv186 = -972						; size = 4
tv182 = -972						; size = 4
$T1 = -968						; size = 4
_flags$2 = -836						; size = 4
_timestring$3 = -832					; size = 256
_file_tm$4 = -576					; size = 4
_fileTime$5 = -572					; size = 8
_f$ = -564						; size = 4
_description$ = -560					; size = 256
_mapName$ = -304					; size = 256
_pTokenList$ = -48					; size = 4
_pFieldName$ = -44					; size = 4
_pSaveData$ = -40					; size = 4
_pData$ = -36						; size = 4
_tokenCount$ = -32					; size = 4
_tokenSize$ = -28					; size = 4
_nFieldSize$ = -24					; size = 4
_nNumberOfFields$ = -20					; size = 4
_size$ = -16						; size = 4
_tag$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_savename$ = 8						; size = 4
_comment$ = 12						; size = 4
_SV_GetSaveComment PROC					; COMDAT

; 2209 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 972				; 000003ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2210 : 	int	i, tag, size, nNumberOfFields, nFieldSize, tokenSize, tokenCount;
; 2211 : 	char	*pData, *pSaveData, *pFieldName, **pTokenList;
; 2212 : 	string	mapName, description;
; 2213 : 	file_t	*f;
; 2214 : 
; 2215 : 	if(( f = FS_Open( savename, "rb", true )) == NULL )

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN10@SV_GetSave

; 2216 : 	{
; 2217 : 		// just not exist - clear comment
; 2218 : 		Q_strncpy( comment, "", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2219 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN10@SV_GetSave:

; 2220 : 	}
; 2221 : 
; 2222 : 	FS_Read( f, &tag, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2223 : 	if( tag != SAVEGAME_HEADER )

	cmp	DWORD PTR _tag$[ebp], 1447121738	; 5641534aH
	je	SHORT $LN11@SV_GetSave

; 2224 : 	{
; 2225 : 		// invalid header
; 2226 : 		Q_strncpy( comment, "<corrupted>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2227 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2228 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN11@SV_GetSave:

; 2229 : 	}
; 2230 : 		
; 2231 : 	FS_Read( f, &tag, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2232 : 
; 2233 : 	if( tag == 0x0065 )

	cmp	DWORD PTR _tag$[ebp], 101		; 00000065H
	jne	SHORT $LN12@SV_GetSave

; 2234 : 	{
; 2235 : 		Q_strncpy( comment, "old version Xash3D <unsupported>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0CB@HLDIHCLB@old?5version?5Xash3D?5?$DMunsupported@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2236 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2237 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN12@SV_GetSave:

; 2238 : 	}
; 2239 : 
; 2240 : 	if( tag < SAVEGAME_VERSION )

	cmp	DWORD PTR _tag$[ebp], 113		; 00000071H
	jge	SHORT $LN13@SV_GetSave

; 2241 : 	{
; 2242 : 		Q_strncpy( comment, "<old version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0O@BNPEDOPK@?$DMold?5version?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2243 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2244 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN13@SV_GetSave:

; 2245 : 	}
; 2246 : 
; 2247 : 	if( tag > SAVEGAME_VERSION )

	cmp	DWORD PTR _tag$[ebp], 113		; 00000071H
	jle	SHORT $LN14@SV_GetSave

; 2248 : 	{
; 2249 : 		// old xash version ?
; 2250 : 		Q_strncpy( comment, "<invalid version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BC@FOOGBDOL@?$DMinvalid?5version?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2251 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2252 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN14@SV_GetSave:

; 2253 : 	}
; 2254 : 
; 2255 : 	mapName[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN36@SV_GetSave
	jmp	SHORT $LN37@SV_GetSave
$LN36@SV_GetSave:
	call	___report_rangecheckfailure
$LN37@SV_GetSave:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _mapName$[ebp+edx], 0

; 2256 : 	comment[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _comment$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 2257 : 
; 2258 : 	FS_Read( f, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2259 : 	FS_Read( f, &tokenCount, sizeof( int ));	// These two ints are the token list

	push	4
	lea	eax, DWORD PTR _tokenCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2260 : 	FS_Read( f, &tokenSize, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _tokenSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2261 : 	size += tokenSize;

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, DWORD PTR _tokenSize$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 2262 : 
; 2263 : 	// sanity check.
; 2264 : 	if( tokenCount < 0 || tokenCount > SAVE_HASHSTRINGS )

	cmp	DWORD PTR _tokenCount$[ebp], 0
	jl	SHORT $LN16@SV_GetSave
	cmp	DWORD PTR _tokenCount$[ebp], 4095	; 00000fffH
	jle	SHORT $LN15@SV_GetSave
$LN16@SV_GetSave:

; 2265 : 	{
; 2266 : 		Q_strncpy( comment, "<corrupted hashtable>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BG@FNCJLPPA@?$DMcorrupted?5hashtable?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2267 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2268 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN15@SV_GetSave:

; 2269 : 	}
; 2270 : 
; 2271 : 	if( tokenSize < 0 || tokenSize > SAVE_HEAPSIZE )

	cmp	DWORD PTR _tokenSize$[ebp], 0
	jl	SHORT $LN18@SV_GetSave
	cmp	DWORD PTR _tokenSize$[ebp], 4194304	; 00400000H
	jle	SHORT $LN17@SV_GetSave
$LN18@SV_GetSave:

; 2272 : 	{
; 2273 : 		Q_strncpy( comment, "<corrupted hashtable>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BG@FNCJLPPA@?$DMcorrupted?5hashtable?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2274 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2275 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN17@SV_GetSave:

; 2276 : 	}
; 2277 : 
; 2278 : 	pSaveData = (char *)Mem_Malloc( host.mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pSaveData$[ebp], eax

; 2279 : 	FS_Read( f, pSaveData, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2280 : 	pData = pSaveData;

	mov	eax, DWORD PTR _pSaveData$[ebp]
	mov	DWORD PTR _pData$[ebp], eax

; 2281 : 
; 2282 : 	// allocate a table for the strings, and parse the table
; 2283 : 	if( tokenSize > 0 )

	cmp	DWORD PTR _tokenSize$[ebp], 0
	jle	$LN19@SV_GetSave

; 2284 : 	{
; 2285 : 		pTokenList = Mem_Calloc( host.mempool, tokenCount * sizeof( char* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _tokenCount$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pTokenList$[ebp], eax

; 2286 : 
; 2287 : 		// make sure the token strings pointed to by the pToken hashtable.
; 2288 : 		for( i = 0; i < tokenCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetSave
$LN2@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _tokenCount$[ebp]
	jge	SHORT $LN3@SV_GetSave

; 2289 : 		{
; 2290 : 			pTokenList[i] = *pData ? pData : NULL;	// point to each string in the pToken table

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN38@SV_GetSave
	mov	edx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR tv182[ebp], edx
	jmp	SHORT $LN39@SV_GetSave
$LN38@SV_GetSave:
	mov	DWORD PTR tv182[ebp], 0
$LN39@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	mov	edx, DWORD PTR tv182[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN5@SV_GetSave:

; 2291 : 			while( *pData++ );			// find next token (after next null)

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv186[ebp], ecx
	mov	edx, DWORD PTR _pData$[ebp]
	add	edx, 1
	mov	DWORD PTR _pData$[ebp], edx
	cmp	DWORD PTR tv186[ebp], 0
	je	SHORT $LN6@SV_GetSave
	jmp	SHORT $LN5@SV_GetSave
$LN6@SV_GetSave:

; 2292 : 		}

	jmp	SHORT $LN2@SV_GetSave
$LN3@SV_GetSave:

; 2293 : 	}

	jmp	SHORT $LN20@SV_GetSave
$LN19@SV_GetSave:

; 2294 : 	else pTokenList = NULL;

	mov	DWORD PTR _pTokenList$[ebp], 0
$LN20@SV_GetSave:

; 2295 : 
; 2296 : 	// short, short (size, index of field name)
; 2297 : 	nFieldSize = *(short *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _nFieldSize$[ebp], ecx

; 2298 : 	pData += sizeof( short );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 2
	mov	DWORD PTR _pData$[ebp], eax

; 2299 : 	pFieldName = pTokenList[*(short *)pData];

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pTokenList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pFieldName$[ebp], eax

; 2300 : 
; 2301 : 	if( Q_stricmp( pFieldName, "GameHeader" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@MNHGMPM@GameHeader@
	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN21@SV_GetSave

; 2302 : 	{
; 2303 : 		Q_strncpy( comment, "<missing GameHeader>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BF@NHHNGGE@?$DMmissing?5GameHeader?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2304 : 		if( pTokenList ) Mem_Free( pTokenList );

	cmp	DWORD PTR _pTokenList$[ebp], 0
	je	SHORT $LN22@SV_GetSave
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 95					; 0000005fH
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN22@SV_GetSave:

; 2305 : 		if( pSaveData ) Mem_Free( pSaveData );

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN23@SV_GetSave
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 96					; 00000060H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@SV_GetSave:

; 2306 : 		FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2307 : 		return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN21@SV_GetSave:

; 2308 : 	}
; 2309 : 
; 2310 : 	// int (fieldcount)
; 2311 : 	pData += sizeof( short );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 2
	mov	DWORD PTR _pData$[ebp], eax

; 2312 : 	nNumberOfFields = (int)*pData;

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _nNumberOfFields$[ebp], ecx

; 2313 : 	pData += nFieldSize;

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _nFieldSize$[ebp]
	mov	DWORD PTR _pData$[ebp], eax

; 2314 : 
; 2315 : 	// each field is a short (size), short (index of name), binary string of "size" bytes (data)
; 2316 : 	for( i = 0; i < nNumberOfFields; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@SV_GetSave
$LN7@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@SV_GetSave:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nNumberOfFields$[ebp]
	jge	$LN8@SV_GetSave

; 2317 : 	{
; 2318 : 		// Data order is:
; 2319 : 		// Size
; 2320 : 		// szName
; 2321 : 		// Actual Data
; 2322 : 		nFieldSize = *(short *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _nFieldSize$[ebp], ecx

; 2323 : 		pData += sizeof( short );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 2
	mov	DWORD PTR _pData$[ebp], eax

; 2324 : 
; 2325 : 		pFieldName = pTokenList[*(short *)pData];

	mov	eax, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pTokenList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pFieldName$[ebp], eax

; 2326 : 		pData += sizeof( short );

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, 2
	mov	DWORD PTR _pData$[ebp], eax

; 2327 : 
; 2328 : 		if( !Q_stricmp( pFieldName, "comment" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07GJGNEJFD@comment@
	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@SV_GetSave

; 2329 : 		{
; 2330 : 			Q_strncpy( description, pData, nFieldSize );

	mov	eax, DWORD PTR _nFieldSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _description$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2331 : 		}

	jmp	SHORT $LN25@SV_GetSave
$LN24@SV_GetSave:

; 2332 : 		else if( !Q_stricmp( pFieldName, "mapName" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07MLAMGOLD@mapName@
	mov	eax, DWORD PTR _pFieldName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@SV_GetSave

; 2333 : 		{
; 2334 : 			Q_strncpy( mapName, pData, nFieldSize );

	mov	eax, DWORD PTR _nFieldSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mapName$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN25@SV_GetSave:

; 2335 : 		}
; 2336 : 
; 2337 : 		// move to start of next field.
; 2338 : 		pData += nFieldSize;

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _nFieldSize$[ebp]
	mov	DWORD PTR _pData$[ebp], eax

; 2339 : 	}

	jmp	$LN7@SV_GetSave
$LN8@SV_GetSave:

; 2340 : 
; 2341 : 	// delete the string table we allocated
; 2342 : 	if( pTokenList ) Mem_Free( pTokenList );

	cmp	DWORD PTR _pTokenList$[ebp], 0
	je	SHORT $LN27@SV_GetSave
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 133				; 00000085H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pTokenList$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN27@SV_GetSave:

; 2343 : 	if( pSaveData ) Mem_Free( pSaveData );

	cmp	DWORD PTR _pSaveData$[ebp], 0
	je	SHORT $LN28@SV_GetSave
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_GetSaveComment@@9@9
	add	eax, 134				; 00000086H
	push	eax
	push	OFFSET ??_C@_0DE@PFNPDMGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pSaveData$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN28@SV_GetSave:

; 2344 : 	FS_Close( f );	

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2345 : 
; 2346 : 	// at least mapname should be filled
; 2347 : 	if( Q_strlen( mapName ) > 0 )

	lea	eax, DWORD PTR _mapName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jle	$LN29@SV_GetSave

; 2348 : 	{
; 2349 : 		time_t		fileTime;
; 2350 : 		const struct tm	*file_tm;
; 2351 : 		string		timestring;
; 2352 : 		int		flags;
; 2353 : 
; 2354 : 		// now check for map problems
; 2355 : 		flags = SV_MapIsValid( mapName, GI->sp_entity, NULL );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 1304				; 00000518H
	push	eax
	lea	ecx, DWORD PTR _mapName$[ebp]
	push	ecx
	call	_SV_MapIsValid
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _flags$2[ebp], eax

; 2356 : 
; 2357 : 		if( FBitSet( flags, MAP_INVALID_VERSION ))

	mov	eax, DWORD PTR _flags$2[ebp]
	and	eax, 8
	je	SHORT $LN30@SV_GetSave

; 2358 : 		{
; 2359 : 			Q_strncpy( comment, va( "<map %s has invalid format>", mapName ), MAX_STRING );

	push	256					; 00000100H
	lea	eax, DWORD PTR _mapName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@FPHEPIAN@?$DMmap?5?$CFs?5has?5invalid?5format?$DO@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2360 : 			return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN30@SV_GetSave:

; 2361 : 		}
; 2362 : 	
; 2363 : 		if( !FBitSet( flags, MAP_IS_EXIST ))

	mov	eax, DWORD PTR _flags$2[ebp]
	and	eax, 1
	jne	SHORT $LN31@SV_GetSave

; 2364 : 		{
; 2365 : 			Q_strncpy( comment, va( "<map %s is missed>", mapName ), MAX_STRING );

	push	256					; 00000100H
	lea	eax, DWORD PTR _mapName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@MBEBJCIG@?$DMmap?5?$CFs?5is?5missed?$DO@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2366 : 			return 0;

	xor	eax, eax
	jmp	$LN35@SV_GetSave
$LN31@SV_GetSave:

; 2367 : 		}
; 2368 : 	
; 2369 : 		fileTime = FS_FileTime( savename, true );

	push	1
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	cdq
	mov	DWORD PTR _fileTime$5[ebp], eax
	mov	DWORD PTR _fileTime$5[ebp+4], edx

; 2370 : 		file_tm = localtime( &fileTime );

	lea	eax, DWORD PTR _fileTime$5[ebp]
	push	eax
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _file_tm$4[ebp], eax

; 2371 : 
; 2372 : 		// split comment to sections
; 2373 : 		if( Q_strstr( savename, "quick" ))

	push	OFFSET ??_C@_05DFMHJABL@quick@
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN32@SV_GetSave

; 2374 : 			Q_strncat( comment, "[quick]", CS_SIZE );

	push	64					; 00000040H
	push	OFFSET ??_C@_07HFEHMCOC@?$FLquick?$FN@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN33@SV_GetSave
$LN32@SV_GetSave:

; 2375 : 		else if( Q_strstr( savename, "autosave" ))

	push	OFFSET ??_C@_08CCMFCJIM@autosave@
	mov	eax, DWORD PTR _savename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@SV_GetSave

; 2376 : 			Q_strncat( comment, "[autosave]", CS_SIZE );

	push	64					; 00000040H
	push	OFFSET ??_C@_0L@DIKLKKMB@?$FLautosave?$FN@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN33@SV_GetSave:

; 2377 : 		Q_strncat( comment, description, CS_SIZE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 2378 : 		strftime( timestring, sizeof ( timestring ), "%b%d %Y", file_tm );

	mov	eax, DWORD PTR _file_tm$4[ebp]
	push	eax
	push	OFFSET ??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$3[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 2379 : 		Q_strncpy( comment + CS_SIZE, timestring, CS_TIME );

	push	16					; 00000010H
	lea	eax, DWORD PTR _timestring$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2380 : 		strftime( timestring, sizeof( timestring ), "%H:%M", file_tm );

	mov	eax, DWORD PTR _file_tm$4[ebp]
	push	eax
	push	OFFSET ??_C@_05JFBIHENH@?$CFH?3?$CFM@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$3[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 2381 : 		Q_strncpy( comment + CS_SIZE + CS_TIME, timestring, CS_TIME );

	push	16					; 00000010H
	lea	eax, DWORD PTR _timestring$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2382 : 		Q_strncpy( comment + CS_SIZE + (CS_TIME * 2), description + CS_SIZE, CS_SIZE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _description$[ebp+64]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	add	ecx, 96					; 00000060H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2383 : 
; 2384 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN35@SV_GetSave
$LN29@SV_GetSave:

; 2385 : 	}	
; 2386 : 
; 2387 : 	Q_strncpy( comment, "<unknown version>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BC@IIBLLBNK@?$DMunknown?5version?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2388 : 
; 2389 : 	return 0;

	xor	eax, eax
$LN35@SV_GetSave:

; 2390 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetSaveComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 528  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  :             return _localtime64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
	add	esp, 4

; 530  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
END
