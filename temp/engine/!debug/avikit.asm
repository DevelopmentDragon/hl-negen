; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\avikit.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@EJNNNEOJ@DrawDibOpen@			; `string'
PUBLIC	??_C@_0M@IANCMLH@DrawDibDraw@			; `string'
PUBLIC	??_C@_0N@GIIEHCFF@DrawDibClose@			; `string'
PUBLIC	_msvfw_dll
PUBLIC	??_C@_0M@LFKFALEL@msvfw32?4dll@			; `string'
PUBLIC	??_C@_0O@PPKHJDGJ@acmStreamOpen@		; `string'
PUBLIC	??_C@_0BH@IPFILDPO@acmStreamPrepareHeader@	; `string'
PUBLIC	??_C@_0BJ@IKNENGPE@acmStreamUnprepareHeader@	; `string'
PUBLIC	??_C@_0BB@LJGIMNNH@acmStreamConvert@		; `string'
PUBLIC	??_C@_0O@IDCIMMHJ@acmStreamSize@		; `string'
PUBLIC	??_C@_0P@IFIKILDC@acmStreamClose@		; `string'
PUBLIC	_msacm_dll
PUBLIC	??_C@_0M@NHDLPJHG@msacm32?4dll@			; `string'
PUBLIC	??_C@_0M@JJIGJDHA@AVIFileExit@			; `string'
PUBLIC	??_C@_0BB@CBNNOBKD@AVIFileGetStream@		; `string'
PUBLIC	??_C@_0M@CJAEHGDC@AVIFileInit@			; `string'
PUBLIC	??_C@_0N@HDHCHIFC@AVIFileOpenA@			; `string'
PUBLIC	??_C@_0P@LKNLKEDF@AVIFileRelease@		; `string'
PUBLIC	??_C@_0BC@NLPDNKGM@AVIStreamGetFrame@		; `string'
PUBLIC	??_C@_0BH@DIBDFONM@AVIStreamGetFrameClose@	; `string'
PUBLIC	??_C@_0BG@NLIAGBJJ@AVIStreamGetFrameOpen@	; `string'
PUBLIC	??_C@_0P@BDHKDKCI@AVIStreamInfoA@		; `string'
PUBLIC	??_C@_0O@DBPDOBMC@AVIStreamRead@		; `string'
PUBLIC	??_C@_0BE@GOIPBLGG@AVIStreamReadFormat@		; `string'
PUBLIC	??_C@_0BB@LNKDMAPH@AVIStreamRelease@		; `string'
PUBLIC	??_C@_0P@LAHPFONK@AVIStreamStart@		; `string'
PUBLIC	??_C@_0BG@HGBOEPLD@AVIStreamTimeToSample@	; `string'
PUBLIC	_avifile_dll
PUBLIC	??_C@_0N@PKHEDOIE@avifil32?4dll@		; `string'
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_BSS	SEGMENT
_pDrawDibOpen DD 01H DUP (?)
_pDrawDibClose DD 01H DUP (?)
_pDrawDibDraw DD 01H DUP (?)
_pacmStreamOpen DD 01H DUP (?)
_pacmStreamPrepareHeader DD 01H DUP (?)
_pacmStreamUnprepareHeader DD 01H DUP (?)
_pacmStreamConvert DD 01H DUP (?)
_pacmStreamSize DD 01H DUP (?)
_pacmStreamClose DD 01H DUP (?)
_pAVIStreamInfo DD 01H DUP (?)
_pAVIStreamRead DD 01H DUP (?)
_pAVIStreamGetFrameOpen DD 01H DUP (?)
_pAVIStreamTimeToSample DD 01H DUP (?)
_pAVIStreamGetFrame DD 01H DUP (?)
_pAVIStreamGetFrameClose DD 01H DUP (?)
_pAVIStreamRelease DD 01H DUP (?)
_pAVIFileOpen DD 01H DUP (?)
_pAVIFileGetStream DD 01H DUP (?)
_pAVIStreamReadFormat DD 01H DUP (?)
_pAVIStreamStart DD 01H DUP (?)
_pAVIFileRelease DD 01H DUP (?)
_pAVIFileInit DD 01H DUP (?)
_pAVIFileExit DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@PKHEDOIE@avifil32?4dll@
CONST	SEGMENT
??_C@_0N@PKHEDOIE@avifil32?4dll@ DB 'avifil32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGBOEPLD@AVIStreamTimeToSample@
CONST	SEGMENT
??_C@_0BG@HGBOEPLD@AVIStreamTimeToSample@ DB 'AVIStreamTimeToSample', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LAHPFONK@AVIStreamStart@
CONST	SEGMENT
??_C@_0P@LAHPFONK@AVIStreamStart@ DB 'AVIStreamStart', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNKDMAPH@AVIStreamRelease@
CONST	SEGMENT
??_C@_0BB@LNKDMAPH@AVIStreamRelease@ DB 'AVIStreamRelease', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOIPBLGG@AVIStreamReadFormat@
CONST	SEGMENT
??_C@_0BE@GOIPBLGG@AVIStreamReadFormat@ DB 'AVIStreamReadFormat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBPDOBMC@AVIStreamRead@
CONST	SEGMENT
??_C@_0O@DBPDOBMC@AVIStreamRead@ DB 'AVIStreamRead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BDHKDKCI@AVIStreamInfoA@
CONST	SEGMENT
??_C@_0P@BDHKDKCI@AVIStreamInfoA@ DB 'AVIStreamInfoA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NLIAGBJJ@AVIStreamGetFrameOpen@
CONST	SEGMENT
??_C@_0BG@NLIAGBJJ@AVIStreamGetFrameOpen@ DB 'AVIStreamGetFrameOpen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DIBDFONM@AVIStreamGetFrameClose@
CONST	SEGMENT
??_C@_0BH@DIBDFONM@AVIStreamGetFrameClose@ DB 'AVIStreamGetFrameClose', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLPDNKGM@AVIStreamGetFrame@
CONST	SEGMENT
??_C@_0BC@NLPDNKGM@AVIStreamGetFrame@ DB 'AVIStreamGetFrame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LKNLKEDF@AVIFileRelease@
CONST	SEGMENT
??_C@_0P@LKNLKEDF@AVIFileRelease@ DB 'AVIFileRelease', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HDHCHIFC@AVIFileOpenA@
CONST	SEGMENT
??_C@_0N@HDHCHIFC@AVIFileOpenA@ DB 'AVIFileOpenA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJAEHGDC@AVIFileInit@
CONST	SEGMENT
??_C@_0M@CJAEHGDC@AVIFileInit@ DB 'AVIFileInit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CBNNOBKD@AVIFileGetStream@
CONST	SEGMENT
??_C@_0BB@CBNNOBKD@AVIFileGetStream@ DB 'AVIFileGetStream', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JJIGJDHA@AVIFileExit@
CONST	SEGMENT
??_C@_0M@JJIGJDHA@AVIFileExit@ DB 'AVIFileExit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHDLPJHG@msacm32?4dll@
CONST	SEGMENT
??_C@_0M@NHDLPJHG@msacm32?4dll@ DB 'msacm32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IFIKILDC@acmStreamClose@
CONST	SEGMENT
??_C@_0P@IFIKILDC@acmStreamClose@ DB 'acmStreamClose', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IDCIMMHJ@acmStreamSize@
CONST	SEGMENT
??_C@_0O@IDCIMMHJ@acmStreamSize@ DB 'acmStreamSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LJGIMNNH@acmStreamConvert@
CONST	SEGMENT
??_C@_0BB@LJGIMNNH@acmStreamConvert@ DB 'acmStreamConvert', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IKNENGPE@acmStreamUnprepareHeader@
CONST	SEGMENT
??_C@_0BJ@IKNENGPE@acmStreamUnprepareHeader@ DB 'acmStreamUnprepareHeader'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IPFILDPO@acmStreamPrepareHeader@
CONST	SEGMENT
??_C@_0BH@IPFILDPO@acmStreamPrepareHeader@ DB 'acmStreamPrepareHeader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PPKHJDGJ@acmStreamOpen@
CONST	SEGMENT
??_C@_0O@PPKHJDGJ@acmStreamOpen@ DB 'acmStreamOpen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFKFALEL@msvfw32?4dll@
CONST	SEGMENT
??_C@_0M@LFKFALEL@msvfw32?4dll@ DB 'msvfw32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GIIEHCFF@DrawDibClose@
CONST	SEGMENT
??_C@_0N@GIIEHCFF@DrawDibClose@ DB 'DrawDibClose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IANCMLH@DrawDibDraw@
CONST	SEGMENT
??_C@_0M@IANCMLH@DrawDibDraw@ DB 'DrawDibDraw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJNNNEOJ@DrawDibOpen@
CONST	SEGMENT
??_C@_0M@EJNNNEOJ@DrawDibOpen@ DB 'DrawDibOpen', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_msvfw_funcs DD	FLAT:??_C@_0M@EJNNNEOJ@DrawDibOpen@
	DD	FLAT:_pDrawDibOpen
	DD	FLAT:??_C@_0M@IANCMLH@DrawDibDraw@
	DD	FLAT:_pDrawDibDraw
	DD	FLAT:??_C@_0N@GIIEHCFF@DrawDibClose@
	DD	FLAT:_pDrawDibClose
	DD	00H
	DD	00H
_msvfw_dll DD	FLAT:??_C@_0M@LFKFALEL@msvfw32?4dll@
	DD	FLAT:_msvfw_funcs
	DD	00H
	ORG $+4
_msacm_funcs DD	FLAT:??_C@_0O@PPKHJDGJ@acmStreamOpen@
	DD	FLAT:_pacmStreamOpen
	DD	FLAT:??_C@_0BH@IPFILDPO@acmStreamPrepareHeader@
	DD	FLAT:_pacmStreamPrepareHeader
	DD	FLAT:??_C@_0BJ@IKNENGPE@acmStreamUnprepareHeader@
	DD	FLAT:_pacmStreamUnprepareHeader
	DD	FLAT:??_C@_0BB@LJGIMNNH@acmStreamConvert@
	DD	FLAT:_pacmStreamConvert
	DD	FLAT:??_C@_0O@IDCIMMHJ@acmStreamSize@
	DD	FLAT:_pacmStreamSize
	DD	FLAT:??_C@_0P@IFIKILDC@acmStreamClose@
	DD	FLAT:_pacmStreamClose
	DD	00H
	DD	00H
_msacm_dll DD	FLAT:??_C@_0M@NHDLPJHG@msacm32?4dll@
	DD	FLAT:_msacm_funcs
	DD	00H
	ORG $+4
_avifile_funcs DD FLAT:??_C@_0M@JJIGJDHA@AVIFileExit@
	DD	FLAT:_pAVIFileExit
	DD	FLAT:??_C@_0BB@CBNNOBKD@AVIFileGetStream@
	DD	FLAT:_pAVIFileGetStream
	DD	FLAT:??_C@_0M@CJAEHGDC@AVIFileInit@
	DD	FLAT:_pAVIFileInit
	DD	FLAT:??_C@_0N@HDHCHIFC@AVIFileOpenA@
	DD	FLAT:_pAVIFileOpen
	DD	FLAT:??_C@_0P@LKNLKEDF@AVIFileRelease@
	DD	FLAT:_pAVIFileRelease
	DD	FLAT:??_C@_0BC@NLPDNKGM@AVIStreamGetFrame@
	DD	FLAT:_pAVIStreamGetFrame
	DD	FLAT:??_C@_0BH@DIBDFONM@AVIStreamGetFrameClose@
	DD	FLAT:_pAVIStreamGetFrameClose
	DD	FLAT:??_C@_0BG@NLIAGBJJ@AVIStreamGetFrameOpen@
	DD	FLAT:_pAVIStreamGetFrameOpen
	DD	FLAT:??_C@_0P@BDHKDKCI@AVIStreamInfoA@
	DD	FLAT:_pAVIStreamInfo
	DD	FLAT:??_C@_0O@DBPDOBMC@AVIStreamRead@
	DD	FLAT:_pAVIStreamRead
	DD	FLAT:??_C@_0BE@GOIPBLGG@AVIStreamReadFormat@
	DD	FLAT:_pAVIStreamReadFormat
	DD	FLAT:??_C@_0BB@LNKDMAPH@AVIStreamRelease@
	DD	FLAT:_pAVIStreamRelease
	DD	FLAT:??_C@_0P@LAHPFONK@AVIStreamStart@
	DD	FLAT:_pAVIStreamStart
	DD	FLAT:??_C@_0BG@HGBOEPLD@AVIStreamTimeToSample@
	DD	FLAT:_pAVIStreamTimeToSample
	DD	00H
	DD	00H
_avifile_dll DD	FLAT:??_C@_0N@PKHEDOIE@avifil32?4dll@
	DD	FLAT:_avifile_funcs
	DD	00H
	ORG $+4
_DATA	ENDS
PUBLIC	_AVI_GetVideoFrameNumber
PUBLIC	_AVI_GetVideoFrame
PUBLIC	_AVI_GetVideoInfo
PUBLIC	_AVI_GetAudioInfo
PUBLIC	_AVI_GetAudioChunk
PUBLIC	_AVI_OpenVideo
PUBLIC	_AVI_LoadVideo
PUBLIC	_AVI_TimeToSoundPosition
PUBLIC	_AVI_GetVideoFrameCount
PUBLIC	_AVI_CloseVideo
PUBLIC	_AVI_IsActive
PUBLIC	_AVI_FreeVideo
PUBLIC	_AVI_GetState
PUBLIC	_AVI_Initailize
PUBLIC	_AVI_Shutdown
PUBLIC	_AVI_ACMConvertAudio
PUBLIC	_AVI_SeekPosition
PUBLIC	?__LINE__Var@?0??AVI_ACMConvertAudio@@9@9	; `AVI_ACMConvertAudio'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@KEAMCFPL@?$FO1Error?3?$FO7?5ACM?5does?5not?5support@ ; `string'
PUBLIC	??_C@_0DC@IDFEAIHB@?$FO1Error?3?$FO7?5ACM?5failed?5to?5open?5c@ ; `string'
PUBLIC	??_C@_0DF@GJCDFDPD@?$FO1Error?3?$FO7?5Couldn?8t?5get?5ACM?5con@ ; `string'
PUBLIC	??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CN@GCGCFHDD@?$FO1Error?3?$FO7?5couldn?8t?5prepare?5str@ ; `string'
PUBLIC	?__LINE__Var@?0??AVI_CloseVideo@@9@9		; `AVI_CloseVideo'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??AVI_OpenVideo@@9@9		; `AVI_OpenVideo'::`1'::__LINE__Var
PUBLIC	??_C@_0CM@IDKPBAPD@?$FO1Error?3?$FO7?5corrupt?5file?5or?5unkn@ ; `string'
PUBLIC	??_C@_0CO@POACPNMK@?$FO1Error?3?$FO7?5insufficient?5memory?5@ ; `string'
PUBLIC	??_C@_0CF@EKECHMB@?$FO1Error?3?$FO7?5disk?5error?5reading?5f@ ; `string'
PUBLIC	??_C@_0CF@HEFHBKHE@?$FO1Error?3?$FO7?5disk?5error?5opening?5f@ ; `string'
PUBLIC	??_C@_0DC@JGEKJML@?$FO1Error?3?$FO7?5no?5handler?5found?5?$CIor@ ; `string'
PUBLIC	??_C@_0DA@KGKLEJPK@?$FO1Error?3?$FO7?5couldn?8t?5find?5a?5vali@ ; `string'
PUBLIC	??_C@_0DD@HEMILJNI@?$FO1Error?3?$FO7?5error?5attempting?5to?5@ ; `string'
PUBLIC	?__LINE__Var@?0??AVI_LoadVideo@@9@9		; `AVI_LoadVideo'::`1'::__LINE__Var
PUBLIC	??_C@_08BKEEFKLC@media?1?$CFs@			; `string'
PUBLIC	??_C@_04CAPFMNON@?4avi@				; `string'
PUBLIC	??_C@_0DD@DNEPLBAF@Couldn?8t?5load?5?$CFs?5from?5packfile?4@ ; `string'
PUBLIC	?__LINE__Var@?0??AVI_FreeVideo@@9@9		; `AVI_FreeVideo'::`1'::__LINE__Var
PUBLIC	??_C@_06ICLMKCAB@?9noavi@			; `string'
PUBLIC	??_C@_0P@OMHOPAK@AVI?3?5Disabled?6@		; `string'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__CreateDIBSection@24:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_LoadLibrary:PROC
EXTRN	_Sys_FreeLibrary:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_IsAllocatedExt:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_cls:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_avi_initialized DD 01H DUP (?)
_avi	DB	0178H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_C@_0P@OMHOPAK@AVI?3?5Disabled?6@
CONST	SEGMENT
??_C@_0P@OMHOPAK@AVI?3?5Disabled?6@ DB 'AVI: Disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICLMKCAB@?9noavi@
CONST	SEGMENT
??_C@_06ICLMKCAB@?9noavi@ DB '-noavi', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AVI_FreeVideo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??AVI_FreeVideo@@9@9 DD 02aaH		; `AVI_FreeVideo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@DNEPLBAF@Couldn?8t?5load?5?$CFs?5from?5packfile?4@
CONST	SEGMENT
??_C@_0DD@DNEPLBAF@Couldn?8t?5load?5?$CFs?5from?5packfile?4@ DB 'Couldn'''
	DB	't load %s from packfile. Please extract it', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAPFMNON@?4avi@
CONST	SEGMENT
??_C@_04CAPFMNON@?4avi@ DB '.avi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BKEEFKLC@media?1?$CFs@
CONST	SEGMENT
??_C@_08BKEEFKLC@media?1?$CFs@ DB 'media/%s', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AVI_LoadVideo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??AVI_LoadVideo@@9@9 DD 0288H		; `AVI_LoadVideo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@HEMILJNI@?$FO1Error?3?$FO7?5error?5attempting?5to?5@
CONST	SEGMENT
??_C@_0DD@HEMILJNI@?$FO1Error?3?$FO7?5error?5attempting?5to?5@ DB '^1Erro'
	DB	'r:^7 error attempting to read video frames.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KGKLEJPK@?$FO1Error?3?$FO7?5couldn?8t?5find?5a?5vali@
CONST	SEGMENT
??_C@_0DA@KGKLEJPK@?$FO1Error?3?$FO7?5couldn?8t?5find?5a?5vali@ DB '^1Err'
	DB	'or:^7 couldn''t find a valid video stream.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JGEKJML@?$FO1Error?3?$FO7?5no?5handler?5found?5?$CIor@
CONST	SEGMENT
??_C@_0DC@JGEKJML@?$FO1Error?3?$FO7?5no?5handler?5found?5?$CIor@ DB '^1Er'
	DB	'ror:^7 no handler found (or file not found).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HEFHBKHE@?$FO1Error?3?$FO7?5disk?5error?5opening?5f@
CONST	SEGMENT
??_C@_0CF@HEFHBKHE@?$FO1Error?3?$FO7?5disk?5error?5opening?5f@ DB '^1Erro'
	DB	'r:^7 disk error opening file.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EKECHMB@?$FO1Error?3?$FO7?5disk?5error?5reading?5f@
CONST	SEGMENT
??_C@_0CF@EKECHMB@?$FO1Error?3?$FO7?5disk?5error?5reading?5f@ DB '^1Error'
	DB	':^7 disk error reading file.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@POACPNMK@?$FO1Error?3?$FO7?5insufficient?5memory?5@
CONST	SEGMENT
??_C@_0CO@POACPNMK@?$FO1Error?3?$FO7?5insufficient?5memory?5@ DB '^1Error'
	DB	':^7 insufficient memory to open file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IDKPBAPD@?$FO1Error?3?$FO7?5corrupt?5file?5or?5unkn@
CONST	SEGMENT
??_C@_0CM@IDKPBAPD@?$FO1Error?3?$FO7?5corrupt?5file?5or?5unkn@ DB '^1Erro'
	DB	'r:^7 corrupt file or unknown format.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AVI_OpenVideo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??AVI_OpenVideo@@9@9 DD 01eaH		; `AVI_OpenVideo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??AVI_CloseVideo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??AVI_CloseVideo@@9@9 DD 01ccH		; `AVI_CloseVideo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CN@GCGCFHDD@?$FO1Error?3?$FO7?5couldn?8t?5prepare?5str@
CONST	SEGMENT
??_C@_0CN@GCGCFHDD@?$FO1Error?3?$FO7?5couldn?8t?5prepare?5str@ DB '^1Erro'
	DB	'r:^7 couldn''t prepare stream headers.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\avikit.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GJCDFDPD@?$FO1Error?3?$FO7?5Couldn?8t?5get?5ACM?5con@
CONST	SEGMENT
??_C@_0DF@GJCDFDPD@?$FO1Error?3?$FO7?5Couldn?8t?5get?5ACM?5con@ DB '^1Err'
	DB	'or:^7 Couldn''t get ACM conversion stream size.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IDFEAIHB@?$FO1Error?3?$FO7?5ACM?5failed?5to?5open?5c@
CONST	SEGMENT
??_C@_0DC@IDFEAIHB@?$FO1Error?3?$FO7?5ACM?5failed?5to?5open?5c@ DB '^1Err'
	DB	'or:^7 ACM failed to open conversion stream.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KEAMCFPL@?$FO1Error?3?$FO7?5ACM?5does?5not?5support@
CONST	SEGMENT
??_C@_0DD@KEAMCFPL@?$FO1Error?3?$FO7?5ACM?5does?5not?5support@ DB '^1Erro'
	DB	'r:^7 ACM does not support this audio codec.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??AVI_ACMConvertAudio@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??AVI_ACMConvertAudio@@9@9 DD 089H	; `AVI_ACMConvertAudio'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	045aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	010aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05a8H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_SeekPosition
_TEXT	SEGMENT
_breaker$ = -4						; size = 4
_Avi$ = 8						; size = 4
_offset$ = 12						; size = 4
_AVI_SeekPosition PROC					; COMDAT

; 337  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 338  : 	int	breaker;
; 339  : 
; 340  : 	if( offset < Avi->cpa_blockoffset ) // well, shit. we can't seek backwards... restart

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax+168]
	jae	$LN4@AVI_SeekPo

; 341  : 	{
; 342  : 		if( Avi->cpa_blockoffset - offset < 500000 )

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	sub	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, 500000				; 0007a120H
	jae	SHORT $LN5@AVI_SeekPo

; 343  : 			return false; // don't bother if it's gonna catch up soon

	xor	eax, eax
	jmp	$LN1@AVI_SeekPo
$LN5@AVI_SeekPo:

; 344  : 
; 345  : 		Avi->cpa_blocknum = 0; // start at 0, eh.

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+160], 0

; 346  : 		Avi->cpa_blockpos = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+164], 0

; 347  : 		Avi->cpa_blockoffset = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+168], 0

; 348  : 
; 349  : 		pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 350  : 		pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN|ACM_STREAMCONVERTF_START );

	push	20					; 00000014H
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert

; 351  : 
; 352  : 		// convert first chunk twice. it often fails the first time. BLACK MAGIC.
; 353  : 		pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 354  : 		pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

	push	4
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert
$LN4@AVI_SeekPo:

; 355  : 	}
; 356  : 
; 357  : 	// now then: seek forwards to the required block
; 358  : 	breaker = 30; // maximum zero blocks: anti-freeze protection

	mov	DWORD PTR _breaker$[ebp], 30		; 0000001eH
$LN2@AVI_SeekPo:

; 359  : 
; 360  : 	while( Avi->cpa_blockoffset + Avi->cpa_conversion_header.cbDstLengthUsed < offset )

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _Avi$[ebp]
	add	ecx, DWORD PTR [edx+104]
	cmp	ecx, DWORD PTR _offset$[ebp]
	jae	$LN3@AVI_SeekPo

; 361  : 	{
; 362  : 		Avi->cpa_blocknum++;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	add	ecx, 1
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+160], ecx

; 363  : 		Avi->cpa_blockoffset += Avi->cpa_conversion_header.cbDstLengthUsed;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _Avi$[ebp]
	add	ecx, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 364  : 
; 365  : 		pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 366  : 		pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

	push	4
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert

; 367  : 
; 368  : 		if( Avi->cpa_conversion_header.cbDstLengthUsed == 0 )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jne	SHORT $LN6@AVI_SeekPo

; 369  : 			breaker--;

	mov	eax, DWORD PTR _breaker$[ebp]
	sub	eax, 1
	mov	DWORD PTR _breaker$[ebp], eax
	jmp	SHORT $LN7@AVI_SeekPo
$LN6@AVI_SeekPo:

; 370  : 		else breaker = 30;

	mov	DWORD PTR _breaker$[ebp], 30		; 0000001eH
$LN7@AVI_SeekPo:

; 371  : 
; 372  : 		if( breaker <= 0 )

	cmp	DWORD PTR _breaker$[ebp], 0
	jg	SHORT $LN8@AVI_SeekPo

; 373  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_SeekPo
$LN8@AVI_SeekPo:

; 374  : 
; 375  : 		Avi->cpa_blockpos = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+164], 0

; 376  : 	}

	jmp	$LN2@AVI_SeekPo
$LN3@AVI_SeekPo:

; 377  : 
; 378  : 	// seek to the right position inside the block
; 379  : 	Avi->cpa_blockpos = offset - Avi->cpa_blockoffset;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	sub	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+164], ecx

; 380  : 
; 381  : 	return true;

	mov	eax, 1
$LN1@AVI_SeekPo:

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_SeekPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_ACMConvertAudio
_TEXT	SEGMENT
_k$1 = -184						; size = 4
_bits$ = -180						; size = 2
_dest_length$ = -176					; size = 4
_stream_info$ = -172					; size = 140
_dh$ = -32						; size = 4
_sh$ = -28						; size = 4
_dest_header$ = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_Avi$ = 8						; size = 4
_AVI_ACMConvertAudio PROC				; COMDAT

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 138  : 	WAVEFORMATEX	dest_header, *sh, *dh;
; 139  : 	AVISTREAMINFO	stream_info;
; 140  : 	dword		dest_length;
; 141  : 	short		bits;
; 142  : 
; 143  : 	// WMA codecs, both versions - they simply don't work.
; 144  : 	if( Avi->audio_header->wFormatTag == 0x160 || Avi->audio_header->wFormatTag == 0x161 )

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 352				; 00000160H
	je	SHORT $LN3@AVI_ACMCon
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 353				; 00000161H
	jne	SHORT $LN2@AVI_ACMCon
$LN3@AVI_ACMCon:

; 145  : 	{
; 146  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@AVI_ACMCon

; 147  : 			Con_Reportf( S_ERROR "ACM does not support this audio codec.\n" );

	push	OFFSET ??_C@_0DD@KEAMCFPL@?$FO1Error?3?$FO7?5ACM?5does?5not?5support@
	call	_Con_Reportf
	add	esp, 4
$LN4@AVI_ACMCon:

; 148  : 		return false;

	xor	eax, eax
	jmp	$LN1@AVI_ACMCon
$LN2@AVI_ACMCon:

; 149  : 	}
; 150  : 
; 151  : 	// get audio stream info to work with
; 152  : 	pAVIStreamInfo( Avi->audio_stream, &stream_info, sizeof( stream_info ));

	push	140					; 0000008cH
	lea	eax, DWORD PTR _stream_info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _pAVIStreamInfo

; 153  : 
; 154  : 	if( Avi->audio_header_size < sizeof( WAVEFORMATEX ))

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+44], 18			; 00000012H
	jae	SHORT $LN5@AVI_ACMCon

; 155  : 	{
; 156  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@AVI_ACMCon

; 157  : 			Con_Reportf( S_ERROR "ACM failed to open conversion stream.\n" );

	push	OFFSET ??_C@_0DC@IDFEAIHB@?$FO1Error?3?$FO7?5ACM?5failed?5to?5open?5c@
	call	_Con_Reportf
	add	esp, 4
$LN6@AVI_ACMCon:

; 158  : 		return false;

	xor	eax, eax
	jmp	$LN1@AVI_ACMCon
$LN5@AVI_ACMCon:

; 159  : 	}
; 160  : 
; 161  : 	sh = (WAVEFORMATEX *)Avi->audio_header;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _sh$[ebp], ecx

; 162  : 	bits = 16; // predict state

	mov	eax, 16					; 00000010H
	mov	WORD PTR _bits$[ebp], ax

; 163  : 
; 164  : 	// how much of this is actually required?
; 165  : 	dest_header.wFormatTag = WAVE_FORMAT_PCM; // yay

	mov	eax, 1
	mov	WORD PTR _dest_header$[ebp], ax

; 166  : 	dest_header.wBitsPerSample = bits; // 16bit

	mov	ax, WORD PTR _bits$[ebp]
	mov	WORD PTR _dest_header$[ebp+14], ax

; 167  : 	dest_header.nChannels = sh->nChannels;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR _dest_header$[ebp+2], cx

; 168  : 	dest_header.nSamplesPerSec = sh->nSamplesPerSec; // take straight from the source stream

	mov	eax, DWORD PTR _sh$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _dest_header$[ebp+4], ecx

; 169  : 	dest_header.nAvgBytesPerSec = (bits >> 3) * sh->nChannels * sh->nSamplesPerSec;

	movsx	eax, WORD PTR _bits$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _sh$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	ecx, DWORD PTR _sh$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _dest_header$[ebp+8], eax

; 170  : 	dest_header.nBlockAlign = (bits >> 3) * sh->nChannels;

	movsx	eax, WORD PTR _bits$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _sh$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	WORD PTR _dest_header$[ebp+12], ax

; 171  : 	dest_header.cbSize = 0; // no more data.

	xor	eax, eax
	mov	WORD PTR _dest_header$[ebp+16], ax

; 172  : 
; 173  : 	dh = &dest_header;

	lea	eax, DWORD PTR _dest_header$[ebp]
	mov	DWORD PTR _dh$[ebp], eax

; 174  : 
; 175  : 	// open the stream
; 176  : 	if( pacmStreamOpen( &Avi->cpa_conversion_stream, NULL, sh, dh, NULL, 0, 0, 0 ) != MMSYSERR_NOERROR )

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _dh$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sh$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Avi$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	DWORD PTR _pacmStreamOpen
	test	eax, eax
	je	$LN7@AVI_ACMCon

; 177  : 	{
; 178  : 		// try with 8 bit destination instead
; 179  : 		bits = 8;

	mov	eax, 8
	mov	WORD PTR _bits$[ebp], ax

; 180  : 
; 181  : 		dest_header.wBitsPerSample = bits; // 8bit

	mov	ax, WORD PTR _bits$[ebp]
	mov	WORD PTR _dest_header$[ebp+14], ax

; 182  : 		dest_header.nAvgBytesPerSec = ( bits >> 3 ) * sh->nChannels * sh->nSamplesPerSec;

	movsx	eax, WORD PTR _bits$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _sh$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	ecx, DWORD PTR _sh$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _dest_header$[ebp+8], eax

; 183  : 		dest_header.nBlockAlign = ( bits >> 3 ) * sh->nChannels; // 1 sample at a time

	movsx	eax, WORD PTR _bits$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _sh$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	eax, edx
	mov	WORD PTR _dest_header$[ebp+12], ax

; 184  : 
; 185  : 		if( pacmStreamOpen( &Avi->cpa_conversion_stream, NULL, sh, dh, NULL, 0, 0, 0 ) != MMSYSERR_NOERROR )

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _dh$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sh$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Avi$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	call	DWORD PTR _pacmStreamOpen
	test	eax, eax
	je	SHORT $LN7@AVI_ACMCon

; 186  : 		{
; 187  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@AVI_ACMCon

; 188  : 				Con_Reportf( S_ERROR "ACM failed to open conversion stream.\n" );

	push	OFFSET ??_C@_0DC@IDFEAIHB@?$FO1Error?3?$FO7?5ACM?5failed?5to?5open?5c@
	call	_Con_Reportf
	add	esp, 4
$LN9@AVI_ACMCon:

; 189  : 			return false;

	xor	eax, eax
	jmp	$LN1@AVI_ACMCon
$LN7@AVI_ACMCon:

; 190  : 		}
; 191  : 	}
; 192  : 
; 193  : 	Avi->cpa_blockalign = sh->nBlockAlign;

	mov	eax, DWORD PTR _sh$[ebp]
	movzx	ecx, WORD PTR [eax+12]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+60], ecx

; 194  : 	dest_length = 0;

	mov	DWORD PTR _dest_length$[ebp], 0

; 195  : 
; 196  : 	// mp3 specific fix
; 197  : 	if( sh->wFormatTag == 0x55 )

	mov	eax, DWORD PTR _sh$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 85					; 00000055H
	jne	SHORT $LN10@AVI_ACMCon

; 198  : 	{
; 199  : 		LPMPEGLAYER3WAVEFORMAT	k;
; 200  : 
; 201  : 		k = (LPMPEGLAYER3WAVEFORMAT)sh;

	mov	eax, DWORD PTR _sh$[ebp]
	mov	DWORD PTR _k$1[ebp], eax

; 202  : 		Avi->cpa_blockalign = k->nBlockSize;

	mov	eax, DWORD PTR _k$1[ebp]
	movzx	ecx, WORD PTR [eax+24]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+60], ecx
$LN10@AVI_ACMCon:

; 203  : 	}
; 204  : 
; 205  : 	// get the size of the output buffer for streaming the compressed audio
; 206  : 	if( pacmStreamSize( Avi->cpa_conversion_stream, Avi->cpa_blockalign, &dest_length, ACM_STREAMSIZEF_SOURCE ) != MMSYSERR_NOERROR )

	push	0
	lea	eax, DWORD PTR _dest_length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _pacmStreamSize
	test	eax, eax
	je	SHORT $LN11@AVI_ACMCon

; 207  : 	{
; 208  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN12@AVI_ACMCon

; 209  : 			Con_Reportf( S_ERROR "Couldn't get ACM conversion stream size.\n" );

	push	OFFSET ??_C@_0DF@GJCDFDPD@?$FO1Error?3?$FO7?5Couldn?8t?5get?5ACM?5con@
	call	_Con_Reportf
	add	esp, 4
$LN12@AVI_ACMCon:

; 210  : 		pacmStreamClose( Avi->cpa_conversion_stream, 0 );

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _pacmStreamClose

; 211  : 		return false;

	xor	eax, eax
	jmp	$LN1@AVI_ACMCon
$LN11@AVI_ACMCon:

; 212  : 	}
; 213  : 
; 214  : 	Avi->cpa_srcbuffer = (byte *)Mem_Malloc( cls.mempool, Avi->cpa_blockalign );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_ACMConvertAudio@@9@9
	add	eax, 77					; 0000004dH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 215  : 	Avi->cpa_dstbuffer = (byte *)Mem_Malloc( cls.mempool, dest_length ); // maintained buffer for raw data

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_ACMConvertAudio@@9@9
	add	eax, 78					; 0000004eH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _dest_length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+156], eax

; 216  : 
; 217  : 	// prep the headers!
; 218  : 	Avi->cpa_conversion_header.cbStruct = sizeof( ACMSTREAMHEADER );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+68], 84			; 00000054H

; 219  : 	Avi->cpa_conversion_header.fdwStatus = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+72], 0

; 220  : 	Avi->cpa_conversion_header.dwUser = 0;				// no user data

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+76], 0

; 221  : 	Avi->cpa_conversion_header.pbSrc = Avi->cpa_srcbuffer;		// source buffer

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+80], edx

; 222  : 	Avi->cpa_conversion_header.cbSrcLength = Avi->cpa_blockalign;	// source buffer size

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+84], edx

; 223  : 	Avi->cpa_conversion_header.cbSrcLengthUsed = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+88], 0

; 224  : 	Avi->cpa_conversion_header.dwSrcUser = 0;			// no user data

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+92], 0

; 225  : 	Avi->cpa_conversion_header.pbDst = Avi->cpa_dstbuffer;		// dest buffer

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	DWORD PTR [eax+96], edx

; 226  : 	Avi->cpa_conversion_header.cbDstLength = dest_length;		// dest buffer size

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _dest_length$[ebp]
	mov	DWORD PTR [eax+100], ecx

; 227  : 	Avi->cpa_conversion_header.cbDstLengthUsed = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+104], 0

; 228  : 	Avi->cpa_conversion_header.dwDstUser = 0;			// no user data

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+108], 0

; 229  : 
; 230  : 	if( pacmStreamPrepareHeader( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, 0 ) != MMSYSERR_NOERROR )

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamPrepareHeader
	test	eax, eax
	je	SHORT $LN13@AVI_ACMCon

; 231  : 	{
; 232  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN14@AVI_ACMCon

; 233  : 			Con_Reportf( S_ERROR "couldn't prepare stream headers.\n" );

	push	OFFSET ??_C@_0CN@GCGCFHDD@?$FO1Error?3?$FO7?5couldn?8t?5prepare?5str@
	call	_Con_Reportf
	add	esp, 4
$LN14@AVI_ACMCon:

; 234  : 		pacmStreamClose( Avi->cpa_conversion_stream, 0 );

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _pacmStreamClose

; 235  : 		return false;

	xor	eax, eax
	jmp	$LN1@AVI_ACMCon
$LN13@AVI_ACMCon:

; 236  : 	}
; 237  : 
; 238  : 	Avi->cpa_blocknum = 0; // start at 0.

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+160], 0

; 239  : 	Avi->cpa_blockpos = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+164], 0

; 240  : 	Avi->cpa_blockoffset = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+168], 0

; 241  : 
; 242  : 	pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 243  : 	pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN|ACM_STREAMCONVERTF_START );

	push	20					; 00000014H
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert

; 244  : 
; 245  : 	// convert first chunk twice. it often fails the first time. BLACK MAGIC.
; 246  : 	pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 247  : 	pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

	push	4
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert

; 248  : 
; 249  : 	Avi->audio_bytes_per_sample = (bits >> 3 ) * Avi->audio_header->nChannels;

	movsx	eax, WORD PTR _bits$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	ecx, WORD PTR [edx+2]
	imul	eax, ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+56], eax

; 250  : 
; 251  : 	return true;

	mov	eax, 1
$LN1@AVI_ACMCon:

; 252  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_ACMConvertAudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_Shutdown
_TEXT	SEGMENT
_AVI_Shutdown PROC					; COMDAT

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 724  : 	if( !avi_initialized ) return;

	cmp	DWORD PTR _avi_initialized, 0
	jne	SHORT $LN2@AVI_Shutdo
	jmp	SHORT $LN1@AVI_Shutdo
$LN2@AVI_Shutdo:

; 725  : 
; 726  : 	pAVIFileExit();

	call	DWORD PTR _pAVIFileExit

; 727  : 
; 728  : 	Sys_FreeLibrary( &avifile_dll );

	push	OFFSET _avifile_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 729  : 	Sys_FreeLibrary( &msvfw_dll );

	push	OFFSET _msvfw_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 730  : 	Sys_FreeLibrary( &msacm_dll );

	push	OFFSET _msacm_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 731  : 	avi_initialized = false;

	mov	DWORD PTR _avi_initialized, 0
$LN1@AVI_Shutdo:

; 732  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_Initailize
_TEXT	SEGMENT
_AVI_Initailize PROC					; COMDAT

; 693  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 694  : 	if( Sys_CheckParm( "-noavi" ))

	push	OFFSET ??_C@_06ICLMKCAB@?9noavi@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@AVI_Initai

; 695  : 	{
; 696  : 		Con_Printf( "AVI: Disabled\n" );

	push	OFFSET ??_C@_0P@OMHOPAK@AVI?3?5Disabled?6@
	call	_Con_Printf
	add	esp, 4

; 697  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_Initai
$LN2@AVI_Initai:

; 698  : 	}
; 699  : 
; 700  : 	if( !Sys_LoadLibrary( &avifile_dll ))

	push	OFFSET _avifile_dll
	call	_Sys_LoadLibrary
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@AVI_Initai

; 701  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_Initai
$LN3@AVI_Initai:

; 702  : 
; 703  : 	if( !Sys_LoadLibrary( &msvfw_dll ))

	push	OFFSET _msvfw_dll
	call	_Sys_LoadLibrary
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@AVI_Initai

; 704  : 	{
; 705  : 		Sys_FreeLibrary( &avifile_dll );

	push	OFFSET _avifile_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 706  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_Initai
$LN4@AVI_Initai:

; 707  : 	}
; 708  : 
; 709  : 	if( !Sys_LoadLibrary( &msacm_dll ))

	push	OFFSET _msacm_dll
	call	_Sys_LoadLibrary
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@AVI_Initai

; 710  : 	{
; 711  : 		Sys_FreeLibrary( &avifile_dll );

	push	OFFSET _avifile_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 712  : 		Sys_FreeLibrary( &msvfw_dll );

	push	OFFSET _msvfw_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 713  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_Initai
$LN5@AVI_Initai:

; 714  : 	}
; 715  : 
; 716  : 	avi_initialized = true;

	mov	DWORD PTR _avi_initialized, 1

; 717  : 	pAVIFileInit();

	call	DWORD PTR _pAVIFileInit

; 718  : 
; 719  : 	return true;

	mov	eax, 1
$LN1@AVI_Initai:

; 720  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_Initailize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetState
_TEXT	SEGMENT
_num$ = 8						; size = 4
_AVI_GetState PROC					; COMDAT

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 638  : 	return &avi[num];

	imul	eax, DWORD PTR _num$[ebp], 188
	add	eax, OFFSET _avi

; 639  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_FreeVideo
_TEXT	SEGMENT
_state$ = 8						; size = 4
_AVI_FreeVideo PROC					; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 683  : 	if( !state ) return;

	cmp	DWORD PTR _state$[ebp], 0
	jne	SHORT $LN2@AVI_FreeVi
	jmp	SHORT $LN1@AVI_FreeVi
$LN2@AVI_FreeVi:

; 684  : 
; 685  : 	if( Mem_IsAllocatedExt( cls.mempool, state ))

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@AVI_FreeVi

; 686  : 	{
; 687  : 		AVI_CloseVideo( state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_AVI_CloseVideo
	add	esp, 4

; 688  : 		Mem_Free( state );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_FreeVideo@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@AVI_FreeVi:

; 689  : 	}
; 690  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_FreeVideo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_IsActive
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_AVI_IsActive PROC					; COMDAT

; 630  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 631  : 	if( Avi != NULL )

	cmp	DWORD PTR _Avi$[ebp], 0
	je	SHORT $LN2@AVI_IsActi

; 632  : 		return Avi->active;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1@AVI_IsActi
$LN2@AVI_IsActi:

; 633  : 	return false;

	xor	eax, eax
$LN1@AVI_IsActi:

; 634  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_IsActive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_CloseVideo
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_AVI_CloseVideo PROC					; COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 461  : 	if( Avi->active )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN2@AVI_CloseV

; 462  : 	{
; 463  : 		pAVIStreamGetFrameClose( Avi->video_getframe );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	DWORD PTR _pAVIStreamGetFrameClose

; 464  : 
; 465  : 		if( Avi->audio_stream != NULL )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	$LN3@AVI_CloseV

; 466  : 		{
; 467  : 			pAVIStreamRelease( Avi->audio_stream );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRelease

; 468  : 			Mem_Free( Avi->audio_header );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_CloseVideo@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 469  : 
; 470  : 			if( Avi->audio_codec != WAVE_FORMAT_PCM )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+48], 1
	je	SHORT $LN3@AVI_CloseV

; 471  : 			{
; 472  : 				pacmStreamUnprepareHeader( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, 0 );

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamUnprepareHeader

; 473  : 				pacmStreamClose( Avi->cpa_conversion_stream, 0 );

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _pacmStreamClose

; 474  : 				Mem_Free( Avi->cpa_srcbuffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_CloseVideo@@9@9
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 475  : 				Mem_Free( Avi->cpa_dstbuffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_CloseVideo@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@AVI_CloseV:

; 476  : 			}
; 477  : 		}
; 478  : 
; 479  : 		pAVIStreamRelease( Avi->video_stream );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _pAVIStreamRelease

; 480  : 
; 481  : 		DeleteObject( Avi->hBitmap );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	call	DWORD PTR __imp__DeleteObject@4

; 482  : 		pDrawDibClose( Avi->hDD );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	DWORD PTR _pDrawDibClose

; 483  : 		DeleteDC( Avi->hDC );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	call	DWORD PTR __imp__DeleteDC@4
$LN2@AVI_CloseV:

; 484  : 	}
; 485  : 
; 486  : 	memset( Avi, 0, sizeof( movie_state_t ));

	push	188					; 000000bcH
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 487  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_CloseVideo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetVideoFrameCount
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_AVI_GetVideoFrameCount PROC				; COMDAT

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 282  : 	if( !Avi->active )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@AVI_GetVid

; 283  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_GetVid
$LN2@AVI_GetVid:

; 284  : 
; 285  : 	return Avi->video_frames;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN1@AVI_GetVid:

; 286  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetVideoFrameCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_TimeToSoundPosition
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_time$ = 12						; size = 4
_AVI_TimeToSoundPosition PROC				; COMDAT

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 290  : 	if( !Avi->active || !Avi->audio_stream )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@AVI_TimeTo
	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@AVI_TimeTo
$LN3@AVI_TimeTo:

; 291  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_TimeTo
$LN2@AVI_TimeTo:

; 292  : 
; 293  : 	// UNDONE: what about compressed audio?
; 294  : 	return pAVIStreamTimeToSample( Avi->audio_stream, time ) * Avi->audio_bytes_per_sample;

	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _pAVIStreamTimeToSample
	mov	ecx, DWORD PTR _Avi$[ebp]
	imul	eax, DWORD PTR [ecx+56]
$LN1@AVI_TimeTo:

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_TimeToSoundPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_LoadVideo
_TEXT	SEGMENT
_fullpath$ = -268					; size = 4
_path$ = -264						; size = 256
_Avi$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_load_audio$ = 12					; size = 4
_AVI_LoadVideo PROC					; COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 649  : 	movie_state_t	*Avi;
; 650  : 	string		path;
; 651  : 	const char	*fullpath;
; 652  : 
; 653  : 	// fast reject
; 654  : 	if( !avi_initialized )

	cmp	DWORD PTR _avi_initialized, 0
	jne	SHORT $LN2@AVI_LoadVi

; 655  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AVI_LoadVi
$LN2@AVI_LoadVi:

; 656  : 
; 657  : 	// open cinematic
; 658  : 	Q_snprintf( path, sizeof( path ), "media/%s", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_08BKEEFKLC@media?1?$CFs@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 659  : 	COM_DefaultExtension( path, ".avi" );

	push	OFFSET ??_C@_04CAPFMNON@?4avi@
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 660  : 	fullpath = FS_GetDiskPath( path, false );

	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	mov	DWORD PTR _fullpath$[ebp], eax

; 661  : 
; 662  : 	if( FS_FileExists( path, false ) && !fullpath )

	push	0
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@AVI_LoadVi
	cmp	DWORD PTR _fullpath$[ebp], 0
	jne	SHORT $LN3@AVI_LoadVi

; 663  : 	{
; 664  : 		Con_Printf( "Couldn't load %s from packfile. Please extract it\n", path );

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@DNEPLBAF@Couldn?8t?5load?5?$CFs?5from?5packfile?4@
	call	_Con_Printf
	add	esp, 8

; 665  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_LoadVi
$LN3@AVI_LoadVi:

; 666  : 	}
; 667  : 
; 668  : 	Avi = Mem_Malloc( cls.mempool, sizeof( movie_state_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_LoadVideo@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	188					; 000000bcH
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _Avi$[ebp], eax

; 669  : 	AVI_OpenVideo( Avi, fullpath, load_audio, false );

	push	0
	mov	eax, DWORD PTR _load_audio$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	push	edx
	call	_AVI_OpenVideo
	add	esp, 16					; 00000010H

; 670  : 
; 671  : 	if( !AVI_IsActive( Avi ))

	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_AVI_IsActive
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@AVI_LoadVi

; 672  : 	{
; 673  : 		AVI_FreeVideo( Avi ); // something bad happens

	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_AVI_FreeVideo
	add	esp, 4

; 674  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_LoadVi
$LN4@AVI_LoadVi:

; 675  : 	}
; 676  : 
; 677  : 	// all done
; 678  : 	return Avi;

	mov	eax, DWORD PTR _Avi$[ebp]
$LN1@AVI_LoadVi:

; 679  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_LoadVideo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_OpenVideo
_TEXT	SEGMENT
tv398 = -288						; size = 8
tv352 = -288						; size = 8
tv394 = -280						; size = 4
tv348 = -280						; size = 4
tv388 = -276						; size = 8
tv343 = -276						; size = 8
tv140 = -272						; size = 4
tv384 = -268						; size = 4
tv339 = -268						; size = 4
tv133 = -268						; size = 4
tv74 = -268						; size = 4
_size$1 = -200						; size = 4
_stream$2 = -196					; size = 4
_hr$ = -192						; size = 4
_opened_streams$ = -188					; size = 4
_stream_info$ = -184					; size = 140
_bmih$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_Avi$ = 8						; size = 4
_filename$ = 12						; size = 4
_load_audio$ = 16					; size = 4
_quiet$ = 20						; size = 4
_AVI_OpenVideo PROC					; COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 491  : 	BITMAPINFOHEADER	bmih;
; 492  : 	AVISTREAMINFO	stream_info;
; 493  : 	long		opened_streams = 0;

	mov	DWORD PTR _opened_streams$[ebp], 0

; 494  : 	LONG		hr;
; 495  : 
; 496  : 	// default state: non-working.
; 497  : 	Avi->active = false;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax], 0

; 498  : 	Avi->quiet = quiet;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _quiet$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 499  : 
; 500  : 	// can't load Video For Windows :-(
; 501  : 	if( !avi_initialized ) return;

	cmp	DWORD PTR _avi_initialized, 0
	jne	SHORT $LN6@AVI_OpenVi
	jmp	$LN1@AVI_OpenVi
$LN6@AVI_OpenVi:

; 502  : 
; 503  : 	// load the AVI
; 504  : 	hr = pAVIFileOpen( &Avi->pfile, filename, OF_SHARE_DENY_WRITE, 0L );

	push	0
	push	32					; 00000020H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	add	ecx, 8
	push	ecx
	call	DWORD PTR _pAVIFileOpen
	mov	DWORD PTR _hr$[ebp], eax

; 505  : 
; 506  : 	if( hr != 0 ) // error opening AVI:

	cmp	DWORD PTR _hr$[ebp], 0
	je	$LN7@AVI_OpenVi

; 507  : 	{
; 508  : 		switch( hr )

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], -2147205017	; 80044067H
	jg	SHORT $LN34@AVI_OpenVi
	cmp	DWORD PTR tv74[ebp], -2147205017	; 80044067H
	je	SHORT $LN10@AVI_OpenVi
	cmp	DWORD PTR tv74[ebp], -2147221164	; 80040154H
	je	$LN16@AVI_OpenVi
	cmp	DWORD PTR tv74[ebp], -2147205018	; 80044066H
	je	SHORT $LN8@AVI_OpenVi
	jmp	SHORT $LN16@AVI_OpenVi
$LN34@AVI_OpenVi:
	cmp	DWORD PTR tv74[ebp], -2147205011	; 8004406dH
	je	SHORT $LN12@AVI_OpenVi
	cmp	DWORD PTR tv74[ebp], -2147205009	; 8004406fH
	je	SHORT $LN14@AVI_OpenVi
	jmp	SHORT $LN16@AVI_OpenVi
$LN8@AVI_OpenVi:

; 509  : 		{
; 510  : 		case AVIERR_BADFORMAT:
; 511  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@AVI_OpenVi

; 512  : 				Con_DPrintf( S_ERROR "corrupt file or unknown format.\n" );

	push	OFFSET ??_C@_0CM@IDKPBAPD@?$FO1Error?3?$FO7?5corrupt?5file?5or?5unkn@
	call	_Con_DPrintf
	add	esp, 4
$LN9@AVI_OpenVi:

; 513  : 			break;

	jmp	SHORT $LN2@AVI_OpenVi
$LN10@AVI_OpenVi:

; 514  : 		case AVIERR_MEMORY:
; 515  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@AVI_OpenVi

; 516  : 				Con_DPrintf( S_ERROR "insufficient memory to open file.\n" );

	push	OFFSET ??_C@_0CO@POACPNMK@?$FO1Error?3?$FO7?5insufficient?5memory?5@
	call	_Con_DPrintf
	add	esp, 4
$LN11@AVI_OpenVi:

; 517  : 			break;

	jmp	SHORT $LN2@AVI_OpenVi
$LN12@AVI_OpenVi:

; 518  : 		case AVIERR_FILEREAD:
; 519  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN13@AVI_OpenVi

; 520  : 				Con_DPrintf( S_ERROR "disk error reading file.\n" );

	push	OFFSET ??_C@_0CF@EKECHMB@?$FO1Error?3?$FO7?5disk?5error?5reading?5f@
	call	_Con_DPrintf
	add	esp, 4
$LN13@AVI_OpenVi:

; 521  : 			break;

	jmp	SHORT $LN2@AVI_OpenVi
$LN14@AVI_OpenVi:

; 522  : 		case AVIERR_FILEOPEN:
; 523  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN15@AVI_OpenVi

; 524  : 				Con_DPrintf( S_ERROR "disk error opening file.\n" );

	push	OFFSET ??_C@_0CF@HEFHBKHE@?$FO1Error?3?$FO7?5disk?5error?5opening?5f@
	call	_Con_DPrintf
	add	esp, 4
$LN15@AVI_OpenVi:

; 525  : 			break;

	jmp	SHORT $LN2@AVI_OpenVi
$LN16@AVI_OpenVi:

; 526  : 		case REGDB_E_CLASSNOTREG:
; 527  : 		default:
; 528  : 			if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN18@AVI_OpenVi

; 529  : 				Con_DPrintf( S_ERROR "no handler found (or file not found).\n" );

	push	OFFSET ??_C@_0DC@JGEKJML@?$FO1Error?3?$FO7?5no?5handler?5found?5?$CIor@
	call	_Con_DPrintf
	add	esp, 4
$LN18@AVI_OpenVi:
$LN2@AVI_OpenVi:

; 530  : 			break;
; 531  : 		}
; 532  : 		return;

	jmp	$LN1@AVI_OpenVi
$LN7@AVI_OpenVi:

; 533  : 	}
; 534  : 
; 535  : 	Avi->video_stream = Avi->audio_stream = NULL;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN35@AVI_OpenVi:

; 536  : 
; 537  : 	// open the streams until a stream is not available. 
; 538  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@AVI_OpenVi

; 539  : 	{
; 540  : 		PAVISTREAM	stream = NULL;

	mov	DWORD PTR _stream$2[ebp], 0

; 541  : 
; 542  : 		if( pAVIFileGetStream( Avi->pfile, &stream, 0L, opened_streams++ ) != AVIERR_OK )

	mov	eax, DWORD PTR _opened_streams$[ebp]
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _stream$2[ebp]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _pAVIFileGetStream
	mov	DWORD PTR tv140[ebp], eax
	mov	edx, DWORD PTR _opened_streams$[ebp]
	add	edx, 1
	mov	DWORD PTR _opened_streams$[ebp], edx
	cmp	DWORD PTR tv140[ebp], 0
	je	SHORT $LN19@AVI_OpenVi

; 543  : 			break;

	jmp	$LN5@AVI_OpenVi
$LN19@AVI_OpenVi:

; 544  : 
; 545  : 		if( stream == NULL )

	cmp	DWORD PTR _stream$2[ebp], 0
	jne	SHORT $LN20@AVI_OpenVi

; 546  : 			break;

	jmp	$LN5@AVI_OpenVi
$LN20@AVI_OpenVi:

; 547  : 
; 548  : 		pAVIStreamInfo( stream, &stream_info, sizeof( stream_info ));

	push	140					; 0000008cH
	lea	eax, DWORD PTR _stream_info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$2[ebp]
	push	ecx
	call	DWORD PTR _pAVIStreamInfo

; 549  : 
; 550  : 		if( stream_info.fccType == streamtypeVIDEO && Avi->video_stream == NULL )

	cmp	DWORD PTR _stream_info$[ebp], 1935960438 ; 73646976H
	jne	$LN21@AVI_OpenVi
	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN21@AVI_OpenVi

; 551  : 		{
; 552  : 			Avi->video_stream = stream;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _stream$2[ebp]
	mov	DWORD PTR [eax+12], ecx

; 553  : 			Avi->video_frames = stream_info.dwLength;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _stream_info$[ebp+32]
	mov	DWORD PTR [eax+20], ecx

; 554  : 			Avi->video_xres = stream_info.rcFrame.right - stream_info.rcFrame.left;

	mov	eax, DWORD PTR _stream_info$[ebp+60]
	sub	eax, DWORD PTR _stream_info$[ebp+52]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 555  : 			Avi->video_yres = stream_info.rcFrame.bottom - stream_info.rcFrame.top;

	mov	eax, DWORD PTR _stream_info$[ebp+64]
	sub	eax, DWORD PTR _stream_info$[ebp+56]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 556  : 			Avi->video_fps = (float)stream_info.dwRate / (float)stream_info.dwScale;

	mov	eax, DWORD PTR _stream_info$[ebp+24]
	mov	DWORD PTR tv339[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv339[ebp]
	mov	ecx, DWORD PTR tv339[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv343[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv343[ebp]
	mov	edx, DWORD PTR _stream_info$[ebp+20]
	mov	DWORD PTR tv348[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv348[ebp]
	mov	eax, DWORD PTR tv348[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv352[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv352[ebp]
	divss	xmm0, xmm1
	mov	ecx, DWORD PTR _Avi$[ebp]
	movss	DWORD PTR [ecx+32], xmm0

; 557  : 		}

	jmp	$LN24@AVI_OpenVi
$LN21@AVI_OpenVi:

; 558  : 		else if( stream_info.fccType == streamtypeAUDIO && Avi->audio_stream == NULL && load_audio )

	cmp	DWORD PTR _stream_info$[ebp], 1935963489 ; 73647561H
	jne	$LN23@AVI_OpenVi
	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	$LN23@AVI_OpenVi
	cmp	DWORD PTR _load_audio$[ebp], 0
	je	$LN23@AVI_OpenVi

; 559  : 		{
; 560  : 			long	size;
; 561  : 
; 562  : 			Avi->audio_stream = stream;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _stream$2[ebp]
	mov	DWORD PTR [eax+36], ecx

; 563  : 
; 564  : 			// read the audio header
; 565  : 			pAVIStreamReadFormat( Avi->audio_stream, pAVIStreamStart( Avi->audio_stream ), 0, &size );

	lea	eax, DWORD PTR _size$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _pAVIStreamStart
	push	eax
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamReadFormat

; 566  : 
; 567  : 			Avi->audio_header = (WAVEFORMAT *)Mem_Malloc( cls.mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_OpenVideo@@9@9
	add	eax, 77					; 0000004dH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 568  : 			pAVIStreamReadFormat( Avi->audio_stream, pAVIStreamStart( Avi->audio_stream ), Avi->audio_header, &size );

	lea	eax, DWORD PTR _size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamStart
	push	eax
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _pAVIStreamReadFormat

; 569  : 			Avi->audio_header_size = size;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _size$1[ebp]
	mov	DWORD PTR [eax+44], ecx

; 570  : 			Avi->audio_codec = Avi->audio_header->wFormatTag;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+48], edx

; 571  : 
; 572  : 			// length of converted audio in samples
; 573  : 			Avi->audio_length = (long)((float)stream_info.dwLength / Avi->audio_header->nAvgBytesPerSec );

	mov	eax, DWORD PTR _stream_info$[ebp+32]
	mov	DWORD PTR tv384[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv384[ebp]
	mov	ecx, DWORD PTR tv384[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv388[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv388[ebp]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv394[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv394[ebp]
	mov	edx, DWORD PTR tv394[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv398[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv398[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 574  : 			Avi->audio_length *= Avi->audio_header->nSamplesPerSec;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+52]
	imul	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 575  : 
; 576  : 			if( Avi->audio_codec != WAVE_FORMAT_PCM )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+48], 1
	je	SHORT $LN25@AVI_OpenVi

; 577  : 			{
; 578  : 				if( !AVI_ACMConvertAudio( Avi ))

	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_AVI_ACMConvertAudio
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@AVI_OpenVi

; 579  : 				{
; 580  : 					Mem_Free( Avi->audio_header );

	mov	eax, DWORD PTR ?__LINE__Var@?0??AVI_OpenVideo@@9@9
	add	eax, 90					; 0000005aH
	push	eax
	push	OFFSET ??_C@_0DD@KNDJMHPJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 581  : 					Avi->audio_stream = NULL;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+36], 0

; 582  : 					continue;

	jmp	$LN35@AVI_OpenVi
$LN27@AVI_OpenVi:

; 583  : 				}
; 584  : 			}

	jmp	SHORT $LN26@AVI_OpenVi
$LN25@AVI_OpenVi:

; 585  : 			else Avi->audio_bytes_per_sample = Avi->audio_header->nBlockAlign;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, WORD PTR [ecx+12]
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+56], edx
$LN26@AVI_OpenVi:

; 586  : 			Avi->audio_length *= Avi->audio_bytes_per_sample;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+52]
	imul	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+52], edx

; 587  : 		} 

	jmp	SHORT $LN24@AVI_OpenVi
$LN23@AVI_OpenVi:

; 588  : 		else
; 589  : 		{
; 590  : 			pAVIStreamRelease( stream );

	mov	eax, DWORD PTR _stream$2[ebp]
	push	eax
	call	DWORD PTR _pAVIStreamRelease
$LN24@AVI_OpenVi:

; 591  : 		}
; 592  : 	}

	jmp	$LN35@AVI_OpenVi
$LN5@AVI_OpenVi:

; 593  : 
; 594  : 	// display error message-stream not found. 
; 595  : 	if( Avi->video_stream == NULL )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN28@AVI_OpenVi

; 596  : 	{
; 597  : 		if( Avi->pfile ) // if file is open, close it 

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN29@AVI_OpenVi

; 598  : 			pAVIFileRelease( Avi->pfile );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _pAVIFileRelease
$LN29@AVI_OpenVi:

; 599  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN30@AVI_OpenVi

; 600  : 			Con_DPrintf( S_ERROR "couldn't find a valid video stream.\n" );

	push	OFFSET ??_C@_0DA@KGKLEJPK@?$FO1Error?3?$FO7?5couldn?8t?5find?5a?5vali@
	call	_Con_DPrintf
	add	esp, 4
$LN30@AVI_OpenVi:

; 601  : 		return;

	jmp	$LN1@AVI_OpenVi
$LN28@AVI_OpenVi:

; 602  : 	}
; 603  : 
; 604  : 	pAVIFileRelease( Avi->pfile ); // release the file

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _pAVIFileRelease

; 605  : 	Avi->video_getframe = pAVIStreamGetFrameOpen( Avi->video_stream, NULL ); // open the frame getter

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _pAVIStreamGetFrameOpen
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+16], eax

; 606  : 
; 607  : 	if( Avi->video_getframe == NULL )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN31@AVI_OpenVi

; 608  : 	{
; 609  : 		if( !Avi->quiet )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN32@AVI_OpenVi

; 610  : 			Con_DPrintf( S_ERROR "error attempting to read video frames.\n" );

	push	OFFSET ??_C@_0DD@HEMILJNI@?$FO1Error?3?$FO7?5error?5attempting?5to?5@
	call	_Con_DPrintf
	add	esp, 4
$LN32@AVI_OpenVi:

; 611  : 		return; // couldn't open frame getter.

	jmp	$LN1@AVI_OpenVi
$LN31@AVI_OpenVi:

; 612  : 	}
; 613  : 
; 614  : 	bmih.biSize = sizeof( BITMAPINFOHEADER );

	mov	DWORD PTR _bmih$[ebp], 40		; 00000028H

; 615  : 	bmih.biPlanes = 1;	

	mov	eax, 1
	mov	WORD PTR _bmih$[ebp+12], ax

; 616  : 	bmih.biBitCount = 32;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _bmih$[ebp+14], ax

; 617  : 	bmih.biCompression = BI_RGB;	

	mov	DWORD PTR _bmih$[ebp+16], 0

; 618  : 	bmih.biWidth = Avi->video_xres;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _bmih$[ebp+4], ecx

; 619  : 	bmih.biHeight = -Avi->video_yres; // invert height to flip image upside down

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	neg	ecx
	mov	DWORD PTR _bmih$[ebp+8], ecx

; 620  : 
; 621  : 	Avi->hDC = CreateCompatibleDC( 0 );

	push	0
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 622  : 	Avi->hDD = pDrawDibOpen();

	call	DWORD PTR _pDrawDibOpen
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 623  : 	Avi->hBitmap = CreateDIBSection( Avi->hDC, (BITMAPINFO*)(&bmih), DIB_RGB_COLORS, (void**)(&Avi->pframe_data), NULL, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	push	0
	lea	ecx, DWORD PTR _bmih$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+172]
	push	eax
	call	DWORD PTR __imp__CreateDIBSection@24
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 624  : 	SelectObject( Avi->hDC, Avi->hBitmap );

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+172]
	push	eax
	call	DWORD PTR __imp__SelectObject@8

; 625  : 
; 626  : 	Avi->active = true; // done

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax], 1
$LN1@AVI_OpenVi:

; 627  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_OpenVideo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetAudioChunk
_TEXT	SEGMENT
_blockread$1 = -16					; size = 4
_remaining_length$2 = -12				; size = 4
_i$ = -8						; size = 4
_result$ = -4						; size = 4
_Avi$ = 8						; size = 4
_audiodata$ = 12					; size = 4
_offset$ = 16						; size = 4
_length$ = 20						; size = 4
_AVI_GetAudioChunk PROC					; COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 387  : 	long	result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 388  : 	int	i;
; 389  : 
; 390  : 	// zero data past the end of the file
; 391  : 	if( offset + length > Avi->audio_length )

	mov	eax, DWORD PTR _offset$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	cmp	eax, DWORD PTR [ecx+52]
	jle	$LN10@AVI_GetAud

; 392  : 	{
; 393  : 		if( offset <= Avi->audio_length )

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jg	SHORT $LN11@AVI_GetAud

; 394  : 		{
; 395  : 			long	remaining_length = Avi->audio_length - offset;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	sub	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _remaining_length$2[ebp], ecx

; 396  : 
; 397  : 			AVI_GetAudioChunk( Avi, audiodata, offset, remaining_length );

	mov	eax, DWORD PTR _remaining_length$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _audiodata$[ebp]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	push	eax
	call	_AVI_GetAudioChunk
	add	esp, 16					; 00000010H

; 398  : 
; 399  : 			for( i = remaining_length; i < length; i++ )

	mov	eax, DWORD PTR _remaining_length$2[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@AVI_GetAud
$LN2@AVI_GetAud:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@AVI_GetAud:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jge	SHORT $LN3@AVI_GetAud

; 400  : 				audiodata[i] = 0;

	mov	eax, DWORD PTR _audiodata$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $LN2@AVI_GetAud
$LN3@AVI_GetAud:

; 401  : 		}

	jmp	SHORT $LN10@AVI_GetAud
$LN11@AVI_GetAud:

; 402  : 		else
; 403  : 		{
; 404  : 			// we out of soundtrack, just zeroing buffer
; 405  : 			for( i = 0; i < length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@AVI_GetAud
$LN5@AVI_GetAud:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@AVI_GetAud:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jge	SHORT $LN6@AVI_GetAud

; 406  : 				audiodata[i] = 0;

	mov	eax, DWORD PTR _audiodata$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0
	jmp	SHORT $LN5@AVI_GetAud
$LN6@AVI_GetAud:

; 407  : 
; 408  : 			return length;

	mov	eax, DWORD PTR _length$[ebp]
	jmp	$LN1@AVI_GetAud
$LN10@AVI_GetAud:

; 409  : 		}
; 410  : 	}
; 411  : 
; 412  : 	// uncompressed audio!
; 413  : 	if( Avi->audio_codec == WAVE_FORMAT_PCM )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+48], 1
	jne	SHORT $LN13@AVI_GetAud

; 414  : 	{
; 415  : 		// very simple - read straight out
; 416  : 		pAVIStreamRead( Avi->audio_stream, offset / Avi->audio_bytes_per_sample, length / Avi->audio_bytes_per_sample, audiodata, length, &result, NULL );

	push	0
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _audiodata$[ebp]
	push	edx
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR _length$[ebp]
	cdq
	idiv	DWORD PTR [ecx+56]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR _offset$[ebp]
	cdq
	idiv	DWORD PTR [ecx+56]
	push	eax
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _pAVIStreamRead

; 417  : 		return result;

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@AVI_GetAud

; 418  : 	}

	jmp	$LN1@AVI_GetAud
$LN13@AVI_GetAud:

; 419  : 	else
; 420  : 	{
; 421  : 		// compressed audio!
; 422  : 		result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 423  : 
; 424  : 		// seek to correct chunk and all that stuff
; 425  : 		if( !AVI_SeekPosition( Avi, offset )) 

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	push	ecx
	call	_AVI_SeekPosition
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@AVI_GetAud

; 426  : 			return 0; // don't continue if we're waiting for the play pointer to catch up

	xor	eax, eax
	jmp	$LN1@AVI_GetAud
$LN8@AVI_GetAud:

; 427  : 
; 428  : 		while( length > 0 )

	cmp	DWORD PTR _length$[ebp], 0
	jle	$LN9@AVI_GetAud

; 429  : 		{
; 430  : 			long	blockread = Avi->cpa_conversion_header.cbDstLengthUsed - Avi->cpa_blockpos;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+104]
	sub	edx, DWORD PTR [ecx+164]
	mov	DWORD PTR _blockread$1[ebp], edx

; 431  : 
; 432  : 			if( blockread <= 0 ) // read next

	cmp	DWORD PTR _blockread$1[ebp], 0
	jg	$LN16@AVI_GetAud

; 433  : 			{
; 434  : 				Avi->cpa_blocknum++;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	add	ecx, 1
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+160], ecx

; 435  : 				Avi->cpa_blockoffset += Avi->cpa_conversion_header.cbDstLengthUsed;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _Avi$[ebp]
	add	ecx, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 436  : 
; 437  : 				pAVIStreamRead( Avi->audio_stream, Avi->cpa_blocknum * Avi->cpa_blockalign, Avi->cpa_blockalign, Avi->cpa_srcbuffer, Avi->cpa_blockalign, NULL, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [eax+160]
	imul	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR _pAVIStreamRead

; 438  : 				pacmStreamConvert( Avi->cpa_conversion_stream, &Avi->cpa_conversion_header, ACM_STREAMCONVERTF_BLOCKALIGN );

	push	4
	mov	eax, DWORD PTR _Avi$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _pacmStreamConvert

; 439  : 
; 440  : 				Avi->cpa_blockpos = 0;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [eax+164], 0

; 441  : 				continue;

	jmp	$LN8@AVI_GetAud
$LN16@AVI_GetAud:

; 442  : 			}
; 443  : 
; 444  : 			if( blockread > length )

	mov	eax, DWORD PTR _blockread$1[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jle	SHORT $LN17@AVI_GetAud

; 445  : 				blockread = length;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR _blockread$1[ebp], eax
$LN17@AVI_GetAud:

; 446  : 
; 447  : 			// copy the data
; 448  : 			memcpy( audiodata + result, (void *)( Avi->cpa_dstbuffer + Avi->cpa_blockpos ), blockread );

	mov	eax, DWORD PTR _blockread$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _Avi$[ebp]
	add	edx, DWORD PTR [eax+164]
	push	edx
	mov	ecx, DWORD PTR _audiodata$[ebp]
	add	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 449  : 
; 450  : 			Avi->cpa_blockpos += blockread;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, DWORD PTR _blockread$1[ebp]
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	DWORD PTR [edx+164], ecx

; 451  : 			result += blockread;

	mov	eax, DWORD PTR _result$[ebp]
	add	eax, DWORD PTR _blockread$1[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 452  : 			length -= blockread;

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, DWORD PTR _blockread$1[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 453  : 		}

	jmp	$LN8@AVI_GetAud
$LN9@AVI_GetAud:

; 454  : 
; 455  : 		return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@AVI_GetAud:

; 456  : 	}
; 457  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetAudioChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetAudioInfo
_TEXT	SEGMENT
tv83 = -68						; size = 4
_Avi$ = 8						; size = 4
_snd_info$ = 12						; size = 4
_AVI_GetAudioInfo PROC					; COMDAT

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 317  : 	if( !Avi->active || Avi->audio_stream == NULL || snd_info == NULL )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@AVI_GetAud
	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN3@AVI_GetAud
	cmp	DWORD PTR _snd_info$[ebp], 0
	jne	SHORT $LN2@AVI_GetAud
$LN3@AVI_GetAud:

; 318  : 	{
; 319  : 		return false;

	xor	eax, eax
	jmp	$LN1@AVI_GetAud
$LN2@AVI_GetAud:

; 320  : 	}
; 321  : 
; 322  : 	snd_info->rate = Avi->audio_header->nSamplesPerSec;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _snd_info$[ebp]
	mov	ax, WORD PTR [ecx+4]
	mov	WORD PTR [edx], ax

; 323  : 	snd_info->channels = Avi->audio_header->nChannels;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _snd_info$[ebp]
	mov	al, BYTE PTR [ecx+2]
	mov	BYTE PTR [edx+3], al

; 324  : 
; 325  : 	if( Avi->audio_codec == WAVE_FORMAT_PCM ) // uncompressed audio!

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+48], 1
	jne	SHORT $LN4@AVI_GetAud

; 326  : 		snd_info->width = ( Avi->audio_bytes_per_sample > Avi->audio_header->nChannels ) ? 2 : 1;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, WORD PTR [ecx+2]
	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax+56], edx
	jle	SHORT $LN7@AVI_GetAud
	mov	DWORD PTR tv83[ebp], 2
	jmp	SHORT $LN8@AVI_GetAud
$LN7@AVI_GetAud:
	mov	DWORD PTR tv83[ebp], 1
$LN8@AVI_GetAud:
	mov	ecx, DWORD PTR _snd_info$[ebp]
	mov	dl, BYTE PTR tv83[ebp]
	mov	BYTE PTR [ecx+2], dl
	jmp	SHORT $LN5@AVI_GetAud
$LN4@AVI_GetAud:

; 327  : 	else snd_info->width = 2; // assume compressed audio is always 16 bit

	mov	eax, DWORD PTR _snd_info$[ebp]
	mov	BYTE PTR [eax+2], 2
$LN5@AVI_GetAud:

; 328  : 
; 329  : 	snd_info->size = snd_info->rate * snd_info->width * snd_info->channels;

	mov	eax, DWORD PTR _snd_info$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _snd_info$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, eax
	mov	edx, DWORD PTR _snd_info$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	edx, DWORD PTR _snd_info$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 330  : 	snd_info->loopStart = 0; // using loopStart as streampos

	mov	eax, DWORD PTR _snd_info$[ebp]
	mov	DWORD PTR [eax+4], 0

; 331  : 
; 332  : 	return true;

	mov	eax, 1
$LN1@AVI_GetAud:

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetAudioInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetVideoInfo
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_xres$ = 12						; size = 4
_yres$ = 16						; size = 4
_duration$ = 20						; size = 4
_AVI_GetVideoInfo PROC					; COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 256  : 	if( !Avi->active )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@AVI_GetVid

; 257  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_GetVid
$LN2@AVI_GetVid:

; 258  : 
; 259  : 	if( xres != NULL )

	cmp	DWORD PTR _xres$[ebp], 0
	je	SHORT $LN3@AVI_GetVid

; 260  : 		*xres = Avi->video_xres;

	mov	eax, DWORD PTR _xres$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@AVI_GetVid:

; 261  : 
; 262  : 	if( yres != NULL )

	cmp	DWORD PTR _yres$[ebp], 0
	je	SHORT $LN4@AVI_GetVid

; 263  : 		*yres = Avi->video_yres;

	mov	eax, DWORD PTR _yres$[ebp]
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
$LN4@AVI_GetVid:

; 264  : 
; 265  : 	if( duration != NULL )

	cmp	DWORD PTR _duration$[ebp], 0
	je	SHORT $LN5@AVI_GetVid

; 266  : 		*duration = (float)Avi->video_frames / Avi->video_fps;

	mov	eax, DWORD PTR _Avi$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _Avi$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _duration$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN5@AVI_GetVid:

; 267  : 
; 268  : 	return true;

	mov	eax, 1
$LN1@AVI_GetVid:

; 269  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetVideoInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetVideoFrame
_TEXT	SEGMENT
_frame_raw$ = -8					; size = 4
_frame_info$ = -4					; size = 4
_Avi$ = 8						; size = 4
_frame$ = 12						; size = 4
_AVI_GetVideoFrame PROC					; COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 300  : 	LPBITMAPINFOHEADER	frame_info;
; 301  : 	byte		*frame_raw;
; 302  : 
; 303  : 	if( !Avi->active ) return NULL;

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@AVI_GetVid
	xor	eax, eax
	jmp	$LN1@AVI_GetVid
$LN2@AVI_GetVid:

; 304  : 
; 305  : 	if( frame >= Avi->video_frames )

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jl	SHORT $LN3@AVI_GetVid

; 306  : 		frame = Avi->video_frames - 1;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	DWORD PTR _frame$[ebp], ecx
$LN3@AVI_GetVid:

; 307  : 
; 308  : 	frame_info = (LPBITMAPINFOHEADER)pAVIStreamGetFrame( Avi->video_getframe, frame );

	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	DWORD PTR _pAVIStreamGetFrame
	mov	DWORD PTR _frame_info$[ebp], eax

; 309  : 	frame_raw = (byte *)frame_info + frame_info->biSize + frame_info->biClrUsed * sizeof( RGBQUAD );

	mov	eax, DWORD PTR _frame_info$[ebp]
	mov	ecx, DWORD PTR _frame_info$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _frame_info$[ebp]
	mov	eax, DWORD PTR [edx+32]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _frame_raw$[ebp], ecx

; 310  : 	pDrawDibDraw( Avi->hDD, Avi->hDC, 0, 0, Avi->video_xres, Avi->video_yres, frame_info, frame_raw, 0, 0, Avi->video_xres, Avi->video_yres, 0 );

	push	0
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _frame_raw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frame_info$[ebp]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _Avi$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	push	edx
	mov	eax, DWORD PTR _Avi$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	call	DWORD PTR _pDrawDibDraw

; 311  : 
; 312  : 	return Avi->pframe_data;

	mov	eax, DWORD PTR _Avi$[ebp]
	mov	eax, DWORD PTR [eax+184]
$LN1@AVI_GetVid:

; 313  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetVideoFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\avikit.c
;	COMDAT _AVI_GetVideoFrameNumber
_TEXT	SEGMENT
_Avi$ = 8						; size = 4
_time$ = 12						; size = 4
_AVI_GetVideoFrameNumber PROC				; COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 274  : 	if( !Avi->active )

	mov	eax, DWORD PTR _Avi$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@AVI_GetVid

; 275  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@AVI_GetVid
$LN2@AVI_GetVid:

; 276  : 
; 277  : 	return (time * Avi->video_fps);

	mov	eax, DWORD PTR _Avi$[ebp]
	movss	xmm0, DWORD PTR _time$[ebp]
	mulss	xmm0, DWORD PTR [eax+32]
	cvttss2si eax, xmm0
$LN1@AVI_GetVid:

; 278  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_AVI_GetVideoFrameNumber ENDP
_TEXT	ENDS
END
