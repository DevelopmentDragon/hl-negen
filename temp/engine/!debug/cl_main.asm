; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_mp_decals
PUBLIC	_cl_logofile
PUBLIC	_cl_logocolor
PUBLIC	_cl_allow_download
PUBLIC	_cl_allow_upload
PUBLIC	_cl_download_ingame
PUBLIC	??_C@_09HLNOEJGD@mp_decals@			; `string'
PUBLIC	??_C@_03MHAIKEMP@300@				; `string'
PUBLIC	??_C@_0BM@FNHNOFFA@decals?5limit?5in?5multiplayer@ ; `string'
PUBLIC	_dev_overview
PUBLIC	??_C@_0N@LIOHAFCO@dev_overview@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BM@HDLBGHAN@draw?5level?5in?5overview?9mode@ ; `string'
PUBLIC	_cl_resend
PUBLIC	??_C@_09MCGIDBGM@cl_resend@			; `string'
PUBLIC	??_C@_03OGGONKIH@6?40@				; `string'
PUBLIC	??_C@_0BH@JNOGBONI@time?5to?5resend?5connect@	; `string'
PUBLIC	??_C@_0BC@FNPFKPHK@cl_allow_download@		; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0CP@EBEFOALA@allow?5to?5downloading?5resources?5@ ; `string'
PUBLIC	??_C@_0BA@CLDDKIHF@cl_allow_upload@		; `string'
PUBLIC	??_C@_0CL@EIEPLMFJ@allow?5to?5uploading?5resources?5to@ ; `string'
PUBLIC	??_C@_0BD@JLPOFKFL@cl_download_ingame@		; `string'
PUBLIC	??_C@_0DG@NJNMAEOG@allow?5to?5downloading?5resources?5@ ; `string'
PUBLIC	??_C@_0M@MEADMGND@cl_logofile@			; `string'
PUBLIC	??_C@_06COJIGPIB@lambda@			; `string'
PUBLIC	??_C@_0BB@DLGKBBEJ@player?5logo?5name@		; `string'
PUBLIC	??_C@_0N@NAANHKBJ@cl_logocolor@			; `string'
PUBLIC	??_C@_06HDDOCMMN@orange@			; `string'
PUBLIC	??_C@_0BC@KELHMHFN@player?5logo?5color@		; `string'
PUBLIC	_cl_test_bandwidth
PUBLIC	??_C@_0BC@JGICJKMO@cl_test_bandwidth@		; `string'
PUBLIC	??_C@_0CI@MKEAGAPI@test?5network?5bandwith?5before?5co@ ; `string'
_DATA	SEGMENT
COMM	_cl:BYTE:045dec0H
COMM	_cls:BYTE:049840H
COMM	_clgame:BYTE:040658H
COMM	_cl_nopred:DWORD
COMM	_cl_showfps:DWORD
COMM	_cl_timeout:DWORD
COMM	_cl_nodelta:DWORD
COMM	_cl_interp:DWORD
COMM	_cl_showerror:DWORD
COMM	_cl_nosmooth:DWORD
COMM	_cl_smoothtime:DWORD
COMM	_cl_crosshair:DWORD
COMM	_cl_cmdrate:DWORD
COMM	_cl_updaterate:DWORD
COMM	_cl_solid_players:DWORD
COMM	_cl_idealpitchscale:DWORD
COMM	_cl_lightstyle_lerping:DWORD
COMM	_cl_draw_particles:DWORD
COMM	_cl_draw_tracers:DWORD
COMM	_cl_draw_beams:DWORD
COMM	_cl_clockreset:DWORD
COMM	_cl_fixtimerate:DWORD
COMM	_cl_bmodelinterp:DWORD
COMM	_cl_lw:DWORD
COMM	_cl_showevents:DWORD
COMM	_rate:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_rcon_client_password:DWORD
COMM	_rcon_address:DWORD
COMM	_cl_cmdbackup:DWORD
COMM	_cl_dlmax:DWORD
COMM	_name:DWORD
COMM	_model:DWORD
COMM	_topcolor:DWORD
COMM	_bottomcolor:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0CI@MKEAGAPI@test?5network?5bandwith?5before?5co@
CONST	SEGMENT
??_C@_0CI@MKEAGAPI@test?5network?5bandwith?5before?5co@ DB 'test network '
	DB	'bandwith before connection', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JGICJKMO@cl_test_bandwidth@
CONST	SEGMENT
??_C@_0BC@JGICJKMO@cl_test_bandwidth@ DB 'cl_test_bandwidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KELHMHFN@player?5logo?5color@
CONST	SEGMENT
??_C@_0BC@KELHMHFN@player?5logo?5color@ DB 'player logo color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDDOCMMN@orange@
CONST	SEGMENT
??_C@_06HDDOCMMN@orange@ DB 'orange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAANHKBJ@cl_logocolor@
CONST	SEGMENT
??_C@_0N@NAANHKBJ@cl_logocolor@ DB 'cl_logocolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DLGKBBEJ@player?5logo?5name@
CONST	SEGMENT
??_C@_0BB@DLGKBBEJ@player?5logo?5name@ DB 'player logo name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06COJIGPIB@lambda@
CONST	SEGMENT
??_C@_06COJIGPIB@lambda@ DB 'lambda', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MEADMGND@cl_logofile@
CONST	SEGMENT
??_C@_0M@MEADMGND@cl_logofile@ DB 'cl_logofile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NJNMAEOG@allow?5to?5downloading?5resources?5@
CONST	SEGMENT
??_C@_0DG@NJNMAEOG@allow?5to?5downloading?5resources?5@ DB 'allow to down'
	DB	'loading resources while client is active', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLPOFKFL@cl_download_ingame@
CONST	SEGMENT
??_C@_0BD@JLPOFKFL@cl_download_ingame@ DB 'cl_download_ingame', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EIEPLMFJ@allow?5to?5uploading?5resources?5to@
CONST	SEGMENT
??_C@_0CL@EIEPLMFJ@allow?5to?5uploading?5resources?5to@ DB 'allow to uplo'
	DB	'ading resources to the server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLDDKIHF@cl_allow_upload@
CONST	SEGMENT
??_C@_0BA@CLDDKIHF@cl_allow_upload@ DB 'cl_allow_upload', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EBEFOALA@allow?5to?5downloading?5resources?5@
CONST	SEGMENT
??_C@_0CP@EBEFOALA@allow?5to?5downloading?5resources?5@ DB 'allow to down'
	DB	'loading resources from the server', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FNPFKPHK@cl_allow_download@
CONST	SEGMENT
??_C@_0BC@FNPFKPHK@cl_allow_download@ DB 'cl_allow_download', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNOGBONI@time?5to?5resend?5connect@
CONST	SEGMENT
??_C@_0BH@JNOGBONI@time?5to?5resend?5connect@ DB 'time to resend connect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OGGONKIH@6?40@
CONST	SEGMENT
??_C@_03OGGONKIH@6?40@ DB '6.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCGIDBGM@cl_resend@
CONST	SEGMENT
??_C@_09MCGIDBGM@cl_resend@ DB 'cl_resend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HDLBGHAN@draw?5level?5in?5overview?9mode@
CONST	SEGMENT
??_C@_0BM@HDLBGHAN@draw?5level?5in?5overview?9mode@ DB 'draw level in ove'
	DB	'rview-mode', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LIOHAFCO@dev_overview@
CONST	SEGMENT
??_C@_0N@LIOHAFCO@dev_overview@ DB 'dev_overview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FNHNOFFA@decals?5limit?5in?5multiplayer@
CONST	SEGMENT
??_C@_0BM@FNHNOFFA@decals?5limit?5in?5multiplayer@ DB 'decals limit in mu'
	DB	'ltiplayer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHAIKEMP@300@
CONST	SEGMENT
??_C@_03MHAIKEMP@300@ DB '300', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLNOEJGD@mp_decals@
CONST	SEGMENT
??_C@_09HLNOEJGD@mp_decals@ DB 'mp_decals', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_mp_decals DD	FLAT:??_C@_09HLNOEJGD@mp_decals@
	DD	FLAT:??_C@_03MHAIKEMP@300@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BM@FNHNOFFA@decals?5limit?5in?5multiplayer@
	ORG $+4
_cl_logofile DD	FLAT:??_C@_0M@MEADMGND@cl_logofile@
	DD	FLAT:??_C@_06COJIGPIB@lambda@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BB@DLGKBBEJ@player?5logo?5name@
	ORG $+4
_cl_logocolor DD FLAT:??_C@_0N@NAANHKBJ@cl_logocolor@
	DD	FLAT:??_C@_06HDDOCMMN@orange@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BC@KELHMHFN@player?5logo?5color@
	ORG $+4
_cl_allow_download DD FLAT:??_C@_0BC@FNPFKPHK@cl_allow_download@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0CP@EBEFOALA@allow?5to?5downloading?5resources?5@
	ORG $+4
_cl_allow_upload DD FLAT:??_C@_0BA@CLDDKIHF@cl_allow_upload@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0CL@EIEPLMFJ@allow?5to?5uploading?5resources?5to@
	ORG $+4
_cl_download_ingame DD FLAT:??_C@_0BD@JLPOFKFL@cl_download_ingame@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0DG@NJNMAEOG@allow?5to?5downloading?5resources?5@
	ORG $+4
_dev_overview DD FLAT:??_C@_0N@LIOHAFCO@dev_overview@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BM@HDLBGHAN@draw?5level?5in?5overview?9mode@
	ORG $+4
_cl_resend DD	FLAT:??_C@_09MCGIDBGM@cl_resend@
	DD	FLAT:??_C@_03OGGONKIH@6?40@
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BH@JNOGBONI@time?5to?5resend?5connect@
	ORG $+4
_cl_test_bandwidth DD FLAT:??_C@_0BC@JGICJKMO@cl_test_bandwidth@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	01H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0CI@MKEAGAPI@test?5network?5bandwith?5before?5co@
	ORG $+4
_DATA	ENDS
PUBLIC	_CL_Init
PUBLIC	_CL_Shutdown
PUBLIC	_Host_ClientBegin
PUBLIC	_Host_ClientFrame
PUBLIC	_CL_Active
PUBLIC	_CL_IsInGame
PUBLIC	_CL_IsInMenu
PUBLIC	_CL_IsInConsole
PUBLIC	_CL_IsIntermission
PUBLIC	_CL_Initialized
PUBLIC	_CL_Userinfo
PUBLIC	_CL_DisableVisibility
PUBLIC	_CL_ServerCommand
PUBLIC	_CL_IsRecordDemo
PUBLIC	_CL_IsTimeDemo
PUBLIC	_CL_IsPlaybackDemo
PUBLIC	_CL_IsBackgroundDemo
PUBLIC	_CL_IsBackgroundMap
PUBLIC	_CL_IsQuakeCompatible
PUBLIC	_CL_Disconnect
PUBLIC	_CL_Crashed
PUBLIC	_CL_Drop
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetRealBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetData
PUBLIC	_CL_Quit_f
PUBLIC	_CL_SendCommand
PUBLIC	_CL_Disconnect_f
PUBLIC	_CL_ProcessFile
PUBLIC	_CL_WriteUsercmd
PUBLIC	_CL_GetFragmentSize
PUBLIC	_CL_PrecacheResources
PUBLIC	_CL_SetupOverviewParams
PUBLIC	_CL_UpdateFrameLerp
PUBLIC	_CL_IsDevOverviewMode
PUBLIC	_CL_SignonReply
PUBLIC	_CL_ClearState
PUBLIC	_CL_CheckClientState
PUBLIC	_CL_DriftInterpolationAmount
PUBLIC	_CL_ComputeClientInterpolationAmount
PUBLIC	_CL_ComputePacketLoss
PUBLIC	_CL_FindInterpolatedAddAngle
PUBLIC	_CL_ApplyAddAngle
PUBLIC	_CL_ProcessShowTexturesCmds
PUBLIC	_CL_ProcessOverviewCmds
PUBLIC	_CL_UpdateClientData
PUBLIC	_CL_CreateCmd
PUBLIC	_CL_WritePacket
PUBLIC	_CL_BeginUpload_f
PUBLIC	_CL_GetCDKeyHash
PUBLIC	_CL_SendConnectPacket
PUBLIC	_CL_CheckForResend
PUBLIC	_CL_AddResource
PUBLIC	_CL_CreateResourceList
PUBLIC	_CL_Connect_f
PUBLIC	_CL_Rcon_f
PUBLIC	_CL_SendDisconnectMessage
PUBLIC	_CL_Reconnect
PUBLIC	_CL_LocalServers_f
PUBLIC	_CL_InternetServers_f
PUBLIC	_CL_Reconnect_f
PUBLIC	_CL_FixupColorStringsForInfoString
PUBLIC	_CL_ParseStatusMessage
PUBLIC	_CL_ParseNETInfoMessage
PUBLIC	_CL_ProcessNetRequests
PUBLIC	_CL_ConnectionlessPacket
PUBLIC	_CL_GetMessage
PUBLIC	_CL_ReadNetMessage
PUBLIC	_CL_ReadPackets
PUBLIC	_CL_CleanFileName
PUBLIC	_CL_RegisterCustomization
PUBLIC	_CL_SetInfo_f
PUBLIC	_CL_Physinfo_f
PUBLIC	_CL_FullServerinfo_f
PUBLIC	_CL_Escape_f
PUBLIC	_CL_InitLocal
PUBLIC	_CL_AdjustClock
PUBLIC	??_C@_0M@DKOEGGOG@scr_loading@			; `string'
PUBLIC	??_C@_0BO@PBAMMEOO@client?5connected?5at?5?$CF?42f?5sec?6@ ; `string'
PUBLIC	??_C@_0BE@HJOLPNGG@CL_SignonReply?3?5?$CFi?6@	; `string'
PUBLIC	??_C@_05EAFKHBAM@begin@				; `string'
PUBLIC	??_C@_0DI@MMJIGOKI@cl_updaterate?5minimum?5is?5?$CFf?0?5re@ ; `string'
PUBLIC	??_C@_0O@GLEIJHMA@cl_updaterate@		; `string'
PUBLIC	??_C@_0CH@GCBKIJKK@cl_updaterate?5clamped?5at?5maximu@ ; `string'
PUBLIC	??_C@_0CA@NNLHIFJL@ex_interp?5forced?5up?5to?5?$CFi?5msec?6@ ; `string'
PUBLIC	??_C@_0CC@CGOAGALG@ex_interp?5forced?5down?5to?5?$CFi?5mse@ ; `string'
PUBLIC	??_C@_09LIPGDLPA@ex_interp@			; `string'
PUBLIC	??_C@_0P@MJMKNHCG@r_showtextures@		; `string'
PUBLIC	?__LINE__Var@?0??CL_WriteUsercmd@@9@9		; `CL_WriteUsercmd'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0DJ@BPAMAEGK@from?5?$DN?$DN?5?91?5?$HM?$HM?5?$CI?5from?5?$DO?$DN?50?5?$CG?$CG?5fr@ ; `string'
PUBLIC	??_C@_0CD@GOANGLPP@to?5?$DO?$DN?50?5?$CG?$CG?5to?5?$DM?5MULTIPLAYER_BAC@ ; `string'
PUBLIC	??_C@_0L@DCAPMAMJ@ClientData@			; `string'
PUBLIC	??_C@_0L@FHOEGPOF@cl_cmdrate@			; `string'
PUBLIC	??_C@_0CD@MNHOADLI@?$FO3Warning?3?$FO1?5Connection?5Problem@ ; `string'
PUBLIC	??_C@_0DG@JCLEFCHC@CL_WritePacket?3?5overflowed?5comm@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_BeginUpload_f@@9@9		; `CL_BeginUpload_f'::`1'::__LINE__Var
PUBLIC	??_C@_04HJKAGJBM@?$CBMD5@			; `string'
PUBLIC	??_C@_0CG@IJLLNIPI@Ingoring?5upload?5of?5non?9customiz@ ; `string'
PUBLIC	??_C@_0L@DHBFCELB@custom?4hpk@			; `string'
PUBLIC	??_C@_0DK@MCGJPAHP@Bogus?5data?5retrieved?5from?5?$CFs?0?5a@ ; `string'
PUBLIC	??_C@_0DD@JPFNAHEK@HPAK_AddLump?5called?5with?5bogus?5@ ; `string'
PUBLIC	??_C@_0BA@OPIGPFCH@Purported?3?5?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BA@LICAHJIO@Actual?5?5?5?3?5?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BL@CFCAJJKK@Removing?5conflicting?5lump?6@ ; `string'
PUBLIC	??_C@_0CK@GCLLEHKK@CL_SendConnectPacket?3?5bad?5serve@ ; `string'
PUBLIC	??_C@_09HOOHLIKH@net_qport@			; `string'
PUBLIC	??_C@_04BCJJGJPP@uuid@				; `string'
PUBLIC	??_C@_05IPCIHGO@qport@				; `string'
PUBLIC	??_C@_0BJ@INHGGABP@connect?5?$CFi?5?$CFi?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_09IPAEKDAI@localhost@			; `string'
PUBLIC	??_C@_0DC@CJPDMOGH@?$FO1Error?3?$FO7?5CL_CheckForResend?3?5c@ ; `string'
PUBLIC	??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@ ; `string'
PUBLIC	??_C@_0O@BELBLLBG@getchallenge?6@		; `string'
PUBLIC	??_C@_08IGNJNAKN@cl_dlmax@			; `string'
PUBLIC	??_C@_0CB@PLILGMJK@Connecting?5to?5?$CFs?4?4?4?5?$FLretry?5?$CD?$CFi?$FN@ ; `string'
PUBLIC	??_C@_0BB@BGHIAFEK@bandwidth?5?$CFi?5?$CFi?6@	; `string'
PUBLIC	??_C@_0BO@LICHHHNB@Too?5many?5resources?5on?5client?6@ ; `string'
PUBLIC	??_C@_0BD@IOMBPIHF@logos?1remapped?4bmp@	; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BJ@FPBNGOLO@Usage?3?5connect?5?$DMserver?$DO?6@ ; `string'
PUBLIC	??_C@_0L@BFANEHJC@server?5?$CFs?6@		; `string'
PUBLIC	??_C@_0DO@NCNKNADM@You?5must?5set?5?8rcon_password?8?5be@ ; `string'
PUBLIC	??_C@_05GCMNNKNG@rcon?5@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0FE@OFOGMBMH@You?5must?5either?5be?5connected?5or@ ; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_0N@CCFOLBKF@scr_download@			; `string'
PUBLIC	??_C@_0M@BOHCKFHE@LastMessage@			; `string'
PUBLIC	??_C@_0L@KKPFIJOL@disconnect@			; `string'
PUBLIC	??_C@_03CLCAEGCJ@new@				; `string'
PUBLIC	??_C@_0BK@EFMONHFA@disconnected?5from?5server?6@ ; `string'
PUBLIC	??_C@_0DD@FDBOEDJA@Scanning?5for?5servers?5on?5the?5loc@ ; `string'
PUBLIC	??_C@_07GBLEFLLO@info?5?$CFi@			; `string'
PUBLIC	??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@	; `string'
PUBLIC	??_C@_0BB@FHKNHLNB@ms?4xash?4su?327010@		; `string'
PUBLIC	??_C@_0CC@FKAGDMAF@?$FO1Error?3?$FO7?5Can?8t?5resolve?5adr?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CO@DFHJDOOJ@Scanning?5for?5servers?5on?5the?5int@ ; `string'
PUBLIC	??_C@_07GGMBKBFD@gamedir@			; `string'
PUBLIC	??_C@_04PNCPDLMM@0?499@				; `string'
PUBLIC	??_C@_05IBNOFEBL@clver@				; `string'
PUBLIC	??_C@_0BB@DIBMBDMI@reconnecting?4?4?4?6@	; `string'
PUBLIC	??_C@_0BK@JJLGHCHK@?$FO1Server?$FO7?3?5?$CFs?0?5Info?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BK@JEDBHIFD@?$FO2Server?$FO7?3?5?$CFs?0?5Game?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_08EJOEDJLI@neterror@			; `string'
PUBLIC	??_C@_08FCFPNNHF@protocol@			; `string'
PUBLIC	??_C@_09MLGAJAED@undefined@			; `string'
PUBLIC	?__LINE__Var@?0??CL_ConnectionlessPacket@@9@9	; `CL_ConnectionlessPacket'::`1'::__LINE__Var
PUBLIC	??_C@_0CC@OJAMPIDI@CL_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_0P@IOGHOCLL@client_connect@		; `string'
PUBLIC	??_C@_0CK@DICJNNNK@?$FO1Error?3?$FO7?5dup?5connect?5received@ ; `string'
PUBLIC	??_C@_04NIDJFNBE@info@				; `string'
PUBLIC	??_C@_07PHGFOLHM@netinfo@			; `string'
PUBLIC	??_C@_03LGLGIONO@cmd@				; `string'
PUBLIC	??_C@_0CL@MOFOLJMP@Command?5packet?5from?5remote?5host@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0L@BEEDAEFO@testpacket@			; `string'
PUBLIC	??_C@_0DE@IFANHFOD@CRC?5?$CFp?5is?5matched?0?5get?5challeng@ ; `string'
PUBLIC	??_C@_04OONEELOO@ping@				; `string'
PUBLIC	??_C@_03JBLJHHJA@ack@				; `string'
PUBLIC	??_C@_09DBEGHIJJ@challenge@			; `string'
PUBLIC	??_C@_04OFDNEFMC@echo@				; `string'
PUBLIC	??_C@_01INIBCBCB@f@				; `string'
PUBLIC	??_C@_0BF@JLOFCKGL@serverlist?5call?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@ ; `string'
PUBLIC	??_C@_0L@GIBDHCEL@ServerData@			; `string'
PUBLIC	??_C@_0CN@GMBCANBL@?$FO3Warning?3?$FO7?5CL_ReadPackets?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0ED@FEECBHMH@?$FO1Error?3?$FO7?5CL_ReadPackets?3?5?$CFs?3s@ ; `string'
PUBLIC	??_C@_0BP@CBAODGNF@?6Server?5connection?5timed?5out?4?6@ ; `string'
PUBLIC	??_C@_0O@FPFBHEJO@customization@		; `string'
PUBLIC	??_C@_0CN@IBPOEPKJ@Unable?5to?5create?5custom?5decal?5f@ ; `string'
PUBLIC	??_C@_0CK@FPPFLGNI@Duplicate?5resource?5received?5and@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_ProcessFile@@9@9		; `CL_ProcessFile'::`1'::__LINE__Var
PUBLIC	??_C@_06PBLIODKG@sound?1@			; `string'
PUBLIC	??_C@_0P@FNEEOGHP@processing?5?$CFs?6@		; `string'
PUBLIC	??_C@_0DA@NHIBONO@?$FO1Error?3?$FO7?5server?5failed?5to?5tra@ ; `string'
PUBLIC	??_C@_0ED@IBJGKGBH@Downloaded?5?$CFi?5bytes?5for?5purport@ ; `string'
PUBLIC	??_C@_0BG@KLNLHGNN@Resource?5Registration@	; `string'
PUBLIC	??_C@_0ED@OIDIDHDM@Received?5a?5decal?5?$CFs?0?5but?5didn?8t@ ; `string'
PUBLIC	??_C@_0BF@CNHFFNEA@User?5info?5settings?3?6@	; `string'
PUBLIC	??_C@_0BC@KADBPMIN@Total?5?$CFi?5symbols?6@	; `string'
PUBLIC	??_C@_0CC@PIAKLNIH@Usage?3?5setinfo?5?$FL?5?$DMkey?$DO?5?$DMvalue?$DO?5@ ; `string'
PUBLIC	??_C@_0BF@GODLHHLE@Phys?5info?5settings?3?6@	; `string'
PUBLIC	??_C@_0CC@DKBPLKFE@?$FO1Error?3?$FO7?5submodel?5?$CFs?5not?5foun@ ; `string'
PUBLIC	??_C@_0BP@KOCONAKK@?$FO1Error?3?$FO7?5?$CFs?$CFs?5couldn?8t?5load?6@ ; `string'
PUBLIC	??_C@_0CO@BDGNMEFL@Usage?3?5fullserverinfo?5?$DMcomplete@ ; `string'
PUBLIC	??_C@_0BH@NFCHEABC@show?5weapon?5chrosshair@	; `string'
PUBLIC	??_C@_09NBNKIDFG@crosshair@			; `string'
PUBLIC	??_C@_0CO@IPIGBHJN@disable?5delta?9compression?5for?5s@ ; `string'
PUBLIC	??_C@_0L@BPLIDNFG@cl_nodelta@			; `string'
PUBLIC	??_C@_0ED@JGEPHGDP@how?5much?5to?5look?5up?1down?5slopes@ ; `string'
PUBLIC	??_C@_03LNMAPFD@0?48@				; `string'
PUBLIC	??_C@_0BD@FBOKDBLE@cl_idealpitchscale@		; `string'
PUBLIC	??_C@_0DC@FNMDJCPC@Make?5all?5players?5not?5solid?5?$CIcan@ ; `string'
PUBLIC	??_C@_0BB@BGAFDJDO@cl_solid_players@		; `string'
PUBLIC	??_C@_0EA@HNPMKLI@Interpolate?5object?5positions?5st@ ; `string'
PUBLIC	??_C@_03NKBOLEBK@0?41@				; `string'
PUBLIC	??_C@_0BN@CMKNHDIB@connect?5timeout?5?$CIin?9seconds?$CJ@ ; `string'
PUBLIC	??_C@_02PPBOIJDM@60@				; `string'
PUBLIC	??_C@_0L@JCNOFHIK@cl_timeout@			; `string'
PUBLIC	??_C@_0BP@LIMJMBAH@remote?5control?5client?5password@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0O@EEIAMLPM@rcon_password@		; `string'
PUBLIC	??_C@_0BH@BPEKCJOI@remote?5control?5address@	; `string'
PUBLIC	??_C@_0N@PJJENLON@rcon_address@			; `string'
PUBLIC	??_C@_0CD@FJCEHFJG@disable?5client?5movement?5predict@ ; `string'
PUBLIC	??_C@_09EFLGBOKH@cl_nopred@			; `string'
PUBLIC	??_C@_0M@IBMGFCGL@player?5name@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_0DA@GGEFMNKI@player?5model?5?$CI?8player?8?5is?5a?5sin@ ; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_0CA@IMLGPKIK@refresh?5rate?5of?5server?5messages@ ; `string'
PUBLIC	??_C@_02PIBHCBOA@20@				; `string'
PUBLIC	??_C@_0DA@PBHOBKHC@max?5allowed?5fragment?5size?5on?5do@ ; `string'
PUBLIC	??_C@_0BE@CPFCAJAK@player?5network?5rate@	; `string'
PUBLIC	??_C@_04ODIEBBEE@3500@				; `string'
PUBLIC	??_C@_04HCCHHEEF@rate@				; `string'
PUBLIC	??_C@_0BB@ILOPDEKA@player?5top?5color@		; `string'
PUBLIC	??_C@_08OLGKFJAO@topcolor@			; `string'
PUBLIC	??_C@_0BE@KBFJNKLM@player?5bottom?5color@	; `string'
PUBLIC	??_C@_0M@IIFIMDEK@bottomcolor@			; `string'
PUBLIC	??_C@_0CA@DGECEPIL@enable?5client?5weapon?5predicting@ ; `string'
PUBLIC	??_C@_05COECHLGF@cl_lw@				; `string'
PUBLIC	??_C@_0BI@HOGAGOPD@enable?5lag?5compensation@	; `string'
PUBLIC	??_C@_05OMKMDA@cl_lc@				; `string'
PUBLIC	??_C@_0BA@BOCGHAFM@server?5password@		; `string'
PUBLIC	??_C@_08NLHBPEGP@password@			; `string'
PUBLIC	??_C@_0M@OFDHDJHD@player?5team@			; `string'
PUBLIC	??_C@_04KADBPNCB@team@				; `string'
PUBLIC	??_C@_0M@JCPGJACL@player?5skin@			; `string'
PUBLIC	??_C@_04NHPAFEHJ@skin@				; `string'
PUBLIC	??_C@_0BA@MDNBJAOI@show?5client?5fps@		; `string'
PUBLIC	??_C@_0L@FNAGCLGI@cl_showfps@			; `string'
PUBLIC	??_C@_0EJ@KOJLGMDL@disable?5smooth?5up?5stair?5climbin@ ; `string'
PUBLIC	??_C@_0M@LLEMEGKL@cl_nosmooth@			; `string'
PUBLIC	??_C@_0BC@ECBHFPKG@time?5to?5smooth?5up@	; `string'
PUBLIC	??_C@_0O@CDOPINFK@cl_smoothtime@		; `string'
PUBLIC	??_C@_0CO@LLNCFEDN@how?5many?5additional?5history?5com@ ; `string'
PUBLIC	??_C@_02PKFBJPLJ@10@				; `string'
PUBLIC	??_C@_0N@NGMAFPKG@cl_cmdbackup@			; `string'
PUBLIC	??_C@_0DI@MEFENBID@Max?5number?5of?5command?5packets?5s@ ; `string'
PUBLIC	??_C@_02PJNFELNH@30@				; `string'
PUBLIC	??_C@_0BB@CDBJOONC@render?5particles@		; `string'
PUBLIC	??_C@_0BA@DLDAOBHF@r_drawparticles@		; `string'
PUBLIC	??_C@_0P@BBEPAELE@render?5tracers@		; `string'
PUBLIC	??_C@_0O@DNAKHALD@r_drawtracers@		; `string'
PUBLIC	??_C@_0N@KECJKNEI@render?5beams@		; `string'
PUBLIC	??_C@_0M@EHKDLKIM@r_drawbeams@			; `string'
PUBLIC	??_C@_0DD@CIKONPNB@enables?5animated?5light?5lerping?5@ ; `string'
PUBLIC	??_C@_0BG@IKBGNHPM@cl_lightstyle_lerping@	; `string'
PUBLIC	??_C@_0BG@FPPOLPLK@show?5prediction?5error@	; `string'
PUBLIC	??_C@_0N@BLPCJECL@cl_showerror@			; `string'
PUBLIC	??_C@_0BM@OOMCGAMM@enable?5bmodel?5interpolation@ ; `string'
PUBLIC	??_C@_0BA@HDGLEIEB@cl_bmodelinterp@		; `string'
PUBLIC	??_C@_0CL@EHNJPADF@frametime?5delta?5maximum?5value?5b@ ; `string'
PUBLIC	??_C@_0O@DJEBIBFL@cl_clockreset@		; `string'
PUBLIC	??_C@_0CH@CLKODIIO@time?5in?5msec?5to?5client?5clock?5ad@ ; `string'
PUBLIC	??_C@_03CDKFEJKH@7?45@				; `string'
PUBLIC	??_C@_0P@GBJMGNNJ@cl_fixtimerate@		; `string'
PUBLIC	??_C@_0CA@CCEFHBIN@scale?5hud?5at?5current?5resolution@ ; `string'
PUBLIC	??_C@_02PGHGPEOM@?91@				; `string'
PUBLIC	??_C@_09GMLECNLK@hud_scale@			; `string'
PUBLIC	??_C@_0CI@MOIEJPFN@indicate?5what?5background?5map?5is@ ; `string'
PUBLIC	??_C@_0BF@DPPOLODC@show?5events?5playback@	; `string'
PUBLIC	??_C@_0O@FNNFDDLC@cl_showevents@		; `string'
PUBLIC	??_C@_0BB@COIHEPAG@last?5played?5demo@		; `string'
PUBLIC	??_C@_08DAPDEFAC@lastdemo@			; `string'
PUBLIC	??_C@_0CI@MGEECIPN@ambient?5lighting?5level?5?$CIlegacy?0@ ; `string'
PUBLIC	??_C@_0L@IEGJIKFJ@lightgamma@			; `string'
PUBLIC	??_C@_0CH@JDLOPMPD@direct?5lighting?5level?5?$CIlegacy?0?5@ ; `string'
PUBLIC	??_C@_06LMLJGLPA@direct@			; `string'
PUBLIC	??_C@_0CD@PNOAHLOJ@enable?5or?5disable?5no?5clipping?5m@ ; `string'
PUBLIC	??_C@_06IHODGGMJ@noclip@			; `string'
PUBLIC	??_C@_0CI@JHOKLOME@notarget?5mode?5?$CImonsters?5do?5not?5@ ; `string'
PUBLIC	??_C@_08HPLPOCJL@notarget@			; `string'
PUBLIC	??_C@_0CE@OIDLHPFJ@re?9init?5HUD?5on?5start?5demo?5recor@ ; `string'
PUBLIC	??_C@_0L@BAECHHDI@fullupdate@			; `string'
PUBLIC	??_C@_0BO@BFJDPOLM@give?5specified?5item?5or?5weapon@ ; `string'
PUBLIC	??_C@_04BMBHJADG@give@				; `string'
PUBLIC	??_C@_0CG@KPKDPDDB@drop?5current?1specified?5item?5or?5@ ; `string'
PUBLIC	??_C@_04PIONEEJD@drop@				; `string'
PUBLIC	??_C@_0P@CNBLLDB@show?5game?5logo@		; `string'
PUBLIC	??_C@_09EPLNALMJ@gametitle@			; `string'
PUBLIC	??_C@_0O@DJFCAHFH@die?5instantly@		; `string'
PUBLIC	??_C@_04BJJEOANI@kill@				; `string'
PUBLIC	??_C@_0P@IHCIBFKI@enable?5godmode@		; `string'
PUBLIC	??_C@_03DKFAMNOH@god@				; `string'
PUBLIC	??_C@_0BJ@JILCKFBM@set?5client?5field?5of?5view@ ; `string'
PUBLIC	??_C@_03PKBINKFB@fov@				; `string'
PUBLIC	??_C@_0BG@MDLCPPLP@logging?5server?5events@	; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_0CO@PMNFOODE@pause?5the?5game?5?$CIif?5the?5server?5a@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_0CB@HEKGMPDC@collect?5info?5about?5local?5server@ ; `string'
PUBLIC	??_C@_0N@OHPGBJMI@localservers@			; `string'
PUBLIC	??_C@_0CE@FCJGMNIB@collect?5info?5about?5internet?5ser@ ; `string'
PUBLIC	??_C@_0BA@HMMIBNGA@internetservers@		; `string'
PUBLIC	??_C@_0CN@KALGIHLE@Play?5cd?9track?5?$CInot?5real?5cd?9play@ ; `string'
PUBLIC	??_C@_02ELLOPNDH@cd@				; `string'
PUBLIC	??_C@_0CM@EAINAEGG@Play?5mp3?9track?5?$CIbased?5on?5virtua@ ; `string'
PUBLIC	??_C@_03LHGNACFN@mp3@				; `string'
PUBLIC	??_C@_0DK@LMLJPMOP@examine?5or?5change?5the?5userinfo?5@ ; `string'
PUBLIC	??_C@_07BANLMPIG@setinfo@			; `string'
PUBLIC	??_C@_0DJ@CCNNGOCK@examine?5or?5change?5the?5userinfo?5@ ; `string'
PUBLIC	??_C@_08PPJNGBMG@userinfo@			; `string'
PUBLIC	??_C@_0BO@NJOOMKKF@print?5current?5client?5physinfo@ ; `string'
PUBLIC	??_C@_08PPPJCMOL@physinfo@			; `string'
PUBLIC	??_C@_0BH@PEHNLCL@disconnect?5from?5server@	; `string'
PUBLIC	??_C@_0O@EIHBBIAA@record?5a?5demo@		; `string'
PUBLIC	??_C@_06KKGOIHDP@record@			; `string'
PUBLIC	??_C@_0M@IJLAHPMN@play?5a?5demo@		; `string'
PUBLIC	??_C@_08KNNNHPIP@playdemo@			; `string'
PUBLIC	??_C@_0P@BGKPKPPK@demo?5benchmark@		; `string'
PUBLIC	??_C@_08LGFIIHD@timedemo@			; `string'
PUBLIC	??_C@_0BN@OJLIDBHD@delete?5a?5specified?5demo?5file@ ; `string'
PUBLIC	??_C@_08PJGEFPKP@killdemo@			; `string'
PUBLIC	??_C@_0DD@POMNLFOG@start?5playing?5back?5the?5selected@ ; `string'
PUBLIC	??_C@_0L@PNDCJELG@startdemos@			; `string'
PUBLIC	??_C@_0DN@JLIMINEP@restart?5looping?5demos?5defined?5b@ ; `string'
PUBLIC	??_C@_05CFPGCNL@demos@				; `string'
PUBLIC	??_C@_0N@BDPMHENF@play?5a?5movie@		; `string'
PUBLIC	??_C@_05PAONDCEJ@movie@				; `string'
PUBLIC	??_C@_0CB@ILBKKEAI@stop?5playing?5or?5recording?5a?5dem@ ; `string'
PUBLIC	??_C@_04PEGFANN@stop@				; `string'
PUBLIC	??_C@_0DJ@OGHCBBKD@collect?5info?5about?5local?5server@ ; `string'
PUBLIC	??_C@_0BJ@MOFFGFNO@escape?5from?5game?5to?5menu@ ; `string'
PUBLIC	??_C@_06CHNIFGOF@escape@			; `string'
PUBLIC	??_C@_0BN@CLBJFNJG@toggle?5between?5game?5and?5menu@ ; `string'
PUBLIC	??_C@_0L@HBDHBCHM@togglemenu@			; `string'
PUBLIC	??_C@_0CL@CGJHNICJ@show?5leaks?5on?5a?5map?5?$CIif?5present@ ; `string'
PUBLIC	??_C@_09OEGDAIFJ@pointfile@			; `string'
PUBLIC	??_C@_08OGKOBMOC@linefile@			; `string'
PUBLIC	??_C@_0CH@MMJIKCDL@sent?5by?5server?5when?5serverinfo?5@ ; `string'
PUBLIC	??_C@_0P@FNBOAPB@fullserverinfo@		; `string'
PUBLIC	??_C@_0BN@LJPCPLKK@uploading?5file?5to?5the?5server@ ; `string'
PUBLIC	??_C@_06KAOCKAGB@upload@			; `string'
PUBLIC	??_C@_0P@MHFGDMFE@quit?5from?5game@		; `string'
PUBLIC	??_C@_04KNNLNNGO@quit@				; `string'
PUBLIC	??_C@_04MKNBDEPB@exit@				; `string'
PUBLIC	??_C@_0CO@FDJKINND@takes?5a?5screenshot?5of?5the?5next?5@ ; `string'
PUBLIC	??_C@_0L@CMHOPIGK@screenshot@			; `string'
PUBLIC	??_C@_0CM@MIGONHLN@takes?5a?5snapshot?5of?5the?5next?5re@ ; `string'
PUBLIC	??_C@_08HLGCJJEE@snapshot@			; `string'
PUBLIC	??_C@_0DD@EKKNFHMF@takes?5a?5six?9sides?5cubemap?5shot?5@ ; `string'
PUBLIC	??_C@_07EMBMCCDB@envshot@			; `string'
PUBLIC	??_C@_0DL@JCALLELG@takes?5a?5six?9sides?5envmap?5?$CIskybo@ ; `string'
PUBLIC	??_C@_07FFKGIHOP@skyshot@			; `string'
PUBLIC	??_C@_0DE@GCJKHONG@same?5as?5?$CCscreenshot?$CC?0?5used?5for?5@ ; `string'
PUBLIC	??_C@_09EFOFPGPE@levelshot@			; `string'
PUBLIC	??_C@_0DB@KFMPKFFP@used?5for?5create?5save?5previews?5w@ ; `string'
PUBLIC	??_C@_08FDCALKIA@saveshot@			; `string'
PUBLIC	??_C@_0CA@MGLGGAIH@connect?5to?5a?5server?5by?5hostname@ ; `string'
PUBLIC	??_C@_07KAIBNCHO@connect@			; `string'
PUBLIC	??_C@_0BL@IIAKJDKL@reconnect?5to?5current?5level@ ; `string'
PUBLIC	??_C@_09MCGBPECP@reconnect@			; `string'
PUBLIC	??_C@_0FA@CJPAEKPF@sends?5a?5command?5to?5the?5server?5c@ ; `string'
PUBLIC	??_C@_04CLKJCJJE@rcon@				; `string'
PUBLIC	??_C@_0N@ONJNAGAI@cls?4datagram@		; `string'
PUBLIC	??_C@_0O@GJDENGBI@?$CFs?1client?4dll@		; `string'
PUBLIC	??_C@_0BN@JKJBEKAB@can?8t?5initialize?5client?4dll?6@ ; `string'
PUBLIC	??_C@_0P@BLEODOCM@CL_Shutdown?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0P@FDJBLPMJ@demoheader?4tmp@		; `string'
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f50624de0000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff028f5c28f5c29
PUBLIC	__real@40000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@402e000000000000
PUBLIC	__real@4059800000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40f00000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42cc0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@46000000
PUBLIC	__real@bf800000
PUBLIC	__real@bf847ae147ae147b
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_GetCurrentUser:PROC
EXTRN	_Sys_GetMachineKey:PROC
EXTRN	_Sys_Quit:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Cmd_ForwardToServer:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_PrintStats:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_RegisterVariable:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_NET_Config:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_GetPacket:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Host_EndGame:PROC
EXTRN	_Host_WriteOpenGLConfig:PROC
EXTRN	_Host_WriteVideoConfig:PROC
EXTRN	_Host_WriteConfig:PROC
EXTRN	_Host_IsLocalGame:PROC
EXTRN	_Host_IsLocalClient:PROC
EXTRN	_Host_ShutdownServer:PROC
EXTRN	_Host_Error:PROC
EXTRN	_SV_Active:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_BlockSequence:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_HashFile:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_CreateCustomization:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_HPAK_ResourceForHash:PROC
EXTRN	_HPAK_AddLump:PROC
EXTRN	_HPAK_RemoveLump:PROC
EXTRN	_HPAK_FlushHostQueue:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_CL_GetMaxClients:PROC
EXTRN	_CL_LoadProgs:PROC
EXTRN	_SCR_UpdateScreen:PROC
EXTRN	_SCR_Shutdown:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_Print:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_Init:PROC
EXTRN	_S_Shutdown:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_fabs:PROC
EXTRN	_Mod_LoadWorld:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_BigShort:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_Setup:PROC
EXTRN	_Netchan_CreateFileFragmentsFromBuffer:PROC
EXTRN	_Netchan_CopyNormalFragments:PROC
EXTRN	_Netchan_CopyFileFragments:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_OutOfBand:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_Netchan_Process:PROC
EXTRN	_Netchan_UpdateProgress:PROC
EXTRN	_Netchan_IncomingReady:PROC
EXTRN	_Netchan_CanPacket:PROC
EXTRN	_Netchan_IsLocal:PROC
EXTRN	_Netchan_ReportFlow:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_Netchan_Clear:PROC
EXTRN	_CL_ScreenShot_f:PROC
EXTRN	_CL_SnapShot_f:PROC
EXTRN	_CL_PlayCDTrack_f:PROC
EXTRN	_CL_EnvShot_f:PROC
EXTRN	_CL_SkyShot_f:PROC
EXTRN	_CL_SaveShot_f:PROC
EXTRN	_CL_LevelShot_f:PROC
EXTRN	_CL_MoveToOnHandList:PROC
EXTRN	_CL_ClearResourceLists:PROC
EXTRN	_CL_StartupDemoHeader:PROC
EXTRN	_CL_WriteDemoUserCmd:PROC
EXTRN	_CL_DemoReadMessage:PROC
EXTRN	_CL_CloseDemoHeader:PROC
EXTRN	_CL_PlayDemo_f:PROC
EXTRN	_CL_TimeDemo_f:PROC
EXTRN	_CL_StartDemos_f:PROC
EXTRN	_CL_Demos_f:PROC
EXTRN	_CL_DeleteDemo_f:PROC
EXTRN	_CL_Record_f:PROC
EXTRN	_CL_Stop_f:PROC
EXTRN	_CL_SetEventIndex:PROC
EXTRN	_CL_BatchResourceRequest:PROC
EXTRN	_CL_EstimateNeededResources:PROC
EXTRN	_CL_UnloadProgs:PROC
EXTRN	_CL_FreeEdicts:PROC
EXTRN	_CL_ClearSpriteTextures:PROC
EXTRN	_NetAPI_CancelAllRequests:PROC
EXTRN	_CL_LoadClientSprite:PROC
EXTRN	_CL_ParseServerMessage:PROC
EXTRN	_CL_RequestMissingResources:PROC
EXTRN	_CL_RegisterResources:PROC
EXTRN	_SCR_EndLoadingPlaque:PROC
EXTRN	_SCR_MakeLevelShot:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_SetSolidPlayers:PROC
EXTRN	_CL_PredictMovement:PROC
EXTRN	_CL_MoveSpectatorCamera:PROC
EXTRN	_CL_SetLastUpdate:PROC
EXTRN	_CL_RedoPrediction:PROC
EXTRN	_CL_ClearPhysEnts:PROC
EXTRN	_CL_PushPMStates:PROC
EXTRN	_CL_PopPMStates:PROC
EXTRN	_CL_ParseQuakeMessage:PROC
EXTRN	_CL_MoveThirdpersonCamera:PROC
EXTRN	_CL_EmitEntities:PROC
EXTRN	_CL_ClearEffects:PROC
EXTRN	_CL_ReadPointFile_f:PROC
EXTRN	_CL_ReadLineFile_f:PROC
EXTRN	_Con_Shutdown:PROC
EXTRN	_S_BeginRegistration:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_EndRegistration:PROC
EXTRN	_SND_UpdateSound:PROC
EXTRN	_UI_AddServerToList:PROC
EXTRN	_SCR_FreeCinematic:PROC
EXTRN	_SCR_NextMovie:PROC
EXTRN	_SCR_RunCinematic:PROC
EXTRN	_CL_PlayVideo_f:PROC
EXTRN	_MSG_WriteDeltaUsercmd:PROC
EXTRN	_VID_CheckChanges:PROC
EXTRN	_R_Init:PROC
EXTRN	_R_Shutdown:PROC
EXTRN	_IN_Shutdown:PROC
EXTRN	_VGui_RunFrame:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host_limitlocal:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_world:BYTE
EXTRN	_net_from:BYTE
EXTRN	_net_message:BYTE
EXTRN	_net_message_buffer:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_gl_showtextures:DWORD
EXTRN	_glState:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9 DD 01H DUP (?) ; `CL_ProcessShowTexturesCmds'::`2'::oldbuttons
?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9 DB 0100H DUP (?) ; `CL_GetCDKeyHash'::`2'::szHashedKeyBuffer
?infostring@?1??CL_ParseStatusMessage@@9@9 DB 0108H DUP (?) ; `CL_ParseStatusMessage'::`2'::infostring
?infostring@?1??CL_ParseNETInfoMessage@@9@9 DB 0108H DUP (?) ; `CL_ParseNETInfoMessage'::`2'::infostring
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bf847ae147ae147b
CONST	SEGMENT
__real@bf847ae147ae147b DQ 0bf847ae147ae147br	; -0.01
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42cc0000
CONST	SEGMENT
__real@42cc0000 DD 042cc0000r			; 102
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40f00000
CONST	SEGMENT
__real@40f00000 DD 040f00000r			; 7.5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4059800000000000
CONST	SEGMENT
__real@4059800000000000 DQ 04059800000000000r	; 102
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff028f5c28f5c29
CONST	SEGMENT
__real@3ff028f5c28f5c29 DQ 03ff028f5c28f5c29r	; 1.01
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f50624de0000000
CONST	SEGMENT
__real@3f50624de0000000 DQ 03f50624de0000000r	; 0.001
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0P@FDJBLPMJ@demoheader?4tmp@
CONST	SEGMENT
??_C@_0P@FDJBLPMJ@demoheader?4tmp@ DB 'demoheader.tmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BLEODOCM@CL_Shutdown?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0P@BLEODOCM@CL_Shutdown?$CI?$CJ?6@ DB 'CL_Shutdown()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JKJBEKAB@can?8t?5initialize?5client?4dll?6@
CONST	SEGMENT
??_C@_0BN@JKJBEKAB@can?8t?5initialize?5client?4dll?6@ DB 'can''t initiali'
	DB	'ze client.dll', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJDENGBI@?$CFs?1client?4dll@
CONST	SEGMENT
??_C@_0O@GJDENGBI@?$CFs?1client?4dll@ DB '%s/client.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONJNAGAI@cls?4datagram@
CONST	SEGMENT
??_C@_0N@ONJNAGAI@cls?4datagram@ DB 'cls.datagram', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLKJCJJE@rcon@
CONST	SEGMENT
??_C@_04CLKJCJJE@rcon@ DB 'rcon', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@CJPAEKPF@sends?5a?5command?5to?5the?5server?5c@
CONST	SEGMENT
??_C@_0FA@CJPAEKPF@sends?5a?5command?5to?5the?5server?5c@ DB 'sends a com'
	DB	'mand to the server console (rcon_password and rcon_address re'
	DB	'quired)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCGBPECP@reconnect@
CONST	SEGMENT
??_C@_09MCGBPECP@reconnect@ DB 'reconnect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IIAKJDKL@reconnect?5to?5current?5level@
CONST	SEGMENT
??_C@_0BL@IIAKJDKL@reconnect?5to?5current?5level@ DB 'reconnect to curren'
	DB	't level', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KAIBNCHO@connect@
CONST	SEGMENT
??_C@_07KAIBNCHO@connect@ DB 'connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MGLGGAIH@connect?5to?5a?5server?5by?5hostname@
CONST	SEGMENT
??_C@_0CA@MGLGGAIH@connect?5to?5a?5server?5by?5hostname@ DB 'connect to a'
	DB	' server by hostname', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FDCALKIA@saveshot@
CONST	SEGMENT
??_C@_08FDCALKIA@saveshot@ DB 'saveshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KFMPKFFP@used?5for?5create?5save?5previews?5w@
CONST	SEGMENT
??_C@_0DB@KFMPKFFP@used?5for?5create?5save?5previews?5w@ DB 'used for cre'
	DB	'ate save previews with LoadGame menu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFOFPGPE@levelshot@
CONST	SEGMENT
??_C@_09EFOFPGPE@levelshot@ DB 'levelshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GCJKHONG@same?5as?5?$CCscreenshot?$CC?0?5used?5for?5@
CONST	SEGMENT
??_C@_0DE@GCJKHONG@same?5as?5?$CCscreenshot?$CC?0?5used?5for?5@ DB 'same '
	DB	'as "screenshot", used for create plaque images', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFKGIHOP@skyshot@
CONST	SEGMENT
??_C@_07FFKGIHOP@skyshot@ DB 'skyshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JCALLELG@takes?5a?5six?9sides?5envmap?5?$CIskybo@
CONST	SEGMENT
??_C@_0DL@JCALLELG@takes?5a?5six?9sides?5envmap?5?$CIskybo@ DB 'takes a s'
	DB	'ix-sides envmap (skybox) shot with specified name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMBMCCDB@envshot@
CONST	SEGMENT
??_C@_07EMBMCCDB@envshot@ DB 'envshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EKKNFHMF@takes?5a?5six?9sides?5cubemap?5shot?5@
CONST	SEGMENT
??_C@_0DD@EKKNFHMF@takes?5a?5six?9sides?5cubemap?5shot?5@ DB 'takes a six'
	DB	'-sides cubemap shot with specified name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HLGCJJEE@snapshot@
CONST	SEGMENT
??_C@_08HLGCJJEE@snapshot@ DB 'snapshot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MIGONHLN@takes?5a?5snapshot?5of?5the?5next?5re@
CONST	SEGMENT
??_C@_0CM@MIGONHLN@takes?5a?5snapshot?5of?5the?5next?5re@ DB 'takes a sna'
	DB	'pshot of the next rendered frame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CMHOPIGK@screenshot@
CONST	SEGMENT
??_C@_0L@CMHOPIGK@screenshot@ DB 'screenshot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FDJKINND@takes?5a?5screenshot?5of?5the?5next?5@
CONST	SEGMENT
??_C@_0CO@FDJKINND@takes?5a?5screenshot?5of?5the?5next?5@ DB 'takes a scr'
	DB	'eenshot of the next rendered frame', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit@ DB 'exit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNNLNNGO@quit@
CONST	SEGMENT
??_C@_04KNNLNNGO@quit@ DB 'quit', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHFGDMFE@quit?5from?5game@
CONST	SEGMENT
??_C@_0P@MHFGDMFE@quit?5from?5game@ DB 'quit from game', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KAOCKAGB@upload@
CONST	SEGMENT
??_C@_06KAOCKAGB@upload@ DB 'upload', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LJPCPLKK@uploading?5file?5to?5the?5server@
CONST	SEGMENT
??_C@_0BN@LJPCPLKK@uploading?5file?5to?5the?5server@ DB 'uploading file t'
	DB	'o the server', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNBOAPB@fullserverinfo@
CONST	SEGMENT
??_C@_0P@FNBOAPB@fullserverinfo@ DB 'fullserverinfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MMJIKCDL@sent?5by?5server?5when?5serverinfo?5@
CONST	SEGMENT
??_C@_0CH@MMJIKCDL@sent?5by?5server?5when?5serverinfo?5@ DB 'sent by serv'
	DB	'er when serverinfo changes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGKOBMOC@linefile@
CONST	SEGMENT
??_C@_08OGKOBMOC@linefile@ DB 'linefile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OEGDAIFJ@pointfile@
CONST	SEGMENT
??_C@_09OEGDAIFJ@pointfile@ DB 'pointfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CGJHNICJ@show?5leaks?5on?5a?5map?5?$CIif?5present@
CONST	SEGMENT
??_C@_0CL@CGJHNICJ@show?5leaks?5on?5a?5map?5?$CIif?5present@ DB 'show lea'
	DB	'ks on a map (if present of course)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HBDHBCHM@togglemenu@
CONST	SEGMENT
??_C@_0L@HBDHBCHM@togglemenu@ DB 'togglemenu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLBJFNJG@toggle?5between?5game?5and?5menu@
CONST	SEGMENT
??_C@_0BN@CLBJFNJG@toggle?5between?5game?5and?5menu@ DB 'toggle between g'
	DB	'ame and menu', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHNIFGOF@escape@
CONST	SEGMENT
??_C@_06CHNIFGOF@escape@ DB 'escape', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MOFFGFNO@escape?5from?5game?5to?5menu@
CONST	SEGMENT
??_C@_0BJ@MOFFGFNO@escape?5from?5game?5to?5menu@ DB 'escape from game to '
	DB	'menu', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OGHCBBKD@collect?5info?5about?5local?5server@
CONST	SEGMENT
??_C@_0DJ@OGHCBBKD@collect?5info?5about?5local?5server@ DB 'collect info '
	DB	'about local servers with specified protocol', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEGFANN@stop@
CONST	SEGMENT
??_C@_04PEGFANN@stop@ DB 'stop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ILBKKEAI@stop?5playing?5or?5recording?5a?5dem@
CONST	SEGMENT
??_C@_0CB@ILBKKEAI@stop?5playing?5or?5recording?5a?5dem@ DB 'stop playing'
	DB	' or recording a demo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PAONDCEJ@movie@
CONST	SEGMENT
??_C@_05PAONDCEJ@movie@ DB 'movie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDPMHENF@play?5a?5movie@
CONST	SEGMENT
??_C@_0N@BDPMHENF@play?5a?5movie@ DB 'play a movie', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFPGCNL@demos@
CONST	SEGMENT
??_C@_05CFPGCNL@demos@ DB 'demos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JLIMINEP@restart?5looping?5demos?5defined?5b@
CONST	SEGMENT
??_C@_0DN@JLIMINEP@restart?5looping?5demos?5defined?5b@ DB 'restart loopi'
	DB	'ng demos defined by the last startdemos command', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PNDCJELG@startdemos@
CONST	SEGMENT
??_C@_0L@PNDCJELG@startdemos@ DB 'startdemos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@POMNLFOG@start?5playing?5back?5the?5selected@
CONST	SEGMENT
??_C@_0DD@POMNLFOG@start?5playing?5back?5the?5selected@ DB 'start playing'
	DB	' back the selected demos sequentially', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJGEFPKP@killdemo@
CONST	SEGMENT
??_C@_08PJGEFPKP@killdemo@ DB 'killdemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OJLIDBHD@delete?5a?5specified?5demo?5file@
CONST	SEGMENT
??_C@_0BN@OJLIDBHD@delete?5a?5specified?5demo?5file@ DB 'delete a specifi'
	DB	'ed demo file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGFIIHD@timedemo@
CONST	SEGMENT
??_C@_08LGFIIHD@timedemo@ DB 'timedemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BGKPKPPK@demo?5benchmark@
CONST	SEGMENT
??_C@_0P@BGKPKPPK@demo?5benchmark@ DB 'demo benchmark', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNNNHPIP@playdemo@
CONST	SEGMENT
??_C@_08KNNNHPIP@playdemo@ DB 'playdemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJLAHPMN@play?5a?5demo@
CONST	SEGMENT
??_C@_0M@IJLAHPMN@play?5a?5demo@ DB 'play a demo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KKGOIHDP@record@
CONST	SEGMENT
??_C@_06KKGOIHDP@record@ DB 'record', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EIHBBIAA@record?5a?5demo@
CONST	SEGMENT
??_C@_0O@EIHBBIAA@record?5a?5demo@ DB 'record a demo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PEHNLCL@disconnect?5from?5server@
CONST	SEGMENT
??_C@_0BH@PEHNLCL@disconnect?5from?5server@ DB 'disconnect from server', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPPJCMOL@physinfo@
CONST	SEGMENT
??_C@_08PPPJCMOL@physinfo@ DB 'physinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NJOOMKKF@print?5current?5client?5physinfo@
CONST	SEGMENT
??_C@_0BO@NJOOMKKF@print?5current?5client?5physinfo@ DB 'print current cl'
	DB	'ient physinfo', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPJNGBMG@userinfo@
CONST	SEGMENT
??_C@_08PPJNGBMG@userinfo@ DB 'userinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CCNNGOCK@examine?5or?5change?5the?5userinfo?5@
CONST	SEGMENT
??_C@_0DJ@CCNNGOCK@examine?5or?5change?5the?5userinfo?5@ DB 'examine or c'
	DB	'hange the userinfo string (alias of setinfo)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BANLMPIG@setinfo@
CONST	SEGMENT
??_C@_07BANLMPIG@setinfo@ DB 'setinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LMLJPMOP@examine?5or?5change?5the?5userinfo?5@
CONST	SEGMENT
??_C@_0DK@LMLJPMOP@examine?5or?5change?5the?5userinfo?5@ DB 'examine or c'
	DB	'hange the userinfo string (alias of userinfo)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHGNACFN@mp3@
CONST	SEGMENT
??_C@_03LHGNACFN@mp3@ DB 'mp3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EAINAEGG@Play?5mp3?9track?5?$CIbased?5on?5virtua@
CONST	SEGMENT
??_C@_0CM@EAINAEGG@Play?5mp3?9track?5?$CIbased?5on?5virtua@ DB 'Play mp3-'
	DB	'track (based on virtual cd-player)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELLOPNDH@cd@
CONST	SEGMENT
??_C@_02ELLOPNDH@cd@ DB 'cd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KALGIHLE@Play?5cd?9track?5?$CInot?5real?5cd?9play@
CONST	SEGMENT
??_C@_0CN@KALGIHLE@Play?5cd?9track?5?$CInot?5real?5cd?9play@ DB 'Play cd-'
	DB	'track (not real cd-player of course)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HMMIBNGA@internetservers@
CONST	SEGMENT
??_C@_0BA@HMMIBNGA@internetservers@ DB 'internetservers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FCJGMNIB@collect?5info?5about?5internet?5ser@
CONST	SEGMENT
??_C@_0CE@FCJGMNIB@collect?5info?5about?5internet?5ser@ DB 'collect info '
	DB	'about internet servers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHPGBJMI@localservers@
CONST	SEGMENT
??_C@_0N@OHPGBJMI@localservers@ DB 'localservers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HEKGMPDC@collect?5info?5about?5local?5server@
CONST	SEGMENT
??_C@_0CB@HEKGMPDC@collect?5info?5about?5local?5server@ DB 'collect info '
	DB	'about local servers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PMNFOODE@pause?5the?5game?5?$CIif?5the?5server?5a@
CONST	SEGMENT
??_C@_0CO@PMNFOODE@pause?5the?5game?5?$CIif?5the?5server?5a@ DB 'pause th'
	DB	'e game (if the server allows pausing)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MDLCPPLP@logging?5server?5events@
CONST	SEGMENT
??_C@_0BG@MDLCPPLP@logging?5server?5events@ DB 'logging server events', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKBINKFB@fov@
CONST	SEGMENT
??_C@_03PKBINKFB@fov@ DB 'fov', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JILCKFBM@set?5client?5field?5of?5view@
CONST	SEGMENT
??_C@_0BJ@JILCKFBM@set?5client?5field?5of?5view@ DB 'set client field of '
	DB	'view', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKFAMNOH@god@
CONST	SEGMENT
??_C@_03DKFAMNOH@god@ DB 'god', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHCIBFKI@enable?5godmode@
CONST	SEGMENT
??_C@_0P@IHCIBFKI@enable?5godmode@ DB 'enable godmode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJJEOANI@kill@
CONST	SEGMENT
??_C@_04BJJEOANI@kill@ DB 'kill', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJFCAHFH@die?5instantly@
CONST	SEGMENT
??_C@_0O@DJFCAHFH@die?5instantly@ DB 'die instantly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPLNALMJ@gametitle@
CONST	SEGMENT
??_C@_09EPLNALMJ@gametitle@ DB 'gametitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CNBLLDB@show?5game?5logo@
CONST	SEGMENT
??_C@_0P@CNBLLDB@show?5game?5logo@ DB 'show game logo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PIONEEJD@drop@
CONST	SEGMENT
??_C@_04PIONEEJD@drop@ DB 'drop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KPKDPDDB@drop?5current?1specified?5item?5or?5@
CONST	SEGMENT
??_C@_0CG@KPKDPDDB@drop?5current?1specified?5item?5or?5@ DB 'drop current'
	DB	'/specified item or weapon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMBHJADG@give@
CONST	SEGMENT
??_C@_04BMBHJADG@give@ DB 'give', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BFJDPOLM@give?5specified?5item?5or?5weapon@
CONST	SEGMENT
??_C@_0BO@BFJDPOLM@give?5specified?5item?5or?5weapon@ DB 'give specified '
	DB	'item or weapon', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BAECHHDI@fullupdate@
CONST	SEGMENT
??_C@_0L@BAECHHDI@fullupdate@ DB 'fullupdate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OIDLHPFJ@re?9init?5HUD?5on?5start?5demo?5recor@
CONST	SEGMENT
??_C@_0CE@OIDLHPFJ@re?9init?5HUD?5on?5start?5demo?5recor@ DB 're-init HUD'
	DB	' on start demo recording', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HPLPOCJL@notarget@
CONST	SEGMENT
??_C@_08HPLPOCJL@notarget@ DB 'notarget', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JHOKLOME@notarget?5mode?5?$CImonsters?5do?5not?5@
CONST	SEGMENT
??_C@_0CI@JHOKLOME@notarget?5mode?5?$CImonsters?5do?5not?5@ DB 'notarget '
	DB	'mode (monsters do not see you)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IHODGGMJ@noclip@
CONST	SEGMENT
??_C@_06IHODGGMJ@noclip@ DB 'noclip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PNOAHLOJ@enable?5or?5disable?5no?5clipping?5m@
CONST	SEGMENT
??_C@_0CD@PNOAHLOJ@enable?5or?5disable?5no?5clipping?5m@ DB 'enable or di'
	DB	'sable no clipping mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMLJGLPA@direct@
CONST	SEGMENT
??_C@_06LMLJGLPA@direct@ DB 'direct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JDLOPMPD@direct?5lighting?5level?5?$CIlegacy?0?5@
CONST	SEGMENT
??_C@_0CH@JDLOPMPD@direct?5lighting?5level?5?$CIlegacy?0?5@ DB 'direct li'
	DB	'ghting level (legacy, unused)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEGJIKFJ@lightgamma@
CONST	SEGMENT
??_C@_0L@IEGJIKFJ@lightgamma@ DB 'lightgamma', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MGEECIPN@ambient?5lighting?5level?5?$CIlegacy?0@
CONST	SEGMENT
??_C@_0CI@MGEECIPN@ambient?5lighting?5level?5?$CIlegacy?0@ DB 'ambient li'
	DB	'ghting level (legacy, unused)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAPDEFAC@lastdemo@
CONST	SEGMENT
??_C@_08DAPDEFAC@lastdemo@ DB 'lastdemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIHEPAG@last?5played?5demo@
CONST	SEGMENT
??_C@_0BB@COIHEPAG@last?5played?5demo@ DB 'last played demo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNNFDDLC@cl_showevents@
CONST	SEGMENT
??_C@_0O@FNNFDDLC@cl_showevents@ DB 'cl_showevents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DPPOLODC@show?5events?5playback@
CONST	SEGMENT
??_C@_0BF@DPPOLODC@show?5events?5playback@ DB 'show events playback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MOIEJPFN@indicate?5what?5background?5map?5is@
CONST	SEGMENT
??_C@_0CI@MOIEJPFN@indicate?5what?5background?5map?5is@ DB 'indicate what'
	DB	' background map is running', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GMLECNLK@hud_scale@
CONST	SEGMENT
??_C@_09GMLECNLK@hud_scale@ DB 'hud_scale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PGHGPEOM@?91@
CONST	SEGMENT
??_C@_02PGHGPEOM@?91@ DB '-1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCEFHBIN@scale?5hud?5at?5current?5resolution@
CONST	SEGMENT
??_C@_0CA@CCEFHBIN@scale?5hud?5at?5current?5resolution@ DB 'scale hud at '
	DB	'current resolution', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBJMGNNJ@cl_fixtimerate@
CONST	SEGMENT
??_C@_0P@GBJMGNNJ@cl_fixtimerate@ DB 'cl_fixtimerate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CDKFEJKH@7?45@
CONST	SEGMENT
??_C@_03CDKFEJKH@7?45@ DB '7.5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CLKODIIO@time?5in?5msec?5to?5client?5clock?5ad@
CONST	SEGMENT
??_C@_0CH@CLKODIIO@time?5in?5msec?5to?5client?5clock?5ad@ DB 'time in mse'
	DB	'c to client clock adjusting', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJEBIBFL@cl_clockreset@
CONST	SEGMENT
??_C@_0O@DJEBIBFL@cl_clockreset@ DB 'cl_clockreset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EHNJPADF@frametime?5delta?5maximum?5value?5b@
CONST	SEGMENT
??_C@_0CL@EHNJPADF@frametime?5delta?5maximum?5value?5b@ DB 'frametime del'
	DB	'ta maximum value before reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HDGLEIEB@cl_bmodelinterp@
CONST	SEGMENT
??_C@_0BA@HDGLEIEB@cl_bmodelinterp@ DB 'cl_bmodelinterp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OOMCGAMM@enable?5bmodel?5interpolation@
CONST	SEGMENT
??_C@_0BM@OOMCGAMM@enable?5bmodel?5interpolation@ DB 'enable bmodel inter'
	DB	'polation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLPCJECL@cl_showerror@
CONST	SEGMENT
??_C@_0N@BLPCJECL@cl_showerror@ DB 'cl_showerror', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FPPOLPLK@show?5prediction?5error@
CONST	SEGMENT
??_C@_0BG@FPPOLPLK@show?5prediction?5error@ DB 'show prediction error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IKBGNHPM@cl_lightstyle_lerping@
CONST	SEGMENT
??_C@_0BG@IKBGNHPM@cl_lightstyle_lerping@ DB 'cl_lightstyle_lerping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CIKONPNB@enables?5animated?5light?5lerping?5@
CONST	SEGMENT
??_C@_0DD@CIKONPNB@enables?5animated?5light?5lerping?5@ DB 'enables anima'
	DB	'ted light lerping (perfomance option)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHKDLKIM@r_drawbeams@
CONST	SEGMENT
??_C@_0M@EHKDLKIM@r_drawbeams@ DB 'r_drawbeams', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KECJKNEI@render?5beams@
CONST	SEGMENT
??_C@_0N@KECJKNEI@render?5beams@ DB 'render beams', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNAKHALD@r_drawtracers@
CONST	SEGMENT
??_C@_0O@DNAKHALD@r_drawtracers@ DB 'r_drawtracers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BBEPAELE@render?5tracers@
CONST	SEGMENT
??_C@_0P@BBEPAELE@render?5tracers@ DB 'render tracers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DLDAOBHF@r_drawparticles@
CONST	SEGMENT
??_C@_0BA@DLDAOBHF@r_drawparticles@ DB 'r_drawparticles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDBJOONC@render?5particles@
CONST	SEGMENT
??_C@_0BB@CDBJOONC@render?5particles@ DB 'render particles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30@
CONST	SEGMENT
??_C@_02PJNFELNH@30@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MEFENBID@Max?5number?5of?5command?5packets?5s@
CONST	SEGMENT
??_C@_0DI@MEFENBID@Max?5number?5of?5command?5packets?5s@ DB 'Max number o'
	DB	'f command packets sent to server per second', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NGMAFPKG@cl_cmdbackup@
CONST	SEGMENT
??_C@_0N@NGMAFPKG@cl_cmdbackup@ DB 'cl_cmdbackup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LLNCFEDN@how?5many?5additional?5history?5com@
CONST	SEGMENT
??_C@_0CO@LLNCFEDN@how?5many?5additional?5history?5com@ DB 'how many addi'
	DB	'tional history commands are sent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CDOPINFK@cl_smoothtime@
CONST	SEGMENT
??_C@_0O@CDOPINFK@cl_smoothtime@ DB 'cl_smoothtime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECBHFPKG@time?5to?5smooth?5up@
CONST	SEGMENT
??_C@_0BC@ECBHFPKG@time?5to?5smooth?5up@ DB 'time to smooth up', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLEMEGKL@cl_nosmooth@
CONST	SEGMENT
??_C@_0M@LLEMEGKL@cl_nosmooth@ DB 'cl_nosmooth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KOJLGMDL@disable?5smooth?5up?5stair?5climbin@
CONST	SEGMENT
??_C@_0EJ@KOJLGMDL@disable?5smooth?5up?5stair?5climbin@ DB 'disable smoot'
	DB	'h up stair climbing and interpolate position in multiplayer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNAGCLGI@cl_showfps@
CONST	SEGMENT
??_C@_0L@FNAGCLGI@cl_showfps@ DB 'cl_showfps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDNBJAOI@show?5client?5fps@
CONST	SEGMENT
??_C@_0BA@MDNBJAOI@show?5client?5fps@ DB 'show client fps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NHPAFEHJ@skin@
CONST	SEGMENT
??_C@_04NHPAFEHJ@skin@ DB 'skin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCPGJACL@player?5skin@
CONST	SEGMENT
??_C@_0M@JCPGJACL@player?5skin@ DB 'player skin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KADBPNCB@team@
CONST	SEGMENT
??_C@_04KADBPNCB@team@ DB 'team', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFDHDJHD@player?5team@
CONST	SEGMENT
??_C@_0M@OFDHDJHD@player?5team@ DB 'player team', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLHBPEGP@password@
CONST	SEGMENT
??_C@_08NLHBPEGP@password@ DB 'password', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOCGHAFM@server?5password@
CONST	SEGMENT
??_C@_0BA@BOCGHAFM@server?5password@ DB 'server password', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMKMDA@cl_lc@
CONST	SEGMENT
??_C@_05OMKMDA@cl_lc@ DB 'cl_lc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HOGAGOPD@enable?5lag?5compensation@
CONST	SEGMENT
??_C@_0BI@HOGAGOPD@enable?5lag?5compensation@ DB 'enable lag compensation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05COECHLGF@cl_lw@
CONST	SEGMENT
??_C@_05COECHLGF@cl_lw@ DB 'cl_lw', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DGECEPIL@enable?5client?5weapon?5predicting@
CONST	SEGMENT
??_C@_0CA@DGECEPIL@enable?5client?5weapon?5predicting@ DB 'enable client '
	DB	'weapon predicting', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIFIMDEK@bottomcolor@
CONST	SEGMENT
??_C@_0M@IIFIMDEK@bottomcolor@ DB 'bottomcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBFJNKLM@player?5bottom?5color@
CONST	SEGMENT
??_C@_0BE@KBFJNKLM@player?5bottom?5color@ DB 'player bottom color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLGKFJAO@topcolor@
CONST	SEGMENT
??_C@_08OLGKFJAO@topcolor@ DB 'topcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILOPDEKA@player?5top?5color@
CONST	SEGMENT
??_C@_0BB@ILOPDEKA@player?5top?5color@ DB 'player top color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate@ DB 'rate', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODIEBBEE@3500@
CONST	SEGMENT
??_C@_04ODIEBBEE@3500@ DB '3500', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPFCAJAK@player?5network?5rate@
CONST	SEGMENT
??_C@_0BE@CPFCAJAK@player?5network?5rate@ DB 'player network rate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PBHOBKHC@max?5allowed?5fragment?5size?5on?5do@
CONST	SEGMENT
??_C@_0DA@PBHOBKHC@max?5allowed?5fragment?5size?5on?5do@ DB 'max allowed '
	DB	'fragment size on download resources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20@
CONST	SEGMENT
??_C@_02PIBHCBOA@20@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IMLGPKIK@refresh?5rate?5of?5server?5messages@
CONST	SEGMENT
??_C@_0CA@IMLGPKIK@refresh?5rate?5of?5server?5messages@ DB 'refresh rate '
	DB	'of server messages', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GGEFMNKI@player?5model?5?$CI?8player?8?5is?5a?5sin@
CONST	SEGMENT
??_C@_0DA@GGEFMNKI@player?5model?5?$CI?8player?8?5is?5a?5sin@ DB 'player '
	DB	'model (''player'' is a singleplayer model)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBMGFCGL@player?5name@
CONST	SEGMENT
??_C@_0M@IBMGFCGL@player?5name@ DB 'player name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFLGBOKH@cl_nopred@
CONST	SEGMENT
??_C@_09EFLGBOKH@cl_nopred@ DB 'cl_nopred', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FJCEHFJG@disable?5client?5movement?5predict@
CONST	SEGMENT
??_C@_0CD@FJCEHFJG@disable?5client?5movement?5predict@ DB 'disable client'
	DB	' movement prediction', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJJENLON@rcon_address@
CONST	SEGMENT
??_C@_0N@PJJENLON@rcon_address@ DB 'rcon_address', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BPEKCJOI@remote?5control?5address@
CONST	SEGMENT
??_C@_0BH@BPEKCJOI@remote?5control?5address@ DB 'remote control address', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EEIAMLPM@rcon_password@
CONST	SEGMENT
??_C@_0O@EEIAMLPM@rcon_password@ DB 'rcon_password', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIMJMBAH@remote?5control?5client?5password@
CONST	SEGMENT
??_C@_0BP@LIMJMBAH@remote?5control?5client?5password@ DB 'remote control '
	DB	'client password', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JCNOFHIK@cl_timeout@
CONST	SEGMENT
??_C@_0L@JCNOFHIK@cl_timeout@ DB 'cl_timeout', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPBOIJDM@60@
CONST	SEGMENT
??_C@_02PPBOIJDM@60@ DB '60', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CMKNHDIB@connect?5timeout?5?$CIin?9seconds?$CJ@
CONST	SEGMENT
??_C@_0BN@CMKNHDIB@connect?5timeout?5?$CIin?9seconds?$CJ@ DB 'connect tim'
	DB	'eout (in-seconds)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NKBOLEBK@0?41@
CONST	SEGMENT
??_C@_03NKBOLEBK@0?41@ DB '0.1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HNPMKLI@Interpolate?5object?5positions?5st@
CONST	SEGMENT
??_C@_0EA@HNPMKLI@Interpolate?5object?5positions?5st@ DB 'Interpolate obj'
	DB	'ect positions starting this many seconds in past', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BGAFDJDO@cl_solid_players@
CONST	SEGMENT
??_C@_0BB@BGAFDJDO@cl_solid_players@ DB 'cl_solid_players', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FNMDJCPC@Make?5all?5players?5not?5solid?5?$CIcan@
CONST	SEGMENT
??_C@_0DC@FNMDJCPC@Make?5all?5players?5not?5solid?5?$CIcan@ DB 'Make all '
	DB	'players not solid (can''t traceline them)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBOKDBLE@cl_idealpitchscale@
CONST	SEGMENT
??_C@_0BD@FBOKDBLE@cl_idealpitchscale@ DB 'cl_idealpitchscale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LNMAPFD@0?48@
CONST	SEGMENT
??_C@_03LNMAPFD@0?48@ DB '0.8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@JGEPHGDP@how?5much?5to?5look?5up?1down?5slopes@
CONST	SEGMENT
??_C@_0ED@JGEPHGDP@how?5much?5to?5look?5up?1down?5slopes@ DB 'how much to'
	DB	' look up/down slopes and stairs when not using freelook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BPLIDNFG@cl_nodelta@
CONST	SEGMENT
??_C@_0L@BPLIDNFG@cl_nodelta@ DB 'cl_nodelta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPIGBHJN@disable?5delta?9compression?5for?5s@
CONST	SEGMENT
??_C@_0CO@IPIGBHJN@disable?5delta?9compression?5for?5s@ DB 'disable delta'
	DB	'-compression for server messages', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NBNKIDFG@crosshair@
CONST	SEGMENT
??_C@_09NBNKIDFG@crosshair@ DB 'crosshair', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NFCHEABC@show?5weapon?5chrosshair@
CONST	SEGMENT
??_C@_0BH@NFCHEABC@show?5weapon?5chrosshair@ DB 'show weapon chrosshair', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BDGNMEFL@Usage?3?5fullserverinfo?5?$DMcomplete@
CONST	SEGMENT
??_C@_0CO@BDGNMEFL@Usage?3?5fullserverinfo?5?$DMcomplete@ DB 'Usage: full'
	DB	'serverinfo <complete info string>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KOCONAKK@?$FO1Error?3?$FO7?5?$CFs?$CFs?5couldn?8t?5load?6@
CONST	SEGMENT
??_C@_0BP@KOCONAKK@?$FO1Error?3?$FO7?5?$CFs?$CFs?5couldn?8t?5load?6@ DB '^'
	DB	'1Error:^7 %s%s couldn''t load', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKBPLKFE@?$FO1Error?3?$FO7?5submodel?5?$CFs?5not?5foun@
CONST	SEGMENT
??_C@_0CC@DKBPLKFE@?$FO1Error?3?$FO7?5submodel?5?$CFs?5not?5foun@ DB '^1E'
	DB	'rror:^7 submodel %s not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GODLHHLE@Phys?5info?5settings?3?6@
CONST	SEGMENT
??_C@_0BF@GODLHHLE@Phys?5info?5settings?3?6@ DB 'Phys info settings:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PIAKLNIH@Usage?3?5setinfo?5?$FL?5?$DMkey?$DO?5?$DMvalue?$DO?5@
CONST	SEGMENT
??_C@_0CC@PIAKLNIH@Usage?3?5setinfo?5?$FL?5?$DMkey?$DO?5?$DMvalue?$DO?5@ DB 'U'
	DB	'sage: setinfo [ <key> <value> ]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KADBPMIN@Total?5?$CFi?5symbols?6@
CONST	SEGMENT
??_C@_0BC@KADBPMIN@Total?5?$CFi?5symbols?6@ DB 'Total %i symbols', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CNHFFNEA@User?5info?5settings?3?6@
CONST	SEGMENT
??_C@_0BF@CNHFFNEA@User?5info?5settings?3?6@ DB 'User info settings:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OIDIDHDM@Received?5a?5decal?5?$CFs?0?5but?5didn?8t@
CONST	SEGMENT
??_C@_0ED@OIDIDHDM@Received?5a?5decal?5?$CFs?0?5but?5didn?8t@ DB 'Receive'
	DB	'd a decal %s, but didn''t find it in resources needed list!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KLNLHGNN@Resource?5Registration@
CONST	SEGMENT
??_C@_0BG@KLNLHGNN@Resource?5Registration@ DB 'Resource Registration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@IBJGKGBH@Downloaded?5?$CFi?5bytes?5for?5purport@
CONST	SEGMENT
??_C@_0ED@IBJGKGBH@Downloaded?5?$CFi?5bytes?5for?5purport@ DB 'Downloaded'
	DB	' %i bytes for purported %i byte file, ignoring download', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NHIBONO@?$FO1Error?3?$FO7?5server?5failed?5to?5tra@
CONST	SEGMENT
??_C@_0DA@NHIBONO@?$FO1Error?3?$FO7?5server?5failed?5to?5tra@ DB '^1Error'
	DB	':^7 server failed to transmit file ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNEEOGHP@processing?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@FNEEOGHP@processing?5?$CFs?6@ DB 'processing %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBLIODKG@sound?1@
CONST	SEGMENT
??_C@_06PBLIODKG@sound?1@ DB 'sound/', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ProcessFile@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ProcessFile@@9@9 DD 088cH		; `CL_ProcessFile'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CK@FPPFLGNI@Duplicate?5resource?5received?5and@
CONST	SEGMENT
??_C@_0CK@FPPFLGNI@Duplicate?5resource?5received?5and@ DB 'Duplicate reso'
	DB	'urce received and ignored.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IBPOEPKJ@Unable?5to?5create?5custom?5decal?5f@
CONST	SEGMENT
??_C@_0CN@IBPOEPKJ@Unable?5to?5create?5custom?5decal?5f@ DB 'Unable to cr'
	DB	'eate custom decal for player %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPFBHEJO@customization@
CONST	SEGMENT
??_C@_0O@FPFBHEJO@customization@ DB 'customization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CBAODGNF@?6Server?5connection?5timed?5out?4?6@
CONST	SEGMENT
??_C@_0BP@CBAODGNF@?6Server?5connection?5timed?5out?4?6@ DB 0aH, 'Server '
	DB	'connection timed out.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FEECBHMH@?$FO1Error?3?$FO7?5CL_ReadPackets?3?5?$CFs?3s@
CONST	SEGMENT
??_C@_0ED@FEECBHMH@?$FO1Error?3?$FO7?5CL_ReadPackets?3?5?$CFs?3s@ DB '^1E'
	DB	'rror:^7 CL_ReadPackets: %s:sequenced packet without connectio'
	DB	'n', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GMBCANBL@?$FO3Warning?3?$FO7?5CL_ReadPackets?3?5?$CFs@
CONST	SEGMENT
??_C@_0CN@GMBCANBL@?$FO3Warning?3?$FO7?5CL_ReadPackets?3?5?$CFs@ DB '^3Wa'
	DB	'rning:^7 CL_ReadPackets: %s:runt packet', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GIBDHCEL@ServerData@
CONST	SEGMENT
??_C@_0L@GIBDHCEL@ServerData@ DB 'ServerData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@
CONST	SEGMENT
??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@ DB '^1Error'
	DB	':^7 bad connectionless packet from %s:', 0aH, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JLOFCKGL@serverlist?5call?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@JLOFCKGL@serverlist?5call?3?5?$CFs?6@ DB 'serverlist call: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f@
CONST	SEGMENT
??_C@_01INIBCBCB@f@ DB 'f', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFDNEFMC@echo@
CONST	SEGMENT
??_C@_04OFDNEFMC@echo@ DB 'echo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DBEGHIJJ@challenge@
CONST	SEGMENT
??_C@_09DBEGHIJJ@challenge@ DB 'challenge', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBLJHHJA@ack@
CONST	SEGMENT
??_C@_03JBLJHHJA@ack@ DB 'ack', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OONEELOO@ping@
CONST	SEGMENT
??_C@_04OONEELOO@ping@ DB 'ping', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IFANHFOD@CRC?5?$CFp?5is?5matched?0?5get?5challeng@
CONST	SEGMENT
??_C@_0DE@IFANHFOD@CRC?5?$CFp?5is?5matched?0?5get?5challeng@ DB 'CRC %p i'
	DB	's matched, get challenge, fragment size %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEEDAEFO@testpacket@
CONST	SEGMENT
??_C@_0L@BEEDAEFO@testpacket@ DB 'testpacket', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MOFOLJMP@Command?5packet?5from?5remote?5host@
CONST	SEGMENT
??_C@_0CL@MOFOLJMP@Command?5packet?5from?5remote?5host@ DB 'Command packe'
	DB	't from remote host. Ignored.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGLGIONO@cmd@
CONST	SEGMENT
??_C@_03LGLGIONO@cmd@ DB 'cmd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHGFOLHM@netinfo@
CONST	SEGMENT
??_C@_07PHGFOLHM@netinfo@ DB 'netinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIDJFNBE@info@
CONST	SEGMENT
??_C@_04NIDJFNBE@info@ DB 'info', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DICJNNNK@?$FO1Error?3?$FO7?5dup?5connect?5received@
CONST	SEGMENT
??_C@_0CK@DICJNNNK@?$FO1Error?3?$FO7?5dup?5connect?5received@ DB '^1Error'
	DB	':^7 dup connect received. ignored', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOGHOCLL@client_connect@
CONST	SEGMENT
??_C@_0P@IOGHOCLL@client_connect@ DB 'client_connect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OJAMPIDI@CL_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@OJAMPIDI@CL_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@ DB 'CL_Con'
	DB	'nectionlessPacket: %s : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ConnectionlessPacket@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ConnectionlessPacket@@9@9 DD 06e2H	; `CL_ConnectionlessPacket'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09MLGAJAED@undefined@
CONST	SEGMENT
??_C@_09MLGAJAED@undefined@ DB 'undefined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCFPNNHF@protocol@
CONST	SEGMENT
??_C@_08FCFPNNHF@protocol@ DB 'protocol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJOEDJLI@neterror@
CONST	SEGMENT
??_C@_08EJOEDJLI@neterror@ DB 'neterror', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JEDBHIFD@?$FO2Server?$FO7?3?5?$CFs?0?5Game?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@JEDBHIFD@?$FO2Server?$FO7?3?5?$CFs?0?5Game?3?5?$CFs?6@ DB '^2Se'
	DB	'rver^7: %s, Game: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JJLGHCHK@?$FO1Server?$FO7?3?5?$CFs?0?5Info?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@JJLGHCHK@?$FO1Server?$FO7?3?5?$CFs?0?5Info?3?5?$CFs?6@ DB '^1Se'
	DB	'rver^7: %s, Info: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DIBMBDMI@reconnecting?4?4?4?6@
CONST	SEGMENT
??_C@_0BB@DIBMBDMI@reconnecting?4?4?4?6@ DB 'reconnecting...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IBNOFEBL@clver@
CONST	SEGMENT
??_C@_05IBNOFEBL@clver@ DB 'clver', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNCPDLMM@0?499@
CONST	SEGMENT
??_C@_04PNCPDLMM@0?499@ DB '0.99', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGMBKBFD@gamedir@
CONST	SEGMENT
??_C@_07GGMBKBFD@gamedir@ DB 'gamedir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DFHJDOOJ@Scanning?5for?5servers?5on?5the?5int@
CONST	SEGMENT
??_C@_0CO@DFHJDOOJ@Scanning?5for?5servers?5on?5the?5int@ DB 'Scanning for'
	DB	' servers on the internet area...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FKAGDMAF@?$FO1Error?3?$FO7?5Can?8t?5resolve?5adr?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@FKAGDMAF@?$FO1Error?3?$FO7?5Can?8t?5resolve?5adr?3?5?$CF@ DB '^'
	DB	'1Error:^7 Can''t resolve adr: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHKNHLNB@ms?4xash?4su?327010@
CONST	SEGMENT
??_C@_0BB@FHKNHLNB@ms?4xash?4su?327010@ DB 'ms.xash.su:27010', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@
CONST	SEGMENT
??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@ DB '1', 0ffH, '0.0.0.0:0', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GBLEFLLO@info?5?$CFi@
CONST	SEGMENT
??_C@_07GBLEFLLO@info?5?$CFi@ DB 'info %i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FDBOEDJA@Scanning?5for?5servers?5on?5the?5loc@
CONST	SEGMENT
??_C@_0DD@FDBOEDJA@Scanning?5for?5servers?5on?5the?5loc@ DB 'Scanning for'
	DB	' servers on the local network area...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EFMONHFA@disconnected?5from?5server?6@
CONST	SEGMENT
??_C@_0BK@EFMONHFA@disconnected?5from?5server?6@ DB 'disconnected from se'
	DB	'rver', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLCAEGCJ@new@
CONST	SEGMENT
??_C@_03CLCAEGCJ@new@ DB 'new', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKPFIJOL@disconnect@
CONST	SEGMENT
??_C@_0L@KKPFIJOL@disconnect@ DB 'disconnect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BOHCKFHE@LastMessage@
CONST	SEGMENT
??_C@_0M@BOHCKFHE@LastMessage@ DB 'LastMessage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCFOLBKF@scr_download@
CONST	SEGMENT
??_C@_0N@CCFOLBKF@scr_download@ DB 'scr_download', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@OFOGMBMH@You?5must?5either?5be?5connected?5or@
CONST	SEGMENT
??_C@_0FE@OFOGMBMH@You?5must?5either?5be?5connected?5or@ DB 'You must eit'
	DB	'her be connected or set the ''rcon_address'' cvar to issue rc'
	DB	'on commands', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCMNNKNG@rcon?5@
CONST	SEGMENT
??_C@_05GCMNNKNG@rcon?5@ DB 'rcon ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NCNKNADM@You?5must?5set?5?8rcon_password?8?5be@
CONST	SEGMENT
??_C@_0DO@NCNKNADM@You?5must?5set?5?8rcon_password?8?5be@ DB 'You must se'
	DB	't ''rcon_password'' before issuing an rcon command.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFANEHJC@server?5?$CFs?6@
CONST	SEGMENT
??_C@_0L@BFANEHJC@server?5?$CFs?6@ DB 'server %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPBNGOLO@Usage?3?5connect?5?$DMserver?$DO?6@
CONST	SEGMENT
??_C@_0BJ@FPBNGOLO@Usage?3?5connect?5?$DMserver?$DO?6@ DB 'Usage: connect'
	DB	' <server>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOMBPIHF@logos?1remapped?4bmp@
CONST	SEGMENT
??_C@_0BD@IOMBPIHF@logos?1remapped?4bmp@ DB 'logos/remapped.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LICHHHNB@Too?5many?5resources?5on?5client?6@
CONST	SEGMENT
??_C@_0BO@LICHHHNB@Too?5many?5resources?5on?5client?6@ DB 'Too many resou'
	DB	'rces on client', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BGHIAFEK@bandwidth?5?$CFi?5?$CFi?6@
CONST	SEGMENT
??_C@_0BB@BGHIAFEK@bandwidth?5?$CFi?5?$CFi?6@ DB 'bandwidth %i %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PLILGMJK@Connecting?5to?5?$CFs?4?4?4?5?$FLretry?5?$CD?$CFi?$FN@
CONST	SEGMENT
??_C@_0CB@PLILGMJK@Connecting?5to?5?$CFs?4?4?4?5?$FLretry?5?$CD?$CFi?$FN@ DB 'C'
	DB	'onnecting to %s... [retry #%i]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGNJNAKN@cl_dlmax@
CONST	SEGMENT
??_C@_08IGNJNAKN@cl_dlmax@ DB 'cl_dlmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BELBLLBG@getchallenge?6@
CONST	SEGMENT
??_C@_0O@BELBLLBG@getchallenge?6@ DB 'getchallenge', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@
CONST	SEGMENT
??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@ DB 'hi-speed co'
	DB	'nnection is failed, use default method', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CJPDMOGH@?$FO1Error?3?$FO7?5CL_CheckForResend?3?5c@
CONST	SEGMENT
??_C@_0DC@CJPDMOGH@?$FO1Error?3?$FO7?5CL_CheckForResend?3?5c@ DB '^1Error'
	DB	':^7 CL_CheckForResend: couldn''t connected', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost@
CONST	SEGMENT
??_C@_09IPAEKDAI@localhost@ DB 'localhost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@INHGGABP@connect?5?$CFi?5?$CFi?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BJ@INHGGABP@connect?5?$CFi?5?$CFi?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@ DB 'c'
	DB	'onnect %i %i "%s" "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPCIHGO@qport@
CONST	SEGMENT
??_C@_05IPCIHGO@qport@ DB 'qport', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCJJGJPP@uuid@
CONST	SEGMENT
??_C@_04BCJJGJPP@uuid@ DB 'uuid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOOHLIKH@net_qport@
CONST	SEGMENT
??_C@_09HOOHLIKH@net_qport@ DB 'net_qport', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GCLLEHKK@CL_SendConnectPacket?3?5bad?5serve@
CONST	SEGMENT
??_C@_0CK@GCLLEHKK@CL_SendConnectPacket?3?5bad?5serve@ DB 'CL_SendConnect'
	DB	'Packet: bad server address', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CFCAJJKK@Removing?5conflicting?5lump?6@
CONST	SEGMENT
??_C@_0BL@CFCAJJKK@Removing?5conflicting?5lump?6@ DB 'Removing conflictin'
	DB	'g lump', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LICAHJIO@Actual?5?5?5?3?5?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@LICAHJIO@Actual?5?5?5?3?5?5?$CFs?6@ DB 'Actual   :  %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OPIGPFCH@Purported?3?5?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@OPIGPFCH@Purported?3?5?5?$CFs?6@ DB 'Purported:  %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JPFNAHEK@HPAK_AddLump?5called?5with?5bogus?5@
CONST	SEGMENT
??_C@_0DD@JPFNAHEK@HPAK_AddLump?5called?5with?5bogus?5@ DB 'HPAK_AddLump '
	DB	'called with bogus lump, md5 mismatch', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MCGJPAHP@Bogus?5data?5retrieved?5from?5?$CFs?0?5a@
CONST	SEGMENT
??_C@_0DK@MCGJPAHP@Bogus?5data?5retrieved?5from?5?$CFs?0?5a@ DB 'Bogus da'
	DB	'ta retrieved from %s, attempting to delete entry', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBFCELB@custom?4hpk@
CONST	SEGMENT
??_C@_0L@DHBFCELB@custom?4hpk@ DB 'custom.hpk', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IJLLNIPI@Ingoring?5upload?5of?5non?9customiz@
CONST	SEGMENT
??_C@_0CG@IJLLNIPI@Ingoring?5upload?5of?5non?9customiz@ DB 'Ingoring uplo'
	DB	'ad of non-customization', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJKAGJBM@?$CBMD5@
CONST	SEGMENT
??_C@_04HJKAGJBM@?$CBMD5@ DB '!MD5', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_BeginUpload_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_BeginUpload_f@@9@9 DD 038aH		; `CL_BeginUpload_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@JCLEFCHC@CL_WritePacket?3?5overflowed?5comm@
CONST	SEGMENT
??_C@_0DG@JCLEFCHC@CL_WritePacket?3?5overflowed?5comm@ DB 'CL_WritePacket'
	DB	': overflowed command buffer (%i bytes)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MNHOADLI@?$FO3Warning?3?$FO1?5Connection?5Problem@
CONST	SEGMENT
??_C@_0CD@MNHOADLI@?$FO3Warning?3?$FO1?5Connection?5Problem@ DB '^3Warnin'
	DB	'g:^1 Connection Problem^7', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHOEGPOF@cl_cmdrate@
CONST	SEGMENT
??_C@_0L@FHOEGPOF@cl_cmdrate@ DB 'cl_cmdrate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DCAPMAMJ@ClientData@
CONST	SEGMENT
??_C@_0L@DCAPMAMJ@ClientData@ DB 'ClientData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOANGLPP@to?5?$DO?$DN?50?5?$CG?$CG?5to?5?$DM?5MULTIPLAYER_BAC@
CONST	SEGMENT
??_C@_0CD@GOANGLPP@to?5?$DO?$DN?50?5?$CG?$CG?5to?5?$DM?5MULTIPLAYER_BAC@ DB 't'
	DB	'o >= 0 && to < MULTIPLAYER_BACKUP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BPAMAEGK@from?5?$DN?$DN?5?91?5?$HM?$HM?5?$CI?5from?5?$DO?$DN?50?5?$CG?$CG?5fr@
CONST	SEGMENT
??_C@_0DJ@BPAMAEGK@from?5?$DN?$DN?5?91?5?$HM?$HM?5?$CI?5from?5?$DO?$DN?50?5?$CG?$CG?5fr@ DB 'f'
	DB	'rom == -1 || ( from >= 0 && from < MULTIPLAYER_BACKUP )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_main.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_WriteUsercmd@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_WriteUsercmd@@9@9 DD 02a8H		; `CL_WriteUsercmd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@MJMKNHCG@r_showtextures@
CONST	SEGMENT
??_C@_0P@MJMKNHCG@r_showtextures@ DB 'r_showtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LIPGDLPA@ex_interp@
CONST	SEGMENT
??_C@_09LIPGDLPA@ex_interp@ DB 'ex_interp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CGOAGALG@ex_interp?5forced?5down?5to?5?$CFi?5mse@
CONST	SEGMENT
??_C@_0CC@CGOAGALG@ex_interp?5forced?5down?5to?5?$CFi?5mse@ DB 'ex_interp'
	DB	' forced down to %i msec', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NNLHIFJL@ex_interp?5forced?5up?5to?5?$CFi?5msec?6@
CONST	SEGMENT
??_C@_0CA@NNLHIFJL@ex_interp?5forced?5up?5to?5?$CFi?5msec?6@ DB 'ex_inter'
	DB	'p forced up to %i msec', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCBKIJKK@cl_updaterate?5clamped?5at?5maximu@
CONST	SEGMENT
??_C@_0CH@GCBKIJKK@cl_updaterate?5clamped?5at?5maximu@ DB 'cl_updaterate '
	DB	'clamped at maximum (%f)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLEIJHMA@cl_updaterate@
CONST	SEGMENT
??_C@_0O@GLEIJHMA@cl_updaterate@ DB 'cl_updaterate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MMJIGOKI@cl_updaterate?5minimum?5is?5?$CFf?0?5re@
CONST	SEGMENT
??_C@_0DI@MMJIGOKI@cl_updaterate?5minimum?5is?5?$CFf?0?5re@ DB 'cl_update'
	DB	'rate minimum is %f, resetting to default (20)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAFKHBAM@begin@
CONST	SEGMENT
??_C@_05EAFKHBAM@begin@ DB 'begin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HJOLPNGG@CL_SignonReply?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BE@HJOLPNGG@CL_SignonReply?3?5?$CFi?6@ DB 'CL_SignonReply: %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PBAMMEOO@client?5connected?5at?5?$CF?42f?5sec?6@
CONST	SEGMENT
??_C@_0BO@PBAMMEOO@client?5connected?5at?5?$CF?42f?5sec?6@ DB 'client con'
	DB	'nected at %.2f sec', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKOEGGOG@scr_loading@
CONST	SEGMENT
??_C@_0M@DKOEGGOG@scr_loading@ DB 'scr_loading', 00H	; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0971H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0175H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	078H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0e8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0267H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	013dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02e6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0141H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0292H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	076eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0356H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	018cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	035aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0afH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_AdjustClock
_TEXT	SEGMENT
tv169 = -112						; size = 8
tv174 = -104						; size = 8
tv164 = -96						; size = 8
tv148 = -96						; size = 8
tv79 = -96						; size = 8
_sign$1 = -24						; size = 8
_adjust$2 = -16						; size = 8
_msec$3 = -8						; size = 8
_CL_AdjustClock PROC					; COMDAT

; 2702 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 2703 : 	if( cl.timedelta == 0.0f || !cl_fixtimerate->value )

	movss	xmm0, DWORD PTR _cl+2167656
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_AdjustC
	mov	eax, DWORD PTR _cl_fixtimerate
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustC
$LN3@CL_AdjustC:

; 2704 : 		return;

	jmp	$LN7@CL_AdjustC
$LN2@CL_AdjustC:

; 2705 : 
; 2706 : 	if( cl_fixtimerate->value < 0.0f )

	mov	eax, DWORD PTR _cl_fixtimerate
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN4@CL_AdjustC

; 2707 : 		Cvar_SetValue( "cl_fixtimerate", 7.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40f00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0P@GBJMGNNJ@cl_fixtimerate@
	call	_Cvar_SetValue
	add	esp, 8
$LN4@CL_AdjustC:

; 2708 : 
; 2709 : 	if( fabs( cl.timedelta ) >= 0.001f )

	cvtss2sd xmm0, DWORD PTR _cl+2167656
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv148[ebp]
	movsd	xmm0, QWORD PTR tv148[ebp]
	comisd	xmm0, QWORD PTR __real@3f50624de0000000
	jb	$LN7@CL_AdjustC

; 2710 : 	{
; 2711 : 		double	msec, adjust, sign;
; 2712 : 
; 2713 : 		msec = ( cl.timedelta * 1000.0 );

	cvtss2sd xmm0, DWORD PTR _cl+2167656
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _msec$3[ebp], xmm0

; 2714 : 		sign = ( msec < 0 ) ? 1.0 : -1.0;

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _msec$3[ebp]
	jbe	SHORT $LN9@CL_AdjustC
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN10@CL_AdjustC
$LN9@CL_AdjustC:
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR tv79[ebp], xmm0
$LN10@CL_AdjustC:
	movsd	xmm0, QWORD PTR tv79[ebp]
	movsd	QWORD PTR _sign$1[ebp], xmm0

; 2715 : 		msec = fabs( msec );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _msec$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR _msec$3[ebp]

; 2716 : 		adjust = sign * ( cl_fixtimerate->value / 1000.0 );

	mov	eax, DWORD PTR _cl_fixtimerate
	cvtss2sd xmm0, DWORD PTR [eax+12]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mulsd	xmm0, QWORD PTR _sign$1[ebp]
	movsd	QWORD PTR _adjust$2[ebp], xmm0

; 2717 : 
; 2718 : 		if( fabs( adjust ) < fabs( cl.timedelta ))

	sub	esp, 8
	movsd	xmm0, QWORD PTR _adjust$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv164[ebp]
	movsd	xmm0, QWORD PTR tv164[ebp]
	cvtss2sd xmm1, DWORD PTR _cl+2167656
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv174[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv169[ebp]
	movsd	xmm0, QWORD PTR tv169[ebp]
	movsd	xmm1, QWORD PTR tv174[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN6@CL_AdjustC

; 2719 : 		{
; 2720 : 			cl.timedelta += adjust;

	cvtss2sd xmm0, DWORD PTR _cl+2167656
	addsd	xmm0, QWORD PTR _adjust$2[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cl+2167656, xmm0

; 2721 : 			cl.time += adjust;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR _adjust$2[ebp]
	movsd	QWORD PTR _cl+2167640, xmm0
$LN6@CL_AdjustC:

; 2722 : 		}
; 2723 : 
; 2724 : 		if( cl.oldtime > cl.time )

	movsd	xmm0, QWORD PTR _cl+2167648
	comisd	xmm0, QWORD PTR _cl+2167640
	jbe	SHORT $LN7@CL_AdjustC

; 2725 : 			cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _cl+2167648, xmm0
$LN7@CL_AdjustC:

; 2726 : 	}
; 2727 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustClock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_InitLocal
_TEXT	SEGMENT
_CL_InitLocal PROC					; COMDAT

; 2572 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2573 : 	cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0

; 2574 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 2575 : 
; 2576 : 	cl.resourcesneeded.pNext = cl.resourcesneeded.pPrev = &cl.resourcesneeded;

	mov	DWORD PTR _cl+3029684, OFFSET _cl+3029552
	mov	eax, DWORD PTR _cl+3029684
	mov	DWORD PTR _cl+3029680, eax

; 2577 : 	cl.resourcesonhand.pNext = cl.resourcesonhand.pPrev = &cl.resourcesonhand;

	mov	DWORD PTR _cl+3029548, OFFSET _cl+3029416
	mov	eax, DWORD PTR _cl+3029548
	mov	DWORD PTR _cl+3029544, eax

; 2578 : 
; 2579 : 	Cvar_RegisterVariable( &mp_decals );

	push	OFFSET _mp_decals
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2580 : 	Cvar_RegisterVariable( &dev_overview );

	push	OFFSET _dev_overview
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2581 : 	Cvar_RegisterVariable( &cl_resend );

	push	OFFSET _cl_resend
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2582 : 	Cvar_RegisterVariable( &cl_allow_upload );

	push	OFFSET _cl_allow_upload
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2583 : 	Cvar_RegisterVariable( &cl_allow_download );

	push	OFFSET _cl_allow_download
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2584 : 	Cvar_RegisterVariable( &cl_download_ingame );

	push	OFFSET _cl_download_ingame
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2585 : 	Cvar_RegisterVariable( &cl_logofile );

	push	OFFSET _cl_logofile
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2586 : 	Cvar_RegisterVariable( &cl_logocolor );

	push	OFFSET _cl_logocolor
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2587 : 	Cvar_RegisterVariable( &cl_test_bandwidth );

	push	OFFSET _cl_test_bandwidth
	call	_Cvar_RegisterVariable
	add	esp, 4

; 2588 : 
; 2589 : 	// register our variables
; 2590 : 	cl_crosshair = Cvar_Get( "crosshair", "1", FCVAR_ARCHIVE, "show weapon chrosshair" );

	push	OFFSET ??_C@_0BH@NFCHEABC@show?5weapon?5chrosshair@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_09NBNKIDFG@crosshair@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_crosshair, eax

; 2591 : 	cl_nodelta = Cvar_Get ("cl_nodelta", "0", 0, "disable delta-compression for server messages" );

	push	OFFSET ??_C@_0CO@IPIGBHJN@disable?5delta?9compression?5for?5s@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0L@BPLIDNFG@cl_nodelta@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nodelta, eax

; 2592 : 	cl_idealpitchscale = Cvar_Get( "cl_idealpitchscale", "0.8", 0, "how much to look up/down slopes and stairs when not using freelook" );

	push	OFFSET ??_C@_0ED@JGEPHGDP@how?5much?5to?5look?5up?1down?5slopes@
	push	0
	push	OFFSET ??_C@_03LNMAPFD@0?48@
	push	OFFSET ??_C@_0BD@FBOKDBLE@cl_idealpitchscale@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_idealpitchscale, eax

; 2593 : 	cl_solid_players = Cvar_Get( "cl_solid_players", "1", 0, "Make all players not solid (can't traceline them)" );

	push	OFFSET ??_C@_0DC@FNMDJCPC@Make?5all?5players?5not?5solid?5?$CIcan@
	push	0
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BB@BGAFDJDO@cl_solid_players@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_solid_players, eax

; 2594 : 	cl_interp = Cvar_Get( "ex_interp", "0.1", FCVAR_ARCHIVE, "Interpolate object positions starting this many seconds in past" ); 

	push	OFFSET ??_C@_0EA@HNPMKLI@Interpolate?5object?5positions?5st@
	push	1
	push	OFFSET ??_C@_03NKBOLEBK@0?41@
	push	OFFSET ??_C@_09LIPGDLPA@ex_interp@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_interp, eax

; 2595 : 	cl_timeout = Cvar_Get( "cl_timeout", "60", 0, "connect timeout (in-seconds)" );

	push	OFFSET ??_C@_0BN@CMKNHDIB@connect?5timeout?5?$CIin?9seconds?$CJ@
	push	0
	push	OFFSET ??_C@_02PPBOIJDM@60@
	push	OFFSET ??_C@_0L@JCNOFHIK@cl_timeout@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_timeout, eax

; 2596 : 
; 2597 : 	rcon_client_password = Cvar_Get( "rcon_password", "", 0, "remote control client password" );

	push	OFFSET ??_C@_0BP@LIMJMBAH@remote?5control?5client?5password@
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_0O@EEIAMLPM@rcon_password@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rcon_client_password, eax

; 2598 : 	rcon_address = Cvar_Get( "rcon_address", "", 0, "remote control address" );

	push	OFFSET ??_C@_0BH@BPEKCJOI@remote?5control?5address@
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_0N@PJJENLON@rcon_address@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rcon_address, eax

; 2599 : 
; 2600 : 	// userinfo
; 2601 : 	cl_nopred = Cvar_Get( "cl_nopred", "0", FCVAR_ARCHIVE|FCVAR_USERINFO, "disable client movement prediction" );

	push	OFFSET ??_C@_0CD@FJCEHFJG@disable?5client?5movement?5predict@
	push	3
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_09EFLGBOKH@cl_nopred@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nopred, eax

; 2602 : 	name = Cvar_Get( "name", Sys_GetCurrentUser(), FCVAR_USERINFO|FCVAR_ARCHIVE|FCVAR_PRINTABLEONLY, "player name" );

	push	OFFSET ??_C@_0M@IBMGFCGL@player?5name@
	push	131					; 00000083H
	call	_Sys_GetCurrentUser
	push	eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _name, eax

; 2603 : 	model = Cvar_Get( "model", "", FCVAR_USERINFO|FCVAR_ARCHIVE, "player model ('player' is a singleplayer model)" );

	push	OFFSET ??_C@_0DA@GGEFMNKI@player?5model?5?$CI?8player?8?5is?5a?5sin@
	push	3
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_05NCCFOPHA@model@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _model, eax

; 2604 : 	cl_updaterate = Cvar_Get( "cl_updaterate", "20", FCVAR_USERINFO|FCVAR_ARCHIVE, "refresh rate of server messages" );

	push	OFFSET ??_C@_0CA@IMLGPKIK@refresh?5rate?5of?5server?5messages@
	push	3
	push	OFFSET ??_C@_02PIBHCBOA@20@
	push	OFFSET ??_C@_0O@GLEIJHMA@cl_updaterate@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_updaterate, eax

; 2605 : 	cl_dlmax = Cvar_Get( "cl_dlmax", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "max allowed fragment size on download resources" );

	push	OFFSET ??_C@_0DA@PBHOBKHC@max?5allowed?5fragment?5size?5on?5do@
	push	3
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_dlmax, eax

; 2606 : 	rate = Cvar_Get( "rate", "3500", FCVAR_USERINFO|FCVAR_ARCHIVE, "player network rate" );

	push	OFFSET ??_C@_0BE@CPFCAJAK@player?5network?5rate@
	push	3
	push	OFFSET ??_C@_04ODIEBBEE@3500@
	push	OFFSET ??_C@_04HCCHHEEF@rate@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rate, eax

; 2607 : 	topcolor = Cvar_Get( "topcolor", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "player top color" );

	push	OFFSET ??_C@_0BB@ILOPDEKA@player?5top?5color@
	push	3
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08OLGKFJAO@topcolor@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _topcolor, eax

; 2608 : 	bottomcolor = Cvar_Get( "bottomcolor", "0", FCVAR_USERINFO|FCVAR_ARCHIVE, "player bottom color" );

	push	OFFSET ??_C@_0BE@KBFJNKLM@player?5bottom?5color@
	push	3
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@IIFIMDEK@bottomcolor@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _bottomcolor, eax

; 2609 : 	cl_lw = Cvar_Get( "cl_lw", "1", FCVAR_ARCHIVE|FCVAR_USERINFO, "enable client weapon predicting" );

	push	OFFSET ??_C@_0CA@DGECEPIL@enable?5client?5weapon?5predicting@
	push	3
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_05COECHLGF@cl_lw@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_lw, eax

; 2610 : 	Cvar_Get( "cl_lc", "1", FCVAR_ARCHIVE|FCVAR_USERINFO, "enable lag compensation" );

	push	OFFSET ??_C@_0BI@HOGAGOPD@enable?5lag?5compensation@
	push	3
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_05OMKMDA@cl_lc@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2611 : 	Cvar_Get( "password", "", FCVAR_USERINFO, "server password" );

	push	OFFSET ??_C@_0BA@BOCGHAFM@server?5password@
	push	2
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_08NLHBPEGP@password@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2612 : 	Cvar_Get( "team", "", FCVAR_USERINFO, "player team" );

	push	OFFSET ??_C@_0M@OFDHDJHD@player?5team@
	push	2
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_04KADBPNCB@team@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2613 : 	Cvar_Get( "skin", "", FCVAR_USERINFO, "player skin" );

	push	OFFSET ??_C@_0M@JCPGJACL@player?5skin@
	push	2
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_04NHPAFEHJ@skin@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2614 : 
; 2615 : 	cl_showfps = Cvar_Get( "cl_showfps", "1", FCVAR_ARCHIVE, "show client fps" );

	push	OFFSET ??_C@_0BA@MDNBJAOI@show?5client?5fps@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0L@FNAGCLGI@cl_showfps@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showfps, eax

; 2616 : 	cl_nosmooth = Cvar_Get( "cl_nosmooth", "0", FCVAR_ARCHIVE, "disable smooth up stair climbing and interpolate position in multiplayer" );

	push	OFFSET ??_C@_0EJ@KOJLGMDL@disable?5smooth?5up?5stair?5climbin@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@LLEMEGKL@cl_nosmooth@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_nosmooth, eax

; 2617 : 	cl_smoothtime = Cvar_Get( "cl_smoothtime", "0", FCVAR_ARCHIVE, "time to smooth up" );

	push	OFFSET ??_C@_0BC@ECBHFPKG@time?5to?5smooth?5up@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@CDOPINFK@cl_smoothtime@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_smoothtime, eax

; 2618 : 	cl_cmdbackup = Cvar_Get( "cl_cmdbackup", "10", FCVAR_ARCHIVE, "how many additional history commands are sent" );

	push	OFFSET ??_C@_0CO@LLNCFEDN@how?5many?5additional?5history?5com@
	push	1
	push	OFFSET ??_C@_02PKFBJPLJ@10@
	push	OFFSET ??_C@_0N@NGMAFPKG@cl_cmdbackup@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_cmdbackup, eax

; 2619 : 	cl_cmdrate = Cvar_Get( "cl_cmdrate", "30", FCVAR_ARCHIVE, "Max number of command packets sent to server per second" );

	push	OFFSET ??_C@_0DI@MEFENBID@Max?5number?5of?5command?5packets?5s@
	push	1
	push	OFFSET ??_C@_02PJNFELNH@30@
	push	OFFSET ??_C@_0L@FHOEGPOF@cl_cmdrate@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_cmdrate, eax

; 2620 : 	cl_draw_particles = Cvar_Get( "r_drawparticles", "1", FCVAR_CHEAT, "render particles" );

	push	OFFSET ??_C@_0BB@CDBJOONC@render?5particles@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BA@DLDAOBHF@r_drawparticles@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_particles, eax

; 2621 : 	cl_draw_tracers = Cvar_Get( "r_drawtracers", "1", FCVAR_CHEAT, "render tracers" );

	push	OFFSET ??_C@_0P@BBEPAELE@render?5tracers@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0O@DNAKHALD@r_drawtracers@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_tracers, eax

; 2622 : 	cl_draw_beams = Cvar_Get( "r_drawbeams", "1", FCVAR_CHEAT, "render beams" );

	push	OFFSET ??_C@_0N@KECJKNEI@render?5beams@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0M@EHKDLKIM@r_drawbeams@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_draw_beams, eax

; 2623 : 	cl_lightstyle_lerping = Cvar_Get( "cl_lightstyle_lerping", "0", FCVAR_ARCHIVE, "enables animated light lerping (perfomance option)" );

	push	OFFSET ??_C@_0DD@CIKONPNB@enables?5animated?5light?5lerping?5@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BG@IKBGNHPM@cl_lightstyle_lerping@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_lightstyle_lerping, eax

; 2624 : 	cl_showerror = Cvar_Get( "cl_showerror", "0", FCVAR_ARCHIVE, "show prediction error" );

	push	OFFSET ??_C@_0BG@FPPOLPLK@show?5prediction?5error@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0N@BLPCJECL@cl_showerror@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showerror, eax

; 2625 : 	cl_bmodelinterp = Cvar_Get( "cl_bmodelinterp", "1", FCVAR_ARCHIVE, "enable bmodel interpolation" );

	push	OFFSET ??_C@_0BM@OOMCGAMM@enable?5bmodel?5interpolation@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BA@HDGLEIEB@cl_bmodelinterp@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_bmodelinterp, eax

; 2626 : 	cl_clockreset = Cvar_Get( "cl_clockreset", "0.1", FCVAR_ARCHIVE, "frametime delta maximum value before reset" );

	push	OFFSET ??_C@_0CL@EHNJPADF@frametime?5delta?5maximum?5value?5b@
	push	1
	push	OFFSET ??_C@_03NKBOLEBK@0?41@
	push	OFFSET ??_C@_0O@DJEBIBFL@cl_clockreset@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_clockreset, eax

; 2627 : 	cl_fixtimerate = Cvar_Get( "cl_fixtimerate", "7.5", FCVAR_ARCHIVE, "time in msec to client clock adjusting" );

	push	OFFSET ??_C@_0CH@CLKODIIO@time?5in?5msec?5to?5client?5clock?5ad@
	push	1
	push	OFFSET ??_C@_03CDKFEJKH@7?45@
	push	OFFSET ??_C@_0P@GBJMGNNJ@cl_fixtimerate@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_fixtimerate, eax

; 2628 : 	Cvar_Get( "hud_scale", "-1", FCVAR_ARCHIVE|FCVAR_LATCH, "scale hud at current resolution" );

	push	OFFSET ??_C@_0CA@CCEFHBIN@scale?5hud?5at?5current?5resolution@
	push	2049					; 00000801H
	push	OFFSET ??_C@_02PGHGPEOM@?91@
	push	OFFSET ??_C@_09GMLECNLK@hud_scale@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2629 : 	Cvar_Get( "cl_background", "0", FCVAR_READ_ONLY, "indicate what background map is running" );

	push	OFFSET ??_C@_0CI@MOIEJPFN@indicate?5what?5background?5map?5is@
	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2630 : 	cl_showevents = Cvar_Get( "cl_showevents", "0", FCVAR_ARCHIVE, "show events playback" );

	push	OFFSET ??_C@_0BF@DPPOLODC@show?5events?5playback@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@FNNFDDLC@cl_showevents@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_showevents, eax

; 2631 : 	Cvar_Get( "lastdemo", "", FCVAR_ARCHIVE, "last played demo" );

	push	OFFSET ??_C@_0BB@COIHEPAG@last?5played?5demo@
	push	1
	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_08DAPDEFAC@lastdemo@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2632 : 
; 2633 : 	// these two added to shut up CS 1.5 about 'unknown' commands
; 2634 : 	Cvar_Get( "lightgamma", "1", FCVAR_ARCHIVE, "ambient lighting level (legacy, unused)" );

	push	OFFSET ??_C@_0CI@MGEECIPN@ambient?5lighting?5level?5?$CIlegacy?0@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0L@IEGJIKFJ@lightgamma@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2635 : 	Cvar_Get( "direct", "1", FCVAR_ARCHIVE, "direct lighting level (legacy, unused)" );

	push	OFFSET ??_C@_0CH@JDLOPMPD@direct?5lighting?5level?5?$CIlegacy?0?5@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_06LMLJGLPA@direct@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 2636 : 
; 2637 : 	// server commands
; 2638 : 	Cmd_AddCommand ("noclip", NULL, "enable or disable no clipping mode" );

	push	OFFSET ??_C@_0CD@PNOAHLOJ@enable?5or?5disable?5no?5clipping?5m@
	push	0
	push	OFFSET ??_C@_06IHODGGMJ@noclip@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2639 : 	Cmd_AddCommand ("notarget", NULL, "notarget mode (monsters do not see you)" );

	push	OFFSET ??_C@_0CI@JHOKLOME@notarget?5mode?5?$CImonsters?5do?5not?5@
	push	0
	push	OFFSET ??_C@_08HPLPOCJL@notarget@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2640 : 	Cmd_AddCommand ("fullupdate", NULL, "re-init HUD on start demo recording" );

	push	OFFSET ??_C@_0CE@OIDLHPFJ@re?9init?5HUD?5on?5start?5demo?5recor@
	push	0
	push	OFFSET ??_C@_0L@BAECHHDI@fullupdate@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2641 : 	Cmd_AddCommand ("give", NULL, "give specified item or weapon" );

	push	OFFSET ??_C@_0BO@BFJDPOLM@give?5specified?5item?5or?5weapon@
	push	0
	push	OFFSET ??_C@_04BMBHJADG@give@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2642 : 	Cmd_AddCommand ("drop", NULL, "drop current/specified item or weapon" );

	push	OFFSET ??_C@_0CG@KPKDPDDB@drop?5current?1specified?5item?5or?5@
	push	0
	push	OFFSET ??_C@_04PIONEEJD@drop@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2643 : 	Cmd_AddCommand ("gametitle", NULL, "show game logo" );

	push	OFFSET ??_C@_0P@CNBLLDB@show?5game?5logo@
	push	0
	push	OFFSET ??_C@_09EPLNALMJ@gametitle@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2644 : 	Cmd_AddCommand( "kill", NULL, "die instantly" );

	push	OFFSET ??_C@_0O@DJFCAHFH@die?5instantly@
	push	0
	push	OFFSET ??_C@_04BJJEOANI@kill@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2645 : 	Cmd_AddCommand ("god", NULL, "enable godmode" );

	push	OFFSET ??_C@_0P@IHCIBFKI@enable?5godmode@
	push	0
	push	OFFSET ??_C@_03DKFAMNOH@god@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2646 : 	Cmd_AddCommand ("fov", NULL, "set client field of view" );

	push	OFFSET ??_C@_0BJ@JILCKFBM@set?5client?5field?5of?5view@
	push	0
	push	OFFSET ??_C@_03PKBINKFB@fov@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2647 : 	Cmd_AddCommand ("log", NULL, "logging server events" );

	push	OFFSET ??_C@_0BG@MDLCPPLP@logging?5server?5events@
	push	0
	push	OFFSET ??_C@_03MGHMBJCF@log@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2648 : 		
; 2649 : 	// register our commands
; 2650 : 	Cmd_AddCommand ("pause", NULL, "pause the game (if the server allows pausing)" );

	push	OFFSET ??_C@_0CO@PMNFOODE@pause?5the?5game?5?$CIif?5the?5server?5a@
	push	0
	push	OFFSET ??_C@_05PDJBBECF@pause@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2651 : 	Cmd_AddCommand ("localservers", CL_LocalServers_f, "collect info about local servers" );

	push	OFFSET ??_C@_0CB@HEKGMPDC@collect?5info?5about?5local?5server@
	push	OFFSET _CL_LocalServers_f
	push	OFFSET ??_C@_0N@OHPGBJMI@localservers@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2652 : 	Cmd_AddCommand ("internetservers", CL_InternetServers_f, "collect info about internet servers" );

	push	OFFSET ??_C@_0CE@FCJGMNIB@collect?5info?5about?5internet?5ser@
	push	OFFSET _CL_InternetServers_f
	push	OFFSET ??_C@_0BA@HMMIBNGA@internetservers@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2653 : 	Cmd_AddCommand ("cd", CL_PlayCDTrack_f, "Play cd-track (not real cd-player of course)" );

	push	OFFSET ??_C@_0CN@KALGIHLE@Play?5cd?9track?5?$CInot?5real?5cd?9play@
	push	OFFSET _CL_PlayCDTrack_f
	push	OFFSET ??_C@_02ELLOPNDH@cd@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2654 : 	Cmd_AddCommand ("mp3", CL_PlayCDTrack_f, "Play mp3-track (based on virtual cd-player)" );

	push	OFFSET ??_C@_0CM@EAINAEGG@Play?5mp3?9track?5?$CIbased?5on?5virtua@
	push	OFFSET _CL_PlayCDTrack_f
	push	OFFSET ??_C@_03LHGNACFN@mp3@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2655 : 
; 2656 : 	Cmd_AddCommand ("setinfo", CL_SetInfo_f, "examine or change the userinfo string (alias of userinfo)" );

	push	OFFSET ??_C@_0DK@LMLJPMOP@examine?5or?5change?5the?5userinfo?5@
	push	OFFSET _CL_SetInfo_f
	push	OFFSET ??_C@_07BANLMPIG@setinfo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2657 : 	Cmd_AddCommand ("userinfo", CL_SetInfo_f, "examine or change the userinfo string (alias of setinfo)" );

	push	OFFSET ??_C@_0DJ@CCNNGOCK@examine?5or?5change?5the?5userinfo?5@
	push	OFFSET _CL_SetInfo_f
	push	OFFSET ??_C@_08PPJNGBMG@userinfo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2658 : 	Cmd_AddCommand ("physinfo", CL_Physinfo_f, "print current client physinfo" );

	push	OFFSET ??_C@_0BO@NJOOMKKF@print?5current?5client?5physinfo@
	push	OFFSET _CL_Physinfo_f
	push	OFFSET ??_C@_08PPPJCMOL@physinfo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2659 : 	Cmd_AddCommand ("disconnect", CL_Disconnect_f, "disconnect from server" );

	push	OFFSET ??_C@_0BH@PEHNLCL@disconnect?5from?5server@
	push	OFFSET _CL_Disconnect_f
	push	OFFSET ??_C@_0L@KKPFIJOL@disconnect@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2660 : 	Cmd_AddCommand ("record", CL_Record_f, "record a demo" );

	push	OFFSET ??_C@_0O@EIHBBIAA@record?5a?5demo@
	push	OFFSET _CL_Record_f
	push	OFFSET ??_C@_06KKGOIHDP@record@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2661 : 	Cmd_AddCommand ("playdemo", CL_PlayDemo_f, "play a demo" );

	push	OFFSET ??_C@_0M@IJLAHPMN@play?5a?5demo@
	push	OFFSET _CL_PlayDemo_f
	push	OFFSET ??_C@_08KNNNHPIP@playdemo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2662 : 	Cmd_AddCommand ("timedemo", CL_TimeDemo_f, "demo benchmark" );

	push	OFFSET ??_C@_0P@BGKPKPPK@demo?5benchmark@
	push	OFFSET _CL_TimeDemo_f
	push	OFFSET ??_C@_08LGFIIHD@timedemo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2663 : 	Cmd_AddCommand ("killdemo", CL_DeleteDemo_f, "delete a specified demo file" );

	push	OFFSET ??_C@_0BN@OJLIDBHD@delete?5a?5specified?5demo?5file@
	push	OFFSET _CL_DeleteDemo_f
	push	OFFSET ??_C@_08PJGEFPKP@killdemo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2664 : 	Cmd_AddCommand ("startdemos", CL_StartDemos_f, "start playing back the selected demos sequentially" );

	push	OFFSET ??_C@_0DD@POMNLFOG@start?5playing?5back?5the?5selected@
	push	OFFSET _CL_StartDemos_f
	push	OFFSET ??_C@_0L@PNDCJELG@startdemos@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2665 : 	Cmd_AddCommand ("demos", CL_Demos_f, "restart looping demos defined by the last startdemos command" );

	push	OFFSET ??_C@_0DN@JLIMINEP@restart?5looping?5demos?5defined?5b@
	push	OFFSET _CL_Demos_f
	push	OFFSET ??_C@_05CFPGCNL@demos@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2666 : 	Cmd_AddCommand ("movie", CL_PlayVideo_f, "play a movie" );

	push	OFFSET ??_C@_0N@BDPMHENF@play?5a?5movie@
	push	OFFSET _CL_PlayVideo_f
	push	OFFSET ??_C@_05PAONDCEJ@movie@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2667 : 	Cmd_AddCommand ("stop", CL_Stop_f, "stop playing or recording a demo" );

	push	OFFSET ??_C@_0CB@ILBKKEAI@stop?5playing?5or?5recording?5a?5dem@
	push	OFFSET _CL_Stop_f
	push	OFFSET ??_C@_04PEGFANN@stop@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2668 : 	Cmd_AddCommand ("info", NULL, "collect info about local servers with specified protocol" );

	push	OFFSET ??_C@_0DJ@OGHCBBKD@collect?5info?5about?5local?5server@
	push	0
	push	OFFSET ??_C@_04NIDJFNBE@info@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2669 : 	Cmd_AddCommand ("escape", CL_Escape_f, "escape from game to menu" );

	push	OFFSET ??_C@_0BJ@MOFFGFNO@escape?5from?5game?5to?5menu@
	push	OFFSET _CL_Escape_f
	push	OFFSET ??_C@_06CHNIFGOF@escape@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2670 : 	Cmd_AddCommand ("togglemenu", CL_Escape_f, "toggle between game and menu" );

	push	OFFSET ??_C@_0BN@CLBJFNJG@toggle?5between?5game?5and?5menu@
	push	OFFSET _CL_Escape_f
	push	OFFSET ??_C@_0L@HBDHBCHM@togglemenu@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2671 : 	Cmd_AddCommand ("pointfile", CL_ReadPointFile_f, "show leaks on a map (if present of course)" );

	push	OFFSET ??_C@_0CL@CGJHNICJ@show?5leaks?5on?5a?5map?5?$CIif?5present@
	push	OFFSET _CL_ReadPointFile_f
	push	OFFSET ??_C@_09OEGDAIFJ@pointfile@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2672 : 	Cmd_AddCommand ("linefile", CL_ReadLineFile_f, "show leaks on a map (if present of course)" );

	push	OFFSET ??_C@_0CL@CGJHNICJ@show?5leaks?5on?5a?5map?5?$CIif?5present@
	push	OFFSET _CL_ReadLineFile_f
	push	OFFSET ??_C@_08OGKOBMOC@linefile@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2673 : 	Cmd_AddCommand ("fullserverinfo", CL_FullServerinfo_f, "sent by server when serverinfo changes" );

	push	OFFSET ??_C@_0CH@MMJIKCDL@sent?5by?5server?5when?5serverinfo?5@
	push	OFFSET _CL_FullServerinfo_f
	push	OFFSET ??_C@_0P@FNBOAPB@fullserverinfo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2674 : 	Cmd_AddCommand ("upload", CL_BeginUpload_f, "uploading file to the server" );

	push	OFFSET ??_C@_0BN@LJPCPLKK@uploading?5file?5to?5the?5server@
	push	OFFSET _CL_BeginUpload_f
	push	OFFSET ??_C@_06KAOCKAGB@upload@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2675 : 	
; 2676 : 	Cmd_AddCommand ("quit", CL_Quit_f, "quit from game" );

	push	OFFSET ??_C@_0P@MHFGDMFE@quit?5from?5game@
	push	OFFSET _CL_Quit_f
	push	OFFSET ??_C@_04KNNLNNGO@quit@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2677 : 	Cmd_AddCommand ("exit", CL_Quit_f, "quit from game" );

	push	OFFSET ??_C@_0P@MHFGDMFE@quit?5from?5game@
	push	OFFSET _CL_Quit_f
	push	OFFSET ??_C@_04MKNBDEPB@exit@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2678 : 
; 2679 : 	Cmd_AddCommand ("screenshot", CL_ScreenShot_f, "takes a screenshot of the next rendered frame" );

	push	OFFSET ??_C@_0CO@FDJKINND@takes?5a?5screenshot?5of?5the?5next?5@
	push	OFFSET _CL_ScreenShot_f
	push	OFFSET ??_C@_0L@CMHOPIGK@screenshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2680 : 	Cmd_AddCommand ("snapshot", CL_SnapShot_f, "takes a snapshot of the next rendered frame" );

	push	OFFSET ??_C@_0CM@MIGONHLN@takes?5a?5snapshot?5of?5the?5next?5re@
	push	OFFSET _CL_SnapShot_f
	push	OFFSET ??_C@_08HLGCJJEE@snapshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2681 : 	Cmd_AddCommand ("envshot", CL_EnvShot_f, "takes a six-sides cubemap shot with specified name" );

	push	OFFSET ??_C@_0DD@EKKNFHMF@takes?5a?5six?9sides?5cubemap?5shot?5@
	push	OFFSET _CL_EnvShot_f
	push	OFFSET ??_C@_07EMBMCCDB@envshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2682 : 	Cmd_AddCommand ("skyshot", CL_SkyShot_f, "takes a six-sides envmap (skybox) shot with specified name" );

	push	OFFSET ??_C@_0DL@JCALLELG@takes?5a?5six?9sides?5envmap?5?$CIskybo@
	push	OFFSET _CL_SkyShot_f
	push	OFFSET ??_C@_07FFKGIHOP@skyshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2683 : 	Cmd_AddCommand ("levelshot", CL_LevelShot_f, "same as \"screenshot\", used for create plaque images" );

	push	OFFSET ??_C@_0DE@GCJKHONG@same?5as?5?$CCscreenshot?$CC?0?5used?5for?5@
	push	OFFSET _CL_LevelShot_f
	push	OFFSET ??_C@_09EFOFPGPE@levelshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2684 : 	Cmd_AddCommand ("saveshot", CL_SaveShot_f, "used for create save previews with LoadGame menu" );

	push	OFFSET ??_C@_0DB@KFMPKFFP@used?5for?5create?5save?5previews?5w@
	push	OFFSET _CL_SaveShot_f
	push	OFFSET ??_C@_08FDCALKIA@saveshot@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2685 : 
; 2686 : 	Cmd_AddCommand ("connect", CL_Connect_f, "connect to a server by hostname" );

	push	OFFSET ??_C@_0CA@MGLGGAIH@connect?5to?5a?5server?5by?5hostname@
	push	OFFSET _CL_Connect_f
	push	OFFSET ??_C@_07KAIBNCHO@connect@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2687 : 	Cmd_AddCommand ("reconnect", CL_Reconnect_f, "reconnect to current level" );

	push	OFFSET ??_C@_0BL@IIAKJDKL@reconnect?5to?5current?5level@
	push	OFFSET _CL_Reconnect_f
	push	OFFSET ??_C@_09MCGBPECP@reconnect@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2688 : 
; 2689 : 	Cmd_AddCommand ("rcon", CL_Rcon_f, "sends a command to the server console (rcon_password and rcon_address required)" );

	push	OFFSET ??_C@_0FA@CJPAEKPF@sends?5a?5command?5to?5the?5server?5c@
	push	OFFSET _CL_Rcon_f
	push	OFFSET ??_C@_04CLKJCJJE@rcon@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2690 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Escape_f
_TEXT	SEGMENT
_CL_Escape_f PROC					; COMDAT

; 2554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2555 : 	if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN2@CL_Escape_

; 2556 : 		return;

	jmp	SHORT $LN1@CL_Escape_
$LN2@CL_Escape_:

; 2557 : 
; 2558 : 	// the final credits is running
; 2559 : 	if( UI_CreditsActive( )) return;

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN3@CL_Escape_
	jmp	SHORT $LN1@CL_Escape_
$LN3@CL_Escape_:

; 2560 : 
; 2561 : 	if( cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN4@CL_Escape_

; 2562 : 		SCR_NextMovie(); // jump to next movie

	call	_SCR_NextMovie
	jmp	SHORT $LN1@CL_Escape_
$LN4@CL_Escape_:

; 2563 : 	else UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN1@CL_Escape_:

; 2564 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Escape_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_FullServerinfo_f
_TEXT	SEGMENT
_CL_FullServerinfo_f PROC				; COMDAT

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2537 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@CL_FullSer

; 2538 : 	{
; 2539 : 		Con_Printf( S_USAGE "fullserverinfo <complete info string>\n" );

	push	OFFSET ??_C@_0CO@BDGNMEFL@Usage?3?5fullserverinfo?5?$DMcomplete@
	call	_Con_Printf
	add	esp, 4

; 2540 : 		return;

	jmp	SHORT $LN1@CL_FullSer
$LN2@CL_FullSer:

; 2541 : 	}
; 2542 : 
; 2543 : 	Q_strncpy( cl.serverinfo, Cmd_Argv( 1 ), sizeof( cl.serverinfo ));

	push	512					; 00000200H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _cl+2167660
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@CL_FullSer:

; 2544 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FullServerinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Physinfo_f
_TEXT	SEGMENT
_CL_Physinfo_f PROC					; COMDAT

; 2381 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2382 : 	Con_Printf( "Phys info settings:\n" );

	push	OFFSET ??_C@_0BF@GODLHHLE@Phys?5info?5settings?3?6@
	call	_Con_Printf
	add	esp, 4

; 2383 : 	Info_Print( cls.physinfo );

	push	OFFSET _cls+10136
	call	_Info_Print
	add	esp, 4

; 2384 : 	Con_Printf( "Total %i symbols\n", Q_strlen( cls.physinfo ));

	push	OFFSET _cls+10136
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BC@KADBPMIN@Total?5?$CFi?5symbols?6@
	call	_Con_Printf
	add	esp, 8

; 2385 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Physinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SetInfo_f
_TEXT	SEGMENT
_var$ = -4						; size = 4
_CL_SetInfo_f PROC					; COMDAT

; 2341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2342 : 	convar_t	*var;
; 2343 : 
; 2344 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@CL_SetInfo

; 2345 : 	{
; 2346 : 		Con_Printf( "User info settings:\n" );

	push	OFFSET ??_C@_0BF@CNHFFNEA@User?5info?5settings?3?6@
	call	_Con_Printf
	add	esp, 4

; 2347 : 		Info_Print( cls.userinfo );

	push	OFFSET _cls+9880
	call	_Info_Print
	add	esp, 4

; 2348 : 		Con_Printf( "Total %i symbols\n", Q_strlen( cls.userinfo ));

	push	OFFSET _cls+9880
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BC@KADBPMIN@Total?5?$CFi?5symbols?6@
	call	_Con_Printf
	add	esp, 8

; 2349 : 		return;

	jmp	$LN1@CL_SetInfo
$LN2@CL_SetInfo:

; 2350 : 	}
; 2351 : 
; 2352 : 	if( Cmd_Argc() != 3 )

	call	_Cmd_Argc
	cmp	eax, 3
	je	SHORT $LN3@CL_SetInfo

; 2353 : 	{
; 2354 : 		Con_Printf( S_USAGE "setinfo [ <key> <value> ]\n" );

	push	OFFSET ??_C@_0CC@PIAKLNIH@Usage?3?5setinfo?5?$FL?5?$DMkey?$DO?5?$DMvalue?$DO?5@
	call	_Con_Printf
	add	esp, 4

; 2355 : 		return;

	jmp	SHORT $LN1@CL_SetInfo
$LN3@CL_SetInfo:

; 2356 : 	}
; 2357 : 
; 2358 : 	// NOTE: some userinfo comed from cvars, e.g. cl_lw but we can call "setinfo cl_lw 1"
; 2359 : 	// without real cvar changing. So we need to lookup for cvar first to make sure what
; 2360 : 	// our key is not linked with console variable
; 2361 : 	var = Cvar_FindVar( Cmd_Argv( 1 ));

	push	0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _var$[ebp], eax

; 2362 : 
; 2363 : 	// make sure what cvar is existed and really part of userinfo
; 2364 : 	if( var && FBitSet( var->flags, FCVAR_USERINFO ))

	cmp	DWORD PTR _var$[ebp], 0
	je	SHORT $LN4@CL_SetInfo
	mov	eax, DWORD PTR _var$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	SHORT $LN4@CL_SetInfo

; 2365 : 	{
; 2366 : 		Cvar_DirectSet( var, Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	call	_Cvar_DirectSet
	add	esp, 8

; 2367 : 	}

	jmp	SHORT $LN1@CL_SetInfo
$LN4@CL_SetInfo:

; 2368 : 	else if( Info_SetValueForKey( cls.userinfo, Cmd_Argv( 1 ), Cmd_Argv( 2 ), MAX_INFO_STRING ))

	push	256					; 00000100H
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET _cls+9880
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@CL_SetInfo

; 2369 : 	{
; 2370 : 		// send update only on successfully changed userinfo
; 2371 : 		Cmd_ForwardToServer ();

	call	_Cmd_ForwardToServer
$LN1@CL_SetInfo:

; 2372 : 	}
; 2373 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_RegisterCustomization
_TEXT	SEGMENT
_player$1 = -12						; size = 4
_pList$ = -8						; size = 4
_bFound$ = -4						; size = 4
_resource$ = 8						; size = 4
_CL_RegisterCustomization PROC				; COMDAT

; 2153 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2154 : 	qboolean		bFound = false;

	mov	DWORD PTR _bFound$[ebp], 0

; 2155 : 	customization_t	*pList;
; 2156 : 
; 2157 : 	for( pList = cl.players[resource->playernum].customdata.pNext; pList; pList = pList->pNext )

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	imul	edx, ecx, 584
	mov	eax, DWORD PTR _cl[edx+2185504]
	mov	DWORD PTR _pList$[ebp], eax
	jmp	SHORT $LN4@CL_Registe
$LN2@CL_Registe:
	mov	eax, DWORD PTR _pList$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pList$[ebp], ecx
$LN4@CL_Registe:
	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $LN3@CL_Registe

; 2158 : 	{
; 2159 : 		if( !memcmp( pList->resource.rgucMD5_hash, resource->rgucMD5_hash, 16 ))

	push	16					; 00000010H
	mov	eax, DWORD PTR _resource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@CL_Registe

; 2160 : 		{
; 2161 : 			bFound = true;

	mov	DWORD PTR _bFound$[ebp], 1

; 2162 : 			break;

	jmp	SHORT $LN3@CL_Registe
$LN5@CL_Registe:

; 2163 : 		}
; 2164 : 	}

	jmp	SHORT $LN2@CL_Registe
$LN3@CL_Registe:

; 2165 : 
; 2166 : 	if( !bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	jne	SHORT $LN6@CL_Registe

; 2167 : 	{
; 2168 : 		player_info_t	*player =  &cl.players[resource->playernum];

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	imul	edx, ecx, 584
	add	edx, OFFSET _cl+2184940
	mov	DWORD PTR _player$1[ebp], edx

; 2169 : 
; 2170 : 		if( !COM_CreateCustomization( &player->customdata, resource, resource->playernum, FCUST_FROMHPAK, NULL, NULL ))

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	mov	edx, DWORD PTR _resource$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$1[ebp]
	add	eax, 404				; 00000194H
	push	eax
	call	_COM_CreateCustomization
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN8@CL_Registe

; 2171 : 			Con_Printf( "Unable to create custom decal for player %i\n", resource->playernum );

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+93]
	push	ecx
	push	OFFSET ??_C@_0CN@IBPOEPKJ@Unable?5to?5create?5custom?5decal?5f@
	call	_Con_Printf
	add	esp, 8
$LN8@CL_Registe:

; 2172 : 	}

	jmp	SHORT $LN1@CL_Registe
$LN6@CL_Registe:

; 2173 : 	else
; 2174 : 	{
; 2175 : 		Con_DPrintf( "Duplicate resource received and ignored.\n" );

	push	OFFSET ??_C@_0CK@FPPFLGNI@Duplicate?5resource?5received?5and@
	call	_Con_DPrintf
	add	esp, 4
$LN1@CL_Registe:

; 2176 : 	}
; 2177 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterCustomization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_CleanFileName
_TEXT	SEGMENT
_pfilename$ = -4					; size = 4
_filename$ = 8						; size = 4
_CL_CleanFileName PROC					; COMDAT

; 2136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2137 : 	const char	*pfilename = filename;

	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _pfilename$[ebp], eax

; 2138 : 
; 2139 : 	if( COM_CheckString( filename ) && filename[0] == '!' )

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_CleanFi
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN2@CL_CleanFi

; 2140 : 		pfilename = "customization";

	mov	DWORD PTR _pfilename$[ebp], OFFSET ??_C@_0O@FPFBHEJO@customization@
$LN2@CL_CleanFi:

; 2141 : 	return pfilename;

	mov	eax, DWORD PTR _pfilename$[ebp]

; 2142 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CleanFileName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ReadPackets
_TEXT	SEGMENT
tv74 = -80						; size = 8
_checktime$1 = -8					; size = 8
_CL_ReadPackets PROC					; COMDAT

; 2073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2074 : 	// decide the simulation time
; 2075 : 	cl.oldtime = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _cl+2167648, xmm0

; 2076 : 
; 2077 : 	if( cls.demoplayback != DEMO_XASH3D && !cl.paused )

	cmp	DWORD PTR _cls+300828, 1
	je	SHORT $LN2@CL_ReadPac
	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN2@CL_ReadPac

; 2078 : 		cl.time += host.frametime;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cl+2167640, xmm0
$LN2@CL_ReadPac:

; 2079 : 
; 2080 : 	// demo time
; 2081 : 	if( cls.demorecording && !cls.demowaiting )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN3@CL_ReadPac
	cmp	DWORD PTR _cls+300832, 0
	jne	SHORT $LN3@CL_ReadPac

; 2082 : 		cls.demotime += host.frametime;

	movsd	xmm0, QWORD PTR _cls+301096
	addsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _cls+301096, xmm0
$LN3@CL_ReadPac:

; 2083 : 
; 2084 : 	CL_ReadNetMessage();

	call	_CL_ReadNetMessage

; 2085 : 
; 2086 : 	CL_ApplyAddAngle();

	call	_CL_ApplyAddAngle

; 2087 : #if 0
; 2088 : 	// keep cheat cvars are unchanged
; 2089 : 	if( cl.maxclients > 1 && cls.state == ca_active && !host_developer.value )
; 2090 : 		Cvar_SetCheatState();
; 2091 : #endif
; 2092 : 	// hot precache and downloading resources
; 2093 : 	if( cls.signon == SIGNONS && cl.lastresourcecheck < host.realtime )

	cmp	DWORD PTR _cls+64, 2
	jne	$LN4@CL_ReadPac
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR _cl+2203632
	jbe	SHORT $LN4@CL_ReadPac

; 2094 : 	{
; 2095 : 		double checktime = Host_IsLocalGame() ? 0.1 : 1.0;

	call	_Host_IsLocalGame
	test	eax, eax
	je	SHORT $LN11@CL_ReadPac
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN12@CL_ReadPac
$LN11@CL_ReadPac:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv74[ebp], xmm0
$LN12@CL_ReadPac:
	movsd	xmm0, QWORD PTR tv74[ebp]
	movsd	QWORD PTR _checktime$1[ebp], xmm0

; 2096 : 
; 2097 : 		if( !cls.dl.custom && cl.resourcesneeded.pNext != &cl.resourcesneeded )

	cmp	DWORD PTR _cls+296708, 0
	jne	SHORT $LN5@CL_ReadPac
	cmp	DWORD PTR _cl+3029680, OFFSET _cl+3029552
	je	SHORT $LN5@CL_ReadPac

; 2098 : 		{
; 2099 : 			// check resource for downloading and precache
; 2100 : 			CL_EstimateNeededResources();

	call	_CL_EstimateNeededResources

; 2101 : 			CL_BatchResourceRequest( false );

	push	0
	call	_CL_BatchResourceRequest
	add	esp, 4

; 2102 : 			cls.dl.custom = true;

	mov	DWORD PTR _cls+296708, 1
$LN5@CL_ReadPac:

; 2103 : 		}
; 2104 : 
; 2105 : 		cl.lastresourcecheck = host.realtime + checktime;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR _checktime$1[ebp]
	movsd	QWORD PTR _cl+2203632, xmm0
$LN4@CL_ReadPac:

; 2106 : 	}
; 2107 : 
; 2108 : 	// singleplayer never has connection timeout
; 2109 : 	if( NET_IsLocalAddress( cls.netchan.remote_address ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _cls+26804
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+26808
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+26812
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+26816
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN6@CL_ReadPac

; 2110 : 		return;

	jmp	SHORT $LN9@CL_ReadPac
$LN6@CL_ReadPac:

; 2111 : 
; 2112 : 	// if in the debugger last frame, don't timeout
; 2113 : 	if( host.frametime > 5.0f ) cls.netchan.last_received = Sys_DoubleTime();

	movsd	xmm0, QWORD PTR _host+1448
	comisd	xmm0, QWORD PTR __real@4014000000000000
	jbe	SHORT $LN7@CL_ReadPac
	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+26832
$LN7@CL_ReadPac:

; 2114 :           
; 2115 : 	// check timeout
; 2116 : 	if( cls.state >= ca_connected && cls.state != ca_cinematic && !cls.demoplayback )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN9@CL_ReadPac
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN9@CL_ReadPac
	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN9@CL_ReadPac

; 2117 : 	{
; 2118 : 		if( host.realtime - cls.netchan.last_received > cl_timeout->value )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+26832
	mov	eax, DWORD PTR _cl_timeout
	cvtss2sd xmm1, DWORD PTR [eax+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN9@CL_ReadPac

; 2119 : 		{
; 2120 : 			Con_Printf( "\nServer connection timed out.\n" );

	push	OFFSET ??_C@_0BP@CBAODGNF@?6Server?5connection?5timed?5out?4?6@
	call	_Con_Printf
	add	esp, 4

; 2121 : 			CL_Disconnect();

	call	_CL_Disconnect
$LN9@CL_ReadPac:

; 2122 : 			return;
; 2123 : 		}
; 2124 : 	}
; 2125 : 	
; 2126 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadPackets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ReadNetMessage
_TEXT	SEGMENT
_curSize$ = -4						; size = 4
_CL_ReadNetMessage PROC					; COMDAT

; 1998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
$LN2@CL_ReadNet:

; 1999 : 	size_t	curSize;
; 2000 : 
; 2001 : 	while( CL_GetMessage( net_message_buffer, &curSize ))

	lea	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message_buffer
	call	_CL_GetMessage
	add	esp, 8
	test	eax, eax
	je	$LN3@CL_ReadNet

; 2002 : 	{
; 2003 : 		MSG_Init( &net_message, "ServerData", net_message_buffer, curSize );

	push	-1
	mov	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message_buffer
	push	OFFSET ??_C@_0L@GIBDHCEL@ServerData@
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2004 : 
; 2005 : 		// check for connectionless packet (0xffffffff) first
; 2006 : 		if( MSG_GetMaxBytes( &net_message ) >= 4 && *(int *)net_message.pData == -1 )

	push	OFFSET _net_message
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	eax, 4
	jl	SHORT $LN4@CL_ReadNet
	mov	eax, DWORD PTR _net_message+8
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN4@CL_ReadNet

; 2007 : 		{
; 2008 : 			CL_ConnectionlessPacket( net_from, &net_message );

	push	OFFSET _net_message
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_CL_ConnectionlessPacket
	add	esp, 24					; 00000018H

; 2009 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN4@CL_ReadNet:

; 2010 : 		}
; 2011 : 
; 2012 : 		// can't be a valid sequenced packet	
; 2013 : 		if( cls.state < ca_connected ) continue;

	cmp	DWORD PTR _cls, 2
	jge	SHORT $LN5@CL_ReadNet
	jmp	$LN2@CL_ReadNet
$LN5@CL_ReadNet:

; 2014 : 
; 2015 : 		if( !cls.demoplayback && MSG_GetMaxBytes( &net_message ) < 8 )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN6@CL_ReadNet
	push	OFFSET _net_message
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN6@CL_ReadNet

; 2016 : 		{
; 2017 : 			Con_Printf( S_WARN "CL_ReadPackets: %s:runt packet\n", NET_AdrToString( net_from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CN@GMBCANBL@?$FO3Warning?3?$FO7?5CL_ReadPackets?3?5?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2018 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN6@CL_ReadNet:

; 2019 : 		}
; 2020 : 
; 2021 : 		// packet from server
; 2022 : 		if( !cls.demoplayback && !NET_CompareAdr( net_from, cls.netchan.remote_address ))

	cmp	DWORD PTR _cls+300828, 0
	jne	$LN7@CL_ReadNet
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _cls+26804
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+26808
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+26812
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+26816
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR [eax+16], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _net_from
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _net_from+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _net_from+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _net_from+12
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _net_from+16
	mov	DWORD PTR [edx+16], eax
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN7@CL_ReadNet

; 2023 : 		{
; 2024 : 			Con_DPrintf( S_ERROR "CL_ReadPackets: %s:sequenced packet without connection\n", NET_AdrToString( net_from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0ED@FEECBHMH@?$FO1Error?3?$FO7?5CL_ReadPackets?3?5?$CFs?3s@
	call	_Con_DPrintf
	add	esp, 8

; 2025 : 			continue;

	jmp	$LN2@CL_ReadNet
$LN7@CL_ReadNet:

; 2026 : 		}
; 2027 : 
; 2028 : 		if( !cls.demoplayback && !Netchan_Process( &cls.netchan, &net_message ))

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN8@CL_ReadNet
	push	OFFSET _net_message
	push	OFFSET _cls+26800
	call	_Netchan_Process
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@CL_ReadNet

; 2029 : 			continue;	// wasn't accepted for some reason

	jmp	$LN2@CL_ReadNet
$LN8@CL_ReadNet:

; 2030 : 
; 2031 : 		// run special handler for quake demos
; 2032 : 		if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN9@CL_ReadNet

; 2033 : 			CL_ParseQuakeMessage( &net_message, true );

	push	1
	push	OFFSET _net_message
	call	_CL_ParseQuakeMessage
	add	esp, 8
	jmp	SHORT $LN10@CL_ReadNet
$LN9@CL_ReadNet:

; 2034 : 		else CL_ParseServerMessage( &net_message, true );

	push	1
	push	OFFSET _net_message
	call	_CL_ParseServerMessage
	add	esp, 8
$LN10@CL_ReadNet:

; 2035 : 		cl.send_reply = true;

	mov	DWORD PTR _cl+60, 1

; 2036 : 	}

	jmp	$LN2@CL_ReadNet
$LN3@CL_ReadNet:

; 2037 : 
; 2038 : 	// build list of all solid entities per next frame (exclude clients)
; 2039 : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 2040 : 
; 2041 : 	// check for fragmentation/reassembly related packets.
; 2042 : 	if( cls.state != ca_disconnected && Netchan_IncomingReady( &cls.netchan ))

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN11@CL_ReadNet
	push	OFFSET _cls+26800
	call	_Netchan_IncomingReady
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@CL_ReadNet

; 2043 : 	{
; 2044 : 		// process the incoming buffer(s)
; 2045 : 		if( Netchan_CopyNormalFragments( &cls.netchan, &net_message, &curSize ))

	lea	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message
	push	OFFSET _cls+26800
	call	_Netchan_CopyNormalFragments
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@CL_ReadNet

; 2046 : 		{
; 2047 : 			MSG_Init( &net_message, "ServerData", net_message_buffer, curSize );

	push	-1
	mov	eax, DWORD PTR _curSize$[ebp]
	push	eax
	push	OFFSET _net_message_buffer
	push	OFFSET ??_C@_0L@GIBDHCEL@ServerData@
	push	OFFSET _net_message
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2048 : 			CL_ParseServerMessage( &net_message, false );

	push	0
	push	OFFSET _net_message
	call	_CL_ParseServerMessage
	add	esp, 8
$LN12@CL_ReadNet:

; 2049 : 		}
; 2050 : 		
; 2051 : 		if( Netchan_CopyFileFragments( &cls.netchan, &net_message ))

	push	OFFSET _net_message
	push	OFFSET _cls+26800
	call	_Netchan_CopyFileFragments
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@CL_ReadNet

; 2052 : 		{
; 2053 : 			// remove from resource request stuff.
; 2054 : 			CL_ProcessFile( true, cls.netchan.incomingfilename );

	push	OFFSET _cls+289204
	push	1
	call	_CL_ProcessFile
	add	esp, 8
$LN11@CL_ReadNet:

; 2055 : 		}
; 2056 : 	}
; 2057 : 
; 2058 : 	Netchan_UpdateProgress( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_UpdateProgress
	add	esp, 4

; 2059 : 
; 2060 : 	// check requests for time-expire
; 2061 : 	CL_ProcessNetRequests();

	call	_CL_ProcessNetRequests

; 2062 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadNetMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_GetMessage
_TEXT	SEGMENT
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_CL_GetMessage PROC					; COMDAT

; 1979 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1980 : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN2@CL_GetMess

; 1981 : 	{
; 1982 : 		if( CL_DemoReadMessage( data, length ))

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_CL_DemoReadMessage
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@CL_GetMess

; 1983 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_GetMess
$LN3@CL_GetMess:

; 1984 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetMess
$LN2@CL_GetMess:

; 1985 : 	}
; 1986 : 
; 1987 : 	if( NET_GetPacket( NS_CLIENT, &net_from, data, length ))

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	push	OFFSET _net_from
	push	0
	call	_NET_GetPacket
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@CL_GetMess

; 1988 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_GetMess
$LN4@CL_GetMess:

; 1989 : 	return false;

	xor	eax, eax
$LN1@CL_GetMess:

; 1990 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ConnectionlessPacket
_TEXT	SEGMENT
_list$1 = -66632					; size = 4
_nr$2 = -66628						; size = 4
_prev$3 = -66624					; size = 4
_list$4 = -66620					; size = 4
_nr$5 = -66616						; size = 4
_crcValue2$6 = -66612					; size = 4
_realsize$7 = -66608					; size = 4
_crcValue$8 = -66604					; size = 4
_recv_buf$9 = -66600					; size = 65536
_servadr$ = -1064					; size = 20
_dataoffset$ = -1044					; size = 4
_len$ = -1040						; size = 4
_buf$ = -1036						; size = 1024
_c$ = -12						; size = 4
_args$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_CL_ConnectionlessPacket PROC				; COMDAT

; 1762 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 67144				; 00010648H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1763 : 	char	*args;
; 1764 : 	char	*c, buf[MAX_SYSPATH];
; 1765 : 	int	len = sizeof( buf );

	mov	DWORD PTR _len$[ebp], 1024		; 00000400H

; 1766 : 	int	dataoffset = 0;

	mov	DWORD PTR _dataoffset$[ebp], 0

; 1767 : 	netadr_t	servadr;
; 1768 : 	
; 1769 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 1770 : 	MSG_ReadLong( msg ); // skip the -1

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4

; 1771 : 
; 1772 : 	args = MSG_ReadStringLine( msg );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 1773 : 
; 1774 : 	Cmd_TokenizeString( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 1775 : 	c = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 1776 : 
; 1777 : 	Con_Reportf( "CL_ConnectionlessPacket: %s : %s\n", NET_AdrToString( from ), c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CC@OJAMPIDI@CL_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 1778 : 
; 1779 : 	// server connection
; 1780 : 	if( !Q_strcmp( c, "client_connect" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0P@IOGHOCLL@client_connect@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_Connect

; 1781 : 	{
; 1782 : 		if( cls.state == ca_connected )

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN8@CL_Connect

; 1783 : 		{
; 1784 : 			Con_DPrintf( S_ERROR "dup connect received. ignored\n");

	push	OFFSET ??_C@_0CK@DICJNNNK@?$FO1Error?3?$FO7?5dup?5connect?5received@
	call	_Con_DPrintf
	add	esp, 4

; 1785 : 			return;

	jmp	$LN43@CL_Connect
$LN8@CL_Connect:

; 1786 : 		}
; 1787 : 
; 1788 : 		CL_Reconnect( true );

	push	1
	call	_CL_Reconnect
	add	esp, 4

; 1789 : 		UI_SetActiveMenu( cl.background );

	mov	eax, DWORD PTR _cl+64
	push	eax
	call	_UI_SetActiveMenu
	add	esp, 4

; 1790 : 	}

	jmp	$LN43@CL_Connect
$LN6@CL_Connect:

; 1791 : 	else if( !Q_strcmp( c, "info" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04NIDJFNBE@info@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_Connect

; 1792 : 	{
; 1793 : 		// server responding to a status broadcast
; 1794 : 		CL_ParseStatusMessage( from, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_CL_ParseStatusMessage
	add	esp, 24					; 00000018H

; 1795 : 	}

	jmp	$LN43@CL_Connect
$LN9@CL_Connect:

; 1796 : 	else if( !Q_strcmp( c, "netinfo" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07PHGFOLHM@netinfo@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@CL_Connect

; 1797 : 	{
; 1798 : 		// server responding to a status broadcast
; 1799 : 		CL_ParseNETInfoMessage( from, msg, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_CL_ParseNETInfoMessage
	add	esp, 28					; 0000001cH

; 1800 : 	}

	jmp	$LN43@CL_Connect
$LN11@CL_Connect:

; 1801 : 	else if( !Q_strcmp( c, "cmd" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03LGLGIONO@cmd@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN13@CL_Connect

; 1802 : 	{
; 1803 : 		// remote command from gui front end
; 1804 : 		if( !NET_IsLocalAddress( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN15@CL_Connect

; 1805 : 		{
; 1806 : 			Con_Printf( "Command packet from remote host. Ignored.\n" );

	push	OFFSET ??_C@_0CL@MOFOLJMP@Command?5packet?5from?5remote?5host@
	call	_Con_Printf
	add	esp, 4

; 1807 : 			return;

	jmp	$LN43@CL_Connect
$LN15@CL_Connect:

; 1808 : 		}
; 1809 : 
; 1810 : 		ShowWindow( host.hWnd, SW_RESTORE );

	push	9
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1811 : 		SetForegroundWindow ( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 1812 : 		args = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 1813 : 		Cbuf_AddText( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1814 : 		Cbuf_AddText( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4

; 1815 : 	}

	jmp	$LN43@CL_Connect
$LN13@CL_Connect:

; 1816 : 	else if( !Q_strcmp( c, "print" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05IJDJACGD@print@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@CL_Connect

; 1817 : 	{
; 1818 : 		// print command from somewhere
; 1819 : 		Con_Printf( "%s", MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8

; 1820 : 	}

	jmp	$LN43@CL_Connect
$LN16@CL_Connect:

; 1821 : 	else if( !Q_strcmp( c, "testpacket" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@BEEDAEFO@testpacket@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN18@CL_Connect

; 1822 : 	{
; 1823 : 		byte	recv_buf[NET_MAX_FRAGMENT];
; 1824 : 		dword	crcValue = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _crcValue$8[ebp], eax

; 1825 : 		int	realsize = MSG_GetMaxBytes( msg ) - MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetMaxBytes
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	esi, eax
	mov	DWORD PTR _realsize$7[ebp], esi

; 1826 : 		dword	crcValue2 = 0;

	mov	DWORD PTR _crcValue2$6[ebp], 0

; 1827 : 
; 1828 : 		if( cls.max_fragment_size != MSG_GetMaxBytes( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	DWORD PTR _cls+144, eax
	je	$LN20@CL_Connect

; 1829 : 		{
; 1830 : 			if( cls.connect_retry >= CL_TEST_RETRIES )

	cmp	DWORD PTR _cls+148, 5
	jl	SHORT $LN21@CL_Connect

; 1831 : 			{
; 1832 : 				// too many fails use default connection method
; 1833 : 				Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET ??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@
	call	_Con_Printf
	add	esp, 4

; 1834 : 				Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET ??_C@_0O@BELBLLBG@getchallenge?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1835 : 				Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	push	ecx
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	call	_Cvar_SetValue
	add	esp, 8

; 1836 : 				cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1837 : 				return;

	jmp	$LN43@CL_Connect
$LN21@CL_Connect:

; 1838 : 			}
; 1839 : 
; 1840 : 			// if we waiting more than cl_timeout or packet was trashed
; 1841 : 			cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1842 : 			return; // just wait for a next responce

	jmp	$LN43@CL_Connect
$LN20@CL_Connect:

; 1843 : 		}
; 1844 : 
; 1845 : 		// reading test buffer
; 1846 : 		MSG_ReadBytes( msg, recv_buf, realsize );

	mov	eax, DWORD PTR _realsize$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _recv_buf$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1847 : 
; 1848 : 		// procssing the CRC
; 1849 : 		CRC32_ProcessBuffer( &crcValue2, recv_buf, realsize );

	mov	eax, DWORD PTR _realsize$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _recv_buf$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _crcValue2$6[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 1850 : 
; 1851 : 		if( crcValue == crcValue2 )

	mov	eax, DWORD PTR _crcValue$8[ebp]
	cmp	eax, DWORD PTR _crcValue2$6[ebp]
	jne	SHORT $LN22@CL_Connect

; 1852 : 		{
; 1853 : 			// packet was sucessfully delivered, adjust the fragment size and get challenge
; 1854 : 			Con_DPrintf( "CRC %p is matched, get challenge, fragment size %d\n", crcValue, cls.max_fragment_size );

	mov	eax, DWORD PTR _cls+144
	push	eax
	mov	ecx, DWORD PTR _crcValue$8[ebp]
	push	ecx
	push	OFFSET ??_C@_0DE@IFANHFOD@CRC?5?$CFp?5is?5matched?0?5get?5challeng@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1855 : 			Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET ??_C@_0O@BELBLLBG@getchallenge?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1856 : 			Cvar_SetValue( "cl_dlmax", cls.max_fragment_size );

	cvtsi2ss xmm0, DWORD PTR _cls+144
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	call	_Cvar_SetValue
	add	esp, 8

; 1857 : 			cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1858 : 		}

	jmp	$LN23@CL_Connect
$LN22@CL_Connect:

; 1859 : 		else
; 1860 : 		{
; 1861 : 			if( cls.connect_retry >= CL_TEST_RETRIES )

	cmp	DWORD PTR _cls+148, 5
	jl	SHORT $LN24@CL_Connect

; 1862 : 			{
; 1863 : 				// too many fails use default connection method
; 1864 : 				Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET ??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@
	call	_Con_Printf
	add	esp, 4

; 1865 : 				Netchan_OutOfBandPrint( NS_CLIENT, from, "getchallenge\n" );

	push	OFFSET ??_C@_0O@BELBLLBG@getchallenge?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1866 : 				Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	push	ecx
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	call	_Cvar_SetValue
	add	esp, 8

; 1867 : 				cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1868 : 				return;

	jmp	$LN43@CL_Connect
$LN24@CL_Connect:

; 1869 : 			}
; 1870 : 
; 1871 : 			// trying the next size of packet
; 1872 : 			cls.connect_time = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0
$LN23@CL_Connect:

; 1873 : 		}
; 1874 : 	}

	jmp	$LN43@CL_Connect
$LN18@CL_Connect:

; 1875 : 	else if( !Q_strcmp( c, "ping" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04OONEELOO@ping@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@CL_Connect

; 1876 : 	{
; 1877 : 		// ping from somewhere
; 1878 : 		Netchan_OutOfBandPrint( NS_CLIENT, from, "ack" );

	push	OFFSET ??_C@_03JBLJHHJA@ack@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1879 : 	}

	jmp	$LN43@CL_Connect
$LN25@CL_Connect:

; 1880 : 	else if( !Q_strcmp( c, "challenge" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09DBEGHIJJ@challenge@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@CL_Connect

; 1881 : 	{
; 1882 : 		// challenge from the server we are connecting to
; 1883 : 		cls.challenge = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _cls+290568, eax

; 1884 : 		CL_SendConnectPacket();

	call	_CL_SendConnectPacket

; 1885 : 		return;

	jmp	$LN43@CL_Connect

; 1886 : 	}

	jmp	$LN43@CL_Connect
$LN27@CL_Connect:

; 1887 : 	else if( !Q_strcmp( c, "echo" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04OFDNEFMC@echo@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@CL_Connect

; 1888 : 	{
; 1889 : 		// echo request from server
; 1890 : 		Netchan_OutOfBandPrint( NS_CLIENT, from, "%s", Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 1891 : 	}

	jmp	$LN43@CL_Connect
$LN29@CL_Connect:

; 1892 : 	else if( !Q_strcmp( c, "disconnect" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@KKPFIJOL@disconnect@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@CL_Connect

; 1893 : 	{
; 1894 : 		// a disconnect message from the server, which will happen if the server
; 1895 : 		// dropped the connection but it is still getting packets from us
; 1896 : 		CL_Disconnect_f();

	call	_CL_Disconnect_f

; 1897 : 	}

	jmp	$LN43@CL_Connect
$LN31@CL_Connect:

; 1898 : 	else if( !Q_strcmp( c, "f" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01INIBCBCB@f@
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN33@CL_Connect
$LN2@CL_Connect:

; 1899 : 	{
; 1900 : 		// serverlist got from masterserver
; 1901 : 		while( MSG_GetNumBitsLeft( msg ) > 8 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jle	$LN3@CL_Connect

; 1902 : 		{
; 1903 : 			MSG_ReadBytes( msg, servadr.ip, sizeof( servadr.ip ));	// 4 bytes for IP

	push	4
	lea	eax, DWORD PTR _servadr$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 1904 : 			servadr.port = MSG_ReadShort( msg );			// 2 bytes for Port

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	WORD PTR _servadr$[ebp+18], ax

; 1905 : 			servadr.type = NA_IP;

	mov	DWORD PTR _servadr$[ebp], 3

; 1906 : 
; 1907 : 			// list is ends here
; 1908 : 			if( !servadr.port )

	movzx	eax, WORD PTR _servadr$[ebp+18]
	test	eax, eax
	jne	$LN35@CL_Connect

; 1909 : 			{
; 1910 : 				if( clgame.request_type == NET_REQUEST_CLIENT && clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+255296, 2
	jne	$LN36@CL_Connect
	cmp	DWORD PTR _clgame+260424, 0
	je	$LN36@CL_Connect

; 1911 : 				{
; 1912 : 					net_request_t	*nr = clgame.master_request;

	mov	eax, DWORD PTR _clgame+260424
	mov	DWORD PTR _nr$5[ebp], eax

; 1913 : 					net_adrlist_t	*list, **prev;
; 1914 : 
; 1915 : 					// setup the answer
; 1916 : 					nr->resp.remote_address = from;

	mov	eax, DWORD PTR _nr$5[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 1917 : 					nr->resp.error = NET_SUCCESS;

	mov	eax, DWORD PTR _nr$5[ebp]
	mov	DWORD PTR [eax], 0

; 1918 : 					nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$5[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$5[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 1919 : 
; 1920 : 					if( nr->timeout <= host.realtime )

	mov	eax, DWORD PTR _nr$5[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jb	SHORT $LN37@CL_Connect

; 1921 : 						SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$5[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$5[ebp]
	mov	DWORD PTR [edx], ecx
$LN37@CL_Connect:

; 1922 : 
; 1923 : 					Con_Printf( "serverlist call: %s\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BF@JLOFCKGL@serverlist?5call?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1924 : 					nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$5[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4

; 1925 : 
; 1926 : 					// throw the list, now it will be stored in user area
; 1927 : 					prev = &((net_adrlist_t *)nr->resp.response);

	mov	eax, DWORD PTR _nr$5[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _prev$3[ebp], eax
$LN4@CL_Connect:

; 1928 : 
; 1929 : 					while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@CL_Connect

; 1930 : 					{
; 1931 : 						list = *prev;

	mov	eax, DWORD PTR _prev$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _list$4[ebp], ecx

; 1932 : 						if( !list ) break;

	cmp	DWORD PTR _list$4[ebp], 0
	jne	SHORT $LN38@CL_Connect
	jmp	SHORT $LN5@CL_Connect
$LN38@CL_Connect:

; 1933 : 
; 1934 : 						// throw out any variables the game created
; 1935 : 						*prev = list->next;

	mov	eax, DWORD PTR _prev$3[ebp]
	mov	ecx, DWORD PTR _list$4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1936 : 						Mem_Free( list );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ConnectionlessPacket@@9@9
	add	eax, 174				; 000000aeH
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _list$4[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1937 : 					}

	jmp	SHORT $LN4@CL_Connect
$LN5@CL_Connect:

; 1938 : 					memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$5[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1939 : 					clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+255296, 0

; 1940 : 					clgame.master_request = NULL;

	mov	DWORD PTR _clgame+260424, 0
$LN36@CL_Connect:

; 1941 : 				}
; 1942 : 				break;

	jmp	$LN3@CL_Connect
$LN35@CL_Connect:

; 1943 : 			}
; 1944 : 
; 1945 : 			if( clgame.request_type == NET_REQUEST_CLIENT && clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+255296, 2
	jne	$LN39@CL_Connect
	cmp	DWORD PTR _clgame+260424, 0
	je	$LN39@CL_Connect

; 1946 : 			{
; 1947 : 				net_request_t	*nr = clgame.master_request;

	mov	eax, DWORD PTR _clgame+260424
	mov	DWORD PTR _nr$2[ebp], eax

; 1948 : 				net_adrlist_t	*list;
; 1949 : 
; 1950 : 				// adding addresses into list
; 1951 : 				list = Z_Malloc( sizeof( *list ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ConnectionlessPacket@@9@9
	add	eax, 189				; 000000bdH
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	24					; 00000018H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _list$1[ebp], eax

; 1952 : 				list->remote_address = servadr;

	mov	eax, DWORD PTR _list$1[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _servadr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _servadr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _servadr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _servadr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _servadr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 1953 : 				list->next = nr->resp.response;

	mov	eax, DWORD PTR _list$1[ebp]
	mov	ecx, DWORD PTR _nr$2[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax], edx

; 1954 : 				nr->resp.response = list;

	mov	eax, DWORD PTR _nr$2[ebp]
	mov	ecx, DWORD PTR _list$1[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1955 : 			}

	jmp	SHORT $LN41@CL_Connect
$LN39@CL_Connect:

; 1956 : 			else if( clgame.request_type == NET_REQUEST_GAMEUI )

	cmp	DWORD PTR _clgame+255296, 1
	jne	SHORT $LN41@CL_Connect

; 1957 : 			{
; 1958 : 				NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1959 : 				Netchan_OutOfBandPrint( NS_CLIENT, servadr, "info %i", PROTOCOL_VERSION );

	push	49					; 00000031H
	push	OFFSET ??_C@_07GBLEFLLO@info?5?$CFi@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _servadr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _servadr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _servadr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _servadr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _servadr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H
$LN41@CL_Connect:

; 1960 : 			}
; 1961 : 		}

	jmp	$LN2@CL_Connect
$LN3@CL_Connect:

; 1962 : 	}

	jmp	$LN43@CL_Connect
$LN33@CL_Connect:

; 1963 : 	else if( clgame.dllFuncs.pfnConnectionlessPacket( &from, args, buf, &len ))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	DWORD PTR _clgame+128
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN42@CL_Connect

; 1964 : 	{
; 1965 : 		// user out of band message (must be handled in CL_ConnectionlessPacket)
; 1966 : 		if( len > 0 ) Netchan_OutOfBand( NS_SERVER, from, len, buf );

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN44@CL_Connect
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	1
	call	_Netchan_OutOfBand
	add	esp, 32					; 00000020H
$LN44@CL_Connect:

; 1967 : 	}

	jmp	SHORT $LN43@CL_Connect
$LN42@CL_Connect:

; 1968 : 	else Con_DPrintf( S_ERROR "bad connectionless packet from %s:\n%s\n", NET_AdrToString( from ), args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN43@CL_Connect:

; 1969 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ConnectionlessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ProcessNetRequests
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_CL_ProcessNetRequests PROC				; COMDAT

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1694 : 	net_request_t	*nr;
; 1695 : 	int		i;
; 1696 : 
; 1697 : 	// find a request with specified context
; 1698 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Process:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_Process

; 1699 : 	{
; 1700 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax

; 1701 : 		if( !nr->pfnFunc ) continue;	// not used

	mov	eax, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN5@CL_Process
	jmp	SHORT $LN2@CL_Process
$LN5@CL_Process:

; 1702 : 
; 1703 : 		if( nr->timeout <= host.realtime )

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jb	SHORT $LN6@CL_Process

; 1704 : 		{
; 1705 : 			// setup the answer
; 1706 : 			SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx

; 1707 : 			nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 1708 : 
; 1709 : 			nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4

; 1710 : 			memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@CL_Process:

; 1711 : 		}
; 1712 : 	}

	jmp	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 1713 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessNetRequests ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ParseNETInfoMessage
_TEXT	SEGMENT
_val$ = -24						; size = 4
_errorBits$ = -20					; size = 4
_type$ = -16						; size = 4
_context$ = -12						; size = 4
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_s$ = 32						; size = 4
_CL_ParseNETInfoMessage PROC				; COMDAT

; 1638 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1639 : 	net_request_t	*nr;
; 1640 : 	static char	infostring[MAX_INFO_STRING+8];
; 1641 : 	int		i, context, type;
; 1642 : 	int		errorBits = 0;

	mov	DWORD PTR _errorBits$[ebp], 0

; 1643 : 	char		*val;
; 1644 : 
; 1645 : 	context = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _context$[ebp], eax

; 1646 : 	type = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax
$LN2@CL_ParseNE:

; 1647 : 	while( *s != '\\' ) s++; // fetching infostring

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@CL_ParseNE
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN2@CL_ParseNE
$LN3@CL_ParseNE:

; 1648 : 
; 1649 : 	// check for errors
; 1650 : 	val = Info_ValueForKey( s, "neterror" );

	push	OFFSET ??_C@_08EJOEDJLI@neterror@
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1651 : 
; 1652 : 	if( !Q_stricmp( val, "protocol" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08FCFPNNHF@protocol@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@CL_ParseNE

; 1653 : 		SetBits( errorBits, NET_ERROR_PROTO_UNSUPPORTED );

	mov	eax, DWORD PTR _errorBits$[ebp]
	or	eax, 2
	mov	DWORD PTR _errorBits$[ebp], eax
	jmp	SHORT $LN9@CL_ParseNE
$LN7@CL_ParseNE:

; 1654 : 	else if( !Q_stricmp( val, "undefined" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09MLGAJAED@undefined@
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_ParseNE

; 1655 : 		SetBits( errorBits, NET_ERROR_UNDEFINED );

	mov	eax, DWORD PTR _errorBits$[ebp]
	or	eax, 4
	mov	DWORD PTR _errorBits$[ebp], eax
$LN9@CL_ParseNE:

; 1656 : 
; 1657 : 	CL_FixupColorStringsForInfoString( s, infostring );

	push	OFFSET ?infostring@?1??CL_ParseNETInfoMessage@@9@9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_CL_FixupColorStringsForInfoString
	add	esp, 8

; 1658 : 
; 1659 : 	// find a request with specified context
; 1660 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_ParseNE
$LN4@CL_ParseNE:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_ParseNE:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN5@CL_ParseNE

; 1661 : 	{
; 1662 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax

; 1663 : 
; 1664 : 		if( nr->resp.context == context && nr->resp.type == type )

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _context$[ebp]
	jne	$LN10@CL_ParseNE
	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _type$[ebp]
	jne	$LN10@CL_ParseNE

; 1665 : 		{
; 1666 : 			// setup the answer
; 1667 : 			nr->resp.response = infostring;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax+40], OFFSET ?infostring@?1??CL_ParseNETInfoMessage@@9@9

; 1668 : 			nr->resp.remote_address = from;

	mov	eax, DWORD PTR _nr$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 1669 : 			nr->resp.error = NET_SUCCESS;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [eax], 0

; 1670 : 			nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 1671 : 
; 1672 : 			if( nr->timeout <= host.realtime )

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+56]
	jb	SHORT $LN11@CL_ParseNE

; 1673 : 				SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx
$LN11@CL_ParseNE:

; 1674 : 			SetBits( nr->resp.error, errorBits ); // misc error bits

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, DWORD PTR _errorBits$[ebp]
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx

; 1675 : 
; 1676 : 			nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4

; 1677 : 
; 1678 : 			if( !FBitSet( nr->flags, FNETAPI_MULTIPLE_RESPONSE ))

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	and	ecx, 1
	jne	SHORT $LN12@CL_ParseNE

; 1679 : 				memset( nr, 0, sizeof( *nr )); // done

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN12@CL_ParseNE:

; 1680 : 			return;

	jmp	SHORT $LN5@CL_ParseNE
$LN10@CL_ParseNE:

; 1681 : 		}
; 1682 : 	}

	jmp	$LN4@CL_ParseNE
$LN5@CL_ParseNE:

; 1683 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseNETInfoMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ParseStatusMessage
_TEXT	SEGMENT
_s$ = -4						; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_CL_ParseStatusMessage PROC				; COMDAT

; 1612 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1613 : 	static char	infostring[MAX_INFO_STRING+8];
; 1614 : 	char		*s = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 1615 : 
; 1616 : 	CL_FixupColorStringsForInfoString( s, infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_CL_FixupColorStringsForInfoString
	add	esp, 8

; 1617 : 
; 1618 : 	if( !COM_CheckString( Info_ValueForKey( infostring, "gamedir" )))

	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_ParseSt

; 1619 : 	{
; 1620 : 		Con_Printf( "^1Server^7: %s, Info: %s\n", NET_AdrToString( from ), infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BK@JJLGHCHK@?$FO1Server?$FO7?3?5?$CFs?0?5Info?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1621 : 		return; // unsupported proto

	jmp	SHORT $LN1@CL_ParseSt
$LN2@CL_ParseSt:

; 1622 : 	}
; 1623 : 
; 1624 : 	// more info about servers
; 1625 : 	Con_Printf( "^2Server^7: %s, Game: %s\n", NET_AdrToString( from ), Info_ValueForKey( infostring, "gamedir" ));

	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BK@JEDBHIFD@?$FO2Server?$FO7?3?5?$CFs?0?5Game?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1626 : 
; 1627 : 	UI_AddServerToList( from, infostring );

	push	OFFSET ?infostring@?1??CL_ParseStatusMessage@@9@9
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_UI_AddServerToList
	add	esp, 24					; 00000018H
$LN1@CL_ParseSt:

; 1628 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseStatusMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_FixupColorStringsForInfoString
_TEXT	SEGMENT
_count$ = -16						; size = 4
_color$ = -12						; size = 4
_endOfKeyVal$ = -8					; size = 4
_hasPrefix$ = -4					; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_CL_FixupColorStringsForInfoString PROC			; COMDAT

; 1548 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1549 : 	qboolean	hasPrefix = false;

	mov	DWORD PTR _hasPrefix$[ebp], 0

; 1550 : 	qboolean	endOfKeyVal = false;

	mov	DWORD PTR _endOfKeyVal$[ebp], 0

; 1551 : 	int	color = 7;

	mov	DWORD PTR _color$[ebp], 7

; 1552 : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1553 : 
; 1554 : 	if( *in == '\\' )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@CL_FixupCo

; 1555 : 	{
; 1556 : 		*out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 1557 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN2@CL_FixupCo:

; 1558 : 	}
; 1559 : 
; 1560 : 	while( *in && count < MAX_INFO_STRING )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@CL_FixupCo
	cmp	DWORD PTR _count$[ebp], 256		; 00000100H
	jge	$LN3@CL_FixupCo

; 1561 : 	{
; 1562 : 		if( IsColorString( in ))

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN5@CL_FixupCo
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN5@CL_FixupCo
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN5@CL_FixupCo
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN5@CL_FixupCo
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN5@CL_FixupCo

; 1563 : 			color = ColorIndex( *(in+1));

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	sub	ecx, 48					; 00000030H
	and	ecx, 7
	mov	DWORD PTR _color$[ebp], ecx
$LN5@CL_FixupCo:

; 1564 : 
; 1565 : 		// color the not reset while end of key (or value) was found!
; 1566 : 		if( *in == '\\' && color != 7 )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN6@CL_FixupCo
	cmp	DWORD PTR _color$[ebp], 7
	je	SHORT $LN6@CL_FixupCo

; 1567 : 		{
; 1568 : 			if( IsColorString( out - 2 ))

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, 2
	je	SHORT $LN7@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-2]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN7@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	test	ecx, ecx
	je	SHORT $LN7@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN7@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN7@CL_FixupCo

; 1569 : 			{
; 1570 : 				*(out - 1) = '7';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax-1], 55			; 00000037H

; 1571 : 			}

	jmp	SHORT $LN8@CL_FixupCo
$LN7@CL_FixupCo:

; 1572 : 			else
; 1573 : 			{
; 1574 : 				*out++ = '^';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 94			; 0000005eH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1575 : 				*out++ = '7';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 55			; 00000037H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1576 : 				count += 2;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 2
	mov	DWORD PTR _count$[ebp], eax
$LN8@CL_FixupCo:

; 1577 : 			}
; 1578 : 			color = 7;

	mov	DWORD PTR _color$[ebp], 7
$LN6@CL_FixupCo:

; 1579 : 		}
; 1580 : 
; 1581 : 		*out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 1582 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 1583 : 	}

	jmp	$LN2@CL_FixupCo
$LN3@CL_FixupCo:

; 1584 : 
; 1585 : 	// check the remaining value
; 1586 : 	if( color != 7 )

	cmp	DWORD PTR _color$[ebp], 7
	je	SHORT $LN9@CL_FixupCo

; 1587 : 	{
; 1588 : 		// if the ends with another color rewrite it
; 1589 : 		if( IsColorString( out - 2 ))

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, 2
	je	SHORT $LN10@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-2]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN10@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	test	ecx, ecx
	je	SHORT $LN10@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@CL_FixupCo
	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN10@CL_FixupCo

; 1590 : 		{
; 1591 : 			*(out - 1) = '7';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax-1], 55			; 00000037H

; 1592 : 		}

	jmp	SHORT $LN9@CL_FixupCo
$LN10@CL_FixupCo:

; 1593 : 		else
; 1594 : 		{
; 1595 : 			*out++ = '^';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 94			; 0000005eH
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1596 : 			*out++ = '7';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 55			; 00000037H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 1597 : 			count += 2;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 2
	mov	DWORD PTR _count$[ebp], eax
$LN9@CL_FixupCo:

; 1598 : 		}
; 1599 : 	}
; 1600 : 
; 1601 : 	*out = '\0';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0

; 1602 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FixupColorStringsForInfoString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Reconnect_f
_TEXT	SEGMENT
_CL_Reconnect_f PROC					; COMDAT

; 1514 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1515 : 	if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_Reconne

; 1516 : 		return;

	jmp	$LN4@CL_Reconne
$LN2@CL_Reconne:

; 1517 : 
; 1518 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1519 : 
; 1520 : 	if( cls.state == ca_connected )

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN3@CL_Reconne

; 1521 : 	{
; 1522 : 		CL_Reconnect( false );

	push	0
	call	_CL_Reconnect
	add	esp, 4

; 1523 : 		return;

	jmp	SHORT $LN4@CL_Reconne
$LN3@CL_Reconne:

; 1524 : 	}
; 1525 : 
; 1526 : 	if( COM_CheckString( cls.servername ))

	push	OFFSET _cls+72
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_Reconne

; 1527 : 	{
; 1528 : 		if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN5@CL_Reconne

; 1529 : 			CL_Disconnect();

	call	_CL_Disconnect
$LN5@CL_Reconne:

; 1530 : 
; 1531 : 		cls.connect_time = MAX_HEARTBEAT;	// fire immediately

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1532 : 		cls.demonum = cls.movienum = -1;	// not in the demo loop now

	mov	DWORD PTR _cls+298772, -1
	mov	eax, DWORD PTR _cls+298772
	mov	DWORD PTR _cls+296712, eax

; 1533 : 		cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1534 : 		cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1535 : 
; 1536 : 		Con_Printf( "reconnecting...\n" );

	push	OFFSET ??_C@_0BB@DIBMBDMI@reconnecting?4?4?4?6@
	call	_Con_Printf
	add	esp, 4
$LN4@CL_Reconne:

; 1537 : 	}
; 1538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Reconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_InternetServers_f
_TEXT	SEGMENT
_adr$ = -544						; size = 20
_remaining$ = -524					; size = 4
_info$ = -520						; size = 4
_fullquery$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_CL_InternetServers_f PROC				; COMDAT

; 1480 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 672				; 000002a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1481 : 	char	fullquery[512] = MS_SCAN_REQUEST;

	mov	eax, DWORD PTR ??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@
	mov	DWORD PTR _fullquery$[ebp], eax
	mov	ecx, DWORD PTR ??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@+4
	mov	DWORD PTR _fullquery$[ebp+4], ecx
	mov	edx, DWORD PTR ??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@+8
	mov	DWORD PTR _fullquery$[ebp+8], edx
	mov	al, BYTE PTR ??_C@_0N@CIFHLALM@1?$PP0?40?40?40?30?$AA@+12
	mov	BYTE PTR _fullquery$[ebp+12], al
	push	499					; 000001f3H
	push	0
	lea	eax, DWORD PTR _fullquery$[ebp+13]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1482 : 	char	*info = fullquery + sizeof( MS_SCAN_REQUEST ) - 1;

	lea	eax, DWORD PTR _fullquery$[ebp+12]
	mov	DWORD PTR _info$[ebp], eax

; 1483 : 	int	remaining = sizeof( fullquery ) - sizeof( MS_SCAN_REQUEST );

	mov	DWORD PTR _remaining$[ebp], 499		; 000001f3H

; 1484 : 	netadr_t	adr;
; 1485 : 
; 1486 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1487 : 
; 1488 : 	if( !NET_StringToAdr( MASTERSERVER_ADR, &adr ) )

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@FHKNHLNB@ms?4xash?4su?327010@
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@CL_Interne

; 1489 : 	{
; 1490 : 		Con_DPrintf( S_ERROR "Can't resolve adr: %s\n", MASTERSERVER_ADR );

	push	OFFSET ??_C@_0BB@FHKNHLNB@ms?4xash?4su?327010@
	push	OFFSET ??_C@_0CC@FKAGDMAF@?$FO1Error?3?$FO7?5Can?8t?5resolve?5adr?3?5?$CF@
	call	_Con_DPrintf
	add	esp, 8

; 1491 : 		return;

	jmp	$LN1@CL_Interne
$LN2@CL_Interne:

; 1492 : 	}
; 1493 : 
; 1494 : 	Con_Printf( "Scanning for servers on the internet area...\n" );

	push	OFFSET ??_C@_0CO@DFHJDOOJ@Scanning?5for?5servers?5on?5the?5int@
	call	_Con_Printf
	add	esp, 4

; 1495 : 	Info_SetValueForKey( info, "gamedir", GI->gamefolder, remaining );

	mov	eax, DWORD PTR _remaining$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SI+768
	push	ecx
	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1496 : 	Info_SetValueForKey( info, "clver", XASH_VERSION, remaining ); // let master know about client version

	mov	eax, DWORD PTR _remaining$[ebp]
	push	eax
	push	OFFSET ??_C@_04PNCPDLMM@0?499@
	push	OFFSET ??_C@_05IBNOFEBL@clver@
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1497 : 
; 1498 : 	NET_SendPacket( NS_CLIENT, sizeof( MS_SCAN_REQUEST ) + Q_strlen( info ), fullquery, adr );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _fullquery$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 13					; 0000000dH
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 1499 : 
; 1500 : 	// now we clearing the vgui request
; 1501 : 	if( clgame.master_request != NULL )

	cmp	DWORD PTR _clgame+260424, 0
	je	SHORT $LN3@CL_Interne

; 1502 : 		memset( clgame.master_request, 0, sizeof( net_request_t ));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _clgame+260424
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN3@CL_Interne:

; 1503 : 	clgame.request_type = NET_REQUEST_GAMEUI;

	mov	DWORD PTR _clgame+255296, 1
$LN1@CL_Interne:

; 1504 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InternetServers_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_LocalServers_f
_TEXT	SEGMENT
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_LocalServers_f PROC					; COMDAT

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1462 : 	netadr_t	adr;
; 1463 : 
; 1464 : 	Con_Printf( "Scanning for servers on the local network area...\n" );

	push	OFFSET ??_C@_0DD@FDBOEDJA@Scanning?5for?5servers?5on?5the?5loc@
	call	_Con_Printf
	add	esp, 4

; 1465 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1466 : 	
; 1467 : 	// send a broadcast packet
; 1468 : 	adr.type = NA_BROADCAST;

	mov	DWORD PTR _adr$[ebp], 2

; 1469 : 	adr.port = MSG_BigShort( PORT_SERVER );

	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax

; 1470 : 
; 1471 : 	Netchan_OutOfBandPrint( NS_CLIENT, adr, "info %i", PROTOCOL_VERSION );

	push	49					; 00000031H
	push	OFFSET ??_C@_07GBLEFLLO@info?5?$CFi@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 1472 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LocalServers_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Reconnect
_TEXT	SEGMENT
_setup_netchan$ = 8					; size = 4
_CL_Reconnect PROC					; COMDAT

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1363 : 	if( setup_netchan )

	cmp	DWORD PTR _setup_netchan$[ebp], 0
	je	SHORT $LN2@CL_Reconne

; 1364 : 	{
; 1365 : 		Netchan_Setup( NS_CLIENT, &cls.netchan, net_from, Cvar_VariableInteger( "net_qport" ), NULL, CL_GetFragmentSize );

	push	OFFSET _CL_GetFragmentSize
	push	0
	push	OFFSET ??_C@_09HOOHLIKH@net_qport@
	call	_Cvar_VariableInteger
	add	esp, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	push	OFFSET _cls+26800
	push	0
	call	_Netchan_Setup
	add	esp, 40					; 00000028H

; 1366 : 	}

	jmp	SHORT $LN3@CL_Reconne
$LN2@CL_Reconne:

; 1367 : 	else
; 1368 : 	{
; 1369 : 		// clear channel and stuff
; 1370 : 		Netchan_Clear( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_Clear
	add	esp, 4

; 1371 : 		MSG_Clear( &cls.netchan.message );

	push	OFFSET _cls+26900
	call	_MSG_Clear
	add	esp, 4
$LN3@CL_Reconne:

; 1372 : 	}
; 1373 : 
; 1374 : 	cls.demonum = cls.movienum = -1;	// not in the demo loop now

	mov	DWORD PTR _cls+298772, -1
	mov	eax, DWORD PTR _cls+298772
	mov	DWORD PTR _cls+296712, eax

; 1375 : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 1376 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1377 : 
; 1378 : 	CL_ServerCommand( true, "new" );

	push	OFFSET ??_C@_03CLCAEGCJ@new@
	push	1
	call	_CL_ServerCommand
	add	esp, 8

; 1379 : 
; 1380 : 	cl.validsequence = 0;		// haven't gotten a valid frame update yet

	mov	DWORD PTR _cl+4, 0

; 1381 : 	cl.delta_sequence = -1;		// we'll request a full delta from the baseline

	mov	DWORD PTR _cl+28, -1

; 1382 : 	cls.lastoutgoingcommand = -1;		// we don't have a backed up cmd history yet

	mov	DWORD PTR _cls+290592, -1

; 1383 : 	cls.nextcmdtime = host.realtime;	// we can send a cmd right away

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+290588, xmm0

; 1384 : 	cl.last_command_ack = -1;

	mov	DWORD PTR _cl+52, -1

; 1385 : 
; 1386 : 	CL_StartupDemoHeader ();

	call	_CL_StartupDemoHeader

; 1387 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Reconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SendDisconnectMessage
_TEXT	SEGMENT
_data$ = -56						; size = 32
_buf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_SendDisconnectMessage PROC				; COMDAT

; 1335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1336 : 	sizebuf_t	buf;
; 1337 : 	byte	data[32];
; 1338 : 
; 1339 : 	if( cls.state == ca_disconnected ) return;

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_SendDis
	jmp	$LN1@CL_SendDis
$LN2@CL_SendDis:

; 1340 : 
; 1341 : 	MSG_Init( &buf, "LastMessage", data, sizeof( data ));

	push	-1
	push	32					; 00000020H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@BOHCKFHE@LastMessage@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1342 : 	MSG_BeginClientCmd( &buf, clc_stringcmd );

	push	0
	push	0
	push	3
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1343 : 	MSG_WriteString( &buf, "disconnect" );

	push	OFFSET ??_C@_0L@KKPFIJOL@disconnect@
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1344 : 
; 1345 : 	if( !cls.netchan.remote_address.type )

	cmp	DWORD PTR _cls+26804, 0
	jne	SHORT $LN3@CL_SendDis

; 1346 : 		cls.netchan.remote_address.type = NA_LOOPBACK;

	mov	DWORD PTR _cls+26804, 1
$LN3@CL_SendDis:

; 1347 : 
; 1348 : 	// make sure message will be delivered
; 1349 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 1350 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 1351 : 	Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN1@CL_SendDis:

; 1352 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendDisconnectMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Rcon_f
_TEXT	SEGMENT
$T1 = -1248						; size = 4
_i$ = -1052						; size = 4
_to$ = -1048						; size = 20
_message$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_CL_Rcon_f PROC						; COMDAT

; 1232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1248				; 000004e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1233 : 	char	message[1024];
; 1234 : 	netadr_t	to;
; 1235 : 	int	i;
; 1236 : 
; 1237 : 	if( !COM_CheckString( rcon_client_password->string ))

	mov	eax, DWORD PTR _rcon_client_password
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_Rcon_f

; 1238 : 	{
; 1239 : 		Con_Printf( "You must set 'rcon_password' before issuing an rcon command.\n" );

	push	OFFSET ??_C@_0DO@NCNKNADM@You?5must?5set?5?8rcon_password?8?5be@
	call	_Con_Printf
	add	esp, 4

; 1240 : 		return;

	jmp	$LN10@CL_Rcon_f
$LN5@CL_Rcon_f:

; 1241 : 	}
; 1242 : 
; 1243 : 	message[0] = (char)255;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _message$[ebp+ecx], -1

; 1244 : 	message[1] = (char)255;

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _message$[ebp+eax], -1

; 1245 : 	message[2] = (char)255;

	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _message$[ebp+eax], -1

; 1246 : 	message[3] = (char)255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _message$[ebp+ecx], -1

; 1247 : 	message[4] = 0;

	mov	eax, 1
	shl	eax, 2
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN11@CL_Rcon_f
	jmp	SHORT $LN12@CL_Rcon_f
$LN11@CL_Rcon_f:
	call	___report_rangecheckfailure
$LN12@CL_Rcon_f:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _message$[ebp+ecx], 0

; 1248 : 
; 1249 : 	NET_Config( true );	// allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1250 : 
; 1251 : 	Q_strcat( message, "rcon " );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05GCMNNKNG@rcon?5@
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1252 : 	Q_strcat( message, rcon_client_password->string );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _rcon_client_password
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1253 : 	Q_strcat( message, " " );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1254 : 
; 1255 : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_Rcon_f
$LN2@CL_Rcon_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Rcon_f:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@CL_Rcon_f

; 1256 : 	{
; 1257 : 		Q_strcat( message, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1258 : 		Q_strcat( message, " " );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1259 : 	}

	jmp	SHORT $LN2@CL_Rcon_f
$LN3@CL_Rcon_f:

; 1260 : 
; 1261 : 	if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN6@CL_Rcon_f

; 1262 : 	{
; 1263 : 		to = cls.netchan.remote_address;

	mov	eax, DWORD PTR _cls+26804
	mov	DWORD PTR _to$[ebp], eax
	mov	ecx, DWORD PTR _cls+26808
	mov	DWORD PTR _to$[ebp+4], ecx
	mov	edx, DWORD PTR _cls+26812
	mov	DWORD PTR _to$[ebp+8], edx
	mov	eax, DWORD PTR _cls+26816
	mov	DWORD PTR _to$[ebp+12], eax
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR _to$[ebp+16], ecx

; 1264 : 	}

	jmp	SHORT $LN7@CL_Rcon_f
$LN6@CL_Rcon_f:

; 1265 : 	else
; 1266 : 	{
; 1267 : 		if( !COM_CheckString( rcon_address->string ))

	mov	eax, DWORD PTR _rcon_address
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@CL_Rcon_f

; 1268 : 		{
; 1269 : 			Con_Printf( "You must either be connected or set the 'rcon_address' cvar to issue rcon commands\n" );

	push	OFFSET ??_C@_0FE@OFOGMBMH@You?5must?5either?5be?5connected?5or@
	call	_Con_Printf
	add	esp, 4

; 1270 : 			return;

	jmp	$LN10@CL_Rcon_f
$LN8@CL_Rcon_f:

; 1271 : 		}
; 1272 : 
; 1273 : 		NET_StringToAdr( rcon_address->string, &to );

	lea	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rcon_address
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_NET_StringToAdr
	add	esp, 8

; 1274 : 		if( to.port == 0 ) to.port = MSG_BigShort( PORT_SERVER );

	movzx	eax, WORD PTR _to$[ebp+18]
	test	eax, eax
	jne	SHORT $LN7@CL_Rcon_f
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _to$[ebp+18], ax
$LN7@CL_Rcon_f:

; 1275 : 	}
; 1276 : 	
; 1277 : 	NET_SendPacket( NS_CLIENT, Q_strlen( message ) + 1, message, to );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN10@CL_Rcon_f:

; 1278 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Rcon_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Connect_f
_TEXT	SEGMENT
_server$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_Connect_f PROC					; COMDAT

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1193 : 	string	server;
; 1194 : 
; 1195 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@CL_Connect

; 1196 : 	{
; 1197 : 		Con_Printf( S_USAGE "connect <server>\n" );

	push	OFFSET ??_C@_0BJ@FPBNGOLO@Usage?3?5connect?5?$DMserver?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1198 : 		return;	

	jmp	$LN1@CL_Connect
$LN2@CL_Connect:

; 1199 : 	}
; 1200 : 
; 1201 : 	Q_strncpy( server, Cmd_Argv( 1 ), sizeof( server ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _server$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1202 : 
; 1203 : 	// if running a local server, kill it and reissue
; 1204 : 	if( SV_Active( )) Host_ShutdownServer();

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN3@CL_Connect
	call	_Host_ShutdownServer
$LN3@CL_Connect:

; 1205 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 1206 : 
; 1207 : 	Con_Printf( "server %s\n", server );

	lea	eax, DWORD PTR _server$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@BFANEHJC@server?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1208 : 	CL_Disconnect();

	call	_CL_Disconnect

; 1209 : 
; 1210 : 	// TESTTEST: a see console during connection
; 1211 : 	UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4

; 1212 : 	Key_SetKeyDest( key_console );

	push	0
	call	_Key_SetKeyDest
	add	esp, 4

; 1213 : 
; 1214 : 	cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1215 : 	Q_strncpy( cls.servername, server, sizeof( cls.servername ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _server$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1216 : 	cls.connect_time = MAX_HEARTBEAT; // CL_CheckForResend() will fire immediately

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _cls+136, xmm0

; 1217 : 	cls.max_fragment_size = FRAGMENT_MAX_SIZE; // guess a we can establish connection with maximum fragment size

	mov	DWORD PTR _cls+144, 64000		; 0000fa00H

; 1218 : 	cls.connect_retry = 0;

	mov	DWORD PTR _cls+148, 0

; 1219 : 	cls.spectator = false;

	mov	DWORD PTR _cls+152, 0

; 1220 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0
$LN1@CL_Connect:

; 1221 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Connect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_CreateResourceList
_TEXT	SEGMENT
_fp$ = -292						; size = 4
_nSize$ = -288						; size = 4
_pNewResource$ = -284					; size = 4
_rgucMD5_hash$ = -280					; size = 16
_szFileName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_CL_CreateResourceList PROC				; COMDAT

; 1150 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1151 : 	char		szFileName[MAX_OSPATH];
; 1152 : 	byte		rgucMD5_hash[16];
; 1153 : 	resource_t	*pNewResource;
; 1154 : 	int		nSize;
; 1155 : 	file_t		*fp;
; 1156 : 
; 1157 : 	HPAK_FlushHostQueue();

	call	_HPAK_FlushHostQueue

; 1158 : 	cl.num_resources = 0;

	mov	DWORD PTR _cl+4561592, 0

; 1159 : 
; 1160 : 	Q_snprintf( szFileName, sizeof( szFileName ), "logos/remapped.bmp" );

	push	OFFSET ??_C@_0BD@IOMBPIHF@logos?1remapped?4bmp@
	push	260					; 00000104H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 12					; 0000000cH

; 1161 : 	memset( rgucMD5_hash, 0, sizeof( rgucMD5_hash ));

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _rgucMD5_hash$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1162 : 
; 1163 : 	fp = FS_Open( szFileName, "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1164 : 
; 1165 : 	if( fp )

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN1@CL_CreateR

; 1166 : 	{
; 1167 : 		MD5_HashFile( rgucMD5_hash, szFileName, NULL );

	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgucMD5_hash$[ebp]
	push	ecx
	call	_MD5_HashFile
	add	esp, 12					; 0000000cH

; 1168 : 		nSize = FS_FileLength( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_FileLength
	add	esp, 4
	mov	DWORD PTR _nSize$[ebp], eax

; 1169 : 
; 1170 : 		if( nSize != 0 )

	cmp	DWORD PTR _nSize$[ebp], 0
	je	SHORT $LN3@CL_CreateR

; 1171 : 		{
; 1172 : 			pNewResource = CL_AddResource( t_decal, szFileName, nSize, false, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	3
	call	_CL_AddResource
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pNewResource$[ebp], eax

; 1173 : 
; 1174 : 			if( pNewResource )

	cmp	DWORD PTR _pNewResource$[ebp], 0
	je	SHORT $LN3@CL_CreateR

; 1175 : 			{
; 1176 : 				SetBits( pNewResource->ucFlags, RES_CUSTOM );

	mov	eax, DWORD PTR _pNewResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 4
	mov	edx, DWORD PTR _pNewResource$[ebp]
	mov	BYTE PTR [edx+76], cl

; 1177 : 				memcpy( pNewResource->rgucMD5_hash, rgucMD5_hash, 16 );

	push	16					; 00000010H
	lea	eax, DWORD PTR _rgucMD5_hash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewResource$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1178 : 				HPAK_AddLump( false, CUSTOM_RES_PATH, pNewResource, NULL, fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pNewResource$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	push	0
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H
$LN3@CL_CreateR:

; 1179 : 			}
; 1180 : 		}
; 1181 : 		FS_Close( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@CL_CreateR:

; 1182 : 	}
; 1183 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_AddResource
_TEXT	SEGMENT
tv75 = -72						; size = 4
_r$ = -4						; size = 4
_type$ = 8						; size = 4
_name$ = 12						; size = 4
_size$ = 16						; size = 4
_bFatalIfMissing$ = 20					; size = 4
_index$ = 24						; size = 4
_CL_AddResource PROC					; COMDAT

; 1133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1134 : 	resource_t	*r = &cl.resourcelist[cl.num_resources];

	imul	eax, DWORD PTR _cl+4561592, 136
	add	eax, OFFSET _cl+3029688
	mov	DWORD PTR _r$[ebp], eax

; 1135 : 
; 1136 : 	if( cl.num_resources >= MAX_RESOURCES )

	cmp	DWORD PTR _cl+4561592, 11264		; 00002c00H
	jl	SHORT $LN2@CL_AddReso

; 1137 : 		Host_Error( "Too many resources on client\n" );

	push	OFFSET ??_C@_0BO@LICHHHNB@Too?5many?5resources?5on?5client?6@
	call	_Host_Error
	add	esp, 4
$LN2@CL_AddReso:

; 1138 : 	cl.num_resources++;

	mov	eax, DWORD PTR _cl+4561592
	add	eax, 1
	mov	DWORD PTR _cl+4561592, eax

; 1139 : 
; 1140 : 	Q_strncpy( r->szFileName, name, sizeof( r->szFileName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1141 : 	r->ucFlags |= bFatalIfMissing ? RES_FATALIFMISSING : 0;

	cmp	DWORD PTR _bFatalIfMissing$[ebp], 0
	je	SHORT $LN4@CL_AddReso
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN5@CL_AddReso
$LN4@CL_AddReso:
	mov	DWORD PTR tv75[ebp], 0
$LN5@CL_AddReso:
	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [edx+76], cl

; 1142 : 	r->nDownloadSize = size;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1143 : 	r->nIndex = index;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 1144 : 	r->type = type;

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 1145 : 
; 1146 : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 1147 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_CheckForResend
_TEXT	SEGMENT
tv137 = -100						; size = 4
tv139 = -96						; size = 4
tv133 = -92						; size = 4
_adr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_CheckForResend PROC					; COMDAT

; 1068 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1069 : 	netadr_t	adr;
; 1070 : 
; 1071 : 	// if the local server is running and we aren't then connect
; 1072 : 	if( cls.state == ca_disconnected && SV_Active( ))

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_CheckFo
	call	_SV_Active
	test	eax, eax
	je	SHORT $LN2@CL_CheckFo

; 1073 : 	{
; 1074 : 		cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1075 : 		cls.state = ca_connecting;

	mov	DWORD PTR _cls, 1

; 1076 : 		Q_strncpy( cls.servername, "localhost", sizeof( cls.servername ));

	push	64					; 00000040H
	push	OFFSET ??_C@_09IPAEKDAI@localhost@
	push	OFFSET _cls+72
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1077 : 		// we don't need a challenge on the localhost
; 1078 : 		CL_SendConnectPacket();

	call	_CL_SendConnectPacket

; 1079 : 		return;

	jmp	$LN14@CL_CheckFo
$LN2@CL_CheckFo:

; 1080 : 	}
; 1081 : 
; 1082 : 	// resend if we haven't gotten a reply yet
; 1083 : 	if( cls.demoplayback || cls.state != ca_connecting )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN4@CL_CheckFo
	cmp	DWORD PTR _cls, 1
	je	SHORT $LN3@CL_CheckFo
$LN4@CL_CheckFo:

; 1084 : 		return;

	jmp	$LN14@CL_CheckFo
$LN3@CL_CheckFo:

; 1085 : 
; 1086 : 	if( cl_resend.value < CL_MIN_RESEND_TIME )

	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR _cl_resend+12
	jbe	SHORT $LN5@CL_CheckFo

; 1087 : 		Cvar_SetValue( "cl_resend", CL_MIN_RESEND_TIME );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09MCGIDBGM@cl_resend@
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN7@CL_CheckFo
$LN5@CL_CheckFo:

; 1088 : 	else if( cl_resend.value > CL_MAX_RESEND_TIME )

	movss	xmm0, DWORD PTR _cl_resend+12
	comiss	xmm0, DWORD PTR __real@41a00000
	jbe	SHORT $LN7@CL_CheckFo

; 1089 : 		Cvar_SetValue( "cl_resend", CL_MAX_RESEND_TIME );

	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09MCGIDBGM@cl_resend@
	call	_Cvar_SetValue
	add	esp, 8
$LN7@CL_CheckFo:

; 1090 : 
; 1091 : 	if(( host.realtime - cls.connect_time ) < cl_resend.value )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+136
	cvtss2sd xmm1, DWORD PTR _cl_resend+12
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@CL_CheckFo

; 1092 : 		return;

	jmp	$LN14@CL_CheckFo
$LN8@CL_CheckFo:

; 1093 : 
; 1094 : 	if( !NET_StringToAdr( cls.servername, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@CL_CheckFo

; 1095 : 	{
; 1096 : 		CL_Disconnect();

	call	_CL_Disconnect

; 1097 : 		return;

	jmp	$LN14@CL_CheckFo
$LN9@CL_CheckFo:

; 1098 : 	}
; 1099 : 
; 1100 : 	// only retry so many times before failure.
; 1101 : 	if( cls.connect_retry >= CL_CONNECTION_RETRIES )

	cmp	DWORD PTR _cls+148, 10			; 0000000aH
	jl	SHORT $LN10@CL_CheckFo

; 1102 : 	{
; 1103 : 		Con_DPrintf( S_ERROR "CL_CheckForResend: couldn't connected\n" );

	push	OFFSET ??_C@_0DC@CJPDMOGH@?$FO1Error?3?$FO7?5CL_CheckForResend?3?5c@
	call	_Con_DPrintf
	add	esp, 4

; 1104 : 		CL_Disconnect();

	call	_CL_Disconnect

; 1105 : 		return;

	jmp	$LN14@CL_CheckFo
$LN10@CL_CheckFo:

; 1106 : 	}
; 1107 : 
; 1108 : 	if( adr.port == 0 ) adr.port = MSG_BigShort( PORT_SERVER );

	movzx	eax, WORD PTR _adr$[ebp+18]
	test	eax, eax
	jne	SHORT $LN11@CL_CheckFo
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax
$LN11@CL_CheckFo:

; 1109 : 
; 1110 : 	if( cls.connect_retry == CL_TEST_RETRIES_NORESPONCE )

	cmp	DWORD PTR _cls+148, 2
	jne	SHORT $LN12@CL_CheckFo

; 1111 : 	{
; 1112 : 		// too many fails use default connection method
; 1113 : 		Con_Printf( "hi-speed connection is failed, use default method\n" );

	push	OFFSET ??_C@_0DD@MOPJJDLG@hi?9speed?5connection?5is?5failed?0?5@
	call	_Con_Printf
	add	esp, 4

; 1114 : 		Netchan_OutOfBandPrint( NS_CLIENT, adr, "getchallenge\n" );

	push	OFFSET ??_C@_0O@BELBLLBG@getchallenge?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 1115 : 		Cvar_SetValue( "cl_dlmax", FRAGMENT_MIN_SIZE );

	push	ecx
	movss	xmm0, DWORD PTR __real@44960000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	call	_Cvar_SetValue
	add	esp, 8

; 1116 : 		cls.connect_time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1117 : 		cls.connect_retry++;

	mov	eax, DWORD PTR _cls+148
	add	eax, 1
	mov	DWORD PTR _cls+148, eax

; 1118 : 		return;

	jmp	$LN14@CL_CheckFo
$LN12@CL_CheckFo:

; 1119 : 	}
; 1120 : 
; 1121 : 	cls.max_fragment_size = Q_max( FRAGMENT_MAX_SIZE, cls.max_fragment_size >> Q_min( 1, cls.connect_retry ));

	cmp	DWORD PTR _cls+148, 1
	jle	SHORT $LN16@CL_CheckFo
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN17@CL_CheckFo
$LN16@CL_CheckFo:
	mov	eax, DWORD PTR _cls+148
	mov	DWORD PTR tv133[ebp], eax
$LN17@CL_CheckFo:
	mov	edx, DWORD PTR _cls+144
	mov	ecx, DWORD PTR tv133[ebp]
	sar	edx, cl
	cmp	edx, 64000				; 0000fa00H
	jge	SHORT $LN20@CL_CheckFo
	mov	DWORD PTR tv139[ebp], 64000		; 0000fa00H
	jmp	SHORT $LN21@CL_CheckFo
$LN20@CL_CheckFo:
	cmp	DWORD PTR _cls+148, 1
	jle	SHORT $LN18@CL_CheckFo
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN19@CL_CheckFo
$LN18@CL_CheckFo:
	mov	eax, DWORD PTR _cls+148
	mov	DWORD PTR tv137[ebp], eax
$LN19@CL_CheckFo:
	mov	edx, DWORD PTR _cls+144
	mov	ecx, DWORD PTR tv137[ebp]
	sar	edx, cl
	mov	DWORD PTR tv139[ebp], edx
$LN21@CL_CheckFo:
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR _cls+144, eax

; 1122 : 	cls.connect_time = host.realtime; // for retransmit requests

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+136, xmm0

; 1123 : 	cls.connect_retry++;

	mov	eax, DWORD PTR _cls+148
	add	eax, 1
	mov	DWORD PTR _cls+148, eax

; 1124 : 
; 1125 : 	Con_Printf( "Connecting to %s... [retry #%i]\n", cls.servername, cls.connect_retry );

	mov	eax, DWORD PTR _cls+148
	push	eax
	push	OFFSET _cls+72
	push	OFFSET ??_C@_0CB@PLILGMJK@Connecting?5to?5?$CFs?4?4?4?5?$FLretry?5?$CD?$CFi?$FN@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1126 : 
; 1127 : 	if( cl_test_bandwidth.value )

	movss	xmm0, DWORD PTR _cl_test_bandwidth+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@CL_CheckFo

; 1128 : 		Netchan_OutOfBandPrint( NS_CLIENT, adr, "bandwidth %i %i\n", PROTOCOL_VERSION, cls.max_fragment_size );

	mov	eax, DWORD PTR _cls+144
	push	eax
	push	49					; 00000031H
	push	OFFSET ??_C@_0BB@BGHIAFEK@bandwidth?5?$CFi?5?$CFi?6@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 36					; 00000024H
	jmp	SHORT $LN14@CL_CheckFo
$LN13@CL_CheckFo:

; 1129 : 	else Netchan_OutOfBandPrint( NS_CLIENT, adr, "getchallenge\n" );

	push	OFFSET ??_C@_0O@BELBLLBG@getchallenge?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN14@CL_CheckFo:

; 1130 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckForResend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SendConnectPacket
_TEXT	SEGMENT
_adr$ = -288						; size = 20
_key$ = -268						; size = 4
_qport$ = -264						; size = 4
_protinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_SendConnectPacket PROC				; COMDAT

; 1035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1036 : 	char	protinfo[MAX_INFO_STRING];
; 1037 : 	char	*qport;
; 1038 : 	char	*key;
; 1039 : 	netadr_t	adr;
; 1040 : 
; 1041 : 	if( !NET_StringToAdr( cls.servername, &adr ))

	lea	eax, DWORD PTR _adr$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@CL_SendCon

; 1042 : 	{
; 1043 : 		Con_Printf( "CL_SendConnectPacket: bad server address\n");

	push	OFFSET ??_C@_0CK@GCLLEHKK@CL_SendConnectPacket?3?5bad?5serve@
	call	_Con_Printf
	add	esp, 4

; 1044 : 		cls.connect_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+136, xmm0

; 1045 : 		return;

	jmp	$LN1@CL_SendCon
$LN2@CL_SendCon:

; 1046 : 	}
; 1047 : 
; 1048 : 	if( adr.port == 0 ) adr.port = MSG_BigShort( PORT_SERVER );

	movzx	eax, WORD PTR _adr$[ebp+18]
	test	eax, eax
	jne	SHORT $LN3@CL_SendCon
	push	27015					; 00006987H
	call	_MSG_BigShort
	add	esp, 4
	mov	WORD PTR _adr$[ebp+18], ax
$LN3@CL_SendCon:

; 1049 : 	qport = Cvar_VariableString( "net_qport" );

	push	OFFSET ??_C@_09HOOHLIKH@net_qport@
	call	_Cvar_VariableString
	add	esp, 4
	mov	DWORD PTR _qport$[ebp], eax

; 1050 : 	key = CL_GetCDKeyHash();

	call	_CL_GetCDKeyHash
	mov	DWORD PTR _key$[ebp], eax

; 1051 : 
; 1052 : 	memset( protinfo, 0, sizeof( protinfo ));

	push	256					; 00000100H
	push	0
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1053 : 	Info_SetValueForKey( protinfo, "uuid", key, sizeof( protinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET ??_C@_04BCJJGJPP@uuid@
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1054 : 	Info_SetValueForKey( protinfo, "qport", qport, sizeof( protinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _qport$[ebp]
	push	eax
	push	OFFSET ??_C@_05IPCIHGO@qport@
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1055 : 
; 1056 : 	Netchan_OutOfBandPrint( NS_CLIENT, adr, "connect %i %i \"%s\" \"%s\"\n", PROTOCOL_VERSION, cls.challenge, protinfo, cls.userinfo );

	push	OFFSET _cls+9880
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+290568
	push	ecx
	push	49					; 00000031H
	push	OFFSET ??_C@_0BJ@INHGGABP@connect?5?$CFi?5?$CFi?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 44					; 0000002cH

; 1057 : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16
$LN1@CL_SendCon:

; 1058 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendConnectPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_GetCDKeyHash
_TEXT	SEGMENT
$T1 = -188						; size = 4
_ctx$ = -120						; size = 88
_digest$ = -32						; size = 17
_nKeyLength$ = -12					; size = 4
_keyBuffer$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_GetCDKeyHash PROC					; COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1003 : 	const char	*keyBuffer;
; 1004 : 	static char	szHashedKeyBuffer[256];
; 1005 : 	int		nKeyLength = 0;

	mov	DWORD PTR _nKeyLength$[ebp], 0

; 1006 : 	byte		digest[17]; // The MD5 Hash
; 1007 : 	MD5Context_t	ctx;
; 1008 : 
; 1009 : 	keyBuffer = Sys_GetMachineKey( &nKeyLength );

	lea	eax, DWORD PTR _nKeyLength$[ebp]
	push	eax
	call	_Sys_GetMachineKey
	add	esp, 4
	mov	DWORD PTR _keyBuffer$[ebp], eax

; 1010 : 
; 1011 : 	// now get the md5 hash of the key
; 1012 : 	memset( &ctx, 0, sizeof( ctx ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1013 : 	memset( digest, 0, sizeof( digest ));

	push	17					; 00000011H
	push	0
	lea	eax, DWORD PTR _digest$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1014 : 	
; 1015 : 	MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 1016 : 	MD5Update( &ctx, (byte *)keyBuffer, nKeyLength );

	mov	eax, DWORD PTR _nKeyLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _keyBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctx$[ebp]
	push	edx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 1017 : 	MD5Final( digest, &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _digest$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 1018 : 	digest[16] = '\0';

	mov	eax, 1
	shl	eax, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 17			; 00000011H
	jae	SHORT $LN3@CL_GetCDKe
	jmp	SHORT $LN4@CL_GetCDKe
$LN3@CL_GetCDKe:
	call	___report_rangecheckfailure
$LN4@CL_GetCDKe:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _digest$[ebp+ecx], 0

; 1019 : 
; 1020 : 	memset( szHashedKeyBuffer, 0, 256 );

	push	256					; 00000100H
	push	0
	push	OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
	call	_memset
	add	esp, 12					; 0000000cH

; 1021 : 	Q_strncpy( szHashedKeyBuffer, MD5_Print( digest ), sizeof( szHashedKeyBuffer ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _digest$[ebp]
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1022 : 
; 1023 : 	return szHashedKeyBuffer;

	mov	eax, OFFSET ?szHashedKeyBuffer@?1??CL_GetCDKeyHash@@9@9
$LN2@CL_GetCDKe:

; 1024 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetCDKeyHash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_BeginUpload_f
_TEXT	SEGMENT
_ctx$1 = -272						; size = 88
_md5$2 = -184						; size = 16
_md5$ = -168						; size = 16
_size$ = -152						; size = 4
_buf$ = -148						; size = 4
_custResource$ = -144					; size = 136
_name$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_BeginUpload_f PROC					; COMDAT

; 906  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 907  : 	char		*name;
; 908  : 	resource_t	custResource;
; 909  : 	byte		*buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 910  : 	int		size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 911  : 	byte		md5[16];
; 912  : 
; 913  : 	name = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 914  : 
; 915  : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_BeginUp

; 916  : 		return;

	jmp	$LN10@CL_BeginUp
$LN2@CL_BeginUp:

; 917  : 
; 918  : 	if( !cl_allow_upload.value )

	movss	xmm0, DWORD PTR _cl_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_BeginUp

; 919  : 		return;

	jmp	$LN10@CL_BeginUp
$LN3@CL_BeginUp:

; 920  : 
; 921  : 	if( Q_strlen( name ) != 36 || Q_strnicmp( name, "!MD5", 4 ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN5@CL_BeginUp
	push	4
	push	OFFSET ??_C@_04HJKAGJBM@?$CBMD5@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@CL_BeginUp
$LN5@CL_BeginUp:

; 922  : 	{
; 923  : 		Con_Printf( "Ingoring upload of non-customization\n" );

	push	OFFSET ??_C@_0CG@IJLLNIPI@Ingoring?5upload?5of?5non?9customiz@
	call	_Con_Printf
	add	esp, 4

; 924  : 		return;

	jmp	$LN10@CL_BeginUp
$LN4@CL_BeginUp:

; 925  : 	}
; 926  : 
; 927  : 	memset( &custResource, 0, sizeof( custResource ));

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 928  : 	COM_HexConvert( name + 4, 32, md5 );

	lea	eax, DWORD PTR _md5$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, 4
	push	ecx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 929  : 
; 930  : 	if( HPAK_ResourceForHash( CUSTOM_RES_PATH, md5, &custResource ))

	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_ResourceForHash
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN9@CL_BeginUp

; 931  : 	{
; 932  : 		if( memcmp( md5, custResource.rgucMD5_hash, 16 ))

	push	16					; 00000010H
	lea	eax, DWORD PTR _custResource$[ebp+77]
	push	eax
	lea	ecx, DWORD PTR _md5$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@CL_BeginUp

; 933  : 		{
; 934  : 			Con_Reportf( "Bogus data retrieved from %s, attempting to delete entry\n", CUSTOM_RES_PATH );

	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	push	OFFSET ??_C@_0DK@MCGJPAHP@Bogus?5data?5retrieved?5from?5?$CFs?0?5a@
	call	_Con_Reportf
	add	esp, 8

; 935  : 			HPAK_RemoveLump( CUSTOM_RES_PATH, &custResource );

	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_RemoveLump
	add	esp, 8

; 936  : 			return;

	jmp	$LN10@CL_BeginUp
$LN7@CL_BeginUp:

; 937  : 		}
; 938  : 
; 939  : 		if( HPAK_GetDataPointer( CUSTOM_RES_PATH, &custResource, &buf, &size ))

	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _custResource$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN9@CL_BeginUp

; 940  : 		{
; 941  : 			byte		md5[16];
; 942  : 			MD5Context_t	ctx;
; 943  : 
; 944  : 			memset( &ctx, 0, sizeof( ctx ));

	push	88					; 00000058H
	push	0
	lea	eax, DWORD PTR _ctx$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 945  : 			MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$1[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 946  : 			MD5Update( &ctx, buf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ctx$1[ebp]
	push	edx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 947  : 			MD5Final( md5, &ctx );

	lea	eax, DWORD PTR _ctx$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$2[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 948  : 
; 949  : 			if( memcmp( custResource.rgucMD5_hash, md5, 16 ))

	push	16					; 00000010H
	lea	eax, DWORD PTR _md5$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _custResource$[ebp+77]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@CL_BeginUp

; 950  : 			{
; 951  : 				Con_Reportf( "HPAK_AddLump called with bogus lump, md5 mismatch\n" );

	push	OFFSET ??_C@_0DD@JPFNAHEK@HPAK_AddLump?5called?5with?5bogus?5@
	call	_Con_Reportf
	add	esp, 4

; 952  : 				Con_Reportf( "Purported:  %s\n", MD5_Print( custResource.rgucMD5_hash ) );

	lea	eax, DWORD PTR _custResource$[ebp+77]
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BA@OPIGPFCH@Purported?3?5?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8

; 953  : 				Con_Reportf( "Actual   :  %s\n", MD5_Print( md5 ) );

	lea	eax, DWORD PTR _md5$2[ebp]
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BA@LICAHJIO@Actual?5?5?5?3?5?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8

; 954  : 				Con_Reportf( "Removing conflicting lump\n" );

	push	OFFSET ??_C@_0BL@CFCAJJKK@Removing?5conflicting?5lump?6@
	call	_Con_Reportf
	add	esp, 4

; 955  : 				HPAK_RemoveLump( CUSTOM_RES_PATH, &custResource );

	lea	eax, DWORD PTR _custResource$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_RemoveLump
	add	esp, 8

; 956  : 				return;

	jmp	SHORT $LN10@CL_BeginUp
$LN9@CL_BeginUp:

; 957  : 			}
; 958  : 		}
; 959  : 	}
; 960  : 
; 961  : 	if( buf && size > 0 )

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN10@CL_BeginUp
	cmp	DWORD PTR _size$[ebp], 0
	jle	SHORT $LN10@CL_BeginUp

; 962  : 	{
; 963  : 		Netchan_CreateFileFragmentsFromBuffer( &cls.netchan, name, buf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET _cls+26800
	call	_Netchan_CreateFileFragmentsFromBuffer
	add	esp, 16					; 00000010H

; 964  : 		Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_FragSend
	add	esp, 4

; 965  : 		Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_BeginUpload_f@@9@9
	add	eax, 59					; 0000003bH
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@CL_BeginUp:

; 966  : 	}
; 967  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_BeginUpload_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_WritePacket
_TEXT	SEGMENT
tv229 = -8588						; size = 4
tv205 = -8588						; size = 4
tv81 = -8588						; size = 4
tv228 = -8584						; size = 4
tv204 = -8584						; size = 4
tv80 = -8584						; size = 4
_outgoing_sequence$1 = -8068				; size = 4
_cmdnumber$ = -8064					; size = 4
_newcmds$ = -8060					; size = 4
_numcmds$ = -8056					; size = 4
_numbackup$ = -8052					; size = 4
_size$ = -8048						; size = 4
_key$ = -8044						; size = 4
_to$ = -8040						; size = 4
_from$ = -8036						; size = 4
_i$ = -8032						; size = 4
_data$ = -8028						; size = 8000
_send_command$ = -28					; size = 4
_buf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_CL_WritePacket PROC					; COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8588				; 0000218cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 713  : 	sizebuf_t		buf;
; 714  : 	qboolean		send_command = false;

	mov	DWORD PTR _send_command$[ebp], 0

; 715  : 	byte		data[MAX_CMD_BUFFER];
; 716  : 	int		i, from, to, key, size;
; 717  : 	int		numbackup = 2;

	mov	DWORD PTR _numbackup$[ebp], 2

; 718  : 	int		numcmds;
; 719  : 	int		newcmds;
; 720  : 	int		cmdnumber;
; 721  : 	
; 722  : 	// don't send anything if playing back a demo
; 723  : 	if( cls.demoplayback || cls.state < ca_connected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN6@CL_WritePa
	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN6@CL_WritePa
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN5@CL_WritePa
$LN6@CL_WritePa:

; 724  : 		return;

	jmp	$LN1@CL_WritePa
$LN5@CL_WritePa:

; 725  : 
; 726  : 	CL_ComputePacketLoss ();

	call	_CL_ComputePacketLoss

; 727  : 
; 728  : 	MSG_Init( &buf, "ClientData", data, sizeof( data ));

	push	-1
	push	8000					; 00001f40H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@DCAPMAMJ@ClientData@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 729  : 
; 730  : 	// Determine number of backup commands to send along
; 731  : 	numbackup = bound( 0, cl_cmdbackup->value, MAX_BACKUP_COMMANDS );

	mov	eax, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN38@CL_WritePa
	mov	ecx, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR __real@41800000
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN36@CL_WritePa
	mov	edx, DWORD PTR _cl_cmdbackup
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR tv80[ebp], xmm0
	jmp	SHORT $LN37@CL_WritePa
$LN36@CL_WritePa:
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR tv80[ebp], xmm0
$LN37@CL_WritePa:
	movss	xmm0, DWORD PTR tv80[ebp]
	movss	DWORD PTR tv81[ebp], xmm0
	jmp	SHORT $LN39@CL_WritePa
$LN38@CL_WritePa:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv81[ebp], xmm0
$LN39@CL_WritePa:
	cvttss2si eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR _numbackup$[ebp], eax

; 732  : 	if( cls.state == ca_connected ) numbackup = 0;

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN7@CL_WritePa
	mov	DWORD PTR _numbackup$[ebp], 0
$LN7@CL_WritePa:

; 733  : 
; 734  : 	// clamp cmdrate
; 735  : 	if( cl_cmdrate->value < 0.0f ) Cvar_SetValue( "cl_cmdrate", 0.0f );

	mov	eax, DWORD PTR _cl_cmdrate
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN8@CL_WritePa
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@FHOEGPOF@cl_cmdrate@
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN10@CL_WritePa
$LN8@CL_WritePa:

; 736  : 	else if( cl_cmdrate->value > 100.0f ) Cvar_SetValue( "cl_cmdrate", 100.0f );

	mov	eax, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN10@CL_WritePa
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@FHOEGPOF@cl_cmdrate@
	call	_Cvar_SetValue
	add	esp, 8
$LN10@CL_WritePa:

; 737  : 
; 738  : 	// Check to see if we can actually send this command
; 739  : 
; 740  : 	// In single player, send commands as fast as possible
; 741  : 	// Otherwise, only send when ready and when not choking bandwidth
; 742  : 	if( cl.maxclients == 1 || ( NET_IsLocalAddress( cls.netchan.remote_address ) && !host_limitlocal->value ))

	cmp	DWORD PTR _cl+2213004, 1
	je	SHORT $LN12@CL_WritePa
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _cls+26804
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+26808
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+26812
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+26816
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN11@CL_WritePa
	mov	eax, DWORD PTR _host_limitlocal
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@CL_WritePa
$LN12@CL_WritePa:

; 743  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN11@CL_WritePa:

; 744  : 
; 745  : 	if(( host.realtime >= cls.nextcmdtime ) && Netchan_CanPacket( &cls.netchan, true ))

	cvtss2sd xmm0, DWORD PTR _cls+290588
	movsd	xmm1, QWORD PTR _host+1440
	comisd	xmm1, xmm0
	jb	SHORT $LN13@CL_WritePa
	push	1
	push	OFFSET _cls+26800
	call	_Netchan_CanPacket
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@CL_WritePa

; 746  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN13@CL_WritePa:

; 747  : 
; 748  : 	if( cl.send_reply )

	cmp	DWORD PTR _cl+60, 0
	je	SHORT $LN14@CL_WritePa

; 749  : 	{
; 750  : 		cl.send_reply = false;

	mov	DWORD PTR _cl+60, 0

; 751  : 		send_command = true;

	mov	DWORD PTR _send_command$[ebp], 1
$LN14@CL_WritePa:

; 752  : 	}
; 753  : 
; 754  : 	// spectator is not sending cmds to server
; 755  : 	if( cls.spectator && cls.state == ca_active && cl.delta_sequence == cl.validsequence )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN16@CL_WritePa
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN16@CL_WritePa
	mov	eax, DWORD PTR _cl+28
	cmp	eax, DWORD PTR _cl+4
	jne	SHORT $LN16@CL_WritePa

; 756  : 	{
; 757  : 		if( !( cls.demorecording && cls.demowaiting ) && cls.nextcmdtime + 1.0f > host.realtime )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN17@CL_WritePa
	cmp	DWORD PTR _cls+300832, 0
	jne	SHORT $LN16@CL_WritePa
$LN17@CL_WritePa:
	movss	xmm0, DWORD PTR _cls+290588
	addss	xmm0, DWORD PTR __real@3f800000
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN16@CL_WritePa

; 758  : 			return;

	jmp	$LN1@CL_WritePa
$LN16@CL_WritePa:

; 759  : 	}
; 760  : 
; 761  : 	if(( cls.netchan.outgoing_sequence - cls.netchan.incoming_acknowledged ) >= CL_UPDATE_MASK )

	mov	eax, DWORD PTR _cls+26880
	sub	eax, DWORD PTR _cls+26868
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	cmp	eax, ecx
	jl	SHORT $LN19@CL_WritePa

; 762  : 	{
; 763  : 		if(( host.realtime - cls.netchan.last_received ) > CONNECTION_PROBLEM_TIME )

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+26832
	comisd	xmm0, QWORD PTR __real@402e000000000000
	jbe	SHORT $LN19@CL_WritePa

; 764  : 		{
; 765  : 			Con_NPrintf( 1, "^3Warning:^1 Connection Problem^7\n" );

	push	OFFSET ??_C@_0CD@MNHOADLI@?$FO3Warning?3?$FO1?5Connection?5Problem@
	push	1
	call	_Con_NPrintf
	add	esp, 8

; 766  : 			cl.validsequence = 0;

	mov	DWORD PTR _cl+4, 0
$LN19@CL_WritePa:

; 767  : 		}
; 768  : 	}
; 769  : 
; 770  : 	if( cl_nodelta->value )

	mov	eax, DWORD PTR _cl_nodelta
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@CL_WritePa

; 771  : 		cl.validsequence = 0;

	mov	DWORD PTR _cl+4, 0
$LN20@CL_WritePa:

; 772  : 
; 773  : 	if( send_command )

	cmp	DWORD PTR _send_command$[ebp], 0
	je	$LN21@CL_WritePa

; 774  : 	{
; 775  : 		int	outgoing_sequence;
; 776  : 	
; 777  : 		if( cl_cmdrate->value > 0 ) // clamped between 10 and 100 fps

	mov	eax, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN23@CL_WritePa

; 778  : 			cls.nextcmdtime = host.realtime + bound( 0.1f, ( 1.0f / cl_cmdrate->value ), 0.01f );

	mov	eax, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jb	SHORT $LN42@CL_WritePa
	mov	ecx, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [ecx+12]
	movss	xmm1, DWORD PTR __real@3c23d70a
	comiss	xmm1, xmm0
	jbe	SHORT $LN40@CL_WritePa
	mov	edx, DWORD PTR _cl_cmdrate
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR tv204[ebp], xmm0
	jmp	SHORT $LN41@CL_WritePa
$LN40@CL_WritePa:
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR tv204[ebp], xmm0
$LN41@CL_WritePa:
	movss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR tv205[ebp], xmm0
	jmp	SHORT $LN43@CL_WritePa
$LN42@CL_WritePa:
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR tv205[ebp], xmm0
$LN43@CL_WritePa:
	cvtss2sd xmm0, DWORD PTR tv205[ebp]
	addsd	xmm0, QWORD PTR _host+1440
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cls+290588, xmm0
	jmp	SHORT $LN24@CL_WritePa
$LN23@CL_WritePa:

; 779  : 		else cls.nextcmdtime = host.realtime; // always able to send right away

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+290588, xmm0
$LN24@CL_WritePa:

; 780  : 
; 781  : 		if( cls.lastoutgoingcommand == -1 )

	cmp	DWORD PTR _cls+290592, -1
	jne	SHORT $LN25@CL_WritePa

; 782  : 		{
; 783  : 			outgoing_sequence = cls.netchan.outgoing_sequence;

	mov	eax, DWORD PTR _cls+26880
	mov	DWORD PTR _outgoing_sequence$1[ebp], eax

; 784  : 			cls.lastoutgoingcommand = cls.netchan.outgoing_sequence;

	mov	eax, DWORD PTR _cls+26880
	mov	DWORD PTR _cls+290592, eax

; 785  : 		}

	jmp	SHORT $LN26@CL_WritePa
$LN25@CL_WritePa:

; 786  : 		else outgoing_sequence = cls.lastoutgoingcommand + 1;

	mov	eax, DWORD PTR _cls+290592
	add	eax, 1
	mov	DWORD PTR _outgoing_sequence$1[ebp], eax
$LN26@CL_WritePa:

; 787  : 
; 788  : 		// begin a client move command
; 789  : 		MSG_BeginClientCmd( &buf, clc_move );

	push	0
	push	0
	push	2
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 790  : 
; 791  : 		// save the position for a checksum byte
; 792  : 		key = MSG_GetRealBytesWritten( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	mov	DWORD PTR _key$[ebp], eax

; 793  : 		MSG_WriteByte( &buf, 0 );

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 794  : 
; 795  : 		// write packet lossage percentation
; 796  : 		MSG_WriteByte( &buf, cls.packet_loss );

	cvttss2si eax, DWORD PTR _cls+290572
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 797  : 
; 798  : 		// say how many backups we'll be sending
; 799  : 		MSG_WriteByte( &buf, numbackup );

	mov	eax, DWORD PTR _numbackup$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 800  : 
; 801  : 		// how many real commands have queued up
; 802  : 		newcmds = ( cls.netchan.outgoing_sequence - cls.lastoutgoingcommand );

	mov	eax, DWORD PTR _cls+26880
	sub	eax, DWORD PTR _cls+290592
	mov	DWORD PTR _newcmds$[ebp], eax

; 803  : 
; 804  : 		// put an upper/lower bound on this
; 805  : 		newcmds = bound( 0, newcmds, MAX_TOTAL_CMDS );

	js	SHORT $LN46@CL_WritePa
	cmp	DWORD PTR _newcmds$[ebp], 32		; 00000020H
	jge	SHORT $LN44@CL_WritePa
	mov	eax, DWORD PTR _newcmds$[ebp]
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN45@CL_WritePa
$LN44@CL_WritePa:
	mov	DWORD PTR tv228[ebp], 32		; 00000020H
$LN45@CL_WritePa:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR tv229[ebp], ecx
	jmp	SHORT $LN47@CL_WritePa
$LN46@CL_WritePa:
	mov	DWORD PTR tv229[ebp], 0
$LN47@CL_WritePa:
	mov	edx, DWORD PTR tv229[ebp]
	mov	DWORD PTR _newcmds$[ebp], edx

; 806  : 		if( cls.state == ca_connected ) newcmds = 0;

	cmp	DWORD PTR _cls, 2
	jne	SHORT $LN27@CL_WritePa
	mov	DWORD PTR _newcmds$[ebp], 0
$LN27@CL_WritePa:

; 807  : 	
; 808  : 		MSG_WriteByte( &buf, newcmds );

	mov	eax, DWORD PTR _newcmds$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 809  : 
; 810  : 		numcmds = newcmds + numbackup;

	mov	eax, DWORD PTR _newcmds$[ebp]
	add	eax, DWORD PTR _numbackup$[ebp]
	mov	DWORD PTR _numcmds$[ebp], eax

; 811  : 		from = -1;

	mov	DWORD PTR _from$[ebp], -1

; 812  : 
; 813  : 		for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_WritePa
$LN2@CL_WritePa:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_WritePa:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@CL_WritePa

; 814  : 		{
; 815  : 			cmdnumber = ( cls.netchan.outgoing_sequence - i ) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _cls+26880
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	mov	DWORD PTR _cmdnumber$[ebp], eax

; 816  : 
; 817  : 			to = cmdnumber;

	mov	eax, DWORD PTR _cmdnumber$[ebp]
	mov	DWORD PTR _to$[ebp], eax

; 818  : 			CL_WriteUsercmd( &buf, from, to );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_CL_WriteUsercmd
	add	esp, 12					; 0000000cH

; 819  : 			from = to;

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 820  : 
; 821  : 			if( MSG_CheckOverflow( &buf ))

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN28@CL_WritePa

; 822  : 				Host_Error( "CL_WritePacket: overflowed command buffer (%i bytes)\n", MAX_CMD_BUFFER );

	push	8000					; 00001f40H
	push	OFFSET ??_C@_0DG@JCLEFCHC@CL_WritePacket?3?5overflowed?5comm@
	call	_Host_Error
	add	esp, 8
$LN28@CL_WritePa:

; 823  : 		}

	jmp	$LN2@CL_WritePa
$LN3@CL_WritePa:

; 824  : 
; 825  : 		// calculate a checksum over the move commands
; 826  : 		size = MSG_GetRealBytesWritten( &buf ) - key - 1;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _key$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 827  : 		buf.pData[key] = CRC32_BlockSequence( buf.pData + key + 1, size, cls.netchan.outgoing_sequence );

	mov	eax, DWORD PTR _cls+26880
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR _buf$[ebp+8]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	_CRC32_BlockSequence
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _buf$[ebp+8]
	add	edx, DWORD PTR _key$[ebp]
	mov	BYTE PTR [edx], al

; 828  : 
; 829  : 		// message we are constructing.
; 830  : 		i = cls.netchan.outgoing_sequence & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26880
	mov	DWORD PTR _i$[ebp], eax

; 831  : 	
; 832  : 		// determine if we need to ask for a new set of delta's.
; 833  : 		if( cl.validsequence && (cls.state == ca_active) && !( cls.demorecording && cls.demowaiting ))

	cmp	DWORD PTR _cl+4, 0
	je	SHORT $LN29@CL_WritePa
	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN29@CL_WritePa
	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN31@CL_WritePa
	cmp	DWORD PTR _cls+300832, 0
	jne	SHORT $LN29@CL_WritePa
$LN31@CL_WritePa:

; 834  : 		{
; 835  : 			cl.delta_sequence = cl.validsequence;

	mov	eax, DWORD PTR _cl+4
	mov	DWORD PTR _cl+28, eax

; 836  : 
; 837  : 			MSG_BeginClientCmd( &buf, clc_delta );

	push	0
	push	0
	push	4
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 838  : 			MSG_WriteByte( &buf, cl.validsequence & 0xFF );

	mov	eax, DWORD PTR _cl+4
	and	eax, 255				; 000000ffH
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 839  : 		}

	jmp	SHORT $LN30@CL_WritePa
$LN29@CL_WritePa:

; 840  : 		else
; 841  : 		{
; 842  : 			// request delta compression of entities
; 843  : 			cl.delta_sequence = -1;

	mov	DWORD PTR _cl+28, -1
$LN30@CL_WritePa:

; 844  : 		}
; 845  : 
; 846  : 		if( MSG_CheckOverflow( &buf ))

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN32@CL_WritePa

; 847  : 			Host_Error( "CL_WritePacket: overflowed command buffer (%i bytes)\n", MAX_CMD_BUFFER );

	push	8000					; 00001f40H
	push	OFFSET ??_C@_0DG@JCLEFCHC@CL_WritePacket?3?5overflowed?5comm@
	call	_Host_Error
	add	esp, 8
$LN32@CL_WritePa:

; 848  : 
; 849  : 		// remember outgoing command that we are sending
; 850  : 		cls.lastoutgoingcommand = cls.netchan.outgoing_sequence;

	mov	eax, DWORD PTR _cls+26880
	mov	DWORD PTR _cls+290592, eax

; 851  : 
; 852  : 		// update size counter for netgraph
; 853  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].sendsize = MSG_GetNumBytesWritten( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	ecx, DWORD PTR _cls+26880
	imul	edx, ecx, 88
	mov	DWORD PTR _cl[edx+1539756], eax

; 854  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].heldback = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26880
	imul	ecx, eax, 88
	mov	DWORD PTR _cl[ecx+1539752], 0

; 855  : 
; 856  : 		// composite the rest of the datagram..
; 857  : 		if( MSG_GetNumBitsWritten( &cls.datagram ) <= MSG_GetNumBitsLeft( &buf ))

	push	OFFSET _cls+10392
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	mov	esi, eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	esi, eax
	jg	SHORT $LN33@CL_WritePa

; 858  : 			MSG_WriteBits( &buf, MSG_GetData( &cls.datagram ), MSG_GetNumBitsWritten( &cls.datagram ));

	push	OFFSET _cls+10392
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+10392
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH
$LN33@CL_WritePa:

; 859  : 		MSG_Clear( &cls.datagram );

	push	OFFSET _cls+10392
	call	_MSG_Clear
	add	esp, 4

; 860  : 
; 861  : 		// deliver the message (or update reliable)
; 862  : 		Netchan_TransmitBits( &cls.netchan, MSG_GetNumBitsWritten( &buf ), MSG_GetData( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH

; 863  : 	}

	jmp	SHORT $LN22@CL_WritePa
$LN21@CL_WritePa:

; 864  : 	else
; 865  : 	{
; 866  : 		// mark command as held back so we'll send it next time
; 867  : 		cl.commands[cls.netchan.outgoing_sequence & CL_UPDATE_MASK].heldback = true;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26880
	imul	ecx, eax, 88
	mov	DWORD PTR _cl[ecx+1539752], 1

; 868  : 
; 869  : 		// increment sequence number so we can detect that we've held back packets.
; 870  : 		cls.netchan.outgoing_sequence++;

	mov	eax, DWORD PTR _cls+26880
	add	eax, 1
	mov	DWORD PTR _cls+26880, eax
$LN22@CL_WritePa:

; 871  : 	}
; 872  : 
; 873  : 	if( cls.demorecording && numbackup > 0 )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN34@CL_WritePa
	cmp	DWORD PTR _numbackup$[ebp], 0
	jle	SHORT $LN34@CL_WritePa

; 874  : 	{
; 875  : 		// Back up one because we've incremented outgoing_sequence each frame by 1 unit
; 876  : 		cmdnumber = ( cls.netchan.outgoing_sequence - 1 ) & CL_UPDATE_MASK;

	mov	eax, DWORD PTR _cls+26880
	sub	eax, 1
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	mov	DWORD PTR _cmdnumber$[ebp], eax

; 877  : 		CL_WriteDemoUserCmd( cmdnumber );

	mov	eax, DWORD PTR _cmdnumber$[ebp]
	push	eax
	call	_CL_WriteDemoUserCmd
	add	esp, 4
$LN34@CL_WritePa:

; 878  : 	}
; 879  : 
; 880  : 	// update download/upload slider.
; 881  : 	Netchan_UpdateProgress( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_UpdateProgress
	add	esp, 4
$LN1@CL_WritePa:

; 882  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WritePacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_CreateCmd
_TEXT	SEGMENT
tv87 = -172						; size = 8
tv86 = -164						; size = 8
tv142 = -160						; size = 4
_ms$ = -92						; size = 4
_i$ = -88						; size = 4
_input_override$ = -84					; size = 4
_active$ = -80						; size = 4
_angles$ = -76						; size = 12
_pcmd$ = -64						; size = 4
_cmd$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_CL_CreateCmd PROC					; COMDAT

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 616  : 	usercmd_t		cmd;
; 617  : 	runcmd_t		*pcmd;
; 618  : 	vec3_t		angles;
; 619  : 	qboolean		active;
; 620  : 	int		input_override;
; 621  : 	int		i, ms;
; 622  : 
; 623  : 	if( cls.state < ca_connected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN3@CL_CreateC
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN2@CL_CreateC
$LN3@CL_CreateC:

; 624  : 		return;

	jmp	$LN1@CL_CreateC
$LN2@CL_CreateC:

; 625  : 
; 626  : 	// store viewangles in case it's will be freeze
; 627  : 	VectorCopy( cl.viewangles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212784]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212784]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212784]
	mov	DWORD PTR _angles$[ebp+eax], ecx

; 628  : 	ms = bound( 1, host.frametime * 1000, 255 );

	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN14@CL_CreateC
	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN12@CL_CreateC
	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR tv86[ebp], xmm0
	jmp	SHORT $LN13@CL_CreateC
$LN12@CL_CreateC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv86[ebp], xmm0
$LN13@CL_CreateC:
	movsd	xmm0, QWORD PTR tv86[ebp]
	movsd	QWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN15@CL_CreateC
$LN14@CL_CreateC:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv87[ebp], xmm0
$LN15@CL_CreateC:
	cvttsd2si eax, QWORD PTR tv87[ebp]
	mov	DWORD PTR _ms$[ebp], eax

; 629  : 	memset( &cmd, 0, sizeof( cmd ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 630  : 	input_override = 0;

	mov	DWORD PTR _input_override$[ebp], 0

; 631  : 
; 632  : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 633  : 	CL_PushPMStates();

	call	_CL_PushPMStates

; 634  : 	CL_SetSolidPlayers( cl.playernum );

	mov	eax, DWORD PTR _cl+2213000
	push	eax
	call	_CL_SetSolidPlayers
	add	esp, 4

; 635  : 
; 636  : 	// message we are constructing.
; 637  : 	i = cls.netchan.outgoing_sequence & CL_UPDATE_MASK;   

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26880
	mov	DWORD PTR _i$[ebp], eax

; 638  : 	pcmd = &cl.commands[i];

	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, OFFSET _cl+1539672
	mov	DWORD PTR _pcmd$[ebp], eax

; 639  : 	pcmd->processedfuncs = false;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+76], 0

; 640  : 
; 641  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN4@CL_CreateC

; 642  : 	{
; 643  : 		pcmd->senttime = host.realtime;      

	mov	eax, DWORD PTR _pcmd$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax], xmm0

; 644  : 		memset( &pcmd->cmd, 0, sizeof( pcmd->cmd ));

	push	56					; 00000038H
	push	0
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 645  : 		pcmd->receivedtime = -1.0;

	mov	eax, DWORD PTR _pcmd$[ebp]
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR [eax+8], xmm0

; 646  : 		pcmd->heldback = false;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+80], 0

; 647  : 		pcmd->sendsize = 0;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+84], 0
$LN4@CL_CreateC:

; 648  : 	}
; 649  : 
; 650  : 	active = (( cls.signon == SIGNONS ) && !cl.paused && !cls.demoplayback );

	cmp	DWORD PTR _cls+64, 2
	jne	SHORT $LN16@CL_CreateC
	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN16@CL_CreateC
	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN16@CL_CreateC
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN17@CL_CreateC
$LN16@CL_CreateC:
	mov	DWORD PTR tv142[ebp], 0
$LN17@CL_CreateC:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR _active$[ebp], eax

; 651  : 	clgame.dllFuncs.CL_CreateMove( host.frametime, &pcmd->cmd, active );

	mov	eax, DWORD PTR _active$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcmd$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	cvtsd2ss xmm0, QWORD PTR _host+1448
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+60
	add	esp, 12					; 0000000cH

; 652  : 
; 653  : 	CL_PopPMStates();

	call	_CL_PopPMStates

; 654  : 
; 655  : 	if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN5@CL_CreateC

; 656  : 	{
; 657  : 		CL_ComputeClientInterpolationAmount( &pcmd->cmd );

	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_CL_ComputeClientInterpolationAmount
	add	esp, 4

; 658  : 		pcmd->cmd.lightlevel = cl.local.light_level;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	cl, BYTE PTR _cl+2212732
	mov	BYTE PTR [eax+48], cl

; 659  : 		pcmd->cmd.msec = ms;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	cl, BYTE PTR _ms$[ebp]
	mov	BYTE PTR [eax+22], cl
$LN5@CL_CreateC:

; 660  : 	}
; 661  : 
; 662  : 	input_override |= CL_ProcessOverviewCmds( &pcmd->cmd );

	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_CL_ProcessOverviewCmds
	add	esp, 4
	or	eax, DWORD PTR _input_override$[ebp]
	mov	DWORD PTR _input_override$[ebp], eax

; 663  : 	input_override |= CL_ProcessShowTexturesCmds( &pcmd->cmd );

	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_CL_ProcessShowTexturesCmds
	add	esp, 4
	or	eax, DWORD PTR _input_override$[ebp]
	mov	DWORD PTR _input_override$[ebp], eax

; 664  : 
; 665  : 	if(( cl.background && !cls.demoplayback ) || input_override || cls.changelevel )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN8@CL_CreateC
	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN7@CL_CreateC
$LN8@CL_CreateC:
	cmp	DWORD PTR _input_override$[ebp], 0
	jne	SHORT $LN7@CL_CreateC
	cmp	DWORD PTR _cls+8, 0
	je	$LN9@CL_CreateC
$LN7@CL_CreateC:

; 666  : 	{
; 667  : 		VectorCopy( angles, pcmd->cmd.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pcmd$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+24], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pcmd$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+24], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pcmd$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+24], eax

; 668  : 		VectorCopy( angles, cl.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR _cl[eax+2212784], ecx

; 669  : 		if( !cl.background ) pcmd->cmd.msec = 0;

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN9@CL_CreateC
	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	BYTE PTR [eax+22], 0
$LN9@CL_CreateC:

; 670  : 	}
; 671  : 
; 672  : 	// demo always have commands so don't overwrite them
; 673  : 	if( !cls.demoplayback ) cl.cmd = &pcmd->cmd;

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN10@CL_CreateC
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _cl+2212776, eax
$LN10@CL_CreateC:

; 674  : 
; 675  : 	// predict all unacknowledged movements
; 676  : 	CL_PredictMovement( false );

	push	0
	call	_CL_PredictMovement
	add	esp, 4
$LN1@CL_CreateC:

; 677  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CreateCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_UpdateClientData
_TEXT	SEGMENT
_cdat$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_CL_UpdateClientData PROC				; COMDAT

; 588  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 589  : 	client_data_t	cdat;
; 590  : 
; 591  : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN2@CL_UpdateC

; 592  : 		return;

	jmp	$LN3@CL_UpdateC
$LN2@CL_UpdateC:

; 593  : 
; 594  : 	memset( &cdat, 0, sizeof( cdat ) );

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _cdat$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 595  : 
; 596  : 	VectorCopy( cl.viewangles, cdat.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212784]
	mov	DWORD PTR _cdat$[ebp+eax+12], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212784]
	mov	DWORD PTR _cdat$[ebp+eax+12], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212784]
	mov	DWORD PTR _cdat$[ebp+eax+12], ecx

; 597  : 	VectorCopy( clgame.entities[cl.viewentity].origin, cdat.origin );

	imul	eax, DWORD PTR _cl+2212780, 3336
	add	eax, DWORD PTR _clgame+996
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx+3224]
	mov	DWORD PTR _cdat$[ebp+ecx], edx
	imul	eax, DWORD PTR _cl+2212780, 3336
	add	eax, DWORD PTR _clgame+996
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx+3224]
	mov	DWORD PTR _cdat$[ebp+edx], eax
	imul	ecx, DWORD PTR _cl+2212780, 3336
	add	ecx, DWORD PTR _clgame+996
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _cdat$[ebp+eax], ecx

; 598  : 	cdat.iWeaponBits = cl.local.weapons;

	mov	eax, DWORD PTR _cl+2212752
	mov	DWORD PTR _cdat$[ebp+24], eax

; 599  : 	cdat.fov = cl.local.scr_fov;

	movss	xmm0, DWORD PTR _cl+2212760
	movss	DWORD PTR _cdat$[ebp+28], xmm0

; 600  : 
; 601  : 	if( clgame.dllFuncs.pfnUpdateClientData( &cdat, cl.time ))

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _cdat$[ebp]
	push	eax
	call	DWORD PTR _clgame+20
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@CL_UpdateC

; 602  : 	{
; 603  : 		// grab changes if successful
; 604  : 		VectorCopy( cdat.viewangles, cl.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cdat$[ebp+ecx+12]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cdat$[ebp+edx+12]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cdat$[ebp+edx+12]
	mov	DWORD PTR _cl[eax+2212784], ecx

; 605  : 		cl.local.scr_fov = cdat.fov;

	movss	xmm0, DWORD PTR _cdat$[ebp+28]
	movss	DWORD PTR _cl+2212760, xmm0
$LN3@CL_UpdateC:

; 606  : 	}
; 607  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ProcessOverviewCmds
_TEXT	SEGMENT
tv66 = -88						; size = 4
_step2$ = -20						; size = 4
_step$ = -16						; size = 4
_size$ = -12						; size = 4
_sign$ = -8						; size = 4
_ov$ = -4						; size = 4
_cmd$ = 8						; size = 4
_CL_ProcessOverviewCmds PROC				; COMDAT

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 537  : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+217612

; 538  : 	int		sign = 1;

	mov	DWORD PTR _sign$[ebp], 1

; 539  : 	float		size = world.size[!ov->rotated] / world.size[ov->rotated];

	mov	eax, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN27@CL_Process
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN28@CL_Process
$LN27@CL_Process:
	mov	DWORD PTR tv66[ebp], 0
$LN28@CL_Process:
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR tv66[ebp]
	movss	xmm0, DWORD PTR _world[eax*4+2620]
	divss	xmm0, DWORD PTR _world[edx*4+2620]
	movss	DWORD PTR _size$[ebp], xmm0

; 540  : 	float		step = (2.0f / size) * host.realframetime;

	movss	xmm0, DWORD PTR __real@40000000
	divss	xmm0, DWORD PTR _size$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR _host+1456
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _step$[ebp], xmm0

; 541  : 	float		step2 = step * 100.0f * (2.0f / ov->flZoom);

	movss	xmm0, DWORD PTR _step$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR __real@40000000
	divss	xmm1, DWORD PTR [eax+40]
	mulss	xmm0, xmm1
	movss	DWORD PTR _step2$[ebp], xmm0

; 542  : 
; 543  : 	if( !CL_IsDevOverviewMode() || gl_showtextures->value )

	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN3@CL_Process
	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 544  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Process
$LN2@CL_Process:

; 545  : 
; 546  : 	if( ov->flZoom < 0.0f ) sign = -1;

	mov	eax, DWORD PTR _ov$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+40]
	jbe	SHORT $LN4@CL_Process
	mov	DWORD PTR _sign$[ebp], -1
$LN4@CL_Process:

; 547  : 
; 548  : 	if( cmd->upmove > 0.0f ) ov->zNear += step;

	mov	eax, DWORD PTR _cmd$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+36], xmm0
	jmp	SHORT $LN7@CL_Process
$LN5@CL_Process:

; 549  : 	else if( cmd->upmove < 0.0f ) ov->zNear -= step;

	mov	eax, DWORD PTR _cmd$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+24]
	jbe	SHORT $LN7@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+36]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+36], xmm0
$LN7@CL_Process:

; 550  : 
; 551  : 	if( cmd->buttons & IN_JUMP ) ov->zFar += step;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 2
	je	SHORT $LN8@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	jmp	SHORT $LN10@CL_Process
$LN8@CL_Process:

; 552  : 	else if( cmd->buttons & IN_DUCK ) ov->zFar -= step;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4
	je	SHORT $LN10@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
$LN10@CL_Process:

; 553  : 
; 554  : 	if( cmd->buttons & IN_FORWARD ) ov->origin[ov->rotated] -= sign * step2;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 8
	je	SHORT $LN11@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx*4]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm1
	jmp	SHORT $LN13@CL_Process
$LN11@CL_Process:

; 555  : 	else if( cmd->buttons & IN_BACK ) ov->origin[ov->rotated] += sign * step2;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 16					; 00000010H
	je	SHORT $LN13@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm0
$LN13@CL_Process:

; 556  : 
; 557  : 	if( ov->rotated )

	mov	eax, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN14@CL_Process

; 558  : 	{
; 559  : 		if( cmd->buttons & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 1280				; 00000500H
	je	SHORT $LN16@CL_Process

; 560  : 			ov->origin[0] -= sign * step2;

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx], xmm1
	jmp	SHORT $LN18@CL_Process
$LN16@CL_Process:

; 561  : 		else if( cmd->buttons & ( IN_LEFT|IN_MOVELEFT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 640				; 00000280H
	je	SHORT $LN18@CL_Process

; 562  : 			ov->origin[0] += sign * step2;

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
$LN18@CL_Process:

; 563  : 	}

	jmp	SHORT $LN21@CL_Process
$LN14@CL_Process:

; 564  : 	else
; 565  : 	{
; 566  : 		if( cmd->buttons & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 1280				; 00000500H
	je	SHORT $LN19@CL_Process

; 567  : 			ov->origin[1] += sign * step2;

	mov	eax, 4
	shl	eax, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	jmp	SHORT $LN21@CL_Process
$LN19@CL_Process:

; 568  : 		else if( cmd->buttons & ( IN_LEFT|IN_MOVELEFT ))

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 640				; 00000280H
	je	SHORT $LN21@CL_Process

; 569  : 			ov->origin[1] -= sign * step2;

	mov	eax, 4
	shl	eax, 0
	cvtsi2ss xmm0, DWORD PTR _sign$[ebp]
	mulss	xmm0, DWORD PTR _step2$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx], xmm1
$LN21@CL_Process:

; 570  : 	}
; 571  : 
; 572  : 	if( cmd->buttons & IN_ATTACK ) ov->flZoom += step;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 1
	je	SHORT $LN22@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	addss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+40], xmm0
	jmp	SHORT $LN24@CL_Process
$LN22@CL_Process:

; 573  : 	else if( cmd->buttons & IN_ATTACK2 ) ov->flZoom -= step;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN24@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	subss	xmm0, DWORD PTR _step$[ebp]
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+40], xmm0
$LN24@CL_Process:

; 574  : 
; 575  : 	if( ov->flZoom == 0.0f ) ov->flZoom = 0.0001f; // to prevent disivion by zero

	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR [eax+40]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@CL_Process
	mov	eax, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR __real@38d1b717
	movss	DWORD PTR [eax+40], xmm0
$LN25@CL_Process:

; 576  : 
; 577  : 	return true;

	mov	eax, 1
$LN1@CL_Process:

; 578  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessOverviewCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ProcessShowTexturesCmds
_TEXT	SEGMENT
tv90 = -80						; size = 4
_released$ = -12					; size = 4
_pressed$ = -8						; size = 4
_changed$ = -4						; size = 4
_cmd$ = 8						; size = 4
_CL_ProcessShowTexturesCmds PROC			; COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 508  : 	static int	oldbuttons;
; 509  : 	int		changed;
; 510  : 	int		pressed, released;
; 511  : 
; 512  : 	if( !gl_showtextures->value || CL_IsDevOverviewMode( ))

	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_Process
	call	_CL_IsDevOverviewMode
	test	eax, eax
	je	SHORT $LN2@CL_Process
$LN3@CL_Process:

; 513  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Process
$LN2@CL_Process:

; 514  : 
; 515  : 	changed = (oldbuttons ^ cmd->buttons);

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR ?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9
	xor	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _changed$[ebp], ecx

; 516  : 	pressed =  changed & cmd->buttons;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _changed$[ebp]
	and	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _pressed$[ebp], ecx

; 517  : 	released = changed & (~cmd->buttons);

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	not	ecx
	and	ecx, DWORD PTR _changed$[ebp]
	mov	DWORD PTR _released$[ebp], ecx

; 518  : 
; 519  : 	if( released & ( IN_RIGHT|IN_MOVERIGHT ))

	mov	eax, DWORD PTR _released$[ebp]
	and	eax, 1280				; 00000500H
	je	SHORT $LN4@CL_Process

; 520  : 		Cvar_SetValue( "r_showtextures", gl_showtextures->value + 1 );

	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	addss	xmm0, DWORD PTR __real@3f800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0P@MJMKNHCG@r_showtextures@
	call	_Cvar_SetValue
	add	esp, 8
$LN4@CL_Process:

; 521  : 	if( released & ( IN_LEFT|IN_MOVELEFT ))

	mov	eax, DWORD PTR _released$[ebp]
	and	eax, 640				; 00000280H
	je	SHORT $LN5@CL_Process

; 522  : 		Cvar_SetValue( "r_showtextures", max( 1, gl_showtextures->value - 1 ));

	mov	eax, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@CL_Process
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN8@CL_Process
$LN7@CL_Process:
	mov	ecx, DWORD PTR _gl_showtextures
	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv90[ebp], xmm0
$LN8@CL_Process:
	push	ecx
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0P@MJMKNHCG@r_showtextures@
	call	_Cvar_SetValue
	add	esp, 8
$LN5@CL_Process:

; 523  : 	oldbuttons = cmd->buttons;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR ?oldbuttons@?1??CL_ProcessShowTexturesCmds@@9@9, ecx

; 524  : 
; 525  : 	return true;

	mov	eax, 1
$LN1@CL_Process:

; 526  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessShowTexturesCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ApplyAddAngle
_TEXT	SEGMENT
_frac$ = -20						; size = 4
_amove$ = -16						; size = 4
_addangletotal$ = -12					; size = 4
_next$ = -8						; size = 4
_prev$ = -4						; size = 4
_CL_ApplyAddAngle PROC					; COMDAT

; 471  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 472  : 	pred_viewangle_t	*prev = NULL, *next = NULL;

	mov	DWORD PTR _prev$[ebp], 0
	mov	DWORD PTR _next$[ebp], 0

; 473  : 	float		addangletotal = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _addangletotal$[ebp], xmm0

; 474  : 	float		amove, frac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 475  : 
; 476  : 	CL_FindInterpolatedAddAngle( cl.time, &frac, &prev, &next );

	lea	eax, DWORD PTR _next$[ebp]
	push	eax
	lea	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	lea	edx, DWORD PTR _frac$[ebp]
	push	edx
	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_CL_FindInterpolatedAddAngle
	add	esp, 16					; 00000010H

; 477  : 
; 478  : 	if( prev && next )

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN2@CL_ApplyAd
	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN2@CL_ApplyAd

; 479  : 		addangletotal = prev->total + frac * ( next->total - prev->total );

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _prev$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	edx, DWORD PTR _prev$[ebp]
	addss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR _addangletotal$[ebp], xmm0
	jmp	SHORT $LN3@CL_ApplyAd
$LN2@CL_ApplyAd:

; 480  : 	else addangletotal = cl.prevaddangletotal;

	movss	xmm0, DWORD PTR _cl+2212972
	movss	DWORD PTR _addangletotal$[ebp], xmm0
$LN3@CL_ApplyAd:

; 481  : 
; 482  : 	amove = addangletotal - cl.prevaddangletotal;

	movss	xmm0, DWORD PTR _addangletotal$[ebp]
	subss	xmm0, DWORD PTR _cl+2212972
	movss	DWORD PTR _amove$[ebp], xmm0

; 483  : 
; 484  : 	// update input angles
; 485  : 	cl.viewangles[YAW] += amove;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+2212784]
	addss	xmm0, DWORD PTR _amove$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cl[ecx+2212784], xmm0

; 486  : 
; 487  : 	// remember last total
; 488  : 	cl.prevaddangletotal = addangletotal;

	movss	xmm0, DWORD PTR _addangletotal$[ebp]
	movss	DWORD PTR _cl+2212972, xmm0

; 489  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ApplyAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_FindInterpolatedAddAngle
_TEXT	SEGMENT
tv134 = -92						; size = 4
tv133 = -88						; size = 4
_at$ = -20						; size = 4
_imod$ = -16						; size = 4
_i1$ = -12						; size = 4
_i0$ = -8						; size = 4
_i$ = -4						; size = 4
_t$ = 8							; size = 4
_frac$ = 12						; size = 4
_prev$ = 16						; size = 4
_next$ = 20						; size = 4
_CL_FindInterpolatedAddAngle PROC			; COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 430  : 	int	i, i0, i1, imod;
; 431  : 	float	at;
; 432  : 
; 433  : 	imod = cl.angle_position - 1;

	mov	eax, DWORD PTR _cl+2212964
	sub	eax, 1
	mov	DWORD PTR _imod$[ebp], eax

; 434  : 	i0 = (imod + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], eax

; 435  : 	i1 = (imod + 0) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], eax

; 436  : 
; 437  : 	if( cl.predicted_angle[i0].starttime >= t )

	mov	eax, DWORD PTR _i0$[ebp]
	movss	xmm0, DWORD PTR _cl[eax*8+2212836]
	comiss	xmm0, DWORD PTR _t$[ebp]
	jb	SHORT $LN3@CL_FindInt

; 438  : 	{
; 439  : 		for( i = 0; i < ANGLE_BACKUP - 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindInt
$LN2@CL_FindInt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FindInt:
	cmp	DWORD PTR _i$[ebp], 14			; 0000000eH
	jge	SHORT $LN3@CL_FindInt

; 440  : 		{
; 441  : 			at = cl.predicted_angle[imod & ANGLE_MASK].starttime;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	movss	xmm0, DWORD PTR _cl[eax*8+2212836]
	movss	DWORD PTR _at$[ebp], xmm0

; 442  : 			if( at == 0.0f ) break;

	movss	xmm0, DWORD PTR _at$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_FindInt
	jmp	SHORT $LN3@CL_FindInt
$LN6@CL_FindInt:

; 443  : 
; 444  : 			if( at < t )

	movss	xmm0, DWORD PTR _t$[ebp]
	comiss	xmm0, DWORD PTR _at$[ebp]
	jbe	SHORT $LN7@CL_FindInt

; 445  : 			{
; 446  : 				i0 = (imod + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], eax

; 447  : 				i1 = (imod + 0) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], eax

; 448  : 				break;

	jmp	SHORT $LN3@CL_FindInt
$LN7@CL_FindInt:

; 449  : 			}
; 450  : 			imod--;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, 1
	mov	DWORD PTR _imod$[ebp], eax

; 451  : 		}

	jmp	SHORT $LN2@CL_FindInt
$LN3@CL_FindInt:

; 452  : 	}
; 453  : 
; 454  : 	*next = &cl.predicted_angle[i0];

	mov	eax, DWORD PTR _i0$[ebp]
	lea	ecx, DWORD PTR _cl[eax*8+2212836]
	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [edx], ecx

; 455  : 	*prev = &cl.predicted_angle[i1];

	mov	eax, DWORD PTR _i1$[ebp]
	lea	ecx, DWORD PTR _cl[eax*8+2212836]
	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [edx], ecx

; 456  : 
; 457  : 	// avoid division by zero (probably this should never happens)
; 458  : 	if((*prev)->starttime == (*next)->starttime )

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, DWORD PTR [eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_FindInt

; 459  : 	{
; 460  : 		*prev = *next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 461  : 		*frac = 0.0f;

	mov	eax, DWORD PTR _frac$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 462  : 		return;

	jmp	$LN1@CL_FindInt
$LN8@CL_FindInt:

; 463  : 	}
; 464  : 
; 465  : 	// time spans the two entries
; 466  : 	*frac = ( t - (*prev)->starttime ) / ((*next)->starttime - (*prev)->starttime );

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, DWORD PTR [edx]
	divss	xmm0, xmm1
	mov	eax, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [eax], xmm0

; 467  : 	*frac = bound( 0.0f, *frac, 1.0f );

	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@CL_FindInt
	mov	ecx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN10@CL_FindInt
	mov	edx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN11@CL_FindInt
$LN10@CL_FindInt:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv133[ebp], xmm0
$LN11@CL_FindInt:
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN13@CL_FindInt
$LN12@CL_FindInt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv134[ebp], xmm0
$LN13@CL_FindInt:
	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR [eax], xmm0
$LN1@CL_FindInt:

; 468  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindInterpolatedAddAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ComputePacketLoss
_TEXT	SEGMENT
_lost$ = -20						; size = 4
_count$ = -16						; size = 4
_frame$ = -12						; size = 4
_frm$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_ComputePacketLoss PROC				; COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 385  : 	int	i, frm;
; 386  : 	frame_t	*frame;
; 387  : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 388  : 	int	lost = 0;

	mov	DWORD PTR _lost$[ebp], 0

; 389  : 
; 390  : 	if( host.realtime < cls.packet_loss_recalc_time )

	movsd	xmm0, QWORD PTR _cls+290576
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN5@CL_Compute

; 391  : 		return;

	jmp	$LN8@CL_Compute
$LN5@CL_Compute:

; 392  : 
; 393  : 	// recalc every second
; 394  : 	cls.packet_loss_recalc_time = host.realtime + 1.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cls+290576, xmm0

; 395  : 
; 396  : 	// compuate packet loss
; 397  : 	for( i = cls.netchan.incoming_sequence - CL_UPDATE_BACKUP + 1; i <= cls.netchan.incoming_sequence; i++ )

	mov	eax, DWORD PTR _cls+26864
	sub	eax, DWORD PTR _CL_UPDATE_BACKUP
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@CL_Compute
$LN2@CL_Compute:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_Compute:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cls+26864
	jg	SHORT $LN3@CL_Compute

; 398  : 	{
; 399  : 		frm = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _frm$[ebp], eax

; 400  : 		frame = &cl.frames[frm & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _frm$[ebp]
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], ecx

; 401  : 
; 402  : 		if( frame->receivedtime == -1.0 )

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_Compute

; 403  : 			lost++;

	mov	eax, DWORD PTR _lost$[ebp]
	add	eax, 1
	mov	DWORD PTR _lost$[ebp], eax
$LN6@CL_Compute:

; 404  : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 405  : 	}

	jmp	SHORT $LN2@CL_Compute
$LN3@CL_Compute:

; 406  : 
; 407  : 	if( count <= 0 ) cls.packet_loss = 0.0f;

	cmp	DWORD PTR _count$[ebp], 0
	jg	SHORT $LN7@CL_Compute
	xorps	xmm0, xmm0
	movss	DWORD PTR _cls+290572, xmm0
	jmp	SHORT $LN8@CL_Compute
$LN7@CL_Compute:

; 408  : 	else cls.packet_loss = ( 100.0f * (float)lost ) / (float)count;

	cvtsi2ss xmm0, DWORD PTR _lost$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _cls+290572, xmm0
$LN8@CL_Compute:

; 409  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputePacketLoss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ComputeClientInterpolationAmount
_TEXT	SEGMENT
tv132 = -88						; size = 4
tv131 = -84						; size = 4
tv80 = -84						; size = 4
_forced$ = -16						; size = 4
_interpolation_msec$ = -12				; size = 4
_max_interp$ = -8					; size = 4
_min_interp$ = -4					; size = 4
_cmd$ = 8						; size = 4
_CL_ComputeClientInterpolationAmount PROC		; COMDAT

; 333  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 334  : 	int	min_interp = MIN_EX_INTERP;

	mov	DWORD PTR _min_interp$[ebp], 50		; 00000032H

; 335  : 	int	max_interp = MAX_EX_INTERP;

	mov	DWORD PTR _max_interp$[ebp], 100	; 00000064H

; 336  : 	int	interpolation_msec;
; 337  : 	qboolean	forced = false;

	mov	DWORD PTR _forced$[ebp], 0

; 338  : 
; 339  : 	if( cl_updaterate->value < MIN_UPDATERATE )

	mov	eax, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN2@CL_Compute

; 340  : 	{
; 341  : 		Con_Printf( "cl_updaterate minimum is %f, resetting to default (20)\n", MIN_UPDATERATE );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0DI@MMJIGOKI@cl_updaterate?5minimum?5is?5?$CFf?0?5re@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 342  : 		Cvar_Reset( "cl_updaterate" );

	push	OFFSET ??_C@_0O@GLEIJHMA@cl_updaterate@
	call	_Cvar_Reset
	add	esp, 4
$LN2@CL_Compute:

; 343  : 	}
; 344  : 
; 345  : 	if( cl_updaterate->value > MAX_UPDATERATE )

	mov	eax, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@42cc0000
	jbe	SHORT $LN3@CL_Compute

; 346  : 	{
; 347  : 		Con_Printf( "cl_updaterate clamped at maximum (%f)\n", MAX_UPDATERATE );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4059800000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CH@GCBKIJKK@cl_updaterate?5clamped?5at?5maximu@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 348  : 		Cvar_SetValue( "cl_updaterate", MAX_UPDATERATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@42cc0000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@GLEIJHMA@cl_updaterate@
	call	_Cvar_SetValue
	add	esp, 8
$LN3@CL_Compute:

; 349  : 	}
; 350  : 
; 351  : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN4@CL_Compute

; 352  : 		max_interp = 200;

	mov	DWORD PTR _max_interp$[ebp], 200	; 000000c8H
$LN4@CL_Compute:

; 353  : 
; 354  : 	min_interp = 1000.0f / cl_updaterate->value;

	mov	eax, DWORD PTR _cl_updaterate
	movss	xmm0, DWORD PTR __real@447a0000
	divss	xmm0, DWORD PTR [eax+12]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _min_interp$[ebp], ecx

; 355  : 	min_interp = Q_max( 1, min_interp );

	cmp	DWORD PTR _min_interp$[ebp], 1
	jge	SHORT $LN10@CL_Compute
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN11@CL_Compute
$LN10@CL_Compute:
	mov	eax, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN11@CL_Compute:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _min_interp$[ebp], ecx

; 356  : 	interpolation_msec = cl_interp->value * 1000.0f;

	mov	eax, DWORD PTR _cl_interp
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _interpolation_msec$[ebp], ecx

; 357  : 
; 358  : 	if(( interpolation_msec + 1 ) < min_interp )

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _min_interp$[ebp]
	jge	SHORT $LN5@CL_Compute

; 359  : 	{
; 360  : 		Con_Printf( "ex_interp forced up to %i msec\n", interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@NNLHIFJL@ex_interp?5forced?5up?5to?5?$CFi?5msec?6@
	call	_Con_Printf
	add	esp, 8

; 361  : 		interpolation_msec = min_interp;

	mov	eax, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], eax

; 362  : 		forced = true;

	mov	DWORD PTR _forced$[ebp], 1

; 363  : 	}

	jmp	SHORT $LN7@CL_Compute
$LN5@CL_Compute:

; 364  : 	else if(( interpolation_msec - 1 ) > max_interp )

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	sub	eax, 1
	cmp	eax, DWORD PTR _max_interp$[ebp]
	jle	SHORT $LN7@CL_Compute

; 365  : 	{
; 366  : 		Con_Printf( "ex_interp forced down to %i msec\n", interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@CGOAGALG@ex_interp?5forced?5down?5to?5?$CFi?5mse@
	call	_Con_Printf
	add	esp, 8

; 367  : 		interpolation_msec = max_interp;

	mov	eax, DWORD PTR _max_interp$[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], eax

; 368  : 		forced = true;

	mov	DWORD PTR _forced$[ebp], 1
$LN7@CL_Compute:

; 369  : 	}
; 370  : 
; 371  : 	if( forced ) Cvar_SetValue( "ex_interp", (float)interpolation_msec * 0.001f );

	cmp	DWORD PTR _forced$[ebp], 0
	je	SHORT $LN8@CL_Compute
	cvtsi2ss xmm0, DWORD PTR _interpolation_msec$[ebp]
	mulss	xmm0, DWORD PTR __real@3a83126f
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09LIPGDLPA@ex_interp@
	call	_Cvar_SetValue
	add	esp, 8
$LN8@CL_Compute:

; 372  : 	interpolation_msec = bound( min_interp, interpolation_msec, max_interp );	

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	cmp	eax, DWORD PTR _min_interp$[ebp]
	jl	SHORT $LN14@CL_Compute
	mov	ecx, DWORD PTR _interpolation_msec$[ebp]
	cmp	ecx, DWORD PTR _max_interp$[ebp]
	jge	SHORT $LN12@CL_Compute
	mov	edx, DWORD PTR _interpolation_msec$[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN13@CL_Compute
$LN12@CL_Compute:
	mov	eax, DWORD PTR _max_interp$[ebp]
	mov	DWORD PTR tv131[ebp], eax
$LN13@CL_Compute:
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN15@CL_Compute
$LN14@CL_Compute:
	mov	edx, DWORD PTR _min_interp$[ebp]
	mov	DWORD PTR tv132[ebp], edx
$LN15@CL_Compute:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR _interpolation_msec$[ebp], eax

; 373  : 
; 374  : 	cmd->lerp_msec = CL_DriftInterpolationAmount( interpolation_msec );

	mov	eax, DWORD PTR _interpolation_msec$[ebp]
	push	eax
	call	_CL_DriftInterpolationAmount
	add	esp, 4
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	WORD PTR [ecx], ax

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputeClientInterpolationAmount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_DriftInterpolationAmount
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv77 = -88						; size = 4
tv83 = -84						; size = 4
tv74 = -84						; size = 4
_msec$ = -16						; size = 4
_diff$ = -12						; size = 4
_maxmove$ = -8						; size = 4
_fgoal$ = -4						; size = 4
_goal$ = 8						; size = 4
_CL_DriftInterpolationAmount PROC			; COMDAT

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 306  : 	float	fgoal, maxmove, diff;
; 307  : 	int	msec;
; 308  : 
; 309  : 	fgoal = (float)goal / 1000.0f;

	cvtsi2ss xmm0, DWORD PTR _goal$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fgoal$[ebp], xmm0

; 310  : 
; 311  : 	if( fgoal != cl.local.interp_amount )

	movss	xmm0, DWORD PTR _fgoal$[ebp]
	ucomiss	xmm0, DWORD PTR _cl+2212628
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@CL_DriftIn

; 312  : 	{
; 313  : 		maxmove = host.frametime * 0.05;

	movsd	xmm0, QWORD PTR _host+1448
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxmove$[ebp], xmm0

; 314  : 		diff = fgoal - cl.local.interp_amount;

	movss	xmm0, DWORD PTR _fgoal$[ebp]
	subss	xmm0, DWORD PTR _cl+2212628
	movss	DWORD PTR _diff$[ebp], xmm0

; 315  : 		diff = bound( -maxmove, diff, maxmove );

	movss	xmm0, DWORD PTR _maxmove$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR _diff$[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN6@CL_DriftIn
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	comiss	xmm0, DWORD PTR _diff$[ebp]
	jbe	SHORT $LN4@CL_DriftIn
	movss	xmm0, DWORD PTR _diff$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN5@CL_DriftIn
$LN4@CL_DriftIn:
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	movss	DWORD PTR tv74[ebp], xmm0
$LN5@CL_DriftIn:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN7@CL_DriftIn
$LN6@CL_DriftIn:
	movss	xmm0, DWORD PTR _maxmove$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv77[ebp], xmm0
$LN7@CL_DriftIn:
	movss	xmm0, DWORD PTR tv77[ebp]
	movss	DWORD PTR _diff$[ebp], xmm0

; 316  : 		cl.local.interp_amount += diff;

	movss	xmm0, DWORD PTR _cl+2212628
	addss	xmm0, DWORD PTR _diff$[ebp]
	movss	DWORD PTR _cl+2212628, xmm0
$LN2@CL_DriftIn:

; 317  : 	}
; 318  : 
; 319  : 	msec = cl.local.interp_amount * 1000.0f;

	movss	xmm0, DWORD PTR _cl+2212628
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _msec$[ebp], eax

; 320  : 	msec = bound( 0, msec, 100 );

	cmp	DWORD PTR _msec$[ebp], 0
	jl	SHORT $LN10@CL_DriftIn
	cmp	DWORD PTR _msec$[ebp], 100		; 00000064H
	jge	SHORT $LN8@CL_DriftIn
	mov	eax, DWORD PTR _msec$[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@CL_DriftIn
$LN8@CL_DriftIn:
	mov	DWORD PTR tv83[ebp], 100		; 00000064H
$LN9@CL_DriftIn:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN11@CL_DriftIn
$LN10@CL_DriftIn:
	mov	DWORD PTR tv84[ebp], 0
$LN11@CL_DriftIn:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _msec$[ebp], edx

; 321  : 
; 322  : 	return msec;

	mov	eax, DWORD PTR _msec$[ebp]

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DriftInterpolationAmount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_LerpPoint
_TEXT	SEGMENT
_frac$ = -8						; size = 4
_f$ = -4						; size = 4
_CL_LerpPoint PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 251  : 	float	f, frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0

; 252  : 
; 253  : 	f = cl_serverframetime();

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	subsd	xmm0, QWORD PTR _cl[edx+32]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 254  : 	
; 255  : 	if( f == 0.0f || cls.timedemo )

	movss	xmm0, DWORD PTR _f$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_LerpPoi
	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN2@CL_LerpPoi
$LN3@CL_LerpPoi:

; 256  : 	{
; 257  : 		cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+2167640, xmm0

; 258  : 		return 1.0f;

	fld1
	jmp	$LN1@CL_LerpPoi
$LN2@CL_LerpPoi:

; 259  : 	}
; 260  : 
; 261  : 	if( f > 0.1f )

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN4@CL_LerpPoi

; 262  : 	{	
; 263  : 		// dropped packet, or start of demo
; 264  : 		cl.mtime[1] = cl.mtime[0] - 0.1f;

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	mov	edx, 8
	shl	edx, 0
	movsd	QWORD PTR _cl[edx+32], xmm0

; 265  : 		f = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _f$[ebp], xmm0
$LN4@CL_LerpPoi:

; 266  : 	}
; 267  : #if 1
; 268  : 	frac = (cl.time - cl.mtime[1]) / f;

	mov	eax, 8
	shl	eax, 0
	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl[eax+32]
	cvtss2sd xmm1, DWORD PTR _f$[ebp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 269  : 
; 270  : 	if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN5@CL_LerpPoi

; 271  : 	{
; 272  : 		if( frac < -0.01 )

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	xmm1, QWORD PTR __real@bf847ae147ae147b
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@CL_LerpPoi

; 273  : 			cl.time = cl.mtime[1];

	mov	eax, 8
	shl	eax, 0
	movsd	xmm0, QWORD PTR _cl[eax+32]
	movsd	QWORD PTR _cl+2167640, xmm0
$LN7@CL_LerpPoi:

; 274  : 		frac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 275  : 	}

	jmp	SHORT $LN8@CL_LerpPoi
$LN5@CL_LerpPoi:

; 276  : 	else if( frac > 1.0f )

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN8@CL_LerpPoi

; 277  : 	{
; 278  : 		if( frac > 1.01 )

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff028f5c28f5c29
	jbe	SHORT $LN9@CL_LerpPoi

; 279  : 			cl.time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR _cl+2167640, xmm0
$LN9@CL_LerpPoi:

; 280  : 		frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN8@CL_LerpPoi:

; 281  : 	}
; 282  : #else
; 283  : 	if( cl_interp->value > 0.001f )
; 284  : 	{
; 285  : 		// manual lerp value (goldsrc mode)
; 286  : 		frac = ( cl.time - cl.mtime[0] ) / cl_interp->value;
; 287  : 	}
; 288  : 	else if( f > 0.001f )
; 289  : 	{
; 290  : 		// automatic lerp (classic mode)
; 291  : 		frac = ( cl.time - cl.mtime[1] ) / f;
; 292  : 	}
; 293  : #endif
; 294  : 	return frac;

	fld	DWORD PTR _frac$[ebp]
$LN1@CL_LerpPoi:

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LerpPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_CheckClientState
_TEXT	SEGMENT
tv82 = -72						; size = 8
_CL_CheckClientState PROC				; COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 188  : 	// first update is the pre-final signon stage
; 189  : 	if(( cls.state == ca_connected || cls.state == ca_validate ) && ( cls.signon == SIGNONS ))

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN3@CL_CheckCl
	cmp	DWORD PTR _cls, 3
	jne	$LN4@CL_CheckCl
$LN3@CL_CheckCl:
	cmp	DWORD PTR _cls+64, 2
	jne	$LN4@CL_CheckCl

; 190  : 	{	
; 191  : 		cls.state = ca_active;

	mov	DWORD PTR _cls, 4

; 192  : 		cls.changelevel = false;		// changelevel is done

	mov	DWORD PTR _cls+8, 0

; 193  : 		cls.changedemo = false;		// changedemo is done

	mov	DWORD PTR _cls+12, 0

; 194  : 		cl.first_frame = true;		// first rendering frame

	mov	DWORD PTR _cl+68, 1

; 195  : 
; 196  : 		SCR_MakeLevelShot();		// make levelshot if needs

	call	_SCR_MakeLevelShot

; 197  : 		Cvar_SetValue( "scr_loading", 0.0f );	// reset progress bar	

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@DKOEGGOG@scr_loading@
	call	_Cvar_SetValue
	add	esp, 8

; 198  : 		Netchan_ReportFlow( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_ReportFlow
	add	esp, 4

; 199  : 
; 200  : 		Con_DPrintf( "client connected at %.2f sec\n", Sys_DoubleTime() - cls.timestart ); 

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv82[ebp]
	movsd	xmm0, QWORD PTR tv82[ebp]
	subsd	xmm0, QWORD PTR _cls+16
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BO@PBAMMEOO@client?5connected?5at?5?$CF?42f?5sec?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 201  : 		if(( cls.demoplayback || cls.disable_servercount != cl.servercount ) && cl.video_prepped )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN5@CL_CheckCl
	mov	eax, DWORD PTR _cls+28
	cmp	eax, DWORD PTR _cl
	je	SHORT $LN4@CL_CheckCl
$LN5@CL_CheckCl:
	cmp	DWORD PTR _cl+16, 0
	je	SHORT $LN4@CL_CheckCl

; 202  : 			SCR_EndLoadingPlaque(); // get rid of loading plaque

	call	_SCR_EndLoadingPlaque
$LN4@CL_CheckCl:

; 203  : 	}
; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckClientState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ClearState
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearState PROC					; COMDAT

; 1288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1289 : 	int	i;
; 1290 : 
; 1291 : 	CL_ClearResourceLists();

	call	_CL_ClearResourceLists

; 1292 : 
; 1293 : 	for( i = 0; i < MAX_CLIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearSt
$LN2@CL_ClearSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearSt:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@CL_ClearSt

; 1294 : 		COM_ClearCustomizationList( &cl.players[i].customdata, false );

	push	0
	imul	eax, DWORD PTR _i$[ebp], 584
	add	eax, OFFSET _cl+2185344
	push	eax
	call	_COM_ClearCustomizationList
	add	esp, 8
	jmp	SHORT $LN2@CL_ClearSt
$LN3@CL_ClearSt:

; 1295 : 
; 1296 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1297 : 	CL_ClearEffects ();

	call	_CL_ClearEffects

; 1298 : 	CL_FreeEdicts ();

	call	_CL_FreeEdicts

; 1299 : 
; 1300 : 	CL_ClearPhysEnts ();

	call	_CL_ClearPhysEnts

; 1301 : 	NetAPI_CancelAllRequests();

	call	_NetAPI_CancelAllRequests

; 1302 : 
; 1303 : 	// wipe the entire cl structure
; 1304 : 	memset( &cl, 0, sizeof( cl ));

	push	4579008					; 0045dec0H
	push	0
	push	OFFSET _cl
	call	_memset
	add	esp, 12					; 0000000cH

; 1305 : 	MSG_Clear( &cls.netchan.message );

	push	OFFSET _cls+26900
	call	_MSG_Clear
	add	esp, 4

; 1306 : 	memset( &clgame.fade, 0, sizeof( clgame.fade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _clgame+214928
	call	_memset
	add	esp, 12					; 0000000cH

; 1307 : 	memset( &clgame.shake, 0, sizeof( clgame.shake ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+214952
	call	_memset
	add	esp, 12					; 0000000cH

; 1308 : 	Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1309 : 	cl.maxclients = 1; // allow to drawing player in menu

	mov	DWORD PTR _cl+2213004, 1

; 1310 : 	cl.mtime[0] = cl.mtime[1] = 1.0f; // because level starts from 1.0f second

	mov	eax, 8
	shl	eax, 0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cl[eax+32], xmm0
	mov	ecx, 8
	imul	edx, ecx, 0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _cl[edx+32], xmm0

; 1311 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1312 : 
; 1313 : 	cl.resourcesneeded.pNext = cl.resourcesneeded.pPrev = &cl.resourcesneeded;

	mov	DWORD PTR _cl+3029684, OFFSET _cl+3029552
	mov	eax, DWORD PTR _cl+3029684
	mov	DWORD PTR _cl+3029680, eax

; 1314 : 	cl.resourcesonhand.pNext = cl.resourcesonhand.pPrev = &cl.resourcesonhand;

	mov	DWORD PTR _cl+3029548, OFFSET _cl+3029416
	mov	eax, DWORD PTR _cl+3029548
	mov	DWORD PTR _cl+3029544, eax

; 1315 : 
; 1316 : 	CL_CreateResourceList();

	call	_CL_CreateResourceList

; 1317 : 	CL_ClearSpriteTextures();	// now all hud sprites are invalid

	call	_CL_ClearSpriteTextures

; 1318 : 
; 1319 : 	cl.local.interp_amount = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _cl+2212628, xmm0

; 1320 : 	cl.local.scr_fov = 90.0f;

	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR _cl+2212760, xmm0

; 1321 : 
; 1322 : 	Cvar_SetValue( "scr_download", -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0N@CCFOLBKF@scr_download@
	call	_Cvar_SetValue
	add	esp, 8

; 1323 : 	Cvar_SetValue( "scr_loading", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@DKOEGGOG@scr_loading@
	call	_Cvar_SetValue
	add	esp, 8

; 1324 : 	host.allow_console = host.allow_console_init;

	mov	eax, DWORD PTR _host+34340
	mov	DWORD PTR _host+34336, eax

; 1325 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SignonReply
_TEXT	SEGMENT
tv66 = -68						; size = 4
_CL_SignonReply PROC					; COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 223  : 	// g-cont. my favorite message :-)
; 224  : 	Con_Reportf( "CL_SignonReply: %i\n", cls.signon );

	mov	eax, DWORD PTR _cls+64
	push	eax
	push	OFFSET ??_C@_0BE@HJOLPNGG@CL_SignonReply?3?5?$CFi?6@
	call	_Con_Reportf
	add	esp, 8

; 225  : 
; 226  : 	switch( cls.signon )

	mov	eax, DWORD PTR _cls+64
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@CL_SignonR
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN6@CL_SignonR
	jmp	SHORT $LN2@CL_SignonR
$LN4@CL_SignonR:

; 227  : 	{
; 228  : 	case 1:
; 229  : 		CL_ServerCommand( true, "begin" );

	push	OFFSET ??_C@_05EAFKHBAM@begin@
	push	1
	call	_CL_ServerCommand
	add	esp, 8

; 230  : 		if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN5@CL_SignonR

; 231  : 			Mem_PrintStats();

	call	_Mem_PrintStats
$LN5@CL_SignonR:

; 232  : 		break;

	jmp	SHORT $LN2@CL_SignonR
$LN6@CL_SignonR:

; 233  : 	case 2:
; 234  : 		if( cl.proxy_redirect && !cls.spectator )

	cmp	DWORD PTR _cl+72, 0
	je	SHORT $LN7@CL_SignonR
	cmp	DWORD PTR _cls+152, 0
	jne	SHORT $LN7@CL_SignonR

; 235  : 			CL_Disconnect();

	call	_CL_Disconnect
$LN7@CL_SignonR:

; 236  : 		cl.proxy_redirect = false;

	mov	DWORD PTR _cl+72, 0
$LN2@CL_SignonR:

; 237  : 		break;
; 238  : 	}
; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SignonReply ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsDevOverviewMode
_TEXT	SEGMENT
_CL_IsDevOverviewMode PROC				; COMDAT

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : 	if( dev_overview.value > 0.0f )

	movss	xmm0, DWORD PTR _dev_overview+12
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@CL_IsDevOv

; 170  : 	{
; 171  : 		if( host_developer.value || cls.spectator )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@CL_IsDevOv
	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN3@CL_IsDevOv
$LN4@CL_IsDevOv:

; 172  : 			return (int)dev_overview.value;

	cvttss2si eax, DWORD PTR _dev_overview+12
	jmp	SHORT $LN1@CL_IsDevOv
$LN3@CL_IsDevOv:

; 173  : 	}
; 174  : 
; 175  : 	return 0;

	xor	eax, eax
$LN1@CL_IsDevOv:

; 176  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsDevOverviewMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_UpdateFrameLerp
_TEXT	SEGMENT
_CL_UpdateFrameLerp PROC				; COMDAT

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 419  : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@CL_UpdateF
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN2@CL_UpdateF
$LN3@CL_UpdateF:

; 420  : 		return;

	jmp	SHORT $LN1@CL_UpdateF
$LN2@CL_UpdateF:

; 421  : 
; 422  : 	// compute last interpolation amount
; 423  : 	cl.lerpFrac = CL_LerpPoint();

	call	_CL_LerpPoint
	fstp	DWORD PTR _cl+48

; 424  : 
; 425  : 	cl.commands[(cls.netchan.outgoing_sequence - 1) & CL_UPDATE_MASK].frame_lerp = cl.lerpFrac;

	mov	eax, DWORD PTR _cls+26880
	sub	eax, 1
	mov	ecx, DWORD PTR _CL_UPDATE_BACKUP
	sub	ecx, 1
	and	eax, ecx
	imul	edx, eax, 88
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR _cl[edx+1539688], xmm0
$LN1@CL_UpdateF:

; 426  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateFrameLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SetupOverviewParams
_TEXT	SEGMENT
tv165 = -84						; size = 4
tv84 = -84						; size = 4
tv73 = -84						; size = 4
tv70 = -84						; size = 4
_aspect$ = -16						; size = 4
_screenAspect$ = -12					; size = 4
_mapAspect$ = -8					; size = 4
_ov$ = -4						; size = 4
_CL_SetupOverviewParams PROC				; COMDAT

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1725 : 	ref_overview_t	*ov = &clgame.overView;

	mov	DWORD PTR _ov$[ebp], OFFSET _clgame+217612

; 1726 : 	float		mapAspect, screenAspect, aspect;
; 1727 : 
; 1728 : 	ov->rotated = ( world.size[1] <= world.size[0] ) ? true : false;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _world[edx+2620]
	comiss	xmm0, DWORD PTR _world[eax+2620]
	jb	SHORT $LN4@CL_SetupOv
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@CL_SetupOv
$LN4@CL_SetupOv:
	mov	DWORD PTR tv70[ebp], 0
$LN5@CL_SetupOv:
	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR [eax+12], ecx

; 1729 : 
; 1730 : 	// calculate nearest aspect
; 1731 : 	mapAspect = world.size[!ov->rotated] / world.size[ov->rotated];

	mov	eax, DWORD PTR _ov$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@CL_SetupOv
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN7@CL_SetupOv
$LN6@CL_SetupOv:
	mov	DWORD PTR tv73[ebp], 0
$LN7@CL_SetupOv:
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR tv73[ebp]
	movss	xmm0, DWORD PTR _world[eax*4+2620]
	divss	xmm0, DWORD PTR _world[edx*4+2620]
	movss	DWORD PTR _mapAspect$[ebp], xmm0

; 1732 : 	screenAspect = (float)glState.width / (float)glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _glState+4
	divss	xmm0, xmm1
	movss	DWORD PTR _screenAspect$[ebp], xmm0

; 1733 : 	aspect = Q_max( mapAspect, screenAspect );

	movss	xmm0, DWORD PTR _mapAspect$[ebp]
	comiss	xmm0, DWORD PTR _screenAspect$[ebp]
	jbe	SHORT $LN8@CL_SetupOv
	movss	xmm0, DWORD PTR _mapAspect$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN9@CL_SetupOv
$LN8@CL_SetupOv:
	movss	xmm0, DWORD PTR _screenAspect$[ebp]
	movss	DWORD PTR tv84[ebp], xmm0
$LN9@CL_SetupOv:
	movss	xmm0, DWORD PTR tv84[ebp]
	movss	DWORD PTR _aspect$[ebp], xmm0

; 1734 : 
; 1735 : 	ov->zNear = world.maxs[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR _world[eax+2608]
	mov	DWORD PTR [ecx+36], edx

; 1736 : 	ov->zFar = world.mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ov$[ebp]
	mov	edx, DWORD PTR _world[eax+2596]
	mov	DWORD PTR [ecx+32], edx

; 1737 : 	ov->flZoom = ( 8192.0f / world.size[ov->rotated] ) / aspect;

	mov	eax, DWORD PTR _ov$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movss	xmm0, DWORD PTR __real@46000000
	divss	xmm0, DWORD PTR _world[ecx*4+2620]
	divss	xmm0, DWORD PTR _aspect$[ebp]
	mov	edx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [edx+40], xmm0

; 1738 : 
; 1739 : 	VectorAverage( world.mins, world.maxs, ov->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2596]
	addss	xmm0, DWORD PTR _world[eax+2608]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _world[ecx+2596]
	addss	xmm0, DWORD PTR _world[edx+2608]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ov$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _world[edx+2596]
	addss	xmm0, DWORD PTR _world[eax+2608]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv165[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ov$[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1740 : 
; 1741 : 	memset( &cls.spectator_state, 0, sizeof( cls.spectator_state ));

	push	9724					; 000025fcH
	push	0
	push	OFFSET _cls+156
	call	_memset
	add	esp, 12					; 0000000cH

; 1742 : 
; 1743 : 	if( cls.spectator )

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN2@CL_SetupOv

; 1744 : 	{
; 1745 : 		cls.spectator_state.playerstate.friction = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cls+352, xmm0

; 1746 : 		cls.spectator_state.playerstate.gravity = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cls+356, xmm0

; 1747 : 		cls.spectator_state.playerstate.number = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	DWORD PTR _cls+160, eax

; 1748 : 		cls.spectator_state.playerstate.usehull = 1;

	mov	DWORD PTR _cls+468, 1

; 1749 : 		cls.spectator_state.playerstate.movetype = MOVETYPE_NOCLIP;

	mov	DWORD PTR _cls+244, 8

; 1750 : 		cls.spectator_state.client.maxspeed = clgame.movevars.spectatormaxspeed;

	movss	xmm0, DWORD PTR _clgame+1036
	movss	DWORD PTR _cls+772, xmm0
$LN2@CL_SetupOv:

; 1751 : 	}
; 1752 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetupOverviewParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_PrecacheResources
_TEXT	SEGMENT
tv297 = -76						; size = 4
tv293 = -76						; size = 4
tv296 = -72						; size = 4
tv292 = -72						; size = 4
tv270 = -72						; size = 4
tv221 = -72						; size = 4
tv172 = -72						; size = 4
tv146 = -72						; size = 4
_pRes$ = -4						; size = 4
_CL_PrecacheResources PROC				; COMDAT

; 2388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2389 : 	resource_t	*pRes;
; 2390 : 
; 2391 : 	// NOTE: world need to be loaded as first model
; 2392 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	eax, DWORD PTR _cl+3029544
	mov	DWORD PTR _pRes$[ebp], eax
	jmp	SHORT $LN4@CL_Precach
$LN2@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pRes$[ebp], ecx
$LN4@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	SHORT $LN3@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+3029416
	je	SHORT $LN3@CL_Precach

; 2393 : 	{
; 2394 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 16					; 00000010H
	je	SHORT $LN13@CL_Precach

; 2395 : 			continue;

	jmp	SHORT $LN2@CL_Precach
$LN13@CL_Precach:

; 2396 : 
; 2397 : 		if( pRes->type != t_model || pRes->nIndex != WORLD_INDEX )

	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+64], 2
	jne	SHORT $LN15@CL_Precach
	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+68], 1
	je	SHORT $LN14@CL_Precach
$LN15@CL_Precach:

; 2398 : 			continue;

	jmp	SHORT $LN2@CL_Precach
$LN14@CL_Precach:

; 2399 : 
; 2400 : 		cl.models[pRes->nIndex] = Mod_LoadWorld( pRes->szFileName, true );

	push	1
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_Mod_LoadWorld
	add	esp, 8
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _cl[edx*4+2980244], eax

; 2401 : 		SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [edx+76], cl

; 2402 : 		cl.nummodels = 1;

	mov	DWORD PTR _cl+2984344, 1

; 2403 : 		break;

	jmp	SHORT $LN3@CL_Precach

; 2404 : 	}

	jmp	SHORT $LN2@CL_Precach
$LN3@CL_Precach:

; 2405 : 
; 2406 : 	// then we set up all the world submodels
; 2407 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	eax, DWORD PTR _cl+3029544
	mov	DWORD PTR _pRes$[ebp], eax
	jmp	SHORT $LN7@CL_Precach
$LN5@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pRes$[ebp], ecx
$LN7@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	$LN6@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+3029416
	je	$LN6@CL_Precach

; 2408 : 	{
; 2409 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 16					; 00000010H
	je	SHORT $LN16@CL_Precach

; 2410 : 			continue;

	jmp	SHORT $LN5@CL_Precach
$LN16@CL_Precach:

; 2411 : 
; 2412 : 		if( pRes->type == t_model && pRes->szFileName[0] == '*' )

	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+64], 2
	jne	$LN17@CL_Precach
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pRes$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	$LN17@CL_Precach

; 2413 : 		{
; 2414 : 			cl.models[pRes->nIndex] = Mod_ForName( pRes->szFileName, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _cl[edx*4+2980244], eax

; 2415 : 			cl.nummodels = Q_max( cl.nummodels, pRes->nIndex + 1 );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	cmp	DWORD PTR _cl+2984344, ecx
	jle	SHORT $LN43@CL_Precach
	mov	edx, DWORD PTR _cl+2984344
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN44@CL_Precach
$LN43@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	DWORD PTR tv146[ebp], ecx
$LN44@CL_Precach:
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR _cl+2984344, edx

; 2416 : 			SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [edx+76], cl

; 2417 : 
; 2418 : 			if( cl.models[pRes->nIndex] == NULL )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	cmp	DWORD PTR _cl[ecx*4+2980244], 0
	jne	SHORT $LN17@CL_Precach

; 2419 : 			{
; 2420 : 				Con_Printf( S_ERROR "submodel %s not found\n", pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@DKBPLKFE@?$FO1Error?3?$FO7?5submodel?5?$CFs?5not?5foun@
	call	_Con_Printf
	add	esp, 8

; 2421 : 
; 2422 : 				if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN17@CL_Precach

; 2423 : 				{
; 2424 : 					CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2425 : 					return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN17@CL_Precach:

; 2426 : 				}
; 2427 : 			}
; 2428 : 		}
; 2429 : 	}

	jmp	$LN5@CL_Precach
$LN6@CL_Precach:

; 2430 : 
; 2431 : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN20@CL_Precach

; 2432 : 		S_BeginRegistration();

	call	_S_BeginRegistration
$LN20@CL_Precach:

; 2433 : 
; 2434 : 	// precache all the remaining resources where order is doesn't matter
; 2435 : 	for( pRes = cl.resourcesonhand.pNext; pRes && pRes != &cl.resourcesonhand; pRes = pRes->pNext )

	mov	eax, DWORD PTR _cl+3029544
	mov	DWORD PTR _pRes$[ebp], eax
	jmp	SHORT $LN10@CL_Precach
$LN8@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _pRes$[ebp], ecx
$LN10@CL_Precach:
	cmp	DWORD PTR _pRes$[ebp], 0
	je	$LN9@CL_Precach
	cmp	DWORD PTR _pRes$[ebp], OFFSET _cl+3029416
	je	$LN9@CL_Precach

; 2436 : 	{
; 2437 : 		if( FBitSet( pRes->ucFlags, RES_PRECACHED ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 16					; 00000010H
	je	SHORT $LN21@CL_Precach

; 2438 : 			continue;

	jmp	SHORT $LN8@CL_Precach
$LN21@CL_Precach:

; 2439 : 
; 2440 : 		switch( pRes->type )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR tv172[ebp], ecx
	cmp	DWORD PTR tv172[ebp], 5
	ja	$LN11@CL_Precach
	mov	edx, DWORD PTR tv172[ebp]
	jmp	DWORD PTR $LN57@CL_Precach[edx*4]
$LN22@CL_Precach:

; 2441 : 		{
; 2442 : 		case t_sound:
; 2443 : 			if( pRes->nIndex != -1 )

	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+68], -1
	je	$LN23@CL_Precach

; 2444 : 			{
; 2445 : 				if( FBitSet( pRes->ucFlags, RES_WASMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 2
	je	SHORT $LN25@CL_Precach

; 2446 : 				{
; 2447 : 					Con_Printf( S_ERROR "%s%s couldn't load\n", DEFAULT_SOUNDPATH, pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_0BP@KOCONAKK@?$FO1Error?3?$FO7?5?$CFs?$CFs?5couldn?8t?5load?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 2448 : 					cl.sound_precache[pRes->nIndex][0] = 0;

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	shl	ecx, 6
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _cl[ecx+eax+2241940], 0

; 2449 : 					cl.sound_index[pRes->nIndex] = 0;

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	xor	edx, edx
	mov	WORD PTR _cl[ecx*2+4561596], dx

; 2450 : 				}

	jmp	SHORT $LN26@CL_Precach
$LN25@CL_Precach:

; 2451 : 				else
; 2452 : 				{
; 2453 : 					Q_strncpy( cl.sound_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.sound_precache[0] )); 

	push	64					; 00000040H
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 6
	add	edx, OFFSET _cl+2241940
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2454 : 					cl.sound_index[pRes->nIndex] = S_RegisterSound( pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	WORD PTR _cl[edx*2+4561596], ax

; 2455 : 
; 2456 : 					if( !cl.sound_index[pRes->nIndex] )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	movsx	edx, WORD PTR _cl[ecx*2+4561596]
	test	edx, edx
	jne	SHORT $LN26@CL_Precach

; 2457 : 					{
; 2458 : 						if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN26@CL_Precach

; 2459 : 						{
; 2460 : 							S_EndRegistration();

	call	_S_EndRegistration

; 2461 : 							CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2462 : 							return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN26@CL_Precach:

; 2463 : 						}
; 2464 : 					}
; 2465 : 				}
; 2466 : 			}

	jmp	SHORT $LN24@CL_Precach
$LN23@CL_Precach:

; 2467 : 			else
; 2468 : 			{
; 2469 : 				// client sounds
; 2470 : 				S_RegisterSound( pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
$LN24@CL_Precach:

; 2471 : 			}
; 2472 : 			break;

	jmp	$LN11@CL_Precach

; 2473 : 		case t_skin:
; 2474 : 			break;

	jmp	$LN11@CL_Precach
$LN30@CL_Precach:

; 2475 : 		case t_model:
; 2476 : 			cl.nummodels = Q_max( cl.nummodels, pRes->nIndex + 1 );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	cmp	DWORD PTR _cl+2984344, ecx
	jle	SHORT $LN45@CL_Precach
	mov	edx, DWORD PTR _cl+2984344
	mov	DWORD PTR tv221[ebp], edx
	jmp	SHORT $LN46@CL_Precach
$LN45@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	DWORD PTR tv221[ebp], ecx
$LN46@CL_Precach:
	mov	edx, DWORD PTR tv221[ebp]
	mov	DWORD PTR _cl+2984344, edx

; 2477 : 			if( pRes->szFileName[0] != '*' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pRes$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN31@CL_Precach

; 2478 : 			{
; 2479 : 				if( pRes->nIndex != -1 )

	mov	eax, DWORD PTR _pRes$[ebp]
	cmp	DWORD PTR [eax+68], -1
	je	SHORT $LN32@CL_Precach

; 2480 : 				{
; 2481 : 					cl.models[pRes->nIndex] = Mod_ForName( pRes->szFileName, false, true );

	push	1
	push	0
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _cl[edx*4+2980244], eax

; 2482 : 
; 2483 : 					if( cl.models[pRes->nIndex] == NULL )

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	cmp	DWORD PTR _cl[ecx*4+2980244], 0
	jne	SHORT $LN34@CL_Precach

; 2484 : 					{
; 2485 : 						if( FBitSet( pRes->ucFlags, RES_FATALIFMISSING ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN34@CL_Precach

; 2486 : 						{
; 2487 : 							S_EndRegistration();

	call	_S_EndRegistration

; 2488 : 							CL_Disconnect_f();

	call	_CL_Disconnect_f

; 2489 : 							return false;

	xor	eax, eax
	jmp	$LN1@CL_Precach
$LN34@CL_Precach:

; 2490 : 						}
; 2491 : 					}
; 2492 : 				}

	jmp	SHORT $LN31@CL_Precach
$LN32@CL_Precach:

; 2493 : 				else
; 2494 : 				{
; 2495 : 					CL_LoadClientSprite( pRes->szFileName );

	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	call	_CL_LoadClientSprite
	add	esp, 4
$LN31@CL_Precach:

; 2496 : 				}
; 2497 : 			}
; 2498 : 			break;

	jmp	$LN11@CL_Precach
$LN36@CL_Precach:

; 2499 : 		case t_decal:
; 2500 : 			if( !FBitSet( pRes->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	jne	SHORT $LN37@CL_Precach

; 2501 : 				Q_strncpy( host.draw_decals[pRes->nIndex], pRes->szFileName, sizeof( host.draw_decals[0] ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 6
	add	edx, OFFSET _host+1468
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN37@CL_Precach:

; 2502 : 			break;

	jmp	$LN11@CL_Precach
$LN38@CL_Precach:

; 2503 : 		case t_generic:
; 2504 : 			Q_strncpy( cl.files_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.files_precache[0] ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 6
	add	edx, OFFSET _cl+2831764
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2505 : 			cl.numfiles = Q_max( cl.numfiles, pRes->nIndex + 1 );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	cmp	DWORD PTR _cl+2984348, ecx
	jle	SHORT $LN47@CL_Precach
	mov	edx, DWORD PTR _cl+2984348
	mov	DWORD PTR tv270[ebp], edx
	jmp	SHORT $LN48@CL_Precach
$LN47@CL_Precach:
	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	DWORD PTR tv270[ebp], ecx
$LN48@CL_Precach:
	mov	edx, DWORD PTR tv270[ebp]
	mov	DWORD PTR _cl+2984348, edx

; 2506 : 			break;

	jmp	SHORT $LN11@CL_Precach
$LN39@CL_Precach:

; 2507 : 		case t_eventscript:
; 2508 : 			Q_strncpy( cl.event_precache[pRes->nIndex], pRes->szFileName, sizeof( cl.event_precache[0] ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRes$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	shl	edx, 6
	add	edx, OFFSET _cl+2766228
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2509 : 			CL_SetEventIndex( cl.event_precache[pRes->nIndex], pRes->nIndex );

	mov	eax, DWORD PTR _pRes$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	eax, DWORD PTR [edx+68]
	shl	eax, 6
	add	eax, OFFSET _cl+2766228
	push	eax
	call	_CL_SetEventIndex
	add	esp, 8
$LN11@CL_Precach:

; 2510 : 			break;
; 2511 : 		default:
; 2512 : 			break;
; 2513 : 		}
; 2514 : 
; 2515 : 		SetBits( pRes->ucFlags, RES_PRECACHED );

	mov	eax, DWORD PTR _pRes$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pRes$[ebp]
	mov	BYTE PTR [edx+76], cl

; 2516 : 	}

	jmp	$LN8@CL_Precach
$LN9@CL_Precach:

; 2517 : 
; 2518 : 	// make sure modelcount is in-range
; 2519 : 	cl.nummodels = bound( 0, cl.nummodels, MAX_MODELS );

	cmp	DWORD PTR _cl+2984344, 0
	jl	SHORT $LN51@CL_Precach
	cmp	DWORD PTR _cl+2984344, 1024		; 00000400H
	jge	SHORT $LN49@CL_Precach
	mov	eax, DWORD PTR _cl+2984344
	mov	DWORD PTR tv292[ebp], eax
	jmp	SHORT $LN50@CL_Precach
$LN49@CL_Precach:
	mov	DWORD PTR tv292[ebp], 1024		; 00000400H
$LN50@CL_Precach:
	mov	ecx, DWORD PTR tv292[ebp]
	mov	DWORD PTR tv293[ebp], ecx
	jmp	SHORT $LN52@CL_Precach
$LN51@CL_Precach:
	mov	DWORD PTR tv293[ebp], 0
$LN52@CL_Precach:
	mov	edx, DWORD PTR tv293[ebp]
	mov	DWORD PTR _cl+2984344, edx

; 2520 : 	cl.numfiles = bound( 0, cl.numfiles, MAX_CUSTOM );

	cmp	DWORD PTR _cl+2984348, 0
	jl	SHORT $LN55@CL_Precach
	cmp	DWORD PTR _cl+2984348, 1024		; 00000400H
	jge	SHORT $LN53@CL_Precach
	mov	eax, DWORD PTR _cl+2984348
	mov	DWORD PTR tv296[ebp], eax
	jmp	SHORT $LN54@CL_Precach
$LN53@CL_Precach:
	mov	DWORD PTR tv296[ebp], 1024		; 00000400H
$LN54@CL_Precach:
	mov	ecx, DWORD PTR tv296[ebp]
	mov	DWORD PTR tv297[ebp], ecx
	jmp	SHORT $LN56@CL_Precach
$LN55@CL_Precach:
	mov	DWORD PTR tv297[ebp], 0
$LN56@CL_Precach:
	mov	edx, DWORD PTR tv297[ebp]
	mov	DWORD PTR _cl+2984348, edx

; 2521 : 
; 2522 : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN41@CL_Precach

; 2523 : 		S_EndRegistration();

	call	_S_EndRegistration
$LN41@CL_Precach:

; 2524 : 
; 2525 : 	return true;

	mov	eax, 1
$LN1@CL_Precach:

; 2526 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN57@CL_Precach:
	DD	$LN22@CL_Precach
	DD	$LN11@CL_Precach
	DD	$LN30@CL_Precach
	DD	$LN36@CL_Precach
	DD	$LN38@CL_Precach
	DD	$LN39@CL_Precach
_CL_PrecacheResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_GetFragmentSize
_TEXT	SEGMENT
_unused$ = 8						; size = 4
_CL_GetFragmentSize PROC				; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 208  : 	if( Netchan_IsLocal( &cls.netchan ))

	push	OFFSET _cls+26800
	call	_Netchan_IsLocal
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_GetFrag

; 209  : 		return FRAGMENT_LOCAL_SIZE;

	mov	eax, 64000				; 0000fa00H
	jmp	SHORT $LN1@CL_GetFrag
$LN2@CL_GetFrag:

; 210  : 
; 211  : 	return FRAGMENT_MIN_SIZE;

	mov	eax, 1200				; 000004b0H
$LN1@CL_GetFrag:

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetFragmentSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_WriteUsercmd
_TEXT	SEGMENT
tv81 = -136						; size = 4
tv72 = -136						; size = 4
_t$ = -68						; size = 4
_f$ = -64						; size = 4
_nullcmd$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_from$ = 12						; size = 4
_to$ = 16						; size = 4
_CL_WriteUsercmd PROC					; COMDAT

; 680  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 681  : 	usercmd_t	nullcmd;
; 682  : 	usercmd_t	*f, *t;
; 683  : 
; 684  : 	Assert( from == -1 || ( from >= 0 && from < MULTIPLAYER_BACKUP ));

	cmp	DWORD PTR _from$[ebp], -1
	je	SHORT $LN6@CL_WriteUs
	cmp	DWORD PTR _from$[ebp], 0
	jl	SHORT $LN5@CL_WriteUs
	cmp	DWORD PTR _from$[ebp], 64		; 00000040H
	jl	SHORT $LN6@CL_WriteUs
$LN5@CL_WriteUs:
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN7@CL_WriteUs
$LN6@CL_WriteUs:
	mov	DWORD PTR tv72[ebp], 1
$LN7@CL_WriteUs:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_WriteUsercmd@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0DJ@BPAMAEGK@from?5?$DN?$DN?5?91?5?$HM?$HM?5?$CI?5from?5?$DO?$DN?50?5?$CG?$CG?5fr@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 685  : 	Assert( to >= 0 && to < MULTIPLAYER_BACKUP );

	cmp	DWORD PTR _to$[ebp], 0
	jl	SHORT $LN8@CL_WriteUs
	cmp	DWORD PTR _to$[ebp], 64			; 00000040H
	jge	SHORT $LN8@CL_WriteUs
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN9@CL_WriteUs
$LN8@CL_WriteUs:
	mov	DWORD PTR tv81[ebp], 0
$LN9@CL_WriteUs:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_WriteUsercmd@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CD@GOANGLPP@to?5?$DO?$DN?50?5?$CG?$CG?5to?5?$DM?5MULTIPLAYER_BAC@
	mov	ecx, DWORD PTR tv81[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 686  : 
; 687  : 	if( from == -1 )

	cmp	DWORD PTR _from$[ebp], -1
	jne	SHORT $LN2@CL_WriteUs

; 688  : 	{
; 689  : 		memset( &nullcmd, 0, sizeof( nullcmd ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _nullcmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 690  : 		f = &nullcmd;

	lea	eax, DWORD PTR _nullcmd$[ebp]
	mov	DWORD PTR _f$[ebp], eax

; 691  : 	}

	jmp	SHORT $LN3@CL_WriteUs
$LN2@CL_WriteUs:

; 692  : 	else
; 693  : 	{
; 694  : 		f = &cl.commands[from].cmd;

	imul	eax, DWORD PTR _from$[ebp], 88
	add	eax, OFFSET _cl+1539692
	mov	DWORD PTR _f$[ebp], eax
$LN3@CL_WriteUs:

; 695  : 	}
; 696  : 
; 697  : 	t = &cl.commands[to].cmd;

	imul	eax, DWORD PTR _to$[ebp], 88
	add	eax, OFFSET _cl+1539692
	mov	DWORD PTR _t$[ebp], eax

; 698  : 
; 699  : 	// write it into the buffer
; 700  : 	MSG_WriteDeltaUsercmd( msg, f, t );

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteDeltaUsercmd
	add	esp, 12					; 0000000cH

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteUsercmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ProcessFile
_TEXT	SEGMENT
_msg$1 = -131124					; size = 20
_msg_buf$2 = -131104					; size = 131072
_p$ = -32						; size = 4
_pfilename$ = -28					; size = 4
_rgucMD5_hash$ = -24					; size = 16
_sound_len$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_successfully_received$ = 8				; size = 4
_filename$ = 12						; size = 4
_CL_ProcessFile PROC					; COMDAT

; 2188 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131636				; 00020234H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2189 : 	int		sound_len = Q_strlen( DEFAULT_SOUNDPATH );

	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _sound_len$[ebp], eax

; 2190 : 	byte		rgucMD5_hash[16];
; 2191 : 	const char	*pfilename;
; 2192 : 	resource_t	*p;
; 2193 : 
; 2194 : 	if( COM_CheckString( filename ) && successfully_received )

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@CL_Process
	cmp	DWORD PTR _successfully_received$[ebp], 0
	je	SHORT $LN8@CL_Process

; 2195 : 	{
; 2196 : 		if( filename[0] != '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN10@CL_Process

; 2197 : 			Con_Printf( "processing %s\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@FNEEOGHP@processing?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN10@CL_Process:

; 2198 : 	}

	jmp	SHORT $LN9@CL_Process
$LN8@CL_Process:

; 2199 : 	else if( !successfully_received )

	cmp	DWORD PTR _successfully_received$[ebp], 0
	jne	SHORT $LN9@CL_Process

; 2200 : 	{
; 2201 : 		Con_Printf( S_ERROR "server failed to transmit file '%s'\n", CL_CleanFileName( filename ));

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_CleanFileName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DA@NHIBONO@?$FO1Error?3?$FO7?5server?5failed?5to?5tra@
	call	_Con_Printf
	add	esp, 8
$LN9@CL_Process:

; 2202 : 	}
; 2203 : 
; 2204 : 	pfilename = filename;

	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _pfilename$[ebp], eax

; 2205 : 
; 2206 : 	if( !Q_strnicmp( filename, DEFAULT_SOUNDPATH, sound_len ))

	mov	eax, DWORD PTR _sound_len$[ebp]
	push	eax
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@CL_Process

; 2207 : 		pfilename += sound_len;

	mov	eax, DWORD PTR _pfilename$[ebp]
	add	eax, DWORD PTR _sound_len$[ebp]
	mov	DWORD PTR _pfilename$[ebp], eax
$LN12@CL_Process:

; 2208 : 
; 2209 : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@CL_Process:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	$LN3@CL_Process

; 2210 : 	{
; 2211 : 		if( !Q_strnicmp( filename, "!MD5", 4 ))

	push	4
	push	OFFSET ??_C@_04HJKAGJBM@?$CBMD5@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@CL_Process

; 2212 : 		{
; 2213 : 			COM_HexConvert( filename + 4, 32, rgucMD5_hash );

	lea	eax, DWORD PTR _rgucMD5_hash$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _filename$[ebp]
	add	ecx, 4
	push	ecx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 2214 : 
; 2215 : 			if( !memcmp( p->rgucMD5_hash, rgucMD5_hash, 16 ))

	push	16					; 00000010H
	lea	eax, DWORD PTR _rgucMD5_hash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 77					; 0000004dH
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@CL_Process

; 2216 : 				break;

	jmp	SHORT $LN3@CL_Process
$LN15@CL_Process:

; 2217 : 		}

	jmp	SHORT $LN14@CL_Process
$LN13@CL_Process:

; 2218 : 		else
; 2219 : 		{
; 2220 : 			if( p->type == t_generic )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax+64], 4
	jne	SHORT $LN16@CL_Process

; 2221 : 			{
; 2222 : 				if( !Q_stricmp( p->szFileName, filename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@CL_Process

; 2223 : 					break;

	jmp	SHORT $LN3@CL_Process
$LN18@CL_Process:

; 2224 : 			}

	jmp	SHORT $LN14@CL_Process
$LN16@CL_Process:

; 2225 : 			else
; 2226 : 			{
; 2227 : 				if( !Q_stricmp( p->szFileName, pfilename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pfilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@CL_Process

; 2228 : 					break;

	jmp	SHORT $LN3@CL_Process
$LN14@CL_Process:

; 2229 : 			}
; 2230 : 		}
; 2231 : 	}

	jmp	$LN2@CL_Process
$LN3@CL_Process:

; 2232 : 
; 2233 : 	if( p != &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	$LN20@CL_Process

; 2234 : 	{
; 2235 : 		if( successfully_received )

	cmp	DWORD PTR _successfully_received$[ebp], 0
	je	SHORT $LN21@CL_Process

; 2236 : 			ClearBits( p->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx+76], cl
$LN21@CL_Process:

; 2237 : 
; 2238 : 		if( filename[0] == '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	jne	$LN22@CL_Process

; 2239 : 		{
; 2240 : 			if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+289464, 0
	je	$LN23@CL_Process

; 2241 : 			{
; 2242 : 				if( p->nDownloadSize == cls.netchan.tempbuffersize )

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	cmp	ecx, DWORD PTR _cls+289468
	jne	SHORT $LN24@CL_Process

; 2243 : 				{
; 2244 : 					if( p->ucFlags & RES_CUSTOM )

	mov	eax, DWORD PTR _p$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN26@CL_Process

; 2245 : 					{
; 2246 : 						HPAK_AddLump( true, CUSTOM_RES_PATH, p, cls.netchan.tempbuffer, NULL );

	push	0
	mov	eax, DWORD PTR _cls+289464
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	push	1
	call	_HPAK_AddLump
	add	esp, 20					; 00000014H

; 2247 : 						CL_RegisterCustomization( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_RegisterCustomization
	add	esp, 4
$LN26@CL_Process:

; 2248 : 					}
; 2249 : 				}

	jmp	SHORT $LN25@CL_Process
$LN24@CL_Process:

; 2250 : 				else
; 2251 : 				{
; 2252 : 					Con_Printf( "Downloaded %i bytes for purported %i byte file, ignoring download\n", 

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _cls+289468
	push	edx
	push	OFFSET ??_C@_0ED@IBJGKGBH@Downloaded?5?$CFi?5bytes?5for?5purport@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN25@CL_Process:

; 2253 : 					cls.netchan.tempbuffersize, p->nDownloadSize );
; 2254 : 				}
; 2255 : 
; 2256 : 				if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+289464, 0
	je	SHORT $LN23@CL_Process

; 2257 : 					Mem_Free( cls.netchan.tempbuffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ProcessFile@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cls+289464
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN23@CL_Process:

; 2258 : 			}
; 2259 : 
; 2260 : 			cls.netchan.tempbuffersize = 0;

	mov	DWORD PTR _cls+289468, 0

; 2261 : 			cls.netchan.tempbuffer = NULL;

	mov	DWORD PTR _cls+289464, 0
$LN22@CL_Process:

; 2262 : 		}
; 2263 : 
; 2264 : 		// moving to 'onhandle' list even if file was missed
; 2265 : 		CL_MoveToOnHandList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_MoveToOnHandList
	add	esp, 4
$LN20@CL_Process:

; 2266 : 	}
; 2267 : 
; 2268 : 	if( cls.state != ca_disconnected )

	cmp	DWORD PTR _cls, 0
	je	$LN1@CL_Process

; 2269 : 	{
; 2270 : 		host.downloadcount = 0;

	mov	DWORD PTR _host+752, 0

; 2271 : 
; 2272 : 		for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN7@CL_Process
$LN5@CL_Process:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
$LN7@CL_Process:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	SHORT $LN6@CL_Process

; 2273 : 			host.downloadcount++;

	mov	eax, DWORD PTR _host+752
	add	eax, 1
	mov	DWORD PTR _host+752, eax
	jmp	SHORT $LN5@CL_Process
$LN6@CL_Process:

; 2274 : 
; 2275 : 		if( cl.resourcesneeded.pNext == &cl.resourcesneeded )

	cmp	DWORD PTR _cl+3029680, OFFSET _cl+3029552
	jne	SHORT $LN29@CL_Process

; 2276 : 		{
; 2277 : 			byte	msg_buf[MAX_INIT_MSG];
; 2278 : 			sizebuf_t msg;
; 2279 : 
; 2280 : 			MSG_Init( &msg, "Resource Registration", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _msg_buf$2[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@KLNLHGNN@Resource?5Registration@
	lea	ecx, DWORD PTR _msg$1[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2281 : 
; 2282 : 			if( CL_PrecacheResources( ))

	call	_CL_PrecacheResources
	test	eax, eax
	je	SHORT $LN30@CL_Process

; 2283 : 				CL_RegisterResources( &msg );

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	_CL_RegisterResources
	add	esp, 4
$LN30@CL_Process:

; 2284 : 
; 2285 : 			if( MSG_GetNumBytesWritten( &msg ) > 0 )

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN29@CL_Process

; 2286 : 			{
; 2287 : 				Netchan_CreateFragments( &cls.netchan, &msg );

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	push	OFFSET _cls+26800
	call	_Netchan_CreateFragments
	add	esp, 8

; 2288 : 				Netchan_FragSend( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_FragSend
	add	esp, 4
$LN29@CL_Process:

; 2289 : 			}
; 2290 : 		}
; 2291 : 
; 2292 : 		if( cls.netchan.tempbuffer )

	cmp	DWORD PTR _cls+289464, 0
	je	SHORT $LN32@CL_Process

; 2293 : 		{
; 2294 : 			Con_Printf( "Received a decal %s, but didn't find it in resources needed list!\n", pfilename );

	mov	eax, DWORD PTR _pfilename$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@OIDIDHDM@Received?5a?5decal?5?$CFs?0?5but?5didn?8t@
	call	_Con_Printf
	add	esp, 8

; 2295 : 			Mem_Free( cls.netchan.tempbuffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ProcessFile@@9@9
	add	eax, 107				; 0000006bH
	push	eax
	push	OFFSET ??_C@_0DE@KLFELIEG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cls+289464
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN32@CL_Process:

; 2296 : 		}
; 2297 : 
; 2298 : 		cls.netchan.tempbuffer = NULL;

	mov	DWORD PTR _cls+289464, 0

; 2299 : 		cls.netchan.tempbuffersize = 0;

	mov	DWORD PTR _cls+289468, 0
$LN1@CL_Process:

; 2300 : 	}
; 2301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Disconnect_f
_TEXT	SEGMENT
_CL_Disconnect_f PROC					; COMDAT

; 1431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1432 : 	if( Host_IsLocalClient( ))

	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN2@CL_Disconn

; 1433 : 		Host_EndGame( true, "disconnected from server\n" );

	push	OFFSET ??_C@_0BK@EFMONHFA@disconnected?5from?5server?6@
	push	1
	call	_Host_EndGame
	add	esp, 8
	jmp	SHORT $LN1@CL_Disconn
$LN2@CL_Disconn:

; 1434 : 	else CL_Disconnect();

	call	_CL_Disconnect
$LN1@CL_Disconn:

; 1435 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Disconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_SendCommand
_TEXT	SEGMENT
_CL_SendCommand PROC					; COMDAT

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 893  : 	// we create commands even if a demo is playing,
; 894  : 	CL_CreateCmd();

	call	_CL_CreateCmd

; 895  : 
; 896  : 	// clc_move, userinfo etc
; 897  : 	CL_WritePacket();

	call	_CL_WritePacket

; 898  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SendCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Quit_f
_TEXT	SEGMENT
_CL_Quit_f PROC						; COMDAT

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 976  : 	CL_Disconnect();

	call	_CL_Disconnect

; 977  : 	Sys_Quit();

	call	_Sys_Quit

; 978  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Quit_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 109  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 106  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetRealBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetRealBytesWritten PROC				; COMDAT

; 103  : _inline int MSG_GetRealBytesWritten( sizebuf_t *sb ) { return sb->iCurBit >> 3; }	// unpadded

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetRealBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Drop
_TEXT	SEGMENT
_CL_Drop PROC						; COMDAT

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 989  : 	if( !cls.initialized )

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@CL_Drop

; 990  : 		return;

	jmp	SHORT $LN1@CL_Drop
$LN2@CL_Drop:

; 991  : 	CL_Disconnect();

	call	_CL_Disconnect
$LN1@CL_Drop:

; 992  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Drop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Crashed
_TEXT	SEGMENT
_CL_Crashed PROC					; COMDAT

; 1438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1439 : 	// already freed
; 1440 : 	if( host.status == HOST_CRASHED ) return;

	cmp	DWORD PTR _host+12, 6
	jne	SHORT $LN2@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN2@CL_Crashed:

; 1441 : 	if( host.type != HOST_NORMAL ) return;

	cmp	DWORD PTR _host+164, 0
	je	SHORT $LN3@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN3@CL_Crashed:

; 1442 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN4@CL_Crashed
	jmp	SHORT $LN1@CL_Crashed
$LN4@CL_Crashed:

; 1443 : 
; 1444 : 	host.status = HOST_CRASHED;

	mov	DWORD PTR _host+12, 6

; 1445 : 
; 1446 : 	CL_Stop_f(); // stop any demos

	call	_CL_Stop_f

; 1447 : 
; 1448 : 	// send a disconnect message to the server
; 1449 : 	CL_SendDisconnectMessage();

	call	_CL_SendDisconnectMessage

; 1450 : 
; 1451 : 	Host_WriteOpenGLConfig();

	call	_Host_WriteOpenGLConfig

; 1452 : 	Host_WriteConfig();	// write config

	call	_Host_WriteConfig
$LN1@CL_Crashed:

; 1453 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Crashed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Disconnect
_TEXT	SEGMENT
_CL_Disconnect PROC					; COMDAT

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1400 : 	if( cls.state == ca_disconnected )

	cmp	DWORD PTR _cls, 0
	jne	SHORT $LN2@CL_Disconn

; 1401 : 		return;

	jmp	$LN1@CL_Disconn
$LN2@CL_Disconn:

; 1402 : 
; 1403 : 	cls.connect_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+136, xmm0

; 1404 : 	cls.changedemo = false;

	mov	DWORD PTR _cls+12, 0

; 1405 : 	cls.max_fragment_size = FRAGMENT_MAX_SIZE; // reset fragment size

	mov	DWORD PTR _cls+144, 64000		; 0000fa00H

; 1406 : 	CL_Stop_f();

	call	_CL_Stop_f

; 1407 : 
; 1408 : 	// send a disconnect message to the server
; 1409 : 	CL_SendDisconnectMessage();

	call	_CL_SendDisconnectMessage

; 1410 : 	CL_ClearState ();

	call	_CL_ClearState

; 1411 : 
; 1412 : 	S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack

; 1413 : 	SCR_EndLoadingPlaque (); // get rid of loading plaque

	call	_SCR_EndLoadingPlaque

; 1414 : 
; 1415 : 	// clear the network channel, too.
; 1416 : 	Netchan_Clear( &cls.netchan );

	push	OFFSET _cls+26800
	call	_Netchan_Clear
	add	esp, 4

; 1417 : 
; 1418 : 	cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0

; 1419 : 	cls.set_lastdemo = false;

	mov	DWORD PTR _cls+301104, 0

; 1420 : 	cls.connect_retry = 0;

	mov	DWORD PTR _cls+148, 0

; 1421 : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1422 : 
; 1423 : 	// back to menu in non-developer mode
; 1424 : 	if( host_developer.value || CL_IsInMenu( ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@CL_Disconn
	call	_CL_IsInMenu
	test	eax, eax
	je	SHORT $LN3@CL_Disconn
$LN4@CL_Disconn:

; 1425 : 		return;

	jmp	SHORT $LN1@CL_Disconn
$LN3@CL_Disconn:

; 1426 : 
; 1427 : 	UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN1@CL_Disconn:

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Disconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsQuakeCompatible
_TEXT	SEGMENT
_CL_IsQuakeCompatible PROC				; COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 151  : 	// feature set
; 152  : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	je	SHORT $LN2@CL_IsQuake

; 153  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsQuake
$LN2@CL_IsQuake:

; 154  : 
; 155  : 	// quake demo playing
; 156  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN3@CL_IsQuake

; 157  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsQuake
$LN3@CL_IsQuake:

; 158  : 
; 159  : 	return false;

	xor	eax, eax
$LN1@CL_IsQuake:

; 160  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsQuakeCompatible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsBackgroundMap
_TEXT	SEGMENT
tv66 = -68						; size = 4
_CL_IsBackgroundMap PROC				; COMDAT

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 146  : 	return ( cl.background && !cls.demoplayback );

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN3@CL_IsBackg
	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN3@CL_IsBackg
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsBackg
$LN3@CL_IsBackg:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsBackg:
	mov	eax, DWORD PTR tv66[ebp]

; 147  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsBackgroundMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsBackgroundDemo
_TEXT	SEGMENT
tv66 = -68						; size = 4
_CL_IsBackgroundDemo PROC				; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 141  : 	return ( cls.demoplayback && cls.demonum != -1 );

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN3@CL_IsBackg
	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN3@CL_IsBackg
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsBackg
$LN3@CL_IsBackg:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsBackg:
	mov	eax, DWORD PTR tv66[ebp]

; 142  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsBackgroundDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsPlaybackDemo
_TEXT	SEGMENT
_CL_IsPlaybackDemo PROC					; COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 121  : 	return cls.demoplayback;

	mov	eax, DWORD PTR _cls+300828

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsPlaybackDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsTimeDemo
_TEXT	SEGMENT
_CL_IsTimeDemo PROC					; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 131  : 	return cls.timedemo;

	mov	eax, DWORD PTR _cls+300836

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsTimeDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsRecordDemo
_TEXT	SEGMENT
_CL_IsRecordDemo PROC					; COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 126  : 	return cls.demorecording;

	mov	eax, DWORD PTR _cls+300824

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsRecordDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_ServerCommand
_TEXT	SEGMENT
_argptr$ = -1032					; size = 4
_string$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_reliable$ = 8						; size = 4
_fmt$ = 12						; size = 4
_CL_ServerCommand PROC					; COMDAT

; 2311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2312 : 	char		string[MAX_SYSPATH];
; 2313 : 	va_list		argptr;
; 2314 : 
; 2315 : 	if( cls.state < ca_connecting )

	cmp	DWORD PTR _cls, 1
	jge	SHORT $LN2@CL_ServerC

; 2316 : 		return;

	jmp	$LN1@CL_ServerC
$LN2@CL_ServerC:

; 2317 : 
; 2318 : 	va_start( argptr, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 2319 : 	Q_vsprintf( string, fmt, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	99999					; 0001869fH
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 2320 : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 2321 : 
; 2322 : 	if( reliable )

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN3@CL_ServerC

; 2323 : 	{
; 2324 : 		MSG_BeginClientCmd( &cls.netchan.message, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+26900
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2325 : 		MSG_WriteString( &cls.netchan.message, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8

; 2326 : 	}

	jmp	SHORT $LN1@CL_ServerC
$LN3@CL_ServerC:

; 2327 : 	else
; 2328 : 	{
; 2329 : 		MSG_BeginClientCmd( &cls.datagram, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+10392
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 2330 : 		MSG_WriteString( &cls.datagram, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	push	OFFSET _cls+10392
	call	_MSG_WriteString
	add	esp, 8
$LN1@CL_ServerC:

; 2331 : 	}
; 2332 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_DisableVisibility
_TEXT	SEGMENT
_CL_DisableVisibility PROC				; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 136  : 	return cls.envshot_disable_vis;

	mov	eax, DWORD PTR _cls+296320

; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DisableVisibility ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Userinfo
_TEXT	SEGMENT
_CL_Userinfo PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 164  : 	return cls.userinfo;

	mov	eax, OFFSET _cls+9880

; 165  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Userinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Initialized
_TEXT	SEGMENT
_CL_Initialized PROC					; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 89   : 	return cls.initialized;

	mov	eax, DWORD PTR _cls+4

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Initialized ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsIntermission
_TEXT	SEGMENT
_CL_IsIntermission PROC					; COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 116  : 	return cl.intermission;

	mov	eax, DWORD PTR _cl+2212820

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsIntermission ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsInConsole
_TEXT	SEGMENT
tv65 = -68						; size = 4
_CL_IsInConsole PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 111  : 	return ( cls.key_dest == key_console );

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN3@CL_IsInCon
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_IsInCon
$LN3@CL_IsInCon:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_IsInCon:
	mov	eax, DWORD PTR tv65[ebp]

; 112  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInConsole ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsInMenu
_TEXT	SEGMENT
tv65 = -68						; size = 4
_CL_IsInMenu PROC					; COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 106  : 	return ( cls.key_dest == key_menu );

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN3@CL_IsInMen
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_IsInMen
$LN3@CL_IsInMen:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_IsInMen:
	mov	eax, DWORD PTR tv65[ebp]

; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInMenu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_IsInGame
_TEXT	SEGMENT
tv69 = -68						; size = 4
_CL_IsInGame PROC					; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 95   : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@CL_IsInGam

; 96   : 		return true; // always active for dedicated servers

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsInGam
$LN2@CL_IsInGam:

; 97   : 
; 98   : 	if( cl.background || CL_GetMaxClients() > 1 )

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN4@CL_IsInGam
	call	_CL_GetMaxClients
	cmp	eax, 1
	jle	SHORT $LN3@CL_IsInGam
$LN4@CL_IsInGam:

; 99   : 		return true; // always active for multiplayer or background map

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsInGam
$LN3@CL_IsInGam:

; 100  : 
; 101  : 	return ( cls.key_dest == key_game ); // active if not menu or console

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN6@CL_IsInGam
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN7@CL_IsInGam
$LN6@CL_IsInGam:
	mov	DWORD PTR tv69[ebp], 0
$LN7@CL_IsInGam:
	mov	eax, DWORD PTR tv69[ebp]
$LN1@CL_IsInGam:

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsInGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Active
_TEXT	SEGMENT
tv65 = -68						; size = 4
_CL_Active PROC						; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 84   : 	return ( cls.state == ca_active );

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@CL_Active
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@CL_Active
$LN3@CL_Active:
	mov	DWORD PTR tv65[ebp], 0
$LN4@CL_Active:
	mov	eax, DWORD PTR tv65[ebp]

; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Active ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _Host_ClientFrame
_TEXT	SEGMENT
_Host_ClientFrame PROC					; COMDAT

; 2760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2761 : 	// if client is not active, do nothing
; 2762 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN4@Host_Clien
	jmp	SHORT $LN1@Host_Clien
$LN4@Host_Clien:

; 2763 : 
; 2764 : 	// if running the server remotely, send intentions now after
; 2765 : 	// the incoming messages have been read
; 2766 : 	if( !SV_Active( )) CL_SendCommand ();

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN5@Host_Clien
	call	_CL_SendCommand
$LN5@Host_Clien:

; 2767 : 
; 2768 : 	clgame.dllFuncs.pfnFrame( host.frametime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+136
	add	esp, 8

; 2769 : 
; 2770 : 	// remember last received framenum
; 2771 : 	CL_SetLastUpdate ();

	call	_CL_SetLastUpdate

; 2772 : 
; 2773 : 	// read updates from server
; 2774 : 	CL_ReadPackets ();

	call	_CL_ReadPackets

; 2775 : 
; 2776 : 	// do prediction again in case we got
; 2777 : 	// a new portion updates from server
; 2778 : 	CL_RedoPrediction ();

	call	_CL_RedoPrediction

; 2779 : 
; 2780 : 	// TODO: implement
; 2781 : //	Voice_Idle( host.frametime );
; 2782 : 
; 2783 : 	// emit visible entities
; 2784 : 	CL_EmitEntities ();

	call	_CL_EmitEntities

; 2785 : 
; 2786 : 	// in case we lost connection
; 2787 : 	CL_CheckForResend ();

	call	_CL_CheckForResend
$LN2@Host_Clien:

; 2788 : 
; 2789 : 	// procssing resources on handle
; 2790 : 	while( CL_RequestMissingResources( ));

	call	_CL_RequestMissingResources
	test	eax, eax
	je	SHORT $LN3@Host_Clien
	jmp	SHORT $LN2@Host_Clien
$LN3@Host_Clien:

; 2791 : 
; 2792 : 	// handle thirdperson camera
; 2793 : 	CL_MoveThirdpersonCamera();

	call	_CL_MoveThirdpersonCamera

; 2794 : 
; 2795 : 	// handle spectator movement
; 2796 : 	CL_MoveSpectatorCamera();

	call	_CL_MoveSpectatorCamera

; 2797 : 
; 2798 : 	// catch changes video settings
; 2799 : 	VID_CheckChanges();

	call	_VID_CheckChanges

; 2800 : 
; 2801 : 	// process VGUI
; 2802 : 	VGui_RunFrame ();

	call	_VGui_RunFrame

; 2803 : 
; 2804 : 	// update the screen
; 2805 : 	SCR_UpdateScreen ();

	call	_SCR_UpdateScreen

; 2806 : 
; 2807 : 	// update audio
; 2808 : 	SND_UpdateSound ();

	call	_SND_UpdateSound

; 2809 : 
; 2810 : 	// play avi-files
; 2811 : 	SCR_RunCinematic ();

	call	_SCR_RunCinematic

; 2812 : 
; 2813 : 	// adjust client time
; 2814 : 	CL_AdjustClock ();

	call	_CL_AdjustClock
$LN1@Host_Clien:

; 2815 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Host_ClientFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _Host_ClientBegin
_TEXT	SEGMENT
_Host_ClientBegin PROC					; COMDAT

; 2736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2737 : 	// if client is not active, do nothing
; 2738 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@Host_Clien
	jmp	SHORT $LN1@Host_Clien
$LN2@Host_Clien:

; 2739 : 
; 2740 : 	// exec console commands
; 2741 : 	Cbuf_Execute ();

	call	_Cbuf_Execute

; 2742 : 
; 2743 : 	// finalize connection process if needs
; 2744 : 	CL_CheckClientState();

	call	_CL_CheckClientState

; 2745 : 
; 2746 : 	// tell the client.dll about client data
; 2747 : 	CL_UpdateClientData();

	call	_CL_UpdateClientData

; 2748 : 
; 2749 : 	// if running the server locally, make intentions now
; 2750 : 	if( SV_Active( )) CL_SendCommand ();

	call	_SV_Active
	test	eax, eax
	je	SHORT $LN1@Host_Clien
	call	_CL_SendCommand
$LN1@Host_Clien:

; 2751 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Host_ClientBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Shutdown
_TEXT	SEGMENT
_CL_Shutdown PROC					; COMDAT

; 2853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2854 : 	// already freed
; 2855 : 	if( !cls.initialized ) return;

	cmp	DWORD PTR _cls+4, 0
	jne	SHORT $LN2@CL_Shutdow
	jmp	SHORT $LN1@CL_Shutdow
$LN2@CL_Shutdow:

; 2856 : 	cls.initialized = false;

	mov	DWORD PTR _cls+4, 0

; 2857 : 
; 2858 : 	Con_Printf( "CL_Shutdown()\n" );

	push	OFFSET ??_C@_0P@BLEODOCM@CL_Shutdown?$CI?$CJ?6@
	call	_Con_Printf
	add	esp, 4

; 2859 : 
; 2860 : 	Host_WriteOpenGLConfig ();

	call	_Host_WriteOpenGLConfig

; 2861 : 	Host_WriteVideoConfig ();

	call	_Host_WriteVideoConfig

; 2862 : 
; 2863 : 	CL_CloseDemoHeader();

	call	_CL_CloseDemoHeader

; 2864 : 	IN_Shutdown ();

	call	_IN_Shutdown

; 2865 : 	SCR_Shutdown ();

	call	_SCR_Shutdown

; 2866 : 	CL_UnloadProgs ();

	call	_CL_UnloadProgs

; 2867 : 
; 2868 : 	FS_Delete( "demoheader.tmp" ); // remove tmp file

	push	OFFSET ??_C@_0P@FDJBLPMJ@demoheader?4tmp@
	call	_FS_Delete
	add	esp, 4

; 2869 : 	SCR_FreeCinematic (); // release AVI's *after* client.dll because custom renderer may use them

	call	_SCR_FreeCinematic

; 2870 : 	S_Shutdown ();

	call	_S_Shutdown

; 2871 : 	R_Shutdown ();

	call	_R_Shutdown

; 2872 : 
; 2873 : 	Con_Shutdown ();

	call	_Con_Shutdown
$LN1@CL_Shutdow:

; 2874 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_main.c
;	COMDAT _CL_Init
_TEXT	SEGMENT
_CL_Init PROC						; COMDAT

; 2825 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2826 : 	if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@CL_Init

; 2827 : 		return; // nothing running on the client

	jmp	$LN1@CL_Init
$LN2@CL_Init:

; 2828 : 
; 2829 : 	CL_InitLocal();

	call	_CL_InitLocal

; 2830 : 
; 2831 : 	R_Init();	// init renderer

	call	_R_Init

; 2832 : 	S_Init();	// init sound

	call	_S_Init

; 2833 : 
; 2834 : 	// unreliable buffer. unsed for unreliable commands and voice stream
; 2835 : 	MSG_Init( &cls.datagram, "cls.datagram", cls.datagram_buf, sizeof( cls.datagram_buf ));

	push	-1
	push	16384					; 00004000H
	push	OFFSET _cls+10412
	push	OFFSET ??_C@_0N@ONJNAGAI@cls?4datagram@
	push	OFFSET _cls+10392
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2836 : 
; 2837 : 	if( !CL_LoadProgs( va( "%s/client.dll", GI->dll_path )))

	mov	eax, DWORD PTR _SI+768
	add	eax, 452				; 000001c4H
	push	eax
	push	OFFSET ??_C@_0O@GJDENGBI@?$CFs?1client?4dll@
	call	_va
	add	esp, 8
	push	eax
	call	_CL_LoadProgs
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@CL_Init

; 2838 : 		Host_Error( "can't initialize client.dll\n" );

	push	OFFSET ??_C@_0BN@JKJBEKAB@can?8t?5initialize?5client?4dll?6@
	call	_Host_Error
	add	esp, 4
$LN3@CL_Init:

; 2839 : 
; 2840 : 	cls.initialized = true;

	mov	DWORD PTR _cls+4, 1

; 2841 : 	cl.maxclients = 1; // allow to drawing player in menu

	mov	DWORD PTR _cl+2213004, 1

; 2842 : 	cls.olddemonum = -1;

	mov	DWORD PTR _cls+296716, -1

; 2843 : 	cls.demonum = -1;

	mov	DWORD PTR _cls+296712, -1
$LN1@CL_Init:

; 2844 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Init ENDP
_TEXT	ENDS
END
