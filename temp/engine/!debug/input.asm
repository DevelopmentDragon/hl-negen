; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\input.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_in_mousecursor:DWORD
COMM	_in_mouseactive:DWORD
COMM	_in_restore_spi:DWORD
COMM	_in_mouseinitialized:DWORD
COMM	_in_mouse_oldbuttonstate:DWORD
COMM	_in_mouse_suspended:DWORD
COMM	_in_mouse_savedpos:DWORD
COMM	_in_mouse_buttons:DWORD
COMM	_window_rect:BYTE:010H
COMM	_real_rect:BYTE:010H
COMM	_in_lastvalidpos:QWORD
COMM	_in_mouse_wheel:DWORD
COMM	_wnd_caption:DWORD
_DATA	ENDS
PUBLIC	_IN_Init
PUBLIC	_Host_InputFrame
PUBLIC	_IN_Shutdown
PUBLIC	_IN_MouseEvent
PUBLIC	_IN_ActivateMouse
PUBLIC	_IN_DeactivateMouse
PUBLIC	_IN_MouseSavePos
PUBLIC	_IN_MouseRestorePos
PUBLIC	_IN_ToggleClientMouse
PUBLIC	_IN_WndProc
PUBLIC	_IN_SetCursor
PUBLIC	_IN_StartupMouse
PUBLIC	_IN_RecalcCenter
PUBLIC	_IN_MouseMove
PUBLIC	??_C@_08GPADOFHN@?9nomouse@			; `string'
PUBLIC	??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@		; `string'
PUBLIC	??_C@_0L@GIACNHMO@fullscreen@			; `string'
PUBLIC	??_C@_0N@FDEDDELO@_window_xpos@			; `string'
PUBLIC	??_C@_0N@GOCDBNAO@_window_ypos@			; `string'
PUBLIC	??_C@_0O@CDJNHCDO@clipboard?4bmp@		; `string'
PUBLIC	__real@00000000
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__RegisterHotKey@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetCapture@4:PROC
EXTRN	__imp__ReleaseCapture@0:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__ClipCursor@4:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_SendKeyEvents:PROC
EXTRN	_Sys_Quit:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_CL_Active:PROC
EXTRN	_Key_Event:PROC
EXTRN	_Key_ClearStates:PROC
EXTRN	_CL_CharEvent:PROC
EXTRN	_CL_IsBackgroundDemo:PROC
EXTRN	_CL_IsBackgroundMap:PROC
EXTRN	_S_Activate:PROC
EXTRN	_UI_MouseMove:PROC
EXTRN	_UI_ShowCursor:PROC
EXTRN	_UI_MouseInRect:PROC
EXTRN	_UI_IsVisible:PROC
EXTRN	_VGUI_SurfaceWndProc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?oldstate@?1??IN_ActivateMouse@@9@9 DD 01H DUP (?)	; `IN_ActivateMouse'::`2'::oldstate
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0O@CDJNHCDO@clipboard?4bmp@
CONST	SEGMENT
??_C@_0O@CDJNHCDO@clipboard?4bmp@ DB 'clipboard.bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOCDBNAO@_window_ypos@
CONST	SEGMENT
??_C@_0N@GOCDBNAO@_window_ypos@ DB '_window_ypos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDEDDELO@_window_xpos@
CONST	SEGMENT
??_C@_0N@FDEDDELO@_window_xpos@ DB '_window_xpos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GIACNHMO@fullscreen@
CONST	SEGMENT
??_C@_0L@GIACNHMO@fullscreen@ DB 'fullscreen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@
CONST	SEGMENT
??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@ DB 'MSWHEEL_ROLLMSG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPADOFHN@?9nomouse@
CONST	SEGMENT
??_C@_08GPADOFHN@?9nomouse@ DB '-nomouse', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_scan_to_key DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	07fH
	DB	09H
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	085H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03bH
	DB	027H
	DB	060H
	DB	086H
	DB	05cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	086H
	DB	02aH
	DB	084H
	DB	020H
	DB	0afH
	DB	087H
	DB	088H
	DB	089H
	DB	08aH
	DB	08bH
	DB	08cH
	DB	08dH
	DB	08eH
	DB	08fH
	DB	090H
	DB	0ffH
	DB	046H
	DB	097H
	DB	080H
	DB	096H
	DB	0adH
	DB	082H
	DB	0a4H
	DB	083H
	DB	0aeH
	DB	098H
	DB	081H
	DB	095H
	DB	093H
	DB	094H
	DB	00H
	DB	00H
	DB	00H
	DB	091H
	DB	092H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_mouse_buttons DD 01H
	DD	02H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	04f1H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_MouseMove
_TEXT	SEGMENT
_current_pos$ = -8					; size = 8
_IN_MouseMove PROC					; COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 347  : 	POINT	current_pos;
; 348  : 	
; 349  : 	if( !in_mouseinitialized || !in_mouseactive || !UI_IsVisible( ))

	cmp	DWORD PTR _in_mouseinitialized, 0
	je	SHORT $LN3@IN_MouseMo
	cmp	DWORD PTR _in_mouseactive, 0
	je	SHORT $LN3@IN_MouseMo
	call	_UI_IsVisible
	test	eax, eax
	jne	SHORT $LN2@IN_MouseMo
$LN3@IN_MouseMo:

; 350  : 		return;

	jmp	SHORT $LN1@IN_MouseMo
$LN2@IN_MouseMo:

; 351  : 
; 352  : 	// find mouse movement
; 353  : 	GetCursorPos( &current_pos );

	lea	eax, DWORD PTR _current_pos$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 354  : 	ScreenToClient( host.hWnd, &current_pos );

	lea	eax, DWORD PTR _current_pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ScreenToClient@8

; 355  : 
; 356  : 	// if the menu is visible, move the menu cursor
; 357  : 	UI_MouseMove( current_pos.x, current_pos.y );

	mov	eax, DWORD PTR _current_pos$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _current_pos$[ebp]
	push	ecx
	call	_UI_MouseMove
	add	esp, 8

; 358  : 
; 359  : 	IN_ActivateCursor();

	call	_IN_ActivateCursor
$LN1@IN_MouseMo:

; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_MouseMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_RecalcCenter
_TEXT	SEGMENT
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_setpos$ = 8						; size = 4
_IN_RecalcCenter PROC					; COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 238  : 	int	width, height;
; 239  : 
; 240  : 	if( host.status != HOST_FRAME )

	cmp	DWORD PTR _host+12, 1
	je	SHORT $LN2@IN_RecalcC

; 241  : 		return;

	jmp	$LN1@IN_RecalcC
$LN2@IN_RecalcC:

; 242  : 
; 243  : 	width = GetSystemMetrics( SM_CXSCREEN );

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _width$[ebp], eax

; 244  : 	height = GetSystemMetrics( SM_CYSCREEN );

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _height$[ebp], eax

; 245  : 	GetWindowRect( host.hWnd, &window_rect );

	push	OFFSET _window_rect
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8

; 246  : 	if( window_rect.left < 0 ) window_rect.left = 0;

	cmp	DWORD PTR _window_rect, 0
	jge	SHORT $LN3@IN_RecalcC
	mov	DWORD PTR _window_rect, 0
$LN3@IN_RecalcC:

; 247  : 	if( window_rect.top < 0 ) window_rect.top = 0;

	cmp	DWORD PTR _window_rect+4, 0
	jge	SHORT $LN4@IN_RecalcC
	mov	DWORD PTR _window_rect+4, 0
$LN4@IN_RecalcC:

; 248  : 	if( window_rect.right >= width ) window_rect.right = width - 1;

	mov	eax, DWORD PTR _window_rect+8
	cmp	eax, DWORD PTR _width$[ebp]
	jl	SHORT $LN5@IN_RecalcC
	mov	eax, DWORD PTR _width$[ebp]
	sub	eax, 1
	mov	DWORD PTR _window_rect+8, eax
$LN5@IN_RecalcC:

; 249  : 	if( window_rect.bottom >= height - 1 ) window_rect.bottom = height - 1;

	mov	eax, DWORD PTR _height$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _window_rect+12, eax
	jl	SHORT $LN6@IN_RecalcC
	mov	eax, DWORD PTR _height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _window_rect+12, eax
$LN6@IN_RecalcC:

; 250  : 
; 251  : 	host.window_center_x = (window_rect.right + window_rect.left) / 2;

	mov	eax, DWORD PTR _window_rect+8
	add	eax, DWORD PTR _window_rect
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _host+34756, eax

; 252  : 	host.window_center_y = (window_rect.top + window_rect.bottom) / 2;

	mov	eax, DWORD PTR _window_rect+4
	add	eax, DWORD PTR _window_rect+12
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _host+34760, eax

; 253  : 	if( setpos ) SetCursorPos( host.window_center_x, host.window_center_y );

	cmp	DWORD PTR _setpos$[ebp], 0
	je	SHORT $LN1@IN_RecalcC
	mov	eax, DWORD PTR _host+34760
	push	eax
	mov	ecx, DWORD PTR _host+34756
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8
$LN1@IN_RecalcC:

; 254  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_RecalcCenter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_ActivateCursor
_TEXT	SEGMENT
_IN_ActivateCursor PROC					; COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 153  : 	if( cls.key_dest == key_menu )

	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN1@IN_Activat

; 154  : 	{
; 155  : 		SetCursor( in_mousecursor );

	mov	eax, DWORD PTR _in_mousecursor
	push	eax
	call	DWORD PTR __imp__SetCursor@4
$LN1@IN_Activat:

; 156  : 	}
; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_ActivateCursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_CursorInRect
_TEXT	SEGMENT
_curpos$ = -8						; size = 8
_IN_CursorInRect PROC					; COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 132  : 	POINT	curpos;
; 133  : 	
; 134  : 	if( !in_mouseinitialized || !in_mouseactive )

	cmp	DWORD PTR _in_mouseinitialized, 0
	je	SHORT $LN3@IN_CursorI
	cmp	DWORD PTR _in_mouseactive, 0
	jne	SHORT $LN2@IN_CursorI
$LN3@IN_CursorI:

; 135  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@IN_CursorI
$LN2@IN_CursorI:

; 136  : 
; 137  : 	// find mouse movement
; 138  : 	GetCursorPos( &curpos );

	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 139  : 
; 140  : 	if( curpos.x < real_rect.left + WND_BORDER )

	mov	eax, DWORD PTR _real_rect
	add	eax, 3
	cmp	DWORD PTR _curpos$[ebp], eax
	jge	SHORT $LN4@IN_CursorI

; 141  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@IN_CursorI
$LN4@IN_CursorI:

; 142  : 	if( curpos.x > real_rect.right - WND_BORDER * 3 )

	mov	eax, DWORD PTR _real_rect+8
	sub	eax, 9
	cmp	DWORD PTR _curpos$[ebp], eax
	jle	SHORT $LN5@IN_CursorI

; 143  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@IN_CursorI
$LN5@IN_CursorI:

; 144  : 	if( curpos.y < real_rect.top + WND_HEADSIZE + WND_BORDER )

	mov	eax, DWORD PTR _wnd_caption
	mov	ecx, DWORD PTR _real_rect+4
	lea	edx, DWORD PTR [ecx+eax+3]
	cmp	DWORD PTR _curpos$[ebp+4], edx
	jge	SHORT $LN6@IN_CursorI

; 145  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@IN_CursorI
$LN6@IN_CursorI:

; 146  : 	if( curpos.y > real_rect.bottom - WND_BORDER * 3 )

	mov	eax, DWORD PTR _real_rect+12
	sub	eax, 9
	cmp	DWORD PTR _curpos$[ebp+4], eax
	jle	SHORT $LN7@IN_CursorI

; 147  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@IN_CursorI
$LN7@IN_CursorI:

; 148  : 	return true;

	mov	eax, 1
$LN1@IN_CursorI:

; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_CursorInRect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_StartupMouse
_TEXT	SEGMENT
_IN_StartupMouse PROC					; COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 122  : 	if( host.type == HOST_DEDICATED ) return;

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN2@IN_Startup
	jmp	SHORT $LN1@IN_Startup
$LN2@IN_Startup:

; 123  : 	if( Sys_CheckParm( "-nomouse" )) return; 

	push	OFFSET ??_C@_08GPADOFHN@?9nomouse@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@IN_Startup
	jmp	SHORT $LN1@IN_Startup
$LN3@IN_Startup:

; 124  : 
; 125  : 	in_mouse_buttons = 8;

	mov	DWORD PTR _in_mouse_buttons, 8

; 126  : 	in_mouseinitialized = true;

	mov	DWORD PTR _in_mouseinitialized, 1

; 127  : 	in_mouse_wheel = RegisterWindowMessage( "MSWHEEL_ROLLMSG" );

	push	OFFSET ??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG@
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _in_mouse_wheel, eax
$LN1@IN_Startup:

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_StartupMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _Host_MapKey
_TEXT	SEGMENT
tv76 = -80						; size = 4
tv73 = -80						; size = 4
_is_extended$ = -12					; size = 4
_modified$ = -8						; size = 4
_result$ = -4						; size = 4
_key$ = 8						; size = 4
_Host_MapKey PROC					; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 74   : 	int	result, modified;
; 75   : 	qboolean	is_extended = false;

	mov	DWORD PTR _is_extended$[ebp], 0

; 76   : 
; 77   : 	modified = ( key >> 16 ) & 255;

	mov	eax, DWORD PTR _key$[ebp]
	sar	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _modified$[ebp], eax

; 78   : 	if( modified > 127 ) return 0;

	cmp	DWORD PTR _modified$[ebp], 127		; 0000007fH
	jle	SHORT $LN6@Host_MapKe
	xor	eax, eax
	jmp	$LN1@Host_MapKe
$LN6@Host_MapKe:

; 79   : 
; 80   : 	if( key & ( 1 << 24 ))

	mov	eax, DWORD PTR _key$[ebp]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN7@Host_MapKe

; 81   : 		is_extended = true;

	mov	DWORD PTR _is_extended$[ebp], 1
$LN7@Host_MapKe:

; 82   : 
; 83   : 	result = scan_to_key[modified];

	mov	eax, DWORD PTR _modified$[ebp]
	movzx	ecx, BYTE PTR _scan_to_key[eax]
	mov	DWORD PTR _result$[ebp], ecx

; 84   : 
; 85   : 	if( !is_extended )

	cmp	DWORD PTR _is_extended$[ebp], 0
	jne	SHORT $LN8@Host_MapKe

; 86   : 	{
; 87   : 		switch( result )

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	sub	ecx, 128				; 00000080H
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 24			; 00000018H
	ja	SHORT $LN20@Host_MapKe
	mov	edx, DWORD PTR tv73[ebp]
	movzx	eax, BYTE PTR $LN27@Host_MapKe[edx]
	jmp	DWORD PTR $LN28@Host_MapKe[eax*4]
$LN10@Host_MapKe:

; 88   : 		{
; 89   : 		case K_HOME: return K_KP_HOME;

	mov	eax, 160				; 000000a0H
	jmp	$LN1@Host_MapKe
$LN11@Host_MapKe:

; 90   : 		case K_UPARROW: return K_KP_UPARROW;

	mov	eax, 161				; 000000a1H
	jmp	$LN1@Host_MapKe
$LN12@Host_MapKe:

; 91   : 		case K_PGUP: return K_KP_PGUP;

	mov	eax, 162				; 000000a2H
	jmp	$LN1@Host_MapKe
$LN13@Host_MapKe:

; 92   : 		case K_LEFTARROW: return K_KP_LEFTARROW;

	mov	eax, 163				; 000000a3H
	jmp	SHORT $LN1@Host_MapKe
$LN14@Host_MapKe:

; 93   : 		case K_RIGHTARROW: return K_KP_RIGHTARROW;

	mov	eax, 165				; 000000a5H
	jmp	SHORT $LN1@Host_MapKe
$LN15@Host_MapKe:

; 94   : 		case K_END: return K_KP_END;

	mov	eax, 166				; 000000a6H
	jmp	SHORT $LN1@Host_MapKe
$LN16@Host_MapKe:

; 95   : 		case K_DOWNARROW: return K_KP_DOWNARROW;

	mov	eax, 167				; 000000a7H
	jmp	SHORT $LN1@Host_MapKe
$LN17@Host_MapKe:

; 96   : 		case K_PGDN: return K_KP_PGDN;

	mov	eax, 168				; 000000a8H
	jmp	SHORT $LN1@Host_MapKe
$LN18@Host_MapKe:

; 97   : 		case K_INS: return K_KP_INS;

	mov	eax, 170				; 000000aaH
	jmp	SHORT $LN1@Host_MapKe
$LN19@Host_MapKe:

; 98   : 		case K_DEL: return K_KP_DEL;

	mov	eax, 171				; 000000abH
	jmp	SHORT $LN1@Host_MapKe
$LN20@Host_MapKe:

; 99   : 		default: return result;

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@Host_MapKe

; 100  : 		}
; 101  : 	}

	jmp	SHORT $LN1@Host_MapKe
$LN8@Host_MapKe:

; 102  : 	else
; 103  : 	{
; 104  : 		switch( result )

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, 13					; 0000000dH
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 242		; 000000f2H
	ja	SHORT $LN25@Host_MapKe
	mov	edx, DWORD PTR tv76[ebp]
	movzx	eax, BYTE PTR $LN29@Host_MapKe[edx]
	jmp	DWORD PTR $LN30@Host_MapKe[eax*4]
$LN21@Host_MapKe:

; 105  : 		{
; 106  : 		case K_PAUSE: return K_KP_NUMLOCK;

	mov	eax, 176				; 000000b0H
	jmp	SHORT $LN1@Host_MapKe
$LN22@Host_MapKe:

; 107  : 		case 0x0D: return K_KP_ENTER;

	mov	eax, 169				; 000000a9H
	jmp	SHORT $LN1@Host_MapKe
$LN23@Host_MapKe:

; 108  : 		case 0x2F: return K_KP_SLASH;

	mov	eax, 172				; 000000acH
	jmp	SHORT $LN1@Host_MapKe
$LN24@Host_MapKe:

; 109  : 		case 0xAF: return K_KP_PLUS;

	mov	eax, 174				; 000000aeH
	jmp	SHORT $LN1@Host_MapKe
$LN25@Host_MapKe:

; 110  : 		default: return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Host_MapKe:

; 111  : 		}
; 112  : 	}
; 113  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@Host_MapKe:
	DD	$LN11@Host_MapKe
	DD	$LN16@Host_MapKe
	DD	$LN13@Host_MapKe
	DD	$LN14@Host_MapKe
	DD	$LN18@Host_MapKe
	DD	$LN19@Host_MapKe
	DD	$LN17@Host_MapKe
	DD	$LN12@Host_MapKe
	DD	$LN10@Host_MapKe
	DD	$LN15@Host_MapKe
	DD	$LN20@Host_MapKe
$LN27@Host_MapKe:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	npad	3
$LN30@Host_MapKe:
	DD	$LN22@Host_MapKe
	DD	$LN23@Host_MapKe
	DD	$LN24@Host_MapKe
	DD	$LN21@Host_MapKe
	DD	$LN25@Host_MapKe
$LN29@Host_MapKe:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_Host_MapKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_SetCursor
_TEXT	SEGMENT
_hCursor$ = 8						; size = 4
_IN_SetCursor PROC					; COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : 	in_mousecursor = hCursor;

	mov	eax, DWORD PTR _hCursor$[ebp]
	mov	DWORD PTR _in_mousecursor, eax

; 162  : 
; 163  : 	IN_ActivateCursor();

	call	_IN_ActivateCursor

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_SetCursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_WndProc
_TEXT	SEGMENT
tv197 = -116						; size = 4
tv294 = -112						; size = 4
tv216 = -112						; size = 4
tv138 = -112						; size = 4
tv65 = -112						; size = 4
_style$1 = -44						; size = 4
_yPos$2 = -40						; size = 4
_xPos$3 = -36						; size = 4
_rect$4 = -32						; size = 16
_fActivate$ = -16					; size = 4
_temp$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_IN_WndProc PROC					; COMDAT

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 463  : 	int	i, temp = 0;

	mov	DWORD PTR _temp$[ebp], 0

; 464  : 	qboolean	fActivate;
; 465  : 
; 466  : 	if( uMsg == in_mouse_wheel )

	mov	eax, DWORD PTR _uMsg$[ebp]
	cmp	eax, DWORD PTR _in_mouse_wheel
	jne	SHORT $LN9@IN_WndProc

; 467  : 		uMsg = WM_MOUSEWHEEL;

	mov	DWORD PTR _uMsg$[ebp], 522		; 0000020aH
$LN9@IN_WndProc:

; 468  : 
; 469  : 	VGUI_SurfaceWndProc( hWnd, uMsg, wParam, lParam );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	_VGUI_SurfaceWndProc
	add	esp, 16					; 00000010H

; 470  : 
; 471  : 	switch( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	ja	SHORT $LN57@IN_WndProc
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	je	$LN18@IN_WndProc
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 7
	ja	$LN2@IN_WndProc
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN60@IN_WndProc[edx*4]
$LN57@IN_WndProc:
	cmp	DWORD PTR tv65[ebp], 274		; 00000112H
	ja	SHORT $LN58@IN_WndProc
	cmp	DWORD PTR tv65[ebp], 274		; 00000112H
	je	$LN40@IN_WndProc
	mov	eax, DWORD PTR tv65[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 229		; 000000e5H
	ja	$LN2@IN_WndProc
	mov	ecx, DWORD PTR tv65[ebp]
	movzx	edx, BYTE PTR $LN61@IN_WndProc[ecx]
	jmp	DWORD PTR $LN62@IN_WndProc[edx*4]
$LN58@IN_WndProc:
	cmp	DWORD PTR tv65[ebp], 786		; 00000312H
	ja	SHORT $LN59@IN_WndProc
	cmp	DWORD PTR tv65[ebp], 786		; 00000312H
	je	$LN50@IN_WndProc
	mov	eax, DWORD PTR tv65[ebp]
	sub	eax, 512				; 00000200H
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 12			; 0000000cH
	ja	$LN2@IN_WndProc
	mov	ecx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN63@IN_WndProc[ecx*4]
$LN59@IN_WndProc:
	jmp	$LN2@IN_WndProc
$LN10@IN_WndProc:

; 472  : 	{
; 473  : 	case WM_KILLFOCUS:
; 474  : 		if( Cvar_VariableInteger( "fullscreen" ))

	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@IN_WndProc

; 475  : 			ShowWindow( host.hWnd, SW_SHOWMINNOACTIVE );

	push	7
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN11@IN_WndProc:

; 476  : 		break;

	jmp	$LN2@IN_WndProc
$LN12@IN_WndProc:

; 477  : 	case WM_SETCURSOR:
; 478  : 		IN_ActivateCursor();

	call	_IN_ActivateCursor

; 479  : 		break;

	jmp	$LN2@IN_WndProc
$LN13@IN_WndProc:

; 480  : 	case WM_MOUSEWHEEL:
; 481  : 		if( !in_mouseactive )

	cmp	DWORD PTR _in_mouseactive, 0
	jne	SHORT $LN14@IN_WndProc

; 482  : 			break;

	jmp	$LN2@IN_WndProc
$LN14@IN_WndProc:

; 483  : 		if(( short )HIWORD( wParam ) > 0 )

	mov	eax, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	test	ecx, ecx
	jle	SHORT $LN15@IN_WndProc

; 484  : 		{
; 485  : 			Key_Event( K_MWHEELUP, true );

	push	1
	push	240					; 000000f0H
	call	_Key_Event
	add	esp, 8

; 486  : 			Key_Event( K_MWHEELUP, false );

	push	0
	push	240					; 000000f0H
	call	_Key_Event
	add	esp, 8

; 487  : 		}

	jmp	SHORT $LN16@IN_WndProc
$LN15@IN_WndProc:

; 488  : 		else
; 489  : 		{
; 490  : 			Key_Event( K_MWHEELDOWN, true );

	push	1
	push	239					; 000000efH
	call	_Key_Event
	add	esp, 8

; 491  : 			Key_Event( K_MWHEELDOWN, false );

	push	0
	push	239					; 000000efH
	call	_Key_Event
	add	esp, 8
$LN16@IN_WndProc:

; 492  : 		}
; 493  : 		break;

	jmp	$LN2@IN_WndProc
$LN17@IN_WndProc:

; 494  : 	case WM_CREATE:
; 495  : 		host.hWnd = hWnd;

	mov	eax, DWORD PTR _hWnd$[ebp]
	mov	DWORD PTR _host+34332, eax

; 496  : 		GetWindowRect( host.hWnd, &real_rect );

	push	OFFSET _real_rect
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8

; 497  : 		RegisterHotKey( host.hWnd, PRINTSCREEN_ID, 0, VK_SNAPSHOT );

	push	44					; 0000002cH
	push	0
	push	1
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__RegisterHotKey@16

; 498  : 		break;

	jmp	$LN2@IN_WndProc
$LN18@IN_WndProc:

; 499  : 	case WM_CLOSE:
; 500  : 		Sys_Quit();

	call	_Sys_Quit

; 501  : 		break;

	jmp	$LN2@IN_WndProc
$LN19@IN_WndProc:

; 502  : 	case WM_ACTIVATE:
; 503  : 		if( host.status == HOST_SHUTDOWN )

	cmp	DWORD PTR _host+12, 2
	jne	SHORT $LN20@IN_WndProc

; 504  : 			break; // no need to activate

	jmp	$LN2@IN_WndProc
$LN20@IN_WndProc:

; 505  : 		if( HIWORD( wParam ))

	mov	eax, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN21@IN_WndProc

; 506  : 			host.status = HOST_SLEEP;

	mov	DWORD PTR _host+12, 4
	jmp	SHORT $LN24@IN_WndProc
$LN21@IN_WndProc:

; 507  : 		else if( LOWORD( wParam ) == WA_INACTIVE )

	mov	eax, DWORD PTR _wParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN23@IN_WndProc

; 508  : 			host.status = HOST_NOFOCUS;

	mov	DWORD PTR _host+12, 5
	jmp	SHORT $LN24@IN_WndProc
$LN23@IN_WndProc:

; 509  : 		else host.status = HOST_FRAME;

	mov	DWORD PTR _host+12, 1
$LN24@IN_WndProc:

; 510  : 		fActivate = (host.status == HOST_FRAME) ? true : false;

	cmp	DWORD PTR _host+12, 1
	jne	SHORT $LN53@IN_WndProc
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN54@IN_WndProc
$LN53@IN_WndProc:
	mov	DWORD PTR tv138[ebp], 0
$LN54@IN_WndProc:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _fActivate$[ebp], eax

; 511  : 		wnd_caption = GetSystemMetrics( SM_CYCAPTION ) + WND_BORDER;

	push	4
	call	DWORD PTR __imp__GetSystemMetrics@4
	add	eax, 3
	mov	DWORD PTR _wnd_caption, eax

; 512  : 
; 513  : 		S_Activate( fActivate, host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	mov	ecx, DWORD PTR _fActivate$[ebp]
	push	ecx
	call	_S_Activate
	add	esp, 8

; 514  : 		IN_ActivateMouse( fActivate );

	mov	eax, DWORD PTR _fActivate$[ebp]
	push	eax
	call	_IN_ActivateMouse
	add	esp, 4

; 515  : 		Key_ClearStates();

	call	_Key_ClearStates

; 516  : 		IN_RecalcCenter( false );

	push	0
	call	_IN_RecalcCenter
	add	esp, 4

; 517  : 
; 518  : 		if( host.status == HOST_FRAME )

	cmp	DWORD PTR _host+12, 1
	jne	SHORT $LN25@IN_WndProc

; 519  : 		{
; 520  : 			SetForegroundWindow( hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 521  : 			ShowWindow( hWnd, SW_RESTORE );

	push	9
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 522  : 		}

	jmp	SHORT $LN27@IN_WndProc
$LN25@IN_WndProc:

; 523  : 		else if( Cvar_VariableInteger( "fullscreen" ))

	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@IN_WndProc

; 524  : 		{
; 525  : 			ShowWindow( hWnd, SW_MINIMIZE );

	push	6
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN27@IN_WndProc:

; 526  : 		}
; 527  : 		break;

	jmp	$LN2@IN_WndProc
$LN28@IN_WndProc:

; 528  : 	case WM_MOVE:
; 529  : 		if( !Cvar_VariableInteger( "fullscreen" ))

	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN29@IN_WndProc

; 530  : 		{
; 531  : 			RECT	rect;
; 532  : 			int	xPos, yPos, style;
; 533  : 
; 534  : 			xPos = (short)LOWORD( lParam );    // horizontal position 

	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	mov	DWORD PTR _xPos$3[ebp], ecx

; 535  : 			yPos = (short)HIWORD( lParam );    // vertical position 

	mov	eax, DWORD PTR _lParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	mov	DWORD PTR _yPos$2[ebp], ecx

; 536  : 
; 537  : 			rect.left = rect.top = 0;

	mov	DWORD PTR _rect$4[ebp+4], 0
	mov	eax, DWORD PTR _rect$4[ebp+4]
	mov	DWORD PTR _rect$4[ebp], eax

; 538  : 			rect.right = rect.bottom = 1;

	mov	DWORD PTR _rect$4[ebp+12], 1
	mov	eax, DWORD PTR _rect$4[ebp+12]
	mov	DWORD PTR _rect$4[ebp+8], eax

; 539  : 			style = GetWindowLong( hWnd, GWL_STYLE );

	push	-16					; fffffff0H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	mov	DWORD PTR _style$1[ebp], eax

; 540  : 			AdjustWindowRect( &rect, style, FALSE );

	push	0
	mov	eax, DWORD PTR _style$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _rect$4[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRect@12

; 541  : 
; 542  : 			Cvar_SetValue( "_window_xpos", xPos + rect.left );

	mov	eax, DWORD PTR _xPos$3[ebp]
	add	eax, DWORD PTR _rect$4[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0N@FDEDDELO@_window_xpos@
	call	_Cvar_SetValue
	add	esp, 8

; 543  : 			Cvar_SetValue( "_window_ypos", yPos + rect.top );

	mov	eax, DWORD PTR _yPos$2[ebp]
	add	eax, DWORD PTR _rect$4[ebp+4]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0N@GOCDBNAO@_window_ypos@
	call	_Cvar_SetValue
	add	esp, 8

; 544  : 			GetWindowRect( host.hWnd, &real_rect );

	push	OFFSET _real_rect
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8
$LN29@IN_WndProc:

; 545  : 		}
; 546  : 		break;

	jmp	$LN2@IN_WndProc
$LN30@IN_WndProc:

; 547  : 	case WM_LBUTTONDOWN:
; 548  : 	case WM_LBUTTONUP:
; 549  : 	case WM_RBUTTONDOWN:
; 550  : 	case WM_RBUTTONUP:
; 551  : 	case WM_MBUTTONDOWN:
; 552  : 	case WM_MBUTTONUP:
; 553  : 	case WM_XBUTTONDOWN:
; 554  : 	case WM_XBUTTONUP:
; 555  : 	case WM_MOUSEMOVE:
; 556  : 		for( i = 0; i < in_mouse_buttons; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@IN_WndProc
$LN4@IN_WndProc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@IN_WndProc:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _in_mouse_buttons
	jge	SHORT $LN5@IN_WndProc

; 557  : 		{
; 558  : 			if( wParam & mouse_buttons[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _wParam$[ebp]
	and	ecx, DWORD PTR _mouse_buttons[eax*4]
	je	SHORT $LN39@IN_WndProc

; 559  : 				temp |= (1<<i);

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _temp$[ebp], eax
$LN39@IN_WndProc:

; 560  : 		}

	jmp	SHORT $LN4@IN_WndProc
$LN5@IN_WndProc:

; 561  : 		IN_MouseEvent( temp );

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_IN_MouseEvent
	add	esp, 4

; 562  : 		break;

	jmp	$LN2@IN_WndProc
$LN40@IN_WndProc:

; 563  : 	case WM_SYSCOMMAND:
; 564  : 		// never turn screensaver or display off while Xash is active
; 565  : 		if(( wParam == SC_SCREENSAVE || wParam == SC_MONITORPOWER ) && host.status != HOST_SLEEP )

	cmp	DWORD PTR _wParam$[ebp], 61760		; 0000f140H
	je	SHORT $LN42@IN_WndProc
	cmp	DWORD PTR _wParam$[ebp], 61808		; 0000f170H
	jne	SHORT $LN41@IN_WndProc
$LN42@IN_WndProc:
	cmp	DWORD PTR _host+12, 4
	je	SHORT $LN41@IN_WndProc

; 566  : 			return 0;

	xor	eax, eax
	jmp	$LN1@IN_WndProc
$LN41@IN_WndProc:

; 567  : 		break;

	jmp	$LN2@IN_WndProc
$LN43@IN_WndProc:

; 568  : 	case WM_SYSKEYDOWN:
; 569  : 		if( wParam == VK_RETURN )

	cmp	DWORD PTR _wParam$[ebp], 13		; 0000000dH
	jne	SHORT $LN44@IN_WndProc

; 570  : 		{
; 571  : 			// alt+enter fullscreen switch
; 572  : 			Cvar_SetValue( "fullscreen", !Cvar_VariableValue( "fullscreen" ));

	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableValue
	add	esp, 4
	fstp	DWORD PTR tv294[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN55@IN_WndProc
	mov	DWORD PTR tv197[ebp], 1
	jmp	SHORT $LN56@IN_WndProc
$LN55@IN_WndProc:
	mov	DWORD PTR tv197[ebp], 0
$LN56@IN_WndProc:
	cvtsi2ss xmm0, DWORD PTR tv197[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_SetValue
	add	esp, 8

; 573  : 			return 0;

	xor	eax, eax
	jmp	$LN1@IN_WndProc
$LN44@IN_WndProc:

; 574  : 		}
; 575  : 		// intentional fallthrough
; 576  : 	case WM_KEYDOWN:
; 577  : 		Key_Event( Host_MapKey( lParam ), true );

	push	1
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	call	_Host_MapKey
	add	esp, 4
	push	eax
	call	_Key_Event
	add	esp, 8

; 578  : 		if( Host_MapKey( lParam ) == K_ALT )

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	call	_Host_MapKey
	add	esp, 4
	cmp	eax, 132				; 00000084H
	jne	SHORT $LN46@IN_WndProc

; 579  : 			return 0;	// prevent WC_SYSMENU call

	xor	eax, eax
	jmp	$LN1@IN_WndProc
$LN46@IN_WndProc:

; 580  : 		break;

	jmp	SHORT $LN2@IN_WndProc
$LN47@IN_WndProc:

; 581  : 	case WM_SYSKEYUP:
; 582  : 	case WM_KEYUP:
; 583  : 		Key_Event( Host_MapKey( lParam ), false );

	push	0
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	call	_Host_MapKey
	add	esp, 4
	push	eax
	call	_Key_Event
	add	esp, 8

; 584  : 		break;

	jmp	SHORT $LN2@IN_WndProc
$LN49@IN_WndProc:

; 585  : 	case WM_CHAR:
; 586  : 		CL_CharEvent( wParam );

	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_CL_CharEvent
	add	esp, 4

; 587  : 		break;

	jmp	SHORT $LN2@IN_WndProc
$LN50@IN_WndProc:

; 588  : 	case WM_HOTKEY:
; 589  : 		switch( LOWORD( wParam ))

	mov	eax, DWORD PTR _wParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	mov	DWORD PTR tv216[ebp], ecx
	cmp	DWORD PTR tv216[ebp], 1
	je	SHORT $LN51@IN_WndProc
	jmp	SHORT $LN7@IN_WndProc
$LN51@IN_WndProc:

; 590  : 		{
; 591  : 		case PRINTSCREEN_ID:
; 592  : 			// anti FiEctro system: prevent to write snapshot without Xash version
; 593  : 			Q_strncpy( cls.shotname, "clipboard.bmp", sizeof( cls.shotname ));

	push	256					; 00000100H
	push	OFFSET ??_C@_0O@CDJNHCDO@clipboard?4bmp@
	push	OFFSET _cls+296324
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 594  : 			cls.scrshot_action = scrshot_snapshot; // build new frame for screenshot

	mov	DWORD PTR _cls+296308, 2

; 595  : 			host.write_to_clipboard = true;

	mov	DWORD PTR _host+34384, 1

; 596  : 			cls.envshot_vieworg = NULL;

	mov	DWORD PTR _cls+296312, 0
$LN7@IN_WndProc:
$LN2@IN_WndProc:

; 597  : 			break;
; 598  : 		}
; 599  : 		break;
; 600  : 	}
; 601  : 
; 602  : 	return DefWindowProc( hWnd, uMsg, wParam, lParam );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
$LN1@IN_WndProc:

; 603  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN60@IN_WndProc:
	DD	$LN17@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN28@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN19@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN10@IN_WndProc
$LN62@IN_WndProc:
	DD	$LN12@IN_WndProc
	DD	$LN44@IN_WndProc
	DD	$LN47@IN_WndProc
	DD	$LN49@IN_WndProc
	DD	$LN43@IN_WndProc
	DD	$LN2@IN_WndProc
$LN61@IN_WndProc:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	3
	DB	5
	DB	4
	DB	2
	npad	2
$LN63@IN_WndProc:
	DD	$LN30@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN2@IN_WndProc
	DD	$LN13@IN_WndProc
	DD	$LN30@IN_WndProc
	DD	$LN30@IN_WndProc
_IN_WndProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_ToggleClientMouse
_TEXT	SEGMENT
_newstate$ = 8						; size = 4
_oldstate$ = 12						; size = 4
_IN_ToggleClientMouse PROC				; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 207  : 	if( newstate == oldstate ) return;

	mov	eax, DWORD PTR _newstate$[ebp]
	cmp	eax, DWORD PTR _oldstate$[ebp]
	jne	SHORT $LN4@IN_ToggleC
	jmp	SHORT $LN1@IN_ToggleC
$LN4@IN_ToggleC:

; 208  : 
; 209  : 	if( oldstate == key_game )

	cmp	DWORD PTR _oldstate$[ebp], 1
	jne	SHORT $LN5@IN_ToggleC

; 210  : 	{
; 211  : 		clgame.dllFuncs.IN_DeactivateMouse();

	call	DWORD PTR _clgame+44

; 212  : 	}

	jmp	SHORT $LN6@IN_ToggleC
$LN5@IN_ToggleC:

; 213  : 	else if( newstate == key_game )

	cmp	DWORD PTR _newstate$[ebp], 1
	jne	SHORT $LN6@IN_ToggleC

; 214  : 	{
; 215  : 		// reset mouse pos, so cancel effect in game
; 216  : 		SetCursorPos( host.window_center_x, host.window_center_y );	

	mov	eax, DWORD PTR _host+34760
	push	eax
	mov	ecx, DWORD PTR _host+34756
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8

; 217  : 		clgame.dllFuncs.IN_ActivateMouse();

	call	DWORD PTR _clgame+40
$LN6@IN_ToggleC:

; 218  : 	}
; 219  : 
; 220  : 	if( newstate == key_menu && ( !CL_IsBackgroundMap() || CL_IsBackgroundDemo( )))

	cmp	DWORD PTR _newstate$[ebp], 2
	jne	SHORT $LN1@IN_ToggleC
	call	_CL_IsBackgroundMap
	test	eax, eax
	je	SHORT $LN9@IN_ToggleC
	call	_CL_IsBackgroundDemo
	test	eax, eax
	je	SHORT $LN1@IN_ToggleC
$LN9@IN_ToggleC:

; 221  : 	{
; 222  : 		in_mouseactive = false;

	mov	DWORD PTR _in_mouseactive, 0

; 223  : 		ClipCursor( NULL );

	push	0
	call	DWORD PTR __imp__ClipCursor@4

; 224  : 		ReleaseCapture();

	call	DWORD PTR __imp__ReleaseCapture@0
$LN2@IN_ToggleC:

; 225  : 		while( ShowCursor( true ) < 0 );

	push	1
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jge	SHORT $LN1@IN_ToggleC
	jmp	SHORT $LN2@IN_ToggleC
$LN1@IN_ToggleC:

; 226  : 	}
; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_ToggleClientMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_MouseRestorePos
_TEXT	SEGMENT
_IN_MouseRestorePos PROC				; COMDAT

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 191  : 	if( !in_mouse_savedpos )

	cmp	DWORD PTR _in_mouse_savedpos, 0
	jne	SHORT $LN2@IN_MouseRe

; 192  : 		return;

	jmp	SHORT $LN1@IN_MouseRe
$LN2@IN_MouseRe:

; 193  : 
; 194  : 	SetCursorPos( in_lastvalidpos.x, in_lastvalidpos.y );

	mov	eax, DWORD PTR _in_lastvalidpos+4
	push	eax
	mov	ecx, DWORD PTR _in_lastvalidpos
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8

; 195  : 	in_mouse_savedpos = false;

	mov	DWORD PTR _in_mouse_savedpos, 0
$LN1@IN_MouseRe:

; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_MouseRestorePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_MouseSavePos
_TEXT	SEGMENT
_IN_MouseSavePos PROC					; COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 175  : 	if( !in_mouseactive )

	cmp	DWORD PTR _in_mouseactive, 0
	jne	SHORT $LN2@IN_MouseSa

; 176  : 		return;

	jmp	SHORT $LN1@IN_MouseSa
$LN2@IN_MouseSa:

; 177  : 
; 178  : 	GetCursorPos( &in_lastvalidpos );

	push	OFFSET _in_lastvalidpos
	call	DWORD PTR __imp__GetCursorPos@4

; 179  : 	in_mouse_savedpos = true;

	mov	DWORD PTR _in_mouse_savedpos, 1
$LN1@IN_MouseSa:

; 180  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_MouseSavePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_DeactivateMouse
_TEXT	SEGMENT
_IN_DeactivateMouse PROC				; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 326  : 	if( !in_mouseinitialized || !in_mouseactive )

	cmp	DWORD PTR _in_mouseinitialized, 0
	je	SHORT $LN5@IN_Deactiv
	cmp	DWORD PTR _in_mouseactive, 0
	jne	SHORT $LN4@IN_Deactiv
$LN5@IN_Deactiv:

; 327  : 		return;

	jmp	SHORT $LN1@IN_Deactiv
$LN4@IN_Deactiv:

; 328  : 
; 329  : 	if( cls.key_dest == key_game )

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN6@IN_Deactiv

; 330  : 	{
; 331  : 		clgame.dllFuncs.IN_DeactivateMouse();

	call	DWORD PTR _clgame+44
$LN6@IN_Deactiv:

; 332  : 	}
; 333  : 
; 334  : 	in_mouseactive = false;

	mov	DWORD PTR _in_mouseactive, 0

; 335  : 	ClipCursor( NULL );

	push	0
	call	DWORD PTR __imp__ClipCursor@4

; 336  : 	ReleaseCapture();

	call	DWORD PTR __imp__ReleaseCapture@0
$LN2@IN_Deactiv:

; 337  : 	while( ShowCursor( true ) < 0 );

	push	1
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jge	SHORT $LN1@IN_Deactiv
	jmp	SHORT $LN2@IN_Deactiv
$LN1@IN_Deactiv:

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_DeactivateMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_ActivateMouse
_TEXT	SEGMENT
_force$ = 8						; size = 4
_IN_ActivateMouse PROC					; COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 265  : 	static int	oldstate;
; 266  : 			
; 267  : 	if( !in_mouseinitialized )

	cmp	DWORD PTR _in_mouseinitialized, 0
	jne	SHORT $LN6@IN_Activat

; 268  : 		return;

	jmp	$LN1@IN_Activat
$LN6@IN_Activat:

; 269  : 
; 270  : 	if( CL_Active() && host.mouse_visible && !force )

	call	_CL_Active
	test	eax, eax
	je	SHORT $LN7@IN_Activat
	cmp	DWORD PTR _host+34372, 0
	je	SHORT $LN7@IN_Activat
	cmp	DWORD PTR _force$[ebp], 0
	jne	SHORT $LN7@IN_Activat

; 271  : 		return;	// VGUI controls  

	jmp	$LN1@IN_Activat
$LN7@IN_Activat:

; 272  : 
; 273  : 	if( cls.key_dest == key_menu && !Cvar_VariableInteger( "fullscreen" ))

	cmp	DWORD PTR _cls+36, 2
	jne	$LN8@IN_Activat
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	$LN8@IN_Activat

; 274  : 	{
; 275  : 		// check for mouse leave-entering
; 276  : 		if( !in_mouse_suspended && !UI_MouseInRect( ))

	cmp	DWORD PTR _in_mouse_suspended, 0
	jne	SHORT $LN9@IN_Activat
	call	_UI_MouseInRect
	test	eax, eax
	jne	SHORT $LN9@IN_Activat

; 277  : 			in_mouse_suspended = true;

	mov	DWORD PTR _in_mouse_suspended, 1
$LN9@IN_Activat:

; 278  : 
; 279  : 		if( oldstate != in_mouse_suspended )

	mov	eax, DWORD PTR ?oldstate@?1??IN_ActivateMouse@@9@9
	cmp	eax, DWORD PTR _in_mouse_suspended
	je	SHORT $LN10@IN_Activat

; 280  : 		{
; 281  : 			if( in_mouse_suspended )

	cmp	DWORD PTR _in_mouse_suspended, 0
	je	SHORT $LN10@IN_Activat

; 282  : 			{
; 283  : 				ClipCursor( NULL );

	push	0
	call	DWORD PTR __imp__ClipCursor@4

; 284  : 				ReleaseCapture();

	call	DWORD PTR __imp__ReleaseCapture@0
$LN2@IN_Activat:

; 285  : 				while( ShowCursor( true ) < 0 );

	push	1
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jge	SHORT $LN3@IN_Activat
	jmp	SHORT $LN2@IN_Activat
$LN3@IN_Activat:

; 286  : 				UI_ShowCursor( false );

	push	0
	call	_UI_ShowCursor
	add	esp, 4
$LN10@IN_Activat:

; 287  : 			}
; 288  : 		}
; 289  : 
; 290  : 		oldstate = in_mouse_suspended;

	mov	eax, DWORD PTR _in_mouse_suspended
	mov	DWORD PTR ?oldstate@?1??IN_ActivateMouse@@9@9, eax

; 291  : 
; 292  : 		if( in_mouse_suspended && IN_CursorInRect( ))

	cmp	DWORD PTR _in_mouse_suspended, 0
	je	SHORT $LN8@IN_Activat
	call	_IN_CursorInRect
	test	eax, eax
	je	SHORT $LN8@IN_Activat

; 293  : 		{
; 294  : 			in_mouse_suspended = false;

	mov	DWORD PTR _in_mouse_suspended, 0

; 295  : 			in_mouseactive = false; // re-initialize mouse

	mov	DWORD PTR _in_mouseactive, 0

; 296  : 			UI_ShowCursor( true );

	push	1
	call	_UI_ShowCursor
	add	esp, 4
$LN8@IN_Activat:

; 297  : 		}
; 298  : 	}
; 299  : 
; 300  : 	if( in_mouseactive ) return;

	cmp	DWORD PTR _in_mouseactive, 0
	je	SHORT $LN13@IN_Activat
	jmp	SHORT $LN1@IN_Activat
$LN13@IN_Activat:

; 301  : 	in_mouseactive = true;

	mov	DWORD PTR _in_mouseactive, 1

; 302  : 
; 303  : 	if( UI_IsVisible( )) return;

	call	_UI_IsVisible
	test	eax, eax
	je	SHORT $LN14@IN_Activat
	jmp	SHORT $LN1@IN_Activat
$LN14@IN_Activat:

; 304  : 
; 305  : 	if( cls.key_dest == key_game )

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN15@IN_Activat

; 306  : 	{
; 307  : 		clgame.dllFuncs.IN_ActivateMouse();

	call	DWORD PTR _clgame+40
$LN15@IN_Activat:

; 308  : 	}
; 309  : 
; 310  : 	IN_RecalcCenter( true );

	push	1
	call	_IN_RecalcCenter
	add	esp, 4

; 311  : 
; 312  : 	SetCapture( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__SetCapture@4

; 313  : 	ClipCursor( &window_rect );

	push	OFFSET _window_rect
	call	DWORD PTR __imp__ClipCursor@4
$LN4@IN_Activat:

; 314  : 	while( ShowCursor( false ) >= 0 );

	push	0
	call	DWORD PTR __imp__ShowCursor@4
	test	eax, eax
	jl	SHORT $LN1@IN_Activat
	jmp	SHORT $LN4@IN_Activat
$LN1@IN_Activat:

; 315  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_ActivateMouse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_MouseEvent
_TEXT	SEGMENT
_i$ = -4						; size = 4
_mstate$ = 8						; size = 4
_IN_MouseEvent PROC					; COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 369  : 	int	i;
; 370  : 
; 371  : 	if( !in_mouseinitialized || !in_mouseactive )

	cmp	DWORD PTR _in_mouseinitialized, 0
	je	SHORT $LN6@IN_MouseEv
	cmp	DWORD PTR _in_mouseactive, 0
	jne	SHORT $LN5@IN_MouseEv
$LN6@IN_MouseEv:

; 372  : 		return;

	jmp	$LN1@IN_MouseEv
$LN5@IN_MouseEv:

; 373  : 
; 374  : 	if( cls.key_dest == key_game )

	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN7@IN_MouseEv

; 375  : 	{
; 376  : 		clgame.dllFuncs.IN_MouseEvent( mstate );

	mov	eax, DWORD PTR _mstate$[ebp]
	push	eax
	call	DWORD PTR _clgame+48
	add	esp, 4

; 377  : 		return;

	jmp	$LN1@IN_MouseEv
$LN7@IN_MouseEv:

; 378  : 	}
; 379  : 
; 380  : 	// perform button actions
; 381  : 	for( i = 0; i < in_mouse_buttons; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@IN_MouseEv
$LN2@IN_MouseEv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IN_MouseEv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _in_mouse_buttons
	jge	SHORT $LN3@IN_MouseEv

; 382  : 	{
; 383  : 		if( FBitSet( mstate, BIT( i )) && !FBitSet( in_mouse_oldbuttonstate, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _mstate$[ebp]
	je	SHORT $LN8@IN_MouseEv
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _in_mouse_oldbuttonstate
	jne	SHORT $LN8@IN_MouseEv

; 384  : 		{
; 385  : 			Key_Event( K_MOUSE1 + i, true );

	push	1
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 241				; 000000f1H
	push	eax
	call	_Key_Event
	add	esp, 8
$LN8@IN_MouseEv:

; 386  : 		}
; 387  : 
; 388  : 		if( !FBitSet( mstate, BIT( i )) && FBitSet( in_mouse_oldbuttonstate, BIT( i )))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _mstate$[ebp]
	jne	SHORT $LN9@IN_MouseEv
	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _in_mouse_oldbuttonstate
	je	SHORT $LN9@IN_MouseEv

; 389  : 		{
; 390  : 			Key_Event( K_MOUSE1 + i, false );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 241				; 000000f1H
	push	eax
	call	_Key_Event
	add	esp, 8
$LN9@IN_MouseEv:

; 391  : 		}
; 392  : 	}	

	jmp	SHORT $LN2@IN_MouseEv
$LN3@IN_MouseEv:

; 393  : 
; 394  : 	in_mouse_oldbuttonstate = mstate;

	mov	eax, DWORD PTR _mstate$[ebp]
	mov	DWORD PTR _in_mouse_oldbuttonstate, eax
$LN1@IN_MouseEv:

; 395  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_MouseEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_Shutdown
_TEXT	SEGMENT
_IN_Shutdown PROC					; COMDAT

; 403  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 404  : 	IN_DeactivateMouse( );

	call	_IN_DeactivateMouse

; 405  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _Host_InputFrame
_TEXT	SEGMENT
_shutdownMouse$ = -4					; size = 4
_Host_InputFrame PROC					; COMDAT

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 427  : 	qboolean	shutdownMouse = false;

	mov	DWORD PTR _shutdownMouse$[ebp], 0

; 428  : 
; 429  : 	Sys_SendKeyEvents ();

	call	_Sys_SendKeyEvents

; 430  : 
; 431  : 	if( !in_mouseinitialized )

	cmp	DWORD PTR _in_mouseinitialized, 0
	jne	SHORT $LN2@Host_Input

; 432  : 		return;

	jmp	SHORT $LN1@Host_Input
$LN2@Host_Input:

; 433  : 
; 434  : 	if( host.status != HOST_FRAME )

	cmp	DWORD PTR _host+12, 1
	je	SHORT $LN3@Host_Input

; 435  : 	{
; 436  : 		IN_DeactivateMouse();

	call	_IN_DeactivateMouse

; 437  : 		return;

	jmp	SHORT $LN1@Host_Input
$LN3@Host_Input:

; 438  : 	}
; 439  : 
; 440  : 	// release mouse during pause or console typeing
; 441  : 	if( cl.paused && cls.key_dest == key_game )

	cmp	DWORD PTR _cl+24, 0
	je	SHORT $LN4@Host_Input
	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN4@Host_Input

; 442  : 		shutdownMouse = true;

	mov	DWORD PTR _shutdownMouse$[ebp], 1
$LN4@Host_Input:

; 443  : 	
; 444  : 	if( shutdownMouse && !Cvar_VariableInteger( "fullscreen" ))

	cmp	DWORD PTR _shutdownMouse$[ebp], 0
	je	SHORT $LN5@Host_Input
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Host_Input

; 445  : 	{
; 446  : 		IN_DeactivateMouse();

	call	_IN_DeactivateMouse

; 447  : 		return;

	jmp	SHORT $LN1@Host_Input
$LN5@Host_Input:

; 448  : 	}
; 449  : 
; 450  : 	IN_ActivateMouse( false );

	push	0
	call	_IN_ActivateMouse
	add	esp, 4

; 451  : 	IN_MouseMove();

	call	_IN_MouseMove
$LN1@Host_Input:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Host_InputFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\input.c
;	COMDAT _IN_Init
_TEXT	SEGMENT
_IN_Init PROC						; COMDAT

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 415  : 	IN_StartupMouse( );

	call	_IN_StartupMouse

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IN_Init ENDP
_TEXT	ENDS
END
