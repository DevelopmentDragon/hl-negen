; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\common.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_file_exts
PUBLIC	??_C@_04IFJILJI@?4cfg@				; `string'
PUBLIC	??_C@_04CLDILLMH@?4lst@				; `string'
PUBLIC	??_C@_04JLMDILM@?4exe@				; `string'
PUBLIC	??_C@_04EGDJFDLM@?4vbs@				; `string'
PUBLIC	??_C@_04PNGHFIJN@?4com@				; `string'
PUBLIC	??_C@_04NEEFLLOK@?4bat@				; `string'
PUBLIC	??_C@_04HLONOPDM@?4dll@				; `string'
PUBLIC	??_C@_04PHHEBHMK@?4ini@				; `string'
PUBLIC	??_C@_04FPOLKAEB@?4log@				; `string'
PUBLIC	??_C@_04GBJEOPBP@?4sys@				; `string'
;	COMDAT ??_C@_04GBJEOPBP@?4sys@
CONST	SEGMENT
??_C@_04GBJEOPBP@?4sys@ DB '.sys', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPOLKAEB@?4log@
CONST	SEGMENT
??_C@_04FPOLKAEB@?4log@ DB '.log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHEBHMK@?4ini@
CONST	SEGMENT
??_C@_04PHHEBHMK@?4ini@ DB '.ini', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLONOPDM@?4dll@
CONST	SEGMENT
??_C@_04HLONOPDM@?4dll@ DB '.dll', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEEFLLOK@?4bat@
CONST	SEGMENT
??_C@_04NEEFLLOK@?4bat@ DB '.bat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNGHFIJN@?4com@
CONST	SEGMENT
??_C@_04PNGHFIJN@?4com@ DB '.com', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGDJFDLM@?4vbs@
CONST	SEGMENT
??_C@_04EGDJFDLM@?4vbs@ DB '.vbs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe@ DB '.exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLDILLMH@?4lst@
CONST	SEGMENT
??_C@_04CLDILLMH@?4lst@ DB '.lst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFJILJI@?4cfg@
CONST	SEGMENT
??_C@_04IFJILJI@?4cfg@ DB '.cfg', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_file_exts DD	FLAT:??_C@_04IFJILJI@?4cfg@
	DD	FLAT:??_C@_04CLDILLMH@?4lst@
	DD	FLAT:??_C@_04JLMDILM@?4exe@
	DD	FLAT:??_C@_04EGDJFDLM@?4vbs@
	DD	FLAT:??_C@_04PNGHFIJN@?4com@
	DD	FLAT:??_C@_04NEEFLLOK@?4bat@
	DD	FLAT:??_C@_04HLONOPDM@?4dll@
	DD	FLAT:??_C@_04PHHEBHMK@?4ini@
	DD	FLAT:??_C@_04FPOLKAEB@?4log@
	DD	FLAT:??_C@_04GBJEOPBP@?4sys@
_DATA	ENDS
PUBLIC	_DBG_AssertFunction
PUBLIC	_COM_FileBase
PUBLIC	_COM_FileExtension
PUBLIC	_COM_DefaultExtension
PUBLIC	_COM_ReplaceExtension
PUBLIC	_COM_ExtractFilePath
PUBLIC	_COM_FileWithoutPath
PUBLIC	_COM_ParseVector
PUBLIC	_COM_NormalizeAngles
PUBLIC	_COM_FileSize
PUBLIC	_COM_FixSlashes
PUBLIC	_COM_FreeFile
PUBLIC	_COM_CheckString
PUBLIC	_COM_CompareFileTime
PUBLIC	_COM_StripExtension
PUBLIC	_pfnCvar_RegisterServerVariable
PUBLIC	_pfnCvar_RegisterEngineVariable
PUBLIC	_pfnCvar_RegisterClientVariable
PUBLIC	_pfnCvar_RegisterGameUIVariable
PUBLIC	_COM_MemFgets
PUBLIC	_COM_HexConvert
PUBLIC	_COM_SaveFile
PUBLIC	_COM_LoadFileForMe
PUBLIC	_COM_IsSafeFileToDownload
PUBLIC	_pfnCVarGetPointer
PUBLIC	_Cache_Check
PUBLIC	_COM_TrimSpace
PUBLIC	_pfnGetModelBounds
PUBLIC	_pfnCVarDirectSet
PUBLIC	_COM_CheckParm
PUBLIC	_pfnGetGameDir
PUBLIC	_pfnGetModelType
PUBLIC	_pfnTime
PUBLIC	_COM_ParseFile
PUBLIC	_COM_LoadFile
PUBLIC	_COM_AddAppDirectoryToSearchPath
PUBLIC	_COM_ExpandFilename
PUBLIC	_COM_SetRandomSeed
PUBLIC	_COM_RandomLong
PUBLIC	_COM_RandomFloat
PUBLIC	_LZSS_IsCompressed
PUBLIC	_LZSS_GetActualSize
PUBLIC	_LZSS_Compress
PUBLIC	_LZSS_Decompress
PUBLIC	_LZSS_CompressNoAlloc
PUBLIC	_COM_Nibble
PUBLIC	??_C@_0CL@NAFOBPMB@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@ ; `string'
PUBLIC	??_C@_0CI@NHHAPFKP@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@ ; `string'
PUBLIC	?__LINE__Var@?0??LZSS_CompressNoAlloc@@9@9	; `LZSS_CompressNoAlloc'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	?__LINE__Var@?0??LZSS_Decompress@@9@9		; `LZSS_Decompress'::`1'::__LINE__Var
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	?__LINE__Var@?0??COM_LoadFileForMe@@9@9		; `COM_LoadFileForMe'::`1'::__LINE__Var
PUBLIC	??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@	; `string'
PUBLIC	??_C@_04HJKAGJBM@?$CBMD5@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4@				; `string'
PUBLIC	??_C@_01PJKLJHI@?$HO@				; `string'
PUBLIC	__real@30000000
PUBLIC	__real@3f7ffffe
PUBLIC	__real@3fefffffbf935359
PUBLIC	__real@43340000
PUBLIC	__real@43b40000
PUBLIC	__real@c3340000
EXTRN	__imp___time64:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Q_strnlwr:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strrchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_IsAllocatedExt:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_RegisterVariable:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_Cvar_BuildAutoDescription:PROC
EXTRN	_FS_AddGameHierarchy:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_FS_FileTime:PROC
EXTRN	_Host_CompareFileTime:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_idum	DD	01H DUP (?)
?iy@?1??lran1@@9@9 DD 01H DUP (?)			; `lran1'::`2'::iy
?iv@?1??lran1@@9@9 DD 020H DUP (?)			; `lran1'::`2'::iv
_BSS	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@3fefffffbf935359
CONST	SEGMENT
__real@3fefffffbf935359 DQ 03fefffffbf935359r	; 1
CONST	ENDS
;	COMDAT __real@3f7ffffe
CONST	SEGMENT
__real@3f7ffffe DD 03f7ffffer			; 1
CONST	ENDS
;	COMDAT __real@30000000
CONST	SEGMENT
__real@30000000 DD 030000000r			; 4.65661e-10
CONST	ENDS
;	COMDAT ??_C@_01PJKLJHI@?$HO@
CONST	SEGMENT
??_C@_01PJKLJHI@?$HO@ DB '~', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJKAGJBM@?$CBMD5@
CONST	SEGMENT
??_C@_04HJKAGJBM@?$CBMD5@ DB '!MD5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@
CONST	SEGMENT
??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@ DB 'enable or disable %s', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??COM_LoadFileForMe@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??COM_LoadFileForMe@@9@9 DD 03f1H	; `COM_LoadFileForMe'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??LZSS_Decompress@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??LZSS_Decompress@@9@9 DD 017dH		; `LZSS_Decompress'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\common.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??LZSS_CompressNoAlloc@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??LZSS_CompressNoAlloc@@9@9 DD 0f3H	; `LZSS_CompressNoAlloc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@NHHAPFKP@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@
CONST	SEGMENT
??_C@_0CI@NHHAPFKP@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@ DB '^'
	DB	'1Error:^7 ASSERT FAILED:', 0aH, ' %s ', 0aH, '(%s@%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NAFOBPMB@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@
CONST	SEGMENT
??_C@_0CL@NAFOBPMB@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@ DB '^'
	DB	'1Error:^7 ASSERT FAILED:', 0aH, ' %s ', 0aH, '(%s@%d)', 0aH, '%'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0a5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01ceH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	011bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01a3H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_Nibble
_TEXT	SEGMENT
_c$ = 8							; size = 1
_COM_Nibble PROC					; COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 891  : 	if(( c >= '0' ) && ( c <= '9' ))

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN2@COM_Nibble
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN2@COM_Nibble

; 892  : 	{
; 893  : 		 return (byte)(c - '0');

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN1@COM_Nibble
$LN2@COM_Nibble:

; 894  : 	}
; 895  : 
; 896  : 	if(( c >= 'A' ) && ( c <= 'F' ))

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN3@COM_Nibble
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN3@COM_Nibble

; 897  : 	{
; 898  : 		 return (byte)(c - 'A' + 0x0a);

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 55					; 00000037H
	jmp	SHORT $LN1@COM_Nibble
$LN3@COM_Nibble:

; 899  : 	}
; 900  : 
; 901  : 	if(( c >= 'a' ) && ( c <= 'f' ))

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN4@COM_Nibble
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN4@COM_Nibble

; 902  : 	{
; 903  : 		 return (byte)(c - 'a' + 0x0a);

	movsx	eax, BYTE PTR _c$[ebp]
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN1@COM_Nibble
$LN4@COM_Nibble:

; 904  : 	}
; 905  : 
; 906  : 	return '0';

	mov	al, 48					; 00000030H
$LN1@COM_Nibble:

; 907  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_Nibble ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_IsWhiteSpace
_TEXT	SEGMENT
_space$ = 8						; size = 1
_COM_IsWhiteSpace PROC					; COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 630  : 	if( space == ' ' || space == '\t' || space == '\r' || space == '\n' )

	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@COM_IsWhit
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 9
	je	SHORT $LN3@COM_IsWhit
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@COM_IsWhit
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@COM_IsWhit
$LN3@COM_IsWhit:

; 631  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@COM_IsWhit
$LN2@COM_IsWhit:

; 632  : 	return 0;

	xor	eax, eax
$LN1@COM_IsWhit:

; 633  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_IsWhiteSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_IsSingleChar
_TEXT	SEGMENT
_c$ = 8							; size = 1
_COM_IsSingleChar PROC					; COMDAT

; 607  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 608  : 	if( c == '{' || c == '}' || c == '\'' || c == ',' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN3@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN3@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN3@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN2@COM_IsSing
$LN3@COM_IsSing:

; 609  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@COM_IsSing
$LN2@COM_IsSing:

; 610  : 
; 611  : 	if( !host.com_ignorebracket && ( c == ')' || c == '(' ))

	cmp	DWORD PTR _host+34364, 0
	jne	SHORT $LN4@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN5@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN4@COM_IsSing
$LN5@COM_IsSing:

; 612  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@COM_IsSing
$LN4@COM_IsSing:

; 613  : 
; 614  : 	if( host.com_handlecolon && c == ':' )

	cmp	DWORD PTR _host+34360, 0
	je	SHORT $LN6@COM_IsSing
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN6@COM_IsSing

; 615  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@COM_IsSing
$LN6@COM_IsSing:

; 616  : 
; 617  : 	return false;

	xor	eax, eax
$LN1@COM_IsSing:

; 618  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_IsSingleChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_CompressNoAlloc
_TEXT	SEGMENT
tv181 = -132						; size = 4
tv143 = -132						; size = 4
tv93 = -132						; size = 4
tv84 = -132						; size = 4
tv74 = -132						; size = 4
_match_length$1 = -64					; size = 4
_length$2 = -60						; size = 4
_encoded_length$3 = -56					; size = 4
_hash$4 = -52						; size = 4
_lookAheadLength$5 = -48				; size = 4
_pCmdByte$ = -44					; size = 4
_putCmdByte$ = -40					; size = 4
_i$ = -36						; size = 4
_pWindow$ = -32						; size = 4
_pLookAhead$ = -28					; size = 4
_pEncodedPosition$ = -24				; size = 4
_pOutput$ = -20						; size = 4
_header$ = -16						; size = 4
_pEnd$ = -12						; size = 4
_pStart$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_pInput$ = 12						; size = 4
_input_length$ = 16					; size = 4
_pOutputBuf$ = 20					; size = 4
_pOutputSize$ = 24					; size = 4
_LZSS_CompressNoAlloc PROC				; COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 244  : 	byte		*pStart = pOutputBuf; // allocate the output buffer, compressed buffer is expected to be less, caller will free

	mov	eax, DWORD PTR _pOutputBuf$[ebp]
	mov	DWORD PTR _pStart$[ebp], eax

; 245  : 	byte		*pEnd = pStart + input_length - sizeof( lzss_header_t ) - 8; // prevent compression failure

	mov	eax, DWORD PTR _input_length$[ebp]
	mov	ecx, DWORD PTR _pStart$[ebp]
	lea	edx, DWORD PTR [ecx+eax-16]
	mov	DWORD PTR _pEnd$[ebp], edx

; 246  : 	lzss_header_t	*header = (lzss_header_t *)pStart;

	mov	eax, DWORD PTR _pStart$[ebp]
	mov	DWORD PTR _header$[ebp], eax

; 247  : 	byte		*pOutput = pStart + sizeof( lzss_header_t );

	mov	eax, DWORD PTR _pStart$[ebp]
	add	eax, 8
	mov	DWORD PTR _pOutput$[ebp], eax

; 248  : 	const byte	*pEncodedPosition = NULL;

	mov	DWORD PTR _pEncodedPosition$[ebp], 0

; 249  : 	byte		*pLookAhead = pInput; 

	mov	eax, DWORD PTR _pInput$[ebp]
	mov	DWORD PTR _pLookAhead$[ebp], eax

; 250  : 	byte		*pWindow = pInput;

	mov	eax, DWORD PTR _pInput$[ebp]
	mov	DWORD PTR _pWindow$[ebp], eax

; 251  : 	int		i, putCmdByte = 0;

	mov	DWORD PTR _putCmdByte$[ebp], 0

; 252  : 	byte		*pCmdByte = NULL;

	mov	DWORD PTR _pCmdByte$[ebp], 0

; 253  : 
; 254  : 	if( input_length <= sizeof( lzss_header_t ) + 8 )

	cmp	DWORD PTR _input_length$[ebp], 16	; 00000010H
	ja	SHORT $LN11@LZSS_Compr

; 255  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@LZSS_Compr
$LN11@LZSS_Compr:

; 256  : 
; 257  : 	// set LZSS header
; 258  : 	header->id = LZSS_ID;

	mov	eax, DWORD PTR _header$[ebp]
	mov	DWORD PTR [eax], 1397971532		; 53535a4cH

; 259  : 	header->size = input_length;

	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR _input_length$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 260  : 
; 261  : 	// create the compression work buffers, small enough (~64K) for stack
; 262  : 	state->hash_table = (lzss_list_t *)_alloca( 256 * sizeof( lzss_list_t ));

	mov	eax, 2048				; 00000800H
	call	__alloca_probe_16
	mov	DWORD PTR tv74[ebp], esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR [eax], ecx

; 263  : 	memset( state->hash_table, 0, 256 * sizeof( lzss_list_t ));

	push	2048					; 00000800H
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 264  : 	state->hash_node = (lzss_node_t *)_alloca( state->window_size * sizeof( lzss_node_t ));

	mov	eax, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 4
	call	__alloca_probe_16
	mov	DWORD PTR tv84[ebp], esp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR [ecx+4], edx

; 265  : 	memset( state->hash_node, 0, state->window_size * sizeof( lzss_node_t ));

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 4
	push	ecx
	push	0
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@LZSS_Compr:

; 266  : 
; 267  : 	while( input_length > 0 )

	cmp	DWORD PTR _input_length$[ebp], 0
	jle	$LN3@LZSS_Compr

; 268  : 	{
; 269  : 		int		lookAheadLength = input_length < LZSS_LOOKAHEAD ? input_length : LZSS_LOOKAHEAD;

	cmp	DWORD PTR _input_length$[ebp], 16	; 00000010H
	jge	SHORT $LN24@LZSS_Compr
	mov	eax, DWORD PTR _input_length$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN25@LZSS_Compr
$LN24@LZSS_Compr:
	mov	DWORD PTR tv93[ebp], 16			; 00000010H
$LN25@LZSS_Compr:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR _lookAheadLength$5[ebp], ecx

; 270  : 		lzss_node_t	*hash = state->hash_table[pLookAhead[0]].start;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pLookAhead$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _hash$4[ebp], eax

; 271  : 		int		encoded_length = 0;

	mov	DWORD PTR _encoded_length$3[ebp], 0

; 272  : 
; 273  : 		pWindow = pLookAhead - state->window_size;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _pLookAhead$[ebp]
	sub	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pWindow$[ebp], ecx

; 274  : 
; 275  : 		if( pWindow < pInput )

	mov	eax, DWORD PTR _pWindow$[ebp]
	cmp	eax, DWORD PTR _pInput$[ebp]
	jae	SHORT $LN12@LZSS_Compr

; 276  : 			pWindow = pInput;

	mov	eax, DWORD PTR _pInput$[ebp]
	mov	DWORD PTR _pWindow$[ebp], eax
$LN12@LZSS_Compr:

; 277  : 
; 278  : 		if( !putCmdByte )

	cmp	DWORD PTR _putCmdByte$[ebp], 0
	jne	SHORT $LN13@LZSS_Compr

; 279  : 		{
; 280  : 			pCmdByte = pOutput++;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	DWORD PTR _pCmdByte$[ebp], eax
	mov	ecx, DWORD PTR _pOutput$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pOutput$[ebp], ecx

; 281  : 			*pCmdByte = 0;

	mov	eax, DWORD PTR _pCmdByte$[ebp]
	mov	BYTE PTR [eax], 0
$LN13@LZSS_Compr:

; 282  : 		}
; 283  : 
; 284  : 		putCmdByte = ( putCmdByte + 1 ) & 0x07;

	mov	eax, DWORD PTR _putCmdByte$[ebp]
	add	eax, 1
	and	eax, 7
	mov	DWORD PTR _putCmdByte$[ebp], eax
$LN4@LZSS_Compr:

; 285  : 
; 286  : 		while( hash != NULL )

	cmp	DWORD PTR _hash$4[ebp], 0
	je	SHORT $LN5@LZSS_Compr

; 287  : 		{
; 288  : 			int	length = lookAheadLength;

	mov	eax, DWORD PTR _lookAheadLength$5[ebp]
	mov	DWORD PTR _length$2[ebp], eax

; 289  : 			int	match_length = 0;

	mov	DWORD PTR _match_length$1[ebp], 0
$LN6@LZSS_Compr:

; 290  : 
; 291  : 			while( length-- && hash->data[match_length] == pLookAhead[match_length] )

	mov	eax, DWORD PTR _length$2[ebp]
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR _length$2[ebp]
	sub	ecx, 1
	mov	DWORD PTR _length$2[ebp], ecx
	cmp	DWORD PTR tv143[ebp], 0
	je	SHORT $LN7@LZSS_Compr
	mov	eax, DWORD PTR _hash$4[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _match_length$1[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _pLookAhead$[ebp]
	add	ecx, DWORD PTR _match_length$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN7@LZSS_Compr

; 292  : 				match_length++;

	mov	eax, DWORD PTR _match_length$1[ebp]
	add	eax, 1
	mov	DWORD PTR _match_length$1[ebp], eax
	jmp	SHORT $LN6@LZSS_Compr
$LN7@LZSS_Compr:

; 293  : 
; 294  : 			if( match_length > encoded_length )

	mov	eax, DWORD PTR _match_length$1[ebp]
	cmp	eax, DWORD PTR _encoded_length$3[ebp]
	jle	SHORT $LN14@LZSS_Compr

; 295  : 			{
; 296  : 				encoded_length = match_length;

	mov	eax, DWORD PTR _match_length$1[ebp]
	mov	DWORD PTR _encoded_length$3[ebp], eax

; 297  : 				pEncodedPosition = hash->data;

	mov	eax, DWORD PTR _hash$4[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pEncodedPosition$[ebp], ecx
$LN14@LZSS_Compr:

; 298  : 			}
; 299  : 
; 300  : 			if( match_length == lookAheadLength )

	mov	eax, DWORD PTR _match_length$1[ebp]
	cmp	eax, DWORD PTR _lookAheadLength$5[ebp]
	jne	SHORT $LN15@LZSS_Compr

; 301  : 				break;

	jmp	SHORT $LN5@LZSS_Compr
$LN15@LZSS_Compr:

; 302  : 
; 303  : 			hash = hash->next;

	mov	eax, DWORD PTR _hash$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _hash$4[ebp], ecx

; 304  : 		}

	jmp	SHORT $LN4@LZSS_Compr
$LN5@LZSS_Compr:

; 305  : 
; 306  : 		if ( encoded_length >= 3 )

	cmp	DWORD PTR _encoded_length$3[ebp], 3
	jl	SHORT $LN16@LZSS_Compr

; 307  : 		{
; 308  : 			*pCmdByte = (*pCmdByte >> 1) | 0x80;

	mov	eax, DWORD PTR _pCmdByte$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sar	ecx, 1
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _pCmdByte$[ebp]
	mov	BYTE PTR [edx], cl

; 309  : 			*pOutput++ = (( pLookAhead - pEncodedPosition - 1 ) >> LZSS_LOOKSHIFT );

	mov	eax, DWORD PTR _pLookAhead$[ebp]
	sub	eax, DWORD PTR _pEncodedPosition$[ebp]
	sub	eax, 1
	sar	eax, 4
	mov	ecx, DWORD PTR _pOutput$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pOutput$[ebp]
	add	edx, 1
	mov	DWORD PTR _pOutput$[ebp], edx

; 310  : 			*pOutput++ = (( pLookAhead - pEncodedPosition - 1 ) << LZSS_LOOKSHIFT ) | ( encoded_length - 1 );

	mov	eax, DWORD PTR _pLookAhead$[ebp]
	sub	eax, DWORD PTR _pEncodedPosition$[ebp]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _encoded_length$3[ebp]
	sub	ecx, 1
	or	eax, ecx
	mov	edx, DWORD PTR _pOutput$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pOutput$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOutput$[ebp], eax

; 311  : 		} 

	jmp	SHORT $LN17@LZSS_Compr
$LN16@LZSS_Compr:

; 312  : 		else 
; 313  : 		{ 
; 314  : 			*pCmdByte = ( *pCmdByte >> 1 );

	mov	eax, DWORD PTR _pCmdByte$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sar	ecx, 1
	mov	edx, DWORD PTR _pCmdByte$[ebp]
	mov	BYTE PTR [edx], cl

; 315  : 			*pOutput++ = *pLookAhead;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	ecx, DWORD PTR _pLookAhead$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pOutput$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOutput$[ebp], eax

; 316  : 			encoded_length = 1;

	mov	DWORD PTR _encoded_length$3[ebp], 1
$LN17@LZSS_Compr:

; 317  : 		}
; 318  : 
; 319  : 		for( i = 0; i < encoded_length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@LZSS_Compr
$LN8@LZSS_Compr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@LZSS_Compr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _encoded_length$3[ebp]
	jge	SHORT $LN9@LZSS_Compr

; 320  : 		{
; 321  : 			LZSS_BuildHash( state, pLookAhead++ );

	mov	eax, DWORD PTR _pLookAhead$[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR tv181[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_LZSS_BuildHash
	add	esp, 8
	mov	eax, DWORD PTR _pLookAhead$[ebp]
	add	eax, 1
	mov	DWORD PTR _pLookAhead$[ebp], eax

; 322  : 		}

	jmp	SHORT $LN8@LZSS_Compr
$LN9@LZSS_Compr:

; 323  : 
; 324  : 		input_length -= encoded_length;

	mov	eax, DWORD PTR _input_length$[ebp]
	sub	eax, DWORD PTR _encoded_length$3[ebp]
	mov	DWORD PTR _input_length$[ebp], eax

; 325  : 
; 326  : 		if( pOutput >= pEnd )

	mov	eax, DWORD PTR _pOutput$[ebp]
	cmp	eax, DWORD PTR _pEnd$[ebp]
	jb	SHORT $LN18@LZSS_Compr

; 327  : 		{
; 328  : 			// compression is worse, abandon
; 329  : 			return NULL;

	xor	eax, eax
	jmp	$LN1@LZSS_Compr
$LN18@LZSS_Compr:

; 330  : 		}
; 331  : 	}

	jmp	$LN2@LZSS_Compr
$LN3@LZSS_Compr:

; 332  : 
; 333  : 	if( input_length != 0 )

	cmp	DWORD PTR _input_length$[ebp], 0
	je	SHORT $LN19@LZSS_Compr

; 334  : 	{
; 335  : 		// unexpected failure
; 336  : 		Assert( 0 );

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??LZSS_CompressNoAlloc@@9@9
	add	eax, 93					; 0000005dH
	push	eax
	push	OFFSET ??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	0
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 337  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@LZSS_Compr
$LN19@LZSS_Compr:

; 338  : 	}
; 339  : 
; 340  : 	if( !putCmdByte )

	cmp	DWORD PTR _putCmdByte$[ebp], 0
	jne	SHORT $LN20@LZSS_Compr

; 341  : 	{
; 342  : 		pCmdByte = pOutput++;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	DWORD PTR _pCmdByte$[ebp], eax
	mov	ecx, DWORD PTR _pOutput$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pOutput$[ebp], ecx

; 343  : 		*pCmdByte = 0x01;

	mov	eax, DWORD PTR _pCmdByte$[ebp]
	mov	BYTE PTR [eax], 1

; 344  : 	}

	jmp	SHORT $LN21@LZSS_Compr
$LN20@LZSS_Compr:

; 345  : 	else
; 346  : 	{
; 347  : 		*pCmdByte = (( *pCmdByte >> 1 ) | 0x80 ) >> ( 7 - putCmdByte );

	mov	eax, DWORD PTR _pCmdByte$[ebp]
	movzx	edx, BYTE PTR [eax]
	sar	edx, 1
	or	edx, 128				; 00000080H
	mov	ecx, 7
	sub	ecx, DWORD PTR _putCmdByte$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _pCmdByte$[ebp]
	mov	BYTE PTR [eax], dl
$LN21@LZSS_Compr:

; 348  : 	}
; 349  : 
; 350  : 	// put two ints at end of buffer
; 351  : 	*pOutput++ = 0;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pOutput$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pOutput$[ebp], ecx

; 352  : 	*pOutput++ = 0;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pOutput$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pOutput$[ebp], ecx

; 353  : 
; 354  : 	if( pOutputSize )

	cmp	DWORD PTR _pOutputSize$[ebp], 0
	je	SHORT $LN22@LZSS_Compr

; 355  : 		*pOutputSize = pOutput - pStart;

	mov	eax, DWORD PTR _pOutput$[ebp]
	sub	eax, DWORD PTR _pStart$[ebp]
	mov	ecx, DWORD PTR _pOutputSize$[ebp]
	mov	DWORD PTR [ecx], eax
$LN22@LZSS_Compr:

; 356  : 
; 357  : 	return pStart;

	mov	eax, DWORD PTR _pStart$[ebp]
$LN1@LZSS_Compr:

; 358  : }

	lea	esp, DWORD PTR [ebp-144]
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_CompressNoAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_BuildHash
_TEXT	SEGMENT
_targetindex$ = -12					; size = 4
_node$ = -8						; size = 4
_list$ = -4						; size = 4
_state$ = 8						; size = 4
_source$ = 12						; size = 4
_LZSS_BuildHash PROC					; COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 211  : 	lzss_list_t	*list;
; 212  : 	lzss_node_t	*node;
; 213  : 	unsigned int	targetindex = (uint)source & ( state->window_size - 1 );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	and	ecx, DWORD PTR _source$[ebp]
	mov	DWORD PTR _targetindex$[ebp], ecx

; 214  : 
; 215  : 	node = &state->hash_node[targetindex];

	mov	eax, DWORD PTR _targetindex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _node$[ebp], eax

; 216  : 
; 217  : 	if( node->data )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LZSS_Build

; 218  : 	{
; 219  : 		list = &state->hash_table[*node->data];

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _list$[ebp], edx

; 220  : 		if( node->prev )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@LZSS_Build

; 221  : 		{
; 222  : 			list->end = node->prev;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 223  : 			node->prev->next = NULL;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+8], 0

; 224  : 		}

	jmp	SHORT $LN2@LZSS_Build
$LN3@LZSS_Build:

; 225  : 		else
; 226  : 		{
; 227  : 			list->start = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax], 0

; 228  : 			list->end = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@LZSS_Build:

; 229  : 		}
; 230  : 	}
; 231  : 
; 232  : 	list = &state->hash_table[*source];

	mov	eax, DWORD PTR _source$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _list$[ebp], ecx

; 233  : 	node->data = source;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [eax], ecx

; 234  : 	node->prev = NULL;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+4], 0

; 235  : 	node->next = list->start;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx

; 236  : 	if( list->start )

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@LZSS_Build

; 237  : 		list->start->prev = node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN6@LZSS_Build
$LN5@LZSS_Build:

; 238  : 	else list->end = node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN6@LZSS_Build:

; 239  : 	list->start = node;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax], ecx

; 240  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_BuildHash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _fran1
_TEXT	SEGMENT
_temp$ = -4						; size = 4
_fran1	PROC						; COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 97   : 	float temp = (float)AM * lran1();

	call	_lran1
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@30000000
	movss	DWORD PTR _temp$[ebp], xmm0

; 98   : 	if( temp > RNMX )

	cvtss2sd xmm0, DWORD PTR _temp$[ebp]
	comisd	xmm0, QWORD PTR __real@3fefffffbf935359
	jbe	SHORT $LN2@fran1

; 99   : 		return (float)RNMX;

	fld	DWORD PTR __real@3f7ffffe
	jmp	SHORT $LN1@fran1
$LN2@fran1:

; 100  : 	return temp;

	fld	DWORD PTR _temp$[ebp]
$LN1@fran1:

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_fran1	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _lran1
_TEXT	SEGMENT
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_lran1	PROC						; COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 63   : 	static long	iy = 0;
; 64   : 	static long	iv[NTAB];
; 65   : 	int		j;
; 66   : 	long		k;
; 67   : 
; 68   : 	if( idum <= 0 || !iy )

	cmp	DWORD PTR _idum, 0
	jle	SHORT $LN6@lran1
	cmp	DWORD PTR ?iy@?1??lran1@@9@9, 0
	jne	$LN5@lran1
$LN6@lran1:

; 69   : 	{
; 70   : 		if( -(idum) < 1 ) idum = 1;

	mov	eax, DWORD PTR _idum
	neg	eax
	cmp	eax, 1
	jge	SHORT $LN7@lran1
	mov	DWORD PTR _idum, 1
	jmp	SHORT $LN8@lran1
$LN7@lran1:

; 71   : 		else idum = -(idum);

	mov	eax, DWORD PTR _idum
	neg	eax
	mov	DWORD PTR _idum, eax
$LN8@lran1:

; 72   : 
; 73   : 		for( j = NTAB + 7; j >= 0; j-- )

	mov	DWORD PTR _j$[ebp], 39			; 00000027H
	jmp	SHORT $LN4@lran1
$LN2@lran1:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@lran1:
	cmp	DWORD PTR _j$[ebp], 0
	jl	SHORT $LN3@lran1

; 74   : 		{
; 75   : 			k = (idum) / IQ;

	mov	eax, DWORD PTR _idum
	cdq
	mov	ecx, 127773				; 0001f31dH
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 76   : 			idum = IA * (idum - k * IQ) - IR * k;

	imul	eax, DWORD PTR _k$[ebp], 127773
	mov	ecx, DWORD PTR _idum
	sub	ecx, eax
	imul	edx, ecx, 16807
	imul	eax, DWORD PTR _k$[ebp], 2836
	sub	edx, eax
	mov	DWORD PTR _idum, edx

; 77   : 			if( idum < 0 ) idum += IM;

	jns	SHORT $LN9@lran1
	mov	eax, DWORD PTR _idum
	add	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _idum, eax
$LN9@lran1:

; 78   : 			if( j < NTAB ) iv[j] = idum;

	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jge	SHORT $LN10@lran1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _idum
	mov	DWORD PTR ?iv@?1??lran1@@9@9[eax*4], ecx
$LN10@lran1:

; 79   : 		}

	jmp	SHORT $LN2@lran1
$LN3@lran1:

; 80   : 
; 81   : 		iy = iv[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR ?iv@?1??lran1@@9@9[ecx]
	mov	DWORD PTR ?iy@?1??lran1@@9@9, edx
$LN5@lran1:

; 82   : 	}
; 83   : 
; 84   : 	k = (idum) / IQ;

	mov	eax, DWORD PTR _idum
	cdq
	mov	ecx, 127773				; 0001f31dH
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 85   : 	idum = IA * (idum - k * IQ) - IR * k;

	imul	eax, DWORD PTR _k$[ebp], 127773
	mov	ecx, DWORD PTR _idum
	sub	ecx, eax
	imul	edx, ecx, 16807
	imul	eax, DWORD PTR _k$[ebp], 2836
	sub	edx, eax
	mov	DWORD PTR _idum, edx

; 86   : 	if( idum < 0 ) idum += IM;

	jns	SHORT $LN11@lran1
	mov	eax, DWORD PTR _idum
	add	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _idum, eax
$LN11@lran1:

; 87   : 	j = iy / NDIV;

	mov	eax, DWORD PTR ?iy@?1??lran1@@9@9
	cdq
	and	edx, 67108863				; 03ffffffH
	add	eax, edx
	sar	eax, 26					; 0000001aH
	mov	DWORD PTR _j$[ebp], eax

; 88   : 	iy = iv[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR ?iv@?1??lran1@@9@9[eax*4]
	mov	DWORD PTR ?iy@?1??lran1@@9@9, ecx

; 89   : 	iv[j] = idum;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _idum
	mov	DWORD PTR ?iv@?1??lran1@@9@9[eax*4], ecx

; 90   : 
; 91   : 	return iy;

	mov	eax, DWORD PTR ?iy@?1??lran1@@9@9

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_lran1	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_Decompress
_TEXT	SEGMENT
_pSource$1 = -32					; size = 4
_count$2 = -28						; size = 4
_i$3 = -24						; size = 4
_position$4 = -20					; size = 4
_actualSize$ = -16					; size = 4
_cmdByte$ = -12						; size = 4
_getCmdByte$ = -8					; size = 4
_totalBytes$ = -4					; size = 4
_pInput$ = 8						; size = 4
_pOutput$ = 12						; size = 4
_LZSS_Decompress PROC					; COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 382  : 	uint	totalBytes = 0;

	mov	DWORD PTR _totalBytes$[ebp], 0

; 383  : 	int	getCmdByte = 0;

	mov	DWORD PTR _getCmdByte$[ebp], 0

; 384  : 	int	cmdByte = 0;

	mov	DWORD PTR _cmdByte$[ebp], 0

; 385  : 	uint	actualSize = LZSS_GetActualSize( pInput );

	mov	eax, DWORD PTR _pInput$[ebp]
	push	eax
	call	_LZSS_GetActualSize
	add	esp, 4
	mov	DWORD PTR _actualSize$[ebp], eax

; 386  : 
; 387  : 	if( !actualSize )

	cmp	DWORD PTR _actualSize$[ebp], 0
	jne	SHORT $LN7@LZSS_Decom

; 388  : 		return 0;

	xor	eax, eax
	jmp	$LN1@LZSS_Decom
$LN7@LZSS_Decom:

; 389  : 
; 390  : 	pInput += sizeof( lzss_header_t );

	mov	eax, DWORD PTR _pInput$[ebp]
	add	eax, 8
	mov	DWORD PTR _pInput$[ebp], eax
$LN2@LZSS_Decom:

; 391  : 
; 392  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@LZSS_Decom

; 393  : 	{
; 394  : 		if( !getCmdByte ) 

	cmp	DWORD PTR _getCmdByte$[ebp], 0
	jne	SHORT $LN8@LZSS_Decom

; 395  : 			cmdByte = *pInput++;

	mov	eax, DWORD PTR _pInput$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _cmdByte$[ebp], ecx
	mov	edx, DWORD PTR _pInput$[ebp]
	add	edx, 1
	mov	DWORD PTR _pInput$[ebp], edx
$LN8@LZSS_Decom:

; 396  : 		getCmdByte = ( getCmdByte + 1 ) & 0x07;

	mov	eax, DWORD PTR _getCmdByte$[ebp]
	add	eax, 1
	and	eax, 7
	mov	DWORD PTR _getCmdByte$[ebp], eax

; 397  : 
; 398  : 		if( cmdByte & 0x01 )

	mov	eax, DWORD PTR _cmdByte$[ebp]
	and	eax, 1
	je	$LN9@LZSS_Decom

; 399  : 		{
; 400  : 			int	position = *pInput++ << LZSS_LOOKSHIFT;

	mov	eax, DWORD PTR _pInput$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	mov	DWORD PTR _position$4[ebp], ecx
	mov	edx, DWORD PTR _pInput$[ebp]
	add	edx, 1
	mov	DWORD PTR _pInput$[ebp], edx

; 401  : 			int	i, count;
; 402  : 			byte	*pSource;
; 403  : 
; 404  : 			position |= ( *pInput >> LZSS_LOOKSHIFT );

	mov	eax, DWORD PTR _pInput$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sar	ecx, 4
	or	ecx, DWORD PTR _position$4[ebp]
	mov	DWORD PTR _position$4[ebp], ecx

; 405  : 			count = ( *pInput++ & 0x0F ) + 1;

	mov	eax, DWORD PTR _pInput$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 15					; 0000000fH
	add	ecx, 1
	mov	DWORD PTR _count$2[ebp], ecx
	mov	edx, DWORD PTR _pInput$[ebp]
	add	edx, 1
	mov	DWORD PTR _pInput$[ebp], edx

; 406  : 
; 407  : 			if( count == 1 ) 

	cmp	DWORD PTR _count$2[ebp], 1
	jne	SHORT $LN11@LZSS_Decom

; 408  : 				break;

	jmp	$LN3@LZSS_Decom
$LN11@LZSS_Decom:

; 409  : 
; 410  : 			pSource = pOutput - position - 1;

	mov	eax, DWORD PTR _pOutput$[ebp]
	sub	eax, DWORD PTR _position$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _pSource$1[ebp], eax

; 411  : 			for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@LZSS_Decom
$LN4@LZSS_Decom:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN6@LZSS_Decom:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _count$2[ebp]
	jge	SHORT $LN5@LZSS_Decom

; 412  : 				*pOutput++ = *pSource++;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	ecx, DWORD PTR _pSource$1[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pOutput$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOutput$[ebp], eax
	mov	ecx, DWORD PTR _pSource$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _pSource$1[ebp], ecx
	jmp	SHORT $LN4@LZSS_Decom
$LN5@LZSS_Decom:

; 413  : 			totalBytes += count;

	mov	eax, DWORD PTR _totalBytes$[ebp]
	add	eax, DWORD PTR _count$2[ebp]
	mov	DWORD PTR _totalBytes$[ebp], eax

; 414  : 		} 

	jmp	SHORT $LN10@LZSS_Decom
$LN9@LZSS_Decom:

; 415  : 		else 
; 416  : 		{
; 417  : 			*pOutput++ = *pInput++;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	ecx, DWORD PTR _pInput$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pOutput$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOutput$[ebp], eax
	mov	ecx, DWORD PTR _pInput$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pInput$[ebp], ecx

; 418  : 			totalBytes++;

	mov	eax, DWORD PTR _totalBytes$[ebp]
	add	eax, 1
	mov	DWORD PTR _totalBytes$[ebp], eax
$LN10@LZSS_Decom:

; 419  : 		}
; 420  : 		cmdByte = cmdByte >> 1;

	mov	eax, DWORD PTR _cmdByte$[ebp]
	sar	eax, 1
	mov	DWORD PTR _cmdByte$[ebp], eax

; 421  : 	}

	jmp	$LN2@LZSS_Decom
$LN3@LZSS_Decom:

; 422  : 
; 423  : 	if( totalBytes != actualSize )

	mov	eax, DWORD PTR _totalBytes$[ebp]
	cmp	eax, DWORD PTR _actualSize$[ebp]
	je	SHORT $LN12@LZSS_Decom

; 424  : 	{
; 425  : 		Assert( 0 );

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??LZSS_Decompress@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	0
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 426  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@LZSS_Decom
$LN12@LZSS_Decom:

; 427  : 	}
; 428  : 	return totalBytes;

	mov	eax, DWORD PTR _totalBytes$[ebp]
$LN1@LZSS_Decom:

; 429  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_Decompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_Compress
_TEXT	SEGMENT
_state$ = -20						; size = 12
_pFinal$ = -8						; size = 4
_pStart$ = -4						; size = 4
_pInput$ = 8						; size = 4
_inputLength$ = 12					; size = 4
_pOutputSize$ = 16					; size = 4
_LZSS_Compress PROC					; COMDAT

; 361  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 362  : 	byte		*pStart = (byte *)malloc( inputLength );

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pStart$[ebp], eax

; 363  : 	byte		*pFinal = NULL;

	mov	DWORD PTR _pFinal$[ebp], 0

; 364  : 	lzss_state_t	state;
; 365  : 
; 366  : 	memset( &state, 0, sizeof( state ));

	push	12					; 0000000cH
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 367  : 	state.window_size = LZSS_WINDOW_SIZE;

	mov	DWORD PTR _state$[ebp+8], 4096		; 00001000H

; 368  : 
; 369  : 	pFinal = LZSS_CompressNoAlloc( &state, pInput, inputLength, pStart, pOutputSize );

	mov	eax, DWORD PTR _pOutputSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pInput$[ebp]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_LZSS_CompressNoAlloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pFinal$[ebp], eax

; 370  : 
; 371  : 	if( !pFinal )

	cmp	DWORD PTR _pFinal$[ebp], 0
	jne	SHORT $LN2@LZSS_Compr

; 372  : 	{
; 373  : 		free( pStart );

	mov	eax, DWORD PTR _pStart$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 374  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@LZSS_Compr
$LN2@LZSS_Compr:

; 375  : 	}
; 376  : 
; 377  : 	return pStart;

	mov	eax, DWORD PTR _pStart$[ebp]
$LN1@LZSS_Compr:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_Compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_GetActualSize
_TEXT	SEGMENT
_phdr$ = -4						; size = 4
_source$ = 8						; size = 4
_LZSS_GetActualSize PROC				; COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 202  : 	lzss_header_t	*phdr = (lzss_header_t *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _phdr$[ebp], eax

; 203  : 
; 204  : 	if( phdr && phdr->id == LZSS_ID )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $LN2@LZSS_GetAc
	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax], 1397971532		; 53535a4cH
	jne	SHORT $LN2@LZSS_GetAc

; 205  : 		return phdr->size;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN1@LZSS_GetAc
$LN2@LZSS_GetAc:

; 206  : 	return 0;

	xor	eax, eax
$LN1@LZSS_GetAc:

; 207  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_GetActualSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _LZSS_IsCompressed
_TEXT	SEGMENT
_phdr$ = -4						; size = 4
_source$ = 8						; size = 4
_LZSS_IsCompressed PROC					; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 193  : 	lzss_header_t	*phdr = (lzss_header_t *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _phdr$[ebp], eax

; 194  : 
; 195  : 	if( phdr && phdr->id == LZSS_ID )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $LN2@LZSS_IsCom
	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax], 1397971532		; 53535a4cH
	jne	SHORT $LN2@LZSS_IsCom

; 196  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@LZSS_IsCom
$LN2@LZSS_IsCom:

; 197  : 	return false;

	xor	eax, eax
$LN1@LZSS_IsCom:

; 198  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LZSS_IsCompressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_RandomFloat
_TEXT	SEGMENT
tv77 = -72						; size = 4
_fl$ = -4						; size = 4
_flLow$ = 8						; size = 4
_flHigh$ = 12						; size = 4
_COM_RandomFloat PROC					; COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 116  : 	float	fl;
; 117  : 
; 118  : 	if( idum == 0 ) COM_SetRandomSeed( 0 );

	cmp	DWORD PTR _idum, 0
	jne	SHORT $LN2@COM_Random
	push	0
	call	_COM_SetRandomSeed
	add	esp, 4
$LN2@COM_Random:

; 119  : 
; 120  : 	fl = fran1(); // float in [0,1]

	call	_fran1
	fstp	DWORD PTR _fl$[ebp]

; 121  : 	return (fl * (flHigh - flLow)) + flLow; // float in [low, high)

	movss	xmm0, DWORD PTR _flHigh$[ebp]
	subss	xmm0, DWORD PTR _flLow$[ebp]
	mulss	xmm0, DWORD PTR _fl$[ebp]
	addss	xmm0, DWORD PTR _flLow$[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	fld	DWORD PTR tv77[ebp]

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_RandomFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_RandomLong
_TEXT	SEGMENT
_x$ = -12						; size = 4
_n$ = -8						; size = 4
_maxAcceptable$ = -4					; size = 4
_lLow$ = 8						; size = 4
_lHigh$ = 12						; size = 4
_COM_RandomLong PROC					; COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 126  : 	dword	maxAcceptable;
; 127  : 	dword	n, x = lHigh - lLow + 1; 	

	mov	eax, DWORD PTR _lHigh$[ebp]
	sub	eax, DWORD PTR _lLow$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 128  : 
; 129  : 	if( idum == 0 ) COM_SetRandomSeed( 0 );

	cmp	DWORD PTR _idum, 0
	jne	SHORT $LN5@COM_Random
	push	0
	call	_COM_SetRandomSeed
	add	esp, 4
$LN5@COM_Random:

; 130  : 
; 131  : 	if( x <= 0 || MAX_RANDOM_RANGE < x - 1 )

	cmp	DWORD PTR _x$[ebp], 0
	jbe	SHORT $LN7@COM_Random
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN6@COM_Random
$LN7@COM_Random:

; 132  : 		return lLow;

	mov	eax, DWORD PTR _lLow$[ebp]
	jmp	SHORT $LN1@COM_Random
$LN6@COM_Random:

; 133  : 
; 134  : 	// The following maps a uniform distribution on the interval [0, MAX_RANDOM_RANGE]
; 135  : 	// to a smaller, client-specified range of [0,x-1] in a way that doesn't bias
; 136  : 	// the uniform distribution unfavorably. Even for a worst case x, the loop is
; 137  : 	// guaranteed to be taken no more than half the time, so for that worst case x,
; 138  : 	// the average number of times through the loop is 2. For cases where x is
; 139  : 	// much smaller than MAX_RANDOM_RANGE, the average number of times through the
; 140  : 	// loop is very close to 1.
; 141  : 	maxAcceptable = MAX_RANDOM_RANGE - ((MAX_RANDOM_RANGE + 1) % x );

	mov	eax, -2147483648			; 80000000H
	xor	edx, edx
	div	DWORD PTR _x$[ebp]
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edx
	mov	DWORD PTR _maxAcceptable$[ebp], eax
$LN4@COM_Random:

; 142  : 	do
; 143  : 	{
; 144  : 		n = lran1();

	call	_lran1
	mov	DWORD PTR _n$[ebp], eax

; 145  : 	} while( n > maxAcceptable );

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _maxAcceptable$[ebp]
	ja	SHORT $LN4@COM_Random

; 146  : 
; 147  : 	return lLow + (n % x);

	mov	eax, DWORD PTR _n$[ebp]
	xor	edx, edx
	div	DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _lLow$[ebp]
	mov	eax, edx
$LN1@COM_Random:

; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_RandomLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_SetRandomSeed
_TEXT	SEGMENT
_lSeed$ = 8						; size = 4
_COM_SetRandomSeed PROC					; COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 105  : 	if( lSeed ) idum = lSeed;

	cmp	DWORD PTR _lSeed$[ebp], 0
	je	SHORT $LN2@COM_SetRan
	mov	eax, DWORD PTR _lSeed$[ebp]
	mov	DWORD PTR _idum, eax
	jmp	SHORT $LN3@COM_SetRan
$LN2@COM_SetRan:

; 106  : 	else idum = -time( NULL );

	push	0
	call	_time
	add	esp, 4
	neg	eax
	mov	DWORD PTR _idum, eax
$LN3@COM_SetRan:

; 107  : 
; 108  : 	if( 1000 < idum )

	cmp	DWORD PTR _idum, 1000			; 000003e8H
	jle	SHORT $LN4@COM_SetRan

; 109  : 		idum = -idum;

	mov	eax, DWORD PTR _idum
	neg	eax
	mov	DWORD PTR _idum, eax
	jmp	SHORT $LN1@COM_SetRan
$LN4@COM_SetRan:

; 110  : 	else if( -1000 < idum )

	cmp	DWORD PTR _idum, -1000			; fffffc18H
	jle	SHORT $LN1@COM_SetRan

; 111  : 		idum -= 22261048;

	mov	eax, DWORD PTR _idum
	sub	eax, 22261048				; 0153ad38H
	mov	DWORD PTR _idum, eax
$LN1@COM_SetRan:

; 112  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_SetRandomSeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_ExpandFilename
_TEXT	SEGMENT
_result$ = -1032					; size = 1024
_path$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_fileName$ = 8						; size = 4
_nameOutBuffer$ = 12					; size = 4
_nameOutBufferSize$ = 16				; size = 4
_COM_ExpandFilename PROC				; COMDAT

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 809  : 	const char	*path;
; 810  : 	char		result[MAX_SYSPATH];
; 811  : 
; 812  : 	if( !COM_CheckString( fileName ) || !nameOutBuffer || nameOutBufferSize <= 0 )

	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@COM_Expand
	cmp	DWORD PTR _nameOutBuffer$[ebp], 0
	je	SHORT $LN3@COM_Expand
	cmp	DWORD PTR _nameOutBufferSize$[ebp], 0
	jg	SHORT $LN2@COM_Expand
$LN3@COM_Expand:

; 813  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@COM_Expand
$LN2@COM_Expand:

; 814  : 
; 815  : 	// filename examples:
; 816  : 	// media\sierra.avi - D:\Xash3D\valve\media\sierra.avi
; 817  : 	// models\barney.mdl - D:\Xash3D\bshift\models\barney.mdl
; 818  : 	if(( path = FS_GetDiskPath( fileName, false )) != NULL )

	push	0
	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	mov	DWORD PTR _path$[ebp], eax
	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN4@COM_Expand

; 819  : 	{
; 820  : 		Q_sprintf( result, "%s/%s", host.rootdir, path );		

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 821  : 
; 822  : 		// check for enough room
; 823  : 		if( Q_strlen( result ) > nameOutBufferSize )

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, DWORD PTR _nameOutBufferSize$[ebp]
	jle	SHORT $LN5@COM_Expand

; 824  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@COM_Expand
$LN5@COM_Expand:

; 825  : 
; 826  : 		Q_strncpy( nameOutBuffer, result, nameOutBufferSize );

	mov	eax, DWORD PTR _nameOutBufferSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nameOutBuffer$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 827  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@COM_Expand
$LN4@COM_Expand:

; 828  : 	}
; 829  : 	return 0;

	xor	eax, eax
$LN1@COM_Expand:

; 830  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_ExpandFilename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_AddAppDirectoryToSearchPath
_TEXT	SEGMENT
_pszBaseDir$ = 8					; size = 4
_appName$ = 12						; size = 4
_COM_AddAppDirectoryToSearchPath PROC			; COMDAT

; 795  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 796  : 	FS_AddGameHierarchy( pszBaseDir, FS_NOWRITE_PATH );

	push	2
	mov	eax, DWORD PTR _pszBaseDir$[ebp]
	push	eax
	call	_FS_AddGameHierarchy
	add	esp, 8

; 797  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_AddAppDirectoryToSearchPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_LoadFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_usehunk$ = 12						; size = 4
_pLength$ = 16						; size = 4
_COM_LoadFile PROC					; COMDAT

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1050 : 	return COM_LoadFileForMe( filename, pLength );

	mov	eax, DWORD PTR _pLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_COM_LoadFileForMe
	add	esp, 8

; 1051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_LoadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_ParseFile
_TEXT	SEGMENT
_len$ = -8						; size = 4
_c$ = -4						; size = 4
_data$ = 8						; size = 4
_token$ = 12						; size = 4
_COM_ParseFile PROC					; COMDAT

; 643  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 644  : 	int	c, len;
; 645  : 
; 646  : 	if( !token )

	cmp	DWORD PTR _token$[ebp], 0
	jne	SHORT $LN11@COM_ParseF

; 647  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$LN11@COM_ParseF:

; 648  : 	
; 649  : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 650  : 	token[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _token$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 651  : 	
; 652  : 	if( !data )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $skipwhite$21

; 653  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$skipwhite$21:

; 654  : // skip whitespace
; 655  : skipwhite:
; 656  : 	while(( c = ((byte)*data)) <= ' ' )

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN3@COM_ParseF

; 657  : 	{
; 658  : 		if( c == 0 )

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN13@COM_ParseF

; 659  : 			return NULL;	// end of file;

	xor	eax, eax
	jmp	$LN1@COM_ParseF
$LN13@COM_ParseF:

; 660  : 		data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax

; 661  : 	}

	jmp	SHORT $skipwhite$21
$LN3@COM_ParseF:

; 662  : 	
; 663  : 	// skip // comments
; 664  : 	if( c=='/' && data[1] == '/' )

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN14@COM_ParseF
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _data$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN14@COM_ParseF
$LN4@COM_ParseF:

; 665  : 	{
; 666  : 		while( *data && *data != '\n' )

	mov	eax, DWORD PTR _data$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@COM_ParseF
	mov	eax, DWORD PTR _data$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN5@COM_ParseF

; 667  : 			data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax
	jmp	SHORT $LN4@COM_ParseF
$LN5@COM_ParseF:

; 668  : 		goto skipwhite;

	jmp	SHORT $skipwhite$21
$LN14@COM_ParseF:

; 669  : 	}
; 670  : 
; 671  : 	// handle quoted strings specially
; 672  : 	if( c == '\"' )

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	jne	SHORT $LN15@COM_ParseF

; 673  : 	{
; 674  : 		data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax
$LN6@COM_ParseF:

; 675  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN15@COM_ParseF

; 676  : 		{
; 677  : 			c = (byte)*data++;

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _data$[ebp]
	add	edx, 1
	mov	DWORD PTR _data$[ebp], edx

; 678  : 			if( c == '\"' || !c )

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	je	SHORT $LN17@COM_ParseF
	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN16@COM_ParseF
$LN17@COM_ParseF:

; 679  : 			{
; 680  : 				token[len] = 0;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 681  : 				return data;

	mov	eax, DWORD PTR _data$[ebp]
	jmp	$LN1@COM_ParseF
$LN16@COM_ParseF:

; 682  : 			}
; 683  : 			token[len] = c;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl

; 684  : 			len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 685  : 		}

	jmp	SHORT $LN6@COM_ParseF
$LN15@COM_ParseF:

; 686  : 	}
; 687  : 
; 688  : 	// parse single characters
; 689  : 	if( COM_IsSingleChar( c ))

	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_COM_IsSingleChar
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@COM_ParseF

; 690  : 	{
; 691  : 		token[len] = c;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl

; 692  : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 693  : 		token[len] = 0;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 694  : 		return data + 1;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	jmp	SHORT $LN1@COM_ParseF
$LN10@COM_ParseF:

; 695  : 	}
; 696  : 
; 697  : 	// parse a regular word
; 698  : 	do
; 699  : 	{
; 700  : 		token[len] = c;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl

; 701  : 		data++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _data$[ebp], eax

; 702  : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 703  : 		c = ((byte)*data);

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx

; 704  : 
; 705  : 		if( COM_IsSingleChar( c ))

	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_COM_IsSingleChar
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@COM_ParseF

; 706  : 			break;

	jmp	SHORT $LN9@COM_ParseF
$LN8@COM_ParseF:

; 707  : 	} while( c > 32 );

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jg	SHORT $LN10@COM_ParseF
$LN9@COM_ParseF:

; 708  : 	
; 709  : 	token[len] = 0;

	mov	eax, DWORD PTR _token$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0

; 710  : 
; 711  : 	return data;

	mov	eax, DWORD PTR _data$[ebp]
$LN1@COM_ParseF:

; 712  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_ParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnTime
_TEXT	SEGMENT
tv68 = -68						; size = 4
_pfnTime PROC						; COMDAT

; 1266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1267 : 	return (float)Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	DWORD PTR tv68[ebp]
	fld	DWORD PTR tv68[ebp]

; 1268 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnGetModelType
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_pfnGetModelType PROC					; COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1110 : 	if( !mod ) return mod_bad;

	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN2@pfnGetMode
	or	eax, -1
	jmp	SHORT $LN1@pfnGetMode
$LN2@pfnGetMode:

; 1111 : 	return mod->type;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [eax+68]
$LN1@pfnGetMode:

; 1112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnGetGameDir
_TEXT	SEGMENT
_szGetGameDir$ = 8					; size = 4
_pfnGetGameDir PROC					; COMDAT

; 1277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1278 : 	if( !szGetGameDir ) return;

	cmp	DWORD PTR _szGetGameDir$[ebp], 0
	jne	SHORT $LN2@pfnGetGame
	jmp	SHORT $LN1@pfnGetGame
$LN2@pfnGetGame:

; 1279 : 	Q_sprintf( szGetGameDir, "%s/%s", host.rootdir, GI->gamedir );

	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	mov	ecx, DWORD PTR _szGetGameDir$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H
$LN1@pfnGetGame:

; 1280 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetGameDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_CheckParm
_TEXT	SEGMENT
_i$ = -4						; size = 4
_parm$ = 8						; size = 4
_ppnext$ = 12						; size = 4
_COM_CheckParm PROC					; COMDAT

; 1246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1247 : 	int	i = Sys_CheckParm( parm );

	mov	eax, DWORD PTR _parm$[ebp]
	push	eax
	call	_Sys_CheckParm
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 1248 : 
; 1249 : 	if( ppnext )

	cmp	DWORD PTR _ppnext$[ebp], 0
	je	SHORT $LN2@COM_CheckP

; 1250 : 	{
; 1251 : 		if( i != 0 && i < host.argc - 1 )

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN3@COM_CheckP
	mov	eax, DWORD PTR _host+920
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@COM_CheckP

; 1252 : 			*ppnext = (char *)host.argv[i + 1];

	mov	eax, DWORD PTR _ppnext$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+928]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@COM_CheckP
$LN3@COM_CheckP:

; 1253 : 		else *ppnext = NULL;

	mov	eax, DWORD PTR _ppnext$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@COM_CheckP:

; 1254 : 	}
; 1255 : 
; 1256 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]

; 1257 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_CheckParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCVarDirectSet
_TEXT	SEGMENT
_var$ = 8						; size = 4
_szValue$ = 12						; size = 4
_pfnCVarDirectSet PROC					; COMDAT

; 1207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1208 : 	Cvar_DirectSet( (convar_t *)var, szValue );

	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _var$[ebp]
	push	ecx
	call	_Cvar_DirectSet
	add	esp, 8

; 1209 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCVarDirectSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnGetModelBounds
_TEXT	SEGMENT
_mod$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_pfnGetModelBounds PROC					; COMDAT

; 1121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1122 : 	if( mod )

	cmp	DWORD PTR _mod$[ebp], 0
	je	$LN2@pfnGetMode

; 1123 : 	{
; 1124 : 		if( mins ) VectorCopy( mod->mins, mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN4@pfnGetMode
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mins$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+84]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+84]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+84]
	mov	DWORD PTR [edx+ecx], eax
$LN4@pfnGetMode:

; 1125 : 		if( maxs ) VectorCopy( mod->maxs, maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN5@pfnGetMode
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+96]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	edx, DWORD PTR [esi+edx+96]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [esi+eax+96]
	mov	DWORD PTR [edx+ecx], eax
$LN5@pfnGetMode:

; 1126 : 	}

	jmp	SHORT $LN7@pfnGetMode
$LN2@pfnGetMode:

; 1127 : 	else
; 1128 : 	{
; 1129 : 		if( mins ) VectorClear( mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN6@pfnGetMode
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN6@pfnGetMode:

; 1130 : 		if( maxs ) VectorClear( maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN7@pfnGetMode
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _maxs$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
$LN7@pfnGetMode:

; 1131 : 	}
; 1132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_TrimSpace
_TEXT	SEGMENT
_length$ = -12						; size = 4
_end$ = -8						; size = 4
_start$ = -4						; size = 4
_source$ = 8						; size = 4
_dest$ = 12						; size = 4
_COM_TrimSpace PROC					; COMDAT

; 841  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 842  : 	int	start, end, length;
; 843  : 
; 844  : 	start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 845  : 	end = Q_strlen( source );

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _end$[ebp], eax
$LN2@COM_TrimSp:

; 846  : 
; 847  : 	while( source[start] && COM_IsWhiteSpace( source[start] ))

	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@COM_TrimSp
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_COM_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@COM_TrimSp

; 848  : 		start++;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, 1
	mov	DWORD PTR _start$[ebp], eax
	jmp	SHORT $LN2@COM_TrimSp
$LN3@COM_TrimSp:

; 849  : 	end--;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN4@COM_TrimSp:

; 850  : 
; 851  : 	while( end > 0 && COM_IsWhiteSpace( source[end] ))

	cmp	DWORD PTR _end$[ebp], 0
	jle	SHORT $LN5@COM_TrimSp
	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_COM_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@COM_TrimSp

; 852  : 		end--;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN4@COM_TrimSp
$LN5@COM_TrimSp:

; 853  : 	end++;

	mov	eax, DWORD PTR _end$[ebp]
	add	eax, 1
	mov	DWORD PTR _end$[ebp], eax

; 854  : 
; 855  : 	length = end - start;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 856  : 
; 857  : 	if( length > 0 )

	cmp	DWORD PTR _length$[ebp], 0
	jle	SHORT $LN6@COM_TrimSp

; 858  : 		memcpy( dest, source + start, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	add	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@COM_TrimSp
$LN6@COM_TrimSp:

; 859  : 	else length = 0;

	mov	DWORD PTR _length$[ebp], 0
$LN7@COM_TrimSp:

; 860  : 
; 861  : 	// terminate the dest string
; 862  : 	dest[length] = 0;

	mov	eax, DWORD PTR _dest$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax], 0

; 863  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_TrimSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _Cache_Check
_TEXT	SEGMENT
_mempool$ = 8						; size = 4
_c$ = 12						; size = 4
_Cache_Check PROC					; COMDAT

; 992  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 993  : 	if( !c->data )

	mov	eax, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@Cache_Chec

; 994  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Cache_Chec
$LN2@Cache_Chec:

; 995  : 
; 996  : 	if( !Mem_IsAllocatedExt( mempool, c->data ))

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mempool$[ebp]
	push	edx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@Cache_Chec

; 997  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Cache_Chec
$LN3@Cache_Chec:

; 998  : 
; 999  : 	return c->data;

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax]
$LN1@Cache_Chec:

; 1000 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cache_Check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCVarGetPointer
_TEXT	SEGMENT
_szVarName$ = 8						; size = 4
_pfnCVarGetPointer PROC					; COMDAT

; 1195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1196 : 	return (cvar_t *)Cvar_FindVar( szVarName );

	push	0
	mov	eax, DWORD PTR _szVarName$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8

; 1197 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCVarGetPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_IsSafeFileToDownload
_TEXT	SEGMENT
_i$ = -4116						; size = 4
_ext$ = -4112						; size = 4
_last$ = -4108						; size = 4
_first$ = -4104						; size = 4
_lwrfilename$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_COM_IsSafeFileToDownload PROC				; COMDAT

; 1283 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4628				; 00001214H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1284 : 	char		lwrfilename[4096];
; 1285 : 	const char	*first, *last;
; 1286 : 	const char	*ext;
; 1287 : 	int		i;
; 1288 : 
; 1289 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@COM_IsSafe

; 1290 : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_IsSafe
$LN5@COM_IsSafe:

; 1291 : 
; 1292 : 	if( !Q_strncmp( filename, "!MD5", 4 ))

	push	4
	push	OFFSET ??_C@_04HJKAGJBM@?$CBMD5@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@COM_IsSafe

; 1293 : 		return true;

	mov	eax, 1
	jmp	$LN1@COM_IsSafe
$LN6@COM_IsSafe:

; 1294 : 
; 1295 : 	Q_strnlwr( filename, lwrfilename, sizeof( lwrfilename ));

	push	4096					; 00001000H
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_strnlwr
	add	esp, 12					; 0000000cH

; 1296 : 
; 1297 : 	if( Q_strstr( lwrfilename, "\\" ) || Q_strstr( lwrfilename, ":" ) || Q_strstr( lwrfilename, ".." ) || Q_strstr( lwrfilename, "~" ))

	push	OFFSET ??_C@_01KICIPPFI@?2@
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@COM_IsSafe
	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@COM_IsSafe
	push	OFFSET ??_C@_02DJGKEECL@?4?4@
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@COM_IsSafe
	push	OFFSET ??_C@_01PJKLJHI@?$HO@
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@COM_IsSafe
$LN8@COM_IsSafe:

; 1298 : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_IsSafe
$LN7@COM_IsSafe:

; 1299 : 
; 1300 : 	if( lwrfilename[0] == '/' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _lwrfilename$[ebp+ecx]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN9@COM_IsSafe

; 1301 : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_IsSafe
$LN9@COM_IsSafe:

; 1302 : 
; 1303 : 	first = Q_strchr( lwrfilename, '.' );

	push	46					; 0000002eH
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strchr
	add	esp, 8
	mov	DWORD PTR _first$[ebp], eax

; 1304 : 	last = Q_strrchr( lwrfilename, '.' );

	push	46					; 0000002eH
	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _last$[ebp], eax

; 1305 : 
; 1306 : 	if( first == NULL || last == NULL )

	cmp	DWORD PTR _first$[ebp], 0
	je	SHORT $LN11@COM_IsSafe
	cmp	DWORD PTR _last$[ebp], 0
	jne	SHORT $LN10@COM_IsSafe
$LN11@COM_IsSafe:

; 1307 : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_IsSafe
$LN10@COM_IsSafe:

; 1308 : 
; 1309 : 	if( first != last )

	mov	eax, DWORD PTR _first$[ebp]
	cmp	eax, DWORD PTR _last$[ebp]
	je	SHORT $LN12@COM_IsSafe

; 1310 : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_IsSafe
$LN12@COM_IsSafe:

; 1311 : 
; 1312 : 	if( Q_strlen( first ) != 4 )

	mov	eax, DWORD PTR _first$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 4
	je	SHORT $LN13@COM_IsSafe

; 1313 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@COM_IsSafe
$LN13@COM_IsSafe:

; 1314 : 
; 1315 : 	ext = COM_FileExtension( lwrfilename );

	lea	eax, DWORD PTR _lwrfilename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 1316 : 
; 1317 : 	for( i = 0; i < ARRAYSIZE( file_exts ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_IsSafe
$LN2@COM_IsSafe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@COM_IsSafe:
	cmp	DWORD PTR _i$[ebp], 10			; 0000000aH
	jae	SHORT $LN3@COM_IsSafe

; 1318 : 	{
; 1319 : 		if( !Q_stricmp( ext, file_exts[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _file_exts[eax*4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@COM_IsSafe

; 1320 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@COM_IsSafe
$LN14@COM_IsSafe:

; 1321 : 	}

	jmp	SHORT $LN2@COM_IsSafe
$LN3@COM_IsSafe:

; 1322 : 
; 1323 : 	return true;

	mov	eax, 1
$LN1@COM_IsSafe:

; 1324 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_IsSafeFileToDownload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_LoadFileForMe
_TEXT	SEGMENT
_iLength$ = -272					; size = 4
_pfile$ = -268						; size = 4
_file$ = -264						; size = 4
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pLength$ = 12						; size = 4
_COM_LoadFileForMe PROC					; COMDAT

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1010 : 	string	name;
; 1011 : 	byte	*file, *pfile;
; 1012 : 	int	iLength;
; 1013 : 
; 1014 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@COM_LoadFi

; 1015 : 	{
; 1016 : 		if( pLength )

	cmp	DWORD PTR _pLength$[ebp], 0
	je	SHORT $LN3@COM_LoadFi

; 1017 : 			*pLength = 0;

	mov	eax, DWORD PTR _pLength$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@COM_LoadFi:

; 1018 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_LoadFi
$LN2@COM_LoadFi:

; 1019 : 	}
; 1020 : 
; 1021 : 	Q_strncpy( name, filename, sizeof( name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1022 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1023 : 
; 1024 : 	pfile = FS_LoadFile( name, &iLength, false );

	push	0
	lea	eax, DWORD PTR _iLength$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pfile$[ebp], eax

; 1025 : 	if( pLength ) *pLength = iLength;

	cmp	DWORD PTR _pLength$[ebp], 0
	je	SHORT $LN4@COM_LoadFi
	mov	eax, DWORD PTR _pLength$[ebp]
	mov	ecx, DWORD PTR _iLength$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@COM_LoadFi:

; 1026 : 
; 1027 : 	if( pfile )

	cmp	DWORD PTR _pfile$[ebp], 0
	je	SHORT $LN5@COM_LoadFi

; 1028 : 	{
; 1029 : 		file = malloc( iLength + 1 );

	mov	eax, DWORD PTR _iLength$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _file$[ebp], eax

; 1030 : 		if( file != NULL )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $LN6@COM_LoadFi

; 1031 : 		{
; 1032 : 			memcpy( file, pfile, iLength );

	mov	eax, DWORD PTR _iLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1033 : 			file[iLength] = '\0';

	mov	eax, DWORD PTR _file$[ebp]
	add	eax, DWORD PTR _iLength$[ebp]
	mov	BYTE PTR [eax], 0
$LN6@COM_LoadFi:

; 1034 : 		}
; 1035 : 		Mem_Free( pfile );

	mov	eax, DWORD PTR ?__LINE__Var@?0??COM_LoadFileForMe@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DD@HCMJEACK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1036 : 		pfile = file;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN5@COM_LoadFi:

; 1037 : 	}
; 1038 : 
; 1039 : 	return pfile;

	mov	eax, DWORD PTR _pfile$[ebp]
$LN1@COM_LoadFi:

; 1040 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_LoadFileForMe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_SaveFile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 4
_COM_SaveFile PROC					; COMDAT

; 1060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1061 : 	// check for empty filename
; 1062 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@COM_SaveFi

; 1063 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@COM_SaveFi
$LN2@COM_SaveFi:

; 1064 : 
; 1065 : 	// check for null data
; 1066 : 	if( !data || len <= 0 )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN4@COM_SaveFi
	cmp	DWORD PTR _len$[ebp], 0
	jg	SHORT $LN3@COM_SaveFi
$LN4@COM_SaveFi:

; 1067 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@COM_SaveFi
$LN3@COM_SaveFi:

; 1068 : 
; 1069 : 	return FS_WriteFile( filename, data, len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH
$LN1@COM_SaveFi:

; 1070 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_SaveFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_HexConvert
_TEXT	SEGMENT
_i$ = -12						; size = 4
_p$ = -8						; size = 4
_pIn$ = -4						; size = 4
_pszInput$ = 8						; size = 4
_nInputLength$ = 12					; size = 4
_pOutput$ = 16						; size = 4
_COM_HexConvert PROC					; COMDAT

; 917  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 918  : 	const char	*pIn;
; 919  : 	byte		*p = pOutput;

	mov	eax, DWORD PTR _pOutput$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 920  : 	int		i;
; 921  : 
; 922  : 
; 923  : 	for( i = 0; i < nInputLength; i += 2 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_HexCon
$LN2@COM_HexCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN4@COM_HexCon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nInputLength$[ebp]
	jge	SHORT $LN1@COM_HexCon

; 924  : 	{
; 925  : 		pIn = &pszInput[i];

	mov	eax, DWORD PTR _pszInput$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pIn$[ebp], eax

; 926  : 		*p = COM_Nibble( pIn[0] ) << 4 | COM_Nibble( pIn[1] );		

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pIn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_COM_Nibble
	add	esp, 4
	movzx	ebx, al
	shl	ebx, 4
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pIn$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_COM_Nibble
	add	esp, 4
	movzx	ecx, al
	or	ebx, ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], bl

; 927  : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 928  : 	}

	jmp	SHORT $LN2@COM_HexCon
$LN1@COM_HexCon:

; 929  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_HexConvert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_MemFgets
_TEXT	SEGMENT
_size$1 = -16						; size = 4
_stop$ = -12						; size = 4
_last$ = -8						; size = 4
_i$ = -4						; size = 4
_pMemFile$ = 8						; size = 4
_fileSize$ = 12						; size = 4
_filePos$ = 16						; size = 4
_pBuffer$ = 20						; size = 4
_bufferSize$ = 24					; size = 4
_COM_MemFgets PROC					; COMDAT

; 938  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 939  : 	int	i, last, stop;
; 940  : 
; 941  : 	if( !pMemFile || !pBuffer || !filePos )

	cmp	DWORD PTR _pMemFile$[ebp], 0
	je	SHORT $LN5@COM_MemFge
	cmp	DWORD PTR _pBuffer$[ebp], 0
	je	SHORT $LN5@COM_MemFge
	cmp	DWORD PTR _filePos$[ebp], 0
	jne	SHORT $LN4@COM_MemFge
$LN5@COM_MemFge:

; 942  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_MemFge
$LN4@COM_MemFge:

; 943  : 
; 944  : 	if( *filePos >= fileSize )

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _fileSize$[ebp]
	jl	SHORT $LN6@COM_MemFge

; 945  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@COM_MemFge
$LN6@COM_MemFge:

; 946  : 
; 947  : 	i = *filePos;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx

; 948  : 	last = fileSize;

	mov	eax, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR _last$[ebp], eax

; 949  : 
; 950  : 	// fgets always NULL terminates, so only read bufferSize-1 characters
; 951  : 	if( last - *filePos > ( bufferSize - 1 ))

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _last$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _bufferSize$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN7@COM_MemFge

; 952  : 		last = *filePos + ( bufferSize - 1);

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _bufferSize$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR _last$[ebp], eax
$LN7@COM_MemFge:

; 953  : 
; 954  : 	stop = 0;

	mov	DWORD PTR _stop$[ebp], 0
$LN2@COM_MemFge:

; 955  : 
; 956  : 	// stop at the next newline (inclusive) or end of buffer
; 957  : 	while( i < last && !stop )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _last$[ebp]
	jge	SHORT $LN3@COM_MemFge
	cmp	DWORD PTR _stop$[ebp], 0
	jne	SHORT $LN3@COM_MemFge

; 958  : 	{
; 959  : 		if( pMemFile[i] == '\n' )

	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN8@COM_MemFge

; 960  : 			stop = 1;

	mov	DWORD PTR _stop$[ebp], 1
$LN8@COM_MemFge:

; 961  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 962  : 	}

	jmp	SHORT $LN2@COM_MemFge
$LN3@COM_MemFge:

; 963  : 
; 964  : 	// if we actually advanced the pointer, copy it over
; 965  : 	if( i != *filePos )

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN9@COM_MemFge

; 966  : 	{
; 967  : 		// we read in size bytes
; 968  : 		int	size = i - *filePos;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _size$1[ebp], ecx

; 969  : 
; 970  : 		// copy it out
; 971  : 		memcpy( pBuffer, pMemFile + *filePos, size );

	mov	eax, DWORD PTR _size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _filePos$[ebp]
	mov	edx, DWORD PTR _pMemFile$[ebp]
	add	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pBuffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 972  : 		
; 973  : 		// If the buffer isn't full, terminate (this is always true)
; 974  : 		if( size < bufferSize ) pBuffer[size] = 0;

	mov	eax, DWORD PTR _size$1[ebp]
	cmp	eax, DWORD PTR _bufferSize$[ebp]
	jge	SHORT $LN10@COM_MemFge
	mov	eax, DWORD PTR _pBuffer$[ebp]
	add	eax, DWORD PTR _size$1[ebp]
	mov	BYTE PTR [eax], 0
$LN10@COM_MemFge:

; 975  : 
; 976  : 		// update file pointer
; 977  : 		*filePos = i;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 978  : 		return pBuffer;

	mov	eax, DWORD PTR _pBuffer$[ebp]
	jmp	SHORT $LN1@COM_MemFge
$LN9@COM_MemFge:

; 979  : 	}
; 980  : 
; 981  : 	return NULL;

	xor	eax, eax
$LN1@COM_MemFge:

; 982  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_MemFgets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCvar_RegisterGameUIVariable
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_szValue$ = 12						; size = 4
_flags$ = 16						; size = 4
_pfnCvar_RegisterGameUIVariable PROC			; COMDAT

; 1181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1182 : 	if( FBitSet( flags, FCVAR_GLCONFIG ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN2@pfnCvar_Re

; 1183 : 		return (cvar_t *)Cvar_Get( szName, szValue, flags, va( CVAR_GLCONFIG_DESCRIPTION, szName ));

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnCvar_Re
$LN2@pfnCvar_Re:

; 1184 : 	return (cvar_t *)Cvar_Get( szName, szValue, flags|FCVAR_GAMEUIDLL, Cvar_BuildAutoDescription( flags|FCVAR_GAMEUIDLL ));

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16384				; 00004000H
	push	eax
	call	_Cvar_BuildAutoDescription
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 16384				; 00004000H
	push	ecx
	mov	edx, DWORD PTR _szValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H
$LN1@pfnCvar_Re:

; 1185 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCvar_RegisterGameUIVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCvar_RegisterClientVariable
_TEXT	SEGMENT
_szName$ = 8						; size = 4
_szValue$ = 12						; size = 4
_flags$ = 16						; size = 4
_pfnCvar_RegisterClientVariable PROC			; COMDAT

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1169 : 	if( FBitSet( flags, FCVAR_GLCONFIG ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN2@pfnCvar_Re

; 1170 : 		return (cvar_t *)Cvar_Get( szName, szValue, flags, va( CVAR_GLCONFIG_DESCRIPTION, szName ));

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@pfnCvar_Re
$LN2@pfnCvar_Re:

; 1171 : 	return (cvar_t *)Cvar_Get( szName, szValue, flags|FCVAR_CLIENTDLL, Cvar_BuildAutoDescription( flags|FCVAR_CLIENTDLL ));

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16					; 00000010H
	push	eax
	call	_Cvar_BuildAutoDescription
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _szValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H
$LN1@pfnCvar_Re:

; 1172 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCvar_RegisterClientVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCvar_RegisterEngineVariable
_TEXT	SEGMENT
_variable$ = 8						; size = 4
_pfnCvar_RegisterEngineVariable PROC			; COMDAT

; 1157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1158 : 	Cvar_RegisterVariable( (convar_t *)variable );

	mov	eax, DWORD PTR _variable$[ebp]
	push	eax
	call	_Cvar_RegisterVariable
	add	esp, 4

; 1159 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCvar_RegisterEngineVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _pfnCvar_RegisterServerVariable
_TEXT	SEGMENT
_variable$ = 8						; size = 4
_pfnCvar_RegisterServerVariable PROC			; COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1143 : 	if( variable != NULL )

	cmp	DWORD PTR _variable$[ebp], 0
	je	SHORT $LN2@pfnCvar_Re

; 1144 : 		SetBits( variable->flags, FCVAR_EXTDLL );

	mov	eax, DWORD PTR _variable$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8
	mov	edx, DWORD PTR _variable$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN2@pfnCvar_Re:

; 1145 : 	Cvar_RegisterVariable( (convar_t *)variable );

	mov	eax, DWORD PTR _variable$[ebp]
	push	eax
	call	_Cvar_RegisterVariable
	add	esp, 4

; 1146 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCvar_RegisterServerVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_StripExtension
_TEXT	SEGMENT
_length$ = -4						; size = 4
_path$ = 8						; size = 4
_COM_StripExtension PROC				; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 552  : 	size_t	length;
; 553  : 
; 554  : 	length = Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _length$[ebp], eax
$LN2@COM_StripE:

; 555  : 	while( length > 0 && path[length] != '.' )

	cmp	DWORD PTR _length$[ebp], 0
	jbe	SHORT $LN3@COM_StripE
	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN3@COM_StripE

; 556  : 	{
; 557  : 		length--;

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 558  : 		if( path[length] == '/' || path[length] == '\\' || path[length] == ':' )

	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN5@COM_StripE
	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@COM_StripE
	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN4@COM_StripE
$LN5@COM_StripE:

; 559  : 			return; // no extension

	jmp	SHORT $LN1@COM_StripE
$LN4@COM_StripE:

; 560  : 	}

	jmp	SHORT $LN2@COM_StripE
$LN3@COM_StripE:

; 561  : 
; 562  : 	if( length ) path[length] = 0;

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN1@COM_StripE
	mov	eax, DWORD PTR _path$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@COM_StripE:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_StripExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_CompareFileTime
_TEXT	SEGMENT
_ft2$1 = -12						; size = 4
_ft1$2 = -8						; size = 4
_bRet$ = -4						; size = 4
_filename1$ = 8						; size = 4
_filename2$ = 12					; size = 4
_iCompare$ = 16						; size = 4
_COM_CompareFileTime PROC				; COMDAT

; 1218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1219 : 	int	bRet = 0;

	mov	DWORD PTR _bRet$[ebp], 0

; 1220 : 
; 1221 : 	*iCompare = 0;

	mov	eax, DWORD PTR _iCompare$[ebp]
	mov	DWORD PTR [eax], 0

; 1222 : 
; 1223 : 	if( filename1 && filename2 )

	cmp	DWORD PTR _filename1$[ebp], 0
	je	SHORT $LN2@COM_Compar
	cmp	DWORD PTR _filename2$[ebp], 0
	je	SHORT $LN2@COM_Compar

; 1224 : 	{
; 1225 : 		long ft1 = FS_FileTime( filename1, false );

	push	0
	mov	eax, DWORD PTR _filename1$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft1$2[ebp], eax

; 1226 : 		long ft2 = FS_FileTime( filename2, false );

	push	0
	mov	eax, DWORD PTR _filename2$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	DWORD PTR _ft2$1[ebp], eax

; 1227 : 
; 1228 : 		// one of files is missing
; 1229 : 		if( ft1 == -1 || ft2 == -1 )

	cmp	DWORD PTR _ft1$2[ebp], -1
	je	SHORT $LN4@COM_Compar
	cmp	DWORD PTR _ft2$1[ebp], -1
	jne	SHORT $LN3@COM_Compar
$LN4@COM_Compar:

; 1230 : 			return bRet;

	mov	eax, DWORD PTR _bRet$[ebp]
	jmp	SHORT $LN1@COM_Compar
$LN3@COM_Compar:

; 1231 : 
; 1232 : 		*iCompare = Host_CompareFileTime( ft1,  ft2 );

	mov	eax, DWORD PTR _ft2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ft1$2[ebp]
	push	ecx
	call	_Host_CompareFileTime
	add	esp, 8
	mov	edx, DWORD PTR _iCompare$[ebp]
	mov	DWORD PTR [edx], eax

; 1233 : 		bRet = 1;

	mov	DWORD PTR _bRet$[ebp], 1
$LN2@COM_Compar:

; 1234 : 	}
; 1235 : 
; 1236 : 	return bRet;

	mov	eax, DWORD PTR _bRet$[ebp]
$LN1@COM_Compar:

; 1237 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_CompareFileTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_CheckString
_TEXT	SEGMENT
_string$ = 8						; size = 4
_COM_CheckString PROC					; COMDAT

; 771  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 772  : 	if( !string || !*string )

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@COM_CheckS
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@COM_CheckS
$LN3@COM_CheckS:

; 773  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@COM_CheckS
$LN2@COM_CheckS:

; 774  : 	return 1;

	mov	eax, 1
$LN1@COM_CheckS:

; 775  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_CheckString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FreeFile
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_COM_FreeFile PROC					; COMDAT

; 1079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1080 : 	free( buffer ); 

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 1081 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FreeFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FixSlashes
_TEXT	SEGMENT
_pname$ = 8						; size = 4
_COM_FixSlashes PROC					; COMDAT

; 873  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN2@COM_FixSla:

; 874  : 	while( *pname )

	mov	eax, DWORD PTR _pname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@COM_FixSla

; 875  : 	{
; 876  : 		if( *pname == '\\' )

	mov	eax, DWORD PTR _pname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN4@COM_FixSla

; 877  : 			*pname = '/';

	mov	eax, DWORD PTR _pname$[ebp]
	mov	BYTE PTR [eax], 47			; 0000002fH
$LN4@COM_FixSla:

; 878  : 		pname++;

	mov	eax, DWORD PTR _pname$[ebp]
	add	eax, 1
	mov	DWORD PTR _pname$[ebp], eax

; 879  : 	}

	jmp	SHORT $LN2@COM_FixSla
$LN1@COM_FixSla:

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FixSlashes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FileSize
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_COM_FileSize PROC					; COMDAT

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 785  : 	return FS_FileSize( filename, false );

	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8

; 786  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FileSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_NormalizeAngles
_TEXT	SEGMENT
_i$ = -4						; size = 4
_angles$ = 8						; size = 4
_COM_NormalizeAngles PROC				; COMDAT

; 1090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1091 : 	int i;
; 1092 : 
; 1093 : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_Normal
$LN2@COM_Normal:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@COM_Normal:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@COM_Normal

; 1094 : 	{
; 1095 : 		if( angles[i] > 180.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN5@COM_Normal

; 1096 : 			angles[i] -= 360.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR __real@43b40000
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _angles$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
	jmp	SHORT $LN7@COM_Normal
$LN5@COM_Normal:

; 1097 : 		else if( angles[i] < -180.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jbe	SHORT $LN7@COM_Normal

; 1098 : 			angles[i] += 360.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _angles$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN7@COM_Normal:

; 1099 : 	}

	jmp	SHORT $LN2@COM_Normal
$LN3@COM_Normal:

; 1100 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_NormalizeAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_ParseVector
_TEXT	SEGMENT
_i$ = -272						; size = 4
_saved$ = -268						; size = 4
_bracket$ = -264					; size = 4
_token$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pfile$ = 8						; size = 4
_v$ = 12						; size = 4
_size$ = 16						; size = 4
_COM_ParseVector PROC					; COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 722  : 	string	token;
; 723  : 	qboolean	bracket = false;

	mov	DWORD PTR _bracket$[ebp], 0

; 724  : 	char	*saved;
; 725  : 	uint	i;
; 726  : 
; 727  : 	if( v == NULL || size == 0 )

	cmp	DWORD PTR _v$[ebp], 0
	je	SHORT $LN6@COM_ParseV
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN5@COM_ParseV
$LN6@COM_ParseV:

; 728  : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_ParseV
$LN5@COM_ParseV:

; 729  : 
; 730  : 	memset( v, 0, sizeof( *v ) * size );

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 731  : 
; 732  : 	if( size == 1 )

	cmp	DWORD PTR _size$[ebp], 1
	jne	SHORT $LN7@COM_ParseV

; 733  : 	{
; 734  : 		*pfile = COM_ParseFile( *pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax

; 735  : 		v[0] = Q_atof( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax+edx]

; 736  : 		return true;

	mov	eax, 1
	jmp	$LN1@COM_ParseV
$LN7@COM_ParseV:

; 737  : 	}
; 738  : 
; 739  : 	saved = *pfile;

	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _saved$[ebp], ecx

; 740  : 
; 741  : 	if(( *pfile = COM_ParseFile( *pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@COM_ParseV

; 742  : 		return false;

	xor	eax, eax
	jmp	$LN1@COM_ParseV
$LN8@COM_ParseV:

; 743  : 
; 744  : 	if( token[0] == '(' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 40					; 00000028H
	jne	SHORT $LN9@COM_ParseV

; 745  : 		bracket = true;

	mov	DWORD PTR _bracket$[ebp], 1
	jmp	SHORT $LN10@COM_ParseV
$LN9@COM_ParseV:

; 746  : 	else *pfile = saved; // restore token to right get it again

	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR _saved$[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@COM_ParseV:

; 747  : 
; 748  : 	for( i = 0; i < size; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@COM_ParseV
$LN2@COM_ParseV:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@COM_ParseV:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jae	SHORT $LN3@COM_ParseV

; 749  : 	{
; 750  : 		*pfile = COM_ParseFile( *pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax

; 751  : 		v[i] = Q_atof( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 752  : 	}

	jmp	SHORT $LN2@COM_ParseV
$LN3@COM_ParseV:

; 753  : 
; 754  : 	if( !bracket ) return true;	// done

	cmp	DWORD PTR _bracket$[ebp], 0
	jne	SHORT $LN11@COM_ParseV
	mov	eax, 1
	jmp	SHORT $LN1@COM_ParseV
$LN11@COM_ParseV:

; 755  : 
; 756  : 	if(( *pfile = COM_ParseFile( *pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _pfile$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN12@COM_ParseV

; 757  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@COM_ParseV
$LN12@COM_ParseV:

; 758  : 
; 759  : 	if( token[0] == ')' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _token$[ebp+ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN13@COM_ParseV

; 760  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@COM_ParseV
$LN13@COM_ParseV:

; 761  : 	return false;

	xor	eax, eax
$LN1@COM_ParseV:

; 762  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_ParseVector ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FileWithoutPath
_TEXT	SEGMENT
tv79 = -80						; size = 4
_colon$ = -12						; size = 4
_backslash$ = -8					; size = 4
_separator$ = -4					; size = 4
_in$ = 8						; size = 4
_COM_FileWithoutPath PROC				; COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 508  : 	const char *separator, *backslash, *colon;
; 509  : 
; 510  : 	separator = Q_strrchr( in, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _separator$[ebp], eax

; 511  : 	backslash = Q_strrchr( in, '\\' );

	push	92					; 0000005cH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 512  : 
; 513  : 	if( !separator || separator < backslash )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN3@COM_FileWi
	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN2@COM_FileWi
$LN3@COM_FileWi:

; 514  : 		separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN2@COM_FileWi:

; 515  : 
; 516  : 	colon = Q_strrchr( in, ':' );

	push	58					; 0000003aH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 517  : 
; 518  : 	if( !separator || separator < colon )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN5@COM_FileWi
	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _colon$[ebp]
	jae	SHORT $LN4@COM_FileWi
$LN5@COM_FileWi:

; 519  : 		separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN4@COM_FileWi:

; 520  : 
; 521  : 	return separator ? separator + 1 : in;

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN7@COM_FileWi
	mov	eax, DWORD PTR _separator$[ebp]
	add	eax, 1
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@COM_FileWi
$LN7@COM_FileWi:
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR tv79[ebp], ecx
$LN8@COM_FileWi:
	mov	eax, DWORD PTR tv79[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FileWithoutPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_ExtractFilePath
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_dest$ = 12						; size = 4
_COM_ExtractFilePath PROC				; COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 531  : 	const char *src = path + Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _path$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _src$[ebp], edx
$LN2@COM_Extrac:

; 532  : 
; 533  : 	// back up until a \ or the start
; 534  : 	while( src != path && !(*(src - 1) == '\\' || *(src - 1) == '/' ))

	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	je	SHORT $LN3@COM_Extrac
	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@COM_Extrac
	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN3@COM_Extrac

; 535  : 		src--;

	mov	eax, DWORD PTR _src$[ebp]
	sub	eax, 1
	mov	DWORD PTR _src$[ebp], eax
	jmp	SHORT $LN2@COM_Extrac
$LN3@COM_Extrac:

; 536  : 
; 537  : 	if( src != path )

	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	je	SHORT $LN4@COM_Extrac

; 538  : 	{
; 539  : 		memcpy( dest, path, src - path );

	mov	eax, DWORD PTR _src$[ebp]
	sub	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 540  : 		dest[src - path - 1] = 0; // cutoff backslash

	mov	eax, DWORD PTR _src$[ebp]
	sub	eax, DWORD PTR _path$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [ecx+eax-1], 0

; 541  : 	}

	jmp	SHORT $LN1@COM_Extrac
$LN4@COM_Extrac:

; 542  : 	else Q_strcpy( dest, "" ); // file without path

	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@COM_Extrac:

; 543  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_ExtractFilePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_ReplaceExtension
_TEXT	SEGMENT
_path$ = 8						; size = 4
_extension$ = 12					; size = 4
_COM_ReplaceExtension PROC				; COMDAT

; 594  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 595  : 	COM_StripExtension( path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 596  : 	COM_DefaultExtension( path, extension );

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_COM_DefaultExtension
	add	esp, 8

; 597  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_ReplaceExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_DefaultExtension
_TEXT	SEGMENT
_src$ = -4						; size = 4
_path$ = 8						; size = 4
_extension$ = 12					; size = 4
_COM_DefaultExtension PROC				; COMDAT

; 571  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 572  : 	const char	*src;
; 573  : 
; 574  : 	// if path doesn't have a .EXT, append extension
; 575  : 	// (extension should include the .)
; 576  : 	src = path + Q_strlen( path ) - 1;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _path$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _src$[ebp], edx
$LN2@COM_Defaul:

; 577  : 
; 578  : 	while( *src != '/' && src != path )

	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN3@COM_Defaul
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _path$[ebp]
	je	SHORT $LN3@COM_Defaul

; 579  : 	{
; 580  : 		// it has an extension
; 581  : 		if( *src == '.' ) return;                 

	mov	eax, DWORD PTR _src$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN4@COM_Defaul
	jmp	SHORT $LN1@COM_Defaul
$LN4@COM_Defaul:

; 582  : 		src--;

	mov	eax, DWORD PTR _src$[ebp]
	sub	eax, 1
	mov	DWORD PTR _src$[ebp], eax

; 583  : 	}

	jmp	SHORT $LN2@COM_Defaul
$LN3@COM_Defaul:

; 584  : 
; 585  : 	Q_strcat( path, extension );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN1@COM_Defaul:

; 586  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_DefaultExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FileExtension
_TEXT	SEGMENT
_dot$ = -16						; size = 4
_colon$ = -12						; size = 4
_backslash$ = -8					; size = 4
_separator$ = -4					; size = 4
_in$ = 8						; size = 4
_COM_FileExtension PROC					; COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 480  : 	const char *separator, *backslash, *colon, *dot;
; 481  : 
; 482  : 	separator = Q_strrchr( in, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _separator$[ebp], eax

; 483  : 	backslash = Q_strrchr( in, '\\' );

	push	92					; 0000005cH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 484  : 
; 485  : 	if( !separator || separator < backslash )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN3@COM_FileEx
	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN2@COM_FileEx
$LN3@COM_FileEx:

; 486  : 		separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN2@COM_FileEx:

; 487  : 
; 488  : 	colon = Q_strrchr( in, ':' );

	push	58					; 0000003aH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 489  : 
; 490  : 	if( !separator || separator < colon )

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN5@COM_FileEx
	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _colon$[ebp]
	jae	SHORT $LN4@COM_FileEx
$LN5@COM_FileEx:

; 491  : 		separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN4@COM_FileEx:

; 492  : 
; 493  : 	dot = Q_strrchr( in, '.' );

	push	46					; 0000002eH
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax

; 494  : 
; 495  : 	if( dot == NULL || ( separator && ( dot < separator )))

	cmp	DWORD PTR _dot$[ebp], 0
	je	SHORT $LN7@COM_FileEx
	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN6@COM_FileEx
	mov	eax, DWORD PTR _dot$[ebp]
	cmp	eax, DWORD PTR _separator$[ebp]
	jae	SHORT $LN6@COM_FileEx
$LN7@COM_FileEx:

; 496  : 		return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN1@COM_FileEx
$LN6@COM_FileEx:

; 497  : 
; 498  : 	return dot + 1;

	mov	eax, DWORD PTR _dot$[ebp]
	add	eax, 1
$LN1@COM_FileEx:

; 499  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FileExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _COM_FileBase
_TEXT	SEGMENT
_end$ = -12						; size = 4
_start$ = -8						; size = 4
_len$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_COM_FileBase PROC					; COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 440  : 	int	len, start, end;
; 441  : 
; 442  : 	len = Q_strlen( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 443  : 	if( !len ) return;

	cmp	DWORD PTR _len$[ebp], 0
	jne	SHORT $LN6@COM_FileBa
	jmp	$LN1@COM_FileBa
$LN6@COM_FileBa:

; 444  : 	
; 445  : 	// scan backward for '.'
; 446  : 	end = len - 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN2@COM_FileBa:

; 447  : 
; 448  : 	while( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )

	cmp	DWORD PTR _end$[ebp], 0
	je	SHORT $LN3@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN3@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN3@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@COM_FileBa

; 449  : 		end--;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN2@COM_FileBa
$LN3@COM_FileBa:

; 450  : 	
; 451  : 	if( in[end] != '.' )

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN7@COM_FileBa

; 452  : 		end = len-1; // no '.', copy to end

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
	jmp	SHORT $LN8@COM_FileBa
$LN7@COM_FileBa:

; 453  : 	else end--; // found ',', copy to left of '.'

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN8@COM_FileBa:

; 454  : 
; 455  : 	// scan backward for '/'
; 456  : 	start = len - 1;

	mov	eax, DWORD PTR _len$[ebp]
	sub	eax, 1
	mov	DWORD PTR _start$[ebp], eax
$LN4@COM_FileBa:

; 457  : 
; 458  : 	while( start >= 0 && in[start] != '/' && in[start] != '\\' )

	cmp	DWORD PTR _start$[ebp], 0
	jl	SHORT $LN5@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN5@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@COM_FileBa

; 459  : 		start--;

	mov	eax, DWORD PTR _start$[ebp]
	sub	eax, 1
	mov	DWORD PTR _start$[ebp], eax
	jmp	SHORT $LN4@COM_FileBa
$LN5@COM_FileBa:

; 460  : 
; 461  : 	if( start < 0 || ( in[start] != '/' && in[start] != '\\' ))

	cmp	DWORD PTR _start$[ebp], 0
	jl	SHORT $LN11@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN9@COM_FileBa
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN9@COM_FileBa
$LN11@COM_FileBa:

; 462  : 		start = 0;

	mov	DWORD PTR _start$[ebp], 0
	jmp	SHORT $LN10@COM_FileBa
$LN9@COM_FileBa:

; 463  : 	else start++;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, 1
	mov	DWORD PTR _start$[ebp], eax
$LN10@COM_FileBa:

; 464  : 
; 465  : 	// length of new sting
; 466  : 	len = end - start + 1;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _start$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 467  : 
; 468  : 	// Copy partial string
; 469  : 	Q_strncpy( out, &in[start], len + 1 );

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 470  : 	out[len] = 0;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@COM_FileBa:

; 471  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_COM_FileBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\common.c
;	COMDAT _DBG_AssertFunction
_TEXT	SEGMENT
_fExpr$ = 8						; size = 4
_szExpr$ = 12						; size = 4
_szFile$ = 16						; size = 4
_szLine$ = 20						; size = 4
_szMessage$ = 24					; size = 4
_DBG_AssertFunction PROC				; COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 40   : 	if( fExpr ) return;

	cmp	DWORD PTR _fExpr$[ebp], 0
	je	SHORT $LN2@DBG_Assert
	jmp	SHORT $LN1@DBG_Assert
$LN2@DBG_Assert:

; 41   : 
; 42   : 	if( szMessage != NULL )

	cmp	DWORD PTR _szMessage$[ebp], 0
	je	SHORT $LN3@DBG_Assert

; 43   : 		Con_DPrintf( S_ERROR "ASSERT FAILED:\n %s \n(%s@%d)\n%s\n", szExpr, szFile, szLine, szMessage );

	mov	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _szExpr$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@NAFOBPMB@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@
	call	_Con_DPrintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN1@DBG_Assert
$LN3@DBG_Assert:

; 44   : 	else Con_DPrintf( S_ERROR "ASSERT FAILED:\n %s \n(%s@%d)\n", szExpr, szFile, szLine );

	mov	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szExpr$[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@NHHAPFKP@?$FO1Error?3?$FO7?5ASSERT?5FAILED?3?6?5?$CFs?5?6@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN1@DBG_Assert:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_DBG_AssertFunction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 551  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4

; 553  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
END
