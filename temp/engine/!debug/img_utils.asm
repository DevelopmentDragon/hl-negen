; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_utils.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_q1palette_init
PUBLIC	_hlpalette_init
PUBLIC	??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@		; `string'
PUBLIC	??_C@_03CBDDAJHO@dds@				; `string'
PUBLIC	??_C@_03LJIJAGL@tga@				; `string'
PUBLIC	??_C@_03CAKEDOOO@bmp@				; `string'
PUBLIC	??_C@_03HPMOIGGE@mip@				; `string'
PUBLIC	??_C@_03JBGBEIGK@mdl@				; `string'
PUBLIC	??_C@_03OOMJFMLF@spr@				; `string'
PUBLIC	??_C@_03MAHLEJNN@lmp@				; `string'
PUBLIC	??_C@_03MJOMNCOE@fnt@				; `string'
PUBLIC	??_C@_03DFNJAFMD@pal@				; `string'
EXTRN	_Image_LoadMIP:PROC
EXTRN	_Image_LoadMDL:PROC
EXTRN	_Image_LoadSPR:PROC
EXTRN	_Image_LoadTGA:PROC
EXTRN	_Image_LoadBMP:PROC
EXTRN	_Image_LoadDDS:PROC
EXTRN	_Image_LoadFNT:PROC
EXTRN	_Image_LoadLMP:PROC
EXTRN	_Image_LoadPAL:PROC
EXTRN	_Image_SaveTGA:PROC
EXTRN	_Image_SaveBMP:PROC
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_d_8toQ1table:DWORD:0100H
COMM	_d_8toHLtable:DWORD:0100H
COMM	_d_8to24table:DWORD:0100H
_DATA	ENDS
_BSS	SEGMENT
_q1palette_init DD 01H DUP (?)
_hlpalette_init DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03DFNJAFMD@pal@
CONST	SEGMENT
??_C@_03DFNJAFMD@pal@ DB 'pal', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJOMNCOE@fnt@
CONST	SEGMENT
??_C@_03MJOMNCOE@fnt@ DB 'fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAHLEJNN@lmp@
CONST	SEGMENT
??_C@_03MAHLEJNN@lmp@ DB 'lmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OOMJFMLF@spr@
CONST	SEGMENT
??_C@_03OOMJFMLF@spr@ DB 'spr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBGBEIGK@mdl@
CONST	SEGMENT
??_C@_03JBGBEIGK@mdl@ DB 'mdl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPMOIGGE@mip@
CONST	SEGMENT
??_C@_03HPMOIGGE@mip@ DB 'mip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CAKEDOOO@bmp@
CONST	SEGMENT
??_C@_03CAKEDOOO@bmp@ DB 'bmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJIJAGL@tga@
CONST	SEGMENT
??_C@_03LJIJAGL@tga@ DB 'tga', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBDDAJHO@dds@
CONST	SEGMENT
??_C@_03CBDDAJHO@dds@ DB 'dds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
CONST	SEGMENT
??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@ DB '%s%s.%s', 00H	; `string'
CONST	ENDS
CONST	SEGMENT
_load_null DD	00H
	DD	00H
	DD	00H
	DD	00H
_load_game DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03CBDDAJHO@dds@
	DD	FLAT:_Image_LoadDDS
	DD	00H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03LJIJAGL@tga@
	DD	FLAT:_Image_LoadTGA
	DD	00H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03CAKEDOOO@bmp@
	DD	FLAT:_Image_LoadBMP
	DD	00H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03HPMOIGGE@mip@
	DD	FLAT:_Image_LoadMIP
	DD	00H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03JBGBEIGK@mdl@
	DD	FLAT:_Image_LoadMDL
	DD	02H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03OOMJFMLF@spr@
	DD	FLAT:_Image_LoadSPR
	DD	02H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03MAHLEJNN@lmp@
	DD	FLAT:_Image_LoadLMP
	DD	00H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03MJOMNCOE@fnt@
	DD	FLAT:_Image_LoadFNT
	DD	02H
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03DFNJAFMD@pal@
	DD	FLAT:_Image_LoadPAL
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_save_null DD	00H
	DD	00H
	DD	00H
_save_game DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03LJIJAGL@tga@
	DD	FLAT:_Image_SaveTGA
	DD	FLAT:??_C@_07GFKBPOLL@?$CFs?$CFs?4?$CFs@
	DD	FLAT:??_C@_03CAKEDOOO@bmp@
	DD	FLAT:_Image_SaveBMP
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_Image_Init
PUBLIC	_Image_Shutdown
PUBLIC	_Image_AddCmdFlags
PUBLIC	_Image_Process
PUBLIC	_Image_PaletteHueReplace
PUBLIC	_Image_PaletteTranslate
PUBLIC	_Image_SetForceFlags
PUBLIC	_Image_CustomPalette
PUBLIC	_Image_ClearForceFlags
PUBLIC	_Image_CheckPaletteQ1
PUBLIC	_Image_ResampleInternal
PUBLIC	_Image_FlipInternal
PUBLIC	_Image_Copy8bitRGBA
PUBLIC	_Image_AddIndexedImageToPack
PUBLIC	_Image_GetPaletteLMP
PUBLIC	_Image_GetPaletteBMP
PUBLIC	_Image_ComparePalette
PUBLIC	_Image_CopyPalette32bit
PUBLIC	_Image_GetPaletteQ1
PUBLIC	_Image_GetPaletteHL
PUBLIC	_Image_Copy
PUBLIC	_Image_CopyParms
PUBLIC	_Image_ValidSize
PUBLIC	_Image_LumpValidSize
PUBLIC	_Image_CheckFlag
PUBLIC	_Image_SetPalette
PUBLIC	_Image_Resample32Lerp
PUBLIC	_Image_Resample32Nolerp
PUBLIC	_Image_Resample24Lerp
PUBLIC	_Image_Resample24Nolerp
PUBLIC	_Image_Resample8Nolerp
PUBLIC	_Image_CreateLumaInternal
PUBLIC	_Image_Decompress
PUBLIC	_Image_DecompressInternal
PUBLIC	_Image_LightGamma
PUBLIC	_Image_RemapInternal
PUBLIC	?__LINE__Var@?0??Image_Init@@9@9		; `Image_Init'::`1'::__LINE__Var
PUBLIC	??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0O@EILAMLBA@ImageLib?5Pool@		; `string'
PUBLIC	?__LINE__Var@?0??Image_Shutdown@@9@9		; `Image_Shutdown'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_Copy@@9@9		; `Image_Copy'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@NIJDPLBA@?$FO1Error?3?$FO7?5Image?3?5?$CI?$CFs?$CJ?5dims?5out@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_ConvertPalTo24bit@@9@9	; `Image_ConvertPalTo24bit'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_CopyPalette32bit@@9@9	; `Image_CopyPalette32bit'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@JKAKIGAD@gfx?1palette?4lmp@		; `string'
PUBLIC	??_C@_0BP@PJJMOBIN@custom?5quake?5palette?5detected?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_Resample32Lerp@@9@9	; `Image_Resample32Lerp'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_Resample24Lerp@@9@9	; `Image_Resample24Lerp'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_ResampleInternal@@9@9	; `Image_ResampleInternal'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_FlipInternal@@9@9	; `Image_FlipInternal'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_CreateLumaInternal@@9@9	; `Image_CreateLumaInternal'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@FDGCNINA@?$FO1Error?3?$FO7?5Image_MakeLuma?3?5unsu@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_AddIndexedImageToPack@@9@9 ; `Image_AddIndexedImageToPack'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_Decompress@@9@9		; `Image_Decompress'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_DecompressInternal@@9@9	; `Image_DecompressInternal'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_ApplyFilter@@9@9		; `Image_ApplyFilter'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Image_Process@@9@9		; `Image_Process'::`1'::__LINE__Var
PUBLIC	??_C@_0CM@LLKBPOHF@Image_Resample?3?5from?$FL?$CFd?5x?5?$CFd?$FN?5t@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb4b4b5
PUBLIC	__real@40000000
PUBLIC	__real@41300000
PUBLIC	__real@41f00000
PUBLIC	__real@426c0000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@43000000
PUBLIC	__real@43340000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@43960000
PUBLIC	__real@43b40000
PUBLIC	__real@47800000
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	__Mem_Check:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_Image_Quantize:PROC
EXTRN	_Image_Reset:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@426c0000
CONST	SEGMENT
__real@426c0000 DD 0426c0000r			; 59
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41300000
CONST	SEGMENT
__real@41300000 DD 041300000r			; 11
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fb4b4b5
CONST	SEGMENT
__real@3fb4b4b5 DD 03fb4b4b5r			; 1.41176
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CM@LLKBPOHF@Image_Resample?3?5from?$FL?$CFd?5x?5?$CFd?$FN?5t@
CONST	SEGMENT
??_C@_0CM@LLKBPOHF@Image_Resample?3?5from?$FL?$CFd?5x?5?$CFd?$FN?5t@ DB 'I'
	DB	'mage_Resample: from[%d x %d] to [%d x %d]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Process@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Process@@9@9 DD 05b2H		; `Image_Process'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_ApplyFilter@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_ApplyFilter@@9@9 DD 055dH	; `Image_ApplyFilter'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_DecompressInternal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_DecompressInternal@@9@9 DD 050aH	; `Image_DecompressInternal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Decompress@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Decompress@@9@9 DD 04c6H		; `Image_Decompress'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_AddIndexedImageToPack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_AddIndexedImageToPack@@9@9 DD 04a7H ; `Image_AddIndexedImageToPack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@FDGCNINA@?$FO1Error?3?$FO7?5Image_MakeLuma?3?5unsu@
CONST	SEGMENT
??_C@_0DC@FDGCNINA@?$FO1Error?3?$FO7?5Image_MakeLuma?3?5unsu@ DB '^1Error'
	DB	':^7 Image_MakeLuma: unsupported format %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_CreateLumaInternal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_CreateLumaInternal@@9@9 DD 048eH	; `Image_CreateLumaInternal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_FlipInternal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_FlipInternal@@9@9 DD 044cH	; `Image_FlipInternal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_ResampleInternal@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_ResampleInternal@@9@9 DD 041fH	; `Image_ResampleInternal'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Resample24Lerp@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Resample24Lerp@@9@9 DD 035cH	; `Image_Resample24Lerp'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Resample32Lerp@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Resample32Lerp@@9@9 DD 02c9H	; `Image_Resample32Lerp'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BP@PJJMOBIN@custom?5quake?5palette?5detected?6@
CONST	SEGMENT
??_C@_0BP@PJJMOBIN@custom?5quake?5palette?5detected?6@ DB 'custom quake p'
	DB	'alette detected', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JKAKIGAD@gfx?1palette?4lmp@
CONST	SEGMENT
??_C@_0BA@JKAKIGAD@gfx?1palette?4lmp@ DB 'gfx/palette.lmp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_CopyPalette32bit@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_CopyPalette32bit@@9@9 DD 015dH	; `Image_CopyPalette32bit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_ConvertPalTo24bit@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_ConvertPalTo24bit@@9@9 DD 0145H	; `Image_ConvertPalTo24bit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@NIJDPLBA@?$FO1Error?3?$FO7?5Image?3?5?$CI?$CFs?$CJ?5dims?5out@
CONST	SEGMENT
??_C@_0DC@NIJDPLBA@?$FO1Error?3?$FO7?5Image?3?5?$CI?$CFs?$CJ?5dims?5out@ DB '^'
	DB	'1Error:^7 Image: (%s) dims out of range [%dx%d]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Copy@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Copy@@9@9 DD 0abH		; `Image_Copy'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Shutdown@@9@9 DD 0a5H		; `Image_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@EILAMLBA@ImageLib?5Pool@
CONST	SEGMENT
??_C@_0O@EILAMLBA@ImageLib?5Pool@ DB 'ImageLib Pool', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_utils.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Init@@9@9 DD 08eH		; `Image_Init'::`1'::__LINE__Var
_DATA	ENDS
_DATA	SEGMENT
_palette_q1 DB	00H
	DB	00H
	DB	00H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	01fH
	DB	01fH
	DB	01fH
	DB	02fH
	DB	02fH
	DB	02fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	04bH
	DB	04bH
	DB	04bH
	DB	05bH
	DB	05bH
	DB	05bH
	DB	06bH
	DB	06bH
	DB	06bH
	DB	07bH
	DB	07bH
	DB	07bH
	DB	08bH
	DB	08bH
	DB	08bH
	DB	09bH
	DB	09bH
	DB	09bH
	DB	0abH
	DB	0abH
	DB	0abH
	DB	0bbH
	DB	0bbH
	DB	0bbH
	DB	0cbH
	DB	0cbH
	DB	0cbH
	DB	0dbH
	DB	0dbH
	DB	0dbH
	DB	0ebH
	DB	0ebH
	DB	0ebH
	DB	0fH
	DB	0bH
	DB	07H
	DB	017H
	DB	0fH
	DB	0bH
	DB	01fH
	DB	017H
	DB	0bH
	DB	027H
	DB	01bH
	DB	0fH
	DB	02fH
	DB	023H
	DB	013H
	DB	037H
	DB	02bH
	DB	017H
	DB	03fH
	DB	02fH
	DB	017H
	DB	04bH
	DB	037H
	DB	01bH
	DB	053H
	DB	03bH
	DB	01bH
	DB	05bH
	DB	043H
	DB	01fH
	DB	063H
	DB	04bH
	DB	01fH
	DB	06bH
	DB	053H
	DB	01fH
	DB	073H
	DB	057H
	DB	01fH
	DB	07bH
	DB	05fH
	DB	023H
	DB	083H
	DB	067H
	DB	023H
	DB	08fH
	DB	06fH
	DB	023H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	013H
	DB	013H
	DB	01bH
	DB	01bH
	DB	01bH
	DB	027H
	DB	027H
	DB	027H
	DB	033H
	DB	02fH
	DB	02fH
	DB	03fH
	DB	037H
	DB	037H
	DB	04bH
	DB	03fH
	DB	03fH
	DB	057H
	DB	047H
	DB	047H
	DB	067H
	DB	04fH
	DB	04fH
	DB	073H
	DB	05bH
	DB	05bH
	DB	07fH
	DB	063H
	DB	063H
	DB	08bH
	DB	06bH
	DB	06bH
	DB	097H
	DB	073H
	DB	073H
	DB	0a3H
	DB	07bH
	DB	07bH
	DB	0afH
	DB	083H
	DB	083H
	DB	0bbH
	DB	08bH
	DB	08bH
	DB	0cbH
	DB	00H
	DB	00H
	DB	00H
	DB	07H
	DB	07H
	DB	00H
	DB	0bH
	DB	0bH
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02bH
	DB	02bH
	DB	07H
	DB	02fH
	DB	02fH
	DB	07H
	DB	037H
	DB	037H
	DB	07H
	DB	03fH
	DB	03fH
	DB	07H
	DB	047H
	DB	047H
	DB	07H
	DB	04bH
	DB	04bH
	DB	0bH
	DB	053H
	DB	053H
	DB	0bH
	DB	05bH
	DB	05bH
	DB	0bH
	DB	063H
	DB	063H
	DB	0bH
	DB	06bH
	DB	06bH
	DB	0fH
	DB	07H
	DB	00H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	DB	017H
	DB	00H
	DB	00H
	DB	01fH
	DB	00H
	DB	00H
	DB	027H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	037H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	04fH
	DB	00H
	DB	00H
	DB	057H
	DB	00H
	DB	00H
	DB	05fH
	DB	00H
	DB	00H
	DB	067H
	DB	00H
	DB	00H
	DB	06fH
	DB	00H
	DB	00H
	DB	077H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02fH
	DB	02bH
	DB	00H
	DB	037H
	DB	02fH
	DB	00H
	DB	043H
	DB	037H
	DB	00H
	DB	04bH
	DB	03bH
	DB	07H
	DB	057H
	DB	043H
	DB	07H
	DB	05fH
	DB	047H
	DB	07H
	DB	06bH
	DB	04bH
	DB	0bH
	DB	077H
	DB	053H
	DB	0fH
	DB	083H
	DB	057H
	DB	013H
	DB	08bH
	DB	05bH
	DB	013H
	DB	097H
	DB	05fH
	DB	01bH
	DB	0a3H
	DB	063H
	DB	01fH
	DB	0afH
	DB	067H
	DB	023H
	DB	023H
	DB	013H
	DB	07H
	DB	02fH
	DB	017H
	DB	0bH
	DB	03bH
	DB	01fH
	DB	0fH
	DB	04bH
	DB	023H
	DB	013H
	DB	057H
	DB	02bH
	DB	017H
	DB	063H
	DB	02fH
	DB	01fH
	DB	073H
	DB	037H
	DB	023H
	DB	07fH
	DB	03bH
	DB	02bH
	DB	08fH
	DB	043H
	DB	033H
	DB	09fH
	DB	04fH
	DB	033H
	DB	0afH
	DB	063H
	DB	02fH
	DB	0bfH
	DB	077H
	DB	02fH
	DB	0cfH
	DB	08fH
	DB	02bH
	DB	0dfH
	DB	0abH
	DB	027H
	DB	0efH
	DB	0cbH
	DB	01fH
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0bH
	DB	07H
	DB	00H
	DB	01bH
	DB	013H
	DB	00H
	DB	02bH
	DB	023H
	DB	0fH
	DB	037H
	DB	02bH
	DB	013H
	DB	047H
	DB	033H
	DB	01bH
	DB	053H
	DB	037H
	DB	023H
	DB	063H
	DB	03fH
	DB	02bH
	DB	06fH
	DB	047H
	DB	033H
	DB	07fH
	DB	053H
	DB	03fH
	DB	08bH
	DB	05fH
	DB	047H
	DB	09bH
	DB	06bH
	DB	053H
	DB	0a7H
	DB	07bH
	DB	05fH
	DB	0b7H
	DB	087H
	DB	06bH
	DB	0c3H
	DB	093H
	DB	07bH
	DB	0d3H
	DB	0a3H
	DB	08bH
	DB	0e3H
	DB	0b3H
	DB	097H
	DB	0abH
	DB	08bH
	DB	0a3H
	DB	09fH
	DB	07fH
	DB	097H
	DB	093H
	DB	073H
	DB	087H
	DB	08bH
	DB	067H
	DB	07bH
	DB	07fH
	DB	05bH
	DB	06fH
	DB	077H
	DB	053H
	DB	063H
	DB	06bH
	DB	04bH
	DB	057H
	DB	05fH
	DB	03fH
	DB	04bH
	DB	057H
	DB	037H
	DB	043H
	DB	04bH
	DB	02fH
	DB	037H
	DB	043H
	DB	027H
	DB	02fH
	DB	037H
	DB	01fH
	DB	023H
	DB	02bH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0bbH
	DB	073H
	DB	09fH
	DB	0afH
	DB	06bH
	DB	08fH
	DB	0a3H
	DB	05fH
	DB	083H
	DB	097H
	DB	057H
	DB	077H
	DB	08bH
	DB	04fH
	DB	06bH
	DB	07fH
	DB	04bH
	DB	05fH
	DB	073H
	DB	043H
	DB	053H
	DB	06bH
	DB	03bH
	DB	04bH
	DB	05fH
	DB	033H
	DB	03fH
	DB	053H
	DB	02bH
	DB	037H
	DB	047H
	DB	023H
	DB	02bH
	DB	03bH
	DB	01fH
	DB	023H
	DB	02fH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0dbH
	DB	0c3H
	DB	0bbH
	DB	0cbH
	DB	0b3H
	DB	0a7H
	DB	0bfH
	DB	0a3H
	DB	09bH
	DB	0afH
	DB	097H
	DB	08bH
	DB	0a3H
	DB	087H
	DB	07bH
	DB	097H
	DB	07bH
	DB	06fH
	DB	087H
	DB	06fH
	DB	05fH
	DB	07bH
	DB	063H
	DB	053H
	DB	06bH
	DB	057H
	DB	047H
	DB	05fH
	DB	04bH
	DB	03bH
	DB	053H
	DB	03fH
	DB	033H
	DB	043H
	DB	033H
	DB	027H
	DB	037H
	DB	02bH
	DB	01fH
	DB	027H
	DB	01fH
	DB	017H
	DB	01bH
	DB	013H
	DB	0fH
	DB	0fH
	DB	0bH
	DB	07H
	DB	06fH
	DB	083H
	DB	07bH
	DB	067H
	DB	07bH
	DB	06fH
	DB	05fH
	DB	073H
	DB	067H
	DB	057H
	DB	06bH
	DB	05fH
	DB	04fH
	DB	063H
	DB	057H
	DB	047H
	DB	05bH
	DB	04fH
	DB	03fH
	DB	053H
	DB	047H
	DB	037H
	DB	04bH
	DB	03fH
	DB	02fH
	DB	043H
	DB	037H
	DB	02bH
	DB	03bH
	DB	02fH
	DB	023H
	DB	033H
	DB	027H
	DB	01fH
	DB	02bH
	DB	01fH
	DB	017H
	DB	023H
	DB	017H
	DB	0fH
	DB	01bH
	DB	013H
	DB	0bH
	DB	013H
	DB	0bH
	DB	07H
	DB	0bH
	DB	07H
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0efH
	DB	0dfH
	DB	017H
	DB	0dbH
	DB	0cbH
	DB	013H
	DB	0cbH
	DB	0b7H
	DB	0fH
	DB	0bbH
	DB	0a7H
	DB	0fH
	DB	0abH
	DB	097H
	DB	0bH
	DB	09bH
	DB	083H
	DB	07H
	DB	08bH
	DB	073H
	DB	07H
	DB	07bH
	DB	063H
	DB	07H
	DB	06bH
	DB	053H
	DB	00H
	DB	05bH
	DB	047H
	DB	00H
	DB	04bH
	DB	037H
	DB	00H
	DB	03bH
	DB	02bH
	DB	00H
	DB	02bH
	DB	01fH
	DB	00H
	DB	01bH
	DB	0fH
	DB	00H
	DB	0bH
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0bH
	DB	0bH
	DB	0efH
	DB	013H
	DB	013H
	DB	0dfH
	DB	01bH
	DB	01bH
	DB	0cfH
	DB	023H
	DB	023H
	DB	0bfH
	DB	02bH
	DB	02bH
	DB	0afH
	DB	02fH
	DB	02fH
	DB	09fH
	DB	02fH
	DB	02fH
	DB	08fH
	DB	02fH
	DB	02fH
	DB	07fH
	DB	02fH
	DB	02fH
	DB	06fH
	DB	02fH
	DB	02fH
	DB	05fH
	DB	02bH
	DB	02bH
	DB	04fH
	DB	023H
	DB	023H
	DB	03fH
	DB	01bH
	DB	01bH
	DB	02fH
	DB	013H
	DB	013H
	DB	01fH
	DB	0bH
	DB	0bH
	DB	0fH
	DB	02bH
	DB	00H
	DB	00H
	DB	03bH
	DB	00H
	DB	00H
	DB	04bH
	DB	07H
	DB	00H
	DB	05fH
	DB	07H
	DB	00H
	DB	06fH
	DB	0fH
	DB	00H
	DB	07fH
	DB	017H
	DB	07H
	DB	093H
	DB	01fH
	DB	07H
	DB	0a3H
	DB	027H
	DB	0bH
	DB	0b7H
	DB	033H
	DB	0fH
	DB	0c3H
	DB	04bH
	DB	01bH
	DB	0cfH
	DB	063H
	DB	02bH
	DB	0dbH
	DB	07fH
	DB	03bH
	DB	0e3H
	DB	097H
	DB	04fH
	DB	0e7H
	DB	0abH
	DB	05fH
	DB	0efH
	DB	0bfH
	DB	077H
	DB	0f7H
	DB	0d3H
	DB	08bH
	DB	0a7H
	DB	07bH
	DB	03bH
	DB	0b7H
	DB	09bH
	DB	037H
	DB	0c7H
	DB	0c3H
	DB	037H
	DB	0e7H
	DB	0e3H
	DB	057H
	DB	07fH
	DB	0bfH
	DB	0ffH
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0d7H
	DB	0ffH
	DB	0ffH
	DB	067H
	DB	00H
	DB	00H
	DB	08bH
	DB	00H
	DB	00H
	DB	0b3H
	DB	00H
	DB	00H
	DB	0d7H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0f3H
	DB	093H
	DB	0ffH
	DB	0f7H
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	09fH
	DB	05bH
	DB	053H
_palette_hl DB	00H
	DB	00H
	DB	00H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	01fH
	DB	01fH
	DB	01fH
	DB	02fH
	DB	02fH
	DB	02fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	04bH
	DB	04bH
	DB	04bH
	DB	05bH
	DB	05bH
	DB	05bH
	DB	06bH
	DB	06bH
	DB	06bH
	DB	07bH
	DB	07bH
	DB	07bH
	DB	08bH
	DB	08bH
	DB	08bH
	DB	09bH
	DB	09bH
	DB	09bH
	DB	0abH
	DB	0abH
	DB	0abH
	DB	0bbH
	DB	0bbH
	DB	0bbH
	DB	0cbH
	DB	0cbH
	DB	0cbH
	DB	0dbH
	DB	0dbH
	DB	0dbH
	DB	0ebH
	DB	0ebH
	DB	0ebH
	DB	0fH
	DB	0bH
	DB	07H
	DB	017H
	DB	0fH
	DB	0bH
	DB	01fH
	DB	017H
	DB	0bH
	DB	027H
	DB	01bH
	DB	0fH
	DB	02fH
	DB	023H
	DB	013H
	DB	037H
	DB	02bH
	DB	017H
	DB	03fH
	DB	02fH
	DB	017H
	DB	04bH
	DB	037H
	DB	01bH
	DB	053H
	DB	03bH
	DB	01bH
	DB	05bH
	DB	043H
	DB	01fH
	DB	063H
	DB	04bH
	DB	01fH
	DB	06bH
	DB	053H
	DB	01fH
	DB	073H
	DB	057H
	DB	01fH
	DB	07bH
	DB	05fH
	DB	023H
	DB	083H
	DB	067H
	DB	023H
	DB	08fH
	DB	06fH
	DB	023H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	013H
	DB	013H
	DB	01bH
	DB	01bH
	DB	01bH
	DB	027H
	DB	027H
	DB	027H
	DB	033H
	DB	02fH
	DB	02fH
	DB	03fH
	DB	037H
	DB	037H
	DB	04bH
	DB	03fH
	DB	03fH
	DB	057H
	DB	047H
	DB	047H
	DB	067H
	DB	04fH
	DB	04fH
	DB	073H
	DB	05bH
	DB	05bH
	DB	07fH
	DB	063H
	DB	063H
	DB	08bH
	DB	06bH
	DB	06bH
	DB	097H
	DB	073H
	DB	073H
	DB	0a3H
	DB	07bH
	DB	07bH
	DB	0afH
	DB	083H
	DB	083H
	DB	0bbH
	DB	08bH
	DB	08bH
	DB	0cbH
	DB	00H
	DB	00H
	DB	00H
	DB	07H
	DB	07H
	DB	00H
	DB	0bH
	DB	0bH
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02bH
	DB	02bH
	DB	07H
	DB	02fH
	DB	02fH
	DB	07H
	DB	037H
	DB	037H
	DB	07H
	DB	03fH
	DB	03fH
	DB	07H
	DB	047H
	DB	047H
	DB	07H
	DB	04bH
	DB	04bH
	DB	0bH
	DB	053H
	DB	053H
	DB	0bH
	DB	05bH
	DB	05bH
	DB	0bH
	DB	063H
	DB	063H
	DB	0bH
	DB	06bH
	DB	06bH
	DB	0fH
	DB	07H
	DB	00H
	DB	00H
	DB	0fH
	DB	00H
	DB	00H
	DB	017H
	DB	00H
	DB	00H
	DB	01fH
	DB	00H
	DB	00H
	DB	027H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	037H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	047H
	DB	00H
	DB	00H
	DB	04fH
	DB	00H
	DB	00H
	DB	057H
	DB	00H
	DB	00H
	DB	05fH
	DB	00H
	DB	00H
	DB	067H
	DB	00H
	DB	00H
	DB	06fH
	DB	00H
	DB	00H
	DB	077H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	013H
	DB	013H
	DB	00H
	DB	01bH
	DB	01bH
	DB	00H
	DB	023H
	DB	023H
	DB	00H
	DB	02fH
	DB	02bH
	DB	00H
	DB	037H
	DB	02fH
	DB	00H
	DB	043H
	DB	037H
	DB	00H
	DB	04bH
	DB	03bH
	DB	07H
	DB	057H
	DB	043H
	DB	07H
	DB	05fH
	DB	047H
	DB	07H
	DB	06bH
	DB	04bH
	DB	0bH
	DB	077H
	DB	053H
	DB	0fH
	DB	083H
	DB	057H
	DB	013H
	DB	08bH
	DB	05bH
	DB	013H
	DB	097H
	DB	05fH
	DB	01bH
	DB	0a3H
	DB	063H
	DB	01fH
	DB	0afH
	DB	067H
	DB	023H
	DB	023H
	DB	013H
	DB	07H
	DB	02fH
	DB	017H
	DB	0bH
	DB	03bH
	DB	01fH
	DB	0fH
	DB	04bH
	DB	023H
	DB	013H
	DB	057H
	DB	02bH
	DB	017H
	DB	063H
	DB	02fH
	DB	01fH
	DB	073H
	DB	037H
	DB	023H
	DB	07fH
	DB	03bH
	DB	02bH
	DB	08fH
	DB	043H
	DB	033H
	DB	09fH
	DB	04fH
	DB	033H
	DB	0afH
	DB	063H
	DB	02fH
	DB	0bfH
	DB	077H
	DB	02fH
	DB	0cfH
	DB	08fH
	DB	02bH
	DB	0dfH
	DB	0abH
	DB	027H
	DB	0efH
	DB	0cbH
	DB	01fH
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0bH
	DB	07H
	DB	00H
	DB	01bH
	DB	013H
	DB	00H
	DB	02bH
	DB	023H
	DB	0fH
	DB	037H
	DB	02bH
	DB	013H
	DB	047H
	DB	033H
	DB	01bH
	DB	053H
	DB	037H
	DB	023H
	DB	063H
	DB	03fH
	DB	02bH
	DB	06fH
	DB	047H
	DB	033H
	DB	07fH
	DB	053H
	DB	03fH
	DB	08bH
	DB	05fH
	DB	047H
	DB	09bH
	DB	06bH
	DB	053H
	DB	0a7H
	DB	07bH
	DB	05fH
	DB	0b7H
	DB	087H
	DB	06bH
	DB	0c3H
	DB	093H
	DB	07bH
	DB	0d3H
	DB	0a3H
	DB	08bH
	DB	0e3H
	DB	0b3H
	DB	097H
	DB	0abH
	DB	08bH
	DB	0a3H
	DB	09fH
	DB	07fH
	DB	097H
	DB	093H
	DB	073H
	DB	087H
	DB	08bH
	DB	067H
	DB	07bH
	DB	07fH
	DB	05bH
	DB	06fH
	DB	077H
	DB	053H
	DB	063H
	DB	06bH
	DB	04bH
	DB	057H
	DB	05fH
	DB	03fH
	DB	04bH
	DB	057H
	DB	037H
	DB	043H
	DB	04bH
	DB	02fH
	DB	037H
	DB	043H
	DB	027H
	DB	02fH
	DB	037H
	DB	01fH
	DB	023H
	DB	02bH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0bbH
	DB	073H
	DB	09fH
	DB	0afH
	DB	06bH
	DB	08fH
	DB	0a3H
	DB	05fH
	DB	083H
	DB	097H
	DB	057H
	DB	077H
	DB	08bH
	DB	04fH
	DB	06bH
	DB	07fH
	DB	04bH
	DB	05fH
	DB	073H
	DB	043H
	DB	053H
	DB	06bH
	DB	03bH
	DB	04bH
	DB	05fH
	DB	033H
	DB	03fH
	DB	053H
	DB	02bH
	DB	037H
	DB	047H
	DB	023H
	DB	02bH
	DB	03bH
	DB	01fH
	DB	023H
	DB	02fH
	DB	017H
	DB	01bH
	DB	023H
	DB	013H
	DB	013H
	DB	017H
	DB	0bH
	DB	0bH
	DB	0fH
	DB	07H
	DB	07H
	DB	0dbH
	DB	0c3H
	DB	0bbH
	DB	0cbH
	DB	0b3H
	DB	0a7H
	DB	0bfH
	DB	0a3H
	DB	09bH
	DB	0afH
	DB	097H
	DB	08bH
	DB	0a3H
	DB	087H
	DB	07bH
	DB	097H
	DB	07bH
	DB	06fH
	DB	087H
	DB	06fH
	DB	05fH
	DB	07bH
	DB	063H
	DB	053H
	DB	06bH
	DB	057H
	DB	047H
	DB	05fH
	DB	04bH
	DB	03bH
	DB	053H
	DB	03fH
	DB	033H
	DB	043H
	DB	033H
	DB	027H
	DB	037H
	DB	02bH
	DB	01fH
	DB	027H
	DB	01fH
	DB	017H
	DB	01bH
	DB	013H
	DB	0fH
	DB	0fH
	DB	0bH
	DB	07H
	DB	06fH
	DB	083H
	DB	07bH
	DB	067H
	DB	07bH
	DB	06fH
	DB	05fH
	DB	073H
	DB	067H
	DB	057H
	DB	06bH
	DB	05fH
	DB	04fH
	DB	063H
	DB	057H
	DB	047H
	DB	05bH
	DB	04fH
	DB	03fH
	DB	053H
	DB	047H
	DB	037H
	DB	04bH
	DB	03fH
	DB	02fH
	DB	043H
	DB	037H
	DB	02bH
	DB	03bH
	DB	02fH
	DB	023H
	DB	033H
	DB	027H
	DB	01fH
	DB	02bH
	DB	01fH
	DB	017H
	DB	023H
	DB	017H
	DB	0fH
	DB	01bH
	DB	013H
	DB	0bH
	DB	013H
	DB	0bH
	DB	07H
	DB	0bH
	DB	07H
	DB	0ffH
	DB	0f3H
	DB	01bH
	DB	0efH
	DB	0dfH
	DB	017H
	DB	0dbH
	DB	0cbH
	DB	013H
	DB	0cbH
	DB	0b7H
	DB	0fH
	DB	0bbH
	DB	0a7H
	DB	0fH
	DB	0abH
	DB	097H
	DB	0bH
	DB	09bH
	DB	083H
	DB	07H
	DB	08bH
	DB	073H
	DB	07H
	DB	07bH
	DB	063H
	DB	07H
	DB	06bH
	DB	053H
	DB	00H
	DB	05bH
	DB	047H
	DB	00H
	DB	04bH
	DB	037H
	DB	00H
	DB	03bH
	DB	02bH
	DB	00H
	DB	02bH
	DB	01fH
	DB	00H
	DB	01bH
	DB	0fH
	DB	00H
	DB	0bH
	DB	07H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0bH
	DB	0bH
	DB	0efH
	DB	013H
	DB	013H
	DB	0dfH
	DB	01bH
	DB	01bH
	DB	0cfH
	DB	023H
	DB	023H
	DB	0bfH
	DB	02bH
	DB	02bH
	DB	0afH
	DB	02fH
	DB	02fH
	DB	09fH
	DB	02fH
	DB	02fH
	DB	08fH
	DB	02fH
	DB	02fH
	DB	07fH
	DB	02fH
	DB	02fH
	DB	06fH
	DB	02fH
	DB	02fH
	DB	05fH
	DB	02bH
	DB	02bH
	DB	04fH
	DB	023H
	DB	023H
	DB	03fH
	DB	01bH
	DB	01bH
	DB	02fH
	DB	013H
	DB	013H
	DB	01fH
	DB	0bH
	DB	0bH
	DB	0fH
	DB	02bH
	DB	00H
	DB	00H
	DB	03bH
	DB	00H
	DB	00H
	DB	04bH
	DB	07H
	DB	00H
	DB	05fH
	DB	07H
	DB	00H
	DB	06fH
	DB	0fH
	DB	00H
	DB	07fH
	DB	017H
	DB	07H
	DB	093H
	DB	01fH
	DB	07H
	DB	0a3H
	DB	027H
	DB	0bH
	DB	0b7H
	DB	033H
	DB	0fH
	DB	0c3H
	DB	04bH
	DB	01bH
	DB	0cfH
	DB	063H
	DB	02bH
	DB	0dbH
	DB	07fH
	DB	03bH
	DB	0e3H
	DB	097H
	DB	04fH
	DB	0e7H
	DB	0abH
	DB	05fH
	DB	0efH
	DB	0bfH
	DB	077H
	DB	0f7H
	DB	0d3H
	DB	08bH
	DB	0a7H
	DB	07bH
	DB	03bH
	DB	0b7H
	DB	09bH
	DB	037H
	DB	0c7H
	DB	0c3H
	DB	037H
	DB	0e7H
	DB	0e3H
	DB	057H
	DB	00H
	DB	0ffH
	DB	00H
	DB	0abH
	DB	0e7H
	DB	0ffH
	DB	0d7H
	DB	0ffH
	DB	0ffH
	DB	067H
	DB	00H
	DB	00H
	DB	08bH
	DB	00H
	DB	00H
	DB	0b3H
	DB	00H
	DB	00H
	DB	0d7H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0f3H
	DB	093H
	DB	0ffH
	DB	0f7H
	DB	0c7H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	09fH
	DB	05bH
	DB	053H
_img_emboss DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	0bf333333r			; -0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	0bf333333r			; -0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	000000000r			; 0
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
	DD	03f333333r			; 0.7
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	055fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	022fH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ApplyFilter
_TEXT	SEGMENT
tv277 = -140						; size = 4
tv223 = -140						; size = 4
tv69 = -140						; size = 4
tv276 = -136						; size = 4
tv222 = -136						; size = 4
tv68 = -136						; size = 4
_tmp$1 = -68						; size = 4
_src$2 = -64						; size = 4
_img_y$3 = -60						; size = 4
_img_x$4 = -56						; size = 4
_avg$5 = -52						; size = 4
_pos_y$6 = -48						; size = 4
_pos_x$7 = -44						; size = 4
_vout$8 = -40						; size = 12
_size$ = -28						; size = 4
_fout$ = -24						; size = 4
_fin$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pic$ = 8						; size = 4
_factor$ = 12						; size = 4
_Image_ApplyFilter PROC					; COMDAT

; 1373 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1374 : 	int	i, x, y; 
; 1375 : 	uint	*fin, *fout; 
; 1376 : 	size_t	size;
; 1377 : 
; 1378 : 	// first expand the image into 32-bit buffer
; 1379 : 	pic = Image_DecompressInternal( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax

; 1380 : 	factor = bound( 0.0f, factor, 1.0f );

	movss	xmm0, DWORD PTR _factor$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN23@Image_Appl
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _factor$[ebp]
	jbe	SHORT $LN21@Image_Appl
	movss	xmm0, DWORD PTR _factor$[ebp]
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN22@Image_Appl
$LN21@Image_Appl:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv68[ebp], xmm0
$LN22@Image_Appl:
	movss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN24@Image_Appl
$LN23@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv69[ebp], xmm0
$LN24@Image_Appl:
	movss	xmm0, DWORD PTR tv69[ebp]
	movss	DWORD PTR _factor$[ebp], xmm0

; 1381 : 	size = image.width * image.height * 4;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 1382 : 	image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ApplyFilter@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1383 : 	fout = (uint *)image.tempbuffer;

	mov	eax, DWORD PTR _image+84
	mov	DWORD PTR _fout$[ebp], eax

; 1384 : 	fin = (uint *)pic->buffer;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _fin$[ebp], ecx

; 1385 : 
; 1386 : 	for( x = 0; x < image.width; x++ ) 

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN4@Image_Appl
$LN2@Image_Appl:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN4@Image_Appl:
	movzx	eax, WORD PTR _image+8
	cmp	DWORD PTR _x$[ebp], eax
	jge	$LN3@Image_Appl

; 1387 : 	{ 
; 1388 : 		for( y = 0; y < image.height; y++ ) 

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@Image_Appl
$LN5@Image_Appl:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN7@Image_Appl:
	movzx	eax, WORD PTR _image+10
	cmp	DWORD PTR _y$[ebp], eax
	jge	$LN6@Image_Appl

; 1389 : 		{ 
; 1390 : 			vec3_t	vout = { 0.0f, 0.0f, 0.0f }; 

	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp+4], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vout$8[ebp+8], xmm0

; 1391 : 			int	pos_x, pos_y;
; 1392 : 			float	avg;
; 1393 : 
; 1394 : 			for( pos_x = 0; pos_x < FILTER_SIZE; pos_x++ ) 

	mov	DWORD PTR _pos_x$7[ebp], 0
	jmp	SHORT $LN10@Image_Appl
$LN8@Image_Appl:
	mov	eax, DWORD PTR _pos_x$7[ebp]
	add	eax, 1
	mov	DWORD PTR _pos_x$7[ebp], eax
$LN10@Image_Appl:
	cmp	DWORD PTR _pos_x$7[ebp], 5
	jge	$LN9@Image_Appl

; 1395 : 			{ 
; 1396 : 				for( pos_y = 0; pos_y < FILTER_SIZE; pos_y++ ) 

	mov	DWORD PTR _pos_y$6[ebp], 0
	jmp	SHORT $LN13@Image_Appl
$LN11@Image_Appl:
	mov	eax, DWORD PTR _pos_y$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pos_y$6[ebp], eax
$LN13@Image_Appl:
	cmp	DWORD PTR _pos_y$6[ebp], 5
	jge	$LN12@Image_Appl

; 1397 : 				{ 
; 1398 : 					int	img_x = (x - (FILTER_SIZE / 2) + pos_x + image.width) % image.width; 

	mov	eax, DWORD PTR _pos_x$7[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [ecx+eax-2]
	movzx	edx, WORD PTR _image+8
	add	eax, edx
	movzx	ecx, WORD PTR _image+8
	cdq
	idiv	ecx
	mov	DWORD PTR _img_x$4[ebp], edx

; 1399 : 					int	img_y = (y - (FILTER_SIZE / 2) + pos_y + image.height) % image.height; 

	mov	eax, DWORD PTR _pos_y$6[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [ecx+eax-2]
	movzx	edx, WORD PTR _image+10
	add	eax, edx
	movzx	ecx, WORD PTR _image+10
	cdq
	idiv	ecx
	mov	DWORD PTR _img_y$3[ebp], edx

; 1400 : 
; 1401 : 					// casting's a unary operation anyway, so the othermost set of brackets in the left part 
; 1402 : 					// of the rvalue should not be necessary... but i'm paranoid when it comes to C... 
; 1403 : 					vout[0] += ((float)((byte *)&fin[img_y * image.width + img_x])[0]) * img_emboss[pos_x][pos_y]; 

	mov	eax, 4
	imul	ecx, eax, 0
	movzx	edx, WORD PTR _image+8
	imul	edx, DWORD PTR _img_y$3[ebp]
	add	edx, DWORD PTR _img_x$4[ebp]
	mov	eax, DWORD PTR _fin$[ebp]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, 1
	imul	eax, eax, 0
	movzx	edx, BYTE PTR [edx+eax]
	cvtsi2ss xmm0, edx
	imul	eax, DWORD PTR _pos_x$7[ebp], 20
	mov	edx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[eax+edx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vout$8[ebp+ecx], xmm0

; 1404 : 					vout[1] += ((float)((byte *)&fin[img_y * image.width + img_x])[1]) * img_emboss[pos_x][pos_y]; 

	mov	eax, 4
	shl	eax, 0
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _img_y$3[ebp]
	add	ecx, DWORD PTR _img_x$4[ebp]
	mov	edx, DWORD PTR _fin$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	shl	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx]
	cvtsi2ss xmm0, ecx
	imul	edx, DWORD PTR _pos_x$7[ebp], 20
	mov	ecx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[edx+ecx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vout$8[ebp+edx], xmm0

; 1405 : 					vout[2] += ((float)((byte *)&fin[img_y * image.width + img_x])[2]) * img_emboss[pos_x][pos_y]; 

	mov	eax, 4
	shl	eax, 1
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _img_y$3[ebp]
	add	ecx, DWORD PTR _img_x$4[ebp]
	mov	edx, DWORD PTR _fin$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	shl	edx, 1
	movzx	ecx, BYTE PTR [ecx+edx]
	cvtsi2ss xmm0, ecx
	imul	edx, DWORD PTR _pos_x$7[ebp], 20
	mov	ecx, DWORD PTR _pos_y$6[ebp]
	mulss	xmm0, DWORD PTR _img_emboss[edx+ecx*4]
	addss	xmm0, DWORD PTR _vout$8[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vout$8[ebp+edx], xmm0

; 1406 : 				} 

	jmp	$LN11@Image_Appl
$LN12@Image_Appl:

; 1407 : 			} 

	jmp	$LN8@Image_Appl
$LN9@Image_Appl:

; 1408 : 
; 1409 : 			// multiply by factor, add bias, and clamp 
; 1410 : 			for( i = 0; i < 3; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Image_Appl
$LN14@Image_Appl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Image_Appl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN15@Image_Appl

; 1411 : 			{ 
; 1412 : 				vout[i] *= factor; 

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+eax*4]
	mulss	xmm0, DWORD PTR _factor$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _vout$8[ebp+ecx*4], xmm0

; 1413 : 				vout[i] += 128.0f; // base 

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+eax*4]
	addss	xmm0, DWORD PTR __real@43000000
	mov	ecx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _vout$8[ebp+ecx*4], xmm0

; 1414 : 				vout[i] = bound( 0.0f, vout[i], 255.0f );

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN27@Image_Appl
	mov	ecx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _vout$8[ebp+ecx*4]
	jbe	SHORT $LN25@Image_Appl
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+edx*4]
	movss	DWORD PTR tv222[ebp], xmm0
	jmp	SHORT $LN26@Image_Appl
$LN25@Image_Appl:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv222[ebp], xmm0
$LN26@Image_Appl:
	movss	xmm0, DWORD PTR tv222[ebp]
	movss	DWORD PTR tv223[ebp], xmm0
	jmp	SHORT $LN28@Image_Appl
$LN27@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv223[ebp], xmm0
$LN28@Image_Appl:
	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	movss	DWORD PTR _vout$8[ebp+eax*4], xmm0

; 1415 : 			} 

	jmp	$LN14@Image_Appl
$LN15@Image_Appl:

; 1416 : 
; 1417 : 			// NTSC greyscale conversion standard 
; 1418 : 			avg = (vout[0] * 30.0f + vout[1] * 59.0f + vout[2] * 11.0f) / 100.0f; 

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vout$8[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@41f00000
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vout$8[ebp+edx]
	mulss	xmm1, DWORD PTR __real@426c0000
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _vout$8[ebp+eax]
	mulss	xmm1, DWORD PTR __real@41300000
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _avg$5[ebp], xmm0

; 1419 : 
; 1420 : 			// divide by 255 so GL operations work as expected 
; 1421 : 			vout[0] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$5[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vout$8[ebp+ecx], xmm0

; 1422 : 			vout[1] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$5[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1423 : 			vout[2] = avg / 255.0f; 

	movss	xmm0, DWORD PTR _avg$5[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vout$8[ebp+eax], xmm0

; 1424 : 
; 1425 : 			// write to temp - first, write data in (to get the alpha channel quickly and 
; 1426 : 			// easily, which will be left well alone by this particular operation...!) 
; 1427 : 			fout[y * image.width + x] = fin[y * image.width + x]; 

	movzx	eax, WORD PTR _image+8
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 1428 : 
; 1429 : 			// now write in each element, applying the blend operator.  blend 
; 1430 : 			// operators are based on standard OpenGL TexEnv modes, and the 
; 1431 : 			// formulas are derived from the OpenGL specs (http://www.opengl.org). 
; 1432 : 			for( i = 0; i < 3; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@Image_Appl
$LN17@Image_Appl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@Image_Appl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN18@Image_Appl

; 1433 : 			{ 
; 1434 : 				// divide by 255 so GL operations work as expected 
; 1435 : 				float	src = ((float)((byte *)&fin[y * image.width + x])[i]) / 255.0f; 

	movzx	eax, WORD PTR _image+8
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _fin$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _src$2[ebp], xmm0

; 1436 : 				float	tmp;
; 1437 : 
; 1438 : 				// default is GL_BLEND here 
; 1439 : 				// CsS + CdD works out as Src * Dst * 2 
; 1440 : 				tmp = vout[i] * src * 2.0f; 

	mov	eax, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR _vout$8[ebp+eax*4]
	mulss	xmm0, DWORD PTR _src$2[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _tmp$1[ebp], xmm0

; 1441 : 
; 1442 : 				// multiply back by 255 to get the proper byte scale 
; 1443 : 				tmp *= 255.0f; 

	movss	xmm0, DWORD PTR _tmp$1[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tmp$1[ebp], xmm0

; 1444 : 
; 1445 : 				// bound the temp target again now, cos the operation may have thrown it out 
; 1446 : 				tmp = bound( 0.0f, tmp, 255.0f );

	movss	xmm0, DWORD PTR _tmp$1[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN31@Image_Appl
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _tmp$1[ebp]
	jbe	SHORT $LN29@Image_Appl
	movss	xmm0, DWORD PTR _tmp$1[ebp]
	movss	DWORD PTR tv276[ebp], xmm0
	jmp	SHORT $LN30@Image_Appl
$LN29@Image_Appl:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv276[ebp], xmm0
$LN30@Image_Appl:
	movss	xmm0, DWORD PTR tv276[ebp]
	movss	DWORD PTR tv277[ebp], xmm0
	jmp	SHORT $LN32@Image_Appl
$LN31@Image_Appl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv277[ebp], xmm0
$LN32@Image_Appl:
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _tmp$1[ebp], xmm0

; 1447 : 				// and copy it in 
; 1448 : 				((byte *)&fout[y * image.width + x])[i] = (byte)tmp; 

	cvttss2si eax, DWORD PTR _tmp$1[ebp]
	movzx	ecx, WORD PTR _image+8
	imul	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 1449 : 			} 

	jmp	$LN17@Image_Appl
$LN18@Image_Appl:

; 1450 : 		} 

	jmp	$LN5@Image_Appl
$LN6@Image_Appl:

; 1451 : 	} 

	jmp	$LN2@Image_Appl
$LN3@Image_Appl:

; 1452 : 
; 1453 : 	// copy result back
; 1454 : 	memcpy( fin, fout, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fin$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1455 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ApplyFilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_RemapInternal
_TEXT	SEGMENT
tv67 = -68						; size = 4
_pic$ = 8						; size = 4
_topColor$ = 12						; size = 4
_bottomColor$ = 16					; size = 4
_Image_RemapInternal PROC				; COMDAT

; 1331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1332 : 	if( !pic->palette )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN4@Image_Rema

; 1333 : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Rema
$LN4@Image_Rema:

; 1334 : 
; 1335 : 	switch( pic->type )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 1
	je	SHORT $LN5@Image_Rema
	cmp	DWORD PTR tv67[ebp], 2
	je	SHORT $LN6@Image_Rema
	jmp	SHORT $LN7@Image_Rema
$LN5@Image_Rema:

; 1336 : 	{
; 1337 : 	case PF_INDEXED_24:
; 1338 : 		break;

	jmp	SHORT $LN2@Image_Rema
$LN6@Image_Rema:

; 1339 : 	case PF_INDEXED_32:
; 1340 : 		Image_ConvertPalTo24bit( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_ConvertPalTo24bit
	add	esp, 4

; 1341 : 		break;

	jmp	SHORT $LN2@Image_Rema
$LN7@Image_Rema:

; 1342 : 	default:
; 1343 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Rema
$LN2@Image_Rema:

; 1344 : 	}
; 1345 : 
; 1346 : 	if( Image_ComparePalette( pic->palette ) == PAL_QUAKE1 )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_Image_ComparePalette
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN8@Image_Rema

; 1347 : 	{
; 1348 : 		Image_PaletteTranslate( pic->palette, topColor * 16, bottomColor * 16, 3 );

	push	3
	mov	eax, DWORD PTR _bottomColor$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _topColor$[ebp]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_Image_PaletteTranslate
	add	esp, 16					; 00000010H

; 1349 : 	}

	jmp	SHORT $LN9@Image_Rema
$LN8@Image_Rema:

; 1350 : 	else
; 1351 : 	{
; 1352 : 		// g-cont. preview images has a swapped top and bottom colors. I don't know why.
; 1353 : 		Image_PaletteHueReplace( pic->palette, topColor, SUIT_HUE_START, SUIT_HUE_END, 3 );

	push	3
	push	223					; 000000dfH
	push	192					; 000000c0H
	mov	eax, DWORD PTR _topColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H

; 1354 : 		Image_PaletteHueReplace( pic->palette, bottomColor, PLATE_HUE_START, PLATE_HUE_END, 3 );

	push	3
	push	191					; 000000bfH
	push	160					; 000000a0H
	mov	eax, DWORD PTR _bottomColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_Image_PaletteHueReplace
	add	esp, 20					; 00000014H
$LN9@Image_Rema:

; 1355 : 	}
; 1356 : 
; 1357 : 	return true;

	mov	eax, 1
$LN1@Image_Rema:

; 1358 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_RemapInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_LightGamma
_TEXT	SEGMENT
_i$ = -8						; size = 4
_in$ = -4						; size = 4
_pic$ = 8						; size = 4
_Image_LightGamma PROC					; COMDAT

; 1313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1314 : 	byte	*in = (byte *)pic->buffer;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _in$[ebp], ecx

; 1315 : 	int	i;
; 1316 : 
; 1317 : 	if( pic->type != PF_RGBA_32 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 3
	je	SHORT $LN5@Image_Ligh

; 1318 : 		return pic;

	mov	eax, DWORD PTR _pic$[ebp]
	jmp	$LN1@Image_Ligh
$LN5@Image_Ligh:

; 1319 : 
; 1320 : 	for( i = 0; i < pic->width * pic->height; i++, in += 4 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Ligh
$LN2@Image_Ligh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$[ebp], ecx
$LN4@Image_Ligh:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@Image_Ligh

; 1321 : 	{
; 1322 : 		in[0] = LightToTexGamma( in[0] );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	_LightToTexGamma
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 1323 : 		in[1] = LightToTexGamma( in[1] );

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1324 : 		in[2] = LightToTexGamma( in[2] );

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 1325 : 	}

	jmp	$LN2@Image_Ligh
$LN3@Image_Ligh:

; 1326 : 
; 1327 : 	return pic;

	mov	eax, DWORD PTR _pic$[ebp]
$LN1@Image_Ligh:

; 1328 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LightGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_DecompressInternal
_TEXT	SEGMENT
_pic$ = 8						; size = 4
_Image_DecompressInternal PROC				; COMDAT

; 1290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1291 : 	// quick case to reject unneeded conversions
; 1292 : 	if( pic->type == PF_RGBA_32 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN2@Image_Deco

; 1293 : 		return pic;

	mov	eax, DWORD PTR _pic$[ebp]
	jmp	$LN1@Image_Deco
$LN2@Image_Deco:

; 1294 : 
; 1295 : 	Image_CopyParms( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_CopyParms
	add	esp, 4

; 1296 : 	image.size = image.ptr = 0;

	mov	DWORD PTR _image+32, 0
	mov	eax, DWORD PTR _image+32
	mov	DWORD PTR _image+28, eax

; 1297 : 
; 1298 : 	Image_Decompress( pic->buffer );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_Image_Decompress
	add	esp, 4

; 1299 : 
; 1300 : 	// now we can change type to RGBA
; 1301 : 	pic->type = PF_RGBA_32;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax+8], 3

; 1302 : 
; 1303 : 	pic->buffer = Mem_Realloc( host.imagepool, pic->buffer, image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_DecompressInternal@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1304 : 	memcpy( pic->buffer, image.tempbuffer, image.size );

	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1305 : 	if( pic->palette ) Mem_Free( pic->palette );

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@Image_Deco
	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_DecompressInternal@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@Image_Deco:

; 1306 : 	pic->flags = image.flags;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _image+24
	mov	DWORD PTR [eax+12], ecx

; 1307 : 	pic->palette = NULL;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1308 : 
; 1309 : 	return pic;

	mov	eax, DWORD PTR _pic$[ebp]
$LN1@Image_Deco:

; 1310 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DecompressInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Decompress
_TEXT	SEGMENT
tv80 = -84						; size = 4
_size$ = -16						; size = 4
_i$ = -12						; size = 4
_fout$ = -8						; size = 4
_fin$ = -4						; size = 4
_data$ = 8						; size = 4
_Image_Decompress PROC					; COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1223 : 	byte	*fin, *fout;
; 1224 : 	int	i, size; 
; 1225 : 
; 1226 : 	if( !data ) return false;

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN13@Image_Deco
	xor	eax, eax
	jmp	$LN1@Image_Deco
$LN13@Image_Deco:

; 1227 : 	fin = (byte *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _fin$[ebp], eax

; 1228 : 
; 1229 : 	size = image.width * image.height * 4;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 1230 : 	image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Decompress@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1231 : 	fout = image.tempbuffer;

	mov	eax, DWORD PTR _image+84
	mov	DWORD PTR _fout$[ebp], eax

; 1232 : 
; 1233 : 	switch( PFDesc[image.type].format )

	imul	eax, DWORD PTR _image+20, 28
	mov	ecx, DWORD PTR _PFDesc[eax]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	sub	edx, 1
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 5
	ja	$LN26@Image_Deco
	mov	eax, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN28@Image_Deco[eax*4]
$LN14@Image_Deco:

; 1234 : 	{
; 1235 : 	case PF_INDEXED_24:
; 1236 : 		if( image.flags & IMAGE_HAS_ALPHA )

	mov	eax, DWORD PTR _image+24
	and	eax, 2
	je	SHORT $LN15@Image_Deco

; 1237 : 		{
; 1238 : 			if( image.flags & IMAGE_COLORINDEX )

	mov	eax, DWORD PTR _image+24
	and	eax, 8
	je	SHORT $LN17@Image_Deco

; 1239 : 				Image_GetPaletteLMP( image.palette, LUMP_GRADIENT ); 

	push	2
	mov	eax, DWORD PTR _image+72
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8
	jmp	SHORT $LN18@Image_Deco
$LN17@Image_Deco:

; 1240 : 			else Image_GetPaletteLMP( image.palette, LUMP_MASKED ); 

	push	1
	mov	eax, DWORD PTR _image+72
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8
$LN18@Image_Deco:

; 1241 : 		}

	jmp	SHORT $LN19@Image_Deco
$LN15@Image_Deco:

; 1242 : 		else Image_GetPaletteLMP( image.palette, LUMP_NORMAL );

	push	0
	mov	eax, DWORD PTR _image+72
	push	eax
	call	_Image_GetPaletteLMP
	add	esp, 8
$LN19@Image_Deco:

; 1243 : 		// intentional falltrough
; 1244 : 	case PF_INDEXED_32:
; 1245 : 		if( !image.d_currentpal ) image.d_currentpal = (uint *)image.palette;

	cmp	DWORD PTR _image+64, 0
	jne	SHORT $LN20@Image_Deco
	mov	eax, DWORD PTR _image+72
	mov	DWORD PTR _image+64, eax
$LN20@Image_Deco:

; 1246 : 		if( !Image_Copy8bitRGBA( fin, fout, image.width * image.height ))

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	push	eax
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	call	_Image_Copy8bitRGBA
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Image_Deco

; 1247 : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Deco
$LN21@Image_Deco:

; 1248 : 		break;

	jmp	$LN2@Image_Deco
$LN22@Image_Deco:

; 1249 : 	case PF_BGR_24:
; 1250 : 		for (i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_Deco
$LN4@Image_Deco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_Deco:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN5@Image_Deco

; 1251 : 		{
; 1252 : 			fout[(i<<2)+0] = fin[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx*4], al

; 1253 : 			fout[(i<<2)+1] = fin[i*3+1];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 1254 : 			fout[(i<<2)+2] = fin[i*3+0];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx*4+2], al

; 1255 : 			fout[(i<<2)+3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	BYTE PTR [ecx+eax*4+3], 255		; 000000ffH

; 1256 : 		}

	jmp	SHORT $LN4@Image_Deco
$LN5@Image_Deco:

; 1257 : 		break;

	jmp	$LN2@Image_Deco
$LN23@Image_Deco:

; 1258 : 	case PF_RGB_24:
; 1259 : 		for (i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Image_Deco
$LN7@Image_Deco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Image_Deco:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN8@Image_Deco

; 1260 : 		{
; 1261 : 			fout[(i<<2)+0] = fin[i*3+0];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx*4], al

; 1262 : 			fout[(i<<2)+1] = fin[i*3+1];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx*4+1], al

; 1263 : 			fout[(i<<2)+2] = fin[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fout$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	al, BYTE PTR [esi+eax+2]
	mov	BYTE PTR [edx+ecx*4+2], al

; 1264 : 			fout[(i<<2)+3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	BYTE PTR [ecx+eax*4+3], 255		; 000000ffH

; 1265 : 		}

	jmp	SHORT $LN7@Image_Deco
$LN8@Image_Deco:

; 1266 : 		break;

	jmp	$LN2@Image_Deco
$LN24@Image_Deco:

; 1267 : 	case PF_BGRA_32:
; 1268 : 		for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_Deco
$LN10@Image_Deco:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Image_Deco:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN11@Image_Deco

; 1269 : 		{
; 1270 : 			fout[i*4+0] = fin[i*4+2];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx*4+2]
	mov	BYTE PTR [ecx+eax*4], dl

; 1271 : 			fout[i*4+1] = fin[i*4+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx*4+1]
	mov	BYTE PTR [ecx+eax*4+1], dl

; 1272 : 			fout[i*4+2] = fin[i*4+0];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx*4]
	mov	BYTE PTR [ecx+eax*4+2], dl

; 1273 : 			fout[i*4+3] = fin[i*4+3];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fout$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _fin$[ebp]
	mov	dl, BYTE PTR [esi+edx*4+3]
	mov	BYTE PTR [ecx+eax*4+3], dl

; 1274 : 		}

	jmp	SHORT $LN10@Image_Deco
$LN11@Image_Deco:

; 1275 : 		break;

	jmp	SHORT $LN2@Image_Deco
$LN25@Image_Deco:

; 1276 : 	case PF_RGBA_32:
; 1277 : 		// fast default case
; 1278 : 		memcpy( fout, fin, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fout$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1279 : 		break;

	jmp	SHORT $LN2@Image_Deco
$LN26@Image_Deco:

; 1280 : 	default: return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Deco
$LN2@Image_Deco:

; 1281 : 	}
; 1282 : 
; 1283 : 	// set new size
; 1284 : 	image.size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _image+28, eax

; 1285 : 
; 1286 : 	return true;

	mov	eax, 1
$LN1@Image_Deco:

; 1287 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@Image_Deco:
	DD	$LN14@Image_Deco
	DD	$LN19@Image_Deco
	DD	$LN25@Image_Deco
	DD	$LN24@Image_Deco
	DD	$LN23@Image_Deco
	DD	$LN22@Image_Deco
_Image_Decompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CreateLumaInternal
_TEXT	SEGMENT
tv87 = -76						; size = 4
tv66 = -76						; size = 4
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_fin$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_type$ = 20						; size = 4
_flags$ = 24						; size = 4
_Image_CreateLumaInternal PROC				; COMDAT

; 1166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1167 : 	byte	*out;
; 1168 : 	int	i;
; 1169 : 
; 1170 : 	if( !FBitSet( flags, IMAGE_HAS_LUMA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	jne	SHORT $LN7@Image_Crea

; 1171 : 		return (byte *)fin;	  

	mov	eax, DWORD PTR _fin$[ebp]
	jmp	$LN1@Image_Crea
$LN7@Image_Crea:

; 1172 : 
; 1173 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN9@Image_Crea
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN9@Image_Crea
	jmp	$LN10@Image_Crea
$LN9@Image_Crea:

; 1174 : 	{
; 1175 : 	case PF_INDEXED_24:
; 1176 : 	case PF_INDEXED_32:
; 1177 : 		out = image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, width * height );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_CreateLumaInternal@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _width$[ebp]
	imul	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax
	mov	ecx, DWORD PTR _image+84
	mov	DWORD PTR _out$[ebp], ecx

; 1178 : 		for( i = 0; i < width * height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_Crea
$LN4@Image_Crea:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_Crea:
	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN5@Image_Crea

; 1179 : 			*out++ = fin[i] >= 224 ? fin[i] : 0;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 224				; 000000e0H
	jl	SHORT $LN12@Image_Crea
	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN13@Image_Crea
$LN12@Image_Crea:
	mov	DWORD PTR tv87[ebp], 0
$LN13@Image_Crea:
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR tv87[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	jmp	SHORT $LN4@Image_Crea
$LN5@Image_Crea:

; 1180 : 		break;

	jmp	SHORT $LN2@Image_Crea
$LN10@Image_Crea:

; 1181 : 	default:
; 1182 : 		// another formats does ugly result :(
; 1183 : 		Con_Printf( S_ERROR "Image_MakeLuma: unsupported format %s\n", PFDesc[type].name );

	imul	eax, DWORD PTR _type$[ebp], 28
	add	eax, OFFSET _PFDesc+4
	push	eax
	push	OFFSET ??_C@_0DC@FDGCNINA@?$FO1Error?3?$FO7?5Image_MakeLuma?3?5unsu@
	call	_Con_Printf
	add	esp, 8

; 1184 : 		return (byte *)fin;	

	mov	eax, DWORD PTR _fin$[ebp]
	jmp	SHORT $LN1@Image_Crea
$LN2@Image_Crea:

; 1185 : 	}
; 1186 : 
; 1187 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Crea:

; 1188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CreateLumaInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample8Nolerp
_TEXT	SEGMENT
_out$ = -28						; size = 4
_fracstep$ = -24					; size = 4
_frac$ = -20						; size = 4
_inrow$ = -16						; size = 4
_in$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample8Nolerp PROC				; COMDAT

; 1027 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1028 : 	int	i, j;
; 1029 : 	byte	*in, *inrow;
; 1030 : 	uint	frac, fracstep;
; 1031 : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 1032 : 
; 1033 : 	in = (byte *)indata;

	mov	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _in$[ebp], eax

; 1034 : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 1035 : 
; 1036 : 	for( i = 0; i < outheight; i++, out += outwidth )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	SHORT $LN1@Image_Resa

; 1037 : 	{
; 1038 : 		inrow = in + inwidth*(i*inheight/outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth$[ebp]
	add	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 1039 : 		frac = fracstep>>1;

	mov	eax, DWORD PTR _fracstep$[ebp]
	shr	eax, 1
	mov	DWORD PTR _frac$[ebp], eax

; 1040 : 
; 1041 : 		for( j = 0; j < outwidth; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Image_Resa
$LN5@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _outwidth$[ebp]
	jge	SHORT $LN6@Image_Resa

; 1042 : 		{
; 1043 : 			out[j] = inrow[frac>>16];

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _inrow$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al

; 1044 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1045 : 		}

	jmp	SHORT $LN5@Image_Resa
$LN6@Image_Resa:

; 1046 : 	}

	jmp	SHORT $LN2@Image_Resa
$LN1@Image_Resa:

; 1047 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample8Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample24Nolerp
_TEXT	SEGMENT
_out$ = -32						; size = 4
_inrow$ = -28						; size = 4
_inwidth3$ = -24					; size = 4
_f$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_fracstep$ = -8						; size = 4
_frac$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample24Nolerp PROC				; COMDAT

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 962  : 	uint	frac, fracstep;
; 963  : 	int	i, j, f, inwidth3 = inwidth * 3;

	imul	eax, DWORD PTR _inwidth$[ebp], 3
	mov	DWORD PTR _inwidth3$[ebp], eax

; 964  : 	byte	*inrow, *out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 965  : 
; 966  : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 967  : 
; 968  : 	for( i = 0; i < outheight; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN1@Image_Resa

; 969  : 	{
; 970  : 		inrow = (byte *)indata + inwidth3 * (i * inheight / outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth3$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 971  : 		frac = fracstep>>1;

	mov	eax, DWORD PTR _fracstep$[ebp]
	shr	eax, 1
	mov	DWORD PTR _frac$[ebp], eax

; 972  : 		j = outwidth - 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@Image_Resa:

; 973  : 
; 974  : 		while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 975  : 		{
; 976  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 977  : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 978  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 979  : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 980  : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 981  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 982  : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 983  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 984  : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 985  : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 986  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 987  : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 988  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 989  : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 990  : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 991  : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 992  : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 993  : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 994  : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 995  : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 996  : 			j -= 4;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax

; 997  : 		}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 998  : 
; 999  : 		if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	$LN7@Image_Resa

; 1000 : 		{
; 1001 : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 1002 : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1003 : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1004 : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1005 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1006 : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 1007 : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1008 : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1009 : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1010 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1011 : 			out += 2;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax
$LN7@Image_Resa:

; 1012 : 		}
; 1013 : 
; 1014 : 		if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	SHORT $LN8@Image_Resa

; 1015 : 		{
; 1016 : 			f = (frac >> 16)*3;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	imul	ecx, eax, 3
	mov	DWORD PTR _f$[ebp], ecx

; 1017 : 			*out++ = inrow[f+0];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1018 : 			*out++ = inrow[f+1];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+1]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1019 : 			*out++ = inrow[f+2];

	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax

; 1020 : 			frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 1021 : 			out += 1;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
$LN8@Image_Resa:

; 1022 : 		}
; 1023 : 	}

	jmp	$LN2@Image_Resa
$LN1@Image_Resa:

; 1024 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample24Lerp
_TEXT	SEGMENT
_resamplerow2$ = -60					; size = 4
_resamplerow1$ = -56					; size = 4
_out$ = -52						; size = 4
_outwidth3$ = -48					; size = 4
_inwidth3$ = -44					; size = 4
_endy$ = -40						; size = 4
_lerp$ = -36						; size = 4
_fstep$ = -32						; size = 4
_f$ = -28						; size = 4
_oldy$ = -24						; size = 4
_yi$ = -20						; size = 4
_r$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_inrow$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample24Lerp PROC				; COMDAT

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 861  : 	const byte *inrow;
; 862  : 	int	i, j, r, yi, oldy, f, fstep, lerp, endy = (inheight - 1);

	mov	eax, DWORD PTR _inheight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endy$[ebp], eax

; 863  : 	int	inwidth3 = inwidth * 3;

	imul	eax, DWORD PTR _inwidth$[ebp], 3
	mov	DWORD PTR _inwidth3$[ebp], eax

; 864  : 	int	outwidth3 = outwidth * 3;

	imul	eax, DWORD PTR _outwidth$[ebp], 3
	mov	DWORD PTR _outwidth3$[ebp], eax

; 865  : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 866  : 	byte	*resamplerow1;
; 867  : 	byte	*resamplerow2;
; 868  : 	
; 869  : 	fstep = (int)(inheight * 65536.0f / outheight);

	cvtsi2ss xmm0, DWORD PTR _inheight$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outheight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 870  : 
; 871  : 	resamplerow1 = (byte *)Mem_Malloc( host.imagepool, outwidth * 3 * 2 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Resample24Lerp@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _outwidth$[ebp], 3
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 872  : 	resamplerow2 = resamplerow1 + outwidth*3;

	imul	eax, DWORD PTR _outwidth$[ebp], 3
	add	eax, DWORD PTR _resamplerow1$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 873  : 
; 874  : 	inrow = (const byte *)indata;

	mov	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 875  : 	oldy = 0;

	mov	DWORD PTR _oldy$[ebp], 0

; 876  : 	Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 877  : 	Image_Resample24LerpLine( inrow + inwidth3, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth3$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 878  : 
; 879  : 	for( i = 0, f = 0; i < outheight; i++, f += fstep )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], ecx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN3@Image_Resa

; 880  : 	{
; 881  : 		yi = f>>16;

	mov	eax, DWORD PTR _f$[ebp]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _yi$[ebp], eax

; 882  : 
; 883  : 		if( yi < endy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _endy$[ebp]
	jge	$LN7@Image_Resa

; 884  : 		{
; 885  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 886  : 			if( yi != oldy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _oldy$[ebp]
	je	SHORT $LN9@Image_Resa

; 887  : 			{
; 888  : 				inrow = (byte *)indata + inwidth3 * yi;

	mov	eax, DWORD PTR _inwidth3$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 889  : 				if( yi == oldy + 1) memcpy( resamplerow1, resamplerow2, outwidth3 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN10@Image_Resa
	mov	eax, DWORD PTR _outwidth3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@Image_Resa
$LN10@Image_Resa:

; 890  : 				else Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H
$LN11@Image_Resa:

; 891  : 				Image_Resample24LerpLine( inrow + inwidth3, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth3$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H

; 892  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN9@Image_Resa:

; 893  : 			}
; 894  : 
; 895  : 			j = outwidth - 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@Image_Resa:

; 896  : 
; 897  : 			while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 898  : 			{
; 899  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 900  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 901  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 902  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 903  : 				LERPBYTE( 4);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 904  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 905  : 				LERPBYTE( 6);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 906  : 				LERPBYTE( 7);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 907  : 				LERPBYTE( 8);

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 908  : 				LERPBYTE( 9);

	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 909  : 				LERPBYTE(10);

	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 910  : 				LERPBYTE(11);

	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 911  : 				out += 12;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _out$[ebp], eax

; 912  : 				resamplerow1 += 12;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 913  : 				resamplerow2 += 12;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 914  : 				j -= 4;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax

; 915  : 			}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 916  : 
; 917  : 			if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	$LN12@Image_Resa

; 918  : 			{
; 919  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 920  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 921  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 922  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 923  : 				LERPBYTE( 4);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 924  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 925  : 				out += 6;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 6
	mov	DWORD PTR _out$[ebp], eax

; 926  : 				resamplerow1 += 6;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 6
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 927  : 				resamplerow2 += 6;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 6
	mov	DWORD PTR _resamplerow2$[ebp], eax
$LN12@Image_Resa:

; 928  : 			}
; 929  : 
; 930  : 			if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	$LN13@Image_Resa

; 931  : 			{
; 932  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 933  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 934  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 935  : 				out += 3;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 3
	mov	DWORD PTR _out$[ebp], eax

; 936  : 				resamplerow1 += 3;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 3
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 937  : 				resamplerow2 += 3;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 3
	mov	DWORD PTR _resamplerow2$[ebp], eax
$LN13@Image_Resa:

; 938  : 			}
; 939  : 
; 940  : 			resamplerow1 -= outwidth3;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	sub	eax, DWORD PTR _outwidth3$[ebp]
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 941  : 			resamplerow2 -= outwidth3;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	sub	eax, DWORD PTR _outwidth3$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 942  : 		}

	jmp	SHORT $LN8@Image_Resa
$LN7@Image_Resa:

; 943  : 		else
; 944  : 		{
; 945  : 			if( yi != oldy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _oldy$[ebp]
	je	SHORT $LN14@Image_Resa

; 946  : 			{
; 947  : 				inrow = (byte *)indata + inwidth3*yi;

	mov	eax, DWORD PTR _inwidth3$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 948  : 				if( yi == oldy + 1) memcpy( resamplerow1, resamplerow2, outwidth3 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN15@Image_Resa
	mov	eax, DWORD PTR _outwidth3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@Image_Resa
$LN15@Image_Resa:

; 949  : 				else Image_Resample24LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample24LerpLine
	add	esp, 16					; 00000010H
$LN16@Image_Resa:

; 950  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN14@Image_Resa:

; 951  : 			}
; 952  : 
; 953  : 			memcpy( out, resamplerow1, outwidth3 );

	mov	eax, DWORD PTR _outwidth3$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@Image_Resa:

; 954  : 		}
; 955  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 956  : 
; 957  : 	Mem_Free( resamplerow1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Resample24Lerp@@9@9
	add	eax, 97					; 00000061H
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 958  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24Lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample32Nolerp
_TEXT	SEGMENT
_out$ = -24						; size = 4
_inrow$ = -20						; size = 4
_fracstep$ = -16					; size = 4
_frac$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample32Nolerp PROC				; COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 822  : 	int	i, j;
; 823  : 	uint	frac, fracstep;
; 824  : 	int	*inrow, *out = (int *)outdata; // relies on int being 4 bytes

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 825  : 
; 826  : 	fracstep = inwidth * 0x10000 / outwidth;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outwidth$[ebp]
	mov	DWORD PTR _fracstep$[ebp], eax

; 827  : 
; 828  : 	for( i = 0; i < outheight; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN1@Image_Resa

; 829  : 	{
; 830  : 		inrow = (int *)indata + inwidth * (i * inheight / outheight);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _inheight$[ebp]
	cdq
	idiv	DWORD PTR _outheight$[ebp]
	imul	eax, DWORD PTR _inwidth$[ebp]
	mov	ecx, DWORD PTR _indata$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inrow$[ebp], edx

; 831  : 		frac = fracstep>>1;

	mov	eax, DWORD PTR _fracstep$[ebp]
	shr	eax, 1
	mov	DWORD PTR _frac$[ebp], eax

; 832  : 		j = outwidth - 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@Image_Resa:

; 833  : 
; 834  : 		while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 835  : 		{
; 836  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 837  : 			out[1] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 838  : 			out[2] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 839  : 			out[3] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 840  : 			out += 4;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 841  : 			j -= 4;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax

; 842  : 		}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 843  : 
; 844  : 		if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	SHORT $LN7@Image_Resa

; 845  : 		{
; 846  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 847  : 			out[1] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 848  : 			out += 2;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 8
	mov	DWORD PTR _out$[ebp], eax
$LN7@Image_Resa:

; 849  : 		}
; 850  : 
; 851  : 		if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	SHORT $LN8@Image_Resa

; 852  : 		{
; 853  : 			out[0] = inrow[frac >> 16];frac += fracstep;

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	esi, DWORD PTR _inrow$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax
	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 854  : 			out += 1;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 4
	mov	DWORD PTR _out$[ebp], eax
$LN8@Image_Resa:

; 855  : 		}
; 856  : 	}

	jmp	$LN2@Image_Resa
$LN1@Image_Resa:

; 857  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32Nolerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample32Lerp
_TEXT	SEGMENT
_resamplerow2$ = -60					; size = 4
_resamplerow1$ = -56					; size = 4
_out$ = -52						; size = 4
_outwidth4$ = -48					; size = 4
_inwidth4$ = -44					; size = 4
_endy$ = -40						; size = 4
_lerp$ = -36						; size = 4
_fstep$ = -32						; size = 4
_f$ = -28						; size = 4
_oldy$ = -24						; size = 4
_yi$ = -20						; size = 4
_r$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_inrow$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outdata$ = 20						; size = 4
_outwidth$ = 24						; size = 4
_outheight$ = 28					; size = 4
_Image_Resample32Lerp PROC				; COMDAT

; 713  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 714  : 	const byte *inrow;
; 715  : 	int	i, j, r, yi, oldy = 0, f, fstep, lerp, endy = (inheight - 1);

	mov	DWORD PTR _oldy$[ebp], 0
	mov	eax, DWORD PTR _inheight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endy$[ebp], eax

; 716  : 	int	inwidth4 = inwidth * 4;

	mov	eax, DWORD PTR _inwidth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _inwidth4$[ebp], eax

; 717  : 	int	outwidth4 = outwidth * 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _outwidth4$[ebp], eax

; 718  : 	byte	*out = (byte *)outdata;

	mov	eax, DWORD PTR _outdata$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 719  : 	byte	*resamplerow1;
; 720  : 	byte	*resamplerow2;
; 721  : 
; 722  : 	fstep = (int)(inheight * 65536.0f / outheight);

	cvtsi2ss xmm0, DWORD PTR _inheight$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outheight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 723  : 
; 724  : 	resamplerow1 = (byte *)Mem_Malloc( host.imagepool, outwidth * 4 * 2);

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Resample32Lerp@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _outwidth$[ebp]
	shl	ecx, 2
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 725  : 	resamplerow2 = resamplerow1 + outwidth * 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _resamplerow2$[ebp], edx

; 726  : 
; 727  : 	inrow = (const byte *)indata;

	mov	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 728  : 
; 729  : 	Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 730  : 	Image_Resample32LerpLine( inrow + inwidth4, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth4$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 731  : 
; 732  : 	for( i = 0, f = 0; i < outheight; i++, f += fstep )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], ecx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jge	$LN3@Image_Resa

; 733  : 	{
; 734  : 		yi = f>>16;

	mov	eax, DWORD PTR _f$[ebp]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _yi$[ebp], eax

; 735  : 
; 736  : 		if( yi < endy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _endy$[ebp]
	jge	$LN7@Image_Resa

; 737  : 		{
; 738  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 739  : 			if( yi != oldy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _oldy$[ebp]
	je	SHORT $LN9@Image_Resa

; 740  : 			{
; 741  : 				inrow = (byte *)indata + inwidth4 * yi;

	mov	eax, DWORD PTR _inwidth4$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 742  : 				if( yi == oldy + 1 ) memcpy( resamplerow1, resamplerow2, outwidth4 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN10@Image_Resa
	mov	eax, DWORD PTR _outwidth4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@Image_Resa
$LN10@Image_Resa:

; 743  : 				else Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H
$LN11@Image_Resa:

; 744  : 				Image_Resample32LerpLine( inrow + inwidth4, resamplerow2, inwidth, outwidth );

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	add	eax, DWORD PTR _inwidth4$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H

; 745  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN9@Image_Resa:

; 746  : 			}
; 747  : 
; 748  : 			j = outwidth - 4;

	mov	eax, DWORD PTR _outwidth$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax
$LN5@Image_Resa:

; 749  : 
; 750  : 			while( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN6@Image_Resa

; 751  : 			{
; 752  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 753  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 754  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 755  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 756  : 				LERPBYTE( 4);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 757  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 758  : 				LERPBYTE( 6);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 759  : 				LERPBYTE( 7);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 760  : 				LERPBYTE( 8);

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 761  : 				LERPBYTE( 9);

	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 762  : 				LERPBYTE(10);

	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 763  : 				LERPBYTE(11);

	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 11
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 764  : 				LERPBYTE(12);

	mov	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 765  : 				LERPBYTE(13);

	mov	eax, 1
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 13
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 766  : 				LERPBYTE(14);

	mov	eax, 1
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 767  : 				LERPBYTE(15);

	mov	eax, 1
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 768  : 				out += 16;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _out$[ebp], eax

; 769  : 				resamplerow1 += 16;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 770  : 				resamplerow2 += 16;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 771  : 				j -= 4;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 4
	mov	DWORD PTR _j$[ebp], eax

; 772  : 			}

	jmp	$LN5@Image_Resa
$LN6@Image_Resa:

; 773  : 
; 774  : 			if( j & 2 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	$LN12@Image_Resa

; 775  : 			{
; 776  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 777  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 778  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 779  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 780  : 				LERPBYTE( 4);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 781  : 				LERPBYTE( 5);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 782  : 				LERPBYTE( 6);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 783  : 				LERPBYTE( 7);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 784  : 				out += 8;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 8
	mov	DWORD PTR _out$[ebp], eax

; 785  : 				resamplerow1 += 8;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 8
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 786  : 				resamplerow2 += 8;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 8
	mov	DWORD PTR _resamplerow2$[ebp], eax
$LN12@Image_Resa:

; 787  : 			}
; 788  : 
; 789  : 			if( j & 1 )

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	$LN13@Image_Resa

; 790  : 			{
; 791  : 				LERPBYTE( 0);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 792  : 				LERPBYTE( 1);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 793  : 				LERPBYTE( 2);

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR _r$[ebp], edx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, DWORD PTR _r$[ebp]
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	add	edx, DWORD PTR _r$[ebp]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 794  : 				LERPBYTE( 3);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR _r$[ebp], eax
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _resamplerow2$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _r$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 795  : 				out += 4;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 4
	mov	DWORD PTR _out$[ebp], eax

; 796  : 				resamplerow1 += 4;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	add	eax, 4
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 797  : 				resamplerow2 += 4;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	add	eax, 4
	mov	DWORD PTR _resamplerow2$[ebp], eax
$LN13@Image_Resa:

; 798  : 			}
; 799  : 
; 800  : 			resamplerow1 -= outwidth4;

	mov	eax, DWORD PTR _resamplerow1$[ebp]
	sub	eax, DWORD PTR _outwidth4$[ebp]
	mov	DWORD PTR _resamplerow1$[ebp], eax

; 801  : 			resamplerow2 -= outwidth4;

	mov	eax, DWORD PTR _resamplerow2$[ebp]
	sub	eax, DWORD PTR _outwidth4$[ebp]
	mov	DWORD PTR _resamplerow2$[ebp], eax

; 802  : 		}

	jmp	SHORT $LN8@Image_Resa
$LN7@Image_Resa:

; 803  : 		else
; 804  : 		{
; 805  : 			if( yi != oldy )

	mov	eax, DWORD PTR _yi$[ebp]
	cmp	eax, DWORD PTR _oldy$[ebp]
	je	SHORT $LN14@Image_Resa

; 806  : 			{
; 807  : 				inrow = (byte *)indata + inwidth4 * yi;

	mov	eax, DWORD PTR _inwidth4$[ebp]
	imul	eax, DWORD PTR _yi$[ebp]
	add	eax, DWORD PTR _indata$[ebp]
	mov	DWORD PTR _inrow$[ebp], eax

; 808  : 				if( yi == oldy + 1 ) memcpy( resamplerow1, resamplerow2, outwidth4 );

	mov	eax, DWORD PTR _oldy$[ebp]
	add	eax, 1
	cmp	DWORD PTR _yi$[ebp], eax
	jne	SHORT $LN15@Image_Resa
	mov	eax, DWORD PTR _outwidth4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@Image_Resa
$LN15@Image_Resa:

; 809  : 				else Image_Resample32LerpLine( inrow, resamplerow1, inwidth, outwidth);

	mov	eax, DWORD PTR _outwidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _resamplerow1$[ebp]
	push	edx
	mov	eax, DWORD PTR _inrow$[ebp]
	push	eax
	call	_Image_Resample32LerpLine
	add	esp, 16					; 00000010H
$LN16@Image_Resa:

; 810  : 				oldy = yi;

	mov	eax, DWORD PTR _yi$[ebp]
	mov	DWORD PTR _oldy$[ebp], eax
$LN14@Image_Resa:

; 811  : 			}
; 812  : 
; 813  : 			memcpy( out, resamplerow1, outwidth4 );

	mov	eax, DWORD PTR _outwidth4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@Image_Resa:

; 814  : 		}
; 815  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 816  : 
; 817  : 	Mem_Free( resamplerow1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Resample32Lerp@@9@9
	add	eax, 104				; 00000068H
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _resamplerow1$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32Lerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample24LerpLine
_TEXT	SEGMENT
_lerp$ = -28						; size = 4
_endx$ = -24						; size = 4
_fstep$ = -20						; size = 4
_f$ = -16						; size = 4
_oldx$ = -12						; size = 4
_xi$ = -8						; size = 4
_j$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_inwidth$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_Image_Resample24LerpLine PROC				; COMDAT

; 680  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 681  : 	int	j, xi, oldx = 0, f, fstep, endx, lerp;

	mov	DWORD PTR _oldx$[ebp], 0

; 682  : 
; 683  : 	fstep = (int)(inwidth * 65536.0f / outwidth);

	cvtsi2ss xmm0, DWORD PTR _inwidth$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outwidth$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 684  : 	endx = (inwidth-1);

	mov	eax, DWORD PTR _inwidth$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endx$[ebp], eax

; 685  : 
; 686  : 	for( j = 0, f = 0; j < outwidth; j++, f += fstep )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], ecx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _outwidth$[ebp]
	jge	$LN3@Image_Resa

; 687  : 	{
; 688  : 		xi = f>>16;

	mov	eax, DWORD PTR _f$[ebp]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _xi$[ebp], eax

; 689  : 
; 690  : 		if( xi != oldx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _oldx$[ebp]
	je	SHORT $LN5@Image_Resa

; 691  : 		{
; 692  : 			in += (xi - oldx) * 3;

	mov	eax, DWORD PTR _xi$[ebp]
	sub	eax, DWORD PTR _oldx$[ebp]
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 693  : 			oldx = xi;

	mov	eax, DWORD PTR _xi$[ebp]
	mov	DWORD PTR _oldx$[ebp], eax
$LN5@Image_Resa:

; 694  : 		}
; 695  : 
; 696  : 		if( xi < endx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _endx$[ebp]
	jge	$LN6@Image_Resa

; 697  : 		{
; 698  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 699  : 			*out++ = (byte)((((in[3] - in[0]) * lerp)>>16) + in[0]);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	sub	eax, edx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 700  : 			*out++ = (byte)((((in[4] - in[1]) * lerp)>>16) + in[1]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 701  : 			*out++ = (byte)((((in[5] - in[2]) * lerp)>>16) + in[2]);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 702  : 		}

	jmp	SHORT $LN7@Image_Resa
$LN6@Image_Resa:

; 703  : 		else // last pixel of the line has no pixel to lerp to
; 704  : 		{
; 705  : 			*out++ = in[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 706  : 			*out++ = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 707  : 			*out++ = in[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
$LN7@Image_Resa:

; 708  : 		}
; 709  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 710  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample24LerpLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Resample32LerpLine
_TEXT	SEGMENT
_lerp$ = -28						; size = 4
_endx$ = -24						; size = 4
_fstep$ = -20						; size = 4
_f$ = -16						; size = 4
_oldx$ = -12						; size = 4
_xi$ = -8						; size = 4
_j$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_inwidth$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_Image_Resample32LerpLine PROC				; COMDAT

; 647  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 648  : 	int	j, xi, oldx = 0, f, fstep, endx, lerp;

	mov	DWORD PTR _oldx$[ebp], 0

; 649  : 
; 650  : 	fstep = (int)(inwidth * 65536.0f / outwidth);

	cvtsi2ss xmm0, DWORD PTR _inwidth$[ebp]
	mulss	xmm0, DWORD PTR __real@47800000
	cvtsi2ss xmm1, DWORD PTR _outwidth$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _fstep$[ebp], eax

; 651  : 	endx = (inwidth-1);

	mov	eax, DWORD PTR _inwidth$[ebp]
	sub	eax, 1
	mov	DWORD PTR _endx$[ebp], eax

; 652  : 
; 653  : 	for( j = 0, f = 0; j < outwidth; j++, f += fstep )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _f$[ebp], 0
	jmp	SHORT $LN4@Image_Resa
$LN2@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, DWORD PTR _fstep$[ebp]
	mov	DWORD PTR _f$[ebp], ecx
$LN4@Image_Resa:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _outwidth$[ebp]
	jge	$LN3@Image_Resa

; 654  : 	{
; 655  : 		xi = f>>16;

	mov	eax, DWORD PTR _f$[ebp]
	sar	eax, 16					; 00000010H
	mov	DWORD PTR _xi$[ebp], eax

; 656  : 		if( xi != oldx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _oldx$[ebp]
	je	SHORT $LN5@Image_Resa

; 657  : 		{
; 658  : 			in += (xi - oldx) * 4;

	mov	eax, DWORD PTR _xi$[ebp]
	sub	eax, DWORD PTR _oldx$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _in$[ebp], edx

; 659  : 			oldx = xi;

	mov	eax, DWORD PTR _xi$[ebp]
	mov	DWORD PTR _oldx$[ebp], eax
$LN5@Image_Resa:

; 660  : 		}
; 661  : 		if( xi < endx )

	mov	eax, DWORD PTR _xi$[ebp]
	cmp	eax, DWORD PTR _endx$[ebp]
	jge	$LN6@Image_Resa

; 662  : 		{
; 663  : 			lerp = f & 0xFFFF;

	mov	eax, DWORD PTR _f$[ebp]
	and	eax, 65535				; 0000ffffH
	mov	DWORD PTR _lerp$[ebp], eax

; 664  : 			*out++ = (byte)((((in[4] - in[0]) * lerp)>>16) + in[0]);

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	sub	edx, ecx
	imul	edx, DWORD PTR _lerp$[ebp]
	sar	edx, 16					; 00000010H
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 665  : 			*out++ = (byte)((((in[5] - in[1]) * lerp)>>16) + in[1]);

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	edx, 1
	shl	edx, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 666  : 			*out++ = (byte)((((in[6] - in[2]) * lerp)>>16) + in[2]);

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	sub	eax, ecx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	edx, 1
	shl	edx, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 667  : 			*out++ = (byte)((((in[7] - in[3]) * lerp)>>16) + in[3]);

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	sub	eax, edx
	imul	eax, DWORD PTR _lerp$[ebp]
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 668  : 		}

	jmp	SHORT $LN7@Image_Resa
$LN6@Image_Resa:

; 669  : 		else // last pixel of the line has no pixel to lerp to
; 670  : 		{
; 671  : 			*out++ = in[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 672  : 			*out++ = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 673  : 			*out++ = in[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 674  : 			*out++ = in[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN7@Image_Resa:

; 675  : 		}
; 676  : 	}

	jmp	$LN2@Image_Resa
$LN3@Image_Resa:

; 677  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Resample32LerpLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ConvertPalTo24bit
_TEXT	SEGMENT
_i$ = -16						; size = 4
_converted$ = -12					; size = 4
_pal24$ = -8						; size = 4
_pal32$ = -4						; size = 4
_pic$ = 8						; size = 4
_Image_ConvertPalTo24bit PROC				; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 326  : 	byte	*pal32, *pal24;
; 327  : 	byte	*converted;
; 328  : 	int	i;
; 329  : 
; 330  : 	if( pic->type == PF_INDEXED_24 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN5@Image_Conv

; 331  : 		return; // does nothing

	jmp	$LN1@Image_Conv
$LN5@Image_Conv:

; 332  : 
; 333  : 	pal24 = converted = Mem_Malloc( host.imagepool, 768 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ConvertPalTo24bit@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	768					; 00000300H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _converted$[ebp], eax
	mov	edx, DWORD PTR _converted$[ebp]
	mov	DWORD PTR _pal24$[ebp], edx

; 334  : 	pal32 = pic->palette;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pal32$[ebp], ecx

; 335  : 
; 336  : 	for( i = 0; i < 256; i++, pal24 += 3, pal32 += 4 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Conv
$LN2@Image_Conv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pal24$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pal24$[ebp], ecx
	mov	edx, DWORD PTR _pal32$[ebp]
	add	edx, 4
	mov	DWORD PTR _pal32$[ebp], edx
$LN4@Image_Conv:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Image_Conv

; 337  : 	{
; 338  : 		pal24[0] = pal32[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl

; 339  : 		pal24[1] = pal32[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 340  : 		pal24[2] = pal32[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pal24$[ebp]
	mov	esi, DWORD PTR _pal32$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al

; 341  : 	}

	jmp	SHORT $LN2@Image_Conv
$LN3@Image_Conv:

; 342  : 
; 343  : 	Mem_Free( pic->palette );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ConvertPalTo24bit@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 344  : 	pic->palette = converted;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _converted$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 345  : 	pic->type = PF_INDEXED_24;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN1@Image_Conv:

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ConvertPalTo24bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_SetPalette
_TEXT	SEGMENT
tv64 = -76						; size = 4
_i$ = -8						; size = 4
_rgba$ = -4						; size = 4
_pal$ = 8						; size = 4
_d_table$ = 12						; size = 4
_Image_SetPalette PROC					; COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 274  : 	byte	rgba[4];
; 275  : 	int	i;	
; 276  : 
; 277  : 	// setup palette
; 278  : 	switch( image.d_rendermode )

	mov	eax, DWORD PTR _image+68
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	ja	$LN1@Image_SetP
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN21@Image_SetP[ecx*4]
$LN16@Image_SetP:

; 279  : 	{
; 280  : 	case LUMP_NORMAL:
; 281  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Image_SetP
$LN4@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN5@Image_SetP

; 282  : 		{
; 283  : 			rgba[0] = pal[i*3+0];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR _rgba$[ebp+edx], al

; 284  : 			rgba[1] = pal[i*3+1];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax+1]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 285  : 			rgba[2] = pal[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax+2]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 286  : 			rgba[3] = 0xFF;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _rgba$[ebp+ecx], 255		; 000000ffH

; 287  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 288  : 		}

	jmp	SHORT $LN4@Image_SetP
$LN5@Image_SetP:

; 289  : 		break;

	jmp	$LN1@Image_SetP
$LN17@Image_SetP:

; 290  : 	case LUMP_GRADIENT:
; 291  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Image_SetP
$LN7@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN8@Image_SetP

; 292  : 		{
; 293  : 			rgba[0] = pal[765];

	mov	eax, 1
	imul	ecx, eax, 765
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 294  : 			rgba[1] = pal[766];

	mov	eax, 1
	imul	ecx, eax, 766
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _rgba$[ebp+edx], cl

; 295  : 			rgba[2] = pal[767];

	mov	eax, 1
	imul	ecx, eax, 767
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _rgba$[ebp+edx], cl

; 296  : 			rgba[3] = i;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR _rgba$[ebp+ecx], dl

; 297  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 298  : 		}

	jmp	$LN7@Image_SetP
$LN8@Image_SetP:

; 299  : 		break;

	jmp	$LN1@Image_SetP
$LN18@Image_SetP:

; 300  : 	case LUMP_MASKED:
; 301  : 		for( i = 0; i < 255; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_SetP
$LN10@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@Image_SetP

; 302  : 		{
; 303  : 			rgba[0] = pal[i*3+0];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR _rgba$[ebp+edx], al

; 304  : 			rgba[1] = pal[i*3+1];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax+1]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 305  : 			rgba[2] = pal[i*3+2];

	imul	eax, DWORD PTR _i$[ebp], 3
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pal$[ebp]
	mov	al, BYTE PTR [edx+eax+2]
	mov	BYTE PTR _rgba$[ebp+ecx], al

; 306  : 			rgba[3] = 0xFF;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _rgba$[ebp+ecx], 255		; 000000ffH

; 307  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 308  : 		}

	jmp	SHORT $LN10@Image_SetP
$LN11@Image_SetP:

; 309  : 		d_table[255] = 0;

	mov	eax, 4
	imul	ecx, eax, 255
	mov	edx, DWORD PTR _d_table$[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 310  : 		break;

	jmp	SHORT $LN1@Image_SetP
$LN19@Image_SetP:

; 311  : 	case LUMP_EXTENDED:
; 312  : 		for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@Image_SetP
$LN13@Image_SetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@Image_SetP:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@Image_SetP

; 313  : 		{
; 314  : 			rgba[0] = pal[i*4+0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [eax+edx*4]
	mov	BYTE PTR _rgba$[ebp+ecx], dl

; 315  : 			rgba[1] = pal[i*4+1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+1]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 316  : 			rgba[2] = pal[i*4+2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pal$[ebp]
	mov	cl, BYTE PTR [edx+ecx*4+2]
	mov	BYTE PTR _rgba$[ebp+eax], cl

; 317  : 			rgba[3] = pal[i*4+3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pal$[ebp]
	mov	dl, BYTE PTR [eax+edx*4+3]
	mov	BYTE PTR _rgba$[ebp+ecx], dl

; 318  : 			d_table[i] = *(uint *)rgba;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _d_table$[ebp]
	mov	edx, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 319  : 		}

	jmp	SHORT $LN13@Image_SetP
$LN1@Image_SetP:

; 320  : 		break;	
; 321  : 	}
; 322  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@Image_SetP:
	DD	$LN16@Image_SetP
	DD	$LN18@Image_SetP
	DD	$LN17@Image_SetP
	DD	$LN19@Image_SetP
_Image_SetPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CheckFlag
_TEXT	SEGMENT
_bit$ = 8						; size = 4
_Image_CheckFlag PROC					; COMDAT

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 197  : 	if( FBitSet( image.force_flags, bit ))

	mov	eax, DWORD PTR _image+92
	and	eax, DWORD PTR _bit$[ebp]
	je	SHORT $LN2@Image_Chec

; 198  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN2@Image_Chec:

; 199  : 
; 200  : 	if( FBitSet( image.cmd_flags, bit ))

	mov	eax, DWORD PTR _image+88
	and	eax, DWORD PTR _bit$[ebp]
	je	SHORT $LN3@Image_Chec

; 201  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN3@Image_Chec:

; 202  : 
; 203  : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_LumpValidSize
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Image_LumpValidSize PROC				; COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 248  : 	if( image.width > LUMP_MAXWIDTH || image.height > LUMP_MAXHEIGHT || image.width <= 0 || image.height <= 0 )

	movzx	eax, WORD PTR _image+8
	cmp	eax, 1024				; 00000400H
	jg	SHORT $LN3@Image_Lump
	movzx	eax, WORD PTR _image+10
	cmp	eax, 1024				; 00000400H
	jg	SHORT $LN3@Image_Lump
	movzx	eax, WORD PTR _image+8
	test	eax, eax
	jle	SHORT $LN3@Image_Lump
	movzx	eax, WORD PTR _image+10
	test	eax, eax
	jg	SHORT $LN2@Image_Lump
$LN3@Image_Lump:

; 249  : 	{
; 250  : 		Con_DPrintf( S_ERROR "Image: (%s) dims out of range [%dx%d]\n", name, image.width,image.height );

	movzx	eax, WORD PTR _image+10
	push	eax
	movzx	ecx, WORD PTR _image+8
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@NIJDPLBA@?$FO1Error?3?$FO7?5Image?3?5?$CI?$CFs?$CJ?5dims?5out@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 251  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Lump
$LN2@Image_Lump:

; 252  : 	}
; 253  : 	return true;

	mov	eax, 1
$LN1@Image_Lump:

; 254  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_LumpValidSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ValidSize
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Image_ValidSize PROC					; COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 238  : 	if( image.width > IMAGE_MAXWIDTH || image.height > IMAGE_MAXHEIGHT || image.width <= 0 || image.height <= 0 )

	movzx	eax, WORD PTR _image+8
	cmp	eax, 8192				; 00002000H
	jg	SHORT $LN3@Image_Vali
	movzx	eax, WORD PTR _image+10
	cmp	eax, 8192				; 00002000H
	jg	SHORT $LN3@Image_Vali
	movzx	eax, WORD PTR _image+8
	test	eax, eax
	jle	SHORT $LN3@Image_Vali
	movzx	eax, WORD PTR _image+10
	test	eax, eax
	jg	SHORT $LN2@Image_Vali
$LN3@Image_Vali:

; 239  : 	{
; 240  : 		Con_DPrintf( S_ERROR "Image: (%s) dims out of range [%dx%d]\n", name, image.width, image.height );

	movzx	eax, WORD PTR _image+10
	push	eax
	movzx	ecx, WORD PTR _image+8
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0DC@NIJDPLBA@?$FO1Error?3?$FO7?5Image?3?5?$CI?$CFs?$CJ?5dims?5out@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 241  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_Vali
$LN2@Image_Vali:

; 242  : 	}
; 243  : 	return true;

	mov	eax, 1
$LN1@Image_Vali:

; 244  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ValidSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CopyParms
_TEXT	SEGMENT
_src$ = 8						; size = 4
_Image_CopyParms PROC					; COMDAT

; 557  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 558  : 	Image_Reset();

	call	_Image_Reset

; 559  : 
; 560  : 	image.width = src->width;

	mov	eax, DWORD PTR _src$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _image+8, cx

; 561  : 	image.height = src->height;

	mov	eax, DWORD PTR _src$[ebp]
	mov	cx, WORD PTR [eax+2]
	mov	WORD PTR _image+10, cx

; 562  : 	image.type = src->type;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _image+20, ecx

; 563  : 	image.flags = src->flags;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _image+24, ecx

; 564  : 	image.size = src->size;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _image+28, ecx

; 565  : 	image.palette = src->palette;	// may be NULL

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _image+72, ecx

; 566  : 
; 567  : 	memcpy( image.fogParams, src->fogParams, sizeof( image.fogParams ));

	push	4
	mov	eax, DWORD PTR _src$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET _image+76
	call	_memcpy
	add	esp, 12					; 0000000cH

; 568  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CopyParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Copy
_TEXT	SEGMENT
_out$ = -4						; size = 4
_size$ = 8						; size = 4
_Image_Copy PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 172  : 	byte	*out;
; 173  : 
; 174  : 	out = Mem_Malloc( host.imagepool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Copy@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 175  : 	memcpy( out, image.tempbuffer, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 176  : 
; 177  : 	return out; 

	mov	eax, DWORD PTR _out$[ebp]

; 178  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_GetPaletteHL
_TEXT	SEGMENT
_Image_GetPaletteHL PROC				; COMDAT

; 391  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 392  : 	if( !hlpalette_init )

	cmp	DWORD PTR _hlpalette_init, 0
	jne	SHORT $LN2@Image_GetP

; 393  : 	{
; 394  : 		image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 395  : 		Image_SetPalette( palette_hl, d_8toHLtable );

	push	OFFSET _d_8toHLtable
	push	OFFSET _palette_hl
	call	_Image_SetPalette
	add	esp, 8

; 396  : 		hlpalette_init = true;

	mov	DWORD PTR _hlpalette_init, 1
$LN2@Image_GetP:

; 397  : 	}
; 398  : 
; 399  : 	image.d_rendermode = LUMP_HALFLIFE;

	mov	DWORD PTR _image+68, 4

; 400  : 	image.d_currentpal = d_8toHLtable;

	mov	DWORD PTR _image+64, OFFSET _d_8toHLtable

; 401  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_GetPaletteHL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_GetPaletteQ1
_TEXT	SEGMENT
_Image_GetPaletteQ1 PROC				; COMDAT

; 377  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 378  : 	if( !q1palette_init )

	cmp	DWORD PTR _q1palette_init, 0
	jne	SHORT $LN2@Image_GetP

; 379  : 	{
; 380  : 		image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 381  : 		Image_SetPalette( palette_q1, d_8toQ1table );

	push	OFFSET _d_8toQ1table
	push	OFFSET _palette_q1
	call	_Image_SetPalette
	add	esp, 8

; 382  : 		d_8toQ1table[255] = 0; // 255 is transparent

	mov	eax, 4
	imul	ecx, eax, 255
	mov	DWORD PTR _d_8toQ1table[ecx], 0

; 383  : 		q1palette_init = true;

	mov	DWORD PTR _q1palette_init, 1
$LN2@Image_GetP:

; 384  : 	}
; 385  : 
; 386  : 	image.d_rendermode = LUMP_QUAKE1;

	mov	DWORD PTR _image+68, 5

; 387  : 	image.d_currentpal = d_8toQ1table;

	mov	DWORD PTR _image+64, OFFSET _d_8toQ1table

; 388  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_GetPaletteQ1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CopyPalette32bit
_TEXT	SEGMENT
_Image_CopyPalette32bit PROC				; COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 350  : 	if( image.palette ) return; // already created ?

	cmp	DWORD PTR _image+72, 0
	je	SHORT $LN2@Image_Copy
	jmp	SHORT $LN1@Image_Copy
$LN2@Image_Copy:

; 351  : 	image.palette = Mem_Malloc( host.imagepool, 1024 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_CopyPalette32bit@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+72, eax

; 352  : 	memcpy( image.palette, image.d_currentpal, 1024 );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _image+64
	push	eax
	mov	ecx, DWORD PTR _image+72
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Image_Copy:

; 353  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CopyPalette32bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ComparePalette
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_Image_ComparePalette PROC				; COMDAT

; 262  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 263  : 	if( pal == NULL )

	cmp	DWORD PTR _pal$[ebp], 0
	jne	SHORT $LN2@Image_Comp

; 264  : 		return PAL_INVALID;

	or	eax, -1
	jmp	SHORT $LN1@Image_Comp
	jmp	SHORT $LN3@Image_Comp
$LN2@Image_Comp:

; 265  : 	else if( !memcmp( palette_q1, pal, 765 )) // last color was changed

	push	765					; 000002fdH
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	push	OFFSET _palette_q1
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@Image_Comp

; 266  : 		return PAL_QUAKE1;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Comp
	jmp	SHORT $LN3@Image_Comp
$LN4@Image_Comp:

; 267  : 	else if( !memcmp( palette_hl, pal, 765 ))

	push	765					; 000002fdH
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	push	OFFSET _palette_hl
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Image_Comp

; 268  : 		return PAL_HALFLIFE;

	mov	eax, 2
	jmp	SHORT $LN1@Image_Comp
$LN3@Image_Comp:

; 269  : 	return PAL_CUSTOM;		

	xor	eax, eax
$LN1@Image_Comp:

; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ComparePalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_GetPaletteBMP
_TEXT	SEGMENT
_pal$ = 8						; size = 4
_Image_GetPaletteBMP PROC				; COMDAT

; 404  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 405  : 	image.d_rendermode = LUMP_EXTENDED;

	mov	DWORD PTR _image+68, 3

; 406  : 
; 407  : 	if( pal )

	cmp	DWORD PTR _pal$[ebp], 0
	je	SHORT $LN1@Image_GetP

; 408  : 	{
; 409  : 		Image_SetPalette( pal, d_8to24table );

	push	OFFSET _d_8to24table
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_SetPalette
	add	esp, 8

; 410  : 		image.d_currentpal = d_8to24table;

	mov	DWORD PTR _image+64, OFFSET _d_8to24table
$LN1@Image_GetP:

; 411  : 	}
; 412  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_GetPaletteBMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_GetPaletteLMP
_TEXT	SEGMENT
tv67 = -68						; size = 4
_pal$ = 8						; size = 4
_rendermode$ = 12					; size = 4
_Image_GetPaletteLMP PROC				; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 416  : 	image.d_rendermode = rendermode;

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR _image+68, eax

; 417  : 
; 418  : 	if( pal )

	cmp	DWORD PTR _pal$[ebp], 0
	je	SHORT $LN4@Image_GetP

; 419  : 	{
; 420  : 		Image_SetPalette( pal, d_8to24table );

	push	OFFSET _d_8to24table
	mov	eax, DWORD PTR _pal$[ebp]
	push	eax
	call	_Image_SetPalette
	add	esp, 8

; 421  : 		image.d_currentpal = d_8to24table;

	mov	DWORD PTR _image+64, OFFSET _d_8to24table

; 422  : 	}

	jmp	SHORT $LN1@Image_GetP
$LN4@Image_GetP:

; 423  : 	else
; 424  : 	{
; 425  : 		switch( rendermode )

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 4
	je	SHORT $LN7@Image_GetP
	cmp	DWORD PTR tv67[ebp], 5
	je	SHORT $LN6@Image_GetP
	jmp	SHORT $LN8@Image_GetP
$LN6@Image_GetP:

; 426  : 		{
; 427  : 		case LUMP_QUAKE1:
; 428  : 			Image_GetPaletteQ1();

	call	_Image_GetPaletteQ1

; 429  : 			break;

	jmp	SHORT $LN1@Image_GetP
$LN7@Image_GetP:

; 430  : 		case LUMP_HALFLIFE:
; 431  : 			Image_GetPaletteHL();

	call	_Image_GetPaletteHL

; 432  : 			break;

	jmp	SHORT $LN1@Image_GetP
$LN8@Image_GetP:

; 433  : 		default:
; 434  : 			// defaulting to half-life palette
; 435  : 			Image_GetPaletteHL();

	call	_Image_GetPaletteHL
$LN1@Image_GetP:

; 436  : 			break;
; 437  : 		}
; 438  : 	}
; 439  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_GetPaletteLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_AddIndexedImageToPack
_TEXT	SEGMENT
_expand_to_rgba$ = -8					; size = 4
_mipsize$ = -4						; size = 4
_in$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_Image_AddIndexedImageToPack PROC			; COMDAT

; 1191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1192 : 	int	mipsize = width * height;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _mipsize$[ebp], eax

; 1193 : 	qboolean	expand_to_rgba = true;

	mov	DWORD PTR _expand_to_rgba$[ebp], 1

; 1194 : 
; 1195 : 	if( Image_CheckFlag( IL_KEEP_8BIT ))

	push	2
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Image_AddI

; 1196 : 		expand_to_rgba = false;

	mov	DWORD PTR _expand_to_rgba$[ebp], 0
	jmp	SHORT $LN3@Image_AddI
$LN2@Image_AddI:

; 1197 : 	else if( FBitSet( image.flags, IMAGE_HAS_LUMA|IMAGE_QUAKESKY ))

	mov	eax, DWORD PTR _image+24
	and	eax, 80					; 00000050H
	je	SHORT $LN3@Image_AddI

; 1198 : 		expand_to_rgba = false;

	mov	DWORD PTR _expand_to_rgba$[ebp], 0
$LN3@Image_AddI:

; 1199 : 
; 1200 : 	image.size = mipsize;

	mov	eax, DWORD PTR _mipsize$[ebp]
	mov	DWORD PTR _image+28, eax

; 1201 : 
; 1202 : 	if( expand_to_rgba ) image.size *= 4;

	cmp	DWORD PTR _expand_to_rgba$[ebp], 0
	je	SHORT $LN5@Image_AddI
	mov	eax, DWORD PTR _image+28
	shl	eax, 2
	mov	DWORD PTR _image+28, eax
	jmp	SHORT $LN6@Image_AddI
$LN5@Image_AddI:

; 1203 : 	else Image_CopyPalette32bit(); 

	call	_Image_CopyPalette32bit
$LN6@Image_AddI:

; 1204 : 
; 1205 : 	// reallocate image buffer
; 1206 : 	image.rgba = Mem_Malloc( host.imagepool, image.size );	

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_AddIndexedImageToPack@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 1207 : 	if( !expand_to_rgba ) memcpy( image.rgba, in, image.size );

	cmp	DWORD PTR _expand_to_rgba$[ebp], 0
	jne	SHORT $LN7@Image_AddI
	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+40
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@Image_AddI
$LN7@Image_AddI:

; 1208 : 	else if( !Image_Copy8bitRGBA( in, image.rgba, mipsize ))

	mov	eax, DWORD PTR _mipsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image+40
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_Image_Copy8bitRGBA
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@Image_AddI

; 1209 : 		return false; // probably pallette not installed

	xor	eax, eax
	jmp	SHORT $LN1@Image_AddI
$LN8@Image_AddI:

; 1210 : 
; 1211 : 	return true;

	mov	eax, 1
$LN1@Image_AddI:

; 1212 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_AddIndexedImageToPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Copy8bitRGBA
_TEXT	SEGMENT
tv82 = -84						; size = 4
_i$ = -16						; size = 4
_col$ = -12						; size = 4
_fin$ = -8						; size = 4
_iout$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_pixels$ = 16						; size = 4
_Image_Copy8bitRGBA PROC				; COMDAT

; 578  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 579  : 	int	*iout = (int *)out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _iout$[ebp], eax

; 580  : 	byte	*fin = (byte *)in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _fin$[ebp], eax

; 581  : 	byte	*col;
; 582  : 	int	i;
; 583  : 
; 584  : 	if( !in || !image.d_currentpal )

	cmp	DWORD PTR _in$[ebp], 0
	je	SHORT $LN11@Image_Copy
	cmp	DWORD PTR _image+64, 0
	jne	SHORT $LN10@Image_Copy
$LN11@Image_Copy:

; 585  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Copy
$LN10@Image_Copy:

; 586  : 
; 587  : 	// this is a base image with luma - clear luma pixels
; 588  : 	if( image.flags & IMAGE_HAS_LUMA )

	mov	eax, DWORD PTR _image+24
	and	eax, 16					; 00000010H
	je	SHORT $LN12@Image_Copy

; 589  : 	{
; 590  : 		for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Copy
$LN2@Image_Copy:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Copy:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN12@Image_Copy

; 591  : 			fin[i] = fin[i] < 224 ? fin[i] : 0;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 224				; 000000e0H
	jge	SHORT $LN19@Image_Copy
	mov	edx, DWORD PTR _fin$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN20@Image_Copy
$LN19@Image_Copy:
	mov	DWORD PTR tv82[ebp], 0
$LN20@Image_Copy:
	mov	ecx, DWORD PTR _fin$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR tv82[ebp]
	mov	BYTE PTR [ecx], dl
	jmp	SHORT $LN2@Image_Copy
$LN12@Image_Copy:

; 592  : 	}
; 593  : 
; 594  : 	// check for color
; 595  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Copy
$LN5@Image_Copy:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Copy:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN8@Image_Copy

; 596  : 	{
; 597  : 		col = (byte *)&image.d_currentpal[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _image+64
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _col$[ebp], edx

; 598  : 		if( col[0] != col[1] || col[1] != col[2] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _col$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _col$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	cmp	eax, ecx
	jne	SHORT $LN14@Image_Copy
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _col$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	cmp	edx, eax
	je	SHORT $LN13@Image_Copy
$LN14@Image_Copy:

; 599  : 		{
; 600  : 			image.flags |= IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax

; 601  : 			break;

	jmp	SHORT $LN8@Image_Copy
$LN13@Image_Copy:

; 602  : 		}
; 603  : 	}

	jmp	SHORT $LN5@Image_Copy
$LN8@Image_Copy:

; 604  : 
; 605  : 	while( pixels >= 8 )

	cmp	DWORD PTR _pixels$[ebp], 8
	jl	$LN9@Image_Copy

; 606  : 	{
; 607  : 		iout[0] = image.d_currentpal[in[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 608  : 		iout[1] = image.d_currentpal[in[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 609  : 		iout[2] = image.d_currentpal[in[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 610  : 		iout[3] = image.d_currentpal[in[3]];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 611  : 		iout[4] = image.d_currentpal[in[4]];

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 612  : 		iout[5] = image.d_currentpal[in[5]];

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 613  : 		iout[6] = image.d_currentpal[in[6]];

	mov	eax, 1
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 614  : 		iout[7] = image.d_currentpal[in[7]];

	mov	eax, 1
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 615  : 
; 616  : 		in += 8;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 8
	mov	DWORD PTR _in$[ebp], eax

; 617  : 		iout += 8;

	mov	eax, DWORD PTR _iout$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _iout$[ebp], eax

; 618  : 		pixels -= 8;

	mov	eax, DWORD PTR _pixels$[ebp]
	sub	eax, 8
	mov	DWORD PTR _pixels$[ebp], eax

; 619  : 	}

	jmp	$LN8@Image_Copy
$LN9@Image_Copy:

; 620  : 
; 621  : 	if( pixels & 4 )

	mov	eax, DWORD PTR _pixels$[ebp]
	and	eax, 4
	je	$LN15@Image_Copy

; 622  : 	{
; 623  : 		iout[0] = image.d_currentpal[in[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 624  : 		iout[1] = image.d_currentpal[in[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 625  : 		iout[2] = image.d_currentpal[in[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 626  : 		iout[3] = image.d_currentpal[in[3]];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 627  : 		in += 4;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 4
	mov	DWORD PTR _in$[ebp], eax

; 628  : 		iout += 4;

	mov	eax, DWORD PTR _iout$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _iout$[ebp], eax
$LN15@Image_Copy:

; 629  : 	}
; 630  : 
; 631  : 	if( pixels & 2 )

	mov	eax, DWORD PTR _pixels$[ebp]
	and	eax, 2
	je	SHORT $LN16@Image_Copy

; 632  : 	{
; 633  : 		iout[0] = image.d_currentpal[in[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax

; 634  : 		iout[1] = image.d_currentpal[in[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 635  : 		in += 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax

; 636  : 		iout += 2;

	mov	eax, DWORD PTR _iout$[ebp]
	add	eax, 8
	mov	DWORD PTR _iout$[ebp], eax
$LN16@Image_Copy:

; 637  : 	}
; 638  : 
; 639  : 	if( pixels & 1 ) // last byte

	mov	eax, DWORD PTR _pixels$[ebp]
	and	eax, 1
	je	SHORT $LN17@Image_Copy

; 640  : 		iout[0] = image.d_currentpal[in[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _iout$[ebp]
	mov	esi, DWORD PTR _image+64
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx], eax
$LN17@Image_Copy:

; 641  : 	image.type = PF_RGBA_32;	// update image type;

	mov	DWORD PTR _image+20, 3

; 642  : 
; 643  : 	return true;

	mov	eax, 1
$LN1@Image_Copy:

; 644  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Copy8bitRGBA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_FlipInternal
_TEXT	SEGMENT
tv130 = -132						; size = 4
tv95 = -132						; size = 4
tv90 = -132						; size = 4
tv83 = -132						; size = 4
tv78 = -132						; size = 4
tv75 = -132						; size = 4
tv72 = -132						; size = 4
tv69 = -132						; size = 4
_out$ = -64						; size = 4
_line$ = -60						; size = 4
_p$ = -56						; size = 4
_col_ofs$ = -52						; size = 4
_row_ofs$ = -48						; size = 4
_col_inc$ = -44						; size = 4
_row_inc$ = -40						; size = 4
_flip_i$ = -36						; size = 4
_flip_y$ = -32						; size = 4
_flip_x$ = -28						; size = 4
_samples$ = -24						; size = 4
_height$ = -20						; size = 2
_width$ = -16						; size = 2
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_i$ = -4						; size = 4
_in$ = 8						; size = 4
_srcwidth$ = 12						; size = 4
_srcheight$ = 16					; size = 4
_type$ = 20						; size = 4
_flags$ = 24						; size = 4
_Image_FlipInternal PROC				; COMDAT

; 1100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 1101 : 	int	i, x, y;
; 1102 : 	word	width = *srcwidth;

	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _width$[ebp], cx

; 1103 : 	word	height = *srcheight; 

	mov	eax, DWORD PTR _srcheight$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _height$[ebp], cx

; 1104 : 	int	samples = PFDesc[type].bpp;

	imul	eax, DWORD PTR _type$[ebp], 28
	mov	ecx, DWORD PTR _PFDesc[eax+24]
	mov	DWORD PTR _samples$[ebp], ecx

; 1105 : 	qboolean	flip_x = FBitSet( flags, IMAGE_FLIP_X ) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN35@Image_Flip
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN36@Image_Flip
$LN35@Image_Flip:
	mov	DWORD PTR tv69[ebp], 0
$LN36@Image_Flip:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _flip_x$[ebp], ecx

; 1106 : 	qboolean	flip_y = FBitSet( flags, IMAGE_FLIP_Y ) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN37@Image_Flip
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN38@Image_Flip
$LN37@Image_Flip:
	mov	DWORD PTR tv72[ebp], 0
$LN38@Image_Flip:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _flip_y$[ebp], ecx

; 1107 : 	qboolean	flip_i = FBitSet( flags, IMAGE_ROT_90 ) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN39@Image_Flip
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN40@Image_Flip
$LN39@Image_Flip:
	mov	DWORD PTR tv75[ebp], 0
$LN40@Image_Flip:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _flip_i$[ebp], ecx

; 1108 : 	int	row_inc = ( flip_y ? -samples : samples ) * width;

	cmp	DWORD PTR _flip_y$[ebp], 0
	je	SHORT $LN41@Image_Flip
	mov	eax, DWORD PTR _samples$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN42@Image_Flip
$LN41@Image_Flip:
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN42@Image_Flip:
	movzx	edx, WORD PTR _width$[ebp]
	imul	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _row_inc$[ebp], edx

; 1109 : 	int	col_inc = ( flip_x ? -samples : samples );

	cmp	DWORD PTR _flip_x$[ebp], 0
	je	SHORT $LN43@Image_Flip
	mov	eax, DWORD PTR _samples$[ebp]
	neg	eax
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN44@Image_Flip
$LN43@Image_Flip:
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN44@Image_Flip:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _col_inc$[ebp], edx

; 1110 : 	int	row_ofs = ( flip_y ? ( height - 1 ) * width * samples : 0 );

	cmp	DWORD PTR _flip_y$[ebp], 0
	je	SHORT $LN45@Image_Flip
	movzx	eax, WORD PTR _height$[ebp]
	sub	eax, 1
	movzx	ecx, WORD PTR _width$[ebp]
	imul	eax, ecx
	imul	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN46@Image_Flip
$LN45@Image_Flip:
	mov	DWORD PTR tv90[ebp], 0
$LN46@Image_Flip:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _row_ofs$[ebp], edx

; 1111 : 	int	col_ofs = ( flip_x ? ( width - 1 ) * samples : 0 );

	cmp	DWORD PTR _flip_x$[ebp], 0
	je	SHORT $LN47@Image_Flip
	movzx	eax, WORD PTR _width$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN48@Image_Flip
$LN47@Image_Flip:
	mov	DWORD PTR tv95[ebp], 0
$LN48@Image_Flip:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _col_ofs$[ebp], ecx

; 1112 : 	const byte *p, *line;
; 1113 : 	byte	*out;
; 1114 : 
; 1115 : 	// nothing to process
; 1116 : 	if( !FBitSet( flags, IMAGE_FLIP_X|IMAGE_FLIP_Y|IMAGE_ROT_90 ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 458752				; 00070000H
	jne	SHORT $LN22@Image_Flip

; 1117 : 		return (byte *)in;

	mov	eax, DWORD PTR _in$[ebp]
	jmp	$LN1@Image_Flip
$LN22@Image_Flip:

; 1118 : 
; 1119 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv130[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 5
	ja	SHORT $LN29@Image_Flip
	mov	edx, DWORD PTR tv130[ebp]
	jmp	DWORD PTR $LN49@Image_Flip[edx*4]
$LN28@Image_Flip:

; 1120 : 	{
; 1121 : 	case PF_INDEXED_24:
; 1122 : 	case PF_INDEXED_32:
; 1123 : 	case PF_RGB_24:
; 1124 : 	case PF_BGR_24:
; 1125 : 	case PF_RGBA_32:
; 1126 : 	case PF_BGRA_32:
; 1127 : 		image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, width * height * samples );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_FlipInternal@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	movzx	ecx, WORD PTR _width$[ebp]
	movzx	edx, WORD PTR _height$[ebp]
	imul	ecx, edx
	imul	ecx, DWORD PTR _samples$[ebp]
	push	ecx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1128 : 		break;

	jmp	SHORT $LN2@Image_Flip
$LN29@Image_Flip:

; 1129 : 	default:
; 1130 : 		return (byte *)in;	

	mov	eax, DWORD PTR _in$[ebp]
	jmp	$LN1@Image_Flip
$LN2@Image_Flip:

; 1131 : 	}
; 1132 : 
; 1133 : 	out = image.tempbuffer;

	mov	eax, DWORD PTR _image+84
	mov	DWORD PTR _out$[ebp], eax

; 1134 : 
; 1135 : 	if( flip_i )

	cmp	DWORD PTR _flip_i$[ebp], 0
	je	$LN30@Image_Flip

; 1136 : 	{
; 1137 : 		for( x = 0, line = in + col_ofs; x < width; x++, line += col_inc )

	mov	DWORD PTR _x$[ebp], 0
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _col_ofs$[ebp]
	mov	DWORD PTR _line$[ebp], eax
	jmp	SHORT $LN6@Image_Flip
$LN4@Image_Flip:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, DWORD PTR _col_inc$[ebp]
	mov	DWORD PTR _line$[ebp], ecx
$LN6@Image_Flip:
	movzx	eax, WORD PTR _width$[ebp]
	cmp	DWORD PTR _x$[ebp], eax
	jge	SHORT $LN5@Image_Flip

; 1138 : 			for( y = 0, p = line + row_ofs; y < height; y++, p += row_inc, out += samples )

	mov	DWORD PTR _y$[ebp], 0
	mov	eax, DWORD PTR _line$[ebp]
	add	eax, DWORD PTR _row_ofs$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN9@Image_Flip
$LN7@Image_Flip:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _row_inc$[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _out$[ebp], edx
$LN9@Image_Flip:
	movzx	eax, WORD PTR _height$[ebp]
	cmp	DWORD PTR _y$[ebp], eax
	jge	SHORT $LN8@Image_Flip

; 1139 : 				for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Image_Flip
$LN10@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jge	SHORT $LN11@Image_Flip

; 1140 : 					out[i] = p[i];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN10@Image_Flip
$LN11@Image_Flip:
	jmp	SHORT $LN7@Image_Flip
$LN8@Image_Flip:
	jmp	$LN4@Image_Flip
$LN5@Image_Flip:

; 1141 : 	}

	jmp	$LN31@Image_Flip
$LN30@Image_Flip:

; 1142 : 	else
; 1143 : 	{
; 1144 : 		for( y = 0, line = in + row_ofs; y < height; y++, line += row_inc )

	mov	DWORD PTR _y$[ebp], 0
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row_ofs$[ebp]
	mov	DWORD PTR _line$[ebp], eax
	jmp	SHORT $LN15@Image_Flip
$LN13@Image_Flip:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _line$[ebp]
	add	ecx, DWORD PTR _row_inc$[ebp]
	mov	DWORD PTR _line$[ebp], ecx
$LN15@Image_Flip:
	movzx	eax, WORD PTR _height$[ebp]
	cmp	DWORD PTR _y$[ebp], eax
	jge	SHORT $LN31@Image_Flip

; 1145 : 			for( x = 0, p = line + col_ofs; x < width; x++, p += col_inc, out += samples )

	mov	DWORD PTR _x$[ebp], 0
	mov	eax, DWORD PTR _line$[ebp]
	add	eax, DWORD PTR _col_ofs$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN18@Image_Flip
$LN16@Image_Flip:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _col_inc$[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _out$[ebp], edx
$LN18@Image_Flip:
	movzx	eax, WORD PTR _width$[ebp]
	cmp	DWORD PTR _x$[ebp], eax
	jge	SHORT $LN17@Image_Flip

; 1146 : 				for( i = 0; i < samples; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@Image_Flip
$LN19@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN21@Image_Flip:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jge	SHORT $LN20@Image_Flip

; 1147 : 					out[i] = p[i];

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN19@Image_Flip
$LN20@Image_Flip:
	jmp	SHORT $LN16@Image_Flip
$LN17@Image_Flip:
	jmp	$LN13@Image_Flip
$LN31@Image_Flip:

; 1148 : 	}
; 1149 : 
; 1150 : 	// update dims
; 1151 : 	if( FBitSet( flags, IMAGE_ROT_90 ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN32@Image_Flip

; 1152 : 	{
; 1153 : 		*srcwidth = height;

	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	cx, WORD PTR _height$[ebp]
	mov	WORD PTR [eax], cx

; 1154 : 		*srcheight = width;		

	mov	eax, DWORD PTR _srcheight$[ebp]
	mov	cx, WORD PTR _width$[ebp]
	mov	WORD PTR [eax], cx

; 1155 : 	}

	jmp	SHORT $LN33@Image_Flip
$LN32@Image_Flip:

; 1156 : 	else
; 1157 : 	{
; 1158 : 		*srcwidth = width;

	mov	eax, DWORD PTR _srcwidth$[ebp]
	mov	cx, WORD PTR _width$[ebp]
	mov	WORD PTR [eax], cx

; 1159 : 		*srcheight = height;	

	mov	eax, DWORD PTR _srcheight$[ebp]
	mov	cx, WORD PTR _height$[ebp]
	mov	WORD PTR [eax], cx
$LN33@Image_Flip:

; 1160 : 	}
; 1161 : 
; 1162 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Flip:

; 1163 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN49@Image_Flip:
	DD	$LN28@Image_Flip
	DD	$LN28@Image_Flip
	DD	$LN28@Image_Flip
	DD	$LN28@Image_Flip
	DD	$LN28@Image_Flip
	DD	$LN28@Image_Flip
_Image_FlipInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ResampleInternal
_TEXT	SEGMENT
tv68 = -72						; size = 4
_quality$ = -4						; size = 4
_indata$ = 8						; size = 4
_inwidth$ = 12						; size = 4
_inheight$ = 16						; size = 4
_outwidth$ = 20						; size = 4
_outheight$ = 24					; size = 4
_type$ = 28						; size = 4
_resampled$ = 32					; size = 4
_Image_ResampleInternal PROC				; COMDAT

; 1055 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1056 : 	qboolean	quality = Image_CheckFlag( IL_USE_LERPING );

	push	1
	call	_Image_CheckFlag
	add	esp, 4
	mov	DWORD PTR _quality$[ebp], eax

; 1057 : 
; 1058 : 	// nothing to resample ?
; 1059 : 	if( inwidth == outwidth && inheight == outheight )

	mov	eax, DWORD PTR _inwidth$[ebp]
	cmp	eax, DWORD PTR _outwidth$[ebp]
	jne	SHORT $LN4@Image_Resa
	mov	eax, DWORD PTR _inheight$[ebp]
	cmp	eax, DWORD PTR _outheight$[ebp]
	jne	SHORT $LN4@Image_Resa

; 1060 : 	{
; 1061 : 		*resampled = false;

	mov	eax, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [eax], 0

; 1062 : 		return (byte *)indata;

	mov	eax, DWORD PTR _indata$[ebp]
	jmp	$LN1@Image_Resa
$LN4@Image_Resa:

; 1063 : 	}
; 1064 : 
; 1065 : 	// alloc new buffer
; 1066 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 5
	ja	$LN15@Image_Resa
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN17@Image_Resa[edx*4]
$LN6@Image_Resa:

; 1067 : 	{
; 1068 : 	case PF_INDEXED_24:
; 1069 : 	case PF_INDEXED_32:
; 1070 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ResampleInternal@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _outwidth$[ebp]
	imul	ecx, DWORD PTR _outheight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1071 : 		Image_Resample8Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample8Nolerp
	add	esp, 24					; 00000018H

; 1072 : 		break;		

	jmp	$LN2@Image_Resa
$LN8@Image_Resa:

; 1073 : 	case PF_RGB_24:
; 1074 : 	case PF_BGR_24:
; 1075 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight * 3 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ResampleInternal@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _outwidth$[ebp]
	imul	ecx, DWORD PTR _outheight$[ebp]
	imul	edx, ecx, 3
	push	edx
	mov	eax, DWORD PTR _image+84
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1076 : 		if( quality ) Image_Resample24Lerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	cmp	DWORD PTR _quality$[ebp], 0
	je	SHORT $LN9@Image_Resa
	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample24Lerp
	add	esp, 24					; 00000018H
	jmp	SHORT $LN10@Image_Resa
$LN9@Image_Resa:

; 1077 : 		else Image_Resample24Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample24Nolerp
	add	esp, 24					; 00000018H
$LN10@Image_Resa:

; 1078 : 		break;

	jmp	$LN2@Image_Resa
$LN12@Image_Resa:

; 1079 : 	case PF_RGBA_32:
; 1080 : 	case PF_BGRA_32:
; 1081 : 		image.tempbuffer = (byte *)Mem_Realloc( host.imagepool, image.tempbuffer, outwidth * outheight * 4 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_ResampleInternal@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _outwidth$[ebp]
	imul	ecx, DWORD PTR _outheight$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 1082 : 		if( quality ) Image_Resample32Lerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	cmp	DWORD PTR _quality$[ebp], 0
	je	SHORT $LN13@Image_Resa
	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample32Lerp
	add	esp, 24					; 00000018H
	jmp	SHORT $LN14@Image_Resa
$LN13@Image_Resa:

; 1083 : 		else Image_Resample32Nolerp( indata, inwidth, inheight, image.tempbuffer, outwidth, outheight );

	mov	eax, DWORD PTR _outheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _inheight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inwidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _indata$[ebp]
	push	edx
	call	_Image_Resample32Nolerp
	add	esp, 24					; 00000018H
$LN14@Image_Resa:

; 1084 : 		break;

	jmp	SHORT $LN2@Image_Resa
$LN15@Image_Resa:

; 1085 : 	default:
; 1086 : 		*resampled = false;

	mov	eax, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [eax], 0

; 1087 : 		return (byte *)indata;	

	mov	eax, DWORD PTR _indata$[ebp]
	jmp	SHORT $LN1@Image_Resa
$LN2@Image_Resa:

; 1088 : 	}
; 1089 : 
; 1090 : 	*resampled = true;

	mov	eax, DWORD PTR _resampled$[ebp]
	mov	DWORD PTR [eax], 1

; 1091 : 	return image.tempbuffer;

	mov	eax, DWORD PTR _image+84
$LN1@Image_Resa:

; 1092 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@Image_Resa:
	DD	$LN6@Image_Resa
	DD	$LN6@Image_Resa
	DD	$LN12@Image_Resa
	DD	$LN12@Image_Resa
	DD	$LN8@Image_Resa
	DD	$LN8@Image_Resa
_Image_ResampleInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CheckPaletteQ1
_TEXT	SEGMENT
_pic$ = -4						; size = 4
_Image_CheckPaletteQ1 PROC				; COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 357  : 	rgbdata_t	*pic = FS_LoadImage( DEFAULT_INTERNAL_PALETTE, NULL, 0 );

	push	0
	push	0
	push	OFFSET ??_C@_0BA@JKAKIGAD@gfx?1palette?4lmp@
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax

; 358  : 
; 359  : 	if( pic && pic->size == 1024 )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN2@Image_Chec
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+32], 1024		; 00000400H
	jne	SHORT $LN2@Image_Chec

; 360  : 	{
; 361  : 		Image_ConvertPalTo24bit( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_ConvertPalTo24bit
	add	esp, 4

; 362  : 		if( Image_ComparePalette( pic->palette ) == PAL_CUSTOM )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_Image_ComparePalette
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Image_Chec

; 363  : 		{
; 364  : 			image.d_rendermode = LUMP_NORMAL;

	mov	DWORD PTR _image+68, 0

; 365  : 			Con_DPrintf( "custom quake palette detected\n" );

	push	OFFSET ??_C@_0BP@PJJMOBIN@custom?5quake?5palette?5detected?6@
	call	_Con_DPrintf
	add	esp, 4

; 366  : 			Image_SetPalette( pic->palette, d_8toQ1table );

	push	OFFSET _d_8toQ1table
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_Image_SetPalette
	add	esp, 8

; 367  : 			d_8toQ1table[255] = 0; // 255 is transparent

	mov	eax, 4
	imul	ecx, eax, 255
	mov	DWORD PTR _d_8toQ1table[ecx], 0

; 368  : 			image.custom_palette = true;

	mov	DWORD PTR _image+96, 1

; 369  : 			q1palette_init = true;

	mov	DWORD PTR _q1palette_init, 1
$LN2@Image_Chec:

; 370  : 		}
; 371  : 	}
; 372  : 
; 373  : 	if( pic ) FS_FreeImage( pic );

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN1@Image_Chec
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4
$LN1@Image_Chec:

; 374  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckPaletteQ1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_ClearForceFlags
_TEXT	SEGMENT
_Image_ClearForceFlags PROC				; COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 223  : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 224  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_ClearForceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_CustomPalette
_TEXT	SEGMENT
_Image_CustomPalette PROC				; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 187  : 	return image.custom_palette;

	mov	eax, DWORD PTR _image+96

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CustomPalette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_SetForceFlags
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_Image_SetForceFlags PROC				; COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 213  : 	SetBits( image.force_flags, flags );

	mov	eax, DWORD PTR _image+92
	or	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _image+92, eax

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_SetForceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_PaletteTranslate
_TEXT	SEGMENT
tv67 = -656						; size = 4
tv66 = -652						; size = 4
_i$ = -520						; size = 4
_src$ = -516						; size = 256
_dst$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_palSrc$ = 8						; size = 4
_top$ = 12						; size = 4
_bottom$ = 16						; size = 4
_pal_size$ = 20						; size = 4
_Image_PaletteTranslate PROC				; COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 518  : 	byte	dst[256], src[256];
; 519  : 	int	i;
; 520  : 
; 521  : 	pal_size = bound( 3, pal_size, 4 );

	cmp	DWORD PTR _pal_size$[ebp], 3
	jl	SHORT $LN21@Image_Pale
	cmp	DWORD PTR _pal_size$[ebp], 4
	jge	SHORT $LN19@Image_Pale
	mov	eax, DWORD PTR _pal_size$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN20@Image_Pale
$LN19@Image_Pale:
	mov	DWORD PTR tv66[ebp], 4
$LN20@Image_Pale:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN22@Image_Pale
$LN21@Image_Pale:
	mov	DWORD PTR tv67[ebp], 3
$LN22@Image_Pale:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _pal_size$[ebp], edx

; 522  : 	for( i = 0; i < 256; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Pale
$LN2@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Image_Pale

; 523  : 		src[i] = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _i$[ebp]
	mov	BYTE PTR _src$[ebp+eax], cl
	jmp	SHORT $LN2@Image_Pale
$LN3@Image_Pale:

; 524  : 	memcpy( dst, src, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _src$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 525  : 
; 526  : 	if( top < 128 )

	cmp	DWORD PTR _top$[ebp], 128		; 00000080H
	jge	SHORT $LN14@Image_Pale

; 527  : 	{
; 528  : 		// the artists made some backwards ranges. sigh.
; 529  : 		memcpy( dst + SHIRT_HUE_START, src + top, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _top$[ebp]
	lea	ecx, DWORD PTR _src$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _dst$[ebp+16]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 530  : 	}

	jmp	SHORT $LN15@Image_Pale
$LN14@Image_Pale:

; 531  : 	else
; 532  : 	{
; 533  : 		for( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Pale
$LN5@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN15@Image_Pale

; 534  : 			dst[SHIRT_HUE_START+i] = src[top + 15 - i];

	mov	eax, DWORD PTR _top$[ebp]
	add	eax, 15					; 0000000fH
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _src$[ebp+eax]
	mov	BYTE PTR _dst$[ebp+ecx+16], dl
	jmp	SHORT $LN5@Image_Pale
$LN15@Image_Pale:

; 535  : 	}
; 536  : 
; 537  : 	if( bottom < 128 )

	cmp	DWORD PTR _bottom$[ebp], 128		; 00000080H
	jge	SHORT $LN16@Image_Pale

; 538  : 	{
; 539  : 		memcpy( dst + PANTS_HUE_START, src + bottom, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _bottom$[ebp]
	lea	ecx, DWORD PTR _src$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _dst$[ebp+96]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 540  : 	}

	jmp	SHORT $LN17@Image_Pale
$LN16@Image_Pale:

; 541  : 	else
; 542  : 	{
; 543  : 		for( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Image_Pale
$LN8@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN17@Image_Pale

; 544  : 			dst[PANTS_HUE_START + i] = src[bottom + 15 - i];

	mov	eax, DWORD PTR _bottom$[ebp]
	add	eax, 15					; 0000000fH
	sub	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _src$[ebp+eax]
	mov	BYTE PTR _dst$[ebp+ecx+96], dl
	jmp	SHORT $LN8@Image_Pale
$LN17@Image_Pale:

; 545  : 	}
; 546  : 
; 547  : 	// last color isn't changed
; 548  : 	for( i = 0; i < 255; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Pale
$LN11@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Image_Pale:
	cmp	DWORD PTR _i$[ebp], 255			; 000000ffH
	jge	SHORT $LN1@Image_Pale

; 549  : 	{
; 550  : 		palSrc[i*pal_size+0] = palette_q1[dst[i]*3+0];

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _dst$[ebp+eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	mov	dl, BYTE PTR _palette_q1[edx]
	mov	BYTE PTR [ecx+eax], dl

; 551  : 		palSrc[i*pal_size+1] = palette_q1[dst[i]*3+1];

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _dst$[ebp+eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	mov	dl, BYTE PTR _palette_q1[edx+1]
	mov	BYTE PTR [ecx+eax+1], dl

; 552  : 		palSrc[i*pal_size+2] = palette_q1[dst[i]*3+2];

	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR _dst$[ebp+eax]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	mov	dl, BYTE PTR _palette_q1[edx+2]
	mov	BYTE PTR [ecx+eax+2], dl

; 553  : 	}

	jmp	$LN11@Image_Pale
$LN1@Image_Pale:

; 554  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_PaletteTranslate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_PaletteHueReplace
_TEXT	SEGMENT
tv135 = -112						; size = 4
tv128 = -112						; size = 4
tv134 = -108						; size = 4
tv95 = -108						; size = 4
tv70 = -108						; size = 4
tv131 = -104						; size = 4
tv92 = -104						; size = 4
tv69 = -104						; size = 4
_i$ = -36						; size = 4
_sat$ = -32						; size = 4
_val$ = -28						; size = 4
_hue$ = -24						; size = 4
_mincol$ = -20						; size = 4
_maxcol$ = -16						; size = 4
_b$ = -12						; size = 4
_g$ = -8						; size = 4
_r$ = -4						; size = 4
_palSrc$ = 8						; size = 4
_newHue$ = 12						; size = 4
_start$ = 16						; size = 4
_end$ = 20						; size = 4
_pal_size$ = 24						; size = 4
_Image_PaletteHueReplace PROC				; COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 443  : 	float	r, g, b;
; 444  : 	float	maxcol, mincol;
; 445  : 	float	hue, val, sat;
; 446  : 	int	i;
; 447  : 
; 448  : 	hue = (float)(newHue * ( 360.0f / 255 ));

	cvtsi2ss xmm0, DWORD PTR _newHue$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb4b4b5
	movss	DWORD PTR _hue$[ebp], xmm0

; 449  : 	pal_size = bound( 3, pal_size, 4 );

	cmp	DWORD PTR _pal_size$[ebp], 3
	jl	SHORT $LN19@Image_Pale
	cmp	DWORD PTR _pal_size$[ebp], 4
	jge	SHORT $LN17@Image_Pale
	mov	eax, DWORD PTR _pal_size$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN18@Image_Pale
$LN17@Image_Pale:
	mov	DWORD PTR tv69[ebp], 4
$LN18@Image_Pale:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN20@Image_Pale
$LN19@Image_Pale:
	mov	DWORD PTR tv70[ebp], 3
$LN20@Image_Pale:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _pal_size$[ebp], edx

; 450  : 
; 451  : 	for( i = start; i <= end; i++ )

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@Image_Pale
$LN2@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Pale:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jg	$LN3@Image_Pale

; 452  : 	{
; 453  : 		r = palSrc[i*pal_size+0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _r$[ebp], xmm0

; 454  : 		g = palSrc[i*pal_size+1];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _g$[ebp], xmm0

; 455  : 		b = palSrc[i*pal_size+2];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _pal_size$[ebp]
	mov	ecx, DWORD PTR _palSrc$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+2]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _b$[ebp], xmm0

; 456  : 		
; 457  : 		maxcol = max( max( r, g ), b ) / 255.0f;

	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, DWORD PTR _g$[ebp]
	jbe	SHORT $LN21@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN22@Image_Pale
$LN21@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv92[ebp], xmm0
$LN22@Image_Pale:
	movss	xmm0, DWORD PTR tv92[ebp]
	comiss	xmm0, DWORD PTR _b$[ebp]
	jbe	SHORT $LN25@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, DWORD PTR _g$[ebp]
	jbe	SHORT $LN23@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN24@Image_Pale
$LN23@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv95[ebp], xmm0
$LN24@Image_Pale:
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
	jmp	SHORT $LN26@Image_Pale
$LN25@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR tv128[ebp], xmm0
$LN26@Image_Pale:
	movss	xmm0, DWORD PTR tv128[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _maxcol$[ebp], xmm0

; 458  : 		mincol = min( min( r, g ), b ) / 255.0f;

	movss	xmm0, DWORD PTR _g$[ebp]
	comiss	xmm0, DWORD PTR _r$[ebp]
	jbe	SHORT $LN27@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
	jmp	SHORT $LN28@Image_Pale
$LN27@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv131[ebp], xmm0
$LN28@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	comiss	xmm0, DWORD PTR tv131[ebp]
	jbe	SHORT $LN31@Image_Pale
	movss	xmm0, DWORD PTR _g$[ebp]
	comiss	xmm0, DWORD PTR _r$[ebp]
	jbe	SHORT $LN29@Image_Pale
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN30@Image_Pale
$LN29@Image_Pale:
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR tv134[ebp], xmm0
$LN30@Image_Pale:
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN32@Image_Pale
$LN31@Image_Pale:
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
$LN32@Image_Pale:
	movss	xmm0, DWORD PTR tv135[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _mincol$[ebp], xmm0

; 459  : 
; 460  : 		if( maxcol == 0 ) continue;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Image_Pale
	jmp	$LN2@Image_Pale
$LN5@Image_Pale:

; 461  : 		
; 462  : 		val = maxcol;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	movss	DWORD PTR _val$[ebp], xmm0

; 463  : 		sat = (maxcol - mincol) / maxcol;

	movss	xmm0, DWORD PTR _maxcol$[ebp]
	subss	xmm0, DWORD PTR _mincol$[ebp]
	divss	xmm0, DWORD PTR _maxcol$[ebp]
	movss	DWORD PTR _sat$[ebp], xmm0

; 464  : 
; 465  : 		mincol = val * (1.0f - sat);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _sat$[ebp]
	mulss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _mincol$[ebp], xmm0

; 466  : 
; 467  : 		if( hue <= 120.0f )

	movss	xmm0, DWORD PTR __real@42f00000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jb	$LN6@Image_Pale

; 468  : 		{
; 469  : 			b = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 470  : 			if( hue < 60 )

	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN8@Image_Pale

; 471  : 			{
; 472  : 				r = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 473  : 				g = mincol + hue * (val - mincol) / (120.0f - hue);

	movss	xmm0, DWORD PTR _val$[ebp]
	subss	xmm0, DWORD PTR _mincol$[ebp]
	mulss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR __real@42f00000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 474  : 			}

	jmp	SHORT $LN9@Image_Pale
$LN8@Image_Pale:

; 475  : 			else
; 476  : 			{
; 477  : 				g = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 478  : 				r = mincol + (120.0f - hue) * (val - mincol) / hue;

	movss	xmm0, DWORD PTR __real@42f00000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	divss	xmm0, DWORD PTR _hue$[ebp]
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0
$LN9@Image_Pale:

; 479  : 			}
; 480  : 		}

	jmp	$LN15@Image_Pale
$LN6@Image_Pale:

; 481  : 		else if( hue <= 240.0f )

	movss	xmm0, DWORD PTR __real@43700000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jb	$LN10@Image_Pale

; 482  : 		{
; 483  : 			r = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 484  : 			if( hue < 180.0f )

	movss	xmm0, DWORD PTR __real@43340000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN12@Image_Pale

; 485  : 			{
; 486  : 				g = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 487  : 				b = mincol + (hue - 120.0f) * (val - mincol) / (240.0f - hue);

	movss	xmm0, DWORD PTR _hue$[ebp]
	subss	xmm0, DWORD PTR __real@42f00000
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@43700000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 488  : 			}

	jmp	SHORT $LN13@Image_Pale
$LN12@Image_Pale:

; 489  : 			else
; 490  : 			{
; 491  : 				b = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 492  : 				g = mincol + (240.0f - hue) * (val - mincol) / (hue - 120.0f);

	movss	xmm0, DWORD PTR __real@43700000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _hue$[ebp]
	subss	xmm1, DWORD PTR __real@42f00000
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0
$LN13@Image_Pale:

; 493  : 			}
; 494  : 		}

	jmp	$LN15@Image_Pale
$LN10@Image_Pale:

; 495  : 		else
; 496  : 		{
; 497  : 			g = mincol;

	movss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 498  : 			if( hue < 300.0f )

	movss	xmm0, DWORD PTR __real@43960000
	comiss	xmm0, DWORD PTR _hue$[ebp]
	jbe	SHORT $LN14@Image_Pale

; 499  : 			{
; 500  : 				b = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 501  : 				r = mincol + (hue - 240.0f) * (val - mincol) / (360.0f - hue);

	movss	xmm0, DWORD PTR _hue$[ebp]
	subss	xmm0, DWORD PTR __real@43700000
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@43b40000
	subss	xmm1, DWORD PTR _hue$[ebp]
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 502  : 			}

	jmp	SHORT $LN15@Image_Pale
$LN14@Image_Pale:

; 503  : 			else
; 504  : 			{
; 505  : 				r = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 506  : 				b = mincol + (360.0f - hue) * (val - mincol) / (hue - 240.0f);

	movss	xmm0, DWORD PTR __real@43b40000
	subss	xmm0, DWORD PTR _hue$[ebp]
	movss	xmm1, DWORD PTR _val$[ebp]
	subss	xmm1, DWORD PTR _mincol$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _hue$[ebp]
	subss	xmm1, DWORD PTR __real@43700000
	divss	xmm0, xmm1
	addss	xmm0, DWORD PTR _mincol$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0
$LN15@Image_Pale:

; 507  : 			}
; 508  : 		}
; 509  : 
; 510  : 		palSrc[i*pal_size+0] = (byte)(r * 255);

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 511  : 		palSrc[i*pal_size+1] = (byte)(g * 255);

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx+1], al

; 512  : 		palSrc[i*pal_size+2] = (byte)(b * 255);

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _pal_size$[ebp]
	mov	edx, DWORD PTR _palSrc$[ebp]
	mov	BYTE PTR [edx+ecx+2], al

; 513  : 	}

	jmp	$LN2@Image_Pale
$LN3@Image_Pale:

; 514  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_PaletteHueReplace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Process
_TEXT	SEGMENT
tv174 = -96						; size = 4
tv170 = -96						; size = 4
tv173 = -92						; size = 4
tv169 = -92						; size = 4
_resampled$1 = -24					; size = 4
_h$2 = -20						; size = 4
_w$3 = -16						; size = 4
_out$ = -12						; size = 4
_result$ = -8						; size = 4
_pic$ = -4						; size = 4
_pix$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_flags$ = 20						; size = 4
_bumpscale$ = 24					; size = 4
_Image_Process PROC					; COMDAT

; 1458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1459 : 	rgbdata_t	*pic = *pix;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pic$[ebp], ecx

; 1460 : 	qboolean	result = true;

	mov	DWORD PTR _result$[ebp], 1

; 1461 : 	byte	*out;
; 1462 : 				
; 1463 : 	// check for buffers
; 1464 : 	if( !pic || !pic->buffer )

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN3@Image_Proc
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@Image_Proc
$LN3@Image_Proc:

; 1465 : 	{
; 1466 : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1467 : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Proc
$LN2@Image_Proc:

; 1468 : 	}
; 1469 : 
; 1470 : 	if( !flags )

	cmp	DWORD PTR _flags$[ebp], 0
	jne	SHORT $LN4@Image_Proc

; 1471 : 	{
; 1472 : 		// clear any force flags
; 1473 : 		image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1474 : 		return false; // no operation specfied

	xor	eax, eax
	jmp	$LN1@Image_Proc
$LN4@Image_Proc:

; 1475 : 	}
; 1476 : 
; 1477 : 	if( FBitSet( flags, IMAGE_MAKE_LUMA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN5@Image_Proc

; 1478 : 	{
; 1479 : 		out = Image_CreateLumaInternal( pic->buffer, pic->width, pic->height, pic->type, pic->flags );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_Image_CreateLumaInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1480 : 		if( pic->buffer != out ) memcpy( pic->buffer, image.tempbuffer, pic->size );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _out$[ebp]
	je	SHORT $LN6@Image_Proc
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN6@Image_Proc:

; 1481 : 		ClearBits( pic->flags, IMAGE_HAS_LUMA );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN5@Image_Proc:

; 1482 : 	}
; 1483 : 
; 1484 : 	if( FBitSet( flags, IMAGE_REMAP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 134217728				; 08000000H
	je	SHORT $LN8@Image_Proc

; 1485 : 	{
; 1486 : 		// NOTE: user should keep copy of indexed image manually for new changes
; 1487 : 		if( Image_RemapInternal( pic, width, height ))

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	push	edx
	call	_Image_RemapInternal
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@Image_Proc

; 1488 : 			pic = Image_DecompressInternal( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN8@Image_Proc:

; 1489 : 	}
; 1490 : 
; 1491 : 	// update format to RGBA if any
; 1492 : 	if( FBitSet( flags, IMAGE_FORCE_RGBA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN9@Image_Proc

; 1493 : 		pic = Image_DecompressInternal( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_DecompressInternal
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN9@Image_Proc:

; 1494 : 
; 1495 : 	if( FBitSet( flags, IMAGE_LIGHTGAMMA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN10@Image_Proc

; 1496 : 		pic = Image_LightGamma( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_LightGamma
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN10@Image_Proc:

; 1497 : 
; 1498 : 	if( FBitSet( flags, IMAGE_EMBOSS ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 524288				; 00080000H
	je	SHORT $LN11@Image_Proc

; 1499 : 		Image_ApplyFilter( pic, bumpscale );

	push	ecx
	movss	xmm0, DWORD PTR _bumpscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_ApplyFilter
	add	esp, 8
$LN11@Image_Proc:

; 1500 : 
; 1501 : 	out = Image_FlipInternal( pic->buffer, &pic->width, &pic->height, pic->type, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_Image_FlipInternal
	add	esp, 20					; 00000014H
	mov	DWORD PTR _out$[ebp], eax

; 1502 : 	if( pic->buffer != out ) memcpy( pic->buffer, image.tempbuffer, pic->size );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _out$[ebp]
	je	SHORT $LN12@Image_Proc
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN12@Image_Proc:

; 1503 : 
; 1504 : 	if( FBitSet( flags, IMAGE_RESAMPLE ) && width > 0 && height > 0 )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1048576				; 00100000H
	je	$LN15@Image_Proc
	cmp	DWORD PTR _width$[ebp], 0
	jle	$LN15@Image_Proc
	cmp	DWORD PTR _height$[ebp], 0
	jle	$LN15@Image_Proc

; 1505 : 	{
; 1506 : 		int	w = bound( 1, width, IMAGE_MAXWIDTH );	// 1 - 4096

	cmp	DWORD PTR _width$[ebp], 1
	jl	SHORT $LN20@Image_Proc
	cmp	DWORD PTR _width$[ebp], 8192		; 00002000H
	jge	SHORT $LN18@Image_Proc
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN19@Image_Proc
$LN18@Image_Proc:
	mov	DWORD PTR tv169[ebp], 8192		; 00002000H
$LN19@Image_Proc:
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv170[ebp], ecx
	jmp	SHORT $LN21@Image_Proc
$LN20@Image_Proc:
	mov	DWORD PTR tv170[ebp], 1
$LN21@Image_Proc:
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _w$3[ebp], edx

; 1507 : 		int	h = bound( 1, height, IMAGE_MAXHEIGHT);	// 1 - 4096

	cmp	DWORD PTR _height$[ebp], 1
	jl	SHORT $LN24@Image_Proc
	cmp	DWORD PTR _height$[ebp], 8192		; 00002000H
	jge	SHORT $LN22@Image_Proc
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN23@Image_Proc
$LN22@Image_Proc:
	mov	DWORD PTR tv173[ebp], 8192		; 00002000H
$LN23@Image_Proc:
	mov	ecx, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv174[ebp], ecx
	jmp	SHORT $LN25@Image_Proc
$LN24@Image_Proc:
	mov	DWORD PTR tv174[ebp], 1
$LN25@Image_Proc:
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR _h$2[ebp], edx

; 1508 : 		qboolean	resampled = false;

	mov	DWORD PTR _resampled$1[ebp], 0

; 1509 : 
; 1510 : 		out = Image_ResampleInternal((uint *)pic->buffer, pic->width, pic->height, w, h, pic->type, &resampled );

	lea	eax, DWORD PTR _resampled$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _h$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_Image_ResampleInternal
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _out$[ebp], eax

; 1511 : 
; 1512 : 		if( resampled ) // resampled or filled

	cmp	DWORD PTR _resampled$1[ebp], 0
	je	$LN14@Image_Proc

; 1513 : 		{
; 1514 : 			Con_Reportf( "Image_Resample: from[%d x %d] to [%d x %d]\n", pic->width, pic->height, w, h );

	mov	eax, DWORD PTR _h$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CM@LLKBPOHF@Image_Resample?3?5from?$FL?$CFd?5x?5?$CFd?$FN?5t@
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 1515 : 			pic->width = w, pic->height = h;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	cx, WORD PTR _w$3[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	ax, WORD PTR _h$2[ebp]
	mov	WORD PTR [edx+2], ax

; 1516 : 			pic->size = w * h * PFDesc[pic->type].bpp;

	mov	eax, DWORD PTR _w$3[ebp]
	imul	eax, DWORD PTR _h$2[ebp]
	mov	ecx, DWORD PTR _pic$[ebp]
	imul	edx, DWORD PTR [ecx+8], 28
	imul	eax, DWORD PTR _PFDesc[edx+24]
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1517 : 			Mem_Free( pic->buffer );		// free original image buffer

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Process@@9@9
	add	eax, 59					; 0000003bH
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1518 : 			pic->buffer = Image_Copy( pic->size );	// unzone buffer (don't touch image.tempbuffer)

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_Image_Copy
	add	esp, 4
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1519 : 		}

	jmp	SHORT $LN15@Image_Proc
$LN14@Image_Proc:

; 1520 : 		else
; 1521 : 		{
; 1522 : 			// not a resampled or filled
; 1523 : 			result = false;

	mov	DWORD PTR _result$[ebp], 0
$LN15@Image_Proc:

; 1524 : 		}
; 1525 : 	}
; 1526 : 
; 1527 : 	// quantize image
; 1528 : 	if( FBitSet( flags, IMAGE_QUANTIZE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 33554432				; 02000000H
	je	SHORT $LN16@Image_Proc

; 1529 : 		pic = Image_Quantize( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_Quantize
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax
$LN16@Image_Proc:

; 1530 : 
; 1531 : 	*pix = pic;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax], ecx

; 1532 : 
; 1533 : 	// clear any force flags
; 1534 : 	image.force_flags = 0;

	mov	DWORD PTR _image+92, 0

; 1535 : 
; 1536 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@Image_Proc:

; 1537 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Process ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_AddCmdFlags
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_Image_AddCmdFlags PROC					; COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 233  : 	SetBits( image.cmd_flags, flags );

	mov	eax, DWORD PTR _image+88
	or	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _image+88, eax

; 234  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_AddCmdFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Shutdown
_TEXT	SEGMENT
_Image_Shutdown PROC					; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 166  : 	Mem_Check(); // check for leaks

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Shutdown@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	__Mem_Check
	add	esp, 8

; 167  : 	Mem_FreePool( &host.imagepool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Shutdown@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _host+34744
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 168  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_utils.c
;	COMDAT _Image_Init
_TEXT	SEGMENT
tv69 = -68						; size = 4
_Image_Init PROC					; COMDAT

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 143  : 	// init pools
; 144  : 	host.imagepool = Mem_AllocPool( "ImageLib Pool" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Init@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DP@FHAAEBGG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0O@EILAMLBA@ImageLib?5Pool@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _host+34744, eax

; 145  : 
; 146  : 	// install image formats (can be re-install later by Image_Setup)
; 147  : 	switch( host.type )

	mov	eax, DWORD PTR _host+164
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN4@Image_Init
	jmp	SHORT $LN5@Image_Init
$LN4@Image_Init:

; 148  : 	{
; 149  : 	case HOST_NORMAL:
; 150  : 		image.cmd_flags = IL_USE_LERPING|IL_ALLOW_OVERWRITE;		

	mov	DWORD PTR _image+88, 5

; 151  : 		image.loadformats = load_game;

	mov	DWORD PTR _image, OFFSET _load_game

; 152  : 		image.saveformats = save_game;

	mov	DWORD PTR _image+4, OFFSET _save_game

; 153  : 		break;

	jmp	SHORT $LN2@Image_Init
$LN5@Image_Init:

; 154  : 	default:	// all other instances not using imagelib
; 155  : 		image.cmd_flags = 0;		

	mov	DWORD PTR _image+88, 0

; 156  : 		image.loadformats = load_game;

	mov	DWORD PTR _image, OFFSET _load_game

; 157  : 		image.saveformats = save_null;

	mov	DWORD PTR _image+4, OFFSET _save_null
$LN2@Image_Init:

; 158  : 		break;
; 159  : 	}
; 160  : 
; 161  : 	image.tempbuffer = NULL;

	mov	DWORD PTR _image+84, 0

; 162  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Init ENDP
_TEXT	ENDS
END
