; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_dds.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Image_DXTGetLinearSize
PUBLIC	_Image_LoadDDS
PUBLIC	_Image_CheckDXT3Alpha
PUBLIC	_Image_CheckDXT5Alpha
PUBLIC	_Image_DXTGetPixelFormat
PUBLIC	_Image_DXTCalcMipmapSize
PUBLIC	_Image_DXTCalcSize
PUBLIC	_Image_DXTAdjustVolume
PUBLIC	??_C@_0EH@LAMPAEAA@?$FO3Warning?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_LoadDDS@@9@9		; `Image_LoadDDS'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@EPJPHCNI@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0EA@KLLBOELA@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0DG@GEPCBDEK@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0DN@FLDEDLMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Image_ValidSize:PROC
EXTRN	_Image_CheckFlag:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0DN@FLDEDLMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@FLDEDLMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_dds.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GEPCBDEK@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0DG@GEPCBDEK@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadDDS: (%s) has unrecognized type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@KLLBOELA@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0EA@KLLBOELA@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadDDS: (%s) have corrupt pixelformat header'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EPJPHCNI@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0DG@EPJPHCNI@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadDDS: (%s) have corrupted header', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_LoadDDS@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_LoadDDS@@9@9 DD 0f3H		; `Image_LoadDDS'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EH@LAMPAEAA@?$FO3Warning?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs@
CONST	SEGMENT
??_C@_0EH@LAMPAEAA@?$FO3Warning?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs@ DB '^'
	DB	'3Warning:^7 Image_LoadDDS: (%s) probably corrupted (%i should'
	DB	' be %i)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_DXTAdjustVolume
_TEXT	SEGMENT
_hdr$ = 8						; size = 4
_Image_DXTAdjustVolume PROC				; COMDAT

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 230  : 	if( hdr->dwDepth <= 1 )

	mov	eax, DWORD PTR _hdr$[ebp]
	cmp	DWORD PTR [eax+24], 1
	ja	SHORT $LN2@Image_DXTA

; 231  : 		return;

	jmp	SHORT $LN1@Image_DXTA
$LN2@Image_DXTA:

; 232  : 
; 233  : 	hdr->dwLinearSize = Image_DXTGetLinearSize( image.type, hdr->dwWidth, hdr->dwHeight, hdr->dwDepth );

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _image+20
	push	eax
	call	_Image_DXTGetLinearSize
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 234  : 	hdr->dwFlags |= DDS_LINEARSIZE;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Image_DXTA:

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTAdjustVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_DXTCalcSize
_TEXT	SEGMENT
_d$ = -16						; size = 4
_h$ = -12						; size = 4
_w$ = -8						; size = 4
_buffsize$ = -4						; size = 4
_name$ = 8						; size = 4
_hdr$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_DXTCalcSize PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 192  : 	size_t buffsize = 0;

	mov	DWORD PTR _buffsize$[ebp], 0

; 193  : 	int w = image.width;

	movzx	eax, WORD PTR _image+8
	mov	DWORD PTR _w$[ebp], eax

; 194  : 	int h = image.height;

	movzx	eax, WORD PTR _image+10
	mov	DWORD PTR _h$[ebp], eax

; 195  : 	int d = image.depth;

	movzx	eax, WORD PTR _image+12
	mov	DWORD PTR _d$[ebp], eax

; 196  : 
; 197  : 	if( hdr->dsCaps.dwCaps2 & DDS_CUBEMAP ) 

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 512				; 00000200H
	je	SHORT $LN2@Image_DXTC

; 198  : 	{
; 199  : 		// cubemap w*h always match for all sides
; 200  : 		buffsize = Image_DXTCalcMipmapSize( hdr ) * 6;

	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	imul	ecx, eax, 6
	mov	DWORD PTR _buffsize$[ebp], ecx

; 201  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN2@Image_DXTC:

; 202  : 	else if( hdr->dwFlags & DDS_MIPMAPCOUNT )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN4@Image_DXTC

; 203  : 	{
; 204  : 		// if mipcount > 1
; 205  : 		buffsize = Image_DXTCalcMipmapSize( hdr );

	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	mov	DWORD PTR _buffsize$[ebp], eax

; 206  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN4@Image_DXTC:

; 207  : 	else if( hdr->dwFlags & ( DDS_LINEARSIZE|DDS_PITCH ))

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 524296				; 00080008H
	je	SHORT $LN6@Image_DXTC

; 208  : 	{
; 209  : 		// just in case (no need, really)
; 210  : 		buffsize = hdr->dwLinearSize;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _buffsize$[ebp], ecx

; 211  : 	}

	jmp	SHORT $LN3@Image_DXTC
$LN6@Image_DXTC:

; 212  : 	else 
; 213  : 	{
; 214  : 		// pretty solution for microsoft bug
; 215  : 		buffsize = Image_DXTCalcMipmapSize( hdr );

	mov	eax, DWORD PTR _hdr$[ebp]
	push	eax
	call	_Image_DXTCalcMipmapSize
	add	esp, 4
	mov	DWORD PTR _buffsize$[ebp], eax
$LN3@Image_DXTC:

; 216  : 	}
; 217  : 
; 218  : 	if( filesize != buffsize ) // main check

	mov	eax, DWORD PTR _filesize$[ebp]
	cmp	eax, DWORD PTR _buffsize$[ebp]
	je	SHORT $LN8@Image_DXTC

; 219  : 	{
; 220  : 		Con_DPrintf( S_WARN "Image_LoadDDS: (%s) probably corrupted (%i should be %i)\n", name, buffsize, filesize );

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	push	OFFSET ??_C@_0EH@LAMPAEAA@?$FO3Warning?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 221  : 		if( buffsize > filesize )

	mov	eax, DWORD PTR _buffsize$[ebp]
	cmp	eax, DWORD PTR _filesize$[ebp]
	jbe	SHORT $LN8@Image_DXTC

; 222  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@Image_DXTC
$LN8@Image_DXTC:

; 223  : 	}
; 224  : 
; 225  : 	return buffsize;

	mov	eax, DWORD PTR _buffsize$[ebp]
$LN1@Image_DXTC:

; 226  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTCalcSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_DXTCalcMipmapSize
_TEXT	SEGMENT
tv81 = -84						; size = 4
tv75 = -84						; size = 4
tv68 = -84						; size = 4
_height$ = -16						; size = 4
_width$ = -12						; size = 4
_i$ = -8						; size = 4
_buffsize$ = -4						; size = 4
_hdr$ = 8						; size = 4
_Image_DXTCalcMipmapSize PROC				; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 176  : 	size_t	buffsize = 0;

	mov	DWORD PTR _buffsize$[ebp], 0

; 177  : 	int	i, width, height;
; 178  : 		
; 179  : 	// now correct buffer size
; 180  : 	for( i = 0; i < Q_max( 1, ( hdr->dwMipMapCount )); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_DXTC
$LN2@Image_DXTC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_DXTC:
	mov	eax, DWORD PTR _hdr$[ebp]
	cmp	DWORD PTR [eax+28], 1
	jae	SHORT $LN6@Image_DXTC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN7@Image_DXTC
$LN6@Image_DXTC:
	mov	ecx, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR tv68[ebp], edx
$LN7@Image_DXTC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR tv68[ebp]
	jae	$LN3@Image_DXTC

; 181  : 	{
; 182  : 		width = Q_max( 1, ( hdr->dwWidth >> i ));

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	cmp	edx, 1
	jae	SHORT $LN8@Image_DXTC
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN9@Image_DXTC
$LN8@Image_DXTC:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	mov	DWORD PTR tv75[ebp], edx
$LN9@Image_DXTC:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 183  : 		height = Q_max( 1, ( hdr->dwHeight >> i ));

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	cmp	edx, 1
	jae	SHORT $LN10@Image_DXTC
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN11@Image_DXTC
$LN10@Image_DXTC:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _i$[ebp]
	shr	edx, cl
	mov	DWORD PTR tv81[ebp], edx
$LN11@Image_DXTC:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 184  : 		buffsize += Image_DXTGetLinearSize( image.type, width, height, image.depth );

	movzx	eax, WORD PTR _image+12
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _image+20
	push	eax
	call	_Image_DXTGetLinearSize
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _buffsize$[ebp]
	mov	DWORD PTR _buffsize$[ebp], eax

; 185  : 	}

	jmp	$LN2@Image_DXTC
$LN3@Image_DXTC:

; 186  : 
; 187  : 	return buffsize;

	mov	eax, DWORD PTR _buffsize$[ebp]

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTCalcMipmapSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_DXTGetPixelFormat
_TEXT	SEGMENT
tv73 = -72						; size = 4
_bits$ = -4						; size = 4
_hdr$ = 8						; size = 4
_Image_DXTGetPixelFormat PROC				; COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 98   : 	uint bits = hdr->dsPixelFormat.dwRGBBitCount;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _bits$[ebp], ecx

; 99   : 
; 100  : 	if( !FBitSet( hdr->dsCaps.dwCaps2, DDS_VOLUME ))

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 2097152				; 00200000H
	jne	SHORT $LN4@Image_DXTG

; 101  : 		hdr->dwDepth = 1;

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	DWORD PTR [eax+24], 1
$LN4@Image_DXTG:

; 102  : 
; 103  : 	if( FBitSet( hdr->dsPixelFormat.dwFlags, DDS_FOURCC ))

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	je	$LN5@Image_DXTG

; 104  : 	{
; 105  : 		switch( hdr->dsPixelFormat.dwFourCC )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 861165636		; 33545844H
	ja	SHORT $LN25@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 861165636		; 33545844H
	je	SHORT $LN9@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 827611204		; 31545844H
	je	SHORT $LN7@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 843666497		; 32495441H
	je	SHORT $LN12@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 844388420		; 32545844H
	je	SHORT $LN8@Image_DXTG
	jmp	SHORT $LN13@Image_DXTG
$LN25@Image_DXTG:
	cmp	DWORD PTR tv73[ebp], 877942852		; 34545844H
	je	SHORT $LN10@Image_DXTG
	cmp	DWORD PTR tv73[ebp], 894720068		; 35545844H
	je	SHORT $LN11@Image_DXTG
	jmp	SHORT $LN13@Image_DXTG
$LN7@Image_DXTG:

; 106  : 		{
; 107  : 		case TYPE_DXT1: 
; 108  : 			image.type = PF_DXT1;

	mov	DWORD PTR _image+20, 7

; 109  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN8@Image_DXTG:

; 110  : 		case TYPE_DXT2:
; 111  : 			image.flags &= ~IMAGE_HAS_ALPHA; // alpha is already premultiplied by color

	mov	eax, DWORD PTR _image+24
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _image+24, eax
$LN9@Image_DXTG:

; 112  : 		case TYPE_DXT3:
; 113  : 			image.type = PF_DXT3;

	mov	DWORD PTR _image+20, 8

; 114  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN10@Image_DXTG:

; 115  : 		case TYPE_DXT4:
; 116  : 			image.flags &= ~IMAGE_HAS_ALPHA; // alpha is already premultiplied by color

	mov	eax, DWORD PTR _image+24
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _image+24, eax
$LN11@Image_DXTG:

; 117  : 		case TYPE_DXT5:
; 118  : 			image.type = PF_DXT5;

	mov	DWORD PTR _image+20, 9

; 119  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN12@Image_DXTG:

; 120  : 		case TYPE_ATI2:
; 121  : 			image.type = PF_ATI2;

	mov	DWORD PTR _image+20, 10			; 0000000aH

; 122  : 			break;

	jmp	SHORT $LN2@Image_DXTG
$LN13@Image_DXTG:

; 123  : 		default:
; 124  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0
$LN2@Image_DXTG:

; 125  : 			break;
; 126  : 		}
; 127  : 	}

	jmp	SHORT $LN6@Image_DXTG
$LN5@Image_DXTG:

; 128  : 	else
; 129  : 	{
; 130  : 		// this dds texture isn't compressed so write out ARGB or luminance format
; 131  : 		if( hdr->dsPixelFormat.dwFlags & DDS_DUDV )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN14@Image_DXTG

; 132  : 		{
; 133  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0

; 134  : 		}

	jmp	SHORT $LN6@Image_DXTG
$LN14@Image_DXTG:

; 135  : 		else if( hdr->dsPixelFormat.dwFlags & DDS_LUMINANCE )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN16@Image_DXTG

; 136  : 		{
; 137  : 			image.type = PF_UNKNOWN; // assume error

	mov	DWORD PTR _image+20, 0

; 138  : 		}

	jmp	SHORT $LN6@Image_DXTG
$LN16@Image_DXTG:

; 139  : 		else 
; 140  : 		{
; 141  : 			if( bits == 32 )

	cmp	DWORD PTR _bits$[ebp], 32		; 00000020H
	jne	SHORT $LN18@Image_DXTG

; 142  : 				image.type = PF_BGRA_32;

	mov	DWORD PTR _image+20, 4
	jmp	SHORT $LN6@Image_DXTG
$LN18@Image_DXTG:

; 143  : 			else if( bits == 24 )

	cmp	DWORD PTR _bits$[ebp], 24		; 00000018H
	jne	SHORT $LN20@Image_DXTG

; 144  : 				image.type = PF_BGR_24;

	mov	DWORD PTR _image+20, 6
	jmp	SHORT $LN6@Image_DXTG
$LN20@Image_DXTG:

; 145  : 			else image.type = PF_UNKNOWN; // assume error;

	mov	DWORD PTR _image+20, 0
$LN6@Image_DXTG:

; 146  : 		}
; 147  : 	}
; 148  : 
; 149  : 	// setup additional flags
; 150  : 	if( hdr->dsCaps.dwCaps1 & DDS_COMPLEX && hdr->dsCaps.dwCaps2 & DDS_CUBEMAP )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	and	ecx, 8
	je	SHORT $LN22@Image_DXTG
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	and	ecx, 512				; 00000200H
	je	SHORT $LN22@Image_DXTG

; 151  : 		image.flags |= IMAGE_CUBEMAP;

	mov	eax, DWORD PTR _image+24
	or	eax, 1
	mov	DWORD PTR _image+24, eax
$LN22@Image_DXTG:

; 152  : 
; 153  : 	if( hdr->dwFlags & DDS_MIPMAPCOUNT )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN1@Image_DXTG

; 154  : 		image.num_mips = hdr->dwMipMapCount; // get actual mip count

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	cl, BYTE PTR [eax+28]
	mov	BYTE PTR _image+14, cl
$LN1@Image_DXTG:

; 155  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_DXTGetPixelFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_CheckDXT5Alpha
_TEXT	SEGMENT
_j$ = -28						; size = 4
_i$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_alphamask$ = -12					; size = 4
_bitmask$ = -8						; size = 4
_bits$ = -4						; size = 4
_hdr$ = 8						; size = 4
_fin$ = 12						; size = 4
_Image_CheckDXT5Alpha PROC				; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 57   : 	uint	bits, bitmask;
; 58   : 	byte	*alphamask; 
; 59   : 	int	x, y, i, j; 
; 60   : 
; 61   : 	for( y = 0; y < hdr->dwHeight; y += 4 )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN4@Image_Chec
$LN2@Image_Chec:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	mov	DWORD PTR _y$[ebp], eax
$LN4@Image_Chec:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	$LN3@Image_Chec

; 62   : 	{
; 63   : 		for( x = 0; x < hdr->dwWidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Image_Chec
$LN5@Image_Chec:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 4
	mov	DWORD PTR _x$[ebp], eax
$LN7@Image_Chec:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	$LN6@Image_Chec

; 64   : 		{
; 65   : 			if( y >= hdr->dwHeight || x >= hdr->dwWidth )

	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN15@Image_Chec
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN14@Image_Chec
$LN15@Image_Chec:

; 66   : 				break;

	jmp	$LN6@Image_Chec
$LN14@Image_Chec:

; 67   : 
; 68   : 			alphamask = fin + 2;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 2
	mov	DWORD PTR _alphamask$[ebp], eax

; 69   : 			fin += 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax

; 70   : 
; 71   : 			bitmask = ((uint *)fin)[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _bitmask$[ebp], edx

; 72   : 			fin += 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax

; 73   : 
; 74   : 			// last three bytes
; 75   : 			bits = (alphamask[3]) | (alphamask[4] << 8) | (alphamask[5] << 16);

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _alphamask$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _alphamask$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	or	eax, ecx
	mov	edx, 1
	imul	ecx, edx, 5
	mov	edx, DWORD PTR _alphamask$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	mov	DWORD PTR _bits$[ebp], eax

; 76   : 
; 77   : 			for( j = 2; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 2
	jmp	SHORT $LN10@Image_Chec
$LN8@Image_Chec:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Image_Chec:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Image_Chec

; 78   : 			{
; 79   : 				for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Chec
$LN11@Image_Chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Image_Chec:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN12@Image_Chec

; 80   : 				{
; 81   : 					// only put pixels out < width or height
; 82   : 					if((( x + i ) < hdr->dwWidth ) && (( y + j ) < hdr->dwHeight ))

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _hdr$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jae	SHORT $LN16@Image_Chec
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _hdr$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jae	SHORT $LN16@Image_Chec

; 83   : 					{
; 84   : 						if( bits & 0x07 )

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 7
	je	SHORT $LN16@Image_Chec

; 85   : 							return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN16@Image_Chec:

; 86   : 					}
; 87   : 					bits >>= 3;

	mov	eax, DWORD PTR _bits$[ebp]
	shr	eax, 3
	mov	DWORD PTR _bits$[ebp], eax

; 88   : 				}

	jmp	SHORT $LN11@Image_Chec
$LN12@Image_Chec:

; 89   : 			}

	jmp	SHORT $LN8@Image_Chec
$LN9@Image_Chec:

; 90   : 		}

	jmp	$LN5@Image_Chec
$LN6@Image_Chec:

; 91   : 	}

	jmp	$LN2@Image_Chec
$LN3@Image_Chec:

; 92   : 
; 93   : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckDXT5Alpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_CheckDXT3Alpha
_TEXT	SEGMENT
_j$ = -28						; size = 4
_i$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_alpha$ = -12						; size = 4
_sAlpha$ = -8						; size = 2
_bitmask$ = -4						; size = 4
_hdr$ = 8						; size = 4
_fin$ = 12						; size = 4
_Image_CheckDXT3Alpha PROC				; COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 21   : 	uint	bitmask;
; 22   : 	word	sAlpha;
; 23   : 	byte	*alpha; 
; 24   : 	int	x, y, i, j; 
; 25   : 
; 26   : 	for( y = 0; y < hdr->dwHeight; y += 4 )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN4@Image_Chec
$LN2@Image_Chec:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 4
	mov	DWORD PTR _y$[ebp], eax
$LN4@Image_Chec:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	$LN3@Image_Chec

; 27   : 	{
; 28   : 		for( x = 0; x < hdr->dwWidth; x += 4 )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@Image_Chec
$LN5@Image_Chec:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 4
	mov	DWORD PTR _x$[ebp], eax
$LN7@Image_Chec:
	mov	eax, DWORD PTR _hdr$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	$LN6@Image_Chec

; 29   : 		{
; 30   : 			alpha = fin;

	mov	eax, DWORD PTR _fin$[ebp]
	mov	DWORD PTR _alpha$[ebp], eax

; 31   : 			fin += 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax

; 32   : 			bitmask = ((uint *)fin)[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fin$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _bitmask$[ebp], edx

; 33   : 			fin += 8;

	mov	eax, DWORD PTR _fin$[ebp]
	add	eax, 8
	mov	DWORD PTR _fin$[ebp], eax

; 34   : 
; 35   : 			for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@Image_Chec
$LN8@Image_Chec:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@Image_Chec:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN9@Image_Chec

; 36   : 			{
; 37   : 				sAlpha = alpha[2*j] + 256 * alpha[2*j+1];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _alpha$[ebp]
	movzx	edx, BYTE PTR [ecx+eax*2]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _alpha$[ebp]
	movzx	eax, BYTE PTR [ecx+eax*2+1]
	shl	eax, 8
	add	edx, eax
	mov	WORD PTR _sAlpha$[ebp], dx

; 38   : 
; 39   : 				for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@Image_Chec
$LN11@Image_Chec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Image_Chec:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN12@Image_Chec

; 40   : 				{
; 41   : 					if((( x + i ) < hdr->dwWidth ) && (( y + j ) < hdr->dwHeight ))

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _hdr$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	jae	SHORT $LN14@Image_Chec
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _hdr$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jae	SHORT $LN14@Image_Chec

; 42   : 					{
; 43   : 						if( sAlpha == 0 )

	movzx	eax, WORD PTR _sAlpha$[ebp]
	test	eax, eax
	jne	SHORT $LN14@Image_Chec

; 44   : 							return true;

	mov	eax, 1
	jmp	SHORT $LN1@Image_Chec
$LN14@Image_Chec:

; 45   : 					}
; 46   : 					sAlpha >>= 4;

	mov	ax, WORD PTR _sAlpha$[ebp]
	shr	ax, 4
	mov	WORD PTR _sAlpha$[ebp], ax

; 47   : 				}

	jmp	SHORT $LN11@Image_Chec
$LN12@Image_Chec:

; 48   : 			}

	jmp	SHORT $LN8@Image_Chec
$LN9@Image_Chec:

; 49   : 		}

	jmp	$LN5@Image_Chec
$LN6@Image_Chec:

; 50   : 	}

	jmp	$LN2@Image_Chec
$LN3@Image_Chec:

; 51   : 
; 52   : 	return false;

	xor	eax, eax
$LN1@Image_Chec:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_CheckDXT3Alpha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_LoadDDS
_TEXT	SEGMENT
tv134 = -204						; size = 4
_fin$ = -136						; size = 4
_header$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadDDS PROC					; COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 244  : 	dds_t	header;
; 245  : 	byte	*fin;
; 246  : 
; 247  : 	if( filesize < sizeof( dds_t ))

	cmp	DWORD PTR _filesize$[ebp], 128		; 00000080H
	jae	SHORT $LN4@Image_Load

; 248  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN4@Image_Load:

; 249  : 
; 250  : 	memcpy( &header, buffer, sizeof( dds_t ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 	if( header.dwIdent != DDSHEADER )

	cmp	DWORD PTR _header$[ebp], 542327876	; 20534444H
	je	SHORT $LN5@Image_Load

; 253  : 		return false; // it's not a dds file, just skip it

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN5@Image_Load:

; 254  : 
; 255  : 	if( header.dwSize != sizeof( dds_t ) - sizeof( uint )) // size of the structure (minus MagicNum)

	cmp	DWORD PTR _header$[ebp+4], 124		; 0000007cH
	je	SHORT $LN6@Image_Load

; 256  : 	{
; 257  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) have corrupted header\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@EPJPHCNI@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 258  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN6@Image_Load:

; 259  : 	}
; 260  : 
; 261  : 	if( header.dsPixelFormat.dwSize != sizeof( dds_pixf_t )) // size of the structure

	cmp	DWORD PTR _header$[ebp+76], 32		; 00000020H
	je	SHORT $LN7@Image_Load

; 262  : 	{
; 263  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) have corrupt pixelformat header\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EA@KLLBOELA@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 264  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN7@Image_Load:

; 265  : 	}
; 266  : 
; 267  : 	image.width = header.dwWidth;

	mov	ax, WORD PTR _header$[ebp+16]
	mov	WORD PTR _image+8, ax

; 268  : 	image.height = header.dwHeight;

	mov	ax, WORD PTR _header$[ebp+12]
	mov	WORD PTR _image+10, ax

; 269  : 
; 270  : 	if( header.dwFlags & DDS_DEPTH )

	mov	eax, DWORD PTR _header$[ebp+8]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN8@Image_Load

; 271  : 		image.depth = header.dwDepth;

	mov	ax, WORD PTR _header$[ebp+24]
	mov	WORD PTR _image+12, ax
	jmp	SHORT $LN9@Image_Load
$LN8@Image_Load:

; 272  : 	else image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax
$LN9@Image_Load:

; 273  : 
; 274  : 	if( !Image_ValidSize( name )) return false;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN10@Image_Load:

; 275  : 
; 276  : 	Image_DXTGetPixelFormat( &header ); // and image type too :)

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_Image_DXTGetPixelFormat
	add	esp, 4

; 277  : 	Image_DXTAdjustVolume( &header );

	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	call	_Image_DXTAdjustVolume
	add	esp, 4

; 278  : 
; 279  : 	if( !Image_CheckFlag( IL_DDS_HARDWARE ) && ImageDXT( image.type ))

	push	16					; 00000010H
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@Image_Load
	cmp	DWORD PTR _image+20, 7
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 8
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 9
	je	SHORT $LN12@Image_Load
	cmp	DWORD PTR _image+20, 10			; 0000000aH
	jne	SHORT $LN11@Image_Load
$LN12@Image_Load:

; 280  : 		return false; // silently rejected

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN11@Image_Load:

; 281  : 
; 282  : 	if( image.type == PF_UNKNOWN ) 

	cmp	DWORD PTR _image+20, 0
	jne	SHORT $LN13@Image_Load

; 283  : 	{
; 284  : 		Con_DPrintf( S_ERROR "Image_LoadDDS: (%s) has unrecognized type\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@GEPCBDEK@?$FO1Error?3?$FO7?5Image_LoadDDS?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 285  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN13@Image_Load:

; 286  : 	}
; 287  : 
; 288  : 	image.size = Image_DXTCalcSize( name, &header, filesize - 128 ); 

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, 128				; 00000080H
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Image_DXTCalcSize
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _image+28, eax

; 289  : 	if( image.size == 0 ) return false; // just in case

	cmp	DWORD PTR _image+28, 0
	jne	SHORT $LN14@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN14@Image_Load:

; 290  : 	fin = (byte *)(buffer + sizeof( dds_t ));

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _fin$[ebp], eax

; 291  : 
; 292  : 	// copy an encode method
; 293  : 	image.encode = (word)header.dwReserved1[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	dx, WORD PTR _header$[ebp+ecx+36]
	mov	WORD PTR _image+16, dx

; 294  : 
; 295  : 	switch( image.encode )

	movzx	eax, WORD PTR _image+16
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR tv134[ebp]
	sub	ecx, 6657				; 00001a01H
	mov	DWORD PTR tv134[ebp], ecx
	cmp	DWORD PTR tv134[ebp], 8
	ja	SHORT $LN21@Image_Load
	mov	edx, DWORD PTR tv134[ebp]
	jmp	DWORD PTR $LN28@Image_Load[edx*4]
$LN15@Image_Load:

; 296  : 	{
; 297  : 	case DXT_ENCODE_COLOR_YCoCg:
; 298  : 		SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax

; 299  : 		break;

	jmp	$LN2@Image_Load
$LN20@Image_Load:

; 300  : 	case DXT_ENCODE_NORMAL_AG_ORTHO:
; 301  : 	case DXT_ENCODE_NORMAL_AG_STEREO:
; 302  : 	case DXT_ENCODE_NORMAL_AG_PARABOLOID:
; 303  : 	case DXT_ENCODE_NORMAL_AG_QUARTIC:
; 304  : 	case DXT_ENCODE_NORMAL_AG_AZIMUTHAL:
; 305  : 		SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax

; 306  : 		break;

	jmp	SHORT $LN2@Image_Load
$LN21@Image_Load:

; 307  : 	default:	// check for real alpha-pixels
; 308  : 		if( image.type == PF_DXT3 && Image_CheckDXT3Alpha( &header, fin ))

	cmp	DWORD PTR _image+20, 8
	jne	SHORT $LN22@Image_Load
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_Image_CheckDXT3Alpha
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@Image_Load

; 309  : 			SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
	jmp	SHORT $LN23@Image_Load
$LN22@Image_Load:

; 310  : 		else if( image.type == PF_DXT5 && Image_CheckDXT5Alpha( &header, fin ))

	cmp	DWORD PTR _image+20, 9
	jne	SHORT $LN23@Image_Load
	mov	eax, DWORD PTR _fin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	call	_Image_CheckDXT5Alpha
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@Image_Load

; 311  : 			SetBits( image.flags, IMAGE_HAS_ALPHA );

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
$LN23@Image_Load:

; 312  : 		if( !FBitSet( header.dsPixelFormat.dwFlags, DDS_LUMINANCE ))

	mov	eax, DWORD PTR _header$[ebp+80]
	and	eax, 131072				; 00020000H
	jne	SHORT $LN2@Image_Load

; 313  : 			SetBits( image.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax
$LN2@Image_Load:

; 314  : 		break;
; 315  : 	}
; 316  : 
; 317  : 	if( header.dwReserved1[1] != 0 )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _header$[ebp+eax+36], 0
	je	$LN26@Image_Load

; 318  : 	{
; 319  : 		// store texture reflectivity
; 320  : 		image.fogParams[0] = ((header.dwReserved1[1] & 0x000000FF) >> 0 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp+eax+36]
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _image[eax+76], cl

; 321  : 		image.fogParams[1] = ((header.dwReserved1[1] & 0x0000FF00) >> 8 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp+eax+36]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _image[edx+76], cl

; 322  : 		image.fogParams[2] = ((header.dwReserved1[1] & 0x00FF0000) >> 16);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp+eax+36]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _image[edx+76], cl

; 323  : 		image.fogParams[3] = ((header.dwReserved1[1] & 0xFF000000) >> 24);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp+eax+36]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _image[eax+76], cl
$LN26@Image_Load:

; 324  : 	}
; 325  : 
; 326  : 	// dds files will be uncompressed on a render. requires minimal of info for set this
; 327  : 	image.rgba = Mem_Malloc( host.imagepool, image.size ); 

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadDDS@@9@9
	add	eax, 84					; 00000054H
	push	eax
	push	OFFSET ??_C@_0DN@FLDEDLMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax

; 328  : 	memcpy( image.rgba, fin, image.size );

	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _fin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image+40
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 329  : 	SetBits( image.flags, IMAGE_DDS_FORMAT );

	mov	eax, DWORD PTR _image+24
	or	eax, 128				; 00000080H
	mov	DWORD PTR _image+24, eax

; 330  : 
; 331  : 	return true;

	mov	eax, 1
$LN1@Image_Load:

; 332  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN28@Image_Load:
	DD	$LN15@Image_Load
	DD	$LN21@Image_Load
	DD	$LN21@Image_Load
	DD	$LN21@Image_Load
	DD	$LN20@Image_Load
	DD	$LN20@Image_Load
	DD	$LN20@Image_Load
	DD	$LN20@Image_Load
	DD	$LN20@Image_Load
_Image_LoadDDS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_dds.c
;	COMDAT _Image_DXTGetLinearSize
_TEXT	SEGMENT
tv64 = -68						; size = 4
_type$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_Image_DXTGetLinearSize PROC				; COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 159  : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN2@Image_DXTG
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN13@Image_DXTG[edx*4]
$LN4@Image_DXTG:

; 160  : 	{
; 161  : 	case PF_DXT1: return ((( width + 3 ) / 4 ) * (( height + 3 ) / 4 ) * depth * 8 );

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2
	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	ecx, eax
	imul	ecx, DWORD PTR _depth$[ebp]
	shl	ecx, 3
	mov	eax, ecx
	jmp	SHORT $LN1@Image_DXTG
$LN7@Image_DXTG:

; 162  : 	case PF_DXT3:
; 163  : 	case PF_DXT5:
; 164  : 	case PF_ATI2: return ((( width + 3 ) / 4 ) * (( height + 3 ) / 4 ) * depth * 16 );

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 2
	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	imul	ecx, eax
	imul	ecx, DWORD PTR _depth$[ebp]
	shl	ecx, 4
	mov	eax, ecx
	jmp	SHORT $LN1@Image_DXTG
$LN9@Image_DXTG:

; 165  : 	case PF_BGR_24:
; 166  : 	case PF_RGB_24: return (width * height * depth * 3);

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	imul	eax, eax, 3
	jmp	SHORT $LN1@Image_DXTG
$LN11@Image_DXTG:

; 167  : 	case PF_BGRA_32:
; 168  : 	case PF_RGBA_32: return (width * height * depth * 4);

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	jmp	SHORT $LN1@Image_DXTG
$LN2@Image_DXTG:

; 169  : 	}	
; 170  : 
; 171  : 	return 0;

	xor	eax, eax
$LN1@Image_DXTG:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN13@Image_DXTG:
	DD	$LN11@Image_DXTG
	DD	$LN11@Image_DXTG
	DD	$LN9@Image_DXTG
	DD	$LN9@Image_DXTG
	DD	$LN4@Image_DXTG
	DD	$LN7@Image_DXTG
	DD	$LN7@Image_DXTG
	DD	$LN7@Image_DXTG
_Image_DXTGetLinearSize ENDP
_TEXT	ENDS
END
