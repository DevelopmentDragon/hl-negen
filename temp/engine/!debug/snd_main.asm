; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\snd_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_sound:BYTE:034H
_DATA	ENDS
PUBLIC	_FS_LoadSound
PUBLIC	_FS_FreeSound
PUBLIC	_FS_OpenStream
PUBLIC	_FS_StreamInfo
PUBLIC	_FS_ReadStream
PUBLIC	_FS_SetStreamPos
PUBLIC	_FS_GetStreamPos
PUBLIC	_FS_FreeStream
PUBLIC	_Sound_Reset
PUBLIC	_SoundPack
PUBLIC	?__LINE__Var@?0??SoundPack@@9@9			; `SoundPack'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_LoadSound@@9@9		; `FS_LoadSound'::`1'::__LINE__Var
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0CP@IJKEFGFF@?$FO3Warning?3?$FO7?5FS_LoadSound?3?5coul@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_FreeSound@@9@9		; `FS_FreeSound'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@KOJOPCOP@FS_OpenStream?3?5couldn?8t?5open?5?$CC?$CF@ ; `string'
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?info@?1??FS_StreamInfo@@9@9 DB 01cH DUP (?)		; `FS_StreamInfo'::`2'::info
_BSS	ENDS
;	COMDAT ??_C@_0CD@KOJOPCOP@FS_OpenStream?3?5couldn?8t?5open?5?$CC?$CF@
CONST	SEGMENT
??_C@_0CD@KOJOPCOP@FS_OpenStream?3?5couldn?8t?5open?5?$CC?$CF@ DB 'FS_Ope'
	DB	'nStream: couldn''t open "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_FreeSound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_FreeSound@@9@9 DD 086H		; `FS_FreeSound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CP@IJKEFGFF@?$FO3Warning?3?$FO7?5FS_LoadSound?3?5coul@
CONST	SEGMENT
??_C@_0CP@IJKEFGFF@?$FO3Warning?3?$FO7?5FS_LoadSound?3?5coul@ DB '^3Warni'
	DB	'ng:^7 FS_LoadSound: couldn''t load "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_LoadSound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_LoadSound@@9@9 DD 03aH		; `FS_LoadSound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\soundlib\snd_main.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SoundPack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SoundPack@@9@9 DD 022H			; `SoundPack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01b8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02f3H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _SoundPack
_TEXT	SEGMENT
_pack$ = -4						; size = 4
_SoundPack PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 35   : 	wavdata_t	*pack = Mem_Calloc( host.soundpool, sizeof( wavdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??SoundPack@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _host+34748
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pack$[ebp], eax

; 36   : 
; 37   : 	pack->buffer = sound.wav;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+40
	mov	DWORD PTR [eax+20], ecx

; 38   : 	pack->width = sound.width;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _sound+16
	mov	BYTE PTR [eax+2], cl

; 39   : 	pack->rate = sound.rate;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cx, WORD PTR _sound+12
	mov	WORD PTR [eax], cx

; 40   : 	pack->type = sound.type;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+8
	mov	DWORD PTR [eax+12], ecx

; 41   : 	pack->size = sound.size;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+36
	mov	DWORD PTR [eax+24], ecx

; 42   : 	pack->loopStart = sound.loopstart;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+24
	mov	DWORD PTR [eax+4], ecx

; 43   : 	pack->samples = sound.samples;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+28
	mov	DWORD PTR [eax+8], ecx

; 44   : 	pack->channels = sound.channels;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	cl, BYTE PTR _sound+20
	mov	BYTE PTR [eax+3], cl

; 45   : 	pack->flags = sound.flags;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _sound+32
	mov	DWORD PTR [eax+16], ecx

; 46   : 
; 47   : 	return pack;

	mov	eax, DWORD PTR _pack$[ebp]

; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SoundPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _Sound_Reset
_TEXT	SEGMENT
_Sound_Reset PROC					; COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 23   : 	// reset global variables
; 24   : 	sound.width = sound.rate = 0;

	mov	DWORD PTR _sound+12, 0
	mov	eax, DWORD PTR _sound+12
	mov	DWORD PTR _sound+16, eax

; 25   : 	sound.channels = sound.loopstart = 0;

	mov	DWORD PTR _sound+24, 0
	mov	eax, DWORD PTR _sound+24
	mov	DWORD PTR _sound+20, eax

; 26   : 	sound.samples = sound.flags = 0;

	mov	DWORD PTR _sound+32, 0
	mov	eax, DWORD PTR _sound+32
	mov	DWORD PTR _sound+28, eax

; 27   : 	sound.type = WF_UNKNOWN;

	mov	DWORD PTR _sound+8, 0

; 28   : 
; 29   : 	sound.wav = NULL;

	mov	DWORD PTR _sound+40, 0

; 30   : 	sound.size = 0;

	mov	DWORD PTR _sound+36, 0

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_FreeStream
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_FreeStream PROC					; COMDAT

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 276  : 	if( !stream || !stream->format || !stream->format->freefunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_FreeStr
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_FreeStr
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN2@FS_FreeStr
$LN3@FS_FreeStr:

; 277  : 		return;

	jmp	SHORT $LN1@FS_FreeStr
$LN2@FS_FreeStr:

; 278  : 
; 279  : 	stream->format->freefunc( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	add	esp, 4
$LN1@FS_FreeStr:

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FreeStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_GetStreamPos
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_GetStreamPos PROC					; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 246  : 	if( !stream || !stream->format || !stream->format->getposfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_GetStre
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_GetStre
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN2@FS_GetStre
$LN3@FS_GetStre:

; 247  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_GetStre
$LN2@FS_GetStre:

; 248  : 
; 249  : 	return stream->format->getposfunc( stream );

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	add	esp, 4
$LN1@FS_GetStre:

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_GetStreamPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_SetStreamPos
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_FS_SetStreamPos PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 261  : 	if( !stream || !stream->format || !stream->format->setposfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_SetStre
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_SetStre
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN2@FS_SetStre
$LN3@FS_SetStre:

; 262  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_SetStre
$LN2@FS_SetStre:

; 263  : 
; 264  : 	return stream->format->setposfunc( stream, newpos );

	mov	eax, DWORD PTR _newpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	add	esp, 8
$LN1@FS_SetStre:

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SetStreamPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_ReadStream
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_bytes$ = 12						; size = 4
_buffer$ = 16						; size = 4
_FS_ReadStream PROC					; COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 228  : 	if( !stream || !stream->format || !stream->format->readfunc )

	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN3@FS_ReadStr
	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@FS_ReadStr
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN2@FS_ReadStr
$LN3@FS_ReadStr:

; 229  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_ReadStr
$LN2@FS_ReadStr:

; 230  : 
; 231  : 	if( bytes <= 0 || buffer == NULL )

	cmp	DWORD PTR _bytes$[ebp], 0
	jle	SHORT $LN5@FS_ReadStr
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN4@FS_ReadStr
$LN5@FS_ReadStr:

; 232  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_ReadStr
$LN4@FS_ReadStr:

; 233  : 
; 234  : 	return stream->format->readfunc( stream, bytes, buffer );

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	add	esp, 12					; 0000000cH
$LN1@FS_ReadStr:

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ReadStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_StreamInfo
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_FS_StreamInfo PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 201  : 	static wavdata_t	info;
; 202  : 
; 203  : 	if( !stream ) return NULL;

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN2@FS_StreamI
	xor	eax, eax
	jmp	SHORT $LN1@FS_StreamI
$LN2@FS_StreamI:

; 204  : 
; 205  : 	// fill structure
; 206  : 	info.loopStart = -1;

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+4, -1

; 207  : 	info.rate = stream->rate;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	cx, WORD PTR [eax+12]
	mov	WORD PTR ?info@?1??FS_StreamInfo@@9@9, cx

; 208  : 	info.width = stream->width;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	cl, BYTE PTR [eax+8]
	mov	BYTE PTR ?info@?1??FS_StreamInfo@@9@9+2, cl

; 209  : 	info.channels = stream->channels;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	cl, BYTE PTR [eax+16]
	mov	BYTE PTR ?info@?1??FS_StreamInfo@@9@9+3, cl

; 210  : 	info.flags = SOUND_STREAM; 

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+16, 2

; 211  : 	info.size = stream->size;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+24, ecx

; 212  : 	info.buffer = NULL;

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+20, 0

; 213  : 	info.samples = 0;	// not actual for streams

	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+8, 0

; 214  : 	info.type = stream->type;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR ?info@?1??FS_StreamInfo@@9@9+12, ecx

; 215  : 
; 216  : 	return &info;

	mov	eax, OFFSET ?info@?1??FS_StreamInfo@@9@9
$LN1@FS_StreamI:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_StreamInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_OpenStream
_TEXT	SEGMENT
_stream$ = -532						; size = 4
_format$ = -528						; size = 4
_anyformat$ = -524					; size = 4
_loadname$ = -520					; size = 256
_path$ = -264						; size = 256
_ext$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_FS_OpenStream PROC					; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 149  : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 150  : 	string		path, loadname;
; 151  : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 152  : 	const streamfmt_t	*format;
; 153  : 	stream_t		*stream;
; 154  : 
; 155  : 	Sound_Reset(); // clear old streaminfo

	call	_Sound_Reset

; 156  : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 157  : 
; 158  : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@FS_OpenStr

; 159  : 	{
; 160  : 		// we needs to compare file extension with list of supported formats
; 161  : 		// and be sure what is real extension, not a filename with dot
; 162  : 		for( format = sound.streamformat; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _sound+4
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN4@FS_OpenStr
$LN2@FS_OpenStr:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _format$[ebp], eax
$LN4@FS_OpenStr:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN8@FS_OpenStr
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@FS_OpenStr

; 163  : 		{
; 164  : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@FS_OpenStr

; 165  : 			{
; 166  : 				COM_StripExtension( loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 167  : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 168  : 				break;

	jmp	SHORT $LN8@FS_OpenStr
$LN9@FS_OpenStr:

; 169  : 			}
; 170  : 		}

	jmp	SHORT $LN2@FS_OpenStr
$LN8@FS_OpenStr:

; 171  : 	}
; 172  : 
; 173  : 	// now try all the formats in the selected list
; 174  : 	for( format = sound.streamformat; format && format->formatstring; format++)

	mov	eax, DWORD PTR _sound+4
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN7@FS_OpenStr
$LN5@FS_OpenStr:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _format$[ebp], eax
$LN7@FS_OpenStr:
	cmp	DWORD PTR _format$[ebp], 0
	je	$LN6@FS_OpenStr
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN6@FS_OpenStr

; 175  : 	{
; 176  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN11@FS_OpenStr
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@FS_OpenStr
$LN11@FS_OpenStr:

; 177  : 		{
; 178  : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 179  : 			if(( stream = format->openfunc( path )) != NULL )

	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 4
	mov	DWORD PTR _stream$[ebp], eax
	cmp	DWORD PTR _stream$[ebp], 0
	je	SHORT $LN10@FS_OpenStr

; 180  : 			{
; 181  : 				stream->format = format;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _format$[ebp]
	mov	DWORD PTR [eax], ecx

; 182  : 				return stream; // done

	mov	eax, DWORD PTR _stream$[ebp]
	jmp	SHORT $LN1@FS_OpenStr
$LN10@FS_OpenStr:

; 183  : 			}
; 184  : 		}
; 185  : 	}

	jmp	$LN5@FS_OpenStr
$LN6@FS_OpenStr:

; 186  : 
; 187  : 	Con_Reportf( "FS_OpenStream: couldn't open \"%s\"\n", loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@KOJOPCOP@FS_OpenStream?3?5couldn?8t?5open?5?$CC?$CF@
	call	_Con_Reportf
	add	esp, 8

; 188  : 
; 189  : 	return NULL;

	xor	eax, eax
$LN1@FS_OpenStr:

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_OpenStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_FreeSound
_TEXT	SEGMENT
_pack$ = 8						; size = 4
_FS_FreeSound PROC					; COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 135  : 	if( !pack ) return;

	cmp	DWORD PTR _pack$[ebp], 0
	jne	SHORT $LN2@FS_FreeSou
	jmp	SHORT $LN1@FS_FreeSou
$LN2@FS_FreeSou:

; 136  : 	if( pack->buffer ) Mem_Free( pack->buffer );

	mov	eax, DWORD PTR _pack$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN3@FS_FreeSou
	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FreeSound@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@FS_FreeSou:

; 137  : 	Mem_Free( pack );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FreeSound@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pack$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@FS_FreeSou:

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FreeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_main.c
;	COMDAT _FS_LoadSound
_TEXT	SEGMENT
_f$ = -536						; size = 4
_format$ = -532						; size = 4
_filesize$ = -528					; size = 4
_anyformat$ = -524					; size = 4
_loadname$ = -520					; size = 256
_path$ = -264						; size = 256
_ext$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_FS_LoadSound PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 664				; 00000298H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 59   : 	const char	*ext = COM_FileExtension( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 60   : 	string		path, loadname;
; 61   : 	qboolean		anyformat = true;

	mov	DWORD PTR _anyformat$[ebp], 1

; 62   : 	int		filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 63   : 	const loadwavfmt_t	*format;
; 64   : 	byte		*f;
; 65   : 
; 66   : 	Sound_Reset(); // clear old sounddata

	call	_Sound_Reset

; 67   : 	Q_strncpy( loadname, filename, sizeof( loadname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _loadname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 68   : 
; 69   : 	if( Q_stricmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@FS_LoadSou

; 70   : 	{
; 71   : 		// we needs to compare file extension with list of supported formats
; 72   : 		// and be sure what is real extension, not a filename with dot
; 73   : 		for( format = sound.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN4@FS_LoadSou
$LN2@FS_LoadSou:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN4@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN11@FS_LoadSou
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@FS_LoadSou

; 74   : 		{
; 75   : 			if( !Q_stricmp( format->ext, ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@FS_LoadSou

; 76   : 			{
; 77   : 				COM_StripExtension( loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 78   : 				anyformat = false;

	mov	DWORD PTR _anyformat$[ebp], 0

; 79   : 				break;

	jmp	SHORT $LN11@FS_LoadSou
$LN12@FS_LoadSou:

; 80   : 			}
; 81   : 		}

	jmp	SHORT $LN2@FS_LoadSou
$LN11@FS_LoadSou:

; 82   : 	}
; 83   : 
; 84   : 	// special mode: skip any checks, load file from buffer
; 85   : 	if( filename[0] == '#' && buffer && size )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN13@FS_LoadSou
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN13@FS_LoadSou
	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN13@FS_LoadSou

; 86   : 		goto load_internal;

	jmp	$load_internal$25
$LN13@FS_LoadSou:

; 87   : 
; 88   : 	// now try all the formats in the selected list
; 89   : 	for( format = sound.loadformats; format && format->formatstring; format++)

	mov	eax, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN7@FS_LoadSou
$LN5@FS_LoadSou:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN7@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	$load_internal$25
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$load_internal$25

; 90   : 	{
; 91   : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN15@FS_LoadSou
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN14@FS_LoadSou
$LN15@FS_LoadSou:

; 92   : 		{
; 93   : 			Q_sprintf( path, format->formatstring, loadname, "", format->ext );

	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_00CNPNBAHC@@
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 20					; 00000014H

; 94   : 			f = FS_LoadFile( path, &filesize, false );

	push	0
	lea	eax, DWORD PTR _filesize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 95   : 			if( f && filesize > 0 )

	cmp	DWORD PTR _f$[ebp], 0
	je	SHORT $LN14@FS_LoadSou
	cmp	DWORD PTR _filesize$[ebp], 0
	jle	SHORT $LN14@FS_LoadSou

; 96   : 			{
; 97   : 				if( format->loadfunc( path, f, filesize ))

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@FS_LoadSou

; 98   : 				{
; 99   : 					Mem_Free(f); // release buffer

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadSound@@9@9
	add	eax, 41					; 00000029H
	push	eax
	push	OFFSET ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 100  : 					return SoundPack(); // loaded

	call	_SoundPack
	jmp	$LN1@FS_LoadSou

; 101  : 				}

	jmp	SHORT $LN14@FS_LoadSou
$LN17@FS_LoadSou:

; 102  : 				else Mem_Free(f); // release buffer 

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadSound@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DO@IHIOPOAG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN14@FS_LoadSou:

; 103  : 			}
; 104  : 		}
; 105  : 	}

	jmp	$LN5@FS_LoadSou
$load_internal$25:

; 106  : 
; 107  : load_internal:
; 108  : 	for( format = sound.loadformats; format && format->formatstring; format++ )

	mov	eax, DWORD PTR _sound
	mov	DWORD PTR _format$[ebp], eax
	jmp	SHORT $LN10@FS_LoadSou
$LN8@FS_LoadSou:
	mov	eax, DWORD PTR _format$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _format$[ebp], eax
$LN10@FS_LoadSou:
	cmp	DWORD PTR _format$[ebp], 0
	je	SHORT $LN9@FS_LoadSou
	mov	eax, DWORD PTR _format$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@FS_LoadSou

; 109  : 	{
; 110  : 		if( anyformat || !Q_stricmp( ext, format->ext ))

	cmp	DWORD PTR _anyformat$[ebp], 0
	jne	SHORT $LN20@FS_LoadSou
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@FS_LoadSou
$LN20@FS_LoadSou:

; 111  : 		{
; 112  : 			if( buffer && size > 0  )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN19@FS_LoadSou
	cmp	DWORD PTR _size$[ebp], 0
	jbe	SHORT $LN19@FS_LoadSou

; 113  : 			{
; 114  : 				if( format->loadfunc( loadname, buffer, size ))

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _loadname$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@FS_LoadSou

; 115  : 					return SoundPack(); // loaded

	call	_SoundPack
	jmp	SHORT $LN1@FS_LoadSou
$LN19@FS_LoadSou:

; 116  : 			}
; 117  : 		}
; 118  : 	}

	jmp	$LN8@FS_LoadSou
$LN9@FS_LoadSou:

; 119  : 
; 120  : 	if( filename[0] != '#' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filename$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	je	SHORT $LN23@FS_LoadSou

; 121  : 		Con_DPrintf( S_WARN "FS_LoadSound: couldn't load \"%s\"\n", loadname );

	lea	eax, DWORD PTR _loadname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@IJKEFGFF@?$FO3Warning?3?$FO7?5FS_LoadSound?3?5coul@
	call	_Con_DPrintf
	add	esp, 8
$LN23@FS_LoadSou:

; 122  : 
; 123  : 	return NULL;

	xor	eax, eax
$LN1@FS_LoadSou:

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadSound ENDP
_TEXT	ENDS
END
