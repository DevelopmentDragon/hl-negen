; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_pmove.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_ClipPMoveToEntity
PUBLIC	_SV_RunCmd
PUBLIC	_SV_InitClientMove
PUBLIC	_SV_GetTrueOrigin
PUBLIC	_SV_GetTrueMinMax
PUBLIC	_SV_PlayerIsFrozen
PUBLIC	_SV_ClearPhysEnts
PUBLIC	_SV_CopyEdictToPhysEnt
PUBLIC	_SV_ShouldUnlagForPlayer
PUBLIC	_SV_AddLinksToPmove
PUBLIC	_SV_AddLaddersToPmove
PUBLIC	_SV_FindEntInPack
PUBLIC	_SV_UnlagCheckTeleport
PUBLIC	_SV_SetupMoveInterpolant
PUBLIC	_SV_RestoreMoveInterpolant
PUBLIC	?__LINE__Var@?0??SV_ClipPMoveToEntity@@9@9	; `SV_ClipPMoveToEntity'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_03EHEMCPIE@bot@				; `string'
PUBLIC	??_C@_06BALNJMNP@player@			; `string'
PUBLIC	?__LINE__Var@?0??SV_AddLinksToPmove@@9@9	; `SV_AddLinksToPmove'::`1'::__LINE__Var
PUBLIC	??_C@_0BG@OLDHMDKH@SV_IsValidEdict?$CI?5pl?5?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnPlaySound@@9@9		; `pfnPlaySound'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnPlaybackEventFull@@9@9	; `pfnPlaybackEventFull'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@JGNNGBDI@SV?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@ ; `string'
PUBLIC	??_C@_0M@IICIDGOJ@sv_maxunlag@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4050000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@43800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileSize:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_pfnGetModelBounds:PROC
EXTRN	_pfnGetModelType:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_SV_StartSound:PROC
EXTRN	_CL_Particle:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_fabs:PROC
EXTRN	_BoundsIntersect:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_PlayerRunThink:PROC
EXTRN	_SV_Impact:PROC
EXTRN	_SV_RefreshUserinfo:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_SetMinMaxSize:PROC
EXTRN	_SV_PlaybackEventFull:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_UpdateBaseVelocity:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_SV_TruePointContents:PROC
EXTRN	_Pmove_Init:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	_PM_RecursiveHullCheck:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_TestPlayerPosition:PROC
EXTRN	_PM_HullPointContents:PROC
EXTRN	_PM_ConvertTrace:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_SV_UPDATE_BACKUP:DWORD
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_areanodes:BYTE
EXTRN	_sv_unlag:BYTE
EXTRN	_sv_maxunlag:BYTE
EXTRN	_sv_unlagpush:BYTE
EXTRN	_sv_background_freeze:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_has_update DD	01H DUP (?)
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?tr@?1??pfnTraceLineEx@@9@9 DB 044H DUP (?)		; `pfnTraceLineEx'::`2'::tr
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0M@IICIDGOJ@sv_maxunlag@
CONST	SEGMENT
??_C@_0M@IICIDGOJ@sv_maxunlag@ DB 'sv_maxunlag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@JGNNGBDI@SV?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@
CONST	SEGMENT
??_C@_0DK@JGNNGBDI@SV?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@ DB 'S'
	DB	'V: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnPlaybackEventFull@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnPlaybackEventFull@@9@9 DD 01eaH	; `pfnPlaybackEventFull'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnPlaySound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnPlaySound@@9@9 DD 01dfH		; `pfnPlaySound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@OLDHMDKH@SV_IsValidEdict?$CI?5pl?5?$CJ@
CONST	SEGMENT
??_C@_0BG@OLDHMDKH@SV_IsValidEdict?$CI?5pl?5?$CJ@ DB 'SV_IsValidEdict( pl'
	DB	' )', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_AddLinksToPmove@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_AddLinksToPmove@@9@9 DD 0d1H	; `SV_AddLinksToPmove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06BALNJMNP@player@
CONST	SEGMENT
??_C@_06BALNJMNP@player@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHEMCPIE@bot@
CONST	SEGMENT
??_C@_03EHEMCPIE@bot@ DB 'bot', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@ DB 'tr != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_pmove.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ClipPMoveToEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ClipPMoveToEntity@@9@9 DD 02fH	; `SV_ClipPMoveToEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0a49H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	093aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0408H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0455H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	069cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_RestoreMoveInterpolant
_TEXT	SEGMENT
_i$ = -12						; size = 4
_oldlerp$ = -8						; size = 4
_check$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_RestoreMoveInterpolant PROC				; COMDAT

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 967  : 	sv_client_t	*check;
; 968  : 	sv_interp_t	*oldlerp;
; 969  : 	int		i;
; 970  : 
; 971  : 	if( !has_update )

	cmp	DWORD PTR _has_update, 0
	jne	SHORT $LN5@SV_Restore

; 972  : 	{
; 973  : 		has_update = true;

	mov	DWORD PTR _has_update, 1

; 974  : 		return;

	jmp	$LN3@SV_Restore
$LN5@SV_Restore:

; 975  : 	}
; 976  : 
; 977  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_Restore

; 978  : 		return;

	jmp	$LN3@SV_Restore
$LN6@SV_Restore:

; 979  : 
; 980  : 	for( i = 0, check = svs.clients; i < svs.maxclients; i++, check++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], eax
	jmp	SHORT $LN4@SV_Restore
$LN2@SV_Restore:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@SV_Restore:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_Restore

; 981  : 	{
; 982  : 		if( check->state != cs_spawned || check == cl )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN8@SV_Restore
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	jne	SHORT $LN7@SV_Restore
$LN8@SV_Restore:

; 983  : 			continue;

	jmp	SHORT $LN2@SV_Restore
$LN7@SV_Restore:

; 984  : 
; 985  : 		oldlerp = &svgame.interp[i];

	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, OFFSET _svgame+8260
	mov	DWORD PTR _oldlerp$[ebp], eax

; 986  : 
; 987  : 		if( VectorCompare( oldlerp->oldpos, oldlerp->newpos ) || !oldlerp->moving )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _oldlerp$[ebp]
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+52]
	ucomiss	xmm0, DWORD PTR [esi+eax+64]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Restore
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _oldlerp$[ebp]
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+52]
	ucomiss	xmm0, DWORD PTR [esi+ecx+64]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Restore
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _oldlerp$[ebp]
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+52]
	ucomiss	xmm0, DWORD PTR [esi+ecx+64]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@SV_Restore
$LN11@SV_Restore:
	mov	eax, DWORD PTR _oldlerp$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@SV_Restore
$LN10@SV_Restore:

; 988  : 			continue; // they didn't actually move.

	jmp	$LN2@SV_Restore
$LN9@SV_Restore:

; 989  : 
; 990  : 		if( !oldlerp->active )

	mov	eax, DWORD PTR _oldlerp$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN12@SV_Restore

; 991  : 			continue;

	jmp	$LN2@SV_Restore
$LN12@SV_Restore:

; 992  : 
; 993  : 		if( VectorCompare( oldlerp->curpos, check->edict->v.origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264948]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+40]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Restore
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+40]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Restore
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _oldlerp$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+40]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Restore

; 994  : 		{
; 995  : 			VectorCopy( oldlerp->oldpos, check->edict->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264948]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+52]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	edx, DWORD PTR [esi+edx+52]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _oldlerp$[ebp]
	mov	eax, DWORD PTR [esi+eax+52]
	mov	DWORD PTR [edx+ecx+136], eax

; 996  : 			SV_LinkEdict( check->edict, false );

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	_SV_LinkEdict
	add	esp, 8
$LN13@SV_Restore:

; 997  : 		}
; 998  : 	}

	jmp	$LN2@SV_Restore
$LN3@SV_Restore:

; 999  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RestoreMoveInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_SetupMoveInterpolant
_TEXT	SEGMENT
tv298 = -152						; size = 4
tv397 = -148						; size = 4
tv370 = -148						; size = 4
tv297 = -148						; size = 4
tv185 = -148						; size = 4
tv179 = -148						; size = 4
_lerp$ = -80						; size = 4
_check$ = -76						; size = 4
_newpos$ = -72						; size = 12
_curpos$ = -60						; size = 12
_lerpstate$ = -48					; size = 4
_state$ = -44						; size = 4
_frame2$ = -40						; size = 4
_frame$ = -36						; size = 4
_lerpFrac$ = -32					; size = 4
_latency$ = -28						; size = 4
_lerp_msec$ = -24					; size = 4
_finalpush$ = -20					; size = 4
_clientnum$ = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_SetupMoveInterpolant PROC				; COMDAT

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 814  : 	int		i, j, clientnum;
; 815  : 	float		finalpush, lerp_msec;
; 816  : 	float		latency, lerpFrac;
; 817  : 	client_frame_t	*frame, *frame2;
; 818  : 	entity_state_t	*state, *lerpstate;
; 819  : 	vec3_t		curpos, newpos;
; 820  : 	sv_client_t	*check;
; 821  : 	sv_interp_t	*lerp;
; 822  : 
; 823  : 	memset( svgame.interp, 0, sizeof( svgame.interp ));

	push	2816					; 00000b00H
	push	0
	push	OFFSET _svgame+8260
	call	_memset
	add	esp, 12					; 0000000cH

; 824  : 	has_update = false;

	mov	DWORD PTR _has_update, 0

; 825  : 
; 826  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_SetupMo

; 827  : 		return;

	jmp	$LN12@SV_SetupMo
$LN14@SV_SetupMo:

; 828  : 
; 829  : 	has_update = true;

	mov	DWORD PTR _has_update, 1

; 830  : 
; 831  : 	for( i = 0, check = svs.clients; i < svs.maxclients; i++, check++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], eax
	jmp	SHORT $LN4@SV_SetupMo
$LN2@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_SetupMo

; 832  : 	{
; 833  : 		if( check->state != cs_spawned || check == cl )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN16@SV_SetupMo
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	jne	SHORT $LN15@SV_SetupMo
$LN16@SV_SetupMo:

; 834  : 			continue;

	jmp	SHORT $LN2@SV_SetupMo
$LN15@SV_SetupMo:

; 835  : 
; 836  : 		lerp = &svgame.interp[i];

	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, OFFSET _svgame+8260
	mov	DWORD PTR _lerp$[ebp], eax

; 837  : 
; 838  : 		VectorCopy( check->edict->v.origin, lerp->oldpos );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR [esi+edx+52], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [edx+eax+136]
	mov	DWORD PTR [esi+ecx+52], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR [esi+eax+52], ecx

; 839  : 		VectorCopy( check->edict->v.absmin, lerp->mins );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [ecx+eax+328]
	mov	DWORD PTR [esi+edx+16], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [edx+eax+328]
	mov	DWORD PTR [esi+ecx+16], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+328]
	mov	DWORD PTR [esi+eax+16], ecx

; 840  : 		VectorCopy( check->edict->v.absmax, lerp->maxs );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR [ecx+eax+340]
	mov	DWORD PTR [esi+edx+28], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR [edx+eax+340]
	mov	DWORD PTR [esi+ecx+28], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+340]
	mov	DWORD PTR [esi+eax+28], ecx

; 841  : 		lerp->active = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax], 1

; 842  : 	}

	jmp	$LN2@SV_SetupMo
$LN3@SV_SetupMo:

; 843  : 
; 844  : 	latency = Q_min( cl->latency, 1.5f );

	mov	eax, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR [eax+264940]
	jbe	SHORT $LN48@SV_SetupMo
	mov	ecx, DWORD PTR _cl$[ebp]
	movss	xmm0, DWORD PTR [ecx+264940]
	movss	DWORD PTR tv179[ebp], xmm0
	jmp	SHORT $LN49@SV_SetupMo
$LN48@SV_SetupMo:
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv179[ebp], xmm0
$LN49@SV_SetupMo:
	movss	xmm0, DWORD PTR tv179[ebp]
	movss	DWORD PTR _latency$[ebp], xmm0

; 845  : 
; 846  : 	if( sv_maxunlag.value != 0.0f )

	movss	xmm0, DWORD PTR _sv_maxunlag+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@SV_SetupMo

; 847  : 	{
; 848  : 		if (sv_maxunlag.value < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _sv_maxunlag+12
	jbe	SHORT $LN18@SV_SetupMo

; 849  : 			Cvar_SetValue( "sv_maxunlag", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@IICIDGOJ@sv_maxunlag@
	call	_Cvar_SetValue
	add	esp, 8
$LN18@SV_SetupMo:

; 850  : 		latency = Q_min( latency, sv_maxunlag.value );

	movss	xmm0, DWORD PTR _sv_maxunlag+12
	comiss	xmm0, DWORD PTR _latency$[ebp]
	jbe	SHORT $LN50@SV_SetupMo
	movss	xmm0, DWORD PTR _latency$[ebp]
	movss	DWORD PTR tv185[ebp], xmm0
	jmp	SHORT $LN51@SV_SetupMo
$LN50@SV_SetupMo:
	movss	xmm0, DWORD PTR _sv_maxunlag+12
	movss	DWORD PTR tv185[ebp], xmm0
$LN51@SV_SetupMo:
	movss	xmm0, DWORD PTR tv185[ebp]
	movss	DWORD PTR _latency$[ebp], xmm0
$LN17@SV_SetupMo:

; 851  : 	}
; 852  : 
; 853  : 	lerp_msec = cl->lastcmd.lerp_msec * 0.001f;

	mov	eax, DWORD PTR _cl$[ebp]
	movsx	ecx, WORD PTR [eax+264856]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _lerp_msec$[ebp], xmm0

; 854  : 	if( lerp_msec > 0.1f ) lerp_msec = 0.1f;

	movss	xmm0, DWORD PTR _lerp_msec$[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN19@SV_SetupMo
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _lerp_msec$[ebp], xmm0
$LN19@SV_SetupMo:

; 855  : 
; 856  : 	if( lerp_msec < cl->cl_updaterate )

	cvtss2sd xmm0, DWORD PTR _lerp_msec$[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm1, QWORD PTR [eax+264360]
	comisd	xmm1, xmm0
	jbe	SHORT $LN20@SV_SetupMo

; 857  : 		lerp_msec = cl->cl_updaterate;

	mov	eax, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [eax+264360]
	movss	DWORD PTR _lerp_msec$[ebp], xmm0
$LN20@SV_SetupMo:

; 858  : 
; 859  : 	finalpush = ( host.realtime - latency - lerp_msec ) + sv_unlagpush.value;

	cvtss2sd xmm0, DWORD PTR _latency$[ebp]
	movsd	xmm1, QWORD PTR _host+1440
	subsd	xmm1, xmm0
	cvtss2sd xmm0, DWORD PTR _lerp_msec$[ebp]
	subsd	xmm1, xmm0
	cvtss2sd xmm0, DWORD PTR _sv_unlagpush+12
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _finalpush$[ebp], xmm0

; 860  : 	if( finalpush > host.realtime ) finalpush = host.realtime; // pushed too much ?

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN21@SV_SetupMo
	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _finalpush$[ebp], xmm0
$LN21@SV_SetupMo:

; 861  : 
; 862  : 	frame = frame2 = NULL;

	mov	DWORD PTR _frame2$[ebp], 0
	mov	eax, DWORD PTR _frame2$[ebp]
	mov	DWORD PTR _frame$[ebp], eax

; 863  : 
; 864  : 	for( i = 0; i < SV_UPDATE_BACKUP; i++, frame2 = frame )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_SetupMo
$LN5@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _frame2$[ebp], ecx
$LN7@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SV_UPDATE_BACKUP
	jge	$LN6@SV_SetupMo

; 865  : 	{
; 866  : 		frame = &cl->frames[(cl->netchan.outgoing_sequence - (i + 1)) & SV_UPDATE_MASK];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	sub	edx, eax
	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	and	edx, eax
	imul	ecx, edx, 9296
	mov	edx, DWORD PTR _cl$[ebp]
	add	ecx, DWORD PTR [edx+281884]
	mov	DWORD PTR _frame$[ebp], ecx

; 867  : 
; 868  : 		for( j = 0; j < frame->num_entities; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_SetupMo
$LN8@SV_SetupMo:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_SetupMo:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+9284]
	jge	$LN9@SV_SetupMo

; 869  : 		{
; 870  : 			state = &svs.packet_entities[(frame->first_entity+j)%svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+9288]
	add	eax, DWORD PTR _j$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], ecx

; 871  : 
; 872  : 			if( state->number < 1 || state->number > svs.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN23@SV_SetupMo
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _svs+16
	jle	SHORT $LN22@SV_SetupMo
$LN23@SV_SetupMo:

; 873  : 				continue;

	jmp	SHORT $LN8@SV_SetupMo
$LN22@SV_SetupMo:

; 874  : 
; 875  : 			lerp = &svgame.interp[state->number-1];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	imul	edx, ecx, 88
	add	edx, OFFSET _svgame+8260
	mov	DWORD PTR _lerp$[ebp], edx

; 876  : 			if( lerp->nointerp ) continue;

	mov	eax, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN24@SV_SetupMo
	jmp	SHORT $LN8@SV_SetupMo
$LN24@SV_SetupMo:

; 877  : 
; 878  : 			if( state->health <= 0 || FBitSet( state->effects, EF_NOINTERP ))

	mov	eax, DWORD PTR _state$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+212]
	jae	SHORT $LN26@SV_SetupMo
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 32					; 00000020H
	je	SHORT $LN25@SV_SetupMo
$LN26@SV_SetupMo:

; 879  : 				lerp->nointerp = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+12], 1
$LN25@SV_SetupMo:

; 880  : 
; 881  : 			if( lerp->firstframe )

	mov	eax, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN27@SV_SetupMo

; 882  : 			{
; 883  : 				if( SV_UnlagCheckTeleport( state->origin, lerp->finalpos ))

	mov	eax, DWORD PTR _lerp$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_SV_UnlagCheckTeleport
	add	esp, 8
	test	eax, eax
	je	SHORT $LN29@SV_SetupMo

; 884  : 					lerp->nointerp = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+12], 1
$LN29@SV_SetupMo:

; 885  : 			}

	jmp	SHORT $LN28@SV_SetupMo
$LN27@SV_SetupMo:

; 886  : 			else
; 887  : 			{
; 888  : 				lerp->firstframe = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN28@SV_SetupMo:

; 889  : 			}
; 890  : 
; 891  : 			VectorCopy( state->origin, lerp->finalpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+76], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+76], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+76], eax

; 892  : 		}

	jmp	$LN8@SV_SetupMo
$LN9@SV_SetupMo:

; 893  : 
; 894  : 		if( finalpush > frame->senttime )

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	comisd	xmm0, QWORD PTR [eax]
	jbe	SHORT $LN30@SV_SetupMo

; 895  : 			break;

	jmp	SHORT $LN6@SV_SetupMo
$LN30@SV_SetupMo:

; 896  : 	}

	jmp	$LN5@SV_SetupMo
$LN6@SV_SetupMo:

; 897  : 
; 898  : 	if( i == SV_UPDATE_BACKUP || finalpush - frame->senttime > 1.0 )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SV_UPDATE_BACKUP
	je	SHORT $LN32@SV_SetupMo
	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	subsd	xmm0, QWORD PTR [eax]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN31@SV_SetupMo
$LN32@SV_SetupMo:

; 899  : 	{
; 900  : 		memset( svgame.interp, 0, sizeof( svgame.interp ));

	push	2816					; 00000b00H
	push	0
	push	OFFSET _svgame+8260
	call	_memset
	add	esp, 12					; 0000000cH

; 901  : 		has_update = false;

	mov	DWORD PTR _has_update, 0

; 902  : 		return;

	jmp	$LN12@SV_SetupMo
$LN31@SV_SetupMo:

; 903  : 	}
; 904  : 
; 905  : 	if( !frame2 )

	cmp	DWORD PTR _frame2$[ebp], 0
	jne	SHORT $LN33@SV_SetupMo

; 906  : 	{
; 907  : 		frame2 = frame;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _frame2$[ebp], eax

; 908  : 		lerpFrac = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 909  : 	}

	jmp	$LN36@SV_SetupMo
$LN33@SV_SetupMo:

; 910  : 	else
; 911  : 	{
; 912  : 		if( frame2->senttime - frame->senttime == 0.0 )

	mov	eax, DWORD PTR _frame2$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	subsd	xmm0, QWORD PTR [ecx]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN35@SV_SetupMo

; 913  : 		{
; 914  : 			lerpFrac = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 915  : 		}

	jmp	$LN36@SV_SetupMo
$LN35@SV_SetupMo:

; 916  : 		else
; 917  : 		{
; 918  : 			lerpFrac = (finalpush - frame->senttime) / (frame2->senttime - frame->senttime);

	cvtss2sd xmm0, DWORD PTR _finalpush$[ebp]
	mov	eax, DWORD PTR _frame$[ebp]
	subsd	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR _frame2$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm1, QWORD PTR [ecx]
	subsd	xmm1, QWORD PTR [edx]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _lerpFrac$[ebp], xmm0

; 919  : 			lerpFrac = bound( 0.0f, lerpFrac, 1.0f );

	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN54@SV_SetupMo
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _lerpFrac$[ebp]
	jbe	SHORT $LN52@SV_SetupMo
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	movss	DWORD PTR tv297[ebp], xmm0
	jmp	SHORT $LN53@SV_SetupMo
$LN52@SV_SetupMo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv297[ebp], xmm0
$LN53@SV_SetupMo:
	movss	xmm0, DWORD PTR tv297[ebp]
	movss	DWORD PTR tv298[ebp], xmm0
	jmp	SHORT $LN55@SV_SetupMo
$LN54@SV_SetupMo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv298[ebp], xmm0
$LN55@SV_SetupMo:
	movss	xmm0, DWORD PTR tv298[ebp]
	movss	DWORD PTR _lerpFrac$[ebp], xmm0
$LN36@SV_SetupMo:

; 920  : 		}
; 921  : 	}
; 922  : 
; 923  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@SV_SetupMo
$LN11@SV_SetupMo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@SV_SetupMo:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+9284]
	jge	$LN12@SV_SetupMo

; 924  : 	{
; 925  : 		state = &svs.packet_entities[(frame->first_entity+i)%svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+9288]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], ecx

; 926  : 
; 927  : 		if( state->number < 1 || state->number > svs.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN38@SV_SetupMo
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _svs+16
	jle	SHORT $LN37@SV_SetupMo
$LN38@SV_SetupMo:

; 928  : 			continue;

	jmp	SHORT $LN11@SV_SetupMo
$LN37@SV_SetupMo:

; 929  : 
; 930  : 		clientnum = state->number - 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _clientnum$[ebp], ecx

; 931  : 		check = &svs.clients[clientnum];

	imul	eax, DWORD PTR _clientnum$[ebp], 289832
	add	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _check$[ebp], eax

; 932  : 
; 933  : 		if( check->state != cs_spawned || check == cl )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN40@SV_SetupMo
	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	jne	SHORT $LN39@SV_SetupMo
$LN40@SV_SetupMo:

; 934  : 			continue;

	jmp	$LN11@SV_SetupMo
$LN39@SV_SetupMo:

; 935  : 
; 936  : 		lerp = &svgame.interp[clientnum];

	imul	eax, DWORD PTR _clientnum$[ebp], 88
	add	eax, OFFSET _svgame+8260
	mov	DWORD PTR _lerp$[ebp], eax

; 937  : 
; 938  : 		if( !lerp->active || lerp->nointerp )

	mov	eax, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN42@SV_SetupMo
	mov	eax, DWORD PTR _lerp$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN41@SV_SetupMo
$LN42@SV_SetupMo:

; 939  : 			continue;

	jmp	$LN11@SV_SetupMo
$LN41@SV_SetupMo:

; 940  : 
; 941  : 		lerpstate = SV_FindEntInPack( state->number, frame2 );

	mov	eax, DWORD PTR _frame2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_SV_FindEntInPack
	add	esp, 8
	mov	DWORD PTR _lerpstate$[ebp], eax

; 942  : 
; 943  : 		if( !lerpstate )

	cmp	DWORD PTR _lerpstate$[ebp], 0
	jne	SHORT $LN43@SV_SetupMo

; 944  : 		{
; 945  : 			VectorCopy( state->origin, curpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _curpos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _curpos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _curpos$[ebp+ecx], eax

; 946  : 		}

	jmp	$LN44@SV_SetupMo
$LN43@SV_SetupMo:

; 947  : 		else
; 948  : 		{
; 949  : 			VectorSubtract( lerpstate->origin, state->origin, newpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _newpos$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax+16]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _newpos$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lerpstate$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+16]
	movss	DWORD PTR tv370[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv370[ebp]
	movss	DWORD PTR _newpos$[ebp+eax], xmm0

; 950  : 			VectorMA( state->origin, lerpFrac, newpos, curpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+eax]
	mov	edx, DWORD PTR _state$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _curpos$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+eax]
	mov	ecx, DWORD PTR _state$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx+16]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _curpos$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _lerpFrac$[ebp]
	mulss	xmm0, DWORD PTR _newpos$[ebp+ecx]
	mov	edx, DWORD PTR _state$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+16]
	addss	xmm1, xmm0
	movss	DWORD PTR tv397[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR _curpos$[ebp+eax], xmm0
$LN44@SV_SetupMo:

; 951  : 		}
; 952  : 
; 953  : 		VectorCopy( curpos, lerp->curpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [edx+eax+40], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [ecx+eax+40], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+40], eax

; 954  : 		VectorCopy( curpos, lerp->newpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [edx+eax+64], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lerp$[ebp]
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [ecx+eax+64], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lerp$[ebp]
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+64], eax

; 955  : 
; 956  : 		if( !VectorCompare( curpos, check->edict->v.origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264948]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _curpos$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR [eax+edx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@SV_SetupMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _curpos$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@SV_SetupMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _curpos$[ebp+eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+136]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN45@SV_SetupMo
$LN46@SV_SetupMo:

; 957  : 		{
; 958  : 			VectorCopy( curpos, check->edict->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+264948]
	mov	edx, 4
	imul	edx, edx, 0
	mov	ecx, DWORD PTR _curpos$[ebp+ecx]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _curpos$[ebp+edx]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _curpos$[ebp+eax]
	mov	DWORD PTR [edx+ecx+136], eax

; 959  : 			SV_LinkEdict( check->edict, false );

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	_SV_LinkEdict
	add	esp, 8

; 960  : 			lerp->moving = true;

	mov	eax, DWORD PTR _lerp$[ebp]
	mov	DWORD PTR [eax+4], 1
$LN45@SV_SetupMo:

; 961  : 		}
; 962  : 	}

	jmp	$LN11@SV_SetupMo
$LN12@SV_SetupMo:

; 963  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetupMoveInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_UnlagCheckTeleport
_TEXT	SEGMENT
tv85 = -76						; size = 8
_i$ = -4						; size = 4
_old_pos$ = 8						; size = 4
_new_pos$ = 12						; size = 4
_SV_UnlagCheckTeleport PROC				; COMDAT

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 802  : 	int	i;
; 803  : 
; 804  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_UnlagCh
$LN2@SV_UnlagCh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_UnlagCh:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_UnlagCh

; 805  : 	{
; 806  : 		if( fabs( old_pos[i] - new_pos[i] ) > 64.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _old_pos$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _new_pos$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv85[ebp]
	movsd	xmm0, QWORD PTR tv85[ebp]
	comisd	xmm0, QWORD PTR __real@4050000000000000
	jbe	SHORT $LN5@SV_UnlagCh

; 807  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_UnlagCh
$LN5@SV_UnlagCh:

; 808  : 	}

	jmp	SHORT $LN2@SV_UnlagCh
$LN3@SV_UnlagCh:

; 809  : 	return false;

	xor	eax, eax
$LN1@SV_UnlagCh:

; 810  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UnlagCheckTeleport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_FindEntInPack
_TEXT	SEGMENT
_i$ = -8						; size = 4
_state$ = -4						; size = 4
_index$ = 8						; size = 4
_frame$ = 12						; size = 4
_SV_FindEntInPack PROC					; COMDAT

; 786  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 787  : 	entity_state_t	*state;
; 788  : 	int		i;	
; 789  : 
; 790  : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_FindEnt
$LN2@SV_FindEnt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_FindEnt:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+9284]
	jge	SHORT $LN3@SV_FindEnt

; 791  : 	{
; 792  : 		state = &svs.packet_entities[(frame->first_entity+i)%svs.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+9288]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _svs+33348
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _svs+33356
	mov	DWORD PTR _state$[ebp], ecx

; 793  : 
; 794  : 		if( state->number == index )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _index$[ebp]
	jne	SHORT $LN5@SV_FindEnt

; 795  : 			return state;

	mov	eax, DWORD PTR _state$[ebp]
	jmp	SHORT $LN1@SV_FindEnt
$LN5@SV_FindEnt:

; 796  : 	}

	jmp	SHORT $LN2@SV_FindEnt
$LN3@SV_FindEnt:

; 797  : 	return NULL;

	xor	eax, eax
$LN1@SV_FindEnt:

; 798  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEntInPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_FinishPMove
_TEXT	SEGMENT
_clent$ = -4						; size = 4
_pmove$ = 8						; size = 4
_cl$ = 12						; size = 4
_SV_FinishPMove PROC					; COMDAT

; 719  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 720  : 	edict_t	*clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _clent$[ebp], ecx

; 721  : 
; 722  : 	clent->v.teleport_time = pmove->waterjumptime;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+668], edx

; 723  : 	VectorCopy( pmove->origin, clent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+56]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+56]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+56]
	mov	DWORD PTR [edx+ecx+136], eax

; 724  : 	VectorCopy( pmove->view_ofs, clent->v.view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+128]
	mov	DWORD PTR [edx+eax+608], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+128]
	mov	DWORD PTR [ecx+eax+608], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+128]
	mov	DWORD PTR [edx+ecx+608], eax

; 725  : 	VectorCopy( pmove->velocity, clent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+160], eax

; 726  : 	VectorCopy( pmove->basevelocity, clent->v.basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+116]
	mov	DWORD PTR [edx+eax+172], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+116]
	mov	DWORD PTR [ecx+eax+172], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+116]
	mov	DWORD PTR [edx+ecx+172], eax

; 727  : 	VectorCopy( pmove->punchangle, clent->v.punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [edx+eax+232], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [ecx+eax+232], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+232], eax

; 728  : 	VectorCopy( pmove->movedir, clent->v.movedir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+104]
	mov	DWORD PTR [edx+eax+196], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+104]
	mov	DWORD PTR [ecx+eax+196], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+104]
	mov	DWORD PTR [edx+ecx+196], eax

; 729  : 	clent->v.flTimeStepSound = pmove->flTimeStepSound;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR [eax+772], edx

; 730  : 	clent->v.flFallVelocity = pmove->flFallVelocity;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	DWORD PTR [eax+788], edx

; 731  : 	clent->v.oldbuttons = pmove->oldbuttons;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR [eax+796], edx

; 732  : 	clent->v.waterlevel = pmove->waterlevel;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+672], edx

; 733  : 	clent->v.watertype = pmove->watertype;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	mov	DWORD PTR [eax+676], edx

; 734  : 	clent->v.maxspeed = pmove->clientmaxspeed;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR [eax+752], edx

; 735  : 	clent->v.flDuckTime = pmove->flDuckTime;

	mov	eax, DWORD PTR _pmove$[ebp]
	cvttss2si ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+780], ecx

; 736  : 	clent->v.flSwimTime = pmove->flSwimTime;

	mov	eax, DWORD PTR _pmove$[ebp]
	cvttss2si ecx, DWORD PTR [eax+172]
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+776], ecx

; 737  : 	clent->v.iStepLeft = pmove->iStepLeft;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	DWORD PTR [eax+784], edx

; 738  : 	clent->v.movetype = pmove->movetype;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR [eax+396], edx

; 739  : 	clent->v.friction = pmove->friction;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+456], edx

; 740  : 	clent->v.deadflag = pmove->deadflag;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+212]
	mov	DWORD PTR [eax+604], edx

; 741  : 	clent->v.effects = pmove->effects;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR [eax+448], edx

; 742  : 	clent->v.bInDuck = pmove->bInDuck;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+768], edx

; 743  : 	clent->v.flags = pmove->flags;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR [eax+656], edx

; 744  : 
; 745  : 	// copy back user variables
; 746  : 	clent->v.iuser1 = pmove->iuser1;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	mov	DWORD PTR [eax+804], edx

; 747  : 	clent->v.iuser2 = pmove->iuser2;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+512]
	mov	DWORD PTR [eax+808], edx

; 748  : 	clent->v.iuser3 = pmove->iuser3;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [eax+812], edx

; 749  : 	clent->v.iuser4 = pmove->iuser4;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+520]
	mov	DWORD PTR [eax+816], edx

; 750  : 	clent->v.fuser1 = pmove->fuser1;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+524]
	mov	DWORD PTR [eax+820], edx

; 751  : 	clent->v.fuser2 = pmove->fuser2;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+528]
	mov	DWORD PTR [eax+824], edx

; 752  : 	clent->v.fuser3 = pmove->fuser3;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	DWORD PTR [eax+828], edx

; 753  : 	clent->v.fuser4 = pmove->fuser4;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR [eax+832], edx

; 754  : 	VectorCopy( pmove->vuser1, clent->v.vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+540]
	mov	DWORD PTR [edx+eax+836], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+540]
	mov	DWORD PTR [ecx+eax+836], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+540]
	mov	DWORD PTR [edx+ecx+836], eax

; 755  : 	VectorCopy( pmove->vuser2, clent->v.vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+552]
	mov	DWORD PTR [edx+eax+848], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+552]
	mov	DWORD PTR [ecx+eax+848], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+552]
	mov	DWORD PTR [edx+ecx+848], eax

; 756  : 	VectorCopy( pmove->vuser3, clent->v.vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+564]
	mov	DWORD PTR [edx+eax+860], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+564]
	mov	DWORD PTR [ecx+eax+860], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+564]
	mov	DWORD PTR [edx+ecx+860], eax

; 757  : 	VectorCopy( pmove->vuser4, clent->v.vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+576]
	mov	DWORD PTR [edx+eax+872], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+576]
	mov	DWORD PTR [ecx+eax+872], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+576]
	mov	DWORD PTR [edx+ecx+872], eax

; 758  : 
; 759  : 	if( pmove->onground == -1 )

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+224], -1
	jne	SHORT $LN2@SV_FinishP

; 760  : 	{
; 761  : 		clent->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 762  : 	}

	jmp	SHORT $LN4@SV_FinishP
$LN2@SV_FinishP:

; 763  : 	else if( pmove->onground >= 0 && pmove->onground < pmove->numphysent )

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+224], 0
	jl	SHORT $LN4@SV_FinishP
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [eax+224]
	cmp	edx, DWORD PTR [ecx+588]
	jge	SHORT $LN4@SV_FinishP

; 764  : 	{
; 765  : 		clent->v.flags |= FL_ONGROUND;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 766  : 		clent->v.groundentity = EDICT_NUM( pmove->physents[pmove->onground].info );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+224], 224
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [edx+ecx+672]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [ecx+648], eax
$LN4@SV_FinishP:

; 767  : 	}
; 768  : 
; 769  : 	// angles
; 770  : 	// show 1/3 the pitch angle and all the roll angle	
; 771  : 	if( !clent->v.fixangle )

	mov	eax, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	$LN5@SV_FinishP

; 772  : 	{
; 773  : 		VectorCopy( pmove->angles, clent->v.v_angle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+68]
	mov	DWORD PTR [edx+eax+244], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR [esi+edx+68]
	mov	DWORD PTR [ecx+eax+244], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [esi+eax+68]
	mov	DWORD PTR [edx+ecx+244], eax

; 774  : 		clent->v.angles[PITCH] = -( clent->v.v_angle[PITCH] / 3.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+244]
	divss	xmm0, DWORD PTR __real@40400000
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clent$[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0

; 775  : 		clent->v.angles[ROLL] = clent->v.v_angle[ROLL];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+208], eax

; 776  : 		clent->v.angles[YAW] = clent->v.v_angle[YAW];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+208], eax
$LN5@SV_FinishP:

; 777  : 	}
; 778  : 
; 779  : 	SV_SetMinMaxSize( clent, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], false );

	push	0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324856]
	push	ecx
	mov	edx, DWORD PTR _clent$[ebp]
	push	edx
	call	_SV_SetMinMaxSize
	add	esp, 16					; 00000010H

; 780  : 
; 781  : 	// all next calls ignore footstep sounds
; 782  : 	pmove->runfuncs = false;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+325044], 0

; 783  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FinishPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_SetupPMove
_TEXT	SEGMENT
tv297 = -104						; size = 4
tv250 = -104						; size = 4
tv77 = -104						; size = 4
_i$ = -36						; size = 4
_clent$ = -32						; size = 4
_absmax$ = -28						; size = 12
_absmin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_cl$ = 12						; size = 4
_ucmd$ = 16						; size = 4
_physinfo$ = 20						; size = 4
_SV_SetupPMove PROC					; COMDAT

; 639  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 640  : 	vec3_t	absmin, absmax;
; 641  : 	edict_t	*clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _clent$[ebp], ecx

; 642  : 	int	i;
; 643  : 
; 644  : 	svgame.globals->frametime = (ucmd->msec * 0.001f);

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3a83126f
	mov	edx, DWORD PTR _svgame+19268
	movss	DWORD PTR [edx+4], xmm0

; 645  : 
; 646  : 	pmove->player_index = NUM_FOR_EDICT( clent ) - 1;

	mov	eax, DWORD PTR _clent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	sub	eax, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [edx], eax

; 647  : 	pmove->multiplayer = (svs.maxclients > 1) ? true : false;

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN7@SV_SetupPM
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN8@SV_SetupPM
$LN7@SV_SetupPM:
	mov	DWORD PTR tv77[ebp], 0
$LN8@SV_SetupPM:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR [eax+8], ecx

; 648  : 	pmove->time = (float)(cl->timebase * 1000.0);

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [eax+264368]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 649  : 	VectorCopy( clent->v.origin, pmove->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+56], eax

; 650  : 	VectorCopy( clent->v.v_angle, pmove->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+68], eax

; 651  : 	VectorCopy( clent->v.v_angle, pmove->oldangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [edx+eax+80], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+80], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+80], eax

; 652  : 	VectorCopy( clent->v.velocity, pmove->velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+160]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+160]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+160]
	mov	DWORD PTR [edx+ecx+92], eax

; 653  : 	VectorCopy( clent->v.basevelocity, pmove->basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+172]
	mov	DWORD PTR [edx+eax+116], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+172]
	mov	DWORD PTR [ecx+eax+116], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+172]
	mov	DWORD PTR [edx+ecx+116], eax

; 654  : 	VectorCopy( clent->v.view_ofs, pmove->view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+608]
	mov	DWORD PTR [edx+eax+128], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+608]
	mov	DWORD PTR [ecx+eax+128], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+608]
	mov	DWORD PTR [edx+ecx+128], eax

; 655  : 	VectorCopy( clent->v.movedir, pmove->movedir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+196]
	mov	DWORD PTR [edx+eax+104], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+196]
	mov	DWORD PTR [ecx+eax+104], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+196]
	mov	DWORD PTR [edx+ecx+104], eax

; 656  : 	pmove->flDuckTime = clent->v.flDuckTime;

	mov	eax, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+780]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+140], xmm0

; 657  : 	pmove->bInDuck = clent->v.bInDuck;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+768]
	mov	DWORD PTR [eax+144], edx

; 658  : 	pmove->usehull = (clent->v.flags & FL_DUCKING) ? 1 : 0; // reset hull

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN9@SV_SetupPM
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN10@SV_SetupPM
$LN9@SV_SetupPM:
	mov	DWORD PTR tv250[ebp], 0
$LN10@SV_SetupPM:
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR tv250[ebp]
	mov	DWORD PTR [edx+188], eax

; 659  : 	pmove->flTimeStepSound = clent->v.flTimeStepSound;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+772]
	mov	DWORD PTR [eax+148], edx

; 660  : 	pmove->iStepLeft = clent->v.iStepLeft;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+784]
	mov	DWORD PTR [eax+152], edx

; 661  : 	pmove->flFallVelocity = clent->v.flFallVelocity;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+788]
	mov	DWORD PTR [eax+156], edx

; 662  : 	pmove->flSwimTime = clent->v.flSwimTime;

	mov	eax, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+776]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+172], xmm0

; 663  : 	VectorCopy( clent->v.punchangle, pmove->punchangle );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+232]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+232]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+232]
	mov	DWORD PTR [edx+ecx+160], eax

; 664  : 	pmove->flSwimTime = clent->v.flSwimTime;

	mov	eax, DWORD PTR _clent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+776]
	mov	ecx, DWORD PTR _pmove$[ebp]
	movss	DWORD PTR [ecx+172], xmm0

; 665  : 	pmove->flNextPrimaryAttack = 0.0f; // not used by PM_ code

	mov	eax, DWORD PTR _pmove$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+176], xmm0

; 666  : 	pmove->effects = clent->v.effects;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+448]
	mov	DWORD PTR [eax+180], edx

; 667  : 	pmove->flags = clent->v.flags;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	mov	DWORD PTR [eax+184], edx

; 668  : 	pmove->gravity = clent->v.gravity;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+452]
	mov	DWORD PTR [eax+192], edx

; 669  : 	pmove->friction = clent->v.friction;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+456]
	mov	DWORD PTR [eax+196], edx

; 670  : 	pmove->oldbuttons = clent->v.oldbuttons;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+796]
	mov	DWORD PTR [eax+200], edx

; 671  : 	pmove->waterjumptime = clent->v.teleport_time;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+668]
	mov	DWORD PTR [eax+204], edx

; 672  : 	pmove->dead = (clent->v.health <= 0.0f ) ? true : false;

	mov	eax, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+520]
	jb	SHORT $LN11@SV_SetupPM
	mov	DWORD PTR tv297[ebp], 1
	jmp	SHORT $LN12@SV_SetupPM
$LN11@SV_SetupPM:
	mov	DWORD PTR tv297[ebp], 0
$LN12@SV_SetupPM:
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	edx, DWORD PTR tv297[ebp]
	mov	DWORD PTR [ecx+208], edx

; 673  : 	pmove->deadflag = clent->v.deadflag;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+604]
	mov	DWORD PTR [eax+212], edx

; 674  : 	pmove->spectator = 0; // spectator physic all execute on client

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+216], 0

; 675  : 	pmove->movetype = clent->v.movetype;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	DWORD PTR [eax+220], edx

; 676  : 	if( pmove->multiplayer ) pmove->onground = -1;

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@SV_SetupPM
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+224], -1
$LN5@SV_SetupPM:

; 677  : 	pmove->waterlevel = clent->v.waterlevel;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR [eax+228], edx

; 678  : 	pmove->watertype = clent->v.watertype;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+676]
	mov	DWORD PTR [eax+232], edx

; 679  : 	pmove->maxspeed = svgame.movevars.maxspeed;

	mov	eax, DWORD PTR _pmove$[ebp]
	movss	xmm0, DWORD PTR _svgame+7944
	movss	DWORD PTR [eax+500], xmm0

; 680  : 	pmove->clientmaxspeed = clent->v.maxspeed;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+752]
	mov	DWORD PTR [eax+504], edx

; 681  : 	pmove->iuser1 = clent->v.iuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	mov	DWORD PTR [eax+508], edx

; 682  : 	pmove->iuser2 = clent->v.iuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR [eax+512], edx

; 683  : 	pmove->iuser3 = clent->v.iuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+812]
	mov	DWORD PTR [eax+516], edx

; 684  : 	pmove->iuser4 = clent->v.iuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+816]
	mov	DWORD PTR [eax+520], edx

; 685  : 	pmove->fuser1 = clent->v.fuser1;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	DWORD PTR [eax+524], edx

; 686  : 	pmove->fuser2 = clent->v.fuser2;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+824]
	mov	DWORD PTR [eax+528], edx

; 687  : 	pmove->fuser3 = clent->v.fuser3;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+828]
	mov	DWORD PTR [eax+532], edx

; 688  : 	pmove->fuser4 = clent->v.fuser4;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	DWORD PTR [eax+536], edx

; 689  : 	VectorCopy( clent->v.vuser1, pmove->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+836]
	mov	DWORD PTR [edx+eax+540], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+836]
	mov	DWORD PTR [ecx+eax+540], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+836]
	mov	DWORD PTR [edx+ecx+540], eax

; 690  : 	VectorCopy( clent->v.vuser2, pmove->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+848]
	mov	DWORD PTR [edx+eax+552], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+848]
	mov	DWORD PTR [ecx+eax+552], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+848]
	mov	DWORD PTR [edx+ecx+552], eax

; 691  : 	VectorCopy( clent->v.vuser3, pmove->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+860]
	mov	DWORD PTR [edx+eax+564], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+860]
	mov	DWORD PTR [ecx+eax+564], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+860]
	mov	DWORD PTR [edx+ecx+564], eax

; 692  : 	VectorCopy( clent->v.vuser4, pmove->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	DWORD PTR [edx+eax+576], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+872]
	mov	DWORD PTR [ecx+eax+576], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	DWORD PTR [edx+ecx+576], eax

; 693  : 	pmove->cmd = *ucmd;	// setup current cmds	

	mov	edi, DWORD PTR _pmove$[ebp]
	add	edi, 283736				; 00045458H
	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR _ucmd$[ebp]
	rep movsd

; 694  : 	pmove->runfuncs = true;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+325044], 1

; 695  : 	
; 696  : 	Q_strncpy( pmove->physinfo, physinfo, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _physinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	add	ecx, 324596				; 0004f3f4H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 697  : 
; 698  : 	// setup physents
; 699  : 	pmove->numvisent = 0;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+149332], 0

; 700  : 	pmove->numphysent = 0;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+588], 0

; 701  : 	pmove->nummoveent = 0;

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	DWORD PTR [eax+134992], 0

; 702  : 
; 703  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SetupPM
$LN2@SV_SetupPM:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_SetupPM:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_SetupPM

; 704  : 	{
; 705  : 		absmin[i] = clent->v.origin[i] - 256.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+136]
	subss	xmm0, DWORD PTR __real@43800000
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _absmin$[ebp+edx*4], xmm0

; 706  : 		absmax[i] = clent->v.origin[i] + 256.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+136]
	addss	xmm0, DWORD PTR __real@43800000
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _absmax$[ebp+edx*4], xmm0

; 707  : 	}

	jmp	SHORT $LN2@SV_SetupPM
$LN3@SV_SetupPM:

; 708  : 
; 709  : 	SV_CopyEdictToPhysEnt( &svgame.pmove->physents[0], &svgame.edicts[0] );

	mov	eax, 900				; 00000384H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _svgame+7928
	push	ecx
	mov	edx, 224				; 000000e0H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+592]
	push	edx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8

; 710  : 	svgame.pmove->visents[0] = svgame.pmove->physents[0];

	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8256
	lea	esi, DWORD PTR [edx+ecx+592]
	mov	eax, 224				; 000000e0H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _svgame+8256
	lea	edi, DWORD PTR [edx+ecx+149336]
	mov	ecx, 56					; 00000038H
	rep movsd

; 711  : 	svgame.pmove->numphysent = 1;	// always have world

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+588], 1

; 712  : 	svgame.pmove->numvisent = 1;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+149332], 1

; 713  : 
; 714  : 	SV_AddLinksToPmove( sv_areanodes, absmin, absmax );

	lea	eax, DWORD PTR _absmax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _absmin$[ebp]
	push	ecx
	push	OFFSET _sv_areanodes
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH

; 715  : 	SV_AddLaddersToPmove( sv_areanodes, absmin, absmax );

	lea	eax, DWORD PTR _absmax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _absmin$[ebp]
	push	ecx
	push	OFFSET _sv_areanodes
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH

; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetupPMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _PM_CheckMovingGround
_TEXT	SEGMENT
tv146 = -68						; size = 4
_ent$ = 8						; size = 4
_frametime$ = 12					; size = 4
_PM_CheckMovingGround PROC				; COMDAT

; 618  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 619  : 	if( svgame.physFuncs.SV_UpdatePlayerBaseVelocity != NULL )

	cmp	DWORD PTR _svgame+19508, 0
	je	SHORT $LN2@PM_CheckMo

; 620  : 	{
; 621  : 		svgame.physFuncs.SV_UpdatePlayerBaseVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19508
	add	esp, 4

; 622  : 	}

	jmp	SHORT $LN3@PM_CheckMo
$LN2@PM_CheckMo:

; 623  : 	else
; 624  : 	{
; 625  : 		SV_UpdateBaseVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_UpdateBaseVelocity
	add	esp, 4
$LN3@PM_CheckMo:

; 626  : 	}
; 627  : 
; 628  : 	if( !FBitSet( ent->v.flags, FL_BASEVELOCITY ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 4194304				; 00400000H
	jne	$LN4@PM_CheckMo

; 629  : 	{
; 630  : 		// apply momentum (add in half of the previous frame of velocity first)
; 631  : 		VectorMA( ent->v.velocity, 1.0f + (frametime * 0.5f), ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+172]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+160]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+172]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+160]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+172]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+160]
	addss	xmm1, xmm0
	movss	DWORD PTR tv146[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv146[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0

; 632  : 		VectorClear( ent->v.basevelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+172], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+172], xmm0
$LN4@PM_CheckMo:

; 633  : 	}
; 634  : 
; 635  : 	ClearBits( ent->v.flags, FL_BASEVELOCITY );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -4194305				; ffbfffffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 636  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_CheckMovingGround ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTraceSurface
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC					; COMDAT

; 543  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 544  : 	physent_t *pe;
; 545  : 
; 546  : 	if( ground < 0 || ground >= svgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 547  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 548  : 
; 549  : 	pe = &svgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 550  : 	return PM_TraceSurface( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 551  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTraceLineEx
_TEXT	SEGMENT
tv66 = -208						; size = 4
$T1 = -204						; size = 68
$T2 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_pmFilter$ = 24						; size = 4
_pfnTraceLineEx PROC					; COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 521  : 	static pmtrace_t	tr;
; 522  : 	int		old_usehull;
; 523  : 
; 524  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 525  : 	svgame.pmove->usehull = usehull;	

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 526  : 
; 527  : 	switch( flags )

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 528  : 	{
; 529  : 	case PM_TRACELINE_PHYSENTSONLY:
; 530  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numphysent, svgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd

; 531  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 532  : 	case PM_TRACELINE_ANYVISIBLE:
; 533  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numvisent, svgame.pmove->visents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 149336				; 00024758H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+149332]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLineEx@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 534  : 		break;
; 535  : 	}
; 536  : 
; 537  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 538  : 
; 539  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLineEx@@9@9

; 540  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLineEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTestPlayerPositionEx
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pmFilter$ = 16						; size = 4
_pfnTestPlayerPositionEx PROC				; COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 516  : 	return PM_TestPlayerPosition( svgame.pmove, pos, ptrace, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptrace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 517  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTestPlayerPositionEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnPlayerTraceEx
_TEXT	SEGMENT
$T1 = -132						; size = 68
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_pmFilter$ = 24						; size = 4
_pfnPlayerTraceEx PROC					; COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 511  : 	return PM_PlayerTraceExt( svgame.pmove, start, end, traceFlags, svgame.pmove->numphysent, svgame.pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 512  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTraceEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnPlaybackEventFull
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_flags$ = 8						; size = 4
_clientindex$ = 12					; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_vparam1$ = 56						; size = 4
_vparam2$ = 60						; size = 4
_aparam1$ = 64						; size = 4
_aparam2$ = 68						; size = 4
_aparam3$ = 72						; size = 1
_pfnPlaybackEventFull PROC				; COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 491  : 	edict_t* ent;
; 492  : 
; 493  : 	ent = EDICT_NUM(clientindex + 1);

	mov	eax, DWORD PTR _clientindex$[ebp]
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 494  : 	if (!SV_IsValidEdict(ent)) return;

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPlaybackEventFull@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnPlaybac
	jmp	SHORT $LN1@pfnPlaybac
$LN2@pfnPlaybac:

; 495  : 
; 496  : 	if (host.type == HOST_DEDICATED)

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN3@pfnPlaybac

; 497  : 		flags |= FEV_NOTHOST; // no local clients for dedicated server

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1
	mov	DWORD PTR _flags$[ebp], eax
$LN3@pfnPlaybac:

; 498  : 
; 499  : 	SV_PlaybackEventFull(flags, ent, eventindex,

	movzx	eax, BYTE PTR _aparam3$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _aparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aparam1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vparam2$[ebp]
	push	edx
	mov	eax, DWORD PTR _vparam1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bparam2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bparam1$[ebp]
	push	edx
	mov	eax, DWORD PTR _iparam2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iparam1$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	eax, DWORD PTR _origin$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _eventindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	call	_SV_PlaybackEventFull
	add	esp, 68					; 00000044H
$LN1@pfnPlaybac:

; 500  : 		delay, origin, angles,
; 501  : 		fparam1, fparam2,
; 502  : 		iparam1, iparam2,
; 503  : 		bparam1, bparam2,
; 504  : 		vparam1, vparam2,
; 505  : 		aparam1, aparam2,
; 506  : 		aparam3);
; 507  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaybackEventFull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnPlaySound
_TEXT	SEGMENT
_ent$ = -4						; size = 4
_channel$ = 8						; size = 4
_sample$ = 12						; size = 4
_volume$ = 16						; size = 4
_attenuation$ = 20					; size = 4
_fFlags$ = 24						; size = 4
_pitch$ = 28						; size = 4
_pfnPlaySound PROC					; COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 480  : 	edict_t	*ent;
; 481  : 
; 482  : 	ent = EDICT_NUM( svgame.pmove->player_index + 1 );

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 483  : 	if( !SV_IsValidEdict( ent )) return;

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnPlaySound@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@pfnPlaySou
	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 484  : 
; 485  : 	SV_StartSound( ent, channel, sample, volume, attenuation, fFlags|SND_FILTER_CLIENT, pitch );

	mov	eax, DWORD PTR _pitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fFlags$[ebp]
	or	ecx, 2048				; 00000800H
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attenuation$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_StartSound
	add	esp, 28					; 0000001cH
$LN1@pfnPlaySou:

; 486  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTraceTexture
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC					; COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 469  : 	physent_t *pe;
; 470  : 
; 471  : 	if( ground < 0 || ground >= svgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 472  : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 473  : 
; 474  : 	pe = &svgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 475  : 	return PM_TraceTexture( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 476  : }			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTraceModel
_TEXT	SEGMENT
tv248 = -196						; size = 4
tv170 = -196						; size = 4
tv149 = -196						; size = 4
_hull$ = -128						; size = 4
_matrix$ = -124						; size = 64
_rotated$ = -60						; size = 4
_temp$ = -56						; size = 12
_offset$ = -44						; size = 12
_end_l$ = -32						; size = 12
_start_l$ = -20						; size = 12
_old_usehull$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_trace$ = 20						; size = 4
_pfnTraceModel PROC					; COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 423  : 	int	old_usehull;
; 424  : 	vec3_t	start_l, end_l;
; 425  : 	vec3_t	offset, temp;
; 426  : 	qboolean	rotated;
; 427  : 	matrix4x4	matrix;
; 428  : 	hull_t	*hull;
; 429  : 
; 430  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 431  : 	svgame.pmove->usehull = 2;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+188], 2

; 432  : 
; 433  : 	hull = PM_HullForBsp( pe, svgame.pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 434  : 
; 435  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 436  : 
; 437  : 	if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	SHORT $LN2@pfnTraceMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@pfnTraceMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@pfnTraceMo
$LN4@pfnTraceMo:

; 438  : 		rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN3@pfnTraceMo
$LN2@pfnTraceMo:

; 439  : 	else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN3@pfnTraceMo:

; 440  : 
; 441  :  	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN5@pfnTraceMo

; 442  :  	{
; 443  :  		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 444  :  		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 445  :  		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 446  :  	}

	jmp	$LN6@pfnTraceMo
$LN5@pfnTraceMo:

; 447  :  	else
; 448  :  	{
; 449  :  		VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv149[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 450  :  		VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN6@pfnTraceMo:

; 451  :  	}
; 452  : 
; 453  : 	PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, (pmtrace_t *)trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 454  : 	trace->ent = NULL;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+48], 0

; 455  : 
; 456  : 	if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN7@pfnTraceMo

; 457  : 	{
; 458  : 		VectorCopy( trace->plane.normal, temp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR _temp$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _temp$[ebp+ecx], eax

; 459  : 		Matrix4x4_TransformPositivePlane( matrix, temp, trace->plane.dist, trace->plane.normal, &trace->plane.dist );

	mov	eax, DWORD PTR _trace$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _trace$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H
$LN7@pfnTraceMo:

; 460  : 	}
; 461  : 
; 462  : 	VectorLerp( start, trace->fraction, end, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [edx+16]
	mov	eax, 4
	imul	edx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+edx]
	subss	xmm1, DWORD PTR [edi+ecx]
	mulss	xmm0, xmm1
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	subss	xmm1, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv248[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv248[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 463  : 
; 464  : 	return trace->fraction;

	mov	eax, DWORD PTR _trace$[ebp]
	fld	DWORD PTR [eax+16]

; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnHullForBsp
_TEXT	SEGMENT
_pe$ = 8						; size = 4
_offset$ = 12						; size = 4
_pfnHullForBsp PROC					; COMDAT

; 417  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 418  : 	return PM_HullForBsp( pe, svgame.pmove, offset );

	mov	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTraceLine
_TEXT	SEGMENT
tv66 = -208						; size = 4
$T1 = -204						; size = 68
$T2 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC					; COMDAT

; 394  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 395  : 	static pmtrace_t	tr;
; 396  : 	int		old_usehull;
; 397  : 
; 398  : 	old_usehull = svgame.pmove->usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 399  : 	svgame.pmove->usehull = usehull;	

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 400  : 
; 401  : 	switch( flags )

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 402  : 	{
; 403  : 	case PM_TRACELINE_PHYSENTSONLY:
; 404  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numphysent, svgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 405  : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 406  : 	case PM_TRACELINE_ANYVISIBLE:
; 407  : 		tr = PM_PlayerTraceExt( svgame.pmove, start, end, 0, svgame.pmove->numvisent, svgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 149336				; 00024758H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+149332]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 408  : 		break;
; 409  : 	}
; 410  : 
; 411  : 	svgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 412  : 
; 413  : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 414  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnPlayerTrace
_TEXT	SEGMENT
$T1 = -132						; size = 68
__$ReturnAddress$ = 8					; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_traceFlags$ = 20					; size = 4
_ignore_pe$ = 24					; size = 4
_pfnPlayerTrace PROC					; COMDAT

; 389  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 390  : 	return PM_PlayerTraceExt( svgame.pmove, start, end, traceFlags, svgame.pmove->numphysent, svgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 391  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnHullPointContents
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_pfnHullPointContents PROC				; COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 385  : 	return PM_HullPointContents( hull, num, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH

; 386  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTruePointContents
_TEXT	SEGMENT
_p$ = 8							; size = 4
_pfnTruePointContents PROC				; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 380  : 	return SV_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_SV_TruePointContents
	add	esp, 4

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTruePointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnPointContents
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC					; COMDAT

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 368  : 	int	cont, truecont;
; 369  : 
; 370  : 	truecont = cont = SV_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_SV_TruePointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], ecx

; 371  : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 372  : 
; 373  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 374  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 375  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnStuckTouch
_TEXT	SEGMENT
_i$ = -4						; size = 4
_hitent$ = 8						; size = 4
_tr$ = 12						; size = 4
_pfnStuckTouch PROC					; COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 349  : 	int	i;
; 350  : 
; 351  : 	for( i = 0; i < svgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnStuckTo
$LN2@pfnStuckTo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnStuckTo:
	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+283792]
	jge	SHORT $LN3@pfnStuckTo

; 352  : 	{
; 353  : 		if( svgame.pmove->touchindex[i].ent == hitent )

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR _svgame+8256
	mov	edx, DWORD PTR [ecx+eax+283844]
	cmp	edx, DWORD PTR _hitent$[ebp]
	jne	SHORT $LN5@pfnStuckTo

; 354  : 			return;

	jmp	$LN1@pfnStuckTo
$LN5@pfnStuckTo:

; 355  : 	}

	jmp	SHORT $LN2@pfnStuckTo
$LN3@pfnStuckTo:

; 356  : 
; 357  : 	if( svgame.pmove->numtouch >= MAX_PHYSENTS )

	mov	eax, DWORD PTR _svgame+8256
	cmp	DWORD PTR [eax+283792], 600		; 00000258H
	jl	SHORT $LN6@pfnStuckTo

; 358  : 		return;

	jmp	$LN1@pfnStuckTo
$LN6@pfnStuckTo:

; 359  : 
; 360  : 	VectorCopy( svgame.pmove->velocity, tr->deltavelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [esi+ecx+92]
	mov	DWORD PTR [edx+eax+52], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8256
	mov	edx, DWORD PTR [esi+edx+92]
	mov	DWORD PTR [ecx+eax+52], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _tr$[ebp]
	mov	esi, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [esi+eax+92]
	mov	DWORD PTR [edx+ecx+52], eax

; 361  : 	tr->ent = hitent;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	ecx, DWORD PTR _hitent$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 362  : 
; 363  : 	svgame.pmove->touchindex[svgame.pmove->numtouch++] = *tr;

	mov	eax, DWORD PTR _svgame+8256
	imul	ecx, DWORD PTR [eax+283792], 68
	mov	edx, DWORD PTR _svgame+8256
	lea	edi, DWORD PTR [edx+ecx+283796]
	mov	ecx, 17					; 00000011H
	mov	esi, DWORD PTR _tr$[ebp]
	rep movsd
	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+283792]
	add	ecx, 1
	mov	edx, DWORD PTR _svgame+8256
	mov	DWORD PTR [edx+283792], ecx
$LN1@pfnStuckTo:

; 364  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStuckTouch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _pfnTestPlayerPosition
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_ptrace$ = 12						; size = 4
_pfnTestPlayerPosition PROC				; COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 344  : 	return PM_TestPlayerPosition( svgame.pmove, pos, ptrace, NULL );

	push	0
	mov	eax, DWORD PTR _ptrace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _svgame+8256
	push	edx
	call	_PM_TestPlayerPosition
	add	esp, 16					; 00000010H

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_AddLaddersToPmove
_TEXT	SEGMENT
_pe$ = -20						; size = 4
_mod$ = -16						; size = 4
_check$ = -12						; size = 4
_next$ = -8						; size = 4
_l$ = -4						; size = 4
_node$ = 8						; size = 4
_pmove_mins$ = 12					; size = 4
_pmove_maxs$ = 16					; size = 4
_SV_AddLaddersToPmove PROC				; COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 302  : 	link_t	*l, *next;
; 303  : 	edict_t	*check;
; 304  : 	model_t	*mod;
; 305  : 	physent_t	*pe;
; 306  : 	
; 307  : 	// get water edicts
; 308  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_AddLadd
$LN2@SV_AddLadd:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_AddLadd:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_AddLadd

; 309  : 	{
; 310  : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 311  : 		check = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _check$[ebp], eax

; 312  : 
; 313  : 		if( check->v.solid != SOLID_NOT || check->v.skin != CONTENTS_LADDER )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN6@SV_AddLadd
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+404], -16		; fffffff0H
	je	SHORT $LN5@SV_AddLadd
$LN6@SV_AddLadd:

; 314  : 			continue;

	jmp	SHORT $LN2@SV_AddLadd
$LN5@SV_AddLadd:

; 315  : 
; 316  : 		mod = SV_ModelHandle( check->v.modelindex );

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 317  : 
; 318  : 		// only brushes can have special contents
; 319  : 		if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN8@SV_AddLadd
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN7@SV_AddLadd
$LN8@SV_AddLadd:

; 320  : 			continue;

	jmp	SHORT $LN2@SV_AddLadd
$LN7@SV_AddLadd:

; 321  : 
; 322  : 		if( !BoundsIntersect( pmove_mins, pmove_maxs, check->v.absmin, check->v.absmax ))

	mov	eax, DWORD PTR _check$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 328				; 00000148H
	push	ecx
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN9@SV_AddLadd

; 323  : 			continue;

	jmp	$LN2@SV_AddLadd
$LN9@SV_AddLadd:

; 324  : 
; 325  : 		if( svgame.pmove->nummoveent == MAX_MOVEENTS )

	mov	eax, DWORD PTR _svgame+8256
	cmp	DWORD PTR [eax+134992], 64		; 00000040H
	jne	SHORT $LN10@SV_AddLadd

; 326  : 			return;

	jmp	$LN14@SV_AddLadd
$LN10@SV_AddLadd:

; 327  : 
; 328  : 		pe = &svgame.pmove->moveents[svgame.pmove->nummoveent];

	mov	eax, DWORD PTR _svgame+8256
	imul	ecx, DWORD PTR [eax+134992], 224
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+134996]
	mov	DWORD PTR _pe$[ebp], eax

; 329  : 		if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@SV_AddLadd

; 330  : 			svgame.pmove->nummoveent++;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+134992]
	add	ecx, 1
	mov	edx, DWORD PTR _svgame+8256
	mov	DWORD PTR [edx+134992], ecx
$LN11@SV_AddLadd:

; 331  : 	}

	jmp	$LN2@SV_AddLadd
$LN3@SV_AddLadd:

; 332  : 	
; 333  : 	// recurse down both sides
; 334  : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN12@SV_AddLadd
	jmp	SHORT $LN14@SV_AddLadd
$LN12@SV_AddLadd:

; 335  : 	
; 336  : 	if( pmove_maxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN13@SV_AddLadd

; 337  : 		SV_AddLaddersToPmove( node->children[0], pmove_mins, pmove_maxs );

	mov	eax, DWORD PTR _pmove_maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH
$LN13@SV_AddLadd:

; 338  : 	if( pmove_mins[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN14@SV_AddLadd

; 339  : 		SV_AddLaddersToPmove( node->children[1], pmove_mins, pmove_maxs );

	mov	eax, DWORD PTR _pmove_maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_SV_AddLaddersToPmove
	add	esp, 12					; 0000000cH
$LN14@SV_AddLadd:

; 340  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddLaddersToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_AddLinksToPmove
_TEXT	SEGMENT
_pe$ = -48						; size = 4
_maxs$ = -44						; size = 12
_mins$ = -32						; size = 12
_pl$ = -20						; size = 4
_check$ = -16						; size = 4
_next$ = -12						; size = 4
_l$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_pmove_mins$ = 12					; size = 4
_pmove_maxs$ = 16					; size = 4
_SV_AddLinksToPmove PROC				; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 210  : 	link_t	*l, *next;
; 211  : 	edict_t	*check, *pl;
; 212  : 	vec3_t	mins, maxs;
; 213  : 	physent_t	*pe;
; 214  : 
; 215  : 	pl = EDICT_NUM( svgame.pmove->player_index + 1 );

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _pl$[ebp], eax

; 216  : 	Assert( SV_IsValidEdict( pl ));

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_AddLinksToPmove@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BG@OLDHMDKH@SV_IsValidEdict?$CI?5pl?5?$CJ@
	mov	ecx, DWORD PTR ?__LINE__Var@?0??SV_AddLinksToPmove@@9@9
	add	ecx, 7
	push	ecx
	push	OFFSET ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	edx, DWORD PTR _pl$[ebp]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 217  : 
; 218  : 	// touch linked edicts
; 219  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _l$[ebp], ecx
	jmp	SHORT $LN4@SV_AddLink
$LN2@SV_AddLink:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$LN4@SV_AddLink:
	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], eax
	je	$LN3@SV_AddLink

; 220  : 	{
; 221  : 		next = l->next;

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _next$[ebp], ecx

; 222  : 		check = EDICT_FROM_AREA( l );

	mov	eax, DWORD PTR _l$[ebp]
	sub	eax, 8
	mov	DWORD PTR _check$[ebp], eax

; 223  : 
; 224  : 		if( check->v.groupinfo != 0 )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN7@SV_AddLink

; 225  : 		{
; 226  : 			if( svs.groupop == GROUP_OP_AND && !FBitSet( check->v.groupinfo, pl->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN6@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	jne	SHORT $LN6@SV_AddLink

; 227  : 				continue;

	jmp	SHORT $LN2@SV_AddLink
$LN6@SV_AddLink:

; 228  : 
; 229  : 			if( svs.groupop == GROUP_OP_NAND && FBitSet( check->v.groupinfo, pl->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN7@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	je	SHORT $LN7@SV_AddLink

; 230  : 				continue;

	jmp	SHORT $LN2@SV_AddLink
$LN7@SV_AddLink:

; 231  : 		}
; 232  : 
; 233  : 		if( check->v.owner == pl || check->v.solid == SOLID_TRIGGER )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	cmp	ecx, DWORD PTR _pl$[ebp]
	je	SHORT $LN9@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+400], 1
	jne	SHORT $LN8@SV_AddLink
$LN9@SV_AddLink:

; 234  : 			continue; // player or player's own missile

	jmp	$LN2@SV_AddLink
$LN8@SV_AddLink:

; 235  : 
; 236  : 		if( svgame.pmove->numvisent < MAX_PHYSENTS )

	mov	eax, DWORD PTR _svgame+8256
	cmp	DWORD PTR [eax+149332], 600		; 00000258H
	jge	SHORT $LN11@SV_AddLink

; 237  : 		{
; 238  : 			pe = &svgame.pmove->visents[svgame.pmove->numvisent];

	mov	eax, DWORD PTR _svgame+8256
	imul	ecx, DWORD PTR [eax+149332], 224
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+149336]
	mov	DWORD PTR _pe$[ebp], eax

; 239  : 			if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@SV_AddLink

; 240  : 				svgame.pmove->numvisent++;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+149332]
	add	ecx, 1
	mov	edx, DWORD PTR _svgame+8256
	mov	DWORD PTR [edx+149332], ecx
$LN11@SV_AddLink:

; 241  : 		}
; 242  : 
; 243  : 		if( check->v.solid == SOLID_NOT && ( check->v.skin == CONTENTS_NONE || check->v.modelindex == 0 ))

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN12@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+404], 0
	je	SHORT $LN13@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+308], 0
	jne	SHORT $LN12@SV_AddLink
$LN13@SV_AddLink:

; 244  : 			continue;

	jmp	$LN2@SV_AddLink
$LN12@SV_AddLink:

; 245  : 
; 246  : 		// ignore monsterclip brushes
; 247  : 		if( FBitSet( check->v.flags, FL_MONSTERCLIP ) && check->v.solid == SOLID_BSP )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN14@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+400], 4
	jne	SHORT $LN14@SV_AddLink

; 248  : 			continue;

	jmp	$LN2@SV_AddLink
$LN14@SV_AddLink:

; 249  : 
; 250  : 		if( check == pl ) continue;	// himself

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _pl$[ebp]
	jne	SHORT $LN15@SV_AddLink
	jmp	$LN2@SV_AddLink
$LN15@SV_AddLink:

; 251  : 
; 252  : 		// nehahra collision flags
; 253  : 		if( check->v.movetype != MOVETYPE_PUSH )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 7
	je	SHORT $LN17@SV_AddLink

; 254  : 		{
; 255  : 			if(( FBitSet( check->v.flags, FL_CLIENT|FL_FAKECLIENT ) && check->v.health <= 0.0f ) || check->v.deadflag == DEAD_DEAD )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8200				; 00002008H
	je	SHORT $LN19@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+520]
	jae	SHORT $LN18@SV_AddLink
$LN19@SV_AddLink:
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+604], 2
	jne	SHORT $LN17@SV_AddLink
$LN18@SV_AddLink:

; 256  : 				continue;	// dead body

	jmp	$LN2@SV_AddLink
$LN17@SV_AddLink:

; 257  : 		}
; 258  : 
; 259  : 		if( VectorIsNull( check->v.size ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+376]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_AddLink

; 260  : 			continue;

	jmp	$LN2@SV_AddLink
$LN20@SV_AddLink:

; 261  : 
; 262  : 		VectorCopy( check->v.absmin, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+328]
	mov	DWORD PTR _mins$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+edx+328]
	mov	DWORD PTR _mins$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+eax+328]
	mov	DWORD PTR _mins$[ebp+ecx], eax

; 263  : 		VectorCopy( check->v.absmax, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+340]
	mov	DWORD PTR _maxs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+edx+340]
	mov	DWORD PTR _maxs$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+eax+340]
	mov	DWORD PTR _maxs$[ebp+ecx], eax

; 264  : 
; 265  : 		if( FBitSet( check->v.flags, FL_CLIENT ) && !FBitSet( check->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN22@SV_AddLink
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8192				; 00002000H
	jne	SHORT $LN22@SV_AddLink

; 266  : 		{
; 267  : 			if( sv.current_client )

	cmp	DWORD PTR _sv+40, 0
	je	SHORT $LN22@SV_AddLink

; 268  : 			{
; 269  : 				// trying to get interpolated values
; 270  : 				SV_GetTrueMinMax( sv.current_client, NUM_FOR_EDICT( check ), mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	eax, DWORD PTR _check$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _sv+40
	push	edx
	call	_SV_GetTrueMinMax
	add	esp, 16					; 00000010H
$LN22@SV_AddLink:

; 271  : 			}
; 272  : 		}
; 273  : 
; 274  : 		if( !BoundsIntersect( pmove_mins, pmove_maxs, mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	push	eax
	call	_BoundsIntersect
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN23@SV_AddLink

; 275  : 			continue;

	jmp	$LN2@SV_AddLink
$LN23@SV_AddLink:

; 276  : 
; 277  : 		if( svgame.pmove->numphysent < MAX_PHYSENTS )

	mov	eax, DWORD PTR _svgame+8256
	cmp	DWORD PTR [eax+588], 600		; 00000258H
	jge	SHORT $LN25@SV_AddLink

; 278  : 		{
; 279  : 			pe = &svgame.pmove->physents[svgame.pmove->numphysent];

	mov	eax, DWORD PTR _svgame+8256
	imul	ecx, DWORD PTR [eax+588], 224
	mov	edx, DWORD PTR _svgame+8256
	lea	eax, DWORD PTR [edx+ecx+592]
	mov	DWORD PTR _pe$[ebp], eax

; 280  : 
; 281  : 			if( SV_CopyEdictToPhysEnt( pe, check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	push	ecx
	call	_SV_CopyEdictToPhysEnt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@SV_AddLink

; 282  : 				svgame.pmove->numphysent++;

	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR [eax+588]
	add	ecx, 1
	mov	edx, DWORD PTR _svgame+8256
	mov	DWORD PTR [edx+588], ecx
$LN25@SV_AddLink:

; 283  : 		}
; 284  : 	}

	jmp	$LN2@SV_AddLink
$LN3@SV_AddLink:

; 285  : 	
; 286  : 	// recurse down both sides
; 287  : 	if( node->axis == -1 ) return;

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN26@SV_AddLink
	jmp	SHORT $LN28@SV_AddLink
$LN26@SV_AddLink:

; 288  : 
; 289  : 	if( pmove_maxs[node->axis] > node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pmove_maxs$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN27@SV_AddLink

; 290  : 		SV_AddLinksToPmove( node->children[0], pmove_mins, pmove_maxs );

	mov	eax, DWORD PTR _pmove_maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH
$LN27@SV_AddLink:

; 291  : 	if( pmove_mins[node->axis] < node->dist )

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _pmove_mins$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, DWORD PTR [eax+ecx*4]
	jbe	SHORT $LN28@SV_AddLink

; 292  : 		SV_AddLinksToPmove( node->children[1], pmove_mins, pmove_maxs );

	mov	eax, DWORD PTR _pmove_maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove_mins$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	call	_SV_AddLinksToPmove
	add	esp, 12					; 0000000cH
$LN28@SV_AddLink:

; 293  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddLinksToPmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_ShouldUnlagForPlayer
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_ShouldUnlagForPlayer PROC				; COMDAT

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 156  : 	// can't unlag in singleplayer
; 157  : 	if( svs.maxclients <= 1 )

	cmp	DWORD PTR _svs+16, 1
	jg	SHORT $LN2@SV_ShouldU

; 158  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN2@SV_ShouldU:

; 159  : 
; 160  : 	// unlag disabled globally
; 161  : 	if( !svgame.dllFuncs.pfnAllowLagCompensation() || !sv_unlag.value )

	call	DWORD PTR _svgame+19468
	test	eax, eax
	je	SHORT $LN4@SV_ShouldU
	movss	xmm0, DWORD PTR _sv_unlag+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_ShouldU
$LN4@SV_ShouldU:

; 162  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN3@SV_ShouldU:

; 163  : 
; 164  : 	if( !FBitSet( cl->flags, FCL_LAG_COMPENSATION ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN5@SV_ShouldU

; 165  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN5@SV_ShouldU:

; 166  : 
; 167  : 	// player not ready
; 168  : 	if( cl->state != cs_spawned )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN6@SV_ShouldU

; 169  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN6@SV_ShouldU:

; 170  : 
; 171  : 	return true;

	mov	eax, 1
$LN1@SV_ShouldU:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ShouldUnlagForPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_CopyEdictToPhysEnt
_TEXT	SEGMENT
tv287 = -72						; size = 4
tv247 = -72						; size = 4
tv243 = -72						; size = 4
tv177 = -72						; size = 4
_mod$ = -4						; size = 4
_pe$ = 8						; size = 4
_ed$ = 12						; size = 4
_SV_CopyEdictToPhysEnt PROC				; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 64   : 	model_t	*mod = SV_ModelHandle( ed->v.modelindex );

	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 65   : 
; 66   : 	if( !mod ) return false;

	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN4@SV_CopyEdi
	xor	eax, eax
	jmp	$LN1@SV_CopyEdi
$LN4@SV_CopyEdi:

; 67   : 	pe->player = false;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+32], 0

; 68   : 
; 69   : 	pe->info = NUM_FOR_EDICT( ed );

	mov	eax, DWORD PTR _ed$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+80], eax

; 70   : 	VectorCopy( ed->v.origin, pe->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+36], eax

; 71   : 	VectorCopy( ed->v.angles, pe->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+84], eax

; 72   : 
; 73   : 	if( FBitSet( ed->v.flags, FL_FAKECLIENT ))

	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN5@SV_CopyEdi

; 74   : 	{
; 75   : 		// bot
; 76   : 		Q_strncpy( pe->name, "bot", sizeof( pe->name ));

	push	32					; 00000020H
	push	OFFSET ??_C@_03EHEMCPIE@bot@
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 77   : 		pe->player = pe->info;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+32], edx

; 78   : 	}

	jmp	SHORT $LN8@SV_CopyEdi
$LN5@SV_CopyEdi:

; 79   : 	else if( FBitSet( ed->v.flags, FL_CLIENT ))

	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN7@SV_CopyEdi

; 80   : 	{
; 81   : 		// client
; 82   : 		SV_GetTrueOrigin( &svs.clients[pe->info - 1], pe->info, pe->origin );

	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	sub	ecx, 1
	imul	edx, ecx, 289832
	add	edx, DWORD PTR _svs+33344
	push	edx
	call	_SV_GetTrueOrigin
	add	esp, 12					; 0000000cH

; 83   : 		Q_strncpy( pe->name, "player", sizeof( pe->name ));

	push	32					; 00000020H
	push	OFFSET ??_C@_06BALNJMNP@player@
	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 84   : 		pe->player = pe->info;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+32], edx

; 85   : 	}

	jmp	SHORT $LN8@SV_CopyEdi
$LN7@SV_CopyEdi:

; 86   : 	else
; 87   : 	{
; 88   : 		// otherwise copy the classname
; 89   : 		Q_strncpy( pe->name, STRING( ed->v.classname ), sizeof( pe->name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@SV_CopyEdi:

; 90   : 	}
; 91   : 
; 92   : 	pe->model = pe->studiomodel = NULL;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 93   : 
; 94   : 	switch( ed->v.solid )

	mov	eax, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR tv177[ebp], ecx
	cmp	DWORD PTR tv177[ebp], 5
	ja	$LN14@SV_CopyEdi
	mov	edx, DWORD PTR tv177[ebp]
	jmp	DWORD PTR $LN22@SV_CopyEdi[edx*4]
$LN9@SV_CopyEdi:

; 95   : 	{
; 96   : 	case SOLID_NOT:
; 97   : 	case SOLID_BSP:
; 98   : 		pe->model = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 99   : 		VectorClear( pe->mins );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+56], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+56], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+56], xmm0

; 100  : 		VectorClear( pe->maxs );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+68], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+68], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+68], xmm0

; 101  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN11@SV_CopyEdi:

; 102  : 	case SOLID_BBOX:
; 103  : 		if( mod && mod->type == mod_studio && mod->flags & STUDIO_TRACE_HITBOX )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN12@SV_CopyEdi
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN12@SV_CopyEdi
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 512				; 00000200H
	je	SHORT $LN12@SV_CopyEdi

; 104  : 			pe->studiomodel = mod;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN12@SV_CopyEdi:

; 105  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+352]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+352]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+352]
	mov	DWORD PTR [edx+ecx+56], eax

; 106  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+364]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+364]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+364]
	mov	DWORD PTR [edx+ecx+68], eax

; 107  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN13@SV_CopyEdi:

; 108  : 	case SOLID_CUSTOM:
; 109  : 		pe->model = (mod->type == mod_brush) ? mod : NULL;

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN16@SV_CopyEdi
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv243[ebp], ecx
	jmp	SHORT $LN17@SV_CopyEdi
$LN16@SV_CopyEdi:
	mov	DWORD PTR tv243[ebp], 0
$LN17@SV_CopyEdi:
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR tv243[ebp]
	mov	DWORD PTR [edx+48], eax

; 110  : 		pe->studiomodel = (mod->type == mod_studio) ? mod : NULL;

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN18@SV_CopyEdi
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv247[ebp], ecx
	jmp	SHORT $LN19@SV_CopyEdi
$LN18@SV_CopyEdi:
	mov	DWORD PTR tv247[ebp], 0
$LN19@SV_CopyEdi:
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR tv247[ebp]
	mov	DWORD PTR [edx+52], eax

; 111  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+352]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+352]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+352]
	mov	DWORD PTR [edx+ecx+56], eax

; 112  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+364]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+364]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+364]
	mov	DWORD PTR [edx+ecx+68], eax

; 113  : 		break;

	jmp	$LN2@SV_CopyEdi
$LN14@SV_CopyEdi:

; 114  : 	default:
; 115  : 		pe->studiomodel = (mod->type == mod_studio) ? mod : NULL;

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN20@SV_CopyEdi
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR tv287[ebp], ecx
	jmp	SHORT $LN21@SV_CopyEdi
$LN20@SV_CopyEdi:
	mov	DWORD PTR tv287[ebp], 0
$LN21@SV_CopyEdi:
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR tv287[ebp]
	mov	DWORD PTR [edx+52], eax

; 116  : 		VectorCopy( ed->v.mins, pe->mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+352]
	mov	DWORD PTR [edx+eax+56], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+352]
	mov	DWORD PTR [ecx+eax+56], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+352]
	mov	DWORD PTR [edx+ecx+56], eax

; 117  : 		VectorCopy( ed->v.maxs, pe->maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+364]
	mov	DWORD PTR [edx+eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+364]
	mov	DWORD PTR [ecx+eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+364]
	mov	DWORD PTR [edx+ecx+68], eax
$LN2@SV_CopyEdi:

; 118  : 		break;
; 119  : 	}
; 120  : 
; 121  : 	pe->solid = ed->v.solid;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+400]
	mov	DWORD PTR [eax+96], edx

; 122  : 	pe->rendermode = ed->v.rendermode;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+496]
	mov	DWORD PTR [eax+104], edx

; 123  : 	pe->skin = ed->v.skin;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+404]
	mov	DWORD PTR [eax+100], edx

; 124  : 	pe->frame = ed->v.frame;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+472]
	mov	DWORD PTR [eax+108], edx

; 125  : 	pe->sequence = ed->v.sequence;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+464]
	mov	DWORD PTR [eax+112], edx

; 126  : 
; 127  : 	memcpy( &pe->controller[0], &ed->v.controller[0], 4 * sizeof( byte ));

	push	4
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ed$[ebp]
	lea	eax, DWORD PTR [edx+ecx+484]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	lea	ecx, DWORD PTR [eax+edx+116]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 128  : 	memcpy( &pe->blending[0], &ed->v.blending[0], 2 * sizeof( byte ));

	push	2
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ed$[ebp]
	lea	eax, DWORD PTR [edx+ecx+488]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pe$[ebp]
	lea	ecx, DWORD PTR [eax+edx+120]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 129  : 
; 130  : 	pe->movetype = ed->v.movetype;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+396]
	mov	DWORD PTR [eax+124], edx

; 131  : 	pe->takedamage = ed->v.takedamage;

	mov	eax, DWORD PTR _ed$[ebp]
	cvttss2si ecx, DWORD PTR [eax+600]
	mov	edx, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [edx+128], ecx

; 132  : 	pe->team = ed->v.team;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	DWORD PTR [eax+136], edx

; 133  : 	pe->classnumber = ed->v.playerclass;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+748]
	mov	DWORD PTR [eax+140], edx

; 134  : 	pe->blooddecal = 0;	// unused in GoldSrc

	mov	eax, DWORD PTR _pe$[ebp]
	mov	DWORD PTR [eax+132], 0

; 135  : 
; 136  : 	// for mods
; 137  : 	pe->iuser1 = ed->v.iuser1;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	mov	DWORD PTR [eax+144], edx

; 138  : 	pe->iuser2 = ed->v.iuser2;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+808]
	mov	DWORD PTR [eax+148], edx

; 139  : 	pe->iuser3 = ed->v.iuser3;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+812]
	mov	DWORD PTR [eax+152], edx

; 140  : 	pe->iuser4 = ed->v.iuser4;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+816]
	mov	DWORD PTR [eax+156], edx

; 141  : 	pe->fuser1 = ed->v.fuser1;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	DWORD PTR [eax+160], edx

; 142  : 	pe->fuser2 = ed->v.fuser2;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+824]
	mov	DWORD PTR [eax+164], edx

; 143  : 	pe->fuser3 = ed->v.fuser3;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+828]
	mov	DWORD PTR [eax+168], edx

; 144  : 	pe->fuser4 = ed->v.fuser4;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [ecx+832]
	mov	DWORD PTR [eax+172], edx

; 145  : 
; 146  : 	VectorCopy( ed->v.vuser1, pe->vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+836]
	mov	DWORD PTR [edx+eax+176], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+836]
	mov	DWORD PTR [ecx+eax+176], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+836]
	mov	DWORD PTR [edx+ecx+176], eax

; 147  : 	VectorCopy( ed->v.vuser2, pe->vuser2 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+848]
	mov	DWORD PTR [edx+eax+188], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+848]
	mov	DWORD PTR [ecx+eax+188], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+848]
	mov	DWORD PTR [edx+ecx+188], eax

; 148  : 	VectorCopy( ed->v.vuser3, pe->vuser3 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+860]
	mov	DWORD PTR [edx+eax+200], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+860]
	mov	DWORD PTR [ecx+eax+200], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+860]
	mov	DWORD PTR [edx+ecx+200], eax

; 149  : 	VectorCopy( ed->v.vuser4, pe->vuser4 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+872]
	mov	DWORD PTR [edx+eax+212], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	edx, DWORD PTR [esi+edx+872]
	mov	DWORD PTR [ecx+eax+212], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	esi, DWORD PTR _ed$[ebp]
	mov	eax, DWORD PTR [esi+eax+872]
	mov	DWORD PTR [edx+ecx+212], eax

; 150  : 
; 151  : 	return true;

	mov	eax, 1
$LN1@SV_CopyEdi:

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN22@SV_CopyEdi:
	DD	$LN9@SV_CopyEdi
	DD	$LN14@SV_CopyEdi
	DD	$LN11@SV_CopyEdi
	DD	$LN14@SV_CopyEdi
	DD	$LN9@SV_CopyEdi
	DD	$LN13@SV_CopyEdi
_SV_CopyEdictToPhysEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_ClearPhysEnts
_TEXT	SEGMENT
_SV_ClearPhysEnts PROC					; COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 27   : 	svgame.pmove->numtouch = 0;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+283792], 0

; 28   : 	svgame.pmove->numvisent = 0;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+149332], 0

; 29   : 	svgame.pmove->nummoveent = 0;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+134992], 0

; 30   : 	svgame.pmove->numphysent = 0;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+588], 0

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClearPhysEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_PlayerIsFrozen
_TEXT	SEGMENT
_pClient$ = 8						; size = 4
_SV_PlayerIsFrozen PROC					; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	if( sv_background_freeze.value && sv.background )

	movss	xmm0, DWORD PTR _sv_background_freeze+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_PlayerI
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_PlayerI

; 36   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_PlayerI
$LN2@SV_PlayerI:

; 37   : 
; 38   : 	if( FBitSet( host.features, ENGINE_QUAKE_COMPATIBLE ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 2
	je	SHORT $LN3@SV_PlayerI

; 39   : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_PlayerI
$LN3@SV_PlayerI:

; 40   : 
; 41   : 	if( FBitSet( pClient->v.flags, FL_FROZEN ))

	mov	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN4@SV_PlayerI

; 42   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_PlayerI
$LN4@SV_PlayerI:

; 43   : 	return false;

	xor	eax, eax
$LN1@SV_PlayerI:

; 44   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlayerIsFrozen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_GetTrueMinMax
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_edictnum$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_SV_GetTrueMinMax PROC					; COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 188  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_GetTrue

; 189  : 		return;

	jmp	$LN5@SV_GetTrue
$LN2@SV_GetTrue:

; 190  : 
; 191  : 	if( edictnum < 1 || edictnum > svs.maxclients )

	cmp	DWORD PTR _edictnum$[ebp], 1
	jl	SHORT $LN4@SV_GetTrue
	mov	eax, DWORD PTR _edictnum$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN3@SV_GetTrue
$LN4@SV_GetTrue:

; 192  : 		return;

	jmp	$LN5@SV_GetTrue
$LN3@SV_GetTrue:

; 193  : 
; 194  : 	if( svgame.interp[edictnum-1].active && svgame.interp[edictnum-1].moving )

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	cmp	DWORD PTR _svgame[ecx+8260], 0
	je	$LN5@SV_GetTrue
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	cmp	DWORD PTR _svgame[ecx+8264], 0
	je	$LN5@SV_GetTrue

; 195  : 	{
; 196  : 		VectorCopy( svgame.interp[edictnum-1].mins, mins );

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR _svgame[ecx+eax+8276]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	edx, DWORD PTR _svgame[edx+eax+8276]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8276]
	mov	DWORD PTR [esi+eax], ecx

; 197  : 		VectorCopy( svgame.interp[edictnum-1].maxs, maxs );

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR _svgame[ecx+eax+8288]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	edx, DWORD PTR _svgame[edx+eax+8288]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8288]
	mov	DWORD PTR [esi+eax], ecx
$LN5@SV_GetTrue:

; 198  : 	}
; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetTrueMinMax ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_GetTrueOrigin
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_edictnum$ = 12						; size = 4
_origin$ = 16						; size = 4
_SV_GetTrueOrigin PROC					; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 176  : 	if( !SV_ShouldUnlagForPlayer( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ShouldUnlagForPlayer
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_GetTrue

; 177  : 		return;

	jmp	$LN5@SV_GetTrue
$LN2@SV_GetTrue:

; 178  : 
; 179  : 	if( edictnum < 1 || edictnum > svs.maxclients )

	cmp	DWORD PTR _edictnum$[ebp], 1
	jl	SHORT $LN4@SV_GetTrue
	mov	eax, DWORD PTR _edictnum$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jle	SHORT $LN3@SV_GetTrue
$LN4@SV_GetTrue:

; 180  : 		return;

	jmp	$LN5@SV_GetTrue
$LN3@SV_GetTrue:

; 181  : 
; 182  : 	if( svgame.interp[edictnum-1].active && svgame.interp[edictnum-1].moving )

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	cmp	DWORD PTR _svgame[ecx+8260], 0
	je	$LN5@SV_GetTrue
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	cmp	DWORD PTR _svgame[ecx+8264], 0
	je	SHORT $LN5@SV_GetTrue

; 183  : 		VectorCopy( svgame.interp[edictnum-1].oldpos, origin ); 

	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR _svgame[ecx+eax+8312]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, DWORD PTR _edictnum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 88
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR _svgame[edx+eax+8312]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, DWORD PTR _edictnum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 88
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _svgame[ecx+edx+8312]
	mov	DWORD PTR [esi+eax], ecx
$LN5@SV_GetTrue:

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetTrueOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_InitClientMove
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SV_InitClientMove PROC					; COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 561  : 	int	i;
; 562  : 
; 563  : 	Pmove_Init ();

	call	_Pmove_Init

; 564  : 
; 565  : 	svgame.pmove->server = true;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+4], 1

; 566  : 	svgame.pmove->movevars = &svgame.movevars;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324852], OFFSET _svgame+7936

; 567  : 	svgame.pmove->runfuncs = false;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325044], 0

; 568  : 
; 569  : 	// enumerate client hulls
; 570  : 	for( i = 0; i < MAX_MAP_HULLS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_InitCli
$LN2@SV_InitCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_InitCli:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@SV_InitCli

; 571  : 	{
; 572  : 		if( svgame.dllFuncs.pfnGetHullBounds( i, host.player_mins[i], host.player_maxs[i] ))

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _host+34284
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, OFFSET _host+34236
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	DWORD PTR _svgame+19456
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN5@SV_InitCli

; 573  : 			Con_Reportf( "SV: hull%i, player_mins: %g %g %g, player_maxs: %g %g %g\n", i,

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+eax+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	imul	eax, edx, 0
	cvtss2sd xmm0, DWORD PTR _host[ecx+eax+34284]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR _host[ecx+edx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	cvtss2sd xmm0, DWORD PTR _host[eax+ecx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _host[edx+ecx+34236]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@JGNNGBDI@SV?3?5hull?$CFi?0?5player_mins?3?5?$CFg?5?$CFg?5@
	call	_Con_Reportf
	add	esp, 56					; 00000038H
$LN5@SV_InitCli:

; 574  : 			host.player_mins[i][0], host.player_mins[i][1], host.player_mins[i][2],
; 575  : 			host.player_maxs[i][0], host.player_maxs[i][1], host.player_maxs[i][2] );
; 576  : 	}

	jmp	$LN2@SV_InitCli
$LN3@SV_InitCli:

; 577  : 
; 578  : 	memcpy( svgame.pmove->player_mins, host.player_mins, sizeof( host.player_mins ));

	push	48					; 00000030H
	push	OFFSET _host+34236
	mov	eax, DWORD PTR _svgame+8256
	add	eax, 324856				; 0004f4f8H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 579  : 	memcpy( svgame.pmove->player_maxs, host.player_maxs, sizeof( host.player_maxs ));

	push	48					; 00000030H
	push	OFFSET _host+34284
	mov	eax, DWORD PTR _svgame+8256
	add	eax, 324904				; 0004f528H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 580  : 
; 581  : 	// common utilities
; 582  : 	svgame.pmove->PM_Info_ValueForKey = Info_ValueForKey;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324952], OFFSET _Info_ValueForKey

; 583  : 	svgame.pmove->PM_Particle = CL_Particle; // for local system only

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324956], OFFSET _CL_Particle

; 584  : 	svgame.pmove->PM_TestPlayerPosition = pfnTestPlayerPosition;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324960], OFFSET _pfnTestPlayerPosition

; 585  : 	svgame.pmove->Con_NPrintf = Con_NPrintf;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324964], OFFSET _Con_NPrintf

; 586  : 	svgame.pmove->Con_DPrintf = Con_DPrintf;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324968], OFFSET _Con_DPrintf

; 587  : 	svgame.pmove->Con_Printf = Con_Printf;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324972], OFFSET _Con_Printf

; 588  : 	svgame.pmove->Sys_FloatTime = Sys_DoubleTime;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324976], OFFSET _Sys_DoubleTime

; 589  : 	svgame.pmove->PM_StuckTouch = pfnStuckTouch;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324980], OFFSET _pfnStuckTouch

; 590  : 	svgame.pmove->PM_PointContents = pfnPointContents;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324984], OFFSET _pfnPointContents

; 591  : 	svgame.pmove->PM_TruePointContents = pfnTruePointContents;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324988], OFFSET _pfnTruePointContents

; 592  : 	svgame.pmove->PM_HullPointContents = pfnHullPointContents; 

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324992], OFFSET _pfnHullPointContents

; 593  : 	svgame.pmove->PM_PlayerTrace = pfnPlayerTrace;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+324996], OFFSET _pfnPlayerTrace

; 594  : 	svgame.pmove->PM_TraceLine = pfnTraceLine;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325000], OFFSET _pfnTraceLine

; 595  : 	svgame.pmove->RandomLong = COM_RandomLong;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325004], OFFSET _COM_RandomLong

; 596  : 	svgame.pmove->RandomFloat = COM_RandomFloat;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325008], OFFSET _COM_RandomFloat

; 597  : 	svgame.pmove->PM_GetModelType = pfnGetModelType;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325012], OFFSET _pfnGetModelType

; 598  : 	svgame.pmove->PM_GetModelBounds = pfnGetModelBounds;	

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325016], OFFSET _pfnGetModelBounds

; 599  : 	svgame.pmove->PM_HullForBsp = pfnHullForBsp;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325020], OFFSET _pfnHullForBsp

; 600  : 	svgame.pmove->PM_TraceModel = pfnTraceModel;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325024], OFFSET _pfnTraceModel

; 601  : 	svgame.pmove->COM_FileSize = COM_FileSize;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325028], OFFSET _COM_FileSize

; 602  : 	svgame.pmove->COM_LoadFile = COM_LoadFile;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325032], OFFSET _COM_LoadFile

; 603  : 	svgame.pmove->COM_FreeFile = COM_FreeFile;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325036], OFFSET _COM_FreeFile

; 604  : 	svgame.pmove->memfgets = COM_MemFgets;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325040], OFFSET _COM_MemFgets

; 605  : 	svgame.pmove->PM_PlaySound = pfnPlaySound;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325048], OFFSET _pfnPlaySound

; 606  : 	svgame.pmove->PM_TraceTexture = pfnTraceTexture;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325052], OFFSET _pfnTraceTexture

; 607  : 	svgame.pmove->PM_PlaybackEventFull = pfnPlaybackEventFull;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325056], OFFSET _pfnPlaybackEventFull

; 608  : 	svgame.pmove->PM_PlayerTraceEx = pfnPlayerTraceEx;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325060], OFFSET _pfnPlayerTraceEx

; 609  : 	svgame.pmove->PM_TestPlayerPositionEx = pfnTestPlayerPositionEx;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325064], OFFSET _pfnTestPlayerPositionEx

; 610  : 	svgame.pmove->PM_TraceLineEx = pfnTraceLineEx;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325068], OFFSET _pfnTraceLineEx

; 611  : 	svgame.pmove->PM_TraceSurface = pfnTraceSurface;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+325072], OFFSET _pfnTraceSurface

; 612  : 
; 613  : 	// initalize pmove
; 614  : 	svgame.dllFuncs.pfnPM_Init( svgame.pmove );

	mov	eax, DWORD PTR _svgame+8256
	push	eax
	call	DWORD PTR _svgame+19412
	add	esp, 4

; 615  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_RunCmd
_TEXT	SEGMENT
_cmd$ = -156						; size = 56
_oldvel$ = -100						; size = 12
_trace$ = -88						; size = 56
_pmtrace$ = -32						; size = 4
_oldmsec$ = -28						; size = 4
_i$ = -24						; size = 4
_frametime$ = -20					; size = 8
_touch$ = -12						; size = 4
_clent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_ucmd$ = 12						; size = 4
_random_seed$ = 16					; size = 4
_SV_RunCmd PROC						; COMDAT

; 1007 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1008 : 	edict_t	*clent, *touch;
; 1009 : 	double	frametime;
; 1010 : 	int	i, oldmsec;
; 1011 : 	pmtrace_t	*pmtrace;
; 1012 : 	trace_t	trace;
; 1013 : 	vec3_t	oldvel;
; 1014 : 	usercmd_t cmd;
; 1015 :    
; 1016 : 	clent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _clent$[ebp], ecx

; 1017 : 	cmd = *ucmd;

	mov	ecx, 14					; 0000000eH
	mov	esi, DWORD PTR _ucmd$[ebp]
	lea	edi, DWORD PTR _cmd$[ebp]
	rep movsd

; 1018 : 
; 1019 : 	if( cl->ignorecmdtime > host.realtime )

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [eax+264928]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN5@SV_RunCmd

; 1020 : 	{
; 1021 : 		cl->cmdtime += ((double)ucmd->msec / 1000.0 );

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	mov	edx, DWORD PTR _cl$[ebp]
	addsd	xmm0, QWORD PTR [edx+264920]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264920], xmm0

; 1022 : 		return;

	jmp	$LN16@SV_RunCmd
$LN5@SV_RunCmd:

; 1023 : 	}
; 1024 : 
; 1025 : 	cl->ignorecmdtime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264928], xmm0

; 1026 : 
; 1027 : 	// chop up very long commands
; 1028 : 	if( cmd.msec > 50 )

	movzx	eax, BYTE PTR _cmd$[ebp+2]
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN6@SV_RunCmd

; 1029 : 	{
; 1030 : 		oldmsec = ucmd->msec;

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _oldmsec$[ebp], ecx

; 1031 : 		cmd.msec = oldmsec / 2;

	mov	eax, DWORD PTR _oldmsec$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _cmd$[ebp+2], al

; 1032 : 		SV_RunCmd( cl, &cmd, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 1033 : 		cmd.msec = oldmsec / 2;

	mov	eax, DWORD PTR _oldmsec$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _cmd$[ebp+2], al

; 1034 : 		cmd.impulse = 0;

	mov	BYTE PTR _cmd$[ebp+36], 0

; 1035 : 		SV_RunCmd( cl, &cmd, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 1036 : 		return;

	jmp	$LN16@SV_RunCmd
$LN6@SV_RunCmd:

; 1037 : 	}
; 1038 : 
; 1039 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN7@SV_RunCmd

; 1040 : 	{
; 1041 : 		SV_SetupMoveInterpolant( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_SetupMoveInterpolant
	add	esp, 4
$LN7@SV_RunCmd:

; 1042 : 	}
; 1043 : 
; 1044 : 	svgame.dllFuncs.pfnCmdStart( cl->edict, ucmd, random_seed );

	mov	eax, DWORD PTR _random_seed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ucmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [edx+264948]
	push	eax
	call	DWORD PTR _svgame+19444
	add	esp, 12					; 0000000cH

; 1045 : 
; 1046 : 	frametime = ((double)ucmd->msec / 1000.0 );

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _frametime$[ebp], xmm0

; 1047 : 	cl->timebase += frametime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [eax+264368]
	addsd	xmm0, QWORD PTR _frametime$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264368], xmm0

; 1048 : 	cl->cmdtime += frametime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [eax+264920]
	addsd	xmm0, QWORD PTR _frametime$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [ecx+264920], xmm0

; 1049 : 
; 1050 : 	PM_CheckMovingGround( clent, frametime );

	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	_PM_CheckMovingGround
	add	esp, 8

; 1051 : 
; 1052 : 	VectorCopy( clent->v.v_angle, svgame.pmove->oldangles ); // save oldangles

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _svgame+8256
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+244]
	mov	DWORD PTR [edx+eax+80], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _svgame+8256
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+244]
	mov	DWORD PTR [ecx+eax+80], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _svgame+8256
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+244]
	mov	DWORD PTR [edx+ecx+80], eax

; 1053 : 	if( !clent->v.fixangle ) VectorCopy( ucmd->viewangles, clent->v.v_angle );

	mov	eax, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	SHORT $LN8@SV_RunCmd
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+244], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+244], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _ucmd$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+244], eax
$LN8@SV_RunCmd:

; 1054 : 
; 1055 : 	VectorClear( clent->v.clbasevelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+184], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+184], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _clent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+184], xmm0

; 1056 : 
; 1057 : 	// copy player buttons
; 1058 : 	clent->v.button = ucmd->buttons;

	mov	eax, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _ucmd$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+620], edx

; 1059 : 	clent->v.light_level = ucmd->lightlevel;

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+28]
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+460], ecx

; 1060 : 	if( ucmd->impulse ) clent->v.impulse = ucmd->impulse;

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN9@SV_RunCmd
	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+36]
	mov	edx, DWORD PTR _clent$[ebp]
	mov	DWORD PTR [edx+624], ecx
$LN9@SV_RunCmd:

; 1061 : 
; 1062 : 	if( ucmd->impulse == 204 )

	mov	eax, DWORD PTR _ucmd$[ebp]
	movzx	ecx, BYTE PTR [eax+36]
	cmp	ecx, 204				; 000000ccH
	jne	SHORT $LN10@SV_RunCmd

; 1063 : 	{
; 1064 : 		// force client.dll update
; 1065 : 		SV_RefreshUserinfo();

	call	_SV_RefreshUserinfo
$LN10@SV_RunCmd:

; 1066 : 	}
; 1067 : 
; 1068 : 	svgame.globals->time = cl->timebase;

	mov	eax, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [eax+264368]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx], xmm0

; 1069 : 	svgame.dllFuncs.pfnPlayerPreThink( clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19364
	add	esp, 4

; 1070 : 	SV_PlayerRunThink( clent, frametime, cl->timebase );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+264368]
	movsd	QWORD PTR [esp], xmm0
	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	call	_SV_PlayerRunThink
	add	esp, 16					; 00000010H

; 1071 : 
; 1072 : 	// If conveyor, or think, set basevelocity, then send to client asap too.
; 1073 : 	if( !VectorIsNull( clent->v.basevelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_RunCmd
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_RunCmd
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@SV_RunCmd
$LN12@SV_RunCmd:

; 1074 : 		VectorCopy( clent->v.basevelocity, clent->v.clbasevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+172]
	mov	DWORD PTR [edx+eax+184], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [esi+edx+172]
	mov	DWORD PTR [ecx+eax+184], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [esi+eax+172]
	mov	DWORD PTR [edx+ecx+184], eax
$LN11@SV_RunCmd:

; 1075 : 
; 1076 : 	// setup playermove state
; 1077 : 	SV_SetupPMove( svgame.pmove, cl, ucmd, cl->physinfo );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	mov	ecx, DWORD PTR _ucmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	call	_SV_SetupPMove
	add	esp, 16					; 00000010H

; 1078 : 
; 1079 : 	// motor!
; 1080 : 	svgame.dllFuncs.pfnPM_Move( svgame.pmove, true );

	push	1
	mov	eax, DWORD PTR _svgame+8256
	push	eax
	call	DWORD PTR _svgame+19408
	add	esp, 8

; 1081 : 
; 1082 : 	// copy results back to client
; 1083 : 	SV_FinishPMove( svgame.pmove, cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	call	_SV_FinishPMove
	add	esp, 8

; 1084 : 
; 1085 : 	if( clent->v.solid != SOLID_NOT && !sv.playersonly )

	mov	eax, DWORD PTR _clent$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	$LN15@SV_RunCmd
	cmp	DWORD PTR _sv+2595648, 0
	jne	$LN15@SV_RunCmd

; 1086 : 	{
; 1087 : 		if( svgame.physFuncs.PM_PlayerTouch != NULL )

	cmp	DWORD PTR _svgame+19572, 0
	je	SHORT $LN14@SV_RunCmd

; 1088 : 		{
; 1089 : 			// run custom impact function
; 1090 : 			svgame.physFuncs.PM_PlayerTouch( svgame.pmove, clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _svgame+8256
	push	ecx
	call	DWORD PTR _svgame+19572
	add	esp, 8

; 1091 : 		}

	jmp	$LN15@SV_RunCmd
$LN14@SV_RunCmd:

; 1092 : 		else
; 1093 : 		{
; 1094 : 			// link into place and touch triggers
; 1095 : 			SV_LinkEdict( clent, true );

	push	1
	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 1096 : 			VectorCopy( clent->v.velocity, oldvel ); // save velocity

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _oldvel$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _oldvel$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _oldvel$[ebp+ecx], eax

; 1097 : 
; 1098 : 			// touch other objects
; 1099 : 			for( i = 0; i < svgame.pmove->numtouch; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_RunCmd
$LN2@SV_RunCmd:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_RunCmd:
	mov	eax, DWORD PTR _svgame+8256
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+283792]
	jge	$LN3@SV_RunCmd

; 1100 : 			{
; 1101 : 				pmtrace = &svgame.pmove->touchindex[i];

	imul	eax, DWORD PTR _i$[ebp], 68
	mov	ecx, DWORD PTR _svgame+8256
	lea	edx, DWORD PTR [ecx+eax+283796]
	mov	DWORD PTR _pmtrace$[ebp], edx

; 1102 : 				touch = EDICT_NUM( svgame.pmove->physents[pmtrace->ent].info );

	mov	eax, DWORD PTR _pmtrace$[ebp]
	imul	ecx, DWORD PTR [eax+48], 224
	mov	edx, DWORD PTR _svgame+8256
	mov	eax, DWORD PTR [edx+ecx+672]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _touch$[ebp], eax

; 1103 : 				VectorCopy( pmtrace->deltavelocity, clent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+52]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	edx, DWORD PTR [esi+edx+52]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	esi, DWORD PTR _pmtrace$[ebp]
	mov	eax, DWORD PTR [esi+eax+52]
	mov	DWORD PTR [edx+ecx+160], eax

; 1104 : 				PM_ConvertTrace( &trace, pmtrace, touch );

	mov	eax, DWORD PTR _touch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmtrace$[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace$[ebp]
	push	edx
	call	_PM_ConvertTrace
	add	esp, 12					; 0000000cH

; 1105 : 				SV_Impact( touch, clent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _touch$[ebp]
	push	edx
	call	_SV_Impact
	add	esp, 12					; 0000000cH

; 1106 : 			}

	jmp	$LN2@SV_RunCmd
$LN3@SV_RunCmd:

; 1107 : 
; 1108 : 			// restore velocity
; 1109 : 			VectorCopy( oldvel, clent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _clent$[ebp]
	mov	ecx, DWORD PTR _oldvel$[ebp+ecx]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _clent$[ebp]
	mov	edx, DWORD PTR _oldvel$[ebp+edx]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _clent$[ebp]
	mov	eax, DWORD PTR _oldvel$[ebp+eax]
	mov	DWORD PTR [edx+ecx+160], eax
$LN15@SV_RunCmd:

; 1110 : 		}
; 1111 : 	}
; 1112 : 
; 1113 : 	svgame.pmove->numtouch = 0;

	mov	eax, DWORD PTR _svgame+8256
	mov	DWORD PTR [eax+283792], 0

; 1114 : 	svgame.globals->time = cl->timebase;

	mov	eax, DWORD PTR _cl$[ebp]
	cvtsd2ss xmm0, QWORD PTR [eax+264368]
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx], xmm0

; 1115 : 	svgame.globals->frametime = frametime;

	cvtsd2ss xmm0, QWORD PTR _frametime$[ebp]
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax+4], xmm0

; 1116 : 
; 1117 : 	// run post-think
; 1118 : 	svgame.dllFuncs.pfnPlayerPostThink( clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19368
	add	esp, 4

; 1119 : 	svgame.dllFuncs.pfnCmdEnd( clent );

	mov	eax, DWORD PTR _clent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19448
	add	esp, 4

; 1120 : 
; 1121 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN16@SV_RunCmd

; 1122 : 	{
; 1123 : 		SV_RestoreMoveInterpolant( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_RestoreMoveInterpolant
	add	esp, 4
$LN16@SV_RunCmd:

; 1124 : 	}
; 1125 : }                                                         

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RunCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_pmove.c
;	COMDAT _SV_ClipPMoveToEntity
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_mins$ = 16						; size = 4
_maxs$ = 20						; size = 4
_end$ = 24						; size = 4
_tr$ = 28						; size = 4
_SV_ClipPMoveToEntity PROC				; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 48   : 	Assert( tr != NULL );

	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $LN5@SV_ClipPMo
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@SV_ClipPMo
$LN5@SV_ClipPMo:
	mov	DWORD PTR tv70[ebp], 0
$LN6@SV_ClipPMo:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ClipPMoveToEntity@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@JEBFDBAM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@GPFGHGBN@tr?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 49   : 
; 50   : 	if( svgame.physFuncs.ClipPMoveToEntity != NULL )

	cmp	DWORD PTR _svgame+19540, 0
	je	SHORT $LN2@SV_ClipPMo

; 51   : 	{
; 52   : 		// do custom sweep test
; 53   : 		svgame.physFuncs.ClipPMoveToEntity( pe, start, mins, maxs, end, tr );

	mov	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	DWORD PTR _svgame+19540
	add	esp, 24					; 00000018H

; 54   : 	}

	jmp	SHORT $LN1@SV_ClipPMo
$LN2@SV_ClipPMo:

; 55   : 	else
; 56   : 	{
; 57   : 		// function is missed, so we didn't hit anything
; 58   : 		tr->allsolid = false;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@SV_ClipPMo:

; 59   : 	}
; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipPMoveToEntity ENDP
_TEXT	ENDS
END
