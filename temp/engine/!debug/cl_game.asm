; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_game.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnDrawConsoleString
PUBLIC	_pfnDrawSetTextColor
PUBLIC	_pfnDrawConsoleStringLen
PUBLIC	_CL_GetEntityByIndex
PUBLIC	_CL_GetMaxClients
PUBLIC	_CL_TextMessageGet
PUBLIC	_pfnIndexFromTrace
PUBLIC	_CL_ModelHandle
PUBLIC	_NetAPI_CancelAllRequests
PUBLIC	_CL_FindModelIndex
PUBLIC	_CL_GetLocalPlayer
PUBLIC	_CL_LoadModel
PUBLIC	_pfnSPR_Load
PUBLIC	_CL_FillRGBA
PUBLIC	_CL_FillRGBACircle
PUBLIC	_CL_PlayerTrace
PUBLIC	_CL_PlayerTraceExt
PUBLIC	_CL_SetTraceHull
PUBLIC	_CL_GetCrosshairPosX
PUBLIC	_CL_GetCrosshairPosY
PUBLIC	_CL_AddEntity
PUBLIC	_TriBegin
PUBLIC	_TriTexCoord2f
PUBLIC	_TriVertex3fv
PUBLIC	_TriVertex3f
PUBLIC	_TriBoxInPVS
PUBLIC	_TriColor4f
PUBLIC	_TriSpriteTexture
PUBLIC	_TriColor4fRendermode
PUBLIC	_TriColor4ub
PUBLIC	_TriBrightness
PUBLIC	_TriRenderMode
PUBLIC	_TriCullFace
PUBLIC	_TriEnd
PUBLIC	_CL_SoundFromIndex
PUBLIC	_CL_GetSpritePointer
PUBLIC	_pfnIsNoClipping
PUBLIC	_pfnCalcShake
PUBLIC	_pfnApplyShake
PUBLIC	_pfnPlaySound
PUBLIC	_pfnIsLocal
PUBLIC	_pfnLocalPlayerDucking
PUBLIC	_pfnLocalPlayerViewheight
PUBLIC	_pfnLocalPlayerBounds
PUBLIC	_pfnGetPhysent
PUBLIC	_pfnGetVisent
PUBLIC	_pfnStopAllSounds
PUBLIC	_pfnGetGameDirectory
PUBLIC	_Key_LookupBinding
PUBLIC	_pfnLoadMapSprite
PUBLIC	_PlayerInfo_ValueForKey
PUBLIC	_PlayerInfo_SetValueForKey
PUBLIC	_pfnGetPlayerUniqueID
PUBLIC	_pfnGetTrackerIDForPlayer
PUBLIC	_pfnGetPlayerForTrackerID
PUBLIC	_pfnServerCmdUnreliable
PUBLIC	_pfnGetMousePos
PUBLIC	_pfnSetMousePos
PUBLIC	_pfnSetMouseEnable
PUBLIC	_pfnParseFile
PUBLIC	_pfnGetClientOldTime
PUBLIC	_pfnGetGravity
PUBLIC	_LocalPlayerInfo_ValueForKey
PUBLIC	_CL_FillRGBABlend
PUBLIC	_pfnGetAppID
PUBLIC	_TriFog
PUBLIC	_TriGetMatrix
PUBLIC	_TriLightAtPoint
PUBLIC	_TriFogParams
PUBLIC	_NetAPI_InitNetworking
PUBLIC	_NetAPI_Status
PUBLIC	_NetAPI_SendRequest
PUBLIC	_NetAPI_CancelRequest
PUBLIC	_NetAPI_AdrToString
PUBLIC	_NetAPI_CompareAdr
PUBLIC	_NetAPI_StringToAdr
PUBLIC	_NetAPI_ValueForKey
PUBLIC	_NetAPI_RemoveKey
PUBLIC	_NetAPI_SetValueForKey
PUBLIC	_Voice_StartVoiceTweakMode
PUBLIC	_Voice_EndVoiceTweakMode
PUBLIC	_Voice_SetControlFloat
PUBLIC	_Voice_GetControlFloat
PUBLIC	??_C@_0L@KIAPHAEH@Initialize@			; `string'
PUBLIC	??_C@_0M@BNFLOIOL@HUD_VidInit@			; `string'
PUBLIC	??_C@_08KOKJKKPB@HUD_Init@			; `string'
PUBLIC	??_C@_0N@FOFGBJMN@HUD_Shutdown@			; `string'
PUBLIC	??_C@_0L@MACKNJBP@HUD_Redraw@			; `string'
PUBLIC	??_C@_0BF@IDOJKCBG@HUD_UpdateClientData@	; `string'
PUBLIC	??_C@_09LNMGGKCH@HUD_Reset@			; `string'
PUBLIC	??_C@_0P@OCPLMJPB@HUD_PlayerMove@		; `string'
PUBLIC	??_C@_0BD@JLKHJBHK@HUD_PlayerMoveInit@		; `string'
PUBLIC	??_C@_0BG@EHKDLCEB@HUD_PlayerMoveTexture@	; `string'
PUBLIC	??_C@_0BJ@NHLLPFJM@HUD_ConnectionlessPacket@	; `string'
PUBLIC	??_C@_0BC@HBPCODFF@HUD_GetHullBounds@		; `string'
PUBLIC	??_C@_09FAJLIMIE@HUD_Frame@			; `string'
PUBLIC	??_C@_0P@FNDJODC@HUD_PostRunCmd@		; `string'
PUBLIC	??_C@_0O@KKOLLGPA@HUD_Key_Event@		; `string'
PUBLIC	??_C@_0O@HHMAJEMG@HUD_AddEntity@		; `string'
PUBLIC	??_C@_0BD@BGCECFFH@HUD_CreateEntities@		; `string'
PUBLIC	??_C@_0BA@PJGHODE@HUD_StudioEvent@		; `string'
PUBLIC	??_C@_0BI@KCDAEKFC@HUD_TxferLocalOverrides@	; `string'
PUBLIC	??_C@_0BH@JBPIPNPI@HUD_ProcessPlayerState@	; `string'
PUBLIC	??_C@_0BI@OEEHHCL@HUD_TxferPredictionData@	; `string'
PUBLIC	??_C@_0BC@NEMGKNDL@HUD_TempEntUpdate@		; `string'
PUBLIC	??_C@_0BI@HECHJHPH@HUD_DrawNormalTriangles@	; `string'
PUBLIC	??_C@_0BN@JBAALJFI@HUD_DrawTransparentTriangles@ ; `string'
PUBLIC	??_C@_0BC@JEJJDIEE@HUD_GetUserEntity@		; `string'
PUBLIC	??_C@_0BA@BPANJAAD@Demo_ReadBuffer@		; `string'
PUBLIC	??_C@_09HLCHOIKO@CAM_Think@			; `string'
PUBLIC	??_C@_0BB@MILNFHEF@CL_IsThirdPerson@		; `string'
PUBLIC	??_C@_0BA@DBBAAIFO@CL_CameraOffset@		; `string'
PUBLIC	??_C@_0O@GCJGNMG@CL_CreateMove@			; `string'
PUBLIC	??_C@_0BB@EGPEAGMP@IN_ActivateMouse@		; `string'
PUBLIC	??_C@_0BD@EHOCBNEH@IN_DeactivateMouse@		; `string'
PUBLIC	??_C@_0O@JIJPHNAI@IN_MouseEvent@		; `string'
PUBLIC	??_C@_0O@EBMDGJDF@IN_Accumulate@		; `string'
PUBLIC	??_C@_0P@DHGCILML@IN_ClearStates@		; `string'
PUBLIC	??_C@_0N@LBEJBAMA@V_CalcRefdef@			; `string'
PUBLIC	??_C@_07BCCDHNLG@KB_Find@			; `string'
PUBLIC	??_C@_0BM@DLIIKKOD@HUD_GetStudioModelInterface@	; `string'
PUBLIC	??_C@_0BE@LCHDHOCI@HUD_DirectorMessage@		; `string'
PUBLIC	??_C@_0BA@NBAMOJFL@HUD_VoiceStatus@		; `string'
PUBLIC	??_C@_0BG@JKMGFIAH@HUD_ChatInputPosition@	; `string'
PUBLIC	??_C@_0BH@NLGOFIFB@HUD_GetRenderInterface@	; `string'
PUBLIC	??_C@_0BF@HNAOHCPH@HUD_ClipMoveToEntity@	; `string'
PUBLIC	_vidmode2
PUBLIC	??_C@_09OMPCNDEM@640?5x?5480@			; `string'
PUBLIC	??_C@_09LMNCLMA@800?5x?5600@			; `string'
PUBLIC	??_C@_09CMCNIKHP@960?5x?5720@			; `string'
PUBLIC	??_C@_0L@KHKHJBNB@1024?5x?5768@			; `string'
PUBLIC	??_C@_0L@BOLNMBPL@1152?5x?5864@			; `string'
PUBLIC	??_C@_0L@CGABCDGE@1280?5x?5800@			; `string'
PUBLIC	??_C@_0L@JKDADILD@1280?5x?5960@			; `string'
PUBLIC	??_C@_0M@PPEHOBIK@1280?5x?51024@		; `string'
PUBLIC	??_C@_0M@JBKIALBN@1600?5x?51200@		; `string'
PUBLIC	??_C@_0M@HFHLDAKK@2048?5x?51536@		; `string'
PUBLIC	??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@	; `string'
PUBLIC	_gTriApi
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddClientCommand:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_pfnCvar_RegisterClientVariable:PROC
EXTRN	_pfnCVarGetPointer:PROC
EXTRN	_COM_CheckParm:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_Key_Event:PROC
EXTRN	_COM_LoadFile:PROC
EXTRN	_COM_AddAppDirectoryToSearchPath:PROC
EXTRN	_COM_ExpandFilename:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_CL_PlaybackEvent:PROC
EXTRN	_CL_SetSolidPlayers:PROC
EXTRN	_CL_WaterEntity:PROC
EXTRN	_CL_TestLine:PROC
EXTRN	_CL_VisTraceLine:PROC
EXTRN	_CL_PushTraceBounds:PROC
EXTRN	_CL_PopTraceBounds:PROC
EXTRN	_CL_PushPMStates:PROC
EXTRN	_CL_PopPMStates:PROC
EXTRN	_CL_SetUpPlayerPrediction:PROC
EXTRN	_CL_WeaponAnim:PROC
EXTRN	_CL_FireCustomDecal:PROC
EXTRN	_CL_DecalShoot:PROC
EXTRN	_Con_Visible:PROC
EXTRN	_R_AllocParticle:PROC
EXTRN	_R_Explosion:PROC
EXTRN	_R_ParticleExplosion:PROC
EXTRN	_R_ParticleExplosion2:PROC
EXTRN	_R_Implosion:PROC
EXTRN	_R_Blood:PROC
EXTRN	_R_BloodStream:PROC
EXTRN	_R_BlobExplosion:PROC
EXTRN	_R_EntityParticles:PROC
EXTRN	_R_FlickerParticles:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_R_ParticleBurst:PROC
EXTRN	_R_LavaSplash:PROC
EXTRN	_R_TeleportSplash:PROC
EXTRN	_R_RocketTrail:PROC
EXTRN	_R_LookupColor:PROC
EXTRN	_R_GetPackedColor:PROC
EXTRN	_R_TracerEffect:PROC
EXTRN	_R_UserTracerParticle:PROC
EXTRN	_R_TracerParticles:PROC
EXTRN	_R_ParticleLine:PROC
EXTRN	_R_ParticleBox:PROC
EXTRN	_R_ShowLine:PROC
EXTRN	_R_BulletImpactParticles:PROC
EXTRN	_R_SparkShower:PROC
EXTRN	_CL_TempEntAlloc:PROC
EXTRN	_CL_TempEntAllocHigh:PROC
EXTRN	_CL_TempEntAllocNoModel:PROC
EXTRN	_CL_TempEntAllocCustom:PROC
EXTRN	_R_FizzEffect:PROC
EXTRN	_R_Bubbles:PROC
EXTRN	_R_BubbleTrail:PROC
EXTRN	_R_AttachTentToPlayer:PROC
EXTRN	_R_KillAttachedTents:PROC
EXTRN	_R_RicochetSprite:PROC
EXTRN	_R_RocketFlare:PROC
EXTRN	_R_MuzzleFlash:PROC
EXTRN	_R_BloodSprite:PROC
EXTRN	_R_BreakModel:PROC
EXTRN	_R_TempModel:PROC
EXTRN	_R_TempSprite:PROC
EXTRN	_R_DefaultSprite:PROC
EXTRN	_R_Sprite_Explode:PROC
EXTRN	_R_Sprite_Smoke:PROC
EXTRN	_R_Spray:PROC
EXTRN	_R_Sprite_Spray:PROC
EXTRN	_R_Sprite_Trail:PROC
EXTRN	_R_FunnelSprite:PROC
EXTRN	_R_LargeFunnel:PROC
EXTRN	_R_SparkEffect:PROC
EXTRN	_R_StreakSplash:PROC
EXTRN	_R_SparkStreaks:PROC
EXTRN	_R_Projectile:PROC
EXTRN	_R_TempSphereModel:PROC
EXTRN	_R_MultiGunshot:PROC
EXTRN	_R_FireField:PROC
EXTRN	_R_PlayerSprites:PROC
EXTRN	_R_Sprite_WallPuff:PROC
EXTRN	_R_RicochetSound:PROC
EXTRN	_CL_AllocDlight:PROC
EXTRN	_CL_AllocElight:PROC
EXTRN	_CL_DecalRemoveAll:PROC
EXTRN	_CL_DecalIndexFromName:PROC
EXTRN	_CL_DecalIndex:PROC
EXTRN	_R_BeamLightning:PROC
EXTRN	_R_BeamEnts:PROC
EXTRN	_R_BeamPoints:PROC
EXTRN	_R_BeamCirclePoints:PROC
EXTRN	_R_BeamEntPoint:PROC
EXTRN	_R_BeamRing:PROC
EXTRN	_R_BeamFollow:PROC
EXTRN	_R_BeamKill:PROC
EXTRN	_R_WorldToScreen:PROC
EXTRN	_R_ScreenToWorld:PROC
EXTRN	_VGui_GetPanel:PROC
EXTRN	_VGui_ViewportPaintBackground:PROC
EXTRN	_clgame:BYTE
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_cl_textbuffer:BYTE:04000H
COMM	_cl_textmessage:BYTE:0160H
_DATA	ENDS
;	COMDAT ??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@ DB '3840 x 2160 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@ DB '1600 x 900 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@ DB '2560 x 1600 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@ DB '2560 x 1440 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@ DB '1920 x 1200 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@ DB '1920 x 1080 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@ DB '1680 x 1050 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@ DB '1440 x 900 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@ DB '1366 x 768 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@ DB '1360 x 768 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@ DB '1280 x 720 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@ DB '1024 x 600 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@ DB '1024 x 576 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@ DB '960 x 540 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@ DB '856 x 480 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@ DB '800 x 480 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HFHLDAKK@2048?5x?51536@
CONST	SEGMENT
??_C@_0M@HFHLDAKK@2048?5x?51536@ DB '2048 x 1536', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBKIALBN@1600?5x?51200@
CONST	SEGMENT
??_C@_0M@JBKIALBN@1600?5x?51200@ DB '1600 x 1200', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPEHOBIK@1280?5x?51024@
CONST	SEGMENT
??_C@_0M@PPEHOBIK@1280?5x?51024@ DB '1280 x 1024', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKDADILD@1280?5x?5960@
CONST	SEGMENT
??_C@_0L@JKDADILD@1280?5x?5960@ DB '1280 x 960', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CGABCDGE@1280?5x?5800@
CONST	SEGMENT
??_C@_0L@CGABCDGE@1280?5x?5800@ DB '1280 x 800', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOLNMBPL@1152?5x?5864@
CONST	SEGMENT
??_C@_0L@BOLNMBPL@1152?5x?5864@ DB '1152 x 864', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHKHJBNB@1024?5x?5768@
CONST	SEGMENT
??_C@_0L@KHKHJBNB@1024?5x?5768@ DB '1024 x 768', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CMCNIKHP@960?5x?5720@
CONST	SEGMENT
??_C@_09CMCNIKHP@960?5x?5720@ DB '960 x 720', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMNCLMA@800?5x?5600@
CONST	SEGMENT
??_C@_09LMNCLMA@800?5x?5600@ DB '800 x 600', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMPCNDEM@640?5x?5480@
CONST	SEGMENT
??_C@_09OMPCNDEM@640?5x?5480@ DB '640 x 480', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_vidmode2 DD	FLAT:??_C@_09OMPCNDEM@640?5x?5480@
	DD	0280H
	DD	01e0H
	DD	00H
	DD	FLAT:??_C@_09LMNCLMA@800?5x?5600@
	DD	0320H
	DD	0258H
	DD	00H
	DD	FLAT:??_C@_09CMCNIKHP@960?5x?5720@
	DD	03c0H
	DD	02d0H
	DD	00H
	DD	FLAT:??_C@_0L@KHKHJBNB@1024?5x?5768@
	DD	0400H
	DD	0300H
	DD	00H
	DD	FLAT:??_C@_0L@BOLNMBPL@1152?5x?5864@
	DD	0480H
	DD	0360H
	DD	00H
	DD	FLAT:??_C@_0L@CGABCDGE@1280?5x?5800@
	DD	0500H
	DD	0320H
	DD	00H
	DD	FLAT:??_C@_0L@JKDADILD@1280?5x?5960@
	DD	0500H
	DD	03c0H
	DD	00H
	DD	FLAT:??_C@_0M@PPEHOBIK@1280?5x?51024@
	DD	0500H
	DD	0400H
	DD	00H
	DD	FLAT:??_C@_0M@JBKIALBN@1600?5x?51200@
	DD	0640H
	DD	04b0H
	DD	00H
	DD	FLAT:??_C@_0M@HFHLDAKK@2048?5x?51536@
	DD	0800H
	DD	0600H
	DD	00H
	DD	FLAT:??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@
	DD	0320H
	DD	01e0H
	DD	01H
	DD	FLAT:??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@
	DD	0358H
	DD	01e0H
	DD	01H
	DD	FLAT:??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@
	DD	03c0H
	DD	021cH
	DD	01H
	DD	FLAT:??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@
	DD	0400H
	DD	0240H
	DD	01H
	DD	FLAT:??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@
	DD	0400H
	DD	0258H
	DD	01H
	DD	FLAT:??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@
	DD	0500H
	DD	02d0H
	DD	01H
	DD	FLAT:??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@
	DD	0550H
	DD	0300H
	DD	01H
	DD	FLAT:??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@
	DD	0556H
	DD	0300H
	DD	01H
	DD	FLAT:??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@
	DD	05a0H
	DD	0384H
	DD	01H
	DD	FLAT:??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@
	DD	0690H
	DD	041aH
	DD	01H
	DD	FLAT:??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@
	DD	0780H
	DD	0438H
	DD	01H
	DD	FLAT:??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@
	DD	0780H
	DD	04b0H
	DD	01H
	DD	FLAT:??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@
	DD	0a00H
	DD	05a0H
	DD	01H
	DD	FLAT:??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@
	DD	0a00H
	DD	0640H
	DD	01H
	DD	FLAT:??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@
	DD	0640H
	DD	0384H
	DD	01H
	DD	FLAT:??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@
	DD	0f00H
	DD	0870H
	DD	01H
_gTriApi DD	01H
	DD	FLAT:_TriRenderMode
	DD	FLAT:_TriBegin
	DD	FLAT:_TriEnd
	DD	FLAT:_TriColor4f
	DD	FLAT:_TriColor4ub
	DD	FLAT:_TriTexCoord2f
	DD	FLAT:_TriVertex3fv
	DD	FLAT:_TriVertex3f
	DD	FLAT:_TriBrightness
	DD	FLAT:_TriCullFace
	DD	FLAT:_TriSpriteTexture
	DD	FLAT:_R_WorldToScreen
	DD	FLAT:_TriFog
	DD	FLAT:_R_ScreenToWorld
	DD	FLAT:_TriGetMatrix
	DD	FLAT:_TriBoxInPVS
	DD	FLAT:_TriLightAtPoint
	DD	FLAT:_TriColor4fRendermode
	DD	FLAT:_TriFogParams
_gEfxApi DD	FLAT:_R_AllocParticle
	DD	FLAT:_R_BlobExplosion
	DD	FLAT:_R_Blood
	DD	FLAT:_R_BloodSprite
	DD	FLAT:_R_BloodStream
	DD	FLAT:_R_BreakModel
	DD	FLAT:_R_Bubbles
	DD	FLAT:_R_BubbleTrail
	DD	FLAT:_R_BulletImpactParticles
	DD	FLAT:_R_EntityParticles
	DD	FLAT:_R_Explosion
	DD	FLAT:_R_FizzEffect
	DD	FLAT:_R_FireField
	DD	FLAT:_R_FlickerParticles
	DD	FLAT:_R_FunnelSprite
	DD	FLAT:_R_Implosion
	DD	FLAT:_R_LargeFunnel
	DD	FLAT:_R_LavaSplash
	DD	FLAT:_R_MultiGunshot
	DD	FLAT:_R_MuzzleFlash
	DD	FLAT:_R_ParticleBox
	DD	FLAT:_R_ParticleBurst
	DD	FLAT:_R_ParticleExplosion
	DD	FLAT:_R_ParticleExplosion2
	DD	FLAT:_R_ParticleLine
	DD	FLAT:_R_PlayerSprites
	DD	FLAT:_R_Projectile
	DD	FLAT:_R_RicochetSound
	DD	FLAT:_R_RicochetSprite
	DD	FLAT:_R_RocketFlare
	DD	FLAT:_R_RocketTrail
	DD	FLAT:_R_RunParticleEffect
	DD	FLAT:_R_ShowLine
	DD	FLAT:_R_SparkEffect
	DD	FLAT:_R_SparkShower
	DD	FLAT:_R_SparkStreaks
	DD	FLAT:_R_Spray
	DD	FLAT:_R_Sprite_Explode
	DD	FLAT:_R_Sprite_Smoke
	DD	FLAT:_R_Sprite_Spray
	DD	FLAT:_R_Sprite_Trail
	DD	FLAT:_R_Sprite_WallPuff
	DD	FLAT:_R_StreakSplash
	DD	FLAT:_R_TracerEffect
	DD	FLAT:_R_UserTracerParticle
	DD	FLAT:_R_TracerParticles
	DD	FLAT:_R_TeleportSplash
	DD	FLAT:_R_TempSphereModel
	DD	FLAT:_R_TempModel
	DD	FLAT:_R_DefaultSprite
	DD	FLAT:_R_TempSprite
	DD	FLAT:_CL_DecalIndex
	DD	FLAT:_CL_DecalIndexFromName
	DD	FLAT:_CL_DecalShoot
	DD	FLAT:_R_AttachTentToPlayer
	DD	FLAT:_R_KillAttachedTents
	DD	FLAT:_R_BeamCirclePoints
	DD	FLAT:_R_BeamEntPoint
	DD	FLAT:_R_BeamEnts
	DD	FLAT:_R_BeamFollow
	DD	FLAT:_R_BeamKill
	DD	FLAT:_R_BeamLightning
	DD	FLAT:_R_BeamPoints
	DD	FLAT:_R_BeamRing
	DD	FLAT:_CL_AllocDlight
	DD	FLAT:_CL_AllocElight
	DD	FLAT:_CL_TempEntAlloc
	DD	FLAT:_CL_TempEntAllocNoModel
	DD	FLAT:_CL_TempEntAllocHigh
	DD	FLAT:_CL_TempEntAllocCustom
	DD	FLAT:_R_GetPackedColor
	DD	FLAT:_R_LookupColor
	DD	FLAT:_CL_DecalRemoveAll
	DD	FLAT:_CL_FireCustomDecal
_gEventApi DD	01H
	DD	FLAT:_pfnPlaySound
	DD	FLAT:_S_StopSound
	DD	FLAT:_CL_FindModelIndex
	DD	FLAT:_pfnIsLocal
	DD	FLAT:_pfnLocalPlayerDucking
	DD	FLAT:_pfnLocalPlayerViewheight
	DD	FLAT:_pfnLocalPlayerBounds
	DD	FLAT:_pfnIndexFromTrace
	DD	FLAT:_pfnGetPhysent
	DD	FLAT:_CL_SetUpPlayerPrediction
	DD	FLAT:_CL_PushPMStates
	DD	FLAT:_CL_PopPMStates
	DD	FLAT:_CL_SetSolidPlayers
	DD	FLAT:_CL_SetTraceHull
	DD	FLAT:_CL_PlayerTrace
	DD	FLAT:_CL_WeaponAnim
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_CL_PlaybackEvent
	DD	FLAT:_pfnTraceTexture
	DD	FLAT:_pfnStopAllSounds
	DD	FLAT:_pfnKillEvents
	DD	FLAT:_CL_PlayerTraceExt
	DD	FLAT:_CL_SoundFromIndex
	DD	FLAT:_pfnTraceSurface
	DD	FLAT:_pfnGetMoveVars
	DD	FLAT:_CL_VisTraceLine
	DD	FLAT:_pfnGetVisent
	DD	FLAT:_CL_TestLine
	DD	FLAT:_CL_PushTraceBounds
	DD	FLAT:_CL_PopTraceBounds
_gDemoApi DD	FLAT:_Demo_IsRecording
	DD	FLAT:_Demo_IsPlayingback
	DD	FLAT:_Demo_IsTimeDemo
	DD	FLAT:_Demo_WriteBuffer
_gNetApi DD	FLAT:_NetAPI_InitNetworking
	DD	FLAT:_NetAPI_Status
	DD	FLAT:_NetAPI_SendRequest
	DD	FLAT:_NetAPI_CancelRequest
	DD	FLAT:_NetAPI_CancelAllRequests
	DD	FLAT:_NetAPI_AdrToString
	DD	FLAT:_NetAPI_CompareAdr
	DD	FLAT:_NetAPI_StringToAdr
	DD	FLAT:_NetAPI_ValueForKey
	DD	FLAT:_NetAPI_RemoveKey
	DD	FLAT:_NetAPI_SetValueForKey
_gVoiceApi DD	FLAT:_Voice_StartVoiceTweakMode
	DD	FLAT:_Voice_EndVoiceTweakMode
	DD	FLAT:_Voice_SetControlFloat
	DD	FLAT:_Voice_GetControlFloat
_DATA	ENDS
;	COMDAT ??_C@_0BF@HNAOHCPH@HUD_ClipMoveToEntity@
CONST	SEGMENT
??_C@_0BF@HNAOHCPH@HUD_ClipMoveToEntity@ DB 'HUD_ClipMoveToEntity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NLGOFIFB@HUD_GetRenderInterface@
CONST	SEGMENT
??_C@_0BH@NLGOFIFB@HUD_GetRenderInterface@ DB 'HUD_GetRenderInterface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JKMGFIAH@HUD_ChatInputPosition@
CONST	SEGMENT
??_C@_0BG@JKMGFIAH@HUD_ChatInputPosition@ DB 'HUD_ChatInputPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBAMOJFL@HUD_VoiceStatus@
CONST	SEGMENT
??_C@_0BA@NBAMOJFL@HUD_VoiceStatus@ DB 'HUD_VoiceStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LCHDHOCI@HUD_DirectorMessage@
CONST	SEGMENT
??_C@_0BE@LCHDHOCI@HUD_DirectorMessage@ DB 'HUD_DirectorMessage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DLIIKKOD@HUD_GetStudioModelInterface@
CONST	SEGMENT
??_C@_0BM@DLIIKKOD@HUD_GetStudioModelInterface@ DB 'HUD_GetStudioModelInt'
	DB	'erface', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCCDHNLG@KB_Find@
CONST	SEGMENT
??_C@_07BCCDHNLG@KB_Find@ DB 'KB_Find', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LBEJBAMA@V_CalcRefdef@
CONST	SEGMENT
??_C@_0N@LBEJBAMA@V_CalcRefdef@ DB 'V_CalcRefdef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHGCILML@IN_ClearStates@
CONST	SEGMENT
??_C@_0P@DHGCILML@IN_ClearStates@ DB 'IN_ClearStates', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EBMDGJDF@IN_Accumulate@
CONST	SEGMENT
??_C@_0O@EBMDGJDF@IN_Accumulate@ DB 'IN_Accumulate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIJPHNAI@IN_MouseEvent@
CONST	SEGMENT
??_C@_0O@JIJPHNAI@IN_MouseEvent@ DB 'IN_MouseEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EHOCBNEH@IN_DeactivateMouse@
CONST	SEGMENT
??_C@_0BD@EHOCBNEH@IN_DeactivateMouse@ DB 'IN_DeactivateMouse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EGPEAGMP@IN_ActivateMouse@
CONST	SEGMENT
??_C@_0BB@EGPEAGMP@IN_ActivateMouse@ DB 'IN_ActivateMouse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCJGNMG@CL_CreateMove@
CONST	SEGMENT
??_C@_0O@GCJGNMG@CL_CreateMove@ DB 'CL_CreateMove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DBBAAIFO@CL_CameraOffset@
CONST	SEGMENT
??_C@_0BA@DBBAAIFO@CL_CameraOffset@ DB 'CL_CameraOffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MILNFHEF@CL_IsThirdPerson@
CONST	SEGMENT
??_C@_0BB@MILNFHEF@CL_IsThirdPerson@ DB 'CL_IsThirdPerson', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLCHOIKO@CAM_Think@
CONST	SEGMENT
??_C@_09HLCHOIKO@CAM_Think@ DB 'CAM_Think', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPANJAAD@Demo_ReadBuffer@
CONST	SEGMENT
??_C@_0BA@BPANJAAD@Demo_ReadBuffer@ DB 'Demo_ReadBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEJJDIEE@HUD_GetUserEntity@
CONST	SEGMENT
??_C@_0BC@JEJJDIEE@HUD_GetUserEntity@ DB 'HUD_GetUserEntity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JBAALJFI@HUD_DrawTransparentTriangles@
CONST	SEGMENT
??_C@_0BN@JBAALJFI@HUD_DrawTransparentTriangles@ DB 'HUD_DrawTransparentT'
	DB	'riangles', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HECHJHPH@HUD_DrawNormalTriangles@
CONST	SEGMENT
??_C@_0BI@HECHJHPH@HUD_DrawNormalTriangles@ DB 'HUD_DrawNormalTriangles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEMGKNDL@HUD_TempEntUpdate@
CONST	SEGMENT
??_C@_0BC@NEMGKNDL@HUD_TempEntUpdate@ DB 'HUD_TempEntUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OEEHHCL@HUD_TxferPredictionData@
CONST	SEGMENT
??_C@_0BI@OEEHHCL@HUD_TxferPredictionData@ DB 'HUD_TxferPredictionData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBPIPNPI@HUD_ProcessPlayerState@
CONST	SEGMENT
??_C@_0BH@JBPIPNPI@HUD_ProcessPlayerState@ DB 'HUD_ProcessPlayerState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KCDAEKFC@HUD_TxferLocalOverrides@
CONST	SEGMENT
??_C@_0BI@KCDAEKFC@HUD_TxferLocalOverrides@ DB 'HUD_TxferLocalOverrides', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PJGHODE@HUD_StudioEvent@
CONST	SEGMENT
??_C@_0BA@PJGHODE@HUD_StudioEvent@ DB 'HUD_StudioEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGCECFFH@HUD_CreateEntities@
CONST	SEGMENT
??_C@_0BD@BGCECFFH@HUD_CreateEntities@ DB 'HUD_CreateEntities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHMAJEMG@HUD_AddEntity@
CONST	SEGMENT
??_C@_0O@HHMAJEMG@HUD_AddEntity@ DB 'HUD_AddEntity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KKOLLGPA@HUD_Key_Event@
CONST	SEGMENT
??_C@_0O@KKOLLGPA@HUD_Key_Event@ DB 'HUD_Key_Event', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FNDJODC@HUD_PostRunCmd@
CONST	SEGMENT
??_C@_0P@FNDJODC@HUD_PostRunCmd@ DB 'HUD_PostRunCmd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAJLIMIE@HUD_Frame@
CONST	SEGMENT
??_C@_09FAJLIMIE@HUD_Frame@ DB 'HUD_Frame', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBPCODFF@HUD_GetHullBounds@
CONST	SEGMENT
??_C@_0BC@HBPCODFF@HUD_GetHullBounds@ DB 'HUD_GetHullBounds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NHLLPFJM@HUD_ConnectionlessPacket@
CONST	SEGMENT
??_C@_0BJ@NHLLPFJM@HUD_ConnectionlessPacket@ DB 'HUD_ConnectionlessPacket'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EHKDLCEB@HUD_PlayerMoveTexture@
CONST	SEGMENT
??_C@_0BG@EHKDLCEB@HUD_PlayerMoveTexture@ DB 'HUD_PlayerMoveTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLKHJBHK@HUD_PlayerMoveInit@
CONST	SEGMENT
??_C@_0BD@JLKHJBHK@HUD_PlayerMoveInit@ DB 'HUD_PlayerMoveInit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OCPLMJPB@HUD_PlayerMove@
CONST	SEGMENT
??_C@_0P@OCPLMJPB@HUD_PlayerMove@ DB 'HUD_PlayerMove', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LNMGGKCH@HUD_Reset@
CONST	SEGMENT
??_C@_09LNMGGKCH@HUD_Reset@ DB 'HUD_Reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IDOJKCBG@HUD_UpdateClientData@
CONST	SEGMENT
??_C@_0BF@IDOJKCBG@HUD_UpdateClientData@ DB 'HUD_UpdateClientData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MACKNJBP@HUD_Redraw@
CONST	SEGMENT
??_C@_0L@MACKNJBP@HUD_Redraw@ DB 'HUD_Redraw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FOFGBJMN@HUD_Shutdown@
CONST	SEGMENT
??_C@_0N@FOFGBJMN@HUD_Shutdown@ DB 'HUD_Shutdown', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KOKJKKPB@HUD_Init@
CONST	SEGMENT
??_C@_08KOKJKKPB@HUD_Init@ DB 'HUD_Init', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNFLOIOL@HUD_VidInit@
CONST	SEGMENT
??_C@_0M@BNFLOIOL@HUD_VidInit@ DB 'HUD_VidInit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIAPHAEH@Initialize@
CONST	SEGMENT
??_C@_0L@KIAPHAEH@Initialize@ DB 'Initialize', 00H	; `string'
CONST	ENDS
PUBLIC	_CL_IsThirdPerson
PUBLIC	_CL_PointContents
PUBLIC	_CL_GetPlayerInfo
PUBLIC	_CL_HudMessage
PUBLIC	_CL_LoadProgs
PUBLIC	_CL_ClearEdicts
PUBLIC	_CL_UnloadProgs
PUBLIC	_CL_LinkUserMessage
PUBLIC	_CL_ParseFinaleCutscene
PUBLIC	_CL_ParseTextMessage
PUBLIC	_CL_DrawHUD
PUBLIC	_CL_InitEdicts
PUBLIC	_CL_FreeEdicts
PUBLIC	_CL_ClearWorld
PUBLIC	_CL_DrawCenterPrint
PUBLIC	_CL_ClearSpriteTextures
PUBLIC	_CL_FreeEntity
PUBLIC	_CL_CenterPrint
PUBLIC	_CL_LoadClientSprite
PUBLIC	_pfnSPR_LoadExt
PUBLIC	_PicAdjustSize
PUBLIC	_PicAdjustScale
PUBLIC	_CL_EDICT_NUM
PUBLIC	_TriWorldToScreen
PUBLIC	_CL_DrawScreenFade
PUBLIC	_CL_DrawCrosshair
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_InitTitles@@9@9		; `CL_InitTitles'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0O@IDJGENMA@TextMessage?$CFi@		; `string'
PUBLIC	??_C@_07JNEKKACO@HudText@			; `string'
PUBLIC	?__LINE__Var@?0??CL_GetLocalPlayer@@9@9		; `CL_GetLocalPlayer'::`1'::__LINE__Var
PUBLIC	??_C@_0P@HGIIKDAL@player?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0DG@DBDANMHK@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5i@ ; `string'
PUBLIC	??_C@_0DE@EDLJDNCH@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5b@ ; `string'
PUBLIC	??_C@_0CG@JNEDKHCH@CL_LinkUserMessage?3?5bad?5message@ ; `string'
PUBLIC	??_C@_0DJ@ELCIIEJ@CL_LinkUserMessage?3?5tried?5to?5ho@ ; `string'
PUBLIC	??_C@_0CM@PACFIKIG@CL_LinkUserMessage?3?5MAX_USER_ME@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_FreeEntity@@9@9		; `CL_FreeEntity'::`1'::__LINE__Var
PUBLIC	??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@	; `string'
PUBLIC	?__LINE__Var@?0??CL_InitEdicts@@9@9		; `CL_InitEdicts'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@CHDGGDIF@clgame?4entities?5?$DN?$DN?5NULL@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_FreeEdicts@@9@9		; `CL_FreeEdicts'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CL_LoadHudSprite@@9@9		; `CL_LoadHudSprite'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@PLPDELIL@m_pSprite?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_0CK@NPFOHACF@?$FO1Error?3?$FO7?5CL_LoadSpriteModel?3?5@ ; `string'
PUBLIC	??_C@_0DD@FHBFLJHM@?$FO1Error?3?$FO7?5MAX_CLIENT_SPRITES?5l@ ; `string'
PUBLIC	?__LINE__Var@?0??pfnSPR_GetList@@9@9		; `pfnSPR_GetList'::`1'::__LINE__Var
PUBLIC	??_C@_0CJ@BEJKEGKD@?$FO1Error?3?$FO7?5SPR_GetList?3?5overflo@ ; `string'
PUBLIC	??_C@_0DF@KLPJHDAJ@?$FO3Warning?3?$FO7?5unexpected?5end?5of?5@ ; `string'
PUBLIC	??_C@_09GMLECNLK@hud_scale@			; `string'
PUBLIC	??_C@_0CF@DEPMEFPI@HookUserMsg?3?5MAX_USER_MESSAGES?5@ ; `string'
PUBLIC	??_C@_07EHMIKJCM@cmd?5?$CFs?6@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0CP@IAOEKLFI@?$FO3Warning?3?$FO7?5CL_HookEvent?3?5?$CFs?5a@ ; `string'
PUBLIC	??_C@_0BN@MDFPKJKH@?$FO1Error?3?$FO7?5?$CFs?5not?5precached?6@ ; `string'
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@		; `string'
PUBLIC	??_C@_0BD@NFJFLDNN@setinfo?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	?__LINE__Var@?0??NetAPI_Status@@9@9		; `NetAPI_Status'::`1'::__LINE__Var
PUBLIC	??_C@_0P@ONIFEFDD@status?5?$CB?$DN?5NULL@	; `string'
PUBLIC	?__LINE__Var@?0??NetAPI_SendRequest@@9@9	; `NetAPI_SendRequest'::`1'::__LINE__Var
PUBLIC	??_C@_0FA@ELMGLAIG@?$FO1Error?3?$FO7?5Net_SendRequest?3?5no?5@ ; `string'
PUBLIC	??_C@_0L@CDAPOKFC@nr?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@ ; `string'
PUBLIC	??_C@_0BB@HHNOHPEH@netinfo?5?$CFi?5?$CFi?5?$CFi@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_UnloadProgs@@9@9		; `CL_UnloadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_04EKNDDILJ@hlfx@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_0BC@CKKMCGJ@host_clientloaded@		; `string'
PUBLIC	?__LINE__Var@?0??CL_LoadProgs@@9@9		; `CL_LoadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@LLJHHINI@Client?5Static?5Pool@	; `string'
PUBLIC	??_C@_0BD@DHOCOKKI@Client?5Edicts?5Zone@	; `string'
PUBLIC	??_C@_0N@EHIMMPKH@GetClientAPI@			; `string'
PUBLIC	??_C@_0CM@BAEMLIIE@CL_LoadProgs?3?5found?5single?5call@ ; `string'
PUBLIC	??_C@_0DA@DLIHFHEG@CL_LoadProgs?3?5failed?5to?5get?5add@ ; `string'
PUBLIC	??_C@_0CF@FEOBBBIH@CL_LoadProgs?3?5can?8t?5init?5client@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0L@CFPFIGM@titles?4txt@			; `string'
PUBLIC	??_C@_0DE@OFHCNHND@?$FO3Warning?3?$FO7?5CL_LoadProgs?3?5coul@ ; `string'
PUBLIC	??_C@_0N@BMBEGFEI@cl_righthand@			; `string'
PUBLIC	??_C@_0BP@MNFFLFE@flip?5viewmodel?5?$CIleft?5to?5right?$CJ@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3e19999a
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@400921fb60000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@437fe666
PUBLIC	__real@43800000
PUBLIC	__real@43b40000
PUBLIC	__real@46000000
PUBLIC	__real@47c34f80
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cmd_Unlink:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_DirectSet:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_Unlink:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_NET_Config:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_StringToAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_ExtractFilePath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileSize:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Key_KeynumToString:PROC
EXTRN	_Key_GetKey:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_ServerCommand:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemoveKey:PROC
EXTRN	_Info_SetValueForStarKey:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	__imp__ceil:PROC
EXTRN	_Mod_ClearUserData:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_MSG_BigShort:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_CL_WriteDemoUserMessage:PROC
EXTRN	_CL_RegisterEvent:PROC
EXTRN	_CL_ResetEvent:PROC
EXTRN	_CL_EventIndex:PROC
EXTRN	_CL_TextMessageParse:PROC
EXTRN	_CL_DispatchUserMessage:PROC
EXTRN	_CL_InitClientMove:PROC
EXTRN	_CL_TruePointContents:PROC
EXTRN	_CL_InitStudioAPI:PROC
EXTRN	_CL_AddVisibleEntity:PROC
EXTRN	_CL_ClearAllRemaps:PROC
EXTRN	_CL_AddClientResource:PROC
EXTRN	_CL_InitParticles:PROC
EXTRN	_CL_FreeParticles:PROC
EXTRN	_CL_InitTempEnts:PROC
EXTRN	_CL_FreeTempEnts:PROC
EXTRN	_CL_InitViewBeams:PROC
EXTRN	_CL_FreeViewBeams:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_Con_DrawCharacter:PROC
EXTRN	_Con_DrawCharacterLen:PROC
EXTRN	_Con_SetFont:PROC
EXTRN	_Con_RestoreFont:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_pfnPIC_Set:PROC
EXTRN	_pfnPIC_DrawAdditive:PROC
EXTRN	_pfnPIC_DrawAdditiveAlt:PROC
EXTRN	_PM_PlayerTraceExt:PROC
EXTRN	_PM_TraceTexture:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_LightPoint:PROC
EXTRN	_R_InitRenderAPI:PROC
EXTRN	_Mod_LoadSpriteModel:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	_R_GetSpriteParms:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	_R_DrawStretchPicRotate:PROC
EXTRN	_Mod_LoadMapSprite:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_R_GetSpriteTexture:PROC
EXTRN	_R_RemoveEfrags:PROC
EXTRN	_Mod_GetCurrentVis:PROC
EXTRN	_COM_LoadLibrary:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_COM_FreeLibrary:PROC
EXTRN	_VGui_Startup:PROC
EXTRN	_VGui_Shutdown:PROC
EXTRN	_S_GetSfxByHandle:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	_scr_loading:DWORD
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_svc_strings:BYTE
EXTRN	_net_local:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_cl_crosshair:DWORD
EXTRN	_cl_righthand:DWORD
EXTRN	_scr_centertime:DWORD
EXTRN	_rate:DWORD
EXTRN	_con_fontsize:DWORD
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glState:BYTE
EXTRN	_g_color_table:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?msgindex@?1??CL_ParseTextMessage@@9@9 DD 01H DUP (?)	; `CL_ParseTextMessage'::`2'::msgindex
?msgindex@?1??CL_ParseFinaleCutscene@@9@9 DD 01H DUP (?) ; `CL_ParseFinaleCutscene'::`2'::msgindex
?tr@?1??pfnTraceLine@@9@9 DB 044H DUP (?)		; `pfnTraceLine'::`2'::tr
?lasttimewarn@?1??CL_FindModelIndex@@9@9 DD 01H DUP (?)	; `CL_FindModelIndex'::`2'::lasttimewarn
?szGetGameDir@?1??pfnGetGameDirectory@@9@9 DB 0400H DUP (?) ; `pfnGetGameDirectory'::`2'::szGetGameDir
?mapname@?1??pfnGetLevelName@@9@9 DB 040H DUP (?)	; `pfnGetLevelName'::`2'::mapname
?gpMove@?1??CL_LoadProgs@@9@9 DB 04f5d4H DUP (?)	; `CL_LoadProgs'::`2'::gpMove
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@47c34f80
CONST	SEGMENT
__real@47c34f80 DD 047c34f80r			; 99999
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437fe666
CONST	SEGMENT
__real@437fe666 DD 0437fe666r			; 255.9
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@400921fb60000000
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BP@MNFFLFE@flip?5viewmodel?5?$CIleft?5to?5right?$CJ@
CONST	SEGMENT
??_C@_0BP@MNFFLFE@flip?5viewmodel?5?$CIleft?5to?5right?$CJ@ DB 'flip view'
	DB	'model (left to right)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BMBEGFEI@cl_righthand@
CONST	SEGMENT
??_C@_0N@BMBEGFEI@cl_righthand@ DB 'cl_righthand', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OFHCNHND@?$FO3Warning?3?$FO7?5CL_LoadProgs?3?5coul@
CONST	SEGMENT
??_C@_0DE@OFHCNHND@?$FO3Warning?3?$FO7?5CL_LoadProgs?3?5coul@ DB '^3Warni'
	DB	'ng:^7 CL_LoadProgs: couldn''t get render API', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFPFIGM@titles?4txt@
CONST	SEGMENT
??_C@_0L@CFPFIGM@titles?4txt@ DB 'titles.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FEOBBBIH@CL_LoadProgs?3?5can?8t?5init?5client@
CONST	SEGMENT
??_C@_0CF@FEOBBBIH@CL_LoadProgs?3?5can?8t?5init?5client@ DB 'CL_LoadProgs'
	DB	': can''t init client API', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DLIHFHEG@CL_LoadProgs?3?5failed?5to?5get?5add@
CONST	SEGMENT
??_C@_0DA@DLIHFHEG@CL_LoadProgs?3?5failed?5to?5get?5add@ DB 'CL_LoadProgs'
	DB	': failed to get address of %s proc', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BAEMLIIE@CL_LoadProgs?3?5found?5single?5call@
CONST	SEGMENT
??_C@_0CM@BAEMLIIE@CL_LoadProgs?3?5found?5single?5call@ DB 'CL_LoadProgs:'
	DB	' found single callback export', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHIMMPKH@GetClientAPI@
CONST	SEGMENT
??_C@_0N@EHIMMPKH@GetClientAPI@ DB 'GetClientAPI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHOCOKKI@Client?5Edicts?5Zone@
CONST	SEGMENT
??_C@_0BD@DHOCOKKI@Client?5Edicts?5Zone@ DB 'Client Edicts Zone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LLJHHINI@Client?5Static?5Pool@
CONST	SEGMENT
??_C@_0BD@LLJHHINI@Client?5Static?5Pool@ DB 'Client Static Pool', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_LoadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_LoadProgs@@9@9 DD 0108cH		; `CL_LoadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@CKKMCGJ@host_clientloaded@
CONST	SEGMENT
??_C@_0BC@CKKMCGJ@host_clientloaded@ DB 'host_clientloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKNDDILJ@hlfx@
CONST	SEGMENT
??_C@_04EKNDDILJ@hlfx@ DB 'hlfx', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_UnloadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_UnloadProgs@@9@9 DD 01070H		; `CL_UnloadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@HHNOHPEH@netinfo?5?$CFi?5?$CFi?5?$CFi@
CONST	SEGMENT
??_C@_0BB@HHNOHPEH@netinfo?5?$CFi?5?$CFi?5?$CFi@ DB 'netinfo %i %i %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@
CONST	SEGMENT
??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@ DB '1', 0ffH, '0.0.'
	DB	'0.0:0', 00H, '\gamedir\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CDAPOKFC@nr?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@CDAPOKFC@nr?5?$CB?$DN?5NULL@ DB 'nr != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@ELMGLAIG@?$FO1Error?3?$FO7?5Net_SendRequest?3?5no?5@
CONST	SEGMENT
??_C@_0FA@ELMGLAIG@?$FO1Error?3?$FO7?5Net_SendRequest?3?5no?5@ DB '^1Erro'
	DB	'r:^7 Net_SendRequest: no callbcak specified for request with '
	DB	'context %i!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NetAPI_SendRequest@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??NetAPI_SendRequest@@9@9 DD 0e2fH	; `NetAPI_SendRequest'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@ONIFEFDD@status?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@ONIFEFDD@status?5?$CB?$DN?5NULL@ DB 'status != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NetAPI_Status@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??NetAPI_Status@@9@9 DD 0e13H		; `NetAPI_Status'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@NFJFLDNN@setinfo?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BD@NFJFLDNN@setinfo?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@ DB 'setinfo "'
	DB	'%s" "%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@
CONST	SEGMENT
??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@ DB 'maps/%s.bsp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDFPKJKH@?$FO1Error?3?$FO7?5?$CFs?5not?5precached?6@
CONST	SEGMENT
??_C@_0BN@MDFPKJKH@?$FO1Error?3?$FO7?5?$CFs?5not?5precached?6@ DB '^1Erro'
	DB	'r:^7 %s not precached', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IAOEKLFI@?$FO3Warning?3?$FO7?5CL_HookEvent?3?5?$CFs?5a@
CONST	SEGMENT
??_C@_0CP@IAOEKLFI@?$FO3Warning?3?$FO7?5CL_HookEvent?3?5?$CFs?5a@ DB '^3W'
	DB	'arning:^7 CL_HookEvent: %s already hooked!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EHMIKJCM@cmd?5?$CFs?6@
CONST	SEGMENT
??_C@_07EHMIKJCM@cmd?5?$CFs?6@ DB 'cmd %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DEPMEFPI@HookUserMsg?3?5MAX_USER_MESSAGES?5@
CONST	SEGMENT
??_C@_0CF@DEPMEFPI@HookUserMsg?3?5MAX_USER_MESSAGES?5@ DB 'HookUserMsg: M'
	DB	'AX_USER_MESSAGES hit!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GMLECNLK@hud_scale@
CONST	SEGMENT
??_C@_09GMLECNLK@hud_scale@ DB 'hud_scale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KLPJHDAJ@?$FO3Warning?3?$FO7?5unexpected?5end?5of?5@
CONST	SEGMENT
??_C@_0DF@KLPJHDAJ@?$FO3Warning?3?$FO7?5unexpected?5end?5of?5@ DB '^3Warn'
	DB	'ing:^7 unexpected end of %s (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BEJKEGKD@?$FO1Error?3?$FO7?5SPR_GetList?3?5overflo@
CONST	SEGMENT
??_C@_0CJ@BEJKEGKD@?$FO1Error?3?$FO7?5SPR_GetList?3?5overflo@ DB '^1Error'
	DB	':^7 SPR_GetList: overflow cache!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnSPR_GetList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnSPR_GetList@@9@9 DD 061eH		; `pfnSPR_GetList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@FHBFLJHM@?$FO1Error?3?$FO7?5MAX_CLIENT_SPRITES?5l@
CONST	SEGMENT
??_C@_0DD@FHBFLJHM@?$FO1Error?3?$FO7?5MAX_CLIENT_SPRITES?5l@ DB '^1Error:'
	DB	'^7 MAX_CLIENT_SPRITES limit exceeded (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NPFOHACF@?$FO1Error?3?$FO7?5CL_LoadSpriteModel?3?5@
CONST	SEGMENT
??_C@_0CK@NPFOHACF@?$FO1Error?3?$FO7?5CL_LoadSpriteModel?3?5@ DB '^1Error'
	DB	':^7 CL_LoadSpriteModel: bad name!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@
CONST	SEGMENT
??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@ DB '^1Err'
	DB	'or:^7 %s couldn''t load', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PLPDELIL@m_pSprite?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BC@PLPDELIL@m_pSprite?5?$CB?$DN?5NULL@ DB 'm_pSprite != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_LoadHudSprite@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_LoadHudSprite@@9@9 DD 04dfH		; `CL_LoadHudSprite'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CL_FreeEdicts@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_FreeEdicts@@9@9 DD 04a6H		; `CL_FreeEdicts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@CHDGGDIF@clgame?4entities?5?$DN?$DN?5NULL@
CONST	SEGMENT
??_C@_0BI@CHDGGDIF@clgame?4entities?5?$DN?$DN?5NULL@ DB 'clgame.entities '
	DB	'== NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_InitEdicts@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_InitEdicts@@9@9 DD 048bH		; `CL_InitEdicts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@ DB 'pEdict != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_FreeEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_FreeEntity@@9@9 DD 0475H		; `CL_FreeEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CM@PACFIKIG@CL_LinkUserMessage?3?5MAX_USER_ME@
CONST	SEGMENT
??_C@_0CM@PACFIKIG@CL_LinkUserMessage?3?5MAX_USER_ME@ DB 'CL_LinkUserMess'
	DB	'age: MAX_USER_MESSAGES hit!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@ELCIIEJ@CL_LinkUserMessage?3?5tried?5to?5ho@
CONST	SEGMENT
??_C@_0DJ@ELCIIEJ@CL_LinkUserMessage?3?5tried?5to?5ho@ DB 'CL_LinkUserMes'
	DB	'sage: tried to hook a system message "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JNEDKHCH@CL_LinkUserMessage?3?5bad?5message@
CONST	SEGMENT
??_C@_0CG@JNEDKHCH@CL_LinkUserMessage?3?5bad?5message@ DB 'CL_LinkUserMes'
	DB	'sage: bad message name', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EDLJDNCH@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5b@
CONST	SEGMENT
??_C@_0DE@EDLJDNCH@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5b@ DB '^1Error'
	DB	':^7 CL_SoundFromIndex: bad sfx for index %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBDANMHK@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5i@
CONST	SEGMENT
??_C@_0DG@DBDANMHK@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5i@ DB '^1Error'
	DB	':^7 CL_SoundFromIndex: invalid sound index %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HGIIKDAL@player?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@HGIIKDAL@player?5?$CB?$DN?5NULL@ DB 'player != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_GetLocalPlayer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_GetLocalPlayer@@9@9 DD 0319H	; `CL_GetLocalPlayer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07JNEKKACO@HudText@
CONST	SEGMENT
??_C@_07JNEKKACO@HudText@ DB 'HudText', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IDJGENMA@TextMessage?$CFi@
CONST	SEGMENT
??_C@_0O@IDJGENMA@TextMessage?$CFi@ DB 'TextMessage%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_game.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_InitTitles@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_InitTitles@@9@9 DD 0289H		; `CL_InitTitles'::`1'::__LINE__Var
_DATA	ENDS
_DATA	SEGMENT
_cdll_exports DD FLAT:??_C@_0L@KIAPHAEH@Initialize@
	DD	FLAT:_clgame+4
	DD	FLAT:??_C@_0M@BNFLOIOL@HUD_VidInit@
	DD	FLAT:_clgame+12
	DD	FLAT:??_C@_08KOKJKKPB@HUD_Init@
	DD	FLAT:_clgame+8
	DD	FLAT:??_C@_0N@FOFGBJMN@HUD_Shutdown@
	DD	FLAT:_clgame+108
	DD	FLAT:??_C@_0L@MACKNJBP@HUD_Redraw@
	DD	FLAT:_clgame+16
	DD	FLAT:??_C@_0BF@IDOJKCBG@HUD_UpdateClientData@
	DD	FLAT:_clgame+20
	DD	FLAT:??_C@_09LNMGGKCH@HUD_Reset@
	DD	FLAT:_clgame+24
	DD	FLAT:??_C@_0P@OCPLMJPB@HUD_PlayerMove@
	DD	FLAT:_clgame+28
	DD	FLAT:??_C@_0BD@JLKHJBHK@HUD_PlayerMoveInit@
	DD	FLAT:_clgame+32
	DD	FLAT:??_C@_0BG@EHKDLCEB@HUD_PlayerMoveTexture@
	DD	FLAT:_clgame+36
	DD	FLAT:??_C@_0BJ@NHLLPFJM@HUD_ConnectionlessPacket@
	DD	FLAT:_clgame+128
	DD	FLAT:??_C@_0BC@HBPCODFF@HUD_GetHullBounds@
	DD	FLAT:_clgame+132
	DD	FLAT:??_C@_09FAJLIMIE@HUD_Frame@
	DD	FLAT:_clgame+136
	DD	FLAT:??_C@_0P@FNDJODC@HUD_PostRunCmd@
	DD	FLAT:_clgame+104
	DD	FLAT:??_C@_0O@KKOLLGPA@HUD_Key_Event@
	DD	FLAT:_clgame+140
	DD	FLAT:??_C@_0O@HHMAJEMG@HUD_AddEntity@
	DD	FLAT:_clgame+84
	DD	FLAT:??_C@_0BD@BGCECFFH@HUD_CreateEntities@
	DD	FLAT:_clgame+88
	DD	FLAT:??_C@_0BA@PJGHODE@HUD_StudioEvent@
	DD	FLAT:_clgame+100
	DD	FLAT:??_C@_0BI@KCDAEKFC@HUD_TxferLocalOverrides@
	DD	FLAT:_clgame+112
	DD	FLAT:??_C@_0BH@JBPIPNPI@HUD_ProcessPlayerState@
	DD	FLAT:_clgame+116
	DD	FLAT:??_C@_0BI@OEEHHCL@HUD_TxferPredictionData@
	DD	FLAT:_clgame+120
	DD	FLAT:??_C@_0BC@NEMGKNDL@HUD_TempEntUpdate@
	DD	FLAT:_clgame+144
	DD	FLAT:??_C@_0BI@HECHJHPH@HUD_DrawNormalTriangles@
	DD	FLAT:_clgame+92
	DD	FLAT:??_C@_0BN@JBAALJFI@HUD_DrawTransparentTriangles@
	DD	FLAT:_clgame+96
	DD	FLAT:??_C@_0BC@JEJJDIEE@HUD_GetUserEntity@
	DD	FLAT:_clgame+148
	DD	FLAT:??_C@_0BA@BPANJAAD@Demo_ReadBuffer@
	DD	FLAT:_clgame+124
	DD	FLAT:??_C@_09HLCHOIKO@CAM_Think@
	DD	FLAT:_clgame+76
	DD	FLAT:??_C@_0BB@MILNFHEF@CL_IsThirdPerson@
	DD	FLAT:_clgame+64
	DD	FLAT:??_C@_0BA@DBBAAIFO@CL_CameraOffset@
	DD	FLAT:_clgame+68
	DD	FLAT:??_C@_0O@GCJGNMG@CL_CreateMove@
	DD	FLAT:_clgame+60
	DD	FLAT:??_C@_0BB@EGPEAGMP@IN_ActivateMouse@
	DD	FLAT:_clgame+40
	DD	FLAT:??_C@_0BD@EHOCBNEH@IN_DeactivateMouse@
	DD	FLAT:_clgame+44
	DD	FLAT:??_C@_0O@JIJPHNAI@IN_MouseEvent@
	DD	FLAT:_clgame+48
	DD	FLAT:??_C@_0O@EBMDGJDF@IN_Accumulate@
	DD	FLAT:_clgame+56
	DD	FLAT:??_C@_0P@DHGCILML@IN_ClearStates@
	DD	FLAT:_clgame+52
	DD	FLAT:??_C@_0N@LBEJBAMA@V_CalcRefdef@
	DD	FLAT:_clgame+80
	DD	FLAT:??_C@_07BCCDHNLG@KB_Find@
	DD	FLAT:_clgame+72
	DD	00H
	DD	00H
_cdll_new_exports DD FLAT:??_C@_0BM@DLIIKKOD@HUD_GetStudioModelInterface@
	DD	FLAT:_clgame+160
	DD	FLAT:??_C@_0BE@LCHDHOCI@HUD_DirectorMessage@
	DD	FLAT:_clgame+156
	DD	FLAT:??_C@_0BA@NBAMOJFL@HUD_VoiceStatus@
	DD	FLAT:_clgame+152
	DD	FLAT:??_C@_0BG@JKMGFIAH@HUD_ChatInputPosition@
	DD	FLAT:_clgame+164
	DD	FLAT:??_C@_0BH@NLGOFIFB@HUD_GetRenderInterface@
	DD	FLAT:_clgame+168
	DD	FLAT:??_C@_0BF@HNAOHCPH@HUD_ClipMoveToEntity@
	DD	FLAT:_clgame+172
	DD	00H
	DD	00H
_gEngfuncs DD	FLAT:_pfnSPR_Load
	DD	FLAT:_pfnSPR_Frames
	DD	FLAT:_pfnSPR_Height
	DD	FLAT:_pfnSPR_Width
	DD	FLAT:_pfnSPR_Set
	DD	FLAT:_pfnSPR_Draw
	DD	FLAT:_pfnSPR_DrawHoles
	DD	FLAT:_pfnSPR_DrawAdditive
	DD	FLAT:_pfnSPR_DrawAdditiveScale
	DD	FLAT:_SPR_EnableScissor
	DD	FLAT:_SPR_DisableScissor
	DD	FLAT:_pfnSPR_GetList
	DD	FLAT:_CL_FillRGBA
	DD	FLAT:_CL_FillRGBACircle
	DD	FLAT:_pfnGetScreenInfo
	DD	FLAT:_pfnSetCrosshair
	DD	FLAT:_pfnCvar_RegisterClientVariable
	DD	FLAT:_Cvar_VariableValue
	DD	FLAT:_Cvar_VariableString
	DD	FLAT:_Cmd_AddClientCommand
	DD	FLAT:_pfnHookUserMsg
	DD	FLAT:_pfnServerCmd
	DD	FLAT:_pfnClientCmd
	DD	FLAT:_pfnGetPlayerInfo
	DD	FLAT:_pfnPlaySoundByName
	DD	FLAT:_pfnPlaySoundByIndex
	DD	FLAT:_AngleVectors
	DD	FLAT:_CL_TextMessageGet
	DD	FLAT:_pfnDrawCharacter
	DD	FLAT:_pfnDrawCharacterAlt
	DD	FLAT:_pfnDrawConsoleString
	DD	FLAT:_pfnDrawSetTextColor
	DD	FLAT:_pfnDrawConsoleStringLen
	DD	FLAT:_pfnConsolePrint
	DD	FLAT:_pfnCenterPrint
	DD	FLAT:_pfnGetWindowCenterX
	DD	FLAT:_pfnGetWindowCenterY
	DD	FLAT:_pfnGetViewAngles
	DD	FLAT:_pfnSetViewAngles
	DD	FLAT:_CL_GetMaxClients
	DD	FLAT:_Cvar_SetValue
	DD	FLAT:_Cmd_Argc
	DD	FLAT:_Cmd_Argv
	DD	FLAT:_Con_Printf
	DD	FLAT:_Con_DPrintf
	DD	FLAT:_Con_NPrintf
	DD	FLAT:_Con_NXPrintf
	DD	FLAT:_pfnPhysInfo_ValueForKey
	DD	FLAT:_pfnServerInfo_ValueForKey
	DD	FLAT:_pfnGetClientMaxspeed
	DD	FLAT:_COM_CheckParm
	DD	FLAT:_Key_Event
	DD	FLAT:_pfnGetMousePosition
	DD	FLAT:_pfnIsNoClipping
	DD	FLAT:_CL_GetLocalPlayer
	DD	FLAT:_pfnGetViewModel
	DD	FLAT:_CL_GetEntityByIndex
	DD	FLAT:_pfnGetClientTime
	DD	FLAT:_pfnCalcShake
	DD	FLAT:_pfnApplyShake
	DD	FLAT:_pfnPointContents
	DD	FLAT:_CL_WaterEntity
	DD	FLAT:_pfnTraceLine
	DD	FLAT:_CL_LoadModel
	DD	FLAT:_CL_AddEntity
	DD	FLAT:_CL_GetSpritePointer
	DD	FLAT:_pfnPlaySoundByNameAtLocation
	DD	FLAT:_pfnPrecacheEvent
	DD	FLAT:_CL_PlaybackEvent
	DD	FLAT:_CL_WeaponAnim
	DD	FLAT:_COM_RandomFloat
	DD	FLAT:_COM_RandomLong
	DD	FLAT:_pfnHookEvent
	DD	FLAT:_Con_Visible
	DD	FLAT:_pfnGetGameDirectory
	DD	FLAT:_pfnCVarGetPointer
	DD	FLAT:_Key_LookupBinding
	DD	FLAT:_pfnGetLevelName
	DD	FLAT:_pfnGetScreenFade
	DD	FLAT:_pfnSetScreenFade
	DD	FLAT:_VGui_GetPanel
	DD	FLAT:_VGui_ViewportPaintBackground
	DD	FLAT:_COM_LoadFile
	DD	FLAT:_pfnParseFile
	DD	FLAT:_COM_FreeFile
	DD	FLAT:_gTriApi
	DD	FLAT:_gEfxApi
	DD	FLAT:_gEventApi
	DD	FLAT:_gDemoApi
	DD	FLAT:_gNetApi
	DD	FLAT:_gVoiceApi
	DD	FLAT:_pfnIsSpectateOnly
	DD	FLAT:_pfnLoadMapSprite
	DD	FLAT:_COM_AddAppDirectoryToSearchPath
	DD	FLAT:_COM_ExpandFilename
	DD	FLAT:_PlayerInfo_ValueForKey
	DD	FLAT:_PlayerInfo_SetValueForKey
	DD	FLAT:_pfnGetPlayerUniqueID
	DD	FLAT:_pfnGetTrackerIDForPlayer
	DD	FLAT:_pfnGetPlayerForTrackerID
	DD	FLAT:_pfnServerCmdUnreliable
	DD	FLAT:_pfnGetMousePos
	DD	FLAT:_pfnSetMousePos
	DD	FLAT:_pfnSetMouseEnable
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnGetClientOldTime
	DD	FLAT:_pfnGetGravity
	DD	FLAT:_CL_ModelHandle
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_LocalPlayerInfo_ValueForKey
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_Cvar_Set
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_Sys_DoubleTime
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_CL_FillRGBABlend
	DD	FLAT:_pfnGetAppID
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_pfnEngineStub
	DD	FLAT:_CL_GetCrosshairPosX
	DD	FLAT:_CL_GetCrosshairPosY
_DATA	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	034aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0e9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0c7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	05eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03c3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	016aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0354H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02ebH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0261H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	022cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	022aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e6H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnEngineStub
_TEXT	SEGMENT
_pfnEngineStub PROC					; COMDAT

; 3891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3892 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnEngineStub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Voice_GetControlFloat
_TEXT	SEGMENT
_iControl$ = 8						; size = 4
_Voice_GetControlFloat PROC				; COMDAT

; 3879 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3880 : 	return 1.0f;

	fld1

; 3881 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Voice_GetControlFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Voice_SetControlFloat
_TEXT	SEGMENT
_iControl$ = 8						; size = 4
_value$ = 12						; size = 4
_Voice_SetControlFloat PROC				; COMDAT

; 3869 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3870 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Voice_SetControlFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Voice_EndVoiceTweakMode
_TEXT	SEGMENT
_Voice_EndVoiceTweakMode PROC				; COMDAT

; 3859 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3860 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Voice_EndVoiceTweakMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Voice_StartVoiceTweakMode
_TEXT	SEGMENT
_Voice_StartVoiceTweakMode PROC				; COMDAT

; 3848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3849 : 	return 0;

	xor	eax, eax

; 3850 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Voice_StartVoiceTweakMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_SetValueForKey
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
_maxsize$ = 20						; size = 4
_NetAPI_SetValueForKey PROC				; COMDAT

; 3828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3829 : 	if( key[0] == '*' ) return;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _key$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN2@NetAPI_Set
	jmp	SHORT $LN1@NetAPI_Set
$LN2@NetAPI_Set:

; 3830 : 	Info_SetValueForStarKey( s, key, value, maxsize );

	mov	eax, DWORD PTR _maxsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
$LN1@NetAPI_Set:

; 3831 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_SetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_RemoveKey
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_NetAPI_RemoveKey PROC					; COMDAT

; 3817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3818 : 	Info_RemoveKey( s, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_RemoveKey
	add	esp, 8

; 3819 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_RemoveKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_ValueForKey
_TEXT	SEGMENT
_s$ = 8							; size = 4
_key$ = 12						; size = 4
_NetAPI_ValueForKey PROC				; COMDAT

; 3806 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3807 : 	return Info_ValueForKey( s, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Info_ValueForKey
	add	esp, 8

; 3808 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_StringToAdr
_TEXT	SEGMENT
_s$ = 8							; size = 4
_a$ = 12						; size = 4
_NetAPI_StringToAdr PROC				; COMDAT

; 3795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3796 : 	return NET_StringToAdr( s, a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_NET_StringToAdr
	add	esp, 8

; 3797 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_StringToAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_CompareAdr
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_NetAPI_CompareAdr PROC					; COMDAT

; 3784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3785 : 	return NET_CompareAdr( *a, *b );

	mov	eax, DWORD PTR _b$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _a$[ebp]
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H

; 3786 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_CompareAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_AdrToString
_TEXT	SEGMENT
_a$ = 8							; size = 4
_NetAPI_AdrToString PROC				; COMDAT

; 3773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3774 : 	return NET_AdrToString( *a );

	mov	eax, DWORD PTR _a$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H

; 3775 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_AdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_CancelRequest
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_context$ = 8						; size = 4
_NetAPI_CancelRequest PROC				; COMDAT

; 3709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3710 : 	net_request_t	*nr;
; 3711 : 	int		i;
; 3712 : 
; 3713 : 	// find a specified request
; 3714 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Can
$LN2@NetAPI_Can:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NetAPI_Can:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN3@NetAPI_Can

; 3715 : 	{
; 3716 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax

; 3717 : 
; 3718 : 		if( clgame.net_requests[i].resp.context == context )

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _clgame[eax+255308]
	cmp	ecx, DWORD PTR _context$[ebp]
	jne	$LN5@NetAPI_Can

; 3719 : 		{
; 3720 : 			if( nr->pfnFunc )

	mov	eax, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN6@NetAPI_Can

; 3721 : 			{
; 3722 : 				SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx

; 3723 : 				nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 3724 : 				nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4
$LN6@NetAPI_Can:

; 3725 :                               }
; 3726 : 
; 3727 : 			if( clgame.net_requests[i].resp.type == NETAPI_REQUEST_SERVERLIST && &clgame.net_requests[i] == clgame.master_request )

	imul	eax, DWORD PTR _i$[ebp], 80
	cmp	DWORD PTR _clgame[eax+255312], 0
	jne	SHORT $LN7@NetAPI_Can
	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	cmp	eax, DWORD PTR _clgame+260424
	jne	SHORT $LN7@NetAPI_Can

; 3728 : 			{
; 3729 : 				if( clgame.request_type == NET_REQUEST_CLIENT )

	cmp	DWORD PTR _clgame+255296, 2
	jne	SHORT $LN8@NetAPI_Can

; 3730 : 					clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+255296, 0
$LN8@NetAPI_Can:

; 3731 : 				clgame.master_request = NULL;

	mov	DWORD PTR _clgame+260424, 0
$LN7@NetAPI_Can:

; 3732 : 			}
; 3733 : 
; 3734 : 			memset( &clgame.net_requests[i], 0, sizeof( net_request_t ));

	push	80					; 00000050H
	push	0
	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3735 : 			break;

	jmp	SHORT $LN3@NetAPI_Can
$LN5@NetAPI_Can:

; 3736 : 		}
; 3737 : 	}

	jmp	$LN2@NetAPI_Can
$LN3@NetAPI_Can:

; 3738 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_CancelRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_SendRequest
_TEXT	SEGMENT
tv128 = -920						; size = 4
_fullquery$1 = -788					; size = 512
_max_timeout$2 = -276					; size = 8
_i$ = -268						; size = 4
_req$ = -264						; size = 256
_nr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_context$ = 8						; size = 4
_request$ = 12						; size = 4
_flags$ = 16						; size = 4
_timeout$ = 20						; size = 8
_remote_address$ = 28					; size = 4
_response$ = 32						; size = 4
_NetAPI_SendRequest PROC				; COMDAT

; 3631 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 920				; 00000398H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3632 : 	net_request_t	*nr = NULL;

	mov	DWORD PTR _nr$[ebp], 0

; 3633 : 	string		req;
; 3634 : 	int		i;
; 3635 : 
; 3636 : 	if( !response )

	cmp	DWORD PTR _response$[ebp], 0
	jne	SHORT $LN8@NetAPI_Sen

; 3637 : 	{
; 3638 : 		Con_DPrintf( S_ERROR "Net_SendRequest: no callbcak specified for request with context %i!\n", context );

	mov	eax, DWORD PTR _context$[ebp]
	push	eax
	push	OFFSET ??_C@_0FA@ELMGLAIG@?$FO1Error?3?$FO7?5Net_SendRequest?3?5no?5@
	call	_Con_DPrintf
	add	esp, 8

; 3639 : 		return;

	jmp	$LN14@NetAPI_Sen
$LN8@NetAPI_Sen:

; 3640 : 	}
; 3641 : 
; 3642 : 	if( remote_address->type >= NA_IPX )

	mov	eax, DWORD PTR _remote_address$[ebp]
	cmp	DWORD PTR [eax], 4
	jl	SHORT $LN9@NetAPI_Sen

; 3643 : 		return; // IPX no longer support

	jmp	$LN14@NetAPI_Sen
$LN9@NetAPI_Sen:

; 3644 : 
; 3645 : 	// find a free request
; 3646 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Sen
$LN2@NetAPI_Sen:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NetAPI_Sen:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@NetAPI_Sen

; 3647 : 	{
; 3648 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax

; 3649 : 		if( !nr->pfnFunc ) break;

	mov	eax, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN10@NetAPI_Sen
	jmp	SHORT $LN3@NetAPI_Sen
$LN10@NetAPI_Sen:

; 3650 : 	}

	jmp	SHORT $LN2@NetAPI_Sen
$LN3@NetAPI_Sen:

; 3651 : 
; 3652 : 	if( i == MAX_REQUESTS )

	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jne	$LN6@NetAPI_Sen

; 3653 : 	{
; 3654 : 		double	max_timeout = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _max_timeout$2[ebp], xmm0

; 3655 : 
; 3656 : 		// no free requests? use oldest
; 3657 : 		for( i = 0, nr = NULL; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _nr$[ebp], 0
	jmp	SHORT $LN7@NetAPI_Sen
$LN5@NetAPI_Sen:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@NetAPI_Sen:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@NetAPI_Sen

; 3658 : 		{
; 3659 : 			if(( host.realtime - clgame.net_requests[i].timesend ) > max_timeout )

	imul	eax, DWORD PTR _i$[ebp], 80
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _clgame[eax+255368]
	comisd	xmm0, QWORD PTR _max_timeout$2[ebp]
	jbe	SHORT $LN12@NetAPI_Sen

; 3660 : 			{
; 3661 : 				max_timeout = host.realtime - clgame.net_requests[i].timesend;

	imul	eax, DWORD PTR _i$[ebp], 80
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _clgame[eax+255368]
	movsd	QWORD PTR _max_timeout$2[ebp], xmm0

; 3662 : 				nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax
$LN12@NetAPI_Sen:

; 3663 : 			}
; 3664 : 		}

	jmp	SHORT $LN5@NetAPI_Sen
$LN6@NetAPI_Sen:

; 3665 : 	}
; 3666 : 
; 3667 : 	Assert( nr != NULL );

	cmp	DWORD PTR _nr$[ebp], 0
	je	SHORT $LN17@NetAPI_Sen
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN18@NetAPI_Sen
$LN17@NetAPI_Sen:
	mov	DWORD PTR tv128[ebp], 0
$LN18@NetAPI_Sen:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??NetAPI_SendRequest@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@CDAPOKFC@nr?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv128[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 3668 : 
; 3669 : 	// clear slot
; 3670 : 	memset( nr, 0, sizeof( *nr ));

	push	80					; 00000050H
	push	0
	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3671 : 
; 3672 : 	// create a new request
; 3673 : 	nr->timesend = host.realtime;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+64], xmm0

; 3674 : 	nr->timeout = nr->timesend + timeout;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR [eax+64]
	addsd	xmm0, QWORD PTR _timeout$[ebp]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+56], xmm0

; 3675 : 	nr->pfnFunc = response;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _response$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 3676 : 	nr->resp.context = context;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _context$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3677 : 	nr->resp.type = request;	

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _request$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3678 : 	nr->resp.remote_address = *remote_address; 

	mov	eax, DWORD PTR _nr$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _remote_address$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx

; 3679 : 	nr->flags = flags;

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 3680 : 
; 3681 : 	if( request == NETAPI_REQUEST_SERVERLIST )

	cmp	DWORD PTR _request$[ebp], 0
	jne	$LN13@NetAPI_Sen

; 3682 : 	{
; 3683 : 		char	fullquery[512] = "1\xFF" "0.0.0.0:0\0" "\\gamedir\\";

	mov	eax, DWORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@
	mov	DWORD PTR _fullquery$1[ebp], eax
	mov	ecx, DWORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@+4
	mov	DWORD PTR _fullquery$1[ebp+4], ecx
	mov	edx, DWORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@+8
	mov	DWORD PTR _fullquery$1[ebp+8], edx
	mov	eax, DWORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@+12
	mov	DWORD PTR _fullquery$1[ebp+12], eax
	mov	ecx, DWORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@+16
	mov	DWORD PTR _fullquery$1[ebp+16], ecx
	mov	dx, WORD PTR ??_C@_0BG@CLPPOLGM@1?$PP0?40?40?40?30?$AA?2gamedir?2@+20
	mov	WORD PTR _fullquery$1[ebp+20], dx
	push	490					; 000001eaH
	push	0
	lea	eax, DWORD PTR _fullquery$1[ebp+22]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3684 : 
; 3685 : 		// make sure what port is specified
; 3686 : 		if( !nr->resp.remote_address.port ) nr->resp.remote_address.port = MSG_BigShort( PORT_MASTER );

	mov	eax, DWORD PTR _nr$[ebp]
	movzx	ecx, WORD PTR [eax+30]
	test	ecx, ecx
	jne	SHORT $LN15@NetAPI_Sen
	push	27010					; 00006982H
	call	_MSG_BigShort
	add	esp, 4
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	WORD PTR [ecx+30], ax
$LN15@NetAPI_Sen:

; 3687 : 
; 3688 : 		// grab the list from the master server
; 3689 : 		Q_strcpy( &fullquery[22], GI->gamedir );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 22
	lea	eax, DWORD PTR _fullquery$1[ebp+edx]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3690 : 		NET_SendPacket( NS_CLIENT, Q_strlen( GI->gamedir ) + 23, fullquery, nr->resp.remote_address );

	mov	eax, DWORD PTR _nr$[ebp]
	add	eax, 12					; 0000000cH
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	lea	ecx, DWORD PTR _fullquery$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _SI+768
	add	edx, 128				; 00000080H
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 23					; 00000017H
	push	eax
	push	0
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 3691 : 		clgame.request_type = NET_REQUEST_CLIENT;

	mov	DWORD PTR _clgame+255296, 2

; 3692 : 		clgame.master_request = nr; // holds the master request unitl the master acking

	mov	eax, DWORD PTR _nr$[ebp]
	mov	DWORD PTR _clgame+260424, eax

; 3693 : 	}

	jmp	SHORT $LN14@NetAPI_Sen
$LN13@NetAPI_Sen:

; 3694 : 	else
; 3695 : 	{
; 3696 : 		// local servers request
; 3697 : 		Q_snprintf( req, sizeof( req ), "netinfo %i %i %i", PROTOCOL_VERSION, context, request );

	mov	eax, DWORD PTR _request$[ebp]
	push	eax
	mov	ecx, DWORD PTR _context$[ebp]
	push	ecx
	push	49					; 00000031H
	push	OFFSET ??_C@_0BB@HHNOHPEH@netinfo?5?$CFi?5?$CFi?5?$CFi@
	push	256					; 00000100H
	lea	edx, DWORD PTR _req$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 3698 : 		Netchan_OutOfBandPrint( NS_CLIENT, nr->resp.remote_address, req );

	lea	eax, DWORD PTR _req$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	add	ecx, 12					; 0000000cH
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	push	0
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN14@NetAPI_Sen:

; 3699 : 	}
; 3700 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_SendRequest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_Status
_TEXT	SEGMENT
tv93 = -80						; size = 8
tv87 = -80						; size = 8
tv81 = -80						; size = 4
tv80 = -76						; size = 4
tv70 = -76						; size = 4
_packet_loss$ = -8					; size = 4
_connected$ = -4					; size = 4
_status$ = 8						; size = 4
_NetAPI_Status PROC					; COMDAT

; 3603 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 3604 : 	qboolean	connected = false;

	mov	DWORD PTR _connected$[ebp], 0

; 3605 : 	int	packet_loss = 0;

	mov	DWORD PTR _packet_loss$[ebp], 0

; 3606 : 
; 3607 : 	Assert( status != NULL );

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN5@NetAPI_Sta
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@NetAPI_Sta
$LN5@NetAPI_Sta:
	mov	DWORD PTR tv70[ebp], 0
$LN6@NetAPI_Sta:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??NetAPI_Status@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@ONIFEFDD@status?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 3608 : 
; 3609 : 	if( cls.state > ca_disconnected && cls.state != ca_cinematic )

	cmp	DWORD PTR _cls, 0
	jle	SHORT $LN2@NetAPI_Sta
	cmp	DWORD PTR _cls, 5
	je	SHORT $LN2@NetAPI_Sta

; 3610 : 		connected = true;

	mov	DWORD PTR _connected$[ebp], 1
$LN2@NetAPI_Sta:

; 3611 : 
; 3612 : 	if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN3@NetAPI_Sta

; 3613 : 		packet_loss = bound( 0, (int)cls.packet_loss, 100 );

	cvttss2si eax, DWORD PTR _cls+290572
	test	eax, eax
	jl	SHORT $LN9@NetAPI_Sta
	cvttss2si ecx, DWORD PTR _cls+290572
	cmp	ecx, 100				; 00000064H
	jge	SHORT $LN7@NetAPI_Sta
	cvttss2si edx, DWORD PTR _cls+290572
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN8@NetAPI_Sta
$LN7@NetAPI_Sta:
	mov	DWORD PTR tv80[ebp], 100		; 00000064H
$LN8@NetAPI_Sta:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN10@NetAPI_Sta
$LN9@NetAPI_Sta:
	mov	DWORD PTR tv81[ebp], 0
$LN10@NetAPI_Sta:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _packet_loss$[ebp], ecx
$LN3@NetAPI_Sta:

; 3614 : 
; 3615 : 	status->connected = connected;

	mov	eax, DWORD PTR _status$[ebp]
	mov	ecx, DWORD PTR _connected$[ebp]
	mov	DWORD PTR [eax], ecx

; 3616 : 	status->connection_time = (connected) ? (host.realtime - cls.netchan.connect_time) : 0.0;

	cmp	DWORD PTR _connected$[ebp], 0
	je	SHORT $LN11@NetAPI_Sta
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+26840
	movsd	QWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN12@NetAPI_Sta
$LN11@NetAPI_Sta:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv87[ebp], xmm0
$LN12@NetAPI_Sta:
	mov	eax, DWORD PTR _status$[ebp]
	movsd	xmm0, QWORD PTR tv87[ebp]
	movsd	QWORD PTR [eax+56], xmm0

; 3617 : 	status->latency = (connected) ? cl.frames[cl.parsecountmod].latency : 0.0;

	cmp	DWORD PTR _connected$[ebp], 0
	je	SHORT $LN13@NetAPI_Sta
	imul	eax, DWORD PTR _cl+12, 24056
	movsd	xmm0, QWORD PTR _cl[eax+96]
	movsd	QWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN14@NetAPI_Sta
$LN13@NetAPI_Sta:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv93[ebp], xmm0
$LN14@NetAPI_Sta:
	mov	ecx, DWORD PTR _status$[ebp]
	movsd	xmm0, QWORD PTR tv93[ebp]
	movsd	QWORD PTR [ecx+48], xmm0

; 3618 : 	status->remote_address = cls.netchan.remote_address;

	mov	eax, DWORD PTR _status$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _cls+26804
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+26808
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+26812
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+26816
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR [eax+16], ecx

; 3619 : 	status->packet_loss = packet_loss;

	mov	eax, DWORD PTR _status$[ebp]
	mov	ecx, DWORD PTR _packet_loss$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 3620 : 	status->local_address = net_local;

	mov	eax, DWORD PTR _status$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx

; 3621 : 	status->rate = rate->value;

	mov	eax, DWORD PTR _rate
	cvtss2sd xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _status$[ebp]
	movsd	QWORD PTR [ecx+64], xmm0

; 3622 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_Status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_InitNetworking
_TEXT	SEGMENT
_NetAPI_InitNetworking PROC				; COMDAT

; 3592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3593 : 	NET_Config( true ); // allow remote

	push	1
	call	_NET_Config
	add	esp, 4

; 3594 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_InitNetworking ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Demo_WriteBuffer
_TEXT	SEGMENT
_size$ = 8						; size = 4
_buffer$ = 12						; size = 4
_Demo_WriteBuffer PROC					; COMDAT

; 3575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3576 : 	CL_WriteDemoUserMessage( buffer, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_CL_WriteDemoUserMessage
	add	esp, 8

; 3577 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Demo_WriteBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Demo_IsTimeDemo
_TEXT	SEGMENT
_Demo_IsTimeDemo PROC					; COMDAT

; 3564 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3565 : 	return cls.timedemo;

	mov	eax, DWORD PTR _cls+300836

; 3566 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Demo_IsTimeDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Demo_IsPlayingback
_TEXT	SEGMENT
_Demo_IsPlayingback PROC				; COMDAT

; 3553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3554 : 	return cls.demoplayback;

	mov	eax, DWORD PTR _cls+300828

; 3555 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Demo_IsPlayingback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Demo_IsRecording
_TEXT	SEGMENT
_Demo_IsRecording PROC					; COMDAT

; 3542 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3543 : 	return cls.demorecording;

	mov	eax, DWORD PTR _cls+300824

; 3544 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Demo_IsRecording ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriFogParams
_TEXT	SEGMENT
_flDensity$ = 8						; size = 4
_iFogSkybox$ = 12					; size = 4
_TriFogParams PROC					; COMDAT

; 3524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3525 : 	RI.fogDensity = flDensity;

	movss	xmm0, DWORD PTR _flDensity$[ebp]
	movss	DWORD PTR _RI+340, xmm0

; 3526 : 	RI.fogSkybox = iFogSkybox;

	mov	eax, DWORD PTR _iFogSkybox$[ebp]
	mov	DWORD PTR _RI+320, eax

; 3527 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriFogParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriLightAtPoint
_TEXT	SEGMENT
tv151 = -112						; size = 8
tv140 = -112						; size = 8
tv129 = -112						; size = 8
tv147 = -104						; size = 4
tv136 = -104						; size = 4
tv93 = -104						; size = 4
$T1 = -100						; size = 16
_vLightColor$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_value$ = 12						; size = 4
_TriLightAtPoint PROC					; COMDAT

; 3488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3489 : 	colorVec	vLightColor;
; 3490 : 
; 3491 : 	if( !pos || !value ) return;

	cmp	DWORD PTR _pos$[ebp], 0
	je	SHORT $LN3@TriLightAt
	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN2@TriLightAt
$LN3@TriLightAt:
	jmp	$LN1@TriLightAt
$LN2@TriLightAt:

; 3492 : 
; 3493 : 	vLightColor = R_LightPoint( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_R_LightPoint
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vLightColor$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vLightColor$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vLightColor$[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _vLightColor$[ebp+12], eax

; 3494 : 
; 3495 : 	value[0] = vLightColor.r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vLightColor$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR tv93[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv129[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv129[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 3496 : 	value[1] = vLightColor.g;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vLightColor$[ebp+4]
	mov	DWORD PTR tv136[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv136[ebp]
	mov	edx, DWORD PTR tv136[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv140[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv140[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 3497 : 	value[2] = vLightColor.b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _vLightColor$[ebp+8]
	mov	DWORD PTR tv147[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR tv147[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv151[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv151[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN1@TriLightAt:

; 3498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TriLightAtPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriGetMatrix
_TEXT	SEGMENT
_pname$ = 8						; size = 4
_matrix$ = 12						; size = 4
_TriGetMatrix PROC					; COMDAT

; 3464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3465 : 	pglGetFloatv( pname, matrix );

	mov	eax, DWORD PTR _matrix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	call	DWORD PTR _pglGetFloatv

; 3466 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriGetMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriFog
_TEXT	SEGMENT
_flFogColor$ = 8					; size = 4
_flStart$ = 12						; size = 4
_flEnd$ = 16						; size = 4
_bOn$ = 20						; size = 4
_TriFog	PROC						; COMDAT

; 3422 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3423 : 	// overrided by internal fog
; 3424 : 	if( RI.fogEnabled ) return;

	cmp	DWORD PTR _RI+316, 0
	je	SHORT $LN2@TriFog
	jmp	$LN1@TriFog
$LN2@TriFog:

; 3425 : 	RI.fogCustom = bOn;

	mov	eax, DWORD PTR _bOn$[ebp]
	mov	DWORD PTR _RI+312, eax

; 3426 : 
; 3427 : 	// check for invalid parms
; 3428 : 	if( flEnd <= flStart )

	movss	xmm0, DWORD PTR _flStart$[ebp]
	comiss	xmm0, DWORD PTR _flEnd$[ebp]
	jb	SHORT $LN3@TriFog

; 3429 : 	{
; 3430 : 		RI.fogCustom = false;

	mov	DWORD PTR _RI+312, 0

; 3431 : 		pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable

; 3432 : 		return;

	jmp	$LN1@TriFog
$LN3@TriFog:

; 3433 : 	}
; 3434 : 
; 3435 : 	if( RI.fogCustom )

	cmp	DWORD PTR _RI+312, 0
	je	SHORT $LN4@TriFog

; 3436 : 		pglEnable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglEnable
	jmp	SHORT $LN5@TriFog
$LN4@TriFog:

; 3437 : 	else pglDisable( GL_FOG );

	push	2912					; 00000b60H
	call	DWORD PTR _pglDisable
$LN5@TriFog:

; 3438 : 
; 3439 : 	// copy fog params
; 3440 : 	RI.fogColor[0] = flFogColor[0] / 255.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _RI[ecx+324], xmm0

; 3441 : 	RI.fogColor[1] = flFogColor[1] / 255.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _RI[edx+324], xmm0

; 3442 : 	RI.fogColor[2] = flFogColor[2] / 255.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _flFogColor$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _RI[edx+324], xmm0

; 3443 : 	RI.fogStart = flStart;

	movss	xmm0, DWORD PTR _flStart$[ebp]
	movss	DWORD PTR _RI+344, xmm0

; 3444 : 	RI.fogColor[3] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _RI[ecx+324], xmm0

; 3445 : 	RI.fogDensity = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _RI+340, xmm0

; 3446 : 	RI.fogSkybox = true;

	mov	DWORD PTR _RI+320, 1

; 3447 : 	RI.fogEnd = flEnd;

	movss	xmm0, DWORD PTR _flEnd$[ebp]
	movss	DWORD PTR _RI+348, xmm0

; 3448 : 
; 3449 : 	pglFogi( GL_FOG_MODE, GL_LINEAR );

	push	9729					; 00002601H
	push	2917					; 00000b65H
	call	DWORD PTR _pglFogi

; 3450 : 	pglFogfv( GL_FOG_COLOR, RI.fogColor );

	push	OFFSET _RI+324
	push	2918					; 00000b66H
	call	DWORD PTR _pglFogfv

; 3451 : 	pglFogf( GL_FOG_START, RI.fogStart );

	push	ecx
	movss	xmm0, DWORD PTR _RI+344
	movss	DWORD PTR [esp], xmm0
	push	2915					; 00000b63H
	call	DWORD PTR _pglFogf

; 3452 : 	pglFogf( GL_FOG_END, RI.fogEnd );

	push	ecx
	movss	xmm0, DWORD PTR _RI+348
	movss	DWORD PTR [esp], xmm0
	push	2916					; 00000b64H
	call	DWORD PTR _pglFogf

; 3453 : 	pglHint( GL_FOG_HINT, GL_NICEST );

	push	4354					; 00001102H
	push	3156					; 00000c54H
	call	DWORD PTR _pglHint
$LN1@TriFog:

; 3454 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriFog	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetAppID
_TEXT	SEGMENT
_pfnGetAppID PROC					; COMDAT

; 3166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3167 : 	return 70;

	mov	eax, 70					; 00000046H

; 3168 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetAppID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FillRGBABlend
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv78 = -68						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_r$ = 24						; size = 4
_g$ = 28						; size = 4
_b$ = 32						; size = 4
_a$ = 36						; size = 4
_CL_FillRGBABlend PROC					; COMDAT

; 3133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3134 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@CL_FillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@CL_FillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_FillRGB
$LN3@CL_FillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@CL_FillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_FillRGB
$LN5@CL_FillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_FillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 3135 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@CL_FillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@CL_FillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@CL_FillRGB
$LN7@CL_FillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@CL_FillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@CL_FillRGB
$LN9@CL_FillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN10@CL_FillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 3136 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@CL_FillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@CL_FillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@CL_FillRGB
$LN11@CL_FillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@CL_FillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@CL_FillRGB
$LN13@CL_FillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN14@CL_FillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 3137 : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@CL_FillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@CL_FillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@CL_FillRGB
$LN15@CL_FillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@CL_FillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@CL_FillRGB
$LN17@CL_FillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN18@CL_FillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 3138 : 
; 3139 : 	SPR_AdjustSize( (float *)&x, (float *)&y, (float *)&w, (float *)&h );

	lea	eax, DWORD PTR _h$[ebp]
	push	eax
	lea	ecx, DWORD PTR _w$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 3140 : 
; 3141 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 3142 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3143 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 3144 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3145 : 	pglColor4f( r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f );

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _g$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3146 : 
; 3147 : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 3148 : 		pglVertex2f( x, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 3149 : 		pglVertex2f( x + w, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 3150 : 		pglVertex2f( x + w, y + h );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 3151 : 		pglVertex2f( x, y + h );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 3152 : 	pglEnd ();

	call	DWORD PTR _pglEnd

; 3153 : 
; 3154 : 	pglColor3f( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 3155 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 3156 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 3157 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FillRGBABlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _LocalPlayerInfo_ValueForKey
_TEXT	SEGMENT
_key$ = 8						; size = 4
_LocalPlayerInfo_ValueForKey PROC			; COMDAT

; 3122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3123 : 	return Info_ValueForKey( cls.userinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cls+9880
	call	_Info_ValueForKey
	add	esp, 8

; 3124 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_LocalPlayerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetGravity
_TEXT	SEGMENT
_pfnGetGravity PROC					; COMDAT

; 3111 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3112 : 	return clgame.movevars.gravity;

	fld	DWORD PTR _clgame+1024

; 3113 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetGravity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetClientOldTime
_TEXT	SEGMENT
tv66 = -68						; size = 4
_pfnGetClientOldTime PROC				; COMDAT

; 3100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3101 : 	return cl.oldtime;

	cvtsd2ss xmm0, QWORD PTR _cl+2167648
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 3102 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClientOldTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnParseFile
_TEXT	SEGMENT
_out$ = -4						; size = 4
_data$ = 8						; size = 4
_token$ = 12						; size = 4
_pfnParseFile PROC					; COMDAT

; 3083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3084 : 	char	*out;
; 3085 : 
; 3086 : 	host.com_handlecolon = true;

	mov	DWORD PTR _host+34360, 1

; 3087 : 	out = COM_ParseFile( data, token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _out$[ebp], eax

; 3088 : 	host.com_handlecolon = false;

	mov	DWORD PTR _host+34360, 0

; 3089 : 
; 3090 : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 3091 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnParseFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSetMouseEnable
_TEXT	SEGMENT
_fEnable$ = 8						; size = 4
_pfnSetMouseEnable PROC					; COMDAT

; 3072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetMouseEnable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSetMousePos
_TEXT	SEGMENT
_mx$ = 8						; size = 4
_my$ = 12						; size = 4
_pfnSetMousePos PROC					; COMDAT

; 3060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3061 : 	SetCursorPos( mx, my );

	mov	eax, DWORD PTR _my$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mx$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8

; 3062 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetMousePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetMousePos
_TEXT	SEGMENT
_ppt$ = 8						; size = 4
_pfnGetMousePos PROC					; COMDAT

; 3049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3050 : 	GetCursorPos( ppt );

	mov	eax, DWORD PTR _ppt$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 3051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetMousePos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnServerCmdUnreliable
_TEXT	SEGMENT
_szCmdString$ = 8					; size = 4
_pfnServerCmdUnreliable PROC				; COMDAT

; 3032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3033 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 3034 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 3035 : 
; 3036 : 	MSG_BeginClientCmd( &cls.datagram, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+10392
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 3037 : 	MSG_WriteString( &cls.datagram, szCmdString );

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	push	OFFSET _cls+10392
	call	_MSG_WriteString
	add	esp, 8

; 3038 : 
; 3039 : 	return 1;

	mov	eax, 1
$LN1@pfnServerC:

; 3040 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerCmdUnreliable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetPlayerForTrackerID
_TEXT	SEGMENT
_trackerID$ = 8						; size = 4
_pfnGetPlayerForTrackerID PROC				; COMDAT

; 3021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3022 : 	return 0;

	xor	eax, eax

; 3023 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerForTrackerID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetTrackerIDForPlayer
_TEXT	SEGMENT
_playerSlot$ = 8					; size = 4
_pfnGetTrackerIDForPlayer PROC				; COMDAT

; 3009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3010 : 	return 0;

	xor	eax, eax

; 3011 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetTrackerIDForPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetPlayerUniqueID
_TEXT	SEGMENT
_iPlayer$ = 8						; size = 4
_playerID$ = 12						; size = 4
_pfnGetPlayerUniqueID PROC				; COMDAT

; 2989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2990 : 	if( iPlayer < 1 || iPlayer > cl.maxclients )

	cmp	DWORD PTR _iPlayer$[ebp], 1
	jl	SHORT $LN3@pfnGetPlay
	mov	eax, DWORD PTR _iPlayer$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jle	SHORT $LN2@pfnGetPlay
$LN3@pfnGetPlay:

; 2991 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 2992 : 
; 2993 : 	// make sure there is a player here..
; 2994 : 	if( !cl.players[iPlayer-1].userinfo[0] || !cl.players[iPlayer-1].name[0] )

	mov	eax, DWORD PTR _iPlayer$[ebp]
	sub	eax, 1
	imul	ecx, eax, 584
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _cl[ecx+eax+2184944]
	test	ecx, ecx
	je	SHORT $LN5@pfnGetPlay
	mov	eax, DWORD PTR _iPlayer$[ebp]
	sub	eax, 1
	imul	ecx, eax, 584
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _cl[ecx+eax+2185200]
	test	ecx, ecx
	jne	SHORT $LN4@pfnGetPlay
$LN5@pfnGetPlay:

; 2995 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetPlay
$LN4@pfnGetPlay:

; 2996 : 
; 2997 : 	memcpy( playerID, cl.players[iPlayer-1].hashedcdkey, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _iPlayer$[ebp]
	sub	eax, 1
	imul	ecx, eax, 584
	add	ecx, OFFSET _cl+2185508
	push	ecx
	mov	edx, DWORD PTR _playerID$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2998 : 	return true;

	mov	eax, 1
$LN1@pfnGetPlay:

; 2999 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerUniqueID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _PlayerInfo_SetValueForKey
_TEXT	SEGMENT
_var$ = -4						; size = 4
_key$ = 8						; size = 4
_value$ = 12						; size = 4
_PlayerInfo_SetValueForKey PROC				; COMDAT

; 2963 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2964 : 	convar_t	*var;
; 2965 : 
; 2966 : 	if( !Q_strcmp( Info_ValueForKey( cls.userinfo, key ), value ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET _cls+9880
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@PlayerInfo

; 2967 : 		return; // no changes ?

	jmp	SHORT $LN1@PlayerInfo
$LN2@PlayerInfo:

; 2968 : 
; 2969 : 	var = Cvar_FindVar( key );

	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _var$[ebp], eax

; 2970 : 
; 2971 : 	if( var && FBitSet( var->flags, FCVAR_USERINFO ))

	cmp	DWORD PTR _var$[ebp], 0
	je	SHORT $LN3@PlayerInfo
	mov	eax, DWORD PTR _var$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 2
	je	SHORT $LN3@PlayerInfo

; 2972 : 	{
; 2973 : 		Cvar_DirectSet( var, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _var$[ebp]
	push	ecx
	call	_Cvar_DirectSet
	add	esp, 8

; 2974 : 	}

	jmp	SHORT $LN1@PlayerInfo
$LN3@PlayerInfo:

; 2975 : 	else if( Info_SetValueForStarKey( cls.userinfo, key, value, MAX_INFO_STRING ))

	push	256					; 00000100H
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET _cls+9880
	call	_Info_SetValueForStarKey
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@PlayerInfo

; 2976 : 	{
; 2977 : 		// time to update server copy of userinfo
; 2978 : 		CL_ServerCommand( true, "setinfo \"%s\" \"%s\"\n", key, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@NFJFLDNN@setinfo?5?$CC?$CFs?$CC?5?$CC?$CFs?$CC?6@
	push	1
	call	_CL_ServerCommand
	add	esp, 16					; 00000010H
$LN1@PlayerInfo:

; 2979 : 	}
; 2980 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PlayerInfo_SetValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _PlayerInfo_ValueForKey
_TEXT	SEGMENT
_playerNum$ = 8						; size = 4
_key$ = 12						; size = 4
_PlayerInfo_ValueForKey PROC				; COMDAT

; 2945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2946 : 	// find the player
; 2947 : 	if(( playerNum > cl.maxclients ) || ( playerNum < 1 ))

	mov	eax, DWORD PTR _playerNum$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jg	SHORT $LN3@PlayerInfo
	cmp	DWORD PTR _playerNum$[ebp], 1
	jge	SHORT $LN2@PlayerInfo
$LN3@PlayerInfo:

; 2948 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PlayerInfo
$LN2@PlayerInfo:

; 2949 : 
; 2950 : 	if( !cl.players[playerNum-1].name[0] )

	mov	eax, DWORD PTR _playerNum$[ebp]
	sub	eax, 1
	imul	ecx, eax, 584
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _cl[ecx+eax+2185200]
	test	ecx, ecx
	jne	SHORT $LN4@PlayerInfo

; 2951 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PlayerInfo
$LN4@PlayerInfo:

; 2952 : 
; 2953 : 	return Info_ValueForKey( cl.players[playerNum-1].userinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerNum$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 584
	add	edx, OFFSET _cl+2184944
	push	edx
	call	_Info_ValueForKey
	add	esp, 8
$LN1@PlayerInfo:

; 2954 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PlayerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnLoadMapSprite
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_pfnLoadMapSprite PROC					; COMDAT

; 2934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2935 : 	return CL_LoadSpriteModel( filename, SPR_MAPSPRITE, 0 );

	push	0
	push	2
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH

; 2936 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLoadMapSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSetScreenFade
_TEXT	SEGMENT
_fade$ = 8						; size = 4
_pfnSetScreenFade PROC					; COMDAT

; 2923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2924 : 	if( fade ) clgame.fade = *fade;

	cmp	DWORD PTR _fade$[ebp], 0
	je	SHORT $LN1@pfnSetScre
	mov	eax, DWORD PTR _fade$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clgame+214928, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _clgame+214932, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _clgame+214936, ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _clgame+214940, edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _clgame+214944, ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _clgame+214948, edx
$LN1@pfnSetScre:

; 2925 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetScreenFade
_TEXT	SEGMENT
_fade$ = 8						; size = 4
_pfnGetScreenFade PROC					; COMDAT

; 2912 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2913 : 	if( fade ) *fade = clgame.fade;

	cmp	DWORD PTR _fade$[ebp], 0
	je	SHORT $LN1@pfnGetScre
	mov	eax, DWORD PTR _fade$[ebp]
	mov	ecx, DWORD PTR _clgame+214928
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _clgame+214932
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _clgame+214936
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _clgame+214940
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _clgame+214944
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _clgame+214948
	mov	DWORD PTR [eax+20], edx
$LN1@pfnGetScre:

; 2914 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetLevelName
_TEXT	SEGMENT
$T1 = -68						; size = 4
_pfnGetLevelName PROC					; COMDAT

; 2895 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2896 : 	static char	mapname[64];
; 2897 : 
; 2898 : 	if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN2@pfnGetLeve

; 2899 : 		Q_snprintf( mapname, sizeof( mapname ), "maps/%s.bsp", clgame.mapname );

	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0M@DKNJHPLK@maps?1?$CFs?4bsp@
	push	64					; 00000040H
	push	OFFSET ?mapname@?1??pfnGetLevelName@@9@9
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@pfnGetLeve
$LN2@pfnGetLeve:

; 2900 : 	else mapname[0] = '\0'; // not in game

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 64			; 00000040H
	jae	SHORT $LN5@pfnGetLeve
	jmp	SHORT $LN6@pfnGetLeve
$LN5@pfnGetLeve:
	call	___report_rangecheckfailure
$LN6@pfnGetLeve:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?mapname@?1??pfnGetLevelName@@9@9[edx], 0
$LN3@pfnGetLeve:

; 2901 : 
; 2902 : 	return mapname;

	mov	eax, OFFSET ?mapname@?1??pfnGetLevelName@@9@9
$LN4@pfnGetLeve:

; 2903 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetLevelName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _Key_LookupBinding
_TEXT	SEGMENT
_pBinding$ = 8						; size = 4
_Key_LookupBinding PROC					; COMDAT

; 2884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2885 : 	return Key_KeynumToString( Key_GetKey( pBinding ));

	mov	eax, DWORD PTR _pBinding$[ebp]
	push	eax
	call	_Key_GetKey
	add	esp, 4
	push	eax
	call	_Key_KeynumToString
	add	esp, 4

; 2886 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Key_LookupBinding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetGameDirectory
_TEXT	SEGMENT
_pfnGetGameDirectory PROC				; COMDAT

; 2870 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2871 : 	static char	szGetGameDir[MAX_SYSPATH];
; 2872 : 
; 2873 : 	Q_sprintf( szGetGameDir, "%s/%s", host.rootdir, GI->gamedir );

	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	push	OFFSET ?szGetGameDir@?1??pfnGetGameDirectory@@9@9
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 2874 : 	return szGetGameDir;

	mov	eax, OFFSET ?szGetGameDir@?1??pfnGetGameDirectory@@9@9

; 2875 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetGameDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnStopAllSounds
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_entchannel$ = 12					; size = 4
_pfnStopAllSounds PROC					; COMDAT

; 2828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2829 : 	S_StopSound( ent, entchannel, NULL );

	push	0
	mov	eax, DWORD PTR _entchannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 2830 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStopAllSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetMoveVars
_TEXT	SEGMENT
_pfnGetMoveVars PROC					; COMDAT

; 2817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2818 : 	return &clgame.movevars;

	mov	eax, OFFSET _clgame+1024

; 2819 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetMoveVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnTraceSurface
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceSurface PROC					; COMDAT

; 2800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2801 : 	physent_t *pe;
; 2802 : 
; 2803 : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceSu
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceSu
$LN3@pfnTraceSu:

; 2804 : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceSu
$LN2@pfnTraceSu:

; 2805 : 
; 2806 : 	pe = &clgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 2807 : 	return PM_TraceSurface( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
$LN1@pfnTraceSu:

; 2808 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnTraceTexture
_TEXT	SEGMENT
_pe$ = -4						; size = 4
_ground$ = 8						; size = 4
_vstart$ = 12						; size = 4
_vend$ = 16						; size = 4
_pfnTraceTexture PROC					; COMDAT

; 2783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2784 : 	physent_t *pe;
; 2785 : 
; 2786 : 	if( ground < 0 || ground >= clgame.pmove->numphysent )

	cmp	DWORD PTR _ground$[ebp], 0
	jl	SHORT $LN3@pfnTraceTe
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _ground$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jl	SHORT $LN2@pfnTraceTe
$LN3@pfnTraceTe:

; 2787 : 		return NULL; // bad ground

	xor	eax, eax
	jmp	SHORT $LN1@pfnTraceTe
$LN2@pfnTraceTe:

; 2788 : 
; 2789 : 	pe = &clgame.pmove->physents[ground];

	imul	eax, DWORD PTR _ground$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 2790 : 	return PM_TraceTexture( pe, vstart, vend );

	mov	eax, DWORD PTR _vend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vstart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceTexture
	add	esp, 12					; 0000000cH
$LN1@pfnTraceTe:

; 2791 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetVisent
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_pfnGetVisent PROC					; COMDAT

; 2731 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2732 : 	if( idx >= 0 && idx < clgame.pmove->numvisent )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN2@pfnGetVise
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	ecx, DWORD PTR [eax+149332]
	jge	SHORT $LN2@pfnGetVise

; 2733 : 	{
; 2734 : 		// return physent
; 2735 : 		return &clgame.pmove->visents[idx];

	imul	eax, DWORD PTR _idx$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [ecx+eax+149336]
	jmp	SHORT $LN1@pfnGetVise
$LN2@pfnGetVise:

; 2736 : 	}
; 2737 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetVise:

; 2738 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetVisent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetPhysent
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_pfnGetPhysent PROC					; COMDAT

; 2715 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2716 : 	if( idx >= 0 && idx < clgame.pmove->numphysent )

	cmp	DWORD PTR _idx$[ebp], 0
	jl	SHORT $LN2@pfnGetPhys
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _idx$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	SHORT $LN2@pfnGetPhys

; 2717 : 	{
; 2718 : 		// return physent
; 2719 : 		return &clgame.pmove->physents[idx];

	imul	eax, DWORD PTR _idx$[ebp], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	eax, DWORD PTR [ecx+eax+592]
	jmp	SHORT $LN1@pfnGetPhys
$LN2@pfnGetPhys:

; 2720 : 	}
; 2721 : 	return NULL;

	xor	eax, eax
$LN1@pfnGetPhys:

; 2722 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPhysent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnLocalPlayerBounds
_TEXT	SEGMENT
_hull$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_pfnLocalPlayerBounds PROC				; COMDAT

; 2684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2685 : 	if( hull >= 0 && hull < 4 )

	cmp	DWORD PTR _hull$[ebp], 0
	jl	$LN4@pfnLocalPl
	cmp	DWORD PTR _hull$[ebp], 4
	jge	$LN4@pfnLocalPl

; 2686 : 	{
; 2687 : 		if( mins ) VectorCopy( clgame.pmove->player_mins[hull], mins );

	cmp	DWORD PTR _mins$[ebp], 0
	je	SHORT $LN3@pfnLocalPl
	imul	eax, DWORD PTR _hull$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+324856]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
$LN3@pfnLocalPl:

; 2688 : 		if( maxs ) VectorCopy( clgame.pmove->player_maxs[hull], maxs );

	cmp	DWORD PTR _maxs$[ebp], 0
	je	SHORT $LN4@pfnLocalPl
	imul	eax, DWORD PTR _hull$[ebp], 12
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+324904]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _hull$[ebp], 12
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
$LN4@pfnLocalPl:

; 2689 : 	}
; 2690 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLocalPlayerBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnLocalPlayerViewheight
_TEXT	SEGMENT
_view_ofs$ = 8						; size = 4
_pfnLocalPlayerViewheight PROC				; COMDAT

; 2673 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2674 : 	if( view_ofs ) VectorCopy( cl.viewheight, view_ofs );		

	cmp	DWORD PTR _view_ofs$[ebp], 0
	je	SHORT $LN2@pfnLocalPl
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _view_ofs$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+2212796]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _view_ofs$[ebp]
	mov	edx, DWORD PTR _cl[edx+2212796]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _view_ofs$[ebp]
	mov	eax, DWORD PTR _cl[eax+2212796]
	mov	DWORD PTR [edx+ecx], eax
$LN2@pfnLocalPl:

; 2675 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLocalPlayerViewheight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnLocalPlayerDucking
_TEXT	SEGMENT
tv65 = -68						; size = 4
_pfnLocalPlayerDucking PROC				; COMDAT

; 2662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2663 : 	return (cl.local.usehull == 1) ? true : false;

	cmp	DWORD PTR _cl+2212740, 1
	jne	SHORT $LN3@pfnLocalPl
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnLocalPl
$LN3@pfnLocalPl:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnLocalPl:
	mov	eax, DWORD PTR tv65[ebp]

; 2664 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLocalPlayerDucking ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnIsLocal
_TEXT	SEGMENT
_playernum$ = 8						; size = 4
_pfnIsLocal PROC					; COMDAT

; 2649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2650 : 	if( playernum == cl.playernum )

	mov	eax, DWORD PTR _playernum$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	jne	SHORT $LN2@pfnIsLocal

; 2651 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnIsLocal
$LN2@pfnIsLocal:

; 2652 : 	return false;

	xor	eax, eax
$LN1@pfnIsLocal:

; 2653 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsLocal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPlaySound
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_org$ = 12						; size = 4
_chan$ = 16						; size = 4
_samp$ = 20						; size = 4
_vol$ = 24						; size = 4
_attn$ = 28						; size = 4
_flags$ = 32						; size = 4
_pitch$ = 36						; size = 4
_pfnPlaySound PROC					; COMDAT

; 2601 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2602 : 	S_StartSound( org, ent, chan, S_RegisterSound( samp ), vol, attn, pitch, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _samp$[ebp]
	push	edx
	call	_S_RegisterSound
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 2603 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnKillEvents
_TEXT	SEGMENT
_eventIndex$ = -16					; size = 4
_ei$ = -12						; size = 4
_es$ = -8						; size = 4
_i$ = -4						; size = 4
_entnum$ = 8						; size = 4
_eventname$ = 12					; size = 4
_pfnKillEvents PROC					; COMDAT

; 2567 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2568 : 	int		i;
; 2569 : 	event_state_t	*es;
; 2570 : 	event_info_t	*ei;
; 2571 : 	int		eventIndex = CL_EventIndex( eventname );

	mov	eax, DWORD PTR _eventname$[ebp]
	push	eax
	call	_CL_EventIndex
	add	esp, 4
	movzx	ecx, ax
	mov	DWORD PTR _eventIndex$[ebp], ecx

; 2572 : 
; 2573 : 	if( eventIndex < 0 || eventIndex >= MAX_EVENTS )

	cmp	DWORD PTR _eventIndex$[ebp], 0
	jl	SHORT $LN6@pfnKillEve
	cmp	DWORD PTR _eventIndex$[ebp], 1024	; 00000400H
	jl	SHORT $LN5@pfnKillEve
$LN6@pfnKillEve:

; 2574 : 		return;

	jmp	SHORT $LN1@pfnKillEve
$LN5@pfnKillEve:

; 2575 : 
; 2576 : 	if( entnum < 0 || entnum > clgame.maxEntities )

	cmp	DWORD PTR _entnum$[ebp], 0
	jl	SHORT $LN8@pfnKillEve
	mov	eax, DWORD PTR _entnum$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jle	SHORT $LN7@pfnKillEve
$LN8@pfnKillEve:

; 2577 : 		return;

	jmp	SHORT $LN1@pfnKillEve
$LN7@pfnKillEve:

; 2578 : 
; 2579 : 	es = &cl.events;

	mov	DWORD PTR _es$[ebp], OFFSET _cl+2203896

; 2580 : 
; 2581 : 	// find all events with specified index and kill it
; 2582 : 	for( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnKillEve
$LN2@pfnKillEve:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnKillEve:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN1@pfnKillEve

; 2583 : 	{
; 2584 : 		ei = &es->ei[i];

	imul	eax, DWORD PTR _i$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 2585 : 
; 2586 : 		if( ei->index == eventIndex && ei->entity_index == entnum )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, DWORD PTR _eventIndex$[ebp]
	jne	SHORT $LN9@pfnKillEve
	mov	eax, DWORD PTR _ei$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@pfnKillEve

; 2587 : 		{
; 2588 : 			CL_ResetEvent( ei );

	mov	eax, DWORD PTR _ei$[ebp]
	push	eax
	call	_CL_ResetEvent
	add	esp, 4

; 2589 : 			break;

	jmp	SHORT $LN1@pfnKillEve
$LN9@pfnKillEve:

; 2590 : 		}
; 2591 : 	}

	jmp	SHORT $LN2@pfnKillEve
$LN1@pfnKillEve:

; 2592 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnKillEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnHookEvent
_TEXT	SEGMENT
_i$ = -76						; size = 4
_ev$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_pfn$ = 12						; size = 4
_pfnHookEvent PROC					; COMDAT

; 2532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2533 : 	char		name[64];
; 2534 : 	cl_user_event_t	*ev;
; 2535 : 	int		i;
; 2536 : 
; 2537 : 	// ignore blank names
; 2538 : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN6@pfnHookEve
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@pfnHookEve
$LN6@pfnHookEve:

; 2539 : 		return;	

	jmp	$LN1@pfnHookEve
$LN5@pfnHookEve:

; 2540 : 
; 2541 : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2542 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2543 : 
; 2544 : 	// find an empty slot
; 2545 : 	for( i = 0; i < MAX_EVENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnHookEve
$LN2@pfnHookEve:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnHookEve:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@pfnHookEve

; 2546 : 	{
; 2547 : 		ev = clgame.events[i];		

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10028]
	mov	DWORD PTR _ev$[ebp], ecx

; 2548 : 		if( !ev ) break;

	cmp	DWORD PTR _ev$[ebp], 0
	jne	SHORT $LN7@pfnHookEve
	jmp	SHORT $LN3@pfnHookEve
$LN7@pfnHookEve:

; 2549 : 
; 2550 : 		if( !Q_stricmp( name, ev->name ) && ev->func != NULL )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _ev$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@pfnHookEve
	mov	eax, DWORD PTR _ev$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN8@pfnHookEve

; 2551 : 		{
; 2552 : 			Con_Reportf( S_WARN "CL_HookEvent: %s already hooked!\n", name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@IAOEKLFI@?$FO3Warning?3?$FO7?5CL_HookEvent?3?5?$CFs?5a@
	call	_Con_Reportf
	add	esp, 8

; 2553 : 			return;

	jmp	SHORT $LN1@pfnHookEve
$LN8@pfnHookEve:

; 2554 : 		}
; 2555 : 	}

	jmp	SHORT $LN2@pfnHookEve
$LN3@pfnHookEve:

; 2556 : 
; 2557 : 	CL_RegisterEvent( i, name, pfn );

	mov	eax, DWORD PTR _pfn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_CL_RegisterEvent
	add	esp, 12					; 0000000cH
$LN1@pfnHookEve:

; 2558 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHookEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPrecacheEvent
_TEXT	SEGMENT
_type$ = 8						; size = 4
_psz$ = 12						; size = 4
_pfnPrecacheEvent PROC					; COMDAT

; 2521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2522 : 	return CL_EventIndex( psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_CL_EventIndex
	add	esp, 4

; 2523 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPrecacheEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPlaySoundByNameAtLocation
_TEXT	SEGMENT
_hSound$ = -4						; size = 4
_szSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_origin$ = 16						; size = 4
_pfnPlaySoundByNameAtLocation PROC			; COMDAT

; 2509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2510 : 	int hSound = S_RegisterSound( szSound );

	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 2511 : 	S_StartSound( origin, 0, CHAN_AUTO, hSound, volume, ATTN_NORM, PITCH_NORM, 0 );

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 2512 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByNameAtLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnTraceLine
_TEXT	SEGMENT
tv66 = -208						; size = 4
$T1 = -204						; size = 68
$T2 = -136						; size = 68
_old_usehull$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_flags$ = 16						; size = 4
_usehull$ = 20						; size = 4
_ignore_pe$ = 24					; size = 4
_pfnTraceLine PROC					; COMDAT

; 2486 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi

; 2487 : 	static pmtrace_t	tr;
; 2488 : 	int		old_usehull;
; 2489 : 
; 2490 : 	old_usehull = clgame.pmove->usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR _old_usehull$[ebp], ecx

; 2491 : 	clgame.pmove->usehull = usehull;	

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 2492 : 
; 2493 : 	switch( flags )

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN4@pfnTraceLi
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN5@pfnTraceLi
	jmp	$LN2@pfnTraceLi
$LN4@pfnTraceLi:

; 2494 : 	{
; 2495 : 	case PM_TRACELINE_PHYSENTSONLY:
; 2496 : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd

; 2497 : 		break;

	jmp	SHORT $LN2@pfnTraceLi
$LN5@pfnTraceLi:

; 2498 : 	case PM_TRACELINE_ANYVISIBLE:
; 2499 : 		tr = PM_PlayerTraceExt( clgame.pmove, start, end, 0, clgame.pmove->numvisent, clgame.pmove->visents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 149336				; 00024758H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+149332]
	push	eax
	push	0
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _clgame+1344
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, OFFSET ?tr@?1??pfnTraceLine@@9@9
	rep movsd
$LN2@pfnTraceLi:

; 2500 : 		break;
; 2501 : 	}
; 2502 : 
; 2503 : 	clgame.pmove->usehull = old_usehull;

	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _old_usehull$[ebp]
	mov	DWORD PTR [eax+188], ecx

; 2504 : 
; 2505 : 	return &tr;

	mov	eax, OFFSET ?tr@?1??pfnTraceLine@@9@9

; 2506 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnTraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPointContents
_TEXT	SEGMENT
_truecont$ = -8						; size = 4
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_truecontents$ = 12					; size = 4
_pfnPointContents PROC					; COMDAT

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2469 : 	int	cont, truecont;
; 2470 : 
; 2471 : 	truecont = cont = CL_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_TruePointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR _truecont$[ebp], ecx

; 2472 : 	if( truecontents ) *truecontents = truecont;

	cmp	DWORD PTR _truecontents$[ebp], 0
	je	SHORT $LN2@pfnPointCo
	mov	eax, DWORD PTR _truecontents$[ebp]
	mov	ecx, DWORD PTR _truecont$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnPointCo:

; 2473 : 
; 2474 : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN3@pfnPointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN3@pfnPointCo

; 2475 : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN3@pfnPointCo:

; 2476 : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 2477 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnIsSpectateOnly
_TEXT	SEGMENT
tv65 = -68						; size = 4
_pfnIsSpectateOnly PROC					; COMDAT

; 2457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2458 : 	return (cls.spectator != 0);

	cmp	DWORD PTR _cls+152, 0
	je	SHORT $LN3@pfnIsSpect
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@pfnIsSpect
$LN3@pfnIsSpect:
	mov	DWORD PTR tv65[ebp], 0
$LN4@pfnIsSpect:
	mov	eax, DWORD PTR tv65[ebp]

; 2459 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsSpectateOnly ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnApplyShake
_TEXT	SEGMENT
tv88 = -68						; size = 4
_origin$ = 8						; size = 4
_angles$ = 12						; size = 4
_factor$ = 16						; size = 4
_pfnApplyShake PROC					; COMDAT

; 2445 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2446 : 	if( origin ) VectorMA( origin, factor, clgame.shake.applied_offset, origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	$LN2@pfnApplySh
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[eax+214988]
	mov	edx, DWORD PTR _origin$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[ecx+214988]
	mov	edx, DWORD PTR _origin$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _factor$[ebp]
	mulss	xmm0, DWORD PTR _clgame[eax+214988]
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv88[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN2@pfnApplySh:

; 2447 : 	if( angles ) angles[ROLL] += clgame.shake.applied_angle * factor;

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN3@pfnApplySh
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _clgame+215000
	mulss	xmm0, DWORD PTR _factor$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _angles$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN3@pfnApplySh:

; 2448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnApplyShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnCalcShake
_TEXT	SEGMENT
tv234 = -96						; size = 8
tv252 = -88						; size = 8
tv156 = -84						; size = 4
_localAmp$ = -16					; size = 4
_freq$ = -12						; size = 4
_fraction$ = -8						; size = 4
_i$ = -4						; size = 4
_pfnCalcShake PROC					; COMDAT

; 2383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 2384 : 	int	i;
; 2385 : 	float	fraction, freq;
; 2386 : 	float	localAmp;
; 2387 : 
; 2388 : 	if( clgame.shake.time == 0 )

	movss	xmm0, DWORD PTR _clgame+214952
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@pfnCalcSha

; 2389 : 		return;

	jmp	$LN1@pfnCalcSha
$LN5@pfnCalcSha:

; 2390 : 
; 2391 : 	if(( cl.time > clgame.shake.time ) || clgame.shake.amplitude <= 0 || clgame.shake.frequency <= 0 )

	cvtss2sd xmm0, DWORD PTR _clgame+214952
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN7@pfnCalcSha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _clgame+214960
	jae	SHORT $LN7@pfnCalcSha
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _clgame+214964
	jb	SHORT $LN6@pfnCalcSha
$LN7@pfnCalcSha:

; 2392 : 	{
; 2393 : 		memset( &clgame.shake, 0, sizeof( clgame.shake ));

	push	52					; 00000034H
	push	0
	push	OFFSET _clgame+214952
	call	_memset
	add	esp, 12					; 0000000cH

; 2394 : 		return;

	jmp	$LN1@pfnCalcSha
$LN6@pfnCalcSha:

; 2395 : 	}
; 2396 : 
; 2397 : 	if( cl.time > clgame.shake.next_shake )

	cvtss2sd xmm0, DWORD PTR _clgame+214968
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	$LN8@pfnCalcSha

; 2398 : 	{
; 2399 : 		// higher frequency means we recalc the extents more often and perturb the display again
; 2400 : 		clgame.shake.next_shake = cl.time + ( 1.0f / clgame.shake.frequency );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _clgame+214964
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _clgame+214968, xmm0

; 2401 : 
; 2402 : 		// compute random shake extents (the shake will settle down from this)
; 2403 : 		for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnCalcSha
$LN2@pfnCalcSha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnCalcSha:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@pfnCalcSha

; 2404 : 			clgame.shake.offset[i] = COM_RandomFloat( -clgame.shake.amplitude, clgame.shake.amplitude );

	push	ecx
	movss	xmm0, DWORD PTR _clgame+214960
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _clgame+214960
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _i$[ebp]
	fstp	DWORD PTR _clgame[eax*4+214972]
	jmp	SHORT $LN2@pfnCalcSha
$LN3@pfnCalcSha:

; 2405 : 		clgame.shake.angle = COM_RandomFloat( -clgame.shake.amplitude * 0.25f, clgame.shake.amplitude * 0.25f );

	movss	xmm0, DWORD PTR _clgame+214960
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _clgame+214960
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@3e800000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _clgame+214984
$LN8@pfnCalcSha:

; 2406 : 	}
; 2407 : 
; 2408 : 	// ramp down amplitude over duration (fraction goes from 1 to 0 linearly with slope 1/duration)
; 2409 : 	fraction = ( clgame.shake.time - cl.time ) / clgame.shake.duration;

	cvtss2sd xmm0, DWORD PTR _clgame+214952
	subsd	xmm0, QWORD PTR _cl+2167640
	cvtss2sd xmm1, DWORD PTR _clgame+214956
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2410 : 
; 2411 : 	// ramp up frequency over duration
; 2412 : 	if( fraction )

	movss	xmm0, DWORD PTR _fraction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@pfnCalcSha

; 2413 : 	{
; 2414 : 		freq = ( clgame.shake.frequency / fraction );

	movss	xmm0, DWORD PTR _clgame+214964
	divss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _freq$[ebp], xmm0

; 2415 : 	}

	jmp	SHORT $LN10@pfnCalcSha
$LN9@pfnCalcSha:

; 2416 : 	else
; 2417 : 	{
; 2418 : 		freq = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _freq$[ebp], xmm0
$LN10@pfnCalcSha:

; 2419 : 	}
; 2420 : 
; 2421 : 	// square fraction to approach zero more quickly
; 2422 : 	fraction *= fraction;

	movss	xmm0, DWORD PTR _fraction$[ebp]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2423 : 
; 2424 : 	// Sine wave that slowly settles to zero
; 2425 : 	fraction = fraction * sin( cl.time * freq );

	cvtss2sd xmm0, DWORD PTR _fraction$[ebp]
	cvtss2sd xmm1, DWORD PTR _freq$[ebp]
	mulsd	xmm1, QWORD PTR _cl+2167640
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv252[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv234[ebp]
	movsd	xmm0, QWORD PTR tv252[ebp]
	mulsd	xmm0, QWORD PTR tv234[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fraction$[ebp], xmm0

; 2426 : 	
; 2427 : 	// add to view origin
; 2428 : 	VectorScale( clgame.shake.offset, fraction, clgame.shake.applied_offset );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _clgame[ecx+214972]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _clgame[eax+214988], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _clgame[ecx+214972]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _clgame[edx+214988], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _clgame[eax+214972]
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR tv156[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv156[ebp]
	movss	DWORD PTR _clgame[ecx+214988], xmm0

; 2429 : 
; 2430 : 	// add to roll
; 2431 : 	clgame.shake.applied_angle = clgame.shake.angle * fraction;

	movss	xmm0, DWORD PTR _clgame+214984
	mulss	xmm0, DWORD PTR _fraction$[ebp]
	movss	DWORD PTR _clgame+215000, xmm0

; 2432 : 
; 2433 : 	// drop amplitude a bit, less for higher frequency shakes
; 2434 : 	localAmp = clgame.shake.amplitude * ( host.frametime / ( clgame.shake.duration * clgame.shake.frequency ));

	cvtss2sd xmm0, DWORD PTR _clgame+214960
	movss	xmm1, DWORD PTR _clgame+214956
	mulss	xmm1, DWORD PTR _clgame+214964
	cvtss2sd xmm1, xmm1
	movsd	xmm2, QWORD PTR _host+1448
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _localAmp$[ebp], xmm0

; 2435 : 	clgame.shake.amplitude -= localAmp;

	movss	xmm0, DWORD PTR _clgame+214960
	subss	xmm0, DWORD PTR _localAmp$[ebp]
	movss	DWORD PTR _clgame+214960, xmm0
$LN1@pfnCalcSha:

; 2436 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCalcShake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetClientTime
_TEXT	SEGMENT
tv66 = -68						; size = 4
_pfnGetClientTime PROC					; COMDAT

; 2372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2373 : 	return cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]

; 2374 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClientTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetViewModel
_TEXT	SEGMENT
_pfnGetViewModel PROC					; COMDAT

; 2361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2362 : 	return &clgame.viewent;

	mov	eax, OFFSET _clgame+260432

; 2363 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetViewModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnIsNoClipping
_TEXT	SEGMENT
tv71 = -68						; size = 4
_pfnIsNoClipping PROC					; COMDAT

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2351 : 	return ( cl.frames[cl.parsecountmod].playerstate[cl.playernum].movetype == MOVETYPE_NOCLIP );

	imul	eax, DWORD PTR _cl+12, 24056
	imul	ecx, DWORD PTR _cl+2213000, 452
	cmp	DWORD PTR _cl[eax+ecx+2824], 8
	jne	SHORT $LN3@pfnIsNoCli
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@pfnIsNoCli
$LN3@pfnIsNoCli:
	mov	DWORD PTR tv71[ebp], 0
$LN4@pfnIsNoCli:
	mov	eax, DWORD PTR tv71[ebp]

; 2352 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsNoClipping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetMousePosition
_TEXT	SEGMENT
_curpos$ = -8						; size = 8
_mx$ = 8						; size = 4
_my$ = 12						; size = 4
_pfnGetMousePosition PROC				; COMDAT

; 2333 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2334 : 	POINT	curpos;
; 2335 : 
; 2336 : 	GetCursorPos( &curpos );

	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 2337 : 	ScreenToClient( host.hWnd, &curpos );

	lea	eax, DWORD PTR _curpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ScreenToClient@8

; 2338 : 
; 2339 : 	if( mx ) *mx = curpos.x;

	cmp	DWORD PTR _mx$[ebp], 0
	je	SHORT $LN2@pfnGetMous
	mov	eax, DWORD PTR _mx$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@pfnGetMous:

; 2340 : 	if( my ) *my = curpos.y;

	cmp	DWORD PTR _my$[ebp], 0
	je	SHORT $LN1@pfnGetMous
	mov	eax, DWORD PTR _my$[ebp]
	mov	ecx, DWORD PTR _curpos$[ebp+4]
	mov	DWORD PTR [eax], ecx
$LN1@pfnGetMous:

; 2341 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetMousePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetClientMaxspeed
_TEXT	SEGMENT
_pfnGetClientMaxspeed PROC				; COMDAT

; 2322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2323 : 	return cl.local.maxspeed;

	fld	DWORD PTR _cl+2212756

; 2324 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClientMaxspeed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnServerInfo_ValueForKey
_TEXT	SEGMENT
_key$ = 8						; size = 4
_pfnServerInfo_ValueForKey PROC				; COMDAT

; 2310 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2311 : 	return Info_ValueForKey( cl.serverinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cl+2167660
	call	_Info_ValueForKey
	add	esp, 8

; 2312 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPhysInfo_ValueForKey
_TEXT	SEGMENT
_key$ = 8						; size = 4
_pfnPhysInfo_ValueForKey PROC				; COMDAT

; 2299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2300 : 	return Info_ValueForKey( cls.physinfo, key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET _cls+10136
	call	_Info_ValueForKey
	add	esp, 8

; 2301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPhysInfo_ValueForKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSetViewAngles
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_pfnSetViewAngles PROC					; COMDAT

; 2288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2289 : 	if( angles ) VectorCopy( angles, cl.viewangles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN2@pfnSetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _cl[eax+2212784], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _cl[ecx+2212784], eax
$LN2@pfnSetView:

; 2290 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetViewAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetViewAngles
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_pfnGetViewAngles PROC					; COMDAT

; 2276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2277 : 	if( angles ) VectorCopy( cl.viewangles, angles );

	cmp	DWORD PTR _angles$[ebp], 0
	je	SHORT $LN2@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+2212784]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR _cl[edx+2212784]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR _cl[eax+2212784]
	mov	DWORD PTR [edx+ecx], eax
$LN2@pfnGetView:

; 2278 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetViewAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetWindowCenterY
_TEXT	SEGMENT
_pfnGetWindowCenterY PROC				; COMDAT

; 2264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2265 : 	return host.window_center_y;

	mov	eax, DWORD PTR _host+34760

; 2266 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetWindowCenterY ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetWindowCenterX
_TEXT	SEGMENT
_pfnGetWindowCenterX PROC				; COMDAT

; 2253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2254 : 	return host.window_center_x;

	mov	eax, DWORD PTR _host+34756

; 2255 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetWindowCenterX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnCenterPrint
_TEXT	SEGMENT
_string$ = 8						; size = 4
_pfnCenterPrint PROC					; COMDAT

; 2242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2243 : 	CL_CenterPrint( string, 0.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3e800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_CL_CenterPrint
	add	esp, 8

; 2244 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnConsolePrint
_TEXT	SEGMENT
_string$ = 8						; size = 4
_pfnConsolePrint PROC					; COMDAT

; 2229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2230 : 	Con_Printf( "%s", string );

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8

; 2231 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnConsolePrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnDrawCharacterAlt
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_r$ = 20						; size = 4
_g$ = 24						; size = 4
_b$ = 28						; size = 4
_a$ = 32						; size = 4
_xscale$ = 36						; size = 4
_yscale$ = 40						; size = 4
_xpivot$ = 44						; size = 4
_ypivot$ = 48						; size = 4
_angle$ = 52						; size = 4
_selfangle$ = 56					; size = 4
_selfxpivot$ = 60					; size = 4
_selfypivot$ = 64					; size = 4
_pfnDrawCharacterAlt PROC				; COMDAT

; 2148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2149 : 	if (!cls.creditsFont.valid)

	cmp	DWORD PTR _cls+294996, 0
	jne	SHORT $LN2@pfnDrawCha

; 2150 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDrawCha
$LN2@pfnDrawCha:

; 2151 : 
; 2152 : 	number &= 255;

	mov	eax, DWORD PTR _number$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _number$[ebp], eax

; 2153 : 
; 2154 : 	if (number < 32) return 0;

	cmp	DWORD PTR _number$[ebp], 32		; 00000020H
	jge	SHORT $LN3@pfnDrawCha
	xor	eax, eax
	jmp	$LN1@pfnDrawCha
$LN3@pfnDrawCha:

; 2155 : 	if (y < -clgame.scrInfo.iCharHeight)

	mov	eax, DWORD PTR _clgame+217096
	neg	eax
	cmp	DWORD PTR _y$[ebp], eax
	jge	SHORT $LN4@pfnDrawCha

; 2156 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDrawCha
$LN4@pfnDrawCha:

; 2157 : 
; 2158 : 	clgame.ds.adjust_size = true;

	mov	DWORD PTR _clgame+214868, 1

; 2159 : 	pfnPIC_Set(cls.creditsFont.hFontTexture, r, g, b, a);

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g$[ebp]
	push	edx
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+290632
	push	ecx
	call	_pfnPIC_Set
	add	esp, 20					; 00000014H

; 2160 : 	pfnPIC_DrawAdditiveAlt(x, y, -1, -1, &cls.creditsFont.fontRc[number], xscale, yscale, selfangle, angle, xpivot, ypivot, selfxpivot, selfypivot); // Turn into new version

	mov	eax, DWORD PTR _selfypivot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _selfxpivot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ypivot$[ebp]
	push	edx
	mov	eax, DWORD PTR _xpivot$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _number$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _cls+290636
	push	ecx
	push	-1
	push	-1
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_pfnPIC_DrawAdditiveAlt
	add	esp, 52					; 00000034H

; 2161 : 	clgame.ds.adjust_size = false;

	mov	DWORD PTR _clgame+214868, 0

; 2162 : 
; 2163 : 	return clgame.scrInfo.charWidths[number];

	mov	eax, DWORD PTR _number$[ebp]
	movsx	eax, WORD PTR _clgame[eax*2+217100]
$LN1@pfnDrawCha:

; 2164 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawCharacterAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnDrawCharacter
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_number$ = 16						; size = 4
_r$ = 20						; size = 4
_g$ = 24						; size = 4
_b$ = 28						; size = 4
_pfnDrawCharacter PROC					; COMDAT

; 2122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2123 : 	if( !cls.creditsFont.valid )

	cmp	DWORD PTR _cls+294996, 0
	jne	SHORT $LN2@pfnDrawCha

; 2124 : 		return 0;

	xor	eax, eax
	jmp	$LN1@pfnDrawCha
$LN2@pfnDrawCha:

; 2125 : 
; 2126 : 	number &= 255;

	mov	eax, DWORD PTR _number$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _number$[ebp], eax

; 2127 : 
; 2128 : 	if( number < 32 ) return 0;

	cmp	DWORD PTR _number$[ebp], 32		; 00000020H
	jge	SHORT $LN3@pfnDrawCha
	xor	eax, eax
	jmp	SHORT $LN1@pfnDrawCha
$LN3@pfnDrawCha:

; 2129 : 	if( y < -clgame.scrInfo.iCharHeight )

	mov	eax, DWORD PTR _clgame+217096
	neg	eax
	cmp	DWORD PTR _y$[ebp], eax
	jge	SHORT $LN4@pfnDrawCha

; 2130 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnDrawCha
$LN4@pfnDrawCha:

; 2131 : 
; 2132 : 	clgame.ds.adjust_size = true;

	mov	DWORD PTR _clgame+214868, 1

; 2133 : 	pfnPIC_Set( cls.creditsFont.hFontTexture, r, g, b, 255 );

	push	255					; 000000ffH
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _cls+290632
	push	eax
	call	_pfnPIC_Set
	add	esp, 20					; 00000014H

; 2134 : 	pfnPIC_DrawAdditive( x, y, -1, -1, &cls.creditsFont.fontRc[number] );

	mov	eax, DWORD PTR _number$[ebp]
	shl	eax, 4
	add	eax, OFFSET _cls+290636
	push	eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_pfnPIC_DrawAdditive
	add	esp, 20					; 00000014H

; 2135 : 	clgame.ds.adjust_size = false;

	mov	DWORD PTR _clgame+214868, 0

; 2136 : 
; 2137 : 	return clgame.scrInfo.charWidths[number];

	mov	eax, DWORD PTR _number$[ebp]
	movsx	eax, WORD PTR _clgame[eax*2+217100]
$LN1@pfnDrawCha:

; 2138 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPlaySoundByIndex
_TEXT	SEGMENT
tv67 = -76						; size = 4
tv66 = -72						; size = 4
_hSound$ = -4						; size = 4
_iSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_pfnPlaySoundByIndex PROC				; COMDAT

; 2076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2077 : 	int hSound;
; 2078 : 
; 2079 : 	// make sure what we in-bounds
; 2080 : 	iSound = bound( 0, iSound, MAX_SOUNDS );

	cmp	DWORD PTR _iSound$[ebp], 0
	jl	SHORT $LN6@pfnPlaySou
	cmp	DWORD PTR _iSound$[ebp], 8192		; 00002000H
	jge	SHORT $LN4@pfnPlaySou
	mov	eax, DWORD PTR _iSound$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN5@pfnPlaySou
$LN4@pfnPlaySou:
	mov	DWORD PTR tv66[ebp], 8192		; 00002000H
$LN5@pfnPlaySou:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN7@pfnPlaySou
$LN6@pfnPlaySou:
	mov	DWORD PTR tv67[ebp], 0
$LN7@pfnPlaySou:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _iSound$[ebp], edx

; 2081 : 	hSound = cl.sound_index[iSound];

	mov	eax, DWORD PTR _iSound$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	mov	DWORD PTR _hSound$[ebp], ecx

; 2082 : 	if( !hSound ) return;

	cmp	DWORD PTR _hSound$[ebp], 0
	jne	SHORT $LN2@pfnPlaySou
	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 2083 : 
; 2084 : 	S_StartSound( NULL, cl.viewentity, CHAN_ITEM, hSound, volume, ATTN_NORM, PITCH_NORM, SND_STOP_LOOPING );

	push	1024					; 00000400H
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _cl+2212780
	push	ecx
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@pfnPlaySou:

; 2085 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnPlaySoundByName
_TEXT	SEGMENT
_hSound$ = -4						; size = 4
_szSound$ = 8						; size = 4
_volume$ = 12						; size = 4
_pfnPlaySoundByName PROC				; COMDAT

; 2064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2065 : 	int hSound = S_RegisterSound( szSound );

	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 2066 : 	S_StartSound( NULL, cl.viewentity, CHAN_ITEM, hSound, volume, ATTN_NORM, PITCH_NORM, SND_STOP_LOOPING );

	push	1024					; 00000400H
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _cl+2212780
	push	ecx
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 2067 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySoundByName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetPlayerInfo
_TEXT	SEGMENT
tv80 = -72						; size = 4
_player$ = -4						; size = 4
_ent_num$ = 8						; size = 4
_pinfo$ = 12						; size = 4
_pfnGetPlayerInfo PROC					; COMDAT

; 2034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2035 : 	player_info_t	*player;
; 2036 : 
; 2037 : 	ent_num -= 1; // player list if offset by 1 from ents

	mov	eax, DWORD PTR _ent_num$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ent_num$[ebp], eax

; 2038 : 
; 2039 : 	if( ent_num >= cl.maxclients || ent_num < 0 || !cl.players[ent_num].name[0] )

	mov	eax, DWORD PTR _ent_num$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jge	SHORT $LN3@pfnGetPlay
	cmp	DWORD PTR _ent_num$[ebp], 0
	jl	SHORT $LN3@pfnGetPlay
	imul	eax, DWORD PTR _ent_num$[ebp], 584
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _cl[eax+edx+2185200]
	test	eax, eax
	jne	SHORT $LN2@pfnGetPlay
$LN3@pfnGetPlay:

; 2040 : 	{
; 2041 : 		pinfo->name = NULL;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [eax], 0

; 2042 : 		pinfo->thisplayer = false;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	BYTE PTR [eax+6], 0

; 2043 : 		return;

	jmp	$LN1@pfnGetPlay
$LN2@pfnGetPlay:

; 2044 : 	}
; 2045 : 
; 2046 : 	player = &cl.players[ent_num];

	imul	eax, DWORD PTR _ent_num$[ebp], 584
	add	eax, OFFSET _cl+2184940
	mov	DWORD PTR _player$[ebp], eax

; 2047 : 	pinfo->thisplayer = ( ent_num == cl.playernum ) ? true : false;

	mov	eax, DWORD PTR _ent_num$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	jne	SHORT $LN5@pfnGetPlay
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN6@pfnGetPlay
$LN5@pfnGetPlay:
	mov	DWORD PTR tv80[ebp], 0
$LN6@pfnGetPlay:
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	dl, BYTE PTR tv80[ebp]
	mov	BYTE PTR [ecx+6], dl

; 2048 : 	pinfo->name = player->name;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 260				; 00000104H
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [ecx], eax

; 2049 : 	pinfo->model = player->model;

	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 304				; 00000130H
	mov	ecx, DWORD PTR _pinfo$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 2050 : 	pinfo->spectator = player->spectator;		

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	dl, BYTE PTR [ecx+292]
	mov	BYTE PTR [eax+7], dl

; 2051 : 	pinfo->ping = player->ping;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	dx, WORD PTR [ecx+296]
	mov	WORD PTR [eax+4], dx

; 2052 : 	pinfo->packetloss = player->packet_loss;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	dl, BYTE PTR [ecx+300]
	mov	BYTE PTR [eax+8], dl

; 2053 : 	pinfo->topcolor = player->topcolor;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	dx, WORD PTR [ecx+368]
	mov	WORD PTR [eax+16], dx

; 2054 : 	pinfo->bottomcolor = player->bottomcolor;

	mov	eax, DWORD PTR _pinfo$[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	dx, WORD PTR [ecx+372]
	mov	WORD PTR [eax+18], dx
$LN1@pfnGetPlay:

; 2055 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnClientCmd
_TEXT	SEGMENT
_szCmdString$ = 8					; size = 4
_pfnClientCmd PROC					; COMDAT

; 2009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2010 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnClientC

; 2011 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnClientC
$LN2@pfnClientC:

; 2012 : 
; 2013 : 	if( cls.initialized )

	cmp	DWORD PTR _cls+4, 0
	je	SHORT $LN3@pfnClientC

; 2014 : 	{
; 2015 : 		Cbuf_AddText( szCmdString );

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 2016 : 		Cbuf_AddText( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4

; 2017 : 	}

	jmp	SHORT $LN4@pfnClientC
$LN3@pfnClientC:

; 2018 : 	else
; 2019 : 	{
; 2020 : 		// will exec later
; 2021 : 		Q_strncat( host.deferred_cmd, va( "%s\n", szCmdString ), sizeof( host.deferred_cmd )); 

	push	128					; 00000080H
	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET _host+756
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN4@pfnClientC:

; 2022 : 	}
; 2023 : 
; 2024 : 	return 1;

	mov	eax, 1
$LN1@pfnClientC:

; 2025 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnServerCmd
_TEXT	SEGMENT
_buf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_szCmdString$ = 8					; size = 4
_pfnServerCmd PROC					; COMDAT

; 1989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1990 : 	string	buf;
; 1991 : 
; 1992 : 	if( !COM_CheckString( szCmdString ))

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnServerC

; 1993 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnServerC
$LN2@pfnServerC:

; 1994 : 
; 1995 : 	// just like the client typed "cmd xxxxx" at the console
; 1996 : 	Q_snprintf( buf, sizeof( buf ) - 1, "cmd %s\n", szCmdString );

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	push	OFFSET ??_C@_07EHMIKJCM@cmd?5?$CFs?6@
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1997 : 	Cbuf_AddText( buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 1998 : 
; 1999 : 	return 1;

	mov	eax, 1
$LN1@pfnServerC:

; 2000 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnServerCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnHookUserMsg
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_pfn$ = 12						; size = 4
_pfnHookUserMsg PROC					; COMDAT

; 1955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1956 : 	int	i;
; 1957 : 
; 1958 : 	// ignore blank names or invalid callbacks
; 1959 : 	if( !pszName || !*pszName || !pfn )

	cmp	DWORD PTR _pszName$[ebp], 0
	je	SHORT $LN6@pfnHookUse
	mov	eax, DWORD PTR _pszName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@pfnHookUse
	cmp	DWORD PTR _pfn$[ebp], 0
	jne	SHORT $LN5@pfnHookUse
$LN6@pfnHookUse:

; 1960 : 		return 0;	

	xor	eax, eax
	jmp	$LN1@pfnHookUse
$LN5@pfnHookUse:

; 1961 : 
; 1962 : 	for( i = 0; i < MAX_USER_MESSAGES && clgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@pfnHookUse
$LN2@pfnHookUse:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@pfnHookUse:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@pfnHookUse
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _clgame[eax+edx+1360]
	test	eax, eax
	je	SHORT $LN3@pfnHookUse

; 1963 : 	{
; 1964 : 		// see if already hooked
; 1965 : 		if( !Q_stricmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1360
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@pfnHookUse

; 1966 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@pfnHookUse
$LN7@pfnHookUse:

; 1967 : 	}

	jmp	SHORT $LN2@pfnHookUse
$LN3@pfnHookUse:

; 1968 : 
; 1969 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN8@pfnHookUse

; 1970 : 	{
; 1971 : 		Host_Error( "HookUserMsg: MAX_USER_MESSAGES hit!\n" );

	push	OFFSET ??_C@_0CF@DEPMEFPI@HookUserMsg?3?5MAX_USER_MESSAGES?5@
	call	_Host_Error
	add	esp, 4

; 1972 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnHookUse
$LN8@pfnHookUse:

; 1973 : 	}
; 1974 : 
; 1975 : 	// hook new message
; 1976 : 	Q_strncpy( clgame.msg[i].name, pszName, sizeof( clgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1360
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1977 : 	clgame.msg[i].func = pfn;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _pfn$[ebp]
	mov	DWORD PTR _clgame[eax+1400], ecx

; 1978 : 
; 1979 : 	return 1;

	mov	eax, 1
$LN1@pfnHookUse:

; 1980 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHookUserMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSetCrosshair
_TEXT	SEGMENT
_hspr$ = 8						; size = 4
_rc$ = 12						; size = 16
_r$ = 28						; size = 4
_g$ = 32						; size = 4
_b$ = 36						; size = 4
_pfnSetCrosshair PROC					; COMDAT

; 1939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1940 : 	clgame.ds.rgbaCrosshair[0] = (byte)r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _clgame[ecx+214924], dl

; 1941 : 	clgame.ds.rgbaCrosshair[1] = (byte)g;

	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _clgame[eax+214924], cl

; 1942 : 	clgame.ds.rgbaCrosshair[2] = (byte)b;

	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _clgame[eax+214924], cl

; 1943 : 	clgame.ds.rgbaCrosshair[3] = (byte)0xFF;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _clgame[ecx+214924], 255	; 000000ffH

; 1944 : 	clgame.ds.pCrosshair = CL_GetSpritePointer( hspr );

	mov	eax, DWORD PTR _hspr$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	mov	DWORD PTR _clgame+214904, eax

; 1945 : 	clgame.ds.rcCrosshair = rc;

	mov	eax, DWORD PTR _rc$[ebp]
	mov	DWORD PTR _clgame+214908, eax
	mov	ecx, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR _clgame+214912, ecx
	mov	edx, DWORD PTR _rc$[ebp+8]
	mov	DWORD PTR _clgame+214916, edx
	mov	eax, DWORD PTR _rc$[ebp+12]
	mov	DWORD PTR _clgame+214920, eax

; 1946 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetCrosshair ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnGetScreenInfo
_TEXT	SEGMENT
_hud_scale_height$1 = -12				; size = 4
_hud_scale_width$2 = -8					; size = 4
_hud_scale$ = -4					; size = 4
_pscrinfo$ = 8						; size = 4
_pfnGetScreenInfo PROC					; COMDAT

; 1880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1881 : 	// setup screen info
; 1882 : 	clgame.scrInfo.iSize = sizeof( clgame.scrInfo );

	mov	DWORD PTR _clgame+217072, 540		; 0000021cH

; 1883 : 	clgame.scrInfo.iFlags = SCRINFO_SCREENFLASH;

	mov	DWORD PTR _clgame+217084, 1

; 1884 : 
; 1885 : 	// Get HUD Scale
; 1886 : 	int hud_scale = Cvar_VariableInteger("hud_scale");

	push	OFFSET ??_C@_09GMLECNLK@hud_scale@
	call	_Cvar_VariableInteger
	add	esp, 4
	mov	DWORD PTR _hud_scale$[ebp], eax

; 1887 : 
; 1888 : 	// Catch stuff you don't want to happen
; 1889 : 	if (hud_scale < -1 || hud_scale >= sizeof(vidmode2)) hud_scale = -1;

	cmp	DWORD PTR _hud_scale$[ebp], -1
	jl	SHORT $LN3@pfnGetScre
	cmp	DWORD PTR _hud_scale$[ebp], 416		; 000001a0H
	jb	SHORT $LN2@pfnGetScre
$LN3@pfnGetScre:
	mov	DWORD PTR _hud_scale$[ebp], -1
$LN2@pfnGetScre:

; 1890 : 
; 1891 : 	if( hud_scale != -1 )

	cmp	DWORD PTR _hud_scale$[ebp], -1
	je	SHORT $defroute$12

; 1892 : 	{
; 1893 : 		int hud_scale_width = vidmode2[hud_scale].width;

	mov	eax, DWORD PTR _hud_scale$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode2[eax+4]
	mov	DWORD PTR _hud_scale_width$2[ebp], ecx

; 1894 : 		int hud_scale_height = vidmode2[hud_scale].height;

	mov	eax, DWORD PTR _hud_scale$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode2[eax+8]
	mov	DWORD PTR _hud_scale_height$1[ebp], ecx

; 1895 : 
; 1896 : 		if (hud_scale_width != glState.width || hud_scale_height != glState.height)

	mov	eax, DWORD PTR _hud_scale_width$2[ebp]
	cmp	eax, DWORD PTR _glState
	jne	SHORT $LN8@pfnGetScre
	mov	eax, DWORD PTR _hud_scale_height$1[ebp]
	cmp	eax, DWORD PTR _glState+4
	je	SHORT $LN6@pfnGetScre
$LN8@pfnGetScre:

; 1897 : 		{
; 1898 : 			// virtual screen space 640x480
; 1899 : 			clgame.scrInfo.iWidth = hud_scale_width;

	mov	eax, DWORD PTR _hud_scale_width$2[ebp]
	mov	DWORD PTR _clgame+217076, eax

; 1900 : 			clgame.scrInfo.iHeight = hud_scale_height;

	mov	eax, DWORD PTR _hud_scale_height$1[ebp]
	mov	DWORD PTR _clgame+217080, eax

; 1901 : 			clgame.scrInfo.iFlags |= SCRINFO_STRETCHED;

	mov	eax, DWORD PTR _clgame+217084
	or	eax, 2
	mov	DWORD PTR _clgame+217084, eax

; 1902 : 		}

	jmp	SHORT $LN7@pfnGetScre
$LN6@pfnGetScre:

; 1903 : 		else
; 1904 : 		{
; 1905 : 			goto defroute;

	jmp	SHORT $defroute$12
$LN7@pfnGetScre:

; 1906 : 		}
; 1907 : 	}

	jmp	SHORT $LN5@pfnGetScre
$defroute$12:

; 1908 : 	else
; 1909 : 	{
; 1910 : 		defroute:
; 1911 : 		clgame.scrInfo.iWidth = glState.width;

	mov	eax, DWORD PTR _glState
	mov	DWORD PTR _clgame+217076, eax

; 1912 : 		clgame.scrInfo.iHeight = glState.height;

	mov	eax, DWORD PTR _glState+4
	mov	DWORD PTR _clgame+217080, eax

; 1913 : 		clgame.scrInfo.iFlags &= ~SCRINFO_STRETCHED;

	mov	eax, DWORD PTR _clgame+217084
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _clgame+217084, eax
$LN5@pfnGetScre:

; 1914 : 	}
; 1915 : 
; 1916 : 	// Always acquire this as is for scaling routines
; 1917 : 	clgame.scrInfo.iHeightOrg = glState.height;

	mov	eax, DWORD PTR _glState+4
	mov	DWORD PTR _clgame+217092, eax

; 1918 : 	clgame.scrInfo.iWidthOrg = glState.width;

	mov	eax, DWORD PTR _glState
	mov	DWORD PTR _clgame+217088, eax

; 1919 : 
; 1920 : 	if( !pscrinfo ) return 0;

	cmp	DWORD PTR _pscrinfo$[ebp], 0
	jne	SHORT $LN9@pfnGetScre
	xor	eax, eax
	jmp	SHORT $LN1@pfnGetScre
$LN9@pfnGetScre:

; 1921 : 
; 1922 : 	if( pscrinfo->iSize != clgame.scrInfo.iSize )

	mov	eax, DWORD PTR _pscrinfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _clgame+217072
	je	SHORT $LN10@pfnGetScre

; 1923 : 		clgame.scrInfo.iSize = pscrinfo->iSize;

	mov	eax, DWORD PTR _pscrinfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clgame+217072, ecx
$LN10@pfnGetScre:

; 1924 : 
; 1925 : 	// copy screeninfo out
; 1926 : 	memcpy( pscrinfo, &clgame.scrInfo, clgame.scrInfo.iSize );

	mov	eax, DWORD PTR _clgame+217072
	push	eax
	push	OFFSET _clgame+217072
	mov	ecx, DWORD PTR _pscrinfo$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1927 : 
; 1928 : 	return 1;

	mov	eax, 1
$LN1@pfnGetScre:

; 1929 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetScreenInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_GetList
_TEXT	SEGMENT
_token$ = -284						; size = 256
_pfile$ = -28						; size = 4
_afile$ = -24						; size = 4
_numSprites$ = -20					; size = 4
_index$ = -16						; size = 4
_slot$ = -12						; size = 4
_pEntry$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_psz$ = 8						; size = 4
_piCount$ = 12						; size = 4
_pfnSPR_GetList PROC					; COMDAT

; 1566 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1567 : 	cached_spritelist_t	*pEntry = &clgame.sprlist[0];

	mov	eax, 72					; 00000048H
	imul	ecx, eax, 0
	add	ecx, OFFSET _clgame+218424
	mov	DWORD PTR _pEntry$[ebp], ecx

; 1568 : 	int		slot, index, numSprites = 0;

	mov	DWORD PTR _numSprites$[ebp], 0

; 1569 : 	char		*afile, *pfile;
; 1570 : 	string		token;
; 1571 : 
; 1572 : 	if( piCount ) *piCount = 0;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN8@pfnSPR_Get
	mov	eax, DWORD PTR _piCount$[ebp]
	mov	DWORD PTR [eax], 0
$LN8@pfnSPR_Get:

; 1573 : 
; 1574 : 	// see if already in list
; 1575 : 	// NOTE: client.dll is cache hud.txt but reparse weapon lists again and again
; 1576 : 	// obviously there a memory leak by-design. Cache the sprite lists to prevent it
; 1577 : 	for( slot = 0; slot < MAX_CLIENT_SPRITES && pEntry->szListName[0]; slot++ )

	mov	DWORD PTR _slot$[ebp], 0
	jmp	SHORT $LN4@pfnSPR_Get
$LN2@pfnSPR_Get:
	mov	eax, DWORD PTR _slot$[ebp]
	add	eax, 1
	mov	DWORD PTR _slot$[ebp], eax
$LN4@pfnSPR_Get:
	cmp	DWORD PTR _slot$[ebp], 512		; 00000200H
	jge	SHORT $LN3@pfnSPR_Get
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pEntry$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN3@pfnSPR_Get

; 1578 : 	{
; 1579 : 		pEntry = &clgame.sprlist[slot];

	imul	eax, DWORD PTR _slot$[ebp], 72
	add	eax, OFFSET _clgame+218424
	mov	DWORD PTR _pEntry$[ebp], eax

; 1580 : 
; 1581 : 		if( !Q_stricmp( pEntry->szListName, psz ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntry$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@pfnSPR_Get

; 1582 : 		{
; 1583 : 			if( piCount ) *piCount = pEntry->count;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN10@pfnSPR_Get
	mov	eax, DWORD PTR _piCount$[ebp]
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax], edx
$LN10@pfnSPR_Get:

; 1584 : 			return pEntry->pList;

	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [eax+64]
	jmp	$LN1@pfnSPR_Get
$LN9@pfnSPR_Get:

; 1585 : 		}
; 1586 : 	}

	jmp	SHORT $LN2@pfnSPR_Get
$LN3@pfnSPR_Get:

; 1587 : 
; 1588 : 	if( slot == MAX_CLIENT_SPRITES )

	cmp	DWORD PTR _slot$[ebp], 512		; 00000200H
	jne	SHORT $LN11@pfnSPR_Get

; 1589 : 	{
; 1590 : 		Con_Printf( S_ERROR "SPR_GetList: overflow cache!\n" );

	push	OFFSET ??_C@_0CJ@BEJKEGKD@?$FO1Error?3?$FO7?5SPR_GetList?3?5overflo@
	call	_Con_Printf
	add	esp, 4

; 1591 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@pfnSPR_Get
$LN11@pfnSPR_Get:

; 1592 :           }
; 1593 : 
; 1594 : 	if( !clgame.itemspath[0] )	// typically it's sprites\*.txt

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _clgame[ecx+740]
	test	edx, edx
	jne	SHORT $LN12@pfnSPR_Get

; 1595 : 		COM_ExtractFilePath( psz, clgame.itemspath );

	push	OFFSET _clgame+740
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_COM_ExtractFilePath
	add	esp, 8
$LN12@pfnSPR_Get:

; 1596 : 
; 1597 : 	afile = FS_LoadFile( psz, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 1598 : 	if( !afile ) return NULL;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN13@pfnSPR_Get
	xor	eax, eax
	jmp	$LN1@pfnSPR_Get
$LN13@pfnSPR_Get:

; 1599 : 
; 1600 : 	pfile = afile;

	mov	eax, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax

; 1601 : 	pfile = COM_ParseFile( pfile, token );          

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1602 : 	numSprites = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _numSprites$[ebp], eax

; 1603 : 
; 1604 : 	Q_strncpy( pEntry->szListName, psz, sizeof( pEntry->szListName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntry$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1605 : 
; 1606 : 	// name, res, pic, x, y, w, h
; 1607 : 	pEntry->pList = Mem_Calloc( cls.mempool, sizeof( client_sprite_t ) * numSprites );

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSPR_GetList@@9@9
	add	eax, 41					; 00000029H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _numSprites$[ebp], 152
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1608 : 
; 1609 : 	for( index = 0; index < numSprites; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN7@pfnSPR_Get
$LN5@pfnSPR_Get:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@pfnSPR_Get:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _numSprites$[ebp]
	jge	$LN6@pfnSPR_Get

; 1610 : 	{
; 1611 : 		if(( pfile = COM_ParseFile( pfile, token )) == NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	jne	SHORT $LN14@pfnSPR_Get

; 1612 : 			break;

	jmp	$LN6@pfnSPR_Get
$LN14@pfnSPR_Get:

; 1613 : 
; 1614 : 		Q_strncpy( pEntry->pList[index].szName, token, sizeof( pEntry->pList[0].szName ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	add	eax, ecx
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1615 : 
; 1616 : 		// read resolution
; 1617 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1618 : 		pEntry->pList[index].iRes = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+132], eax

; 1619 : 
; 1620 : 		// read spritename
; 1621 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1622 : 		Q_strncpy( pEntry->pList[index].szSprite, token, sizeof( pEntry->pList[0].szSprite ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+64]
	lea	ecx, DWORD PTR [eax+ecx+64]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1623 : 
; 1624 : 		// parse rectangle
; 1625 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1626 : 		pEntry->pList[index].rc.left = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+136], eax

; 1627 : 
; 1628 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1629 : 		pEntry->pList[index].rc.top = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	imul	ecx, DWORD PTR _index$[ebp], 152
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [edx+64]
	mov	DWORD PTR [edx+ecx+144], eax

; 1630 : 
; 1631 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1632 : 		pEntry->pList[index].rc.right = pEntry->pList[index].rc.left + Q_atoi( token );

	imul	esi, DWORD PTR _index$[ebp], 152
	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	edi, DWORD PTR [eax+64]
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	add	eax, DWORD PTR [edi+esi+136]
	imul	edx, DWORD PTR _index$[ebp], 152
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [ecx+64]
	mov	DWORD PTR [ecx+edx+140], eax

; 1633 : 
; 1634 : 		pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1635 : 		pEntry->pList[index].rc.bottom = pEntry->pList[index].rc.top + Q_atoi( token );

	imul	esi, DWORD PTR _index$[ebp], 152
	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	edi, DWORD PTR [eax+64]
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	add	eax, DWORD PTR [edi+esi+144]
	imul	edx, DWORD PTR _index$[ebp], 152
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [ecx+64]
	mov	DWORD PTR [ecx+edx+148], eax

; 1636 : 
; 1637 : 		pEntry->count++;

	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 1
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	DWORD PTR [edx+68], ecx

; 1638 : 	}

	jmp	$LN5@pfnSPR_Get
$LN6@pfnSPR_Get:

; 1639 : 
; 1640 : 	if( index < numSprites )

	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _numSprites$[ebp]
	jge	SHORT $LN15@pfnSPR_Get

; 1641 : 		Con_DPrintf( S_WARN "unexpected end of %s (%i should be %i)\n", psz, numSprites, index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numSprites$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@KLPJHDAJ@?$FO3Warning?3?$FO7?5unexpected?5end?5of?5@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN15@pfnSPR_Get:

; 1642 : 	if( piCount ) *piCount = pEntry->count;

	cmp	DWORD PTR _piCount$[ebp], 0
	je	SHORT $LN16@pfnSPR_Get
	mov	eax, DWORD PTR _piCount$[ebp]
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax], edx
$LN16@pfnSPR_Get:

; 1643 : 	Mem_Free( afile );

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnSPR_GetList@@9@9
	add	eax, 77					; 0000004dH
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _afile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1644 : 
; 1645 : 	return pEntry->pList;

	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [eax+64]
$LN1@pfnSPR_Get:

; 1646 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_GetList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_DrawAdditiveScale
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_xscale$ = 24						; size = 4
_yscale$ = 28						; size = 4
_selfangle$ = 32					; size = 4
_angle$ = 36						; size = 4
_xpivot$ = 40						; size = 4
_ypivot$ = 44						; size = 4
_pfnSPR_DrawAdditiveScale PROC				; COMDAT

; 1549 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1550 : 	pglEnable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1551 : 	pglBlendFunc(GL_ONE, GL_ONE);

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 1552 : 
; 1553 : 	SPR_DrawGenericScale(frame, x, y, -1, -1, prc, xscale, yscale, selfangle, angle, xpivot, ypivot, -1, -1);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGenericScale
	add	esp, 56					; 00000038H

; 1554 : 
; 1555 : 	pglDisable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1556 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_DrawAdditiveScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_DrawAdditive
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_DrawAdditive PROC				; COMDAT

; 1533 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1534 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1535 : 	pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 1536 : 
; 1537 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1538 : 
; 1539 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_DrawAdditive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Draw
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_Draw PROC					; COMDAT

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1503 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1504 : 
; 1505 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1506 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Draw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Set
_TEXT	SEGMENT
tv85 = -72						; size = 4
tv78 = -72						; size = 4
tv71 = -72						; size = 4
tv84 = -68						; size = 4
tv77 = -68						; size = 4
tv70 = -68						; size = 4
_hPic$ = 8						; size = 4
_r$ = 12						; size = 4
_g$ = 16						; size = 4
_b$ = 20						; size = 4
_pfnSPR_Set PROC					; COMDAT

; 1487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1488 : 	clgame.ds.pSprite = CL_GetSpritePointer( hPic );

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	mov	DWORD PTR _clgame+214844, eax

; 1489 : 	clgame.ds.spriteColor[0] = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@pfnSPR_Set
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@pfnSPR_Set
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN4@pfnSPR_Set
$LN3@pfnSPR_Set:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN4@pfnSPR_Set:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN6@pfnSPR_Set
$LN5@pfnSPR_Set:
	mov	DWORD PTR tv71[ebp], 0
$LN6@pfnSPR_Set:
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR tv71[ebp]
	mov	BYTE PTR _clgame[eax+214884], cl

; 1490 : 	clgame.ds.spriteColor[1] = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@pfnSPR_Set
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@pfnSPR_Set
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN8@pfnSPR_Set
$LN7@pfnSPR_Set:
	mov	DWORD PTR tv77[ebp], 255		; 000000ffH
$LN8@pfnSPR_Set:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN10@pfnSPR_Set
$LN9@pfnSPR_Set:
	mov	DWORD PTR tv78[ebp], 0
$LN10@pfnSPR_Set:
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR tv78[ebp]
	mov	BYTE PTR _clgame[edx+214884], al

; 1491 : 	clgame.ds.spriteColor[2] = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@pfnSPR_Set
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@pfnSPR_Set
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN12@pfnSPR_Set
$LN11@pfnSPR_Set:
	mov	DWORD PTR tv84[ebp], 255		; 000000ffH
$LN12@pfnSPR_Set:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	jmp	SHORT $LN14@pfnSPR_Set
$LN13@pfnSPR_Set:
	mov	DWORD PTR tv85[ebp], 0
$LN14@pfnSPR_Set:
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR tv85[ebp]
	mov	BYTE PTR _clgame[edx+214884], al

; 1492 : 	clgame.ds.spriteColor[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _clgame[ecx+214884], 255	; 000000ffH

; 1493 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Width
_TEXT	SEGMENT
_sprWidth$ = -4						; size = 4
_hPic$ = 8						; size = 4
_frame$ = 12						; size = 4
_pfnSPR_Width PROC					; COMDAT

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1473 : 	int	sprWidth;
; 1474 : 
; 1475 : 	R_GetSpriteParms( &sprWidth, NULL, NULL, frame, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _sprWidth$[ebp]
	push	edx
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1476 : 
; 1477 : 	return sprWidth;

	mov	eax, DWORD PTR _sprWidth$[ebp]

; 1478 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Width ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Height
_TEXT	SEGMENT
_sprHeight$ = -4					; size = 4
_hPic$ = 8						; size = 4
_frame$ = 12						; size = 4
_pfnSPR_Height PROC					; COMDAT

; 1457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1458 : 	int	sprHeight;
; 1459 : 
; 1460 : 	R_GetSpriteParms( NULL, &sprHeight, NULL, frame, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _sprHeight$[ebp]
	push	edx
	push	0
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1461 : 
; 1462 : 	return sprHeight;

	mov	eax, DWORD PTR _sprHeight$[ebp]

; 1463 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Height ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Frames
_TEXT	SEGMENT
_numFrames$ = -4					; size = 4
_hPic$ = 8						; size = 4
_pfnSPR_Frames PROC					; COMDAT

; 1442 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1443 : 	int	numFrames;
; 1444 : 
; 1445 : 	R_GetSpriteParms( NULL, NULL, &numFrames, 0, CL_GetSpritePointer( hPic ));

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	call	_CL_GetSpritePointer
	add	esp, 4
	push	eax
	push	0
	lea	ecx, DWORD PTR _numFrames$[ebp]
	push	ecx
	push	0
	push	0
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 1446 : 
; 1447 : 	return numFrames;

	mov	eax, DWORD PTR _numFrames$[ebp]

; 1448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Frames ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetSpritePointer
_TEXT	SEGMENT
tv73 = -76						; size = 4
_type$1 = -8						; size = 4
_mod$ = -4						; size = 4
_hSprite$ = 8						; size = 4
_CL_GetSpritePointer PROC				; COMDAT

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1412 : 	model_t	*mod;
; 1413 : 
; 1414 : 	if( hSprite <= 0 || hSprite >= MAX_CLIENT_SPRITES )

	cmp	DWORD PTR _hSprite$[ebp], 0
	jle	SHORT $LN3@CL_GetSpri
	cmp	DWORD PTR _hSprite$[ebp], 512		; 00000200H
	jl	SHORT $LN2@CL_GetSpri
$LN3@CL_GetSpri:

; 1415 : 		return NULL; // bad image

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetSpri
$LN2@CL_GetSpri:

; 1416 : 	mod = &clgame.sprites[hSprite];

	imul	eax, DWORD PTR _hSprite$[ebp], 392
	add	eax, OFFSET _clgame+14124
	mov	DWORD PTR _mod$[ebp], eax

; 1417 : 
; 1418 : 	if( mod->needload == NL_NEEDS_LOADED )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+64], 1
	jne	SHORT $LN4@CL_GetSpri

; 1419 : 	{
; 1420 : 		int	type = FBitSet( mod->flags, MODEL_CLIENT ) ? SPR_HUDSPRITE : SPR_MAPSPRITE;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN8@CL_GetSpri
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN9@CL_GetSpri
$LN8@CL_GetSpri:
	mov	DWORD PTR tv73[ebp], 2
$LN9@CL_GetSpri:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _type$1[ebp], edx

; 1421 : 
; 1422 : 		if( CL_LoadHudSprite( mod->name, mod, type, mod->numtexinfo ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	mov	edx, DWORD PTR _type$1[ebp]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@CL_GetSpri

; 1423 : 			return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_GetSpri
$LN4@CL_GetSpri:

; 1424 : 	}
; 1425 : 
; 1426 : 	if( mod->mempool )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN6@CL_GetSpri

; 1427 : 	{
; 1428 : 		mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2

; 1429 : 		return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_GetSpri
$LN6@CL_GetSpri:

; 1430 : 	}
; 1431 : 
; 1432 : 	return NULL;

	xor	eax, eax
$LN1@CL_GetSpri:

; 1433 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetSpritePointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LoadSpriteModel
_TEXT	SEGMENT
_i$ = -76						; size = 4
_mod$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
_texFlags$ = 16						; size = 4
_CL_LoadSpriteModel PROC				; COMDAT

; 1307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1308 : 	char	name[MAX_QPATH];
; 1309 : 	model_t	*mod;
; 1310 : 	int	i;
; 1311 : 
; 1312 : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@CL_LoadSpr

; 1313 : 	{
; 1314 : 		Con_Reportf( S_ERROR "CL_LoadSpriteModel: bad name!\n" );

	push	OFFSET ??_C@_0CK@NPFOHACF@?$FO1Error?3?$FO7?5CL_LoadSpriteModel?3?5@
	call	_Con_Reportf
	add	esp, 4

; 1315 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_LoadSpr
$LN8@CL_LoadSpr:

; 1316 : 	}
; 1317 : 
; 1318 : 	Q_strncpy( name, filename, sizeof( name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1319 : 	COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1320 : 
; 1321 : 	// slot 0 isn't used
; 1322 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+14124
	jmp	SHORT $LN4@CL_LoadSpr
$LN2@CL_LoadSpr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@CL_LoadSpr:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@CL_LoadSpr

; 1323 : 	{
; 1324 : 		if( !Q_stricmp( mod->name, name ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_LoadSpr

; 1325 : 		{
; 1326 : 			if( mod->needload == NL_NEEDS_LOADED )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+64], 1
	jne	SHORT $LN10@CL_LoadSpr

; 1327 : 			{
; 1328 : 				if( CL_LoadHudSprite( name, mod, type, texFlags ))

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@CL_LoadSpr

; 1329 : 					return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@CL_LoadSpr
$LN10@CL_LoadSpr:

; 1330 : 			}
; 1331 : 
; 1332 : 			// prolonge registration
; 1333 : 			mod->needload = NL_PRESENT;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+64], 2

; 1334 : 			return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	$LN1@CL_LoadSpr
$LN9@CL_LoadSpr:

; 1335 : 		}
; 1336 : 	}

	jmp	SHORT $LN2@CL_LoadSpr
$LN3@CL_LoadSpr:

; 1337 : 
; 1338 : 	// find a free model slot spot
; 1339 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+14124
	jmp	SHORT $LN7@CL_LoadSpr
$LN5@CL_LoadSpr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN7@CL_LoadSpr:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN6@CL_LoadSpr

; 1340 : 		if( !mod->name[0] ) break; // this is a valid spot

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN12@CL_LoadSpr
	jmp	SHORT $LN6@CL_LoadSpr
$LN12@CL_LoadSpr:
	jmp	SHORT $LN5@CL_LoadSpr
$LN6@CL_LoadSpr:

; 1341 : 
; 1342 : 	if( i == MAX_CLIENT_SPRITES ) 

	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jne	SHORT $LN13@CL_LoadSpr

; 1343 : 	{
; 1344 : 		Con_Printf( S_ERROR "MAX_CLIENT_SPRITES limit exceeded (%d)\n", MAX_CLIENT_SPRITES );

	push	512					; 00000200H
	push	OFFSET ??_C@_0DD@FHBFLJHM@?$FO1Error?3?$FO7?5MAX_CLIENT_SPRITES?5l@
	call	_Con_Printf
	add	esp, 8

; 1345 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadSpr
$LN13@CL_LoadSpr:

; 1346 : 	}
; 1347 : 
; 1348 : 	// load new map sprite
; 1349 : 	if( CL_LoadHudSprite( name, mod, type, texFlags ))

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_CL_LoadHudSprite
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN14@CL_LoadSpr

; 1350 : 		return mod;

	mov	eax, DWORD PTR _mod$[ebp]
	jmp	SHORT $LN1@CL_LoadSpr
$LN14@CL_LoadSpr:

; 1351 : 	return NULL;

	xor	eax, eax
$LN1@CL_LoadSpr:

; 1352 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadSpriteModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LoadHudSprite
_TEXT	SEGMENT
tv70 = -80						; size = 4
_loaded$ = -12						; size = 4
_size$ = -8						; size = 4
_buf$ = -4						; size = 4
_szSpriteName$ = 8					; size = 4
_m_pSprite$ = 12					; size = 4
_type$ = 16						; size = 4
_texFlags$ = 20						; size = 4
_CL_LoadHudSprite PROC					; COMDAT

; 1247 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1248 : 	byte	*buf;
; 1249 : 	size_t	size;
; 1250 : 	qboolean	loaded;
; 1251 : 
; 1252 : 	Assert( m_pSprite != NULL );

	cmp	DWORD PTR _m_pSprite$[ebp], 0
	je	SHORT $LN12@CL_LoadHud
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN13@CL_LoadHud
$LN12@CL_LoadHud:
	mov	DWORD PTR tv70[ebp], 0
$LN13@CL_LoadHud:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_LoadHudSprite@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BC@PLPDELIL@m_pSprite?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1253 : 
; 1254 : 	Q_strncpy( m_pSprite->name, szSpriteName, sizeof( m_pSprite->name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _szSpriteName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSprite$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1255 : 
; 1256 : 	// it's hud sprite, make difference names to prevent free shared textures
; 1257 : 	if( type == SPR_CLIENT || type == SPR_HUDSPRITE )

	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN3@CL_LoadHud
	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN2@CL_LoadHud
$LN3@CL_LoadHud:

; 1258 : 		SetBits( m_pSprite->flags, MODEL_CLIENT );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [edx+80], ecx
$LN2@CL_LoadHud:

; 1259 : 	m_pSprite->numtexinfo = texFlags; // store texFlags into numtexinfo

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	ecx, DWORD PTR _texFlags$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 1260 : 
; 1261 : 	if( FS_FileSize( szSpriteName, false ) == -1 )

	push	0
	mov	eax, DWORD PTR _szSpriteName$[ebp]
	push	eax
	call	_FS_FileSize
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN4@CL_LoadHud

; 1262 : 	{
; 1263 : 		if( cls.state != ca_active && cl.maxclients > 1 )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN5@CL_LoadHud
	cmp	DWORD PTR _cl+2213004, 1
	jle	SHORT $LN5@CL_LoadHud

; 1264 : 		{
; 1265 : 			// trying to download sprite from server
; 1266 : 			CL_AddClientResource( szSpriteName, t_model );

	push	2
	mov	eax, DWORD PTR _szSpriteName$[ebp]
	push	eax
	call	_CL_AddClientResource
	add	esp, 8

; 1267 : 			m_pSprite->needload = NL_NEEDS_LOADED;

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [eax+64], 1

; 1268 : 			return true;

	mov	eax, 1
	jmp	$LN1@CL_LoadHud

; 1269 : 		}

	jmp	SHORT $LN4@CL_LoadHud
$LN5@CL_LoadHud:

; 1270 : 		else
; 1271 : 		{
; 1272 : 			Con_Reportf( S_ERROR "%s couldn't load\n", szSpriteName );

	mov	eax, DWORD PTR _szSpriteName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@FMGBLKJM@?$FO1Error?3?$FO7?5?$CFs?5couldn?8t?5load?6@
	call	_Con_Reportf
	add	esp, 8

; 1273 : 			Mod_UnloadSpriteModel( m_pSprite );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1274 : 			return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadHud
$LN4@CL_LoadHud:

; 1275 : 		}
; 1276 : 	}
; 1277 : 
; 1278 : 	buf = FS_LoadFile( szSpriteName, &size, false );

	push	0
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szSpriteName$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 1279 : 	ASSERT( buf != NULL );

	cmp	DWORD PTR _buf$[ebp], 0
	jne	SHORT $LN7@CL_LoadHud
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_LoadHudSprite@@9@9
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN7@CL_LoadHud:

; 1280 : 
; 1281 : 	if( type == SPR_MAPSPRITE )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN8@CL_LoadHud

; 1282 : 		Mod_LoadMapSprite( m_pSprite, buf, size, &loaded );

	lea	eax, DWORD PTR _loaded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_LoadMapSprite
	add	esp, 16					; 00000010H
	jmp	SHORT $LN9@CL_LoadHud
$LN8@CL_LoadHud:

; 1283 : 	else Mod_LoadSpriteModel( m_pSprite, buf, &loaded, texFlags );		

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _loaded$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_LoadSpriteModel
	add	esp, 16					; 00000010H
$LN9@CL_LoadHud:

; 1284 : 
; 1285 : 	Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_LoadHudSprite@@9@9
	add	eax, 38					; 00000026H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1286 : 
; 1287 : 	if( !loaded )

	cmp	DWORD PTR _loaded$[ebp], 0
	jne	SHORT $LN10@CL_LoadHud

; 1288 : 	{
; 1289 : 		Mod_UnloadSpriteModel( m_pSprite );

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1290 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadHud
$LN10@CL_LoadHud:

; 1291 : 	}
; 1292 : 
; 1293 : 	m_pSprite->needload = NL_PRESENT;

	mov	eax, DWORD PTR _m_pSprite$[ebp]
	mov	DWORD PTR [eax+64], 2

; 1294 : 
; 1295 : 	return true;

	mov	eax, 1
$LN1@CL_LoadHud:

; 1296 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadHudSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawPause
_TEXT	SEGMENT
_yscale$ = -24						; size = 4
_xscale$ = -20						; size = 4
_height$ = -16						; size = 4
_width$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_CL_DrawPause PROC					; COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1048 : 	int	x, y, width, height;
; 1049 : 	float	xscale, yscale;
; 1050 : 
; 1051 : 	R_GetTextureParms( &width, &height, cls.pauseIcon );

	mov	eax, DWORD PTR _cls+290620
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 1052 : 	x = ( clgame.scrInfo.iWidth - width ) >> 1;

	mov	eax, DWORD PTR _clgame+217076
	sub	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 1053 : 	y = ( clgame.scrInfo.iHeight - height) >> 1;

	mov	eax, DWORD PTR _clgame+217080
	sub	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	mov	DWORD PTR _y$[ebp], eax

; 1054 : 
; 1055 : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+217076
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 1056 : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+217080
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 1057 : 
; 1058 : 	x *= xscale;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 1059 : 	y *= yscale;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 1060 : 	width *= xscale;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _width$[ebp], eax

; 1061 : 	height *= yscale;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _height$[ebp], eax

; 1062 : 
; 1063 : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1064 : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 1065 : 	R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.pauseIcon );

	mov	eax, DWORD PTR _cls+290620
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 1066 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawPause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawLoading
_TEXT	SEGMENT
_s2$ = -36						; size = 4
_step$ = -32						; size = 4
_yscale$ = -28						; size = 4
_xscale$ = -24						; size = 4
_right$ = -20						; size = 4
_height$ = -16						; size = 4
_width$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_percent$ = 8						; size = 4
_CL_DrawLoading PROC					; COMDAT

; 999  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 1000 : 	int	x, y, width, height, right;
; 1001 : 	float	xscale, yscale, step, s2;
; 1002 : 
; 1003 : 	R_GetTextureParms( &width, &height, cls.loadingBar );

	mov	eax, DWORD PTR _cls+290628
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 1004 : 	x = ( clgame.scrInfo.iWidth - width ) >> 1;

	mov	eax, DWORD PTR _clgame+217076
	sub	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 1005 : 	y = ( clgame.scrInfo.iHeight - height) >> 1;

	mov	eax, DWORD PTR _clgame+217080
	sub	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	mov	DWORD PTR _y$[ebp], eax

; 1006 : 
; 1007 : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+217076
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 1008 : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+217080
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 1009 : 
; 1010 : 	x *= xscale;

	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _x$[ebp], eax

; 1011 : 	y *= yscale;

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y$[ebp], eax

; 1012 : 	width *= xscale;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _width$[ebp], eax

; 1013 : 	height *= yscale;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _height$[ebp], eax

; 1014 : 
; 1015 : 	if( cl_allow_levelshots->value )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@CL_DrawLoa

; 1016 :           {
; 1017 : 		pglColor4ub( 128, 128, 128, 255 );

	push	255					; 000000ffH
	push	128					; 00000080H
	push	128					; 00000080H
	push	128					; 00000080H
	call	DWORD PTR _pglColor4ub

; 1018 : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 1019 : 		R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.loadingBar );

	mov	eax, DWORD PTR _cls+290628
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 1020 : 
; 1021 : 		step = (float)width / 100.0f;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _step$[ebp], xmm0

; 1022 : 		right = (int)ceil( percent * step );

	movss	xmm0, DWORD PTR _percent$[ebp]
	mulss	xmm0, DWORD PTR _step$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _right$[ebp], eax

; 1023 : 		s2 = (float)right / width;

	cvtsi2ss xmm0, DWORD PTR _right$[ebp]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 1024 : 		width = right;

	mov	eax, DWORD PTR _right$[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 1025 : 	
; 1026 : 		pglColor4ub( 208, 152, 0, 255 );

	push	255					; 000000ffH
	push	0
	push	152					; 00000098H
	push	208					; 000000d0H
	call	DWORD PTR _pglColor4ub

; 1027 : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 1028 : 		R_DrawStretchPic( x, y, width, height, 0, 0, s2, 1, cls.loadingBar );

	mov	eax, DWORD PTR _cls+290628
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 1029 : 		pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1030 : 	}

	jmp	$LN3@CL_DrawLoa
$LN2@CL_DrawLoa:

; 1031 : 	else
; 1032 : 	{
; 1033 : 		pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 1034 : 		GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 1035 : 		R_DrawStretchPic( x, y, width, height, 0, 0, 1, 1, cls.loadingBar );

	mov	eax, DWORD PTR _cls+290628
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H
$LN3@CL_DrawLoa:

; 1036 : 	}
; 1037 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawLoading ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawCrosshair
_TEXT	SEGMENT
tv170 = -136						; size = 4
tv145 = -136						; size = 4
_screen$1 = -68						; size = 12
_point$2 = -56						; size = 12
_forward$3 = -44					; size = 12
_angles$4 = -32						; size = 12
_height$ = -20						; size = 4
_width$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_DrawCrosshair PROC					; COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 891  : 	int	x, y, width, height;
; 892  : 
; 893  : 	if( !clgame.ds.pCrosshair || !cl_crosshair->value )

	cmp	DWORD PTR _clgame+214904, 0
	je	SHORT $LN3@CL_DrawCro
	mov	eax, DWORD PTR _cl_crosshair
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_DrawCro
$LN3@CL_DrawCro:

; 894  : 		return;

	jmp	$LN1@CL_DrawCro
$LN2@CL_DrawCro:

; 895  : 
; 896  : 	// any camera on or client is died
; 897  : 	if( cl.local.health <= 0 || cl.viewentity != ( cl.playernum + 1 ))

	cmp	DWORD PTR _cl+2212656, 0
	jle	SHORT $LN5@CL_DrawCro
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	je	SHORT $LN4@CL_DrawCro
$LN5@CL_DrawCro:

; 898  : 		return;

	jmp	$LN1@CL_DrawCro
$LN4@CL_DrawCro:

; 899  : 
; 900  : 	// get crosshair dimension
; 901  : 	width = clgame.ds.rcCrosshair.right - clgame.ds.rcCrosshair.left;

	mov	eax, DWORD PTR _clgame+214912
	sub	eax, DWORD PTR _clgame+214908
	mov	DWORD PTR _width$[ebp], eax

; 902  : 	height = clgame.ds.rcCrosshair.bottom - clgame.ds.rcCrosshair.top;

	mov	eax, DWORD PTR _clgame+214920
	sub	eax, DWORD PTR _clgame+214916
	mov	DWORD PTR _height$[ebp], eax

; 903  : 
; 904  : 	x = clgame.viewport[0] + ( clgame.viewport[2] >> 1 ); 

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clgame[edx+214828]
	sar	eax, 1
	add	eax, DWORD PTR _clgame[ecx+214828]
	mov	DWORD PTR _x$[ebp], eax

; 905  : 	y = clgame.viewport[1] + ( clgame.viewport[3] >> 1 );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _clgame[edx+214828]
	sar	ecx, 1
	add	ecx, DWORD PTR _clgame[eax+214828]
	mov	DWORD PTR _y$[ebp], ecx

; 906  : 
; 907  : 	// g-cont - cl.crosshairangle is the autoaim angle.
; 908  : 	// if we're not using autoaim, just draw in the middle of the screen
; 909  : 	if( !VectorIsNull( cl.crosshairangle ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _cl[ecx+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_DrawCro
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_DrawCro
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@CL_DrawCro
$LN7@CL_DrawCro:

; 910  : 	{
; 911  : 		vec3_t	angles;
; 912  : 		vec3_t	forward;
; 913  : 		vec3_t	point, screen;
; 914  : 
; 915  : 		VectorAdd( RI.viewangles, cl.crosshairangle, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	addss	xmm0, DWORD PTR _cl[eax+2212824]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	movss	DWORD PTR tv145[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR _angles$4[ebp+edx], xmm0

; 916  : 		AngleVectors( angles, forward, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _forward$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles$4[ebp]
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 917  : 		VectorAdd( RI.vieworg, forward, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	movss	DWORD PTR tv170[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv170[ebp]
	movss	DWORD PTR _point$2[ebp+edx], xmm0

; 918  : 		R_WorldToScreen( point, screen );

	lea	eax, DWORD PTR _screen$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _point$2[ebp]
	push	ecx
	call	_R_WorldToScreen
	add	esp, 8

; 919  : 
; 920  : 		x += ( clgame.viewport[2] >> 1 ) * screen[0] + 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clgame[eax+214828]
	sar	ecx, 1
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+eax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _x$[ebp], ecx

; 921  : 		y += ( clgame.viewport[3] >> 1 ) * screen[1] + 0.5f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _clgame[ecx+214828]
	sar	edx, 1
	cvtsi2ss xmm0, edx
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+eax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _y$[ebp], ecx
$LN6@CL_DrawCro:

; 922  : 	}
; 923  : 
; 924  : 	// move at center the screen
; 925  : 	x -= 0.5f * width;

	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _x$[ebp], eax

; 926  : 	y -= 0.5f * height;

	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	subss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax

; 927  : 
; 928  : 	clgame.ds.pSprite = clgame.ds.pCrosshair;

	mov	eax, DWORD PTR _clgame+214904
	mov	DWORD PTR _clgame+214844, eax

; 929  : 	*(int *)clgame.ds.spriteColor = *(int *)clgame.ds.rgbaCrosshair;

	mov	eax, DWORD PTR _clgame+214924
	mov	DWORD PTR _clgame+214884, eax

; 930  : 
; 931  : 	SPR_EnableScissor( x, y, width, height );

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_EnableScissor
	add	esp, 16					; 00000010H

; 932  : 	pfnSPR_DrawHoles( 0, x, y, &clgame.ds.rcCrosshair );

	push	OFFSET _clgame+214908
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	_pfnSPR_DrawHoles
	add	esp, 16					; 00000010H

; 933  : 	SPR_DisableScissor();

	call	_SPR_DisableScissor
$LN1@CL_DrawCro:

; 934  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawCrosshair ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_DisableScissor
_TEXT	SEGMENT
_SPR_DisableScissor PROC				; COMDAT

; 874  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 875  : 	clgame.ds.scissor_x = 0;

	mov	DWORD PTR _clgame+214848, 0

; 876  : 	clgame.ds.scissor_width = 0;

	mov	DWORD PTR _clgame+214856, 0

; 877  : 	clgame.ds.scissor_y = 0;

	mov	DWORD PTR _clgame+214852, 0

; 878  : 	clgame.ds.scissor_height = 0;

	mov	DWORD PTR _clgame+214860, 0

; 879  : 	clgame.ds.scissor_test = false;

	mov	DWORD PTR _clgame+214864, 0

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_DisableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_EnableScissor
_TEXT	SEGMENT
tv83 = -72						; size = 4
tv77 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv82 = -68						; size = 4
tv76 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_SPR_EnableScissor PROC					; COMDAT

; 853  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 854  : 	// check bounds
; 855  : 	x = bound( 0, x, clgame.scrInfo.iWidth );

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN5@SPR_Enable
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _clgame+217076
	jge	SHORT $LN3@SPR_Enable
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $LN4@SPR_Enable
$LN3@SPR_Enable:
	mov	edx, DWORD PTR _clgame+217076
	mov	DWORD PTR tv66[ebp], edx
$LN4@SPR_Enable:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN6@SPR_Enable
$LN5@SPR_Enable:
	mov	DWORD PTR tv67[ebp], 0
$LN6@SPR_Enable:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _x$[ebp], ecx

; 856  : 	y = bound( 0, y, clgame.scrInfo.iHeight );

	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN9@SPR_Enable
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _clgame+217080
	jge	SHORT $LN7@SPR_Enable
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN8@SPR_Enable
$LN7@SPR_Enable:
	mov	edx, DWORD PTR _clgame+217080
	mov	DWORD PTR tv70[ebp], edx
$LN8@SPR_Enable:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN10@SPR_Enable
$LN9@SPR_Enable:
	mov	DWORD PTR tv71[ebp], 0
$LN10@SPR_Enable:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 857  : 	width = bound( 0, width, clgame.scrInfo.iWidth - x );

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN13@SPR_Enable
	mov	eax, DWORD PTR _clgame+217076
	sub	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR _width$[ebp], eax
	jge	SHORT $LN11@SPR_Enable
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	jmp	SHORT $LN12@SPR_Enable
$LN11@SPR_Enable:
	mov	edx, DWORD PTR _clgame+217076
	sub	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv76[ebp], edx
$LN12@SPR_Enable:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN14@SPR_Enable
$LN13@SPR_Enable:
	mov	DWORD PTR tv77[ebp], 0
$LN14@SPR_Enable:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _width$[ebp], ecx

; 858  : 	height = bound( 0, height, clgame.scrInfo.iHeight - y );

	cmp	DWORD PTR _height$[ebp], 0
	jl	SHORT $LN17@SPR_Enable
	mov	eax, DWORD PTR _clgame+217080
	sub	eax, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _height$[ebp], eax
	jge	SHORT $LN15@SPR_Enable
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $LN16@SPR_Enable
$LN15@SPR_Enable:
	mov	edx, DWORD PTR _clgame+217080
	sub	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN16@SPR_Enable:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN18@SPR_Enable
$LN17@SPR_Enable:
	mov	DWORD PTR tv83[ebp], 0
$LN18@SPR_Enable:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _height$[ebp], ecx

; 859  : 
; 860  : 	clgame.ds.scissor_x = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _clgame+214848, eax

; 861  : 	clgame.ds.scissor_width = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _clgame+214856, eax

; 862  : 	clgame.ds.scissor_y = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _clgame+214852, eax

; 863  : 	clgame.ds.scissor_height = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _clgame+214860, eax

; 864  : 	clgame.ds.scissor_test = true;

	mov	DWORD PTR _clgame+214864, 1

; 865  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_EnableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_SoundFromIndex
_TEXT	SEGMENT
tv67 = -80						; size = 4
tv66 = -76						; size = 4
_hSound$ = -8						; size = 4
_sfx$ = -4						; size = 4
_index$ = 8						; size = 4
_CL_SoundFromIndex PROC					; COMDAT

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 823  : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 824  : 	int	hSound;
; 825  : 
; 826  : 	// make sure what we in-bounds
; 827  : 	index = bound( 0, index, MAX_SOUNDS );

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN7@CL_SoundFr
	cmp	DWORD PTR _index$[ebp], 8192		; 00002000H
	jge	SHORT $LN5@CL_SoundFr
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN6@CL_SoundFr
$LN5@CL_SoundFr:
	mov	DWORD PTR tv66[ebp], 8192		; 00002000H
$LN6@CL_SoundFr:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN8@CL_SoundFr
$LN7@CL_SoundFr:
	mov	DWORD PTR tv67[ebp], 0
$LN8@CL_SoundFr:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _index$[ebp], edx

; 828  : 	hSound = cl.sound_index[index];

	mov	eax, DWORD PTR _index$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	mov	DWORD PTR _hSound$[ebp], ecx

; 829  : 
; 830  : 	if( !hSound )

	cmp	DWORD PTR _hSound$[ebp], 0
	jne	SHORT $LN2@CL_SoundFr

; 831  : 	{
; 832  : 		Con_DPrintf( S_ERROR "CL_SoundFromIndex: invalid sound index %i\n", index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@DBDANMHK@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5i@
	call	_Con_DPrintf
	add	esp, 8

; 833  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_SoundFr
$LN2@CL_SoundFr:

; 834  : 	}
; 835  : 
; 836  : 	sfx = S_GetSfxByHandle( hSound );

	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 837  : 	if( !sfx )

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@CL_SoundFr

; 838  : 	{
; 839  : 		Con_DPrintf( S_ERROR "CL_SoundFromIndex: bad sfx for index %i\n", index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@EDLJDNCH@?$FO1Error?3?$FO7?5CL_SoundFromIndex?3?5b@
	call	_Con_DPrintf
	add	esp, 8

; 840  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_SoundFr
$LN3@CL_SoundFr:

; 841  : 	}
; 842  : 
; 843  : 	return sfx->name;

	mov	eax, DWORD PTR _sfx$[ebp]
$LN1@CL_SoundFr:

; 844  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SoundFromIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_InitTitles
_TEXT	SEGMENT
_i$ = -12						; size = 4
_pMemFile$ = -8						; size = 4
_fileSize$ = -4						; size = 4
_filename$ = 8						; size = 4
_CL_InitTitles PROC					; COMDAT

; 649  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 650  : 	size_t	fileSize;
; 651  : 	byte	*pMemFile;
; 652  : 	int	i;
; 653  : 
; 654  : 	// initialize text messages (game_text)
; 655  : 	for( i = 0; i < MAX_TEXTCHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_InitTit
$LN2@CL_InitTit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_InitTit:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@CL_InitTit

; 656  : 	{
; 657  : 		cl_textmessage[i].pName = _copystring( clgame.mempool, va( TEXT_MSGNAME, i ), __FILE__, __LINE__ );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitTitles@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	OFFSET ??_C@_0O@IDJGENMA@TextMessage?$CFi@
	call	_va
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _clgame+224
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _cl_textmessage[ecx+36], eax

; 658  : 		cl_textmessage[i].pMessage = cl_textbuffer[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 11					; 0000000bH
	add	eax, OFFSET _cl_textbuffer
	imul	ecx, DWORD PTR _i$[ebp], 44
	mov	DWORD PTR _cl_textmessage[ecx+40], eax

; 659  : 	}

	jmp	SHORT $LN2@CL_InitTit
$LN3@CL_InitTit:

; 660  : 
; 661  : 	// clear out any old data that's sitting around.
; 662  : 	if( clgame.titles ) Mem_Free( clgame.titles );

	cmp	DWORD PTR _clgame+255288, 0
	je	SHORT $LN5@CL_InitTit
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitTitles@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clgame+255288
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@CL_InitTit:

; 663  : 
; 664  : 	clgame.titles = NULL;

	mov	DWORD PTR _clgame+255288, 0

; 665  : 	clgame.numTitles = 0;

	mov	DWORD PTR _clgame+255292, 0

; 666  : 
; 667  : 	pMemFile = FS_LoadFile( filename, &fileSize, false );

	push	0
	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pMemFile$[ebp], eax

; 668  : 	if( !pMemFile ) return;

	cmp	DWORD PTR _pMemFile$[ebp], 0
	jne	SHORT $LN6@CL_InitTit
	jmp	SHORT $LN1@CL_InitTit
$LN6@CL_InitTit:

; 669  : 
; 670  : 	CL_TextMessageParse( pMemFile, fileSize );

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	call	_CL_TextMessageParse
	add	esp, 8

; 671  : 	Mem_Free( pMemFile );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitTitles@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pMemFile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@CL_InitTit:

; 672  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitTitles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawScreenFade
_TEXT	SEGMENT
tv141 = -84						; size = 4
tv140 = -80						; size = 4
_testFlags$ = -12					; size = 4
_iFadeAlpha$ = -8					; size = 4
_sf$ = -4						; size = 4
_CL_DrawScreenFade PROC					; COMDAT

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 600  : 	screenfade_t	*sf = &clgame.fade;

	mov	DWORD PTR _sf$[ebp], OFFSET _clgame+214928

; 601  : 	int		iFadeAlpha, testFlags;
; 602  : 
; 603  : 	// keep pushing reset time out indefinitely
; 604  : 	if( sf->fadeFlags & FFADE_STAYOUT )

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 4
	je	SHORT $LN2@CL_DrawScr

; 605  : 		sf->fadeReset = cl.time + 0.1f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _sf$[ebp]
	movss	DWORD PTR [eax+12], xmm0
$LN2@CL_DrawScr:

; 606  : 		
; 607  : 	if( sf->fadeReset == 0.0f && sf->fadeEnd == 0.0f )

	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CL_DrawScr

; 608  : 		return;	// inactive

	jmp	$LN1@CL_DrawScr
$LN3@CL_DrawScr:

; 609  : 
; 610  : 	// all done?
; 611  : 	if(( cl.time > sf->fadeReset ) && ( cl.time > sf->fadeEnd ))

	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+4]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@CL_DrawScr

; 612  : 	{
; 613  : 		memset( &clgame.fade, 0, sizeof( clgame.fade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _clgame+214928
	call	_memset
	add	esp, 12					; 0000000cH

; 614  : 		return;

	jmp	$LN1@CL_DrawScr
$LN4@CL_DrawScr:

; 615  : 	}
; 616  : 
; 617  : 	testFlags = (sf->fadeFlags & ~FFADE_MODULATE);

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, -3					; fffffffdH
	mov	DWORD PTR _testFlags$[ebp], ecx

; 618  : 
; 619  : 	// fading...
; 620  : 	if( testFlags == FFADE_STAYOUT )

	cmp	DWORD PTR _testFlags$[ebp], 4
	jne	SHORT $LN5@CL_DrawScr

; 621  : 	{
; 622  : 		iFadeAlpha = sf->fadealpha;

	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR _iFadeAlpha$[ebp], ecx

; 623  : 	}

	jmp	SHORT $LN6@CL_DrawScr
$LN5@CL_DrawScr:

; 624  : 	else
; 625  : 	{
; 626  : 		iFadeAlpha = sf->fadeSpeed * ( sf->fadeEnd - cl.time );

	mov	eax, DWORD PTR _sf$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _sf$[ebp]
	cvtss2sd xmm1, DWORD PTR [ecx+4]
	subsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iFadeAlpha$[ebp], edx

; 627  : 		if( sf->fadeFlags & FFADE_OUT ) iFadeAlpha += sf->fadealpha;

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 1
	je	SHORT $LN7@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	add	ecx, DWORD PTR _iFadeAlpha$[ebp]
	mov	DWORD PTR _iFadeAlpha$[ebp], ecx
$LN7@CL_DrawScr:

; 628  : 		iFadeAlpha = bound( 0, iFadeAlpha, sf->fadealpha );

	cmp	DWORD PTR _iFadeAlpha$[ebp], 0
	jl	SHORT $LN13@CL_DrawScr
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	cmp	DWORD PTR _iFadeAlpha$[ebp], ecx
	jge	SHORT $LN11@CL_DrawScr
	mov	edx, DWORD PTR _iFadeAlpha$[ebp]
	mov	DWORD PTR tv140[ebp], edx
	jmp	SHORT $LN12@CL_DrawScr
$LN11@CL_DrawScr:
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	mov	DWORD PTR tv140[ebp], ecx
$LN12@CL_DrawScr:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], edx
	jmp	SHORT $LN14@CL_DrawScr
$LN13@CL_DrawScr:
	mov	DWORD PTR tv141[ebp], 0
$LN14@CL_DrawScr:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _iFadeAlpha$[ebp], eax
$LN6@CL_DrawScr:

; 629  : 	}
; 630  : 
; 631  : 	pglColor4ub( sf->fader, sf->fadeg, sf->fadeb, iFadeAlpha );

	movzx	eax, BYTE PTR _iFadeAlpha$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sf$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	push	edx
	mov	eax, DWORD PTR _sf$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	mov	edx, DWORD PTR _sf$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	push	eax
	call	DWORD PTR _pglColor4ub

; 632  : 
; 633  : 	if( sf->fadeFlags & FFADE_MODULATE )

	mov	eax, DWORD PTR _sf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 2
	je	SHORT $LN8@CL_DrawScr

; 634  : 		GL_SetRenderMode( kRenderTransAdd );

	push	5
	call	_GL_SetRenderMode
	add	esp, 4
	jmp	SHORT $LN9@CL_DrawScr
$LN8@CL_DrawScr:

; 635  : 	else GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4
$LN9@CL_DrawScr:

; 636  : 	R_DrawStretchPic( 0, 0, glState.width, glState.height, 0, 0, 1, 1, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState+4
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _glState
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 637  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@CL_DrawScr:

; 638  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawScreenFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_DrawGenericScale
_TEXT	SEGMENT
_rc$1 = -48						; size = 16
_h$2 = -32						; size = 4
_w$3 = -28						; size = 4
_texnum$ = -24						; size = 4
_t2$ = -20						; size = 4
_t1$ = -16						; size = 4
_s2$ = -12						; size = 4
_s1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_prc$ = 28						; size = 4
_xscale$ = 32						; size = 4
_yscale$ = 36						; size = 4
_selfangle$ = 40					; size = 4
_angle$ = 44						; size = 4
_xpivot$ = 48						; size = 4
_ypivot$ = 52						; size = 4
_selfxpivot$ = 56					; size = 4
_selfypivot$ = 60					; size = 4
_SPR_DrawGenericScale PROC				; COMDAT

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 471  : 	float	s1, s2, t1, t2;
; 472  : 	int	texnum;
; 473  : 
; 474  : 	if (width == -1 && height == -1)

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe

; 475  : 	{
; 476  : 		int	w, h;
; 477  : 
; 478  : 		// assume we get sizes from image
; 479  : 		R_GetSpriteParms(&w, &h, NULL, frame, clgame.ds.pSprite);

	mov	eax, DWORD PTR _clgame+214844
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _h$2[ebp]
	push	edx
	lea	eax, DWORD PTR _w$3[ebp]
	push	eax
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 480  : 
; 481  : 		width = w;

	cvtsi2ss xmm0, DWORD PTR _w$3[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 482  : 		height = h;

	cvtsi2ss xmm0, DWORD PTR _h$2[ebp]
	movss	DWORD PTR _height$[ebp], xmm0
$LN2@SPR_DrawGe:

; 483  : 	}
; 484  : 
; 485  : 	if (prc)

	cmp	DWORD PTR _prc$[ebp], 0
	je	$LN3@SPR_DrawGe

; 486  : 	{
; 487  : 		wrect_t	rc;
; 488  : 
; 489  : 		rc = *prc;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _rc$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _rc$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rc$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _rc$1[ebp+12], edx

; 490  : 
; 491  : 		// Sigh! some stupid modmakers set wrong rectangles in hud.txt 
; 492  : 		if (rc.left <= 0 || rc.left >= width) rc.left = 0;

	cmp	DWORD PTR _rc$1[ebp], 0
	jle	SHORT $LN6@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jb	SHORT $LN5@SPR_DrawGe
$LN6@SPR_DrawGe:
	mov	DWORD PTR _rc$1[ebp], 0
$LN5@SPR_DrawGe:

; 493  : 		if (rc.top <= 0 || rc.top >= height) rc.top = 0;

	cmp	DWORD PTR _rc$1[ebp+8], 0
	jle	SHORT $LN8@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+8]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jb	SHORT $LN7@SPR_DrawGe
$LN8@SPR_DrawGe:
	mov	DWORD PTR _rc$1[ebp+8], 0
$LN7@SPR_DrawGe:

; 494  : 		if (rc.right <= 0 || rc.right > width) rc.right = width;

	cmp	DWORD PTR _rc$1[ebp+4], 0
	jle	SHORT $LN10@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+4]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jbe	SHORT $LN9@SPR_DrawGe
$LN10@SPR_DrawGe:
	cvttss2si eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _rc$1[ebp+4], eax
$LN9@SPR_DrawGe:

; 495  : 		if (rc.bottom <= 0 || rc.bottom > height) rc.bottom = height;

	cmp	DWORD PTR _rc$1[ebp+12], 0
	jle	SHORT $LN12@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+12]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jbe	SHORT $LN11@SPR_DrawGe
$LN12@SPR_DrawGe:
	cvttss2si eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rc$1[ebp+12], eax
$LN11@SPR_DrawGe:

; 496  : 
; 497  : 		// calc user-defined rectangle
; 498  : 		s1 = (float)rc.left / width;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 499  : 		t1 = (float)rc.top / height;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+8]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t1$[ebp], xmm0

; 500  : 		s2 = (float)rc.right / width;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+4]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0

; 501  : 		t2 = (float)rc.bottom / height;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+12]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t2$[ebp], xmm0

; 502  : 		width = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$1[ebp+4]
	sub	eax, DWORD PTR _rc$1[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _width$[ebp], xmm0

; 503  : 		height = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$1[ebp+12]
	sub	eax, DWORD PTR _rc$1[ebp+8]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _height$[ebp], xmm0

; 504  : 	}

	jmp	SHORT $LN4@SPR_DrawGe
$LN3@SPR_DrawGe:

; 505  : 	else
; 506  : 	{
; 507  : 		s1 = t1 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _t1$[ebp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 508  : 		s2 = t2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t2$[ebp], xmm0
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0
$LN4@SPR_DrawGe:

; 509  : 	}
; 510  : 
; 511  : 	// pass scissor test if supposed
; 512  : 	if (clgame.ds.scissor_test && !SPR_Scissor(&x, &y, &width, &height, &s1, &t1, &s2, &t2))

	cmp	DWORD PTR _clgame+214864, 0
	je	SHORT $LN13@SPR_DrawGe
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_SPR_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN13@SPR_DrawGe

; 513  : 		return;

	jmp	$LN1@SPR_DrawGe
$LN13@SPR_DrawGe:

; 514  : 
; 515  : 	// scale for screen sizes
; 516  : 	SPR_AdjustScale(&width, &height, xscale, yscale);

	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_SPR_AdjustScale
	add	esp, 16					; 00000010H

; 517  : 	SPR_AdjustSize(&x, &y, &width, &height);

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 518  : 	texnum = R_GetSpriteTexture(clgame.ds.pSprite, frame);

	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+214844
	push	ecx
	call	_R_GetSpriteTexture
	add	esp, 8
	mov	DWORD PTR _texnum$[ebp], eax

; 519  : 	pglColor4ubv(clgame.ds.spriteColor);

	push	OFFSET _clgame+214884
	call	DWORD PTR _pglColor4ubv

; 520  : 	pglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 521  : 	
; 522  : 	pglPushMatrix();

	call	DWORD PTR _pglPushMatrix

; 523  : 	pglPopMatrix();

	call	DWORD PTR _pglPopMatrix

; 524  : 	R_DrawStretchPicRotate(x, y, width, height, s1, t1, s2, t2, texnum, xscale, yscale, selfangle, angle, xpivot, ypivot, selfxpivot, selfypivot);

	push	ecx
	movss	xmm0, DWORD PTR _selfypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfxpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPicRotate
	add	esp, 68					; 00000044H
$LN1@SPR_DrawGe:

; 525  : ;
; 526  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_DrawGenericScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_DrawGeneric
_TEXT	SEGMENT
_rc$1 = -48						; size = 16
_h$2 = -32						; size = 4
_w$3 = -28						; size = 4
_texnum$ = -24						; size = 4
_t2$ = -20						; size = 4
_t1$ = -16						; size = 4
_s2$ = -12						; size = 4
_s1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_prc$ = 28						; size = 4
_SPR_DrawGeneric PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 410  : 	float	s1, s2, t1, t2;
; 411  : 	int	texnum;
; 412  : 
; 413  : 	if( width == -1 && height == -1 )

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_DrawGe

; 414  : 	{
; 415  : 		int	w, h;
; 416  : 
; 417  : 		// assume we get sizes from image
; 418  : 		R_GetSpriteParms( &w, &h, NULL, frame, clgame.ds.pSprite );

	mov	eax, DWORD PTR _clgame+214844
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _h$2[ebp]
	push	edx
	lea	eax, DWORD PTR _w$3[ebp]
	push	eax
	call	_R_GetSpriteParms
	add	esp, 20					; 00000014H

; 419  : 
; 420  : 		width = w;

	cvtsi2ss xmm0, DWORD PTR _w$3[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 421  : 		height = h;

	cvtsi2ss xmm0, DWORD PTR _h$2[ebp]
	movss	DWORD PTR _height$[ebp], xmm0
$LN2@SPR_DrawGe:

; 422  : 	}
; 423  : 
; 424  : 	if( prc )

	cmp	DWORD PTR _prc$[ebp], 0
	je	$LN3@SPR_DrawGe

; 425  : 	{
; 426  : 		wrect_t	rc;
; 427  : 
; 428  : 		rc = *prc;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _rc$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _rc$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rc$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _rc$1[ebp+12], edx

; 429  : 
; 430  : 		// Sigh! some stupid modmakers set wrong rectangles in hud.txt 
; 431  : 		if( rc.left <= 0 || rc.left >= width ) rc.left = 0;

	cmp	DWORD PTR _rc$1[ebp], 0
	jle	SHORT $LN6@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jb	SHORT $LN5@SPR_DrawGe
$LN6@SPR_DrawGe:
	mov	DWORD PTR _rc$1[ebp], 0
$LN5@SPR_DrawGe:

; 432  : 		if( rc.top <= 0 || rc.top >= height ) rc.top = 0;

	cmp	DWORD PTR _rc$1[ebp+8], 0
	jle	SHORT $LN8@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+8]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jb	SHORT $LN7@SPR_DrawGe
$LN8@SPR_DrawGe:
	mov	DWORD PTR _rc$1[ebp+8], 0
$LN7@SPR_DrawGe:

; 433  : 		if( rc.right <= 0 || rc.right > width ) rc.right = width;

	cmp	DWORD PTR _rc$1[ebp+4], 0
	jle	SHORT $LN10@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+4]
	comiss	xmm0, DWORD PTR _width$[ebp]
	jbe	SHORT $LN9@SPR_DrawGe
$LN10@SPR_DrawGe:
	cvttss2si eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _rc$1[ebp+4], eax
$LN9@SPR_DrawGe:

; 434  : 		if( rc.bottom <= 0 || rc.bottom > height ) rc.bottom = height;

	cmp	DWORD PTR _rc$1[ebp+12], 0
	jle	SHORT $LN12@SPR_DrawGe
	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+12]
	comiss	xmm0, DWORD PTR _height$[ebp]
	jbe	SHORT $LN11@SPR_DrawGe
$LN12@SPR_DrawGe:
	cvttss2si eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rc$1[ebp+12], eax
$LN11@SPR_DrawGe:

; 435  : 
; 436  : 		// calc user-defined rectangle
; 437  : 		s1 = (float)rc.left / width;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 438  : 		t1 = (float)rc.top / height;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+8]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t1$[ebp], xmm0

; 439  : 		s2 = (float)rc.right / width;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+4]
	divss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0

; 440  : 		t2 = (float)rc.bottom / height;

	cvtsi2ss xmm0, DWORD PTR _rc$1[ebp+12]
	divss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR _t2$[ebp], xmm0

; 441  : 		width = rc.right - rc.left;

	mov	eax, DWORD PTR _rc$1[ebp+4]
	sub	eax, DWORD PTR _rc$1[ebp]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _width$[ebp], xmm0

; 442  : 		height = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$1[ebp+12]
	sub	eax, DWORD PTR _rc$1[ebp+8]
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _height$[ebp], xmm0

; 443  : 	}

	jmp	SHORT $LN4@SPR_DrawGe
$LN3@SPR_DrawGe:

; 444  : 	else
; 445  : 	{
; 446  : 		s1 = t1 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _t1$[ebp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 447  : 		s2 = t2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t2$[ebp], xmm0
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0
$LN4@SPR_DrawGe:

; 448  : 	}
; 449  : 
; 450  : 	// pass scissor test if supposed
; 451  : 	if( clgame.ds.scissor_test && !SPR_Scissor( &x, &y, &width, &height, &s1, &t1, &s2, &t2 ))

	cmp	DWORD PTR _clgame+214864, 0
	je	SHORT $LN13@SPR_DrawGe
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_SPR_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN13@SPR_DrawGe

; 452  : 		return;

	jmp	$LN1@SPR_DrawGe
$LN13@SPR_DrawGe:

; 453  : 
; 454  : 	// scale for screen sizes
; 455  : 	SPR_AdjustSize( &x, &y, &width, &height );

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_SPR_AdjustSize
	add	esp, 16					; 00000010H

; 456  : 	texnum = R_GetSpriteTexture( clgame.ds.pSprite, frame );

	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+214844
	push	ecx
	call	_R_GetSpriteTexture
	add	esp, 8
	mov	DWORD PTR _texnum$[ebp], eax

; 457  : 	pglColor4ubv( clgame.ds.spriteColor );

	push	OFFSET _clgame+214884
	call	DWORD PTR _pglColor4ubv

; 458  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 459  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, texnum );

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H
$LN1@SPR_DrawGe:

; 460  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_DrawGeneric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_Scissor
_TEXT	SEGMENT
_dvdy$ = -8						; size = 4
_dudx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_u0$ = 24						; size = 4
_v0$ = 28						; size = 4
_u1$ = 32						; size = 4
_v1$ = 36						; size = 4
_SPR_Scissor PROC					; COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 354  : 	float	dudx, dvdy;
; 355  : 
; 356  : 	// clip sub rect to sprite
; 357  : 	if(( width == 0 ) || ( height == 0 ))

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN3@SPR_Scisso
	cmp	DWORD PTR _height$[ebp], 0
	jne	SHORT $LN2@SPR_Scisso
$LN3@SPR_Scisso:

; 358  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN2@SPR_Scisso:

; 359  : 
; 360  : 	if( *x + *width <= clgame.ds.scissor_x )

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _clgame+214848
	comiss	xmm1, xmm0
	jb	SHORT $LN4@SPR_Scisso

; 361  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN4@SPR_Scisso:

; 362  : 	if( *x >= clgame.ds.scissor_x + clgame.ds.scissor_width )

	mov	eax, DWORD PTR _clgame+214848
	add	eax, DWORD PTR _clgame+214856
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jb	SHORT $LN5@SPR_Scisso

; 363  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN5@SPR_Scisso:

; 364  : 	if( *y + *height <= clgame.ds.scissor_y )

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _clgame+214852
	comiss	xmm1, xmm0
	jb	SHORT $LN6@SPR_Scisso

; 365  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN6@SPR_Scisso:

; 366  : 	if( *y >= clgame.ds.scissor_y + clgame.ds.scissor_height )

	mov	eax, DWORD PTR _clgame+214852
	add	eax, DWORD PTR _clgame+214860
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jb	SHORT $LN7@SPR_Scisso

; 367  : 		return false;

	xor	eax, eax
	jmp	$LN1@SPR_Scisso
$LN7@SPR_Scisso:

; 368  : 
; 369  : 	dudx = (*u1 - *u0) / *width;

	mov	eax, DWORD PTR _u1$[ebp]
	mov	ecx, DWORD PTR _u0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _dudx$[ebp], xmm0

; 370  : 	dvdy = (*v1 - *v0) / *height;

	mov	eax, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _height$[ebp]
	divss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _dvdy$[ebp], xmm0

; 371  : 
; 372  : 	if( *x < clgame.ds.scissor_x )

	cvtsi2ss xmm0, DWORD PTR _clgame+214848
	mov	eax, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN8@SPR_Scisso

; 373  : 	{
; 374  : 		*u0 += (clgame.ds.scissor_x - *x) * dudx;

	cvtsi2ss xmm0, DWORD PTR _clgame+214848
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	ecx, DWORD PTR _u0$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _u0$[ebp]
	movss	DWORD PTR [edx], xmm0

; 375  : 		*width -= clgame.ds.scissor_x - *x;

	cvtsi2ss xmm0, DWORD PTR _clgame+214848
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm1

; 376  : 		*x = clgame.ds.scissor_x;

	cvtsi2ss xmm0, DWORD PTR _clgame+214848
	mov	eax, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN8@SPR_Scisso:

; 377  : 	}
; 378  : 
; 379  : 	if( *x + *width > clgame.ds.scissor_x + clgame.ds.scissor_width )

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clgame+214848
	add	edx, DWORD PTR _clgame+214856
	cvtsi2ss xmm1, edx
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@SPR_Scisso

; 380  : 	{
; 381  : 		*u1 -= (*x + *width - (clgame.ds.scissor_x + clgame.ds.scissor_width)) * dudx;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clgame+214848
	add	edx, DWORD PTR _clgame+214856
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	eax, DWORD PTR _u1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _u1$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 382  : 		*width = clgame.ds.scissor_x + clgame.ds.scissor_width - *x;

	mov	eax, DWORD PTR _clgame+214848
	add	eax, DWORD PTR _clgame+214856
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN9@SPR_Scisso:

; 383  : 	}
; 384  : 
; 385  : 	if( *y < clgame.ds.scissor_y )

	cvtsi2ss xmm0, DWORD PTR _clgame+214852
	mov	eax, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN10@SPR_Scisso

; 386  : 	{
; 387  : 		*v0 += (clgame.ds.scissor_y - *y) * dvdy;

	cvtsi2ss xmm0, DWORD PTR _clgame+214852
	mov	eax, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	ecx, DWORD PTR _v0$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _v0$[ebp]
	movss	DWORD PTR [edx], xmm0

; 388  : 		*height -= clgame.ds.scissor_y - *y;

	cvtsi2ss xmm0, DWORD PTR _clgame+214852
	mov	eax, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _height$[ebp]
	movss	DWORD PTR [edx], xmm1

; 389  : 		*y = clgame.ds.scissor_y;

	cvtsi2ss xmm0, DWORD PTR _clgame+214852
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN10@SPR_Scisso:

; 390  : 	}
; 391  : 
; 392  : 	if( *y + *height > clgame.ds.scissor_y + clgame.ds.scissor_height )

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clgame+214852
	add	edx, DWORD PTR _clgame+214860
	cvtsi2ss xmm1, edx
	comiss	xmm0, xmm1
	jbe	SHORT $LN11@SPR_Scisso

; 393  : 	{
; 394  : 		*v1 -= (*y + *height - (clgame.ds.scissor_y + clgame.ds.scissor_height)) * dvdy;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clgame+214852
	add	edx, DWORD PTR _clgame+214860
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	eax, DWORD PTR _v1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _v1$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 395  : 		*height = clgame.ds.scissor_y + clgame.ds.scissor_height - *y;

	mov	eax, DWORD PTR _clgame+214852
	add	eax, DWORD PTR _clgame+214860
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _height$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN11@SPR_Scisso:

; 396  : 	}
; 397  : 
; 398  : 	return true;

	mov	eax, 1
$LN1@SPR_Scisso:

; 399  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_Scissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_AdjustScale
_TEXT	SEGMENT
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_xscale$ = 16						; size = 4
_yscale$ = 20						; size = 4
_SPR_AdjustScale PROC					; COMDAT

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 314  : 	if (!xscale && !yscale && !w && !h) return;

	movss	xmm0, DWORD PTR _xscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_Adjust
	movss	xmm0, DWORD PTR _yscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	jmp	SHORT $LN4@SPR_Adjust
$LN2@SPR_Adjust:

; 315  : 
; 316  : 	if (w) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN3@SPR_Adjust
	mov	eax, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN3@SPR_Adjust:

; 317  : 	if (h) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN4@SPR_Adjust
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN4@SPR_Adjust:

; 318  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_AdjustScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _SPR_AdjustSize
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_SPR_AdjustSize PROC					; COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 291  : 	float	xscale, yscale;
; 292  : 
; 293  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@SPR_Adjust
	jmp	$LN6@SPR_Adjust
$LN2@SPR_Adjust:

; 294  : 
; 295  : 	// scale for screen sizes
; 296  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+217076
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 297  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+217080
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 298  : 
; 299  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN3@SPR_Adjust
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN3@SPR_Adjust:

; 300  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN4@SPR_Adjust
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN4@SPR_Adjust:

; 301  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN5@SPR_Adjust
	mov	eax, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN5@SPR_Adjust:

; 302  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN6@SPR_Adjust
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN6@SPR_Adjust:

; 303  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SPR_AdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_AdjustYPos
_TEXT	SEGMENT
_yPos$ = -4						; size = 4
_y$ = 8							; size = 4
_height$ = 12						; size = 4
_CL_AdjustYPos PROC					; COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 218  : 	int	yPos;
; 219  : 
; 220  : 	if( y == -1 ) // centered?

	movss	xmm0, DWORD PTR _y$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustY

; 221  : 	{
; 222  : 		yPos = ( glState.height - height ) * 0.5f;

	mov	eax, DWORD PTR _glState+4
	sub	eax, DWORD PTR _height$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _yPos$[ebp], ecx

; 223  : 	}

	jmp	SHORT $LN5@CL_AdjustY
$LN2@CL_AdjustY:

; 224  : 	else
; 225  : 	{
; 226  : 		// Alight bottom?
; 227  : 		if( y < 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _y$[ebp]
	jbe	SHORT $LN4@CL_AdjustY

; 228  : 			yPos = (1.0f + y) * glState.height - height; // Alight bottom

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState+4
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	subss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _yPos$[ebp], eax
	jmp	SHORT $LN5@CL_AdjustY
$LN4@CL_AdjustY:

; 229  : 		else // align top
; 230  : 			yPos = y * glState.height;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	mulss	xmm0, DWORD PTR _y$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _yPos$[ebp], eax
$LN5@CL_AdjustY:

; 231  : 	}
; 232  : 
; 233  : 	if( yPos + height > glState.height )

	mov	eax, DWORD PTR _yPos$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _glState+4
	jle	SHORT $LN6@CL_AdjustY

; 234  : 		yPos = glState.height - height;

	mov	eax, DWORD PTR _glState+4
	sub	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _yPos$[ebp], eax
	jmp	SHORT $LN8@CL_AdjustY
$LN6@CL_AdjustY:

; 235  : 	else if( yPos < 0 )

	cmp	DWORD PTR _yPos$[ebp], 0
	jge	SHORT $LN8@CL_AdjustY

; 236  : 		yPos = 0;

	mov	DWORD PTR _yPos$[ebp], 0
$LN8@CL_AdjustY:

; 237  : 
; 238  : 	return yPos;

	mov	eax, DWORD PTR _yPos$[ebp]

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustYPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_AdjustXPos
_TEXT	SEGMENT
_xPos$ = -4						; size = 4
_x$ = 8							; size = 4
_width$ = 12						; size = 4
_totalWidth$ = 16					; size = 4
_CL_AdjustXPos PROC					; COMDAT

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 187  : 	int	xPos;
; 188  : 
; 189  : 	if( x == -1 )

	movss	xmm0, DWORD PTR _x$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_AdjustX

; 190  : 	{
; 191  : 		xPos = ( glState.width - width ) * 0.5f;

	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _width$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _xPos$[ebp], ecx

; 192  : 	}

	jmp	SHORT $LN5@CL_AdjustX
$LN2@CL_AdjustX:

; 193  : 	else
; 194  : 	{
; 195  : 		if ( x < 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _x$[ebp]
	jbe	SHORT $LN4@CL_AdjustX

; 196  : 			xPos = (1.0f + x) * glState.width - totalWidth;	// Alight right

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, DWORD PTR _glState
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _totalWidth$[ebp]
	subss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _xPos$[ebp], eax
	jmp	SHORT $LN5@CL_AdjustX
$LN4@CL_AdjustX:

; 197  : 		else // align left
; 198  : 			xPos = x * glState.width;

	cvtsi2ss xmm0, DWORD PTR _glState
	mulss	xmm0, DWORD PTR _x$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _xPos$[ebp], eax
$LN5@CL_AdjustX:

; 199  : 	}
; 200  : 
; 201  : 	if( xPos + width > glState.width )

	mov	eax, DWORD PTR _xPos$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _glState
	jle	SHORT $LN6@CL_AdjustX

; 202  : 		xPos = glState.width - width;

	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _xPos$[ebp], eax
	jmp	SHORT $LN8@CL_AdjustX
$LN6@CL_AdjustX:

; 203  : 	else if( xPos < 0 )

	cmp	DWORD PTR _xPos$[ebp], 0
	jge	SHORT $LN8@CL_AdjustX

; 204  : 		xPos = 0;

	mov	DWORD PTR _xPos$[ebp], 0
$LN8@CL_AdjustX:

; 205  : 
; 206  : 	return xPos;

	mov	eax, DWORD PTR _xPos$[ebp]

; 207  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AdjustXPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_DrawHoles
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_prc$ = 20						; size = 4
_pfnSPR_DrawHoles PROC					; COMDAT

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1516 : 	pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 1517 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1518 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1519 : 
; 1520 : 	SPR_DrawGeneric( frame, x, y, -1, -1, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_SPR_DrawGeneric
	add	esp, 24					; 00000018H

; 1521 : 
; 1522 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1523 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1524 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_DrawHoles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriEnd
_TEXT	SEGMENT
_TriEnd	PROC						; COMDAT

; 3262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3263 : 	pglEnd();

	call	DWORD PTR _pglEnd

; 3264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriEnd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriCullFace
_TEXT	SEGMENT
tv64 = -68						; size = 4
_mode$ = 8						; size = 4
_TriCullFace PROC					; COMDAT

; 3357 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3358 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN4@TriCullFac
	jmp	SHORT $LN5@TriCullFac
$LN4@TriCullFac:

; 3359 : 	{
; 3360 : 	case TRI_FRONT:
; 3361 : 		clgame.ds.cullMode = GL_FRONT;

	mov	DWORD PTR _clgame+214876, 1028		; 00000404H

; 3362 : 		break;

	jmp	SHORT $LN2@TriCullFac
$LN5@TriCullFac:

; 3363 : 	default:
; 3364 : 		clgame.ds.cullMode = GL_NONE;

	mov	DWORD PTR _clgame+214876, 0
$LN2@TriCullFac:

; 3365 : 		break;
; 3366 : 	}
; 3367 : 
; 3368 : 	GL_Cull( clgame.ds.cullMode );

	mov	eax, DWORD PTR _clgame+214876
	push	eax
	call	_GL_Cull
	add	esp, 4

; 3369 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriCullFace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriRenderMode
_TEXT	SEGMENT
tv64 = -68						; size = 4
_mode$ = 8						; size = 4
_TriRenderMode PROC					; COMDAT

; 3184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3185 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	$LN2@TriRenderM
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN11@TriRenderM[ecx*4]
$LN4@TriRenderM:

; 3186 : 	{
; 3187 : 	case kRenderNormal:
; 3188 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 3189 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 3190 : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 3191 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN5@TriRenderM:

; 3192 : 	case kRenderTransAlpha:
; 3193 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3194 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 3195 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3196 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 3197 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN7@TriRenderM:

; 3198 : 	case kRenderTransColor:
; 3199 : 	case kRenderTransTexture:
; 3200 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3201 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3202 : 		break;

	jmp	SHORT $LN2@TriRenderM
$LN9@TriRenderM:

; 3203 : 	case kRenderGlow:
; 3204 : 	case kRenderTransAdd:
; 3205 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3206 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3207 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask
$LN2@TriRenderM:

; 3208 : 		break;
; 3209 : 	}
; 3210 : 
; 3211 : 	clgame.ds.renderMode = mode;

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR _clgame+214872, eax

; 3212 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@TriRenderM:
	DD	$LN4@TriRenderM
	DD	$LN7@TriRenderM
	DD	$LN7@TriRenderM
	DD	$LN9@TriRenderM
	DD	$LN5@TriRenderM
	DD	$LN9@TriRenderM
_TriRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriBrightness
_TEXT	SEGMENT
_b$ = -12						; size = 4
_g$ = -8						; size = 4
_r$ = -4						; size = 4
_brightness$ = 8					; size = 4
_TriBrightness PROC					; COMDAT

; 3340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3341 : 	float	r, g, b;
; 3342 : 
; 3343 : 	r = clgame.ds.triRGBA[0] * clgame.ds.triRGBA[3] * brightness;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _clgame[ecx+214888]
	mulss	xmm0, DWORD PTR _clgame[eax+214888]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _r$[ebp], xmm0

; 3344 : 	g = clgame.ds.triRGBA[1] * clgame.ds.triRGBA[3] * brightness;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR _clgame[eax+214888]
	mulss	xmm0, DWORD PTR _clgame[edx+214888]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _g$[ebp], xmm0

; 3345 : 	b = clgame.ds.triRGBA[2] * clgame.ds.triRGBA[3] * brightness;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR _clgame[eax+214888]
	mulss	xmm0, DWORD PTR _clgame[edx+214888]
	mulss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0

; 3346 : 
; 3347 : 	pglColor4f( r, g, b, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3348 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriBrightness ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriColor4ub
_TEXT	SEGMENT
_r$ = 8							; size = 1
_g$ = 12						; size = 1
_b$ = 16						; size = 1
_a$ = 20						; size = 1
_TriColor4ub PROC					; COMDAT

; 3291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3292 : 	clgame.ds.triRGBA[0] = r * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _r$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _clgame[edx+214888], xmm0

; 3293 : 	clgame.ds.triRGBA[1] = g * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _g$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _clgame[ecx+214888], xmm0

; 3294 : 	clgame.ds.triRGBA[2] = b * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _b$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _clgame[ecx+214888], xmm0

; 3295 : 	clgame.ds.triRGBA[3] = a * (1.0f / 255.0f);

	movzx	eax, BYTE PTR _a$[ebp]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR _clgame[edx+214888], xmm0

; 3296 : 
; 3297 : 	pglColor4f( clgame.ds.triRGBA[0], clgame.ds.triRGBA[1], clgame.ds.triRGBA[2], 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _clgame[eax+214888]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _clgame[ecx+214888]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _clgame[eax+214888]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3298 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriColor4ub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriWorldToScreen
_TEXT	SEGMENT
_retval$ = -4						; size = 4
_world$ = 8						; size = 4
_screen$ = 12						; size = 4
_TriWorldToScreen PROC					; COMDAT

; 3401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3402 : 	int	retval;
; 3403 : 
; 3404 : 	retval = R_WorldToScreen( world, screen );

	mov	eax, DWORD PTR _screen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _world$[ebp]
	push	ecx
	call	_R_WorldToScreen
	add	esp, 8
	mov	DWORD PTR _retval$[ebp], eax

; 3405 : 
; 3406 : 	screen[0] =  0.5f * screen[0] * (float)clgame.viewport[2];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 1
	cvtsi2ss xmm1, DWORD PTR _clgame[eax+214828]
	mulss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3407 : 	screen[1] = -0.5f * screen[1] * (float)clgame.viewport[3];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _screen$[ebp]
	movss	xmm0, DWORD PTR __real@bf000000
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	imul	eax, edx, 3
	cvtsi2ss xmm1, DWORD PTR _clgame[eax+214828]
	mulss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 3408 : 	screen[0] += 0.5f * (float)clgame.viewport[2];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	cvtsi2ss xmm0, DWORD PTR _clgame[edx+214828]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _screen$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3409 : 	screen[1] += 0.5f * (float)clgame.viewport[3];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 3
	cvtsi2ss xmm0, DWORD PTR _clgame[edx+214828]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR _screen$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _screen$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 3410 : 
; 3411 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 3412 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriWorldToScreen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriColor4fRendermode
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_rendermode$ = 24					; size = 4
_TriColor4fRendermode PROC				; COMDAT

; 3508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3509 : 	if( clgame.ds.renderMode == kRenderTransAlpha )

	cmp	DWORD PTR _clgame+214872, 4
	jne	SHORT $LN2@TriColor4f

; 3510 : 	{
; 3511 : 		clgame.ds.triRGBA[3] = a / 255.0f;

	movss	xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR _clgame[ecx+214888], xmm0

; 3512 : 		pglColor4f( r, g, b, a );

	push	ecx
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3513 : 	}

	jmp	SHORT $LN3@TriColor4f
$LN2@TriColor4f:

; 3514 : 	else pglColor4f( r * a, g * a, b * a, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN3@TriColor4f:

; 3515 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriColor4fRendermode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriSpriteTexture
_TEXT	SEGMENT
_gl_texturenum$ = -4					; size = 4
_pSpriteModel$ = 8					; size = 4
_frame$ = 12						; size = 4
_TriSpriteTexture PROC					; COMDAT

; 3379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3380 : 	int	gl_texturenum;
; 3381 : 
; 3382 : 	if(( gl_texturenum = R_GetSpriteTexture( pSpriteModel, frame )) == 0 )

	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSpriteModel$[ebp]
	push	ecx
	call	_R_GetSpriteTexture
	add	esp, 8
	mov	DWORD PTR _gl_texturenum$[ebp], eax
	cmp	DWORD PTR _gl_texturenum$[ebp], 0
	jne	SHORT $LN2@TriSpriteT

; 3383 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@TriSpriteT
$LN2@TriSpriteT:

; 3384 : 
; 3385 : 	if( gl_texturenum <= 0 || gl_texturenum > MAX_TEXTURES )

	cmp	DWORD PTR _gl_texturenum$[ebp], 0
	jle	SHORT $LN4@TriSpriteT
	cmp	DWORD PTR _gl_texturenum$[ebp], 4096	; 00001000H
	jle	SHORT $LN3@TriSpriteT
$LN4@TriSpriteT:

; 3386 : 		gl_texturenum = tr.defaultTexture;

	mov	eax, DWORD PTR _tr
	mov	DWORD PTR _gl_texturenum$[ebp], eax
$LN3@TriSpriteT:

; 3387 : 
; 3388 : 	GL_Bind( GL_TEXTURE0, gl_texturenum );

	mov	eax, DWORD PTR _gl_texturenum$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 3389 : 
; 3390 : 	return 1;

	mov	eax, 1
$LN1@TriSpriteT:

; 3391 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriSpriteTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriColor4f
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_TriColor4f PROC					; COMDAT

; 3273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3274 : 	if( clgame.ds.renderMode == kRenderTransAlpha )

	cmp	DWORD PTR _clgame+214872, 4
	jne	SHORT $LN2@TriColor4f

; 3275 : 		pglColor4ub( r * 255.9f, g * 255.9f, b * 255.9f, a * 255.0f );

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	movzx	ecx, al
	push	ecx
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si edx, xmm0
	movzx	eax, dl
	push	eax
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si ecx, xmm0
	movzx	edx, cl
	push	edx
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437fe666
	cvttss2si eax, xmm0
	movzx	ecx, al
	push	ecx
	call	DWORD PTR _pglColor4ub
	jmp	SHORT $LN3@TriColor4f
$LN2@TriColor4f:

; 3276 : 	else pglColor4f( r * a, g * a, b * a, 1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR _a$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN3@TriColor4f:

; 3277 : 
; 3278 : 	clgame.ds.triRGBA[0] = r;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _clgame[ecx+214888], xmm0

; 3279 : 	clgame.ds.triRGBA[1] = g;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR _clgame[eax+214888], xmm0

; 3280 : 	clgame.ds.triRGBA[2] = b;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR _clgame[eax+214888], xmm0

; 3281 : 	clgame.ds.triRGBA[3] = a;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR _clgame[ecx+214888], xmm0

; 3282 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriColor4f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriBoxInPVS
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_TriBoxInPVS PROC					; COMDAT

; 3476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3477 : 	return Mod_BoxVisible( mins, maxs, Mod_GetCurrentVis( ));

	call	_Mod_GetCurrentVis
	push	eax
	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH

; 3478 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriBoxInPVS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriVertex3f
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_TriVertex3f PROC					; COMDAT

; 3329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3330 : 	pglVertex3f( x, y, z );

	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex3f

; 3331 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriVertex3f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriVertex3fv
_TEXT	SEGMENT
_v$ = 8							; size = 4
_TriVertex3fv PROC					; COMDAT

; 3318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3319 : 	pglVertex3fv( v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 3320 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriVertex3fv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriTexCoord2f
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_TriTexCoord2f PROC					; COMDAT

; 3307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3308 : 	pglTexCoord2f( u, v );

	push	ecx
	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 3309 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TriTexCoord2f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _TriBegin
_TEXT	SEGMENT
tv64 = -68						; size = 4
_mode$ = 8						; size = 4
_TriBegin PROC						; COMDAT

; 3222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3223 : 	switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 7
	ja	SHORT $LN12@TriBegin
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@TriBegin[ecx*4]
$LN4@TriBegin:

; 3224 : 	{
; 3225 : 	case TRI_POINTS:
; 3226 : 		mode = GL_POINTS;

	mov	DWORD PTR _mode$[ebp], 0

; 3227 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN5@TriBegin:

; 3228 : 	case TRI_TRIANGLES:
; 3229 : 		mode = GL_TRIANGLES;

	mov	DWORD PTR _mode$[ebp], 4

; 3230 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN6@TriBegin:

; 3231 : 	case TRI_TRIANGLE_FAN:
; 3232 : 		mode = GL_TRIANGLE_FAN;

	mov	DWORD PTR _mode$[ebp], 6

; 3233 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN7@TriBegin:

; 3234 : 	case TRI_QUADS:
; 3235 : 		mode = GL_QUADS;

	mov	DWORD PTR _mode$[ebp], 7

; 3236 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN8@TriBegin:

; 3237 : 	case TRI_LINES:
; 3238 : 		mode = GL_LINES;

	mov	DWORD PTR _mode$[ebp], 1

; 3239 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN9@TriBegin:

; 3240 : 	case TRI_TRIANGLE_STRIP:
; 3241 : 		mode = GL_TRIANGLE_STRIP;

	mov	DWORD PTR _mode$[ebp], 5

; 3242 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN10@TriBegin:

; 3243 : 	case TRI_QUAD_STRIP:
; 3244 : 		mode = GL_QUAD_STRIP;

	mov	DWORD PTR _mode$[ebp], 8

; 3245 : 		break;

	jmp	SHORT $LN2@TriBegin
$LN12@TriBegin:

; 3246 : 	case TRI_POLYGON:
; 3247 : 	default:	mode = GL_POLYGON;

	mov	DWORD PTR _mode$[ebp], 9
$LN2@TriBegin:

; 3248 : 		break;
; 3249 : 	}
; 3250 : 
; 3251 : 	pglBegin( mode );

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	call	DWORD PTR _pglBegin

; 3252 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@TriBegin:
	DD	$LN5@TriBegin
	DD	$LN6@TriBegin
	DD	$LN7@TriBegin
	DD	$LN12@TriBegin
	DD	$LN8@TriBegin
	DD	$LN9@TriBegin
	DD	$LN10@TriBegin
	DD	$LN4@TriBegin
_TriBegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_AddEntity
_TEXT	SEGMENT
_entityType$ = 8					; size = 4
_pEnt$ = 12						; size = 4
_CL_AddEntity PROC					; COMDAT

; 2853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2854 : 	if( !pEnt ) return false;

	cmp	DWORD PTR _pEnt$[ebp], 0
	jne	SHORT $LN2@CL_AddEnti
	xor	eax, eax
	jmp	SHORT $LN1@CL_AddEnti
$LN2@CL_AddEnti:

; 2855 : 
; 2856 : 	// clear effects for all temp entities
; 2857 : 	if( !pEnt->index ) pEnt->curstate.effects = 0;

	mov	eax, DWORD PTR _pEnt$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@CL_AddEnti
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR [eax+972], 0
$LN3@CL_AddEnti:

; 2858 : 
; 2859 : 	// let the render reject entity without model
; 2860 : 	return CL_AddVisibleEntity( pEnt, entityType );

	mov	eax, DWORD PTR _entityType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	push	ecx
	call	_CL_AddVisibleEntity
	add	esp, 8
$LN1@CL_AddEnti:

; 2861 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 876  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jge	SHORT $LN2@CL_EDICT_N

; 877  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 878  : 
; 879  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 880  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetCrosshairPosY
_TEXT	SEGMENT
tv159 = -124						; size = 4
tv134 = -124						; size = 4
_screen$1 = -56						; size = 12
_point$2 = -44						; size = 12
_forward$3 = -32					; size = 12
_angles$4 = -20						; size = 12
_y$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_GetCrosshairPosY PROC				; COMDAT

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 966  : 	// any camera on or client is died
; 967  : 	if (cl.local.health <= 0 || cl.viewentity != (cl.playernum + 1))

	cmp	DWORD PTR _cl+2212656, 0
	jle	SHORT $LN3@CL_GetCros
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	je	SHORT $LN2@CL_GetCros
$LN3@CL_GetCros:

; 968  : 		return;

	jmp	$LN1@CL_GetCros
$LN2@CL_GetCros:

; 969  : 
; 970  : 	int y = clgame.viewport[1] + (clgame.viewport[3] >> 1);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _clgame[edx+214828]
	sar	ecx, 1
	add	ecx, DWORD PTR _clgame[eax+214828]
	mov	DWORD PTR _y$[ebp], ecx

; 971  : 
; 972  : 	// g-cont - cl.crosshairangle is the autoaim angle.
; 973  : 	// if we're not using autoaim, just draw in the middle of the screen
; 974  : 	if (!VectorIsNull(cl.crosshairangle))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _cl[ecx+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_GetCros
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_GetCros
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_GetCros
$LN5@CL_GetCros:

; 975  : 	{
; 976  : 		vec3_t	angles;
; 977  : 		vec3_t	forward;
; 978  : 		vec3_t	point, screen;
; 979  : 
; 980  : 		VectorAdd(RI.viewangles, cl.crosshairangle, angles);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	addss	xmm0, DWORD PTR _cl[eax+2212824]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _angles$4[ebp+edx], xmm0

; 981  : 		AngleVectors(angles, forward, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _forward$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles$4[ebp]
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 982  : 		VectorAdd(RI.vieworg, forward, point);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	movss	DWORD PTR tv159[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR _point$2[ebp+edx], xmm0

; 983  : 		R_WorldToScreen(point, screen);

	lea	eax, DWORD PTR _screen$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _point$2[ebp]
	push	ecx
	call	_R_WorldToScreen
	add	esp, 8

; 984  : 
; 985  : 		y += (clgame.viewport[3] >> 1) * screen[1] + 0.5f;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _clgame[ecx+214828]
	sar	edx, 1
	cvtsi2ss xmm0, edx
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+eax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _y$[ebp], ecx
$LN4@CL_GetCros:

; 986  : 	}
; 987  : 
; 988  : 	return y;

	mov	eax, DWORD PTR _y$[ebp]
$LN1@CL_GetCros:

; 989  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetCrosshairPosY ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetCrosshairPosX
_TEXT	SEGMENT
tv159 = -124						; size = 4
tv134 = -124						; size = 4
_screen$1 = -56						; size = 12
_point$2 = -44						; size = 12
_forward$3 = -32					; size = 12
_angles$4 = -20						; size = 12
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_GetCrosshairPosX PROC				; COMDAT

; 938  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 939  : 	// any camera on or client is died
; 940  : 	if (cl.local.health <= 0 || cl.viewentity != (cl.playernum + 1))

	cmp	DWORD PTR _cl+2212656, 0
	jle	SHORT $LN3@CL_GetCros
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	je	SHORT $LN2@CL_GetCros
$LN3@CL_GetCros:

; 941  : 		return;

	jmp	$LN1@CL_GetCros
$LN2@CL_GetCros:

; 942  : 
; 943  : 	int x = clgame.viewport[0] + (clgame.viewport[2] >> 1);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _clgame[edx+214828]
	sar	eax, 1
	add	eax, DWORD PTR _clgame[ecx+214828]
	mov	DWORD PTR _x$[ebp], eax

; 944  : 
; 945  : 	// g-cont - cl.crosshairangle is the autoaim angle.
; 946  : 	// if we're not using autoaim, just draw in the middle of the screen
; 947  : 	if (!VectorIsNull(cl.crosshairangle))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _cl[ecx+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_GetCros
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_GetCros
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _cl[eax+2212824]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_GetCros
$LN5@CL_GetCros:

; 948  : 	{
; 949  : 		vec3_t	angles;
; 950  : 		vec3_t	forward;
; 951  : 		vec3_t	point, screen;
; 952  : 
; 953  : 		VectorAdd(RI.viewangles, cl.crosshairangle, angles);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+212]
	addss	xmm0, DWORD PTR _cl[eax+2212824]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _angles$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+212]
	addss	xmm0, DWORD PTR _cl[ecx+2212824]
	movss	DWORD PTR tv134[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _angles$4[ebp+edx], xmm0

; 954  : 		AngleVectors(angles, forward, NULL, NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _forward$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles$4[ebp]
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 955  : 		VectorAdd(RI.vieworg, forward, point);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _RI[eax+200]
	addss	xmm0, DWORD PTR _forward$3[ebp+ecx]
	movss	DWORD PTR tv159[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR _point$2[ebp+edx], xmm0

; 956  : 		R_WorldToScreen(point, screen);

	lea	eax, DWORD PTR _screen$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _point$2[ebp]
	push	ecx
	call	_R_WorldToScreen
	add	esp, 8

; 957  : 
; 958  : 		x += (clgame.viewport[2] >> 1) * screen[0] + 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _clgame[eax+214828]
	sar	ecx, 1
	cvtsi2ss xmm0, ecx
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm0, DWORD PTR _screen$1[ebp+eax]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	addss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _x$[ebp], ecx
$LN4@CL_GetCros:

; 959  : 	}
; 960  : 
; 961  : 	return x;

	mov	eax, DWORD PTR _x$[ebp]
$LN1@CL_GetCros:

; 962  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetCrosshairPosX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_SetTraceHull
_TEXT	SEGMENT
tv68 = -72						; size = 4
tv67 = -68						; size = 4
_hull$ = 8						; size = 4
_CL_SetTraceHull PROC					; COMDAT

; 2747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2748 : 	clgame.pmove->usehull = bound( 0, hull, 3 );

	cmp	DWORD PTR _hull$[ebp], 0
	jl	SHORT $LN5@CL_SetTrac
	cmp	DWORD PTR _hull$[ebp], 3
	jge	SHORT $LN3@CL_SetTrac
	mov	eax, DWORD PTR _hull$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@CL_SetTrac
$LN3@CL_SetTrac:
	mov	DWORD PTR tv67[ebp], 3
$LN4@CL_SetTrac:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN6@CL_SetTrac
$LN5@CL_SetTrac:
	mov	DWORD PTR tv68[ebp], 0
$LN6@CL_SetTrac:
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR [edx+188], eax

; 2749 : 
; 2750 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetTraceHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_PlayerTraceExt
_TEXT	SEGMENT
$T1 = -132						; size = 68
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_traceFlags$ = 16					; size = 4
_pfnIgnore$ = 20					; size = 4
_tr$ = 24						; size = 4
_CL_PlayerTraceExt PROC					; COMDAT

; 2771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 2772 : 	if( !tr ) return;

	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN2@CL_PlayerT
	jmp	SHORT $LN1@CL_PlayerT
$LN2@CL_PlayerT:

; 2773 : 	*tr = PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, -1, pfnIgnore );

	mov	eax, DWORD PTR _pfnIgnore$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR _tr$[ebp]
	rep movsd
$LN1@CL_PlayerT:

; 2774 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTraceExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_PlayerTrace
_TEXT	SEGMENT
$T1 = -132						; size = 68
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_traceFlags$ = 16					; size = 4
_ignore_pe$ = 20					; size = 4
_tr$ = 24						; size = 4
_CL_PlayerTrace PROC					; COMDAT

; 2759 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi

; 2760 : 	if( !tr ) return;

	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN2@CL_PlayerT
	jmp	SHORT $LN1@CL_PlayerT
$LN2@CL_PlayerT:

; 2761 : 	*tr = PM_PlayerTraceExt( clgame.pmove, start, end, traceFlags, clgame.pmove->numphysent, clgame.pmove->physents, ignore_pe, NULL );

	push	0
	mov	eax, DWORD PTR _ignore_pe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+588]
	push	eax
	mov	ecx, DWORD PTR _traceFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _clgame+1344
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	mov	edi, DWORD PTR _tr$[ebp]
	rep movsd
$LN1@CL_PlayerT:

; 2762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FillRGBACircle
_TEXT	SEGMENT
tv431 = -144						; size = 8
tv449 = -136						; size = 8
tv447 = -128						; size = 8
tv425 = -120						; size = 8
tv445 = -112						; size = 8
tv443 = -104						; size = 8
tv214 = -104						; size = 4
tv149 = -104						; size = 4
tv81 = -104						; size = 4
tv77 = -104						; size = 4
tv73 = -104						; size = 4
tv69 = -104						; size = 4
tv217 = -100						; size = 4
tv213 = -100						; size = 4
tv147 = -100						; size = 4
tv80 = -100						; size = 4
tv76 = -100						; size = 4
tv72 = -100						; size = 4
tv68 = -100						; size = 4
_i_drawcenter$ = -32					; size = 4
_i_gldrawstyle$ = -28					; size = 4
_adjusted_numshapes$ = -24				; size = 4
_adjusted_twicepi$ = -20				; size = 4
_draw_ratio$ = -16					; size = 4
_total_draw$ = -12					; size = 4
_twicePi$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_numshapes$ = 24					; size = 4
_type$ = 28						; size = 4
_thickness$ = 32					; size = 4
_angle_start$ = 36					; size = 4
_angle_end$ = 40					; size = 4
_r$ = 44						; size = 4
_g$ = 48						; size = 4
_b$ = 52						; size = 4
_a$ = 56						; size = 4
_xscale$ = 60						; size = 4
_yscale$ = 64						; size = 4
_selfangle$ = 68					; size = 4
_angle$ = 72						; size = 4
_xpivot$ = 76						; size = 4
_ypivot$ = 80						; size = 4
_CL_FillRGBACircle PROC					; COMDAT

; 1746 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 1747 : 	// Sanity check, do not draw if we do not recognize circle shape
; 1748 : 	if (type < 0 || type > 4)

	cmp	DWORD PTR _type$[ebp], 0
	jl	SHORT $LN6@CL_FillRGB
	cmp	DWORD PTR _type$[ebp], 4
	jle	SHORT $LN5@CL_FillRGB
$LN6@CL_FillRGB:

; 1749 : 		return;

	jmp	$LN1@CL_FillRGB
$LN5@CL_FillRGB:

; 1750 : 
; 1751 : 	r = bound(0, r, 255);

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN14@CL_FillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN12@CL_FillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN13@CL_FillRGB
$LN12@CL_FillRGB:
	mov	DWORD PTR tv68[ebp], 255		; 000000ffH
$LN13@CL_FillRGB:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN15@CL_FillRGB
$LN14@CL_FillRGB:
	mov	DWORD PTR tv69[ebp], 0
$LN15@CL_FillRGB:
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 1752 : 	g = bound(0, g, 255);

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN18@CL_FillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN16@CL_FillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN17@CL_FillRGB
$LN16@CL_FillRGB:
	mov	DWORD PTR tv72[ebp], 255		; 000000ffH
$LN17@CL_FillRGB:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN19@CL_FillRGB
$LN18@CL_FillRGB:
	mov	DWORD PTR tv73[ebp], 0
$LN19@CL_FillRGB:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 1753 : 	b = bound(0, b, 255);

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN22@CL_FillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN20@CL_FillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN21@CL_FillRGB
$LN20@CL_FillRGB:
	mov	DWORD PTR tv76[ebp], 255		; 000000ffH
$LN21@CL_FillRGB:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN23@CL_FillRGB
$LN22@CL_FillRGB:
	mov	DWORD PTR tv77[ebp], 0
$LN23@CL_FillRGB:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 1754 : 	a = bound(0, a, 255);

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN26@CL_FillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN24@CL_FillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN25@CL_FillRGB
$LN24@CL_FillRGB:
	mov	DWORD PTR tv80[ebp], 255		; 000000ffH
$LN25@CL_FillRGB:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	jmp	SHORT $LN27@CL_FillRGB
$LN26@CL_FillRGB:
	mov	DWORD PTR tv81[ebp], 0
$LN27@CL_FillRGB:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 1755 : 
; 1756 : 	//SPR_AdjustSize((float*)&x, (float*)&y, (float*)&radius, (float*)&radius);
; 1757 : 
; 1758 : 	pglDisable(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1759 : 	pglEnable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1760 : 	pglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1761 : 	pglBlendFunc(GL_SRC_ALPHA, GL_ONE);

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1762 : 	pglColor4f(r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f);

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _g$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1763 : 
; 1764 : 	// Prepare vars
; 1765 : 	if (!xscale) xscale = 1.0;

	movss	xmm0, DWORD PTR _xscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_FillRGB
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _xscale$[ebp], xmm0
$LN7@CL_FillRGB:

; 1766 : 	if (!yscale) yscale = 1.0;

	movss	xmm0, DWORD PTR _yscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_FillRGB
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _yscale$[ebp], xmm0
$LN8@CL_FillRGB:

; 1767 : 
; 1768 : 	// Initialize increment and pi
; 1769 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1770 : 	float twicePi = 2.0f * M_PI;

	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _twicePi$[ebp], xmm0

; 1771 : 
; 1772 : 	// To ensure scaling works properly
; 1773 : 	x *= (1.0f / xscale);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _xscale$[ebp]
	cvtsi2ss xmm1, DWORD PTR _x$[ebp]
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _x$[ebp], eax

; 1774 : 	y *= (1.0f / yscale);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _yscale$[ebp]
	cvtsi2ss xmm1, DWORD PTR _y$[ebp]
	mulss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _y$[ebp], eax

; 1775 : 
; 1776 : 	// Adjustements happen here
; 1777 : 	float total_draw = fabs(max(angle_start, angle_end) - min(angle_start, angle_end));

	movss	xmm0, DWORD PTR _angle_start$[ebp]
	comiss	xmm0, DWORD PTR _angle_end$[ebp]
	jbe	SHORT $LN28@CL_FillRGB
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN29@CL_FillRGB
$LN28@CL_FillRGB:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	movss	DWORD PTR tv147[ebp], xmm0
$LN29@CL_FillRGB:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	comiss	xmm0, DWORD PTR _angle_start$[ebp]
	jbe	SHORT $LN30@CL_FillRGB
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN31@CL_FillRGB
$LN30@CL_FillRGB:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	movss	DWORD PTR tv149[ebp], xmm0
$LN31@CL_FillRGB:
	movss	xmm0, DWORD PTR tv147[ebp]
	subss	xmm0, DWORD PTR tv149[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _total_draw$[ebp]

; 1778 : 	float draw_ratio = total_draw / 360.0f;

	movss	xmm0, DWORD PTR _total_draw$[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _draw_ratio$[ebp], xmm0

; 1779 : 	float adjusted_twicepi = twicePi * draw_ratio;

	movss	xmm0, DWORD PTR _twicePi$[ebp]
	mulss	xmm0, DWORD PTR _draw_ratio$[ebp]
	movss	DWORD PTR _adjusted_twicepi$[ebp], xmm0

; 1780 : 	int adjusted_numshapes = numshapes;

	mov	eax, DWORD PTR _numshapes$[ebp]
	mov	DWORD PTR _adjusted_numshapes$[ebp], eax

; 1781 : 	if (total_draw < 360.0f) adjusted_numshapes = (int)ceil(draw_ratio * (float)adjusted_numshapes);

	movss	xmm0, DWORD PTR __real@43b40000
	comiss	xmm0, DWORD PTR _total_draw$[ebp]
	jbe	SHORT $LN9@CL_FillRGB
	cvtsi2ss xmm0, DWORD PTR _adjusted_numshapes$[ebp]
	mulss	xmm0, DWORD PTR _draw_ratio$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _adjusted_numshapes$[ebp], eax
$LN9@CL_FillRGB:

; 1782 : 
; 1783 : 	// Push matrix
; 1784 : 	pglPushMatrix();

	call	DWORD PTR _pglPushMatrix

; 1785 : 
; 1786 : 	// draw angle adjustement
; 1787 : 	pglTranslatef(x, y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1788 : 	pglRotatef(angle_start, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 1789 : 	pglTranslatef(-x, -y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	neg	ecx
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1790 : 
; 1791 : 	// Rotation around itself
; 1792 : 	pglTranslatef(x, y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1793 : 	pglRotatef(selfangle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 1794 : 	pglTranslatef(-x, -y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	neg	ecx
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1795 : 
; 1796 : 	// Rotation around defined pivot
; 1797 : 	pglTranslatef(xpivot, ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1798 : 	pglRotatef(angle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 1799 : 	pglTranslatef(-xpivot, -ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1800 : 
; 1801 : 	// Overall scale
; 1802 : 	pglScalef(xscale, yscale, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglScalef

; 1803 : 
; 1804 : 	// Computer GL draw style and whether or not we draw the center
; 1805 : 	// type 0 is either a full circle or arc, depending on start and end angle
; 1806 : 	// type 1 is a hollow segment
; 1807 : 	// type 2 is a hollow sector
; 1808 : 	// type 3 is a filled sector or full disc, depending on start and end angle
; 1809 : 	// type 4 is a filled segment
; 1810 : 	int i_gldrawstyle = (type == 3 || type == 4) ? GL_TRIANGLE_FAN : ((type != 0) ? GL_LINE_LOOP : GL_LINE_STRIP);

	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN32@CL_FillRGB
	cmp	DWORD PTR _type$[ebp], 4
	je	SHORT $LN32@CL_FillRGB
	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN33@CL_FillRGB
	mov	DWORD PTR tv213[ebp], 2
	jmp	SHORT $LN34@CL_FillRGB
$LN33@CL_FillRGB:
	mov	DWORD PTR tv213[ebp], 3
$LN34@CL_FillRGB:
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN35@CL_FillRGB
$LN32@CL_FillRGB:
	mov	DWORD PTR tv214[ebp], 6
$LN35@CL_FillRGB:
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _i_gldrawstyle$[ebp], ecx

; 1811 : 	int i_drawcenter = (type % 2) ? 1 : 0;

	mov	eax, DWORD PTR _type$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN38@CL_FillRGB
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN38@CL_FillRGB:
	test	eax, eax
	je	SHORT $LN36@CL_FillRGB
	mov	DWORD PTR tv217[ebp], 1
	jmp	SHORT $LN37@CL_FillRGB
$LN36@CL_FillRGB:
	mov	DWORD PTR tv217[ebp], 0
$LN37@CL_FillRGB:
	mov	ecx, DWORD PTR tv217[ebp]
	mov	DWORD PTR _i_drawcenter$[ebp], ecx

; 1812 : 
; 1813 : 	// Draw the thing
; 1814 : 	pglLineWidth(thickness);

	push	ecx
	movss	xmm0, DWORD PTR _thickness$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1815 : 	pglBegin(i_gldrawstyle);

	mov	eax, DWORD PTR _i_gldrawstyle$[ebp]
	push	eax
	call	DWORD PTR _pglBegin

; 1816 : 	if (i_drawcenter) pglVertex2f(x, y); // draw center of circle

	cmp	DWORD PTR _i_drawcenter$[ebp], 0
	je	SHORT $LN10@CL_FillRGB
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f
$LN10@CL_FillRGB:

; 1817 : 	for (i = 0; i <= adjusted_numshapes; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FillRGB
$LN2@CL_FillRGB:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FillRGB:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _adjusted_numshapes$[ebp]
	jg	$LN3@CL_FillRGB

; 1818 : 		pglVertex2f(

	cvtsi2sd xmm0, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR _yscale$[ebp]
	mulss	xmm1, DWORD PTR _height$[ebp]
	cvtss2sd xmm1, xmm1
	cvtsi2ss xmm2, DWORD PTR _i$[ebp]
	mulss	xmm2, DWORD PTR _adjusted_twicepi$[ebp]
	cvtsi2ss xmm3, DWORD PTR _adjusted_numshapes$[ebp]
	divss	xmm2, xmm3
	cvtss2sd xmm2, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv443[ebp], xmm0
	movsd	QWORD PTR tv445[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv425[ebp]
	movsd	xmm0, QWORD PTR tv445[ebp]
	mulsd	xmm0, QWORD PTR tv425[ebp]
	movsd	xmm1, QWORD PTR tv443[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _xscale$[ebp]
	mulss	xmm1, DWORD PTR _width$[ebp]
	cvtss2sd xmm1, xmm1
	cvtsi2ss xmm2, DWORD PTR _i$[ebp]
	mulss	xmm2, DWORD PTR _adjusted_twicepi$[ebp]
	cvtsi2ss xmm3, DWORD PTR _adjusted_numshapes$[ebp]
	divss	xmm2, xmm3
	cvtss2sd xmm2, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv447[ebp], xmm0
	movsd	QWORD PTR tv449[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv431[ebp]
	movsd	xmm0, QWORD PTR tv449[ebp]
	mulsd	xmm0, QWORD PTR tv431[ebp]
	movsd	xmm1, QWORD PTR tv447[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1819 : 			x + (xscale * width * cos(i * adjusted_twicepi / adjusted_numshapes)),
; 1820 : 			y + (yscale * height * sin(i * adjusted_twicepi / adjusted_numshapes))
; 1821 : 		);
; 1822 : 	}

	jmp	$LN2@CL_FillRGB
$LN3@CL_FillRGB:

; 1823 : 	pglEnd();

	call	DWORD PTR _pglEnd

; 1824 : 	pglLineWidth(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1825 : 	// Return to normal
; 1826 : 	pglPopMatrix();

	call	DWORD PTR _pglPopMatrix

; 1827 : 
; 1828 : 	pglColor3f(1.0f, 1.0f, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1829 : 	pglEnable(GL_TEXTURE_2D);

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1830 : 	pglDisable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN1@CL_FillRGB:

; 1831 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FillRGBACircle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FillRGBA
_TEXT	SEGMENT
tv383 = -112						; size = 8
tv367 = -112						; size = 8
tv423 = -104						; size = 8
tv415 = -104						; size = 8
tv421 = -96						; size = 8
tv413 = -96						; size = 8
tv376 = -88						; size = 8
tv360 = -88						; size = 8
tv419 = -80						; size = 8
tv411 = -80						; size = 8
tv417 = -72						; size = 8
tv409 = -72						; size = 8
tv79 = -72						; size = 4
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv183 = -68						; size = 4
tv78 = -68						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_type$ = 24						; size = 4
_thickness$ = 28					; size = 4
_r$ = 32						; size = 4
_g$ = 36						; size = 4
_b$ = 40						; size = 4
_a$ = 44						; size = 4
_xscale$ = 48						; size = 4
_yscale$ = 52						; size = 4
_selfangle$ = 56					; size = 4
_angle$ = 60						; size = 4
_xpivot$ = 64						; size = 4
_ypivot$ = 68						; size = 4
_CL_FillRGBA PROC					; COMDAT

; 1655 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 1656 : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN18@CL_FillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN16@CL_FillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN17@CL_FillRGB
$LN16@CL_FillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN17@CL_FillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN19@CL_FillRGB
$LN18@CL_FillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN19@CL_FillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 1657 : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN22@CL_FillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN20@CL_FillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN21@CL_FillRGB
$LN20@CL_FillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN21@CL_FillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN23@CL_FillRGB
$LN22@CL_FillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN23@CL_FillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 1658 : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN26@CL_FillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN24@CL_FillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN25@CL_FillRGB
$LN24@CL_FillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN25@CL_FillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN27@CL_FillRGB
$LN26@CL_FillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN27@CL_FillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 1659 : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN30@CL_FillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN28@CL_FillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN29@CL_FillRGB
$LN28@CL_FillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN29@CL_FillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN31@CL_FillRGB
$LN30@CL_FillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN31@CL_FillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 1660 : 
; 1661 : 	//SPR_AdjustSize( (float *)&x, (float *)&y, (float *)&width, (float *)&height );
; 1662 : 
; 1663 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1664 : 	pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1665 : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 1666 : 	pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1667 : 	pglColor4f( r / 255.0f, g / 255.0f, b / 255.0f, a / 255.0f );

	cvtsi2ss xmm0, DWORD PTR _a$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _b$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _g$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _r$[ebp]
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1668 : 
; 1669 : 	// Push matrix
; 1670 : 	pglPushMatrix();

	call	DWORD PTR _pglPushMatrix

; 1671 : 
; 1672 : 	// Rotation around itself
; 1673 : 	if (type == 1 || type == 2)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN6@CL_FillRGB
	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN4@CL_FillRGB
$LN6@CL_FillRGB:

; 1674 : 		pglTranslatef(x, y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef
	jmp	SHORT $LN5@CL_FillRGB
$LN4@CL_FillRGB:

; 1675 : 	else
; 1676 : 		pglTranslatef(x + (width / 2), y + (height / 2), 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _height$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _y$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _width$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _x$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef
$LN5@CL_FillRGB:

; 1677 : 
; 1678 : 	pglRotatef(selfangle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 1679 : 
; 1680 : 	if (type == 1 || type== 2)

	cmp	DWORD PTR _type$[ebp], 1
	je	SHORT $LN9@CL_FillRGB
	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN7@CL_FillRGB
$LN9@CL_FillRGB:

; 1681 : 		pglTranslatef(-x, -y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _y$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	neg	ecx
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef
	jmp	SHORT $LN8@CL_FillRGB
$LN7@CL_FillRGB:

; 1682 : 	else
; 1683 : 		pglTranslatef(-x - (width / 2), -y - (height / 2), 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _y$[ebp]
	neg	ecx
	mov	eax, DWORD PTR _height$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	neg	ecx
	mov	eax, DWORD PTR _width$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef
$LN8@CL_FillRGB:

; 1684 : 
; 1685 : 
; 1686 : 	// Rotation around defined pivot
; 1687 : 	pglTranslatef(xpivot, ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1688 : 	pglRotatef(angle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 1689 : 	pglTranslatef(-xpivot, -ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1690 : 
; 1691 : 	// Overall scale
; 1692 : 	//pglScalef(xscale, yscale, 1.0f);
; 1693 : 
; 1694 : 	switch (type)

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR tv183[ebp], 1
	je	SHORT $LN10@CL_FillRGB
	cmp	DWORD PTR tv183[ebp], 2
	je	SHORT $LN10@CL_FillRGB
	jmp	$LN14@CL_FillRGB
$LN10@CL_FillRGB:

; 1695 : 	{
; 1696 : 	case 1:
; 1697 : 	case 2:
; 1698 : 		{
; 1699 : 			// Draw the thing
; 1700 : 			pglLineWidth(thickness);

	push	ecx
	movss	xmm0, DWORD PTR _thickness$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1701 : 			pglBegin(GL_LINE_STRIP);

	push	3
	call	DWORD PTR _pglBegin

; 1702 : 			pglVertex2f(

	cvtsi2sd xmm0, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	mulss	xmm1, DWORD PTR _yscale$[ebp]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	xorps	xmm2, xmm2
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv409[ebp], xmm0
	movsd	QWORD PTR tv411[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv360[ebp]
	movsd	xmm0, QWORD PTR tv411[ebp]
	mulsd	xmm0, QWORD PTR tv360[ebp]
	movsd	xmm1, QWORD PTR tv409[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	mulss	xmm1, DWORD PTR _xscale$[ebp]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	xorps	xmm2, xmm2
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv413[ebp], xmm0
	movsd	QWORD PTR tv415[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv367[ebp]
	movsd	xmm0, QWORD PTR tv415[ebp]
	mulsd	xmm0, QWORD PTR tv367[ebp]
	movsd	xmm1, QWORD PTR tv413[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1703 : 				x + (xscale * width * cos(0)),
; 1704 : 				y + (yscale * height * sin(0))
; 1705 : 			);
; 1706 : 			if (type == 2)

	cmp	DWORD PTR _type$[ebp], 2
	jne	$LN12@CL_FillRGB

; 1707 : 			{
; 1708 : 				pglVertex2f(

	cvtsi2sd xmm0, DWORD PTR _y$[ebp]
	cvtsi2ss xmm1, DWORD PTR _height$[ebp]
	mulss	xmm1, DWORD PTR _yscale$[ebp]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	xmm2, QWORD PTR __real@400921fb60000000
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv417[ebp], xmm0
	movsd	QWORD PTR tv419[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv376[ebp]
	movsd	xmm0, QWORD PTR tv419[ebp]
	mulsd	xmm0, QWORD PTR tv376[ebp]
	movsd	xmm1, QWORD PTR tv417[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR _x$[ebp]
	cvtsi2ss xmm1, DWORD PTR _width$[ebp]
	mulss	xmm1, DWORD PTR _xscale$[ebp]
	cvtss2sd xmm1, xmm1
	sub	esp, 8
	movsd	xmm2, QWORD PTR __real@400921fb60000000
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv421[ebp], xmm0
	movsd	QWORD PTR tv423[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv383[ebp]
	movsd	xmm0, QWORD PTR tv423[ebp]
	mulsd	xmm0, QWORD PTR tv383[ebp]
	movsd	xmm1, QWORD PTR tv421[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1709 : 					x + (xscale * width * cos(M_PI)),
; 1710 : 					y + (yscale * height * sin(M_PI))
; 1711 : 				);
; 1712 : 			}

	jmp	SHORT $LN13@CL_FillRGB
$LN12@CL_FillRGB:

; 1713 : 			else
; 1714 : 			{
; 1715 : 				pglVertex2f(x, y); // draw center of circle

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f
$LN13@CL_FillRGB:

; 1716 : 			}
; 1717 : 			pglEnd();

	call	DWORD PTR _pglEnd

; 1718 : 			pglLineWidth(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1719 : 		}
; 1720 : 		break;

	jmp	$LN2@CL_FillRGB
$LN14@CL_FillRGB:

; 1721 : 	default:
; 1722 : 		pglBegin(GL_QUADS);

	push	7
	call	DWORD PTR _pglBegin

; 1723 : 		pglVertex2f(x, y);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1724 : 		pglVertex2f(x + width, y);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1725 : 		pglVertex2f(x + width, y + height);

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1726 : 		pglVertex2f(x, y + height);

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 1727 : 		pglEnd();

	call	DWORD PTR _pglEnd
$LN2@CL_FillRGB:

; 1728 : 		break;
; 1729 : 	}
; 1730 : 
; 1731 : 	// Pop matrix
; 1732 : 	pglPopMatrix();

	call	DWORD PTR _pglPopMatrix

; 1733 : 
; 1734 : 	pglColor3f( 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1735 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1736 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1737 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FillRGBA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _PicAdjustScale
_TEXT	SEGMENT
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_xscale$ = 16						; size = 4
_yscale$ = 20						; size = 4
_PicAdjustScale PROC					; COMDAT

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 346  : 	if (!xscale && !yscale && !w && !h) return;

	movss	xmm0, DWORD PTR _xscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@PicAdjustS
	movss	xmm0, DWORD PTR _yscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@PicAdjustS
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN2@PicAdjustS
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN2@PicAdjustS
	jmp	SHORT $LN4@PicAdjustS
$LN2@PicAdjustS:

; 347  : 
; 348  : 	if (w) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN3@PicAdjustS
	mov	eax, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN3@PicAdjustS:

; 349  : 	if (h) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN4@PicAdjustS
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN4@PicAdjustS:

; 350  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PicAdjustScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _PicAdjustSize
_TEXT	SEGMENT
_yscale$ = -8						; size = 4
_xscale$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_PicAdjustSize PROC					; COMDAT

; 328  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 329  : 	float	xscale, yscale;
; 330  : 
; 331  : 	if( !clgame.ds.adjust_size ) return;

	cmp	DWORD PTR _clgame+214868, 0
	jne	SHORT $LN2@PicAdjustS
	jmp	$LN7@PicAdjustS
$LN2@PicAdjustS:

; 332  : 	if( !x && !y && !w && !h ) return;

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _y$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _w$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN3@PicAdjustS
	jmp	$LN7@PicAdjustS
$LN3@PicAdjustS:

; 333  : 
; 334  : 	// scale for screen sizes
; 335  : 	xscale = glState.width / (float)clgame.scrInfo.iWidth;

	cvtsi2ss xmm0, DWORD PTR _glState
	cvtsi2ss xmm1, DWORD PTR _clgame+217076
	divss	xmm0, xmm1
	movss	DWORD PTR _xscale$[ebp], xmm0

; 336  : 	yscale = glState.height / (float)clgame.scrInfo.iHeight;

	cvtsi2ss xmm0, DWORD PTR _glState+4
	cvtsi2ss xmm1, DWORD PTR _clgame+217080
	divss	xmm0, xmm1
	movss	DWORD PTR _yscale$[ebp], xmm0

; 337  : 
; 338  : 	if( x ) *x *= xscale;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN4@PicAdjustS
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN4@PicAdjustS:

; 339  : 	if( y ) *y *= yscale;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN5@PicAdjustS
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN5@PicAdjustS:

; 340  : 	if( w ) *w *= xscale;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN6@PicAdjustS
	mov	eax, DWORD PTR _w$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _xscale$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN6@PicAdjustS:

; 341  : 	if( h ) *h *= yscale;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN7@PicAdjustS
	mov	eax, DWORD PTR _h$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _yscale$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN7@PicAdjustS:

; 342  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PicAdjustSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_LoadExt
_TEXT	SEGMENT
_spr$ = -4						; size = 4
_szPicName$ = 8						; size = 4
_texFlags$ = 12						; size = 4
_pfnSPR_LoadExt PROC					; COMDAT

; 1379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1380 : 	model_t	*spr;
; 1381 : 
; 1382 : 	if(( spr = CL_LoadSpriteModel( szPicName, SPR_CLIENT, texFlags )) == NULL )

	mov	eax, DWORD PTR _texFlags$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _szPicName$[ebp]
	push	ecx
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _spr$[ebp], eax
	cmp	DWORD PTR _spr$[ebp], 0
	jne	SHORT $LN2@pfnSPR_Loa

; 1383 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnSPR_Loa
$LN2@pfnSPR_Loa:

; 1384 : 
; 1385 : 	return (spr - clgame.sprites); // return index

	mov	eax, DWORD PTR _spr$[ebp]
	sub	eax, OFFSET _clgame+14124
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
$LN1@pfnSPR_Loa:

; 1386 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_LoadExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnSPR_Load
_TEXT	SEGMENT
_spr$ = -4						; size = 4
_szPicName$ = 8						; size = 4
_pfnSPR_Load PROC					; COMDAT

; 1395 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1396 : 	model_t	*spr;
; 1397 : 
; 1398 : 	if(( spr = CL_LoadSpriteModel( szPicName, SPR_HUDSPRITE, 0 )) == NULL )

	push	0
	push	1
	mov	eax, DWORD PTR _szPicName$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _spr$[ebp], eax
	cmp	DWORD PTR _spr$[ebp], 0
	jne	SHORT $LN2@pfnSPR_Loa

; 1399 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnSPR_Loa
$LN2@pfnSPR_Loa:

; 1400 : 
; 1401 : 	return (spr - clgame.sprites); // return index

	mov	eax, DWORD PTR _spr$[ebp]
	sub	eax, OFFSET _clgame+14124
	cdq
	mov	ecx, 392				; 00000188H
	idiv	ecx
$LN1@pfnSPR_Loa:

; 1402 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSPR_Load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LoadModel
_TEXT	SEGMENT
_i$ = -4						; size = 4
_modelname$ = 8						; size = 4
_index$ = 12						; size = 4
_CL_LoadModel PROC					; COMDAT

; 2839 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2840 : 	int	i;
; 2841 : 
; 2842 : 	if( index ) *index = -1;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN2@CL_LoadMod
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN2@CL_LoadMod:

; 2843 : 
; 2844 : 	if(( i = CL_FindModelIndex( modelname )) == 0 )

	mov	eax, DWORD PTR _modelname$[ebp]
	push	eax
	call	_CL_FindModelIndex
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@CL_LoadMod

; 2845 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_LoadMod
$LN3@CL_LoadMod:

; 2846 : 
; 2847 : 	if( index ) *index = i;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN4@CL_LoadMod
	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@CL_LoadMod:

; 2848 : 
; 2849 : 	return CL_ModelHandle( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
$LN1@CL_LoadMod:

; 2850 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LoadClientSprite
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_CL_LoadClientSprite PROC				; COMDAT

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1363 : 	return CL_LoadSpriteModel( filename, SPR_CLIENT, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_CL_LoadSpriteModel
	add	esp, 12					; 0000000cH

; 1364 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadClientSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetLocalPlayer
_TEXT	SEGMENT
tv73 = -72						; size = 4
_player$ = -4						; size = 4
_CL_GetLocalPlayer PROC					; COMDAT

; 793  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 794  : 	cl_entity_t	*player;
; 795  : 
; 796  : 	player = CL_EDICT_NUM( cl.playernum + 1 );

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax

; 797  : 	Assert( player != NULL );

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN3@CL_GetLoca
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@CL_GetLoca
$LN3@CL_GetLoca:
	mov	DWORD PTR tv73[ebp], 0
$LN4@CL_GetLoca:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_GetLocalPlayer@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@HGIIKDAL@player?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv73[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 798  : 
; 799  : 	return player;

	mov	eax, DWORD PTR _player$[ebp]

; 800  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetLocalPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FindModelIndex
_TEXT	SEGMENT
_i$ = -72						; size = 4
_filepath$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_m$ = 8							; size = 4
_CL_FindModelIndex PROC					; COMDAT

; 2612 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2613 : 	char		filepath[MAX_QPATH];
; 2614 : 	static float	lasttimewarn;
; 2615 : 	int		i;
; 2616 : 
; 2617 : 	if( !COM_CheckString( m ))

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_FindMod

; 2618 : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_FindMod
$LN5@CL_FindMod:

; 2619 : 
; 2620 : 	Q_strncpy( filepath, m, sizeof( filepath ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2621 : 	COM_FixSlashes( filepath );

	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2622 : 
; 2623 : 	for( i = 0; i < cl.nummodels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindMod
$LN2@CL_FindMod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FindMod:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2984344
	jge	SHORT $LN3@CL_FindMod

; 2624 : 	{
; 2625 : 		if( !cl.models[i+1] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _cl[eax*4+2980248], 0
	jne	SHORT $LN6@CL_FindMod

; 2626 : 			continue;

	jmp	SHORT $LN2@CL_FindMod
$LN6@CL_FindMod:

; 2627 : 
; 2628 : 		if( !Q_stricmp( cl.models[i+1]->name, filepath ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cl[ecx*4+2980248]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@CL_FindMod

; 2629 : 			return i+1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	jmp	SHORT $LN1@CL_FindMod
$LN7@CL_FindMod:

; 2630 : 	}

	jmp	SHORT $LN2@CL_FindMod
$LN3@CL_FindMod:

; 2631 : 
; 2632 : 	if( lasttimewarn < host.realtime )

	cvtss2sd xmm0, DWORD PTR ?lasttimewarn@?1??CL_FindModelIndex@@9@9
	movsd	xmm1, QWORD PTR _host+1440
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@CL_FindMod

; 2633 : 	{
; 2634 : 		// tell user about problem (but don't spam console)
; 2635 : 		Con_Printf( S_ERROR "%s not precached\n", filepath );

	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@MDFPKJKH@?$FO1Error?3?$FO7?5?$CFs?5not?5precached?6@
	call	_Con_Printf
	add	esp, 8

; 2636 : 		lasttimewarn = host.realtime + 1.0f;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR ?lasttimewarn@?1??CL_FindModelIndex@@9@9, xmm0
$LN8@CL_FindMod:

; 2637 : 	}
; 2638 : 
; 2639 : 	return 0;

	xor	eax, eax
$LN1@CL_FindMod:

; 2640 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindModelIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _NetAPI_CancelAllRequests
_TEXT	SEGMENT
_i$ = -8						; size = 4
_nr$ = -4						; size = 4
_NetAPI_CancelAllRequests PROC				; COMDAT

; 3747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3748 : 	net_request_t	*nr;
; 3749 : 	int		i;
; 3750 : 
; 3751 : 	// tell the user about cancel
; 3752 : 	for( i = 0; i < MAX_REQUESTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NetAPI_Can
$LN2@NetAPI_Can:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NetAPI_Can:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@NetAPI_Can

; 3753 : 	{
; 3754 : 		nr = &clgame.net_requests[i];

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, OFFSET _clgame+255304
	mov	DWORD PTR _nr$[ebp], eax

; 3755 : 		if( !nr->pfnFunc ) continue;	// not used

	mov	eax, DWORD PTR _nr$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN5@NetAPI_Can
	jmp	SHORT $LN2@NetAPI_Can
$LN5@NetAPI_Can:

; 3756 : 		SetBits( nr->resp.error, NET_ERROR_TIMEOUT );

	mov	eax, DWORD PTR _nr$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _nr$[ebp]
	mov	DWORD PTR [edx], ecx

; 3757 : 		nr->resp.ping = host.realtime - nr->timesend;

	mov	eax, DWORD PTR _nr$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+64]
	mov	ecx, DWORD PTR _nr$[ebp]
	movsd	QWORD PTR [ecx+32], xmm0

; 3758 : 		nr->pfnFunc( &nr->resp );

	mov	eax, DWORD PTR _nr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nr$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 4

; 3759 : 	}

	jmp	SHORT $LN2@NetAPI_Can
$LN3@NetAPI_Can:

; 3760 : 
; 3761 : 	memset( clgame.net_requests, 0, sizeof( clgame.net_requests ));

	push	5120					; 00001400H
	push	0
	push	OFFSET _clgame+255304
	call	_memset
	add	esp, 12					; 0000000cH

; 3762 : 	clgame.request_type = NET_REQUEST_CANCEL;

	mov	DWORD PTR _clgame+255296, 0

; 3763 : 	clgame.master_request = NULL;

	mov	DWORD PTR _clgame+260424, 0

; 3764 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NetAPI_CancelAllRequests ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ModelHandle
_TEXT	SEGMENT
_modelindex$ = 8					; size = 4
_CL_ModelHandle PROC					; COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 126  : 	if( modelindex < 0 || modelindex >= MAX_MODELS )

	cmp	DWORD PTR _modelindex$[ebp], 0
	jl	SHORT $LN3@CL_ModelHa
	cmp	DWORD PTR _modelindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@CL_ModelHa
$LN3@CL_ModelHa:

; 127  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_ModelHa
$LN2@CL_ModelHa:

; 128  : 	return cl.models[modelindex];

	mov	eax, DWORD PTR _modelindex$[ebp]
	mov	eax, DWORD PTR _cl[eax*4+2980244]
$LN1@CL_ModelHa:

; 129  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ModelHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnIndexFromTrace
_TEXT	SEGMENT
_pTrace$ = 8						; size = 4
_pfnIndexFromTrace PROC					; COMDAT

; 2699 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2700 : 	if( pTrace->ent >= 0 && pTrace->ent < clgame.pmove->numphysent )

	mov	eax, DWORD PTR _pTrace$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jl	SHORT $LN2@pfnIndexFr
	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR _clgame+1344
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx+588]
	jge	SHORT $LN2@pfnIndexFr

; 2701 : 	{
; 2702 : 		// return cl.entities number
; 2703 : 		return clgame.pmove->physents[pTrace->ent].info;

	mov	eax, DWORD PTR _pTrace$[ebp]
	imul	ecx, DWORD PTR [eax+48], 224
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+ecx+672]
	jmp	SHORT $LN1@pfnIndexFr
$LN2@pfnIndexFr:

; 2704 : 	}
; 2705 : 	return -1;

	or	eax, -1
$LN1@pfnIndexFr:

; 2706 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIndexFromTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_TextMessageGet
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pName$ = 8						; size = 4
_CL_TextMessageGet PROC					; COMDAT

; 2095 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2096 : 	int	i;
; 2097 : 
; 2098 : 	// first check internal messages
; 2099 : 	for( i = 0; i < MAX_TEXTCHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_TextMes
$LN2@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_TextMes:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@CL_TextMes

; 2100 : 	{
; 2101 : 		if( !Q_strcmp( pName, va( TEXT_MSGNAME, i )))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@IDJGENMA@TextMessage?$CFi@
	call	_va
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@CL_TextMes

; 2102 : 			return cl_textmessage + i;

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	jmp	SHORT $LN1@CL_TextMes
$LN8@CL_TextMes:

; 2103 : 	}

	jmp	SHORT $LN2@CL_TextMes
$LN3@CL_TextMes:

; 2104 : 
; 2105 : 	// find desired message
; 2106 : 	for( i = 0; i < clgame.numTitles; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_TextMes
$LN5@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _clgame+255292
	jge	SHORT $LN6@CL_TextMes

; 2107 : 	{
; 2108 : 		if( !Q_stricmp( pName, clgame.titles[i].pName ))

	push	99999					; 0001869fH
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+255288
	mov	edx, DWORD PTR [ecx+eax+36]
	push	edx
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@CL_TextMes

; 2109 : 			return clgame.titles + i;

	imul	eax, DWORD PTR _i$[ebp], 44
	add	eax, DWORD PTR _clgame+255288
	jmp	SHORT $LN1@CL_TextMes
$LN9@CL_TextMes:

; 2110 : 	}

	jmp	SHORT $LN5@CL_TextMes
$LN6@CL_TextMes:

; 2111 : 	return NULL; // found nothing

	xor	eax, eax
$LN1@CL_TextMes:

; 2112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TextMessageGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_CenterPrint
_TEXT	SEGMENT
_s$ = -12						; size = 4
_width$ = -8						; size = 4
_length$ = -4						; size = 4
_text$ = 8						; size = 4
_y$ = 12						; size = 4
_CL_CenterPrint PROC					; COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 250  : 	int	length = 0;

	mov	DWORD PTR _length$[ebp], 0

; 251  : 	int	width = 0;

	mov	DWORD PTR _width$[ebp], 0

; 252  : 	char	*s;
; 253  : 
; 254  : 	if( !COM_CheckString( text ))

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@CL_CenterP

; 255  : 		return;

	jmp	$LN1@CL_CenterP
$LN4@CL_CenterP:

; 256  : 
; 257  : 	clgame.centerPrint.lines = 1;

	mov	DWORD PTR _clgame+215012, 1

; 258  : 	clgame.centerPrint.totalWidth = 0;

	mov	DWORD PTR _clgame+217064, 0

; 259  : 	clgame.centerPrint.time = cl.mtime[0]; // allow pause for centerprint

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR _clgame+215004, xmm0

; 260  : 	Q_strncpy( clgame.centerPrint.message, text, sizeof( clgame.centerPrint.message ));

	push	2048					; 00000800H
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _clgame+215016
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 261  : 	s = clgame.centerPrint.message;

	mov	DWORD PTR _s$[ebp], OFFSET _clgame+215016
$LN2@CL_CenterP:

; 262  : 
; 263  : 	// count the number of lines for centering
; 264  : 	while( *s )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@CL_CenterP

; 265  : 	{
; 266  : 		if( *s == '\n' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN5@CL_CenterP

; 267  : 		{
; 268  : 			clgame.centerPrint.lines++;

	mov	eax, DWORD PTR _clgame+215012
	add	eax, 1
	mov	DWORD PTR _clgame+215012, eax

; 269  : 			if( width > clgame.centerPrint.totalWidth )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _clgame+217064
	jle	SHORT $LN7@CL_CenterP

; 270  : 				clgame.centerPrint.totalWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _clgame+217064, eax
$LN7@CL_CenterP:

; 271  : 			width = 0;

	mov	DWORD PTR _width$[ebp], 0

; 272  : 		}

	jmp	SHORT $LN6@CL_CenterP
$LN5@CL_CenterP:

; 273  : 		else width += clgame.scrInfo.charWidths[*s];

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, WORD PTR _clgame[ecx*2+217100]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _width$[ebp], edx
$LN6@CL_CenterP:

; 274  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 275  : 		length++;

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 276  : 	}

	jmp	SHORT $LN2@CL_CenterP
$LN3@CL_CenterP:

; 277  : 
; 278  : 	clgame.centerPrint.totalHeight = ( clgame.centerPrint.lines * clgame.scrInfo.iCharHeight ); 

	mov	eax, DWORD PTR _clgame+215012
	imul	eax, DWORD PTR _clgame+217096
	mov	DWORD PTR _clgame+217068, eax

; 279  : 	clgame.centerPrint.y = CL_AdjustYPos( y, clgame.centerPrint.totalHeight );

	mov	eax, DWORD PTR _clgame+217068
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_CL_AdjustYPos
	add	esp, 8
	mov	DWORD PTR _clgame+215008, eax
$LN1@CL_CenterP:

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FreeEntity
_TEXT	SEGMENT
tv70 = -68						; size = 4
_pEdict$ = 8						; size = 4
_CL_FreeEntity PROC					; COMDAT

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1142 : 	Assert( pEdict != NULL );

	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $LN3@CL_FreeEnt
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_FreeEnt
$LN3@CL_FreeEnt:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_FreeEnt:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeEntity@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@OBCGMAHI@pEdict?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1143 : 	R_RemoveEfrags( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_R_RemoveEfrags
	add	esp, 4

; 1144 : 	CL_KillDeadBeams( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	_CL_KillDeadBeams
	add	esp, 4

; 1145 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ClearSpriteTextures
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearSpriteTextures PROC				; COMDAT

; 1232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1233 : 	int	i;
; 1234 : 
; 1235 : 	for( i = 1; i < MAX_CLIENT_SPRITES; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_ClearSp
$LN2@CL_ClearSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearSp:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN1@CL_ClearSp

; 1236 : 		clgame.sprites[i].needload = NL_UNREFERENCED;

	imul	eax, DWORD PTR _i$[ebp], 392
	mov	DWORD PTR _clgame[eax+14188], 0
	jmp	SHORT $LN2@CL_ClearSp
$LN1@CL_ClearSp:

; 1237 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearSpriteTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawCenterPrint
_TEXT	SEGMENT
$T1 = -196						; size = 4
_c$2 = -125						; size = 1
_charHeight$ = -124					; size = 4
_charWidth$ = -120					; size = 4
_line$ = -116						; size = 80
_colorDefault$ = -36					; size = 4
_lineLength$ = -32					; size = 4
_width$ = -28						; size = 4
_y$ = -24						; size = 4
_x$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_pText$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_DrawCenterPrint PROC				; COMDAT

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 537  : 	char	*pText;
; 538  : 	int	i, j, x, y;
; 539  : 	int	width, lineLength;
; 540  : 	byte	*colorDefault, line[MAX_LINELENGTH];
; 541  : 	int	charWidth, charHeight;
; 542  : 
; 543  : 	if( !clgame.centerPrint.time )

	movss	xmm0, DWORD PTR _clgame+215004
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_DrawCen

; 544  : 		return;

	jmp	$LN3@CL_DrawCen
$LN10@CL_DrawCen:

; 545  : 
; 546  : 	if(( cl.time - clgame.centerPrint.time ) >= scr_centertime->value )

	cvtss2sd xmm0, DWORD PTR _clgame+215004
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	mov	eax, DWORD PTR _scr_centertime
	cvtss2sd xmm0, DWORD PTR [eax+12]
	comisd	xmm1, xmm0
	jb	SHORT $LN11@CL_DrawCen

; 547  : 	{
; 548  : 		// time expired
; 549  : 		clgame.centerPrint.time = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+215004, xmm0

; 550  : 		return;

	jmp	$LN3@CL_DrawCen
$LN11@CL_DrawCen:

; 551  : 	}
; 552  : 
; 553  : 	y = clgame.centerPrint.y; // start y

	mov	eax, DWORD PTR _clgame+215008
	mov	DWORD PTR _y$[ebp], eax

; 554  : 	colorDefault = g_color_table[7];

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, OFFSET _g_color_table
	mov	DWORD PTR _colorDefault$[ebp], ecx

; 555  : 	pText = clgame.centerPrint.message;

	mov	DWORD PTR _pText$[ebp], OFFSET _clgame+215016

; 556  : 	Con_DrawCharacterLen( 0, NULL, &charHeight );

	lea	eax, DWORD PTR _charHeight$[ebp]
	push	eax
	push	0
	push	0
	call	_Con_DrawCharacterLen
	add	esp, 12					; 0000000cH

; 557  : 	
; 558  : 	for( i = 0; i < clgame.centerPrint.lines; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_DrawCen
$LN2@CL_DrawCen:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_DrawCen:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _clgame+215012
	jge	$LN3@CL_DrawCen

; 559  : 	{
; 560  : 		lineLength = 0;

	mov	DWORD PTR _lineLength$[ebp], 0

; 561  : 		width = 0;

	mov	DWORD PTR _width$[ebp], 0
$LN5@CL_DrawCen:

; 562  : 
; 563  : 		while( *pText && *pText != '\n' && lineLength < MAX_LINELENGTH )

	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@CL_DrawCen
	mov	eax, DWORD PTR _pText$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN6@CL_DrawCen
	cmp	DWORD PTR _lineLength$[ebp], 80		; 00000050H
	jge	SHORT $LN6@CL_DrawCen

; 564  : 		{
; 565  : 			byte c = *pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$2[ebp], cl

; 566  : 			line[lineLength] = c;

	mov	eax, DWORD PTR _lineLength$[ebp]
	mov	cl, BYTE PTR _c$2[ebp]
	mov	BYTE PTR _line$[ebp+eax], cl

; 567  : 			Con_DrawCharacterLen( c, &charWidth, NULL );

	push	0
	lea	eax, DWORD PTR _charWidth$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _c$2[ebp]
	push	ecx
	call	_Con_DrawCharacterLen
	add	esp, 12					; 0000000cH

; 568  : 			width += charWidth;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _charWidth$[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 569  : 			lineLength++;

	mov	eax, DWORD PTR _lineLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _lineLength$[ebp], eax

; 570  : 			pText++;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 1
	mov	DWORD PTR _pText$[ebp], eax

; 571  : 		}

	jmp	SHORT $LN5@CL_DrawCen
$LN6@CL_DrawCen:

; 572  : 
; 573  : 		if( lineLength == MAX_LINELENGTH )

	cmp	DWORD PTR _lineLength$[ebp], 80		; 00000050H
	jne	SHORT $LN12@CL_DrawCen

; 574  : 			lineLength--;

	mov	eax, DWORD PTR _lineLength$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lineLength$[ebp], eax
$LN12@CL_DrawCen:

; 575  : 
; 576  : 		pText++; // Skip LineFeed

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, 1
	mov	DWORD PTR _pText$[ebp], eax

; 577  : 		line[lineLength] = 0;

	mov	eax, DWORD PTR _lineLength$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 80			; 00000050H
	jae	SHORT $LN15@CL_DrawCen
	jmp	SHORT $LN16@CL_DrawCen
$LN15@CL_DrawCen:
	call	___report_rangecheckfailure
$LN16@CL_DrawCen:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _line$[ebp+ecx], 0

; 578  : 
; 579  : 		x = CL_AdjustXPos( -1, width, clgame.centerPrint.totalWidth );

	mov	eax, DWORD PTR _clgame+217064
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_CL_AdjustXPos
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _x$[ebp], eax

; 580  : 
; 581  : 		for( j = 0; j < lineLength; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@CL_DrawCen
$LN7@CL_DrawCen:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@CL_DrawCen:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _lineLength$[ebp]
	jge	SHORT $LN8@CL_DrawCen

; 582  : 		{
; 583  : 			if( x >= 0 && y >= 0 && x <= glState.width )

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN13@CL_DrawCen
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN13@CL_DrawCen
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _glState
	jg	SHORT $LN13@CL_DrawCen

; 584  : 				x += Con_DrawCharacter( x, y, line[j], colorDefault );

	mov	eax, DWORD PTR _colorDefault$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	movzx	edx, BYTE PTR _line$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_Con_DrawCharacter
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN13@CL_DrawCen:

; 585  : 		}

	jmp	SHORT $LN7@CL_DrawCen
$LN8@CL_DrawCen:

; 586  : 		y += charHeight;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _charHeight$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 587  : 	}

	jmp	$LN2@CL_DrawCen
$LN3@CL_DrawCen:

; 588  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawCenterPrint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ClearWorld
_TEXT	SEGMENT
_world$ = -4						; size = 4
_CL_ClearWorld PROC					; COMDAT

; 1148 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1149 : 	cl_entity_t	*world;
; 1150 : 
; 1151 : 	world = clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	mov	DWORD PTR _world$[ebp], eax

; 1152 : 	world->curstate.modelindex = 1;	// world model

	mov	eax, DWORD PTR _world$[ebp]
	mov	DWORD PTR [eax+952], 1

; 1153 : 	world->curstate.solid = SOLID_BSP;

	mov	eax, 4
	mov	ecx, DWORD PTR _world$[ebp]
	mov	WORD PTR [ecx+968], ax

; 1154 : 	world->curstate.movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _world$[ebp]
	mov	DWORD PTR [eax+1000], 7

; 1155 : 	world->model = cl.worldmodel;

	mov	eax, DWORD PTR _world$[ebp]
	mov	ecx, DWORD PTR _cl+4579004
	mov	DWORD PTR [eax+3300], ecx

; 1156 : 	world->index = 0;

	mov	eax, DWORD PTR _world$[ebp]
	mov	DWORD PTR [eax], 0

; 1157 : 
; 1158 : 	clgame.ds.cullMode = GL_FRONT;

	mov	DWORD PTR _clgame+214876, 1028		; 00000404H

; 1159 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1016, 0

; 1160 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearWorld ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_FreeEdicts
_TEXT	SEGMENT
_CL_FreeEdicts PROC					; COMDAT

; 1190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1191 : 	if( clgame.drawFuncs.R_ProcessEntData != NULL )

	cmp	DWORD PTR _clgame+208, 0
	je	SHORT $LN2@CL_FreeEdi

; 1192 : 	{
; 1193 : 		// let the client.dll free custom data
; 1194 : 		clgame.drawFuncs.R_ProcessEntData( false );

	push	0
	call	DWORD PTR _clgame+208
	add	esp, 4
$LN2@CL_FreeEdi:

; 1195 : 	}
; 1196 : 
; 1197 : 	if( clgame.entities )

	cmp	DWORD PTR _clgame+996, 0
	je	SHORT $LN3@CL_FreeEdi

; 1198 : 		Mem_Free( clgame.entities );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeEdicts@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clgame+996
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@CL_FreeEdi:

; 1199 : 	clgame.entities = NULL;

	mov	DWORD PTR _clgame+996, 0

; 1200 : 
; 1201 : 	if( clgame.static_entities )

	cmp	DWORD PTR _clgame+1000, 0
	je	SHORT $LN4@CL_FreeEdi

; 1202 : 		Mem_Free( clgame.static_entities );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeEdicts@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _clgame+1000
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@CL_FreeEdi:

; 1203 : 	clgame.static_entities = NULL;

	mov	DWORD PTR _clgame+1000, 0

; 1204 : 
; 1205 : 	if( cls.packet_entities )

	cmp	DWORD PTR _cls+295012, 0
	je	SHORT $LN5@CL_FreeEdi

; 1206 : 		Z_Free( cls.packet_entities );

	cmp	DWORD PTR _cls+295012, 0
	je	SHORT $LN5@CL_FreeEdi
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeEdicts@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cls+295012
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@CL_FreeEdi:

; 1207 : 
; 1208 : 	cls.packet_entities = NULL;

	mov	DWORD PTR _cls+295012, 0

; 1209 : 	cls.num_client_entities = 0;

	mov	DWORD PTR _cls+295004, 0

; 1210 : 	cls.next_client_entities = 0;

	mov	DWORD PTR _cls+295008, 0

; 1211 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1016, 0

; 1212 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_InitEdicts
_TEXT	SEGMENT
tv74 = -68						; size = 4
tv70 = -68						; size = 4
_CL_InitEdicts PROC					; COMDAT

; 1163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1164 : 	Assert( clgame.entities == NULL );

	cmp	DWORD PTR _clgame+996, 0
	jne	SHORT $LN6@CL_InitEdi
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@CL_InitEdi
$LN6@CL_InitEdi:
	mov	DWORD PTR tv70[ebp], 0
$LN7@CL_InitEdi:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitEdicts@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@CHDGGDIF@clgame?4entities?5?$DN?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1165 : 
; 1166 : 	if( !clgame.mempool ) return; // Host_Error without client

	cmp	DWORD PTR _clgame+224, 0
	jne	SHORT $LN2@CL_InitEdi
	jmp	$LN1@CL_InitEdi
$LN2@CL_InitEdi:

; 1167 : 
; 1168 : 	CL_UPDATE_BACKUP = ( cl.maxclients == 1 ) ? SINGLEPLAYER_BACKUP : MULTIPLAYER_BACKUP;

	cmp	DWORD PTR _cl+2213004, 1
	jne	SHORT $LN8@CL_InitEdi
	mov	DWORD PTR tv74[ebp], 16			; 00000010H
	jmp	SHORT $LN9@CL_InitEdi
$LN8@CL_InitEdi:
	mov	DWORD PTR tv74[ebp], 64			; 00000040H
$LN9@CL_InitEdi:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _CL_UPDATE_BACKUP, eax

; 1169 : 	cls.num_client_entities = CL_UPDATE_BACKUP * NUM_PACKET_ENTITIES;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	shl	eax, 8
	mov	DWORD PTR _cls+295004, eax

; 1170 : 	cls.packet_entities = Mem_Realloc( clgame.mempool, cls.packet_entities, sizeof( entity_state_t ) * cls.num_client_entities );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitEdicts@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _cls+295004, 452
	push	ecx
	mov	edx, DWORD PTR _cls+295012
	push	edx
	mov	eax, DWORD PTR _clgame+224
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _cls+295012, eax

; 1171 : 	clgame.entities = Mem_Calloc( clgame.mempool, sizeof( cl_entity_t ) * clgame.maxEntities );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitEdicts@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _clgame+1008, 3336
	push	ecx
	mov	edx, DWORD PTR _clgame+224
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+996, eax

; 1172 : 	clgame.static_entities = Mem_Calloc( clgame.mempool, sizeof( cl_entity_t ) * MAX_STATIC_ENTITIES );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitEdicts@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	10328256				; 009d98c0H
	mov	ecx, DWORD PTR _clgame+224
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+1000, eax

; 1173 : 	clgame.numStatics = 0;

	mov	DWORD PTR _clgame+1016, 0

; 1174 : 
; 1175 : 	if(( clgame.maxRemapInfos - 1 ) != clgame.maxEntities )

	mov	eax, DWORD PTR _clgame+1012
	sub	eax, 1
	cmp	eax, DWORD PTR _clgame+1008
	je	SHORT $LN3@CL_InitEdi

; 1176 : 	{
; 1177 : 		CL_ClearAllRemaps (); // purge old remap info

	call	_CL_ClearAllRemaps

; 1178 : 		clgame.maxRemapInfos = clgame.maxEntities + 1; 

	mov	eax, DWORD PTR _clgame+1008
	add	eax, 1
	mov	DWORD PTR _clgame+1012, eax

; 1179 : 		clgame.remap_info = (remap_info_t **)Mem_Calloc( clgame.mempool, sizeof( remap_info_t* ) * clgame.maxRemapInfos );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitEdicts@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _clgame+1012
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _clgame+224
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+1004, eax
$LN3@CL_InitEdi:

; 1180 : 	}
; 1181 : 
; 1182 : 	if( clgame.drawFuncs.R_ProcessEntData != NULL )

	cmp	DWORD PTR _clgame+208, 0
	je	SHORT $LN1@CL_InitEdi

; 1183 : 	{
; 1184 : 		// let the client.dll free custom data
; 1185 : 		clgame.drawFuncs.R_ProcessEntData( true );

	push	1
	call	DWORD PTR _clgame+208
	add	esp, 4
$LN1@CL_InitEdi:

; 1186 : 	}
; 1187 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_DrawHUD
_TEXT	SEGMENT
tv68 = -68						; size = 4
_state$ = 8						; size = 4
_CL_DrawHUD PROC					; COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1070 : 	if( state == CL_ACTIVE && !cl.video_prepped )

	cmp	DWORD PTR _state$[ebp], 2
	jne	SHORT $LN4@CL_DrawHUD
	cmp	DWORD PTR _cl+16, 0
	jne	SHORT $LN4@CL_DrawHUD

; 1071 : 		state = CL_LOADING;

	mov	DWORD PTR _state$[ebp], 1
$LN4@CL_DrawHUD:

; 1072 : 
; 1073 : 	if( state == CL_ACTIVE && cl.paused )

	cmp	DWORD PTR _state$[ebp], 2
	jne	SHORT $LN5@CL_DrawHUD
	cmp	DWORD PTR _cl+24, 0
	je	SHORT $LN5@CL_DrawHUD

; 1074 : 		state = CL_PAUSED;

	mov	DWORD PTR _state$[ebp], 3
$LN5@CL_DrawHUD:

; 1075 : 
; 1076 : 	switch( state )

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN2@CL_DrawHUD
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN14@CL_DrawHUD[edx*4]
$LN6@CL_DrawHUD:

; 1077 : 	{
; 1078 : 	case CL_ACTIVE:
; 1079 : 		if( !cl.intermission )

	cmp	DWORD PTR _cl+2212820, 0
	jne	SHORT $LN7@CL_DrawHUD

; 1080 : 			CL_DrawScreenFade ();

	call	_CL_DrawScreenFade
$LN7@CL_DrawHUD:

; 1081 : 		CL_DrawCrosshair ();

	call	_CL_DrawCrosshair

; 1082 : 		CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 1083 : 		clgame.dllFuncs.pfnRedraw( cl.time, cl.intermission );

	mov	eax, DWORD PTR _cl+2212820
	push	eax
	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+16
	add	esp, 8

; 1084 : 		if( cl.intermission ) CL_DrawScreenFade ();

	cmp	DWORD PTR _cl+2212820, 0
	je	SHORT $LN8@CL_DrawHUD
	call	_CL_DrawScreenFade
$LN8@CL_DrawHUD:

; 1085 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN9@CL_DrawHUD:

; 1086 : 	case CL_PAUSED:
; 1087 : 		CL_DrawScreenFade ();

	call	_CL_DrawScreenFade

; 1088 : 		CL_DrawCrosshair ();

	call	_CL_DrawCrosshair

; 1089 : 		CL_DrawCenterPrint ();

	call	_CL_DrawCenterPrint

; 1090 : 		clgame.dllFuncs.pfnRedraw( cl.time, cl.intermission );

	mov	eax, DWORD PTR _cl+2212820
	push	eax
	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+16
	add	esp, 8

; 1091 : 		CL_DrawPause();

	call	_CL_DrawPause

; 1092 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN10@CL_DrawHUD:

; 1093 : 	case CL_LOADING:
; 1094 : 		CL_DrawLoading( scr_loading->value );

	mov	eax, DWORD PTR _scr_loading
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	call	_CL_DrawLoading
	add	esp, 4

; 1095 : 		break;

	jmp	SHORT $LN2@CL_DrawHUD
$LN11@CL_DrawHUD:

; 1096 : 	case CL_CHANGELEVEL:
; 1097 : 		if( cls.draw_changelevel )

	cmp	DWORD PTR _cls+32, 0
	je	SHORT $LN12@CL_DrawHUD

; 1098 : 		{
; 1099 : 			CL_DrawLoading( 100.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_CL_DrawLoading
	add	esp, 4

; 1100 : 			cls.draw_changelevel = false;

	mov	DWORD PTR _cls+32, 0
$LN12@CL_DrawHUD:
$LN2@CL_DrawHUD:

; 1101 : 		}
; 1102 : 		break;
; 1103 : 	}
; 1104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN14@CL_DrawHUD:
	DD	$LN10@CL_DrawHUD
	DD	$LN6@CL_DrawHUD
	DD	$LN9@CL_DrawHUD
	DD	$LN11@CL_DrawHUD
_CL_DrawHUD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ParseTextMessage
_TEXT	SEGMENT
_channel$ = -8						; size = 4
_text$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseTextMessage PROC				; COMDAT

; 695  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 696  : 	static int		msgindex = 0;
; 697  : 	client_textmessage_t	*text;
; 698  : 	int			channel;
; 699  : 
; 700  : 	// read channel ( 0 - auto)
; 701  : 	channel = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _channel$[ebp], eax

; 702  : 
; 703  : 	if( channel <= 0 || channel > ( MAX_TEXTCHANNELS - 1 ))

	cmp	DWORD PTR _channel$[ebp], 0
	jle	SHORT $LN3@CL_ParseTe
	cmp	DWORD PTR _channel$[ebp], 7
	jle	SHORT $LN2@CL_ParseTe
$LN3@CL_ParseTe:

; 704  : 	{
; 705  : 		channel = msgindex;

	mov	eax, DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9
	mov	DWORD PTR _channel$[ebp], eax

; 706  : 		msgindex = (msgindex + 1) & (MAX_TEXTCHANNELS - 1);

	mov	eax, DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9
	add	eax, 1
	and	eax, 7
	mov	DWORD PTR ?msgindex@?1??CL_ParseTextMessage@@9@9, eax
$LN2@CL_ParseTe:

; 707  : 	}	
; 708  : 
; 709  : 	// grab message channel
; 710  : 	text = &cl_textmessage[channel];

	imul	eax, DWORD PTR _channel$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	mov	DWORD PTR _text$[ebp], eax

; 711  : 
; 712  : 	text->x = (float)(MSG_ReadShort( msg ) / 8192.0f);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46000000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 713  : 	text->y = (float)(MSG_ReadShort( msg ) / 8192.0f);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@46000000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 714  : 	text->effect = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	DWORD PTR [ecx], eax

; 715  : 	text->r1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+4], al

; 716  : 	text->g1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+5], al

; 717  : 	text->b1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+6], al

; 718  : 	text->a1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+7], al

; 719  : 	text->r2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+8], al

; 720  : 	text->g2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+9], al

; 721  : 	text->b2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+10], al

; 722  : 	text->a2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR [ecx+11], al

; 723  : 	text->fadein = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 724  : 	text->fadeout = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+24], xmm0

; 725  : 	text->holdtime = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+28], xmm0

; 726  : 
; 727  : 	if( text->effect == 2 )

	mov	eax, DWORD PTR _text$[ebp]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN4@CL_ParseTe

; 728  : 		text->fxtime = (float)(MSG_ReadShort( msg ) / 256.0f );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _text$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	jmp	SHORT $LN5@CL_ParseTe
$LN4@CL_ParseTe:

; 729  : 	else text->fxtime = 0.0f;

	mov	eax, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+32], xmm0
$LN5@CL_ParseTe:

; 730  : 
; 731  : 	// to prevent grab too long messages
; 732  : 	Q_strncpy( (char *)text->pMessage, MSG_ReadString( msg ), 2048 ); 		

	push	2048					; 00000800H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 733  : 
; 734  : 	CL_HudMessage( text->pName );

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_CL_HudMessage
	add	esp, 4

; 735  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseTextMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ParseFinaleCutscene
_TEXT	SEGMENT
_channel$ = -8						; size = 4
_text$ = -4						; size = 4
_msg$ = 8						; size = 4
_level$ = 12						; size = 4
_CL_ParseFinaleCutscene PROC				; COMDAT

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 746  : 	static int		msgindex = 0;
; 747  : 	client_textmessage_t	*text;
; 748  : 	int			channel;
; 749  : 
; 750  : 	cl.intermission = level;

	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR _cl+2212820, eax

; 751  : 
; 752  : 	channel = msgindex;

	mov	eax, DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9
	mov	DWORD PTR _channel$[ebp], eax

; 753  : 	msgindex = (msgindex + 1) & (MAX_TEXTCHANNELS - 1);

	mov	eax, DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9
	add	eax, 1
	and	eax, 7
	mov	DWORD PTR ?msgindex@?1??CL_ParseFinaleCutscene@@9@9, eax

; 754  : 
; 755  : 	// grab message channel
; 756  : 	text = &cl_textmessage[channel];

	imul	eax, DWORD PTR _channel$[ebp], 44
	add	eax, OFFSET _cl_textmessage
	mov	DWORD PTR _text$[ebp], eax

; 757  : 
; 758  : 	// NOTE: svc_finale and svc_cutscene has a
; 759  : 	// predefined settings like Quake-style
; 760  : 	text->x = -1.0f;

	mov	eax, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+12], xmm0

; 761  : 	text->y = 0.15f;

	mov	eax, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [eax+16], xmm0

; 762  : 	text->effect = 2;	// scan out effect

	mov	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR [eax], 2

; 763  : 	text->r1 = 245;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+4], 245			; 000000f5H

; 764  : 	text->g1 = 245;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+5], 245			; 000000f5H

; 765  : 	text->b1 = 245;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+6], 245			; 000000f5H

; 766  : 	text->a1 = 0;	// unused

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+7], 0

; 767  : 	text->r2 = 0;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+8], 0

; 768  : 	text->g2 = 0;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+9], 0

; 769  : 	text->b2 = 0;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+10], 0

; 770  : 	text->a2 = 0;

	mov	eax, DWORD PTR _text$[ebp]
	mov	BYTE PTR [eax+11], 0

; 771  : 	text->fadein = 0.15f;

	mov	eax, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR [eax+20], xmm0

; 772  : 	text->fadeout = 0.0f;

	mov	eax, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+24], xmm0

; 773  : 	text->holdtime = 99999.0f;

	mov	eax, DWORD PTR _text$[ebp]
	movss	xmm0, DWORD PTR __real@47c34f80
	movss	DWORD PTR [eax+28], xmm0

; 774  : 	text->fxtime = 0.0f;

	mov	eax, DWORD PTR _text$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+32], xmm0

; 775  : 
; 776  : 	// to prevent grab too long messages
; 777  : 	Q_strncpy( (char *)text->pMessage, MSG_ReadString( msg ), 2048 ); 		

	push	2048					; 00000800H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 778  : 
; 779  : 	if( *text->pMessage == '\0' )

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN2@CL_ParseFi

; 780  : 		return; // no real text

	jmp	SHORT $LN1@CL_ParseFi
$LN2@CL_ParseFi:

; 781  : 
; 782  : 	CL_HudMessage( text->pName );

	mov	eax, DWORD PTR _text$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_CL_HudMessage
	add	esp, 4
$LN1@CL_ParseFi:

; 783  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseFinaleCutscene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LinkUserMessage
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pszName$ = 8						; size = 4
_svc_num$ = 12						; size = 4
_iSize$ = 16						; size = 4
_CL_LinkUserMessage PROC				; COMDAT

; 1107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1108 : 	int	i;
; 1109 : 
; 1110 : 	if( !pszName || !*pszName )

	cmp	DWORD PTR _pszName$[ebp], 0
	je	SHORT $LN6@CL_LinkUse
	mov	eax, DWORD PTR _pszName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@CL_LinkUse
$LN6@CL_LinkUse:

; 1111 : 		Host_Error( "CL_LinkUserMessage: bad message name\n" );

	push	OFFSET ??_C@_0CG@JNEDKHCH@CL_LinkUserMessage?3?5bad?5message@
	call	_Host_Error
	add	esp, 4
$LN5@CL_LinkUse:

; 1112 : 
; 1113 : 	if( svc_num <= svc_lastmsg )

	cmp	DWORD PTR _svc_num$[ebp], 58		; 0000003aH
	jg	SHORT $LN7@CL_LinkUse

; 1114 : 		Host_Error( "CL_LinkUserMessage: tried to hook a system message \"%s\"\n", svc_strings[svc_num] );	

	mov	eax, DWORD PTR _svc_num$[ebp]
	mov	ecx, DWORD PTR _svc_strings[eax*4]
	push	ecx
	push	OFFSET ??_C@_0DJ@ELCIIEJ@CL_LinkUserMessage?3?5tried?5to?5ho@
	call	_Host_Error
	add	esp, 8
$LN7@CL_LinkUse:

; 1115 : 
; 1116 : 	// see if already hooked
; 1117 : 	for( i = 0; i < MAX_USER_MESSAGES && clgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_LinkUse
$LN2@CL_LinkUse:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_LinkUse:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN3@CL_LinkUse
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _clgame[eax+edx+1360]
	test	eax, eax
	je	SHORT $LN3@CL_LinkUse

; 1118 : 	{
; 1119 : 		// NOTE: no check for DispatchFunc, check only name
; 1120 : 		if( !Q_stricmp( clgame.msg[i].name, pszName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1360
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@CL_LinkUse

; 1121 : 		{
; 1122 : 			clgame.msg[i].number = svc_num;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR _clgame[eax+1392], ecx

; 1123 : 			clgame.msg[i].size = iSize;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _clgame[eax+1396], ecx

; 1124 : 			return;

	jmp	SHORT $LN1@CL_LinkUse
$LN8@CL_LinkUse:

; 1125 : 		}
; 1126 : 	}

	jmp	SHORT $LN2@CL_LinkUse
$LN3@CL_LinkUse:

; 1127 : 
; 1128 : 	if( i == MAX_USER_MESSAGES ) 

	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jne	SHORT $LN9@CL_LinkUse

; 1129 : 	{
; 1130 : 		Host_Error( "CL_LinkUserMessage: MAX_USER_MESSAGES hit!\n" );

	push	OFFSET ??_C@_0CM@PACFIKIG@CL_LinkUserMessage?3?5MAX_USER_ME@
	call	_Host_Error
	add	esp, 4

; 1131 : 		return;

	jmp	SHORT $LN1@CL_LinkUse
$LN9@CL_LinkUse:

; 1132 : 	}
; 1133 : 
; 1134 : 	// register new message without DispatchFunc, so we should parse it properly
; 1135 : 	Q_strncpy( clgame.msg[i].name, pszName, sizeof( clgame.msg[i].name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 44
	add	ecx, OFFSET _clgame+1360
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1136 : 	clgame.msg[i].number = svc_num;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _svc_num$[ebp]
	mov	DWORD PTR _clgame[eax+1392], ecx

; 1137 : 	clgame.msg[i].size = iSize;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _clgame[eax+1396], ecx
$LN1@CL_LinkUse:

; 1138 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_UnloadProgs
_TEXT	SEGMENT
_CL_UnloadProgs PROC					; COMDAT

; 4208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 4209 : 	if( !clgame.hInstance ) return;

	cmp	DWORD PTR _clgame, 0
	jne	SHORT $LN2@CL_UnloadP
	jmp	$LN1@CL_UnloadP
$LN2@CL_UnloadP:

; 4210 : 
; 4211 : 	CL_FreeEdicts();

	call	_CL_FreeEdicts

; 4212 : 	CL_FreeTempEnts();

	call	_CL_FreeTempEnts

; 4213 : 	CL_FreeViewBeams();

	call	_CL_FreeViewBeams

; 4214 : 	CL_FreeParticles();

	call	_CL_FreeParticles

; 4215 : 	CL_ClearAllRemaps();

	call	_CL_ClearAllRemaps

; 4216 : 	Mod_ClearUserData();

	call	_Mod_ClearUserData

; 4217 : 	VGui_Shutdown();

	call	_VGui_Shutdown

; 4218 : 
; 4219 : 	// NOTE: HLFX 0.5 has strange bug: hanging on exit if no map was loaded
; 4220 : 	if( Q_stricmp( GI->gamedir, "hlfx" ) || GI->version != 0.5f )

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04EKNDDILJ@hlfx@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@CL_UnloadP
	mov	eax, DWORD PTR _SI+768
	movss	xmm0, DWORD PTR [eax+448]
	ucomiss	xmm0, DWORD PTR __real@3f000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_UnloadP
$LN4@CL_UnloadP:

; 4221 : 		clgame.dllFuncs.pfnShutdown();

	call	DWORD PTR _clgame+108
$LN3@CL_UnloadP:

; 4222 : 
; 4223 : 	Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4224 : 	Cvar_FullSet( "host_clientloaded", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BC@CKKMCGJ@host_clientloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4225 : 
; 4226 : 	COM_FreeLibrary( clgame.hInstance );

	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4227 : 	Mem_FreePool( &cls.mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_UnloadProgs@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _cls+40
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4228 : 	Mem_FreePool( &clgame.mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_UnloadProgs@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _clgame+224
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 4229 : 	memset( &clgame, 0, sizeof( clgame ));

	push	263768					; 00040658H
	push	0
	push	OFFSET _clgame
	call	_memset
	add	esp, 12					; 0000000cH

; 4230 : 
; 4231 : 	Cvar_Unlink( FCVAR_CLIENTDLL );

	push	16					; 00000010H
	call	_Cvar_Unlink
	add	esp, 4

; 4232 : 	Cmd_Unlink( CMD_CLIENTDLL );

	push	2
	call	_Cmd_Unlink
	add	esp, 4
$LN1@CL_UnloadP:

; 4233 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UnloadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_ClearEdicts
_TEXT	SEGMENT
_CL_ClearEdicts PROC					; COMDAT

; 1215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1216 : 	if( clgame.entities != NULL )

	cmp	DWORD PTR _clgame+996, 0
	je	SHORT $LN2@CL_ClearEd

; 1217 : 		return;

	jmp	SHORT $LN1@CL_ClearEd
$LN2@CL_ClearEd:

; 1218 : 
; 1219 : 	// in case we stopped with error
; 1220 : 	clgame.maxEntities = 2;

	mov	DWORD PTR _clgame+1008, 2

; 1221 : 	CL_InitEdicts();

	call	_CL_InitEdicts
$LN1@CL_ClearEd:

; 1222 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearEdicts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_LoadProgs
_TEXT	SEGMENT
tv167 = -80						; size = 4
tv141 = -80						; size = 4
_critical_exports$ = -12				; size = 4
_GetClientAPI$ = -8					; size = 4
_func$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_LoadProgs PROC					; COMDAT

; 4236 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 4237 : 	static playermove_t		gpMove;
; 4238 : 	const dllfunc_t		*func;
; 4239 : 	CL_EXPORT_FUNCS		GetClientAPI; // single export
; 4240 : 	qboolean			critical_exports = true;

	mov	DWORD PTR _critical_exports$[ebp], 1

; 4241 : 
; 4242 : 	if( clgame.hInstance ) CL_UnloadProgs();

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN17@CL_LoadPro
	call	_CL_UnloadProgs
$LN17@CL_LoadPro:

; 4243 : 
; 4244 : 	// initialize PlayerMove
; 4245 : 	clgame.pmove = &gpMove;

	mov	DWORD PTR _clgame+1344, OFFSET ?gpMove@?1??CL_LoadProgs@@9@9

; 4246 : 
; 4247 : 	cls.mempool = Mem_AllocPool( "Client Static Pool" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_LoadProgs@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BD@LLJHHINI@Client?5Static?5Pool@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cls+40, eax

; 4248 : 	clgame.mempool = Mem_AllocPool( "Client Edicts Zone" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_LoadProgs@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@CNKFMGMJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BD@DHOCOKKI@Client?5Edicts?5Zone@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clgame+224, eax

; 4249 : 	clgame.entities = NULL;

	mov	DWORD PTR _clgame+996, 0

; 4250 : 
; 4251 : 	clgame.hInstance = COM_LoadLibrary( name, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _clgame, eax

; 4252 : 	if( !clgame.hInstance ) return false;

	cmp	DWORD PTR _clgame, 0
	jne	SHORT $LN18@CL_LoadPro
	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN18@CL_LoadPro:

; 4253 : 
; 4254 : 	// clear exports
; 4255 : 	for( func = cdll_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN4@CL_LoadPro
$LN2@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN4@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN3@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@CL_LoadPro

; 4256 : 		*func->func = NULL;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@CL_LoadPro
$LN3@CL_LoadPro:

; 4257 : 
; 4258 : 	// trying to get single export
; 4259 : 	if(( GetClientAPI = (void *)COM_GetProcAddress( clgame.hInstance, "GetClientAPI" )) != NULL )

	push	OFFSET ??_C@_0N@EHIMMPKH@GetClientAPI@
	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _GetClientAPI$[ebp], eax
	cmp	DWORD PTR _GetClientAPI$[ebp], 0
	je	SHORT $LN19@CL_LoadPro

; 4260 : 	{
; 4261 : 		Con_Reportf( "CL_LoadProgs: found single callback export\n" );		

	push	OFFSET ??_C@_0CM@BAEMLIIE@CL_LoadProgs?3?5found?5single?5call@
	call	_Con_Reportf
	add	esp, 4

; 4262 : 
; 4263 : 		// trying to fill interface now
; 4264 : 		GetClientAPI( &clgame.dllFuncs );

	push	OFFSET _clgame+4
	call	DWORD PTR _GetClientAPI$[ebp]
	add	esp, 4

; 4265 : 
; 4266 : 		// check critical functions again
; 4267 : 		for( func = cdll_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN7@CL_LoadPro
$LN5@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN7@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN6@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@CL_LoadPro

; 4268 : 		{
; 4269 : 			if( func->func == NULL )

	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN20@CL_LoadPro

; 4270 : 				break; // BAH critical function was missed

	jmp	SHORT $LN6@CL_LoadPro
$LN20@CL_LoadPro:

; 4271 : 		}

	jmp	SHORT $LN5@CL_LoadPro
$LN6@CL_LoadPro:

; 4272 : 
; 4273 : 		// because all the exports are loaded through function 'F"
; 4274 : 		if( !func || !func->name )

	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN22@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN19@CL_LoadPro
$LN22@CL_LoadPro:

; 4275 : 			critical_exports = false;

	mov	DWORD PTR _critical_exports$[ebp], 0
$LN19@CL_LoadPro:

; 4276 : 	}
; 4277 : 
; 4278 : 	for( func = cdll_exports; func && func->name != NULL; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_exports
	jmp	SHORT $LN10@CL_LoadPro
$LN8@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN10@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN9@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@CL_LoadPro

; 4279 : 	{
; 4280 : 		if( *func->func != NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN23@CL_LoadPro

; 4281 : 			continue;	// already get through 'F'

	jmp	SHORT $LN8@CL_LoadPro
$LN23@CL_LoadPro:

; 4282 : 
; 4283 : 		// functions are cleared before all the extensions are evaluated
; 4284 : 		if(( *func->func = (void *)COM_GetProcAddress( clgame.hInstance, func->name )) == NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _clgame
	push	edx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR tv141[ebp], eax
	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR tv141[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN24@CL_LoadPro

; 4285 : 		{
; 4286 :           		Con_Reportf( "CL_LoadProgs: failed to get address of %s proc\n", func->name );

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DA@DLIHFHEG@CL_LoadProgs?3?5failed?5to?5get?5add@
	call	_Con_Reportf
	add	esp, 8

; 4287 : 
; 4288 : 			if( critical_exports )

	cmp	DWORD PTR _critical_exports$[ebp], 0
	je	SHORT $LN24@CL_LoadPro

; 4289 : 			{
; 4290 : 				COM_FreeLibrary( clgame.hInstance );

	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4291 : 				clgame.hInstance = NULL;

	mov	DWORD PTR _clgame, 0

; 4292 : 				return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN24@CL_LoadPro:

; 4293 : 			}
; 4294 : 		}
; 4295 : 	}

	jmp	$LN8@CL_LoadPro
$LN9@CL_LoadPro:

; 4296 : 
; 4297 : 	// it may be loaded through 'GetClientAPI' so we don't need to clear them
; 4298 : 	if( critical_exports )

	cmp	DWORD PTR _critical_exports$[ebp], 0
	je	SHORT $LN26@CL_LoadPro

; 4299 : 	{
; 4300 : 		// clear new exports
; 4301 : 		for( func = cdll_new_exports; func && func->name; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_new_exports
	jmp	SHORT $LN13@CL_LoadPro
$LN11@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN13@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN26@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN26@CL_LoadPro

; 4302 : 			*func->func = NULL;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN11@CL_LoadPro
$LN26@CL_LoadPro:

; 4303 : 	}
; 4304 : 
; 4305 : 	for( func = cdll_new_exports; func && func->name != NULL; func++ )

	mov	DWORD PTR _func$[ebp], OFFSET _cdll_new_exports
	jmp	SHORT $LN16@CL_LoadPro
$LN14@CL_LoadPro:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN16@CL_LoadPro:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN15@CL_LoadPro
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN15@CL_LoadPro

; 4306 : 	{
; 4307 : 		if( *func->func != NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN27@CL_LoadPro

; 4308 : 			continue;	// already get through 'F'

	jmp	SHORT $LN14@CL_LoadPro
$LN27@CL_LoadPro:

; 4309 : 
; 4310 : 		// functions are cleared before all the extensions are evaluated
; 4311 : 		// NOTE: new exports can be missed without stop the engine
; 4312 : 		if(( *func->func = (void *)COM_GetProcAddress( clgame.hInstance, func->name )) == NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _clgame
	push	edx
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR tv167[ebp], eax
	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR tv167[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR tv167[ebp], 0
	jne	SHORT $LN28@CL_LoadPro

; 4313 : 			Con_Reportf( "CL_LoadProgs: failed to get address of %s proc\n", func->name );

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DA@DLIHFHEG@CL_LoadProgs?3?5failed?5to?5get?5add@
	call	_Con_Reportf
	add	esp, 8
$LN28@CL_LoadPro:

; 4314 : 	}

	jmp	SHORT $LN14@CL_LoadPro
$LN15@CL_LoadPro:

; 4315 : 
; 4316 : 	if( !clgame.dllFuncs.pfnInitialize( &gEngfuncs, CLDLL_INTERFACE_VERSION ))

	push	7
	push	OFFSET _gEngfuncs
	call	DWORD PTR _clgame+4
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@CL_LoadPro

; 4317 : 	{
; 4318 : 		COM_FreeLibrary( clgame.hInstance );

	mov	eax, DWORD PTR _clgame
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 4319 : 		Con_Reportf( "CL_LoadProgs: can't init client API\n" );

	push	OFFSET ??_C@_0CF@FEOBBBIH@CL_LoadProgs?3?5can?8t?5init?5client@
	call	_Con_Reportf
	add	esp, 4

; 4320 : 		clgame.hInstance = NULL;

	mov	DWORD PTR _clgame, 0

; 4321 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_LoadPro
$LN29@CL_LoadPro:

; 4322 : 	}
; 4323 : 
; 4324 : 	Cvar_FullSet( "host_clientloaded", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BC@CKKMCGJ@host_clientloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 4325 : 
; 4326 : 	clgame.maxRemapInfos = 0; // will be alloc on first call CL_InitEdicts();

	mov	DWORD PTR _clgame+1012, 0

; 4327 : 	clgame.maxEntities = 2; // world + localclient (have valid entities not in game)

	mov	DWORD PTR _clgame+1008, 2

; 4328 : 
; 4329 : 	CL_InitTitles( "titles.txt" );

	push	OFFSET ??_C@_0L@CFPFIGM@titles?4txt@
	call	_CL_InitTitles
	add	esp, 4

; 4330 : 	CL_InitParticles ();

	call	_CL_InitParticles

; 4331 : 	CL_InitViewBeams ();

	call	_CL_InitViewBeams

; 4332 : 	CL_InitTempEnts ();

	call	_CL_InitTempEnts

; 4333 : 
; 4334 : 	if( !R_InitRenderAPI())	// Xash3D extension

	call	_R_InitRenderAPI
	test	eax, eax
	jne	SHORT $LN30@CL_LoadPro

; 4335 : 		Con_Reportf( S_WARN "CL_LoadProgs: couldn't get render API\n" );

	push	OFFSET ??_C@_0DE@OFHCNHND@?$FO3Warning?3?$FO7?5CL_LoadProgs?3?5coul@
	call	_Con_Reportf
	add	esp, 4
$LN30@CL_LoadPro:

; 4336 : 
; 4337 : 	CL_InitEdicts ();		// initailize local player and world

	call	_CL_InitEdicts

; 4338 : 	CL_InitClientMove();	// initialize pm_shared

	call	_CL_InitClientMove

; 4339 : 
; 4340 : 	// initialize game
; 4341 : 	clgame.dllFuncs.pfnInit();

	call	DWORD PTR _clgame+8

; 4342 : 
; 4343 : 	CL_InitStudioAPI( );

	call	_CL_InitStudioAPI

; 4344 : 
; 4345 : 	// initialize VGui
; 4346 : 	VGui_Startup ();

	call	_VGui_Startup

; 4347 : 
; 4348 : 	// trying to grab them from client.dll
; 4349 : 	cl_righthand = Cvar_FindVar( "cl_righthand" );

	push	0
	push	OFFSET ??_C@_0N@BMBEGFEI@cl_righthand@
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cl_righthand, eax

; 4350 : 
; 4351 : 	if( cl_righthand == NULL )

	cmp	DWORD PTR _cl_righthand, 0
	jne	SHORT $LN31@CL_LoadPro

; 4352 : 		cl_righthand = Cvar_Get( "cl_righthand", "0", FCVAR_ARCHIVE, "flip viewmodel (left to right)" );

	push	OFFSET ??_C@_0BP@MNFFLFE@flip?5viewmodel?5?$CIleft?5to?5right?$CJ@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0N@BMBEGFEI@cl_righthand@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_righthand, eax
$LN31@CL_LoadPro:

; 4353 : 
; 4354 : 	return true;

	mov	eax, 1
$LN1@CL_LoadPro:

; 4355 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetMaxClients
_TEXT	SEGMENT
_CL_GetMaxClients PROC					; COMDAT

; 810  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 811  : 	return cl.maxclients;

	mov	eax, DWORD PTR _cl+2213004

; 812  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetMaxClients ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_HudMessage
_TEXT	SEGMENT
_pMessage$ = 8						; size = 4
_CL_HudMessage PROC					; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 683  : 	if( !COM_CheckString( pMessage )) return;

	mov	eax, DWORD PTR _pMessage$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_HudMess
	jmp	SHORT $LN1@CL_HudMess
$LN2@CL_HudMess:

; 684  : 	CL_DispatchUserMessage( "HudText", Q_strlen( pMessage ), (void *)pMessage );

	mov	eax, DWORD PTR _pMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMessage$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_07JNEKKACO@HudText@
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH
$LN1@CL_HudMess:

; 685  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_HudMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetPlayerInfo
_TEXT	SEGMENT
_playerIndex$ = 8					; size = 4
_CL_GetPlayerInfo PROC					; COMDAT

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 156  : 	if( playerIndex < 0 || playerIndex >= cl.maxclients )

	cmp	DWORD PTR _playerIndex$[ebp], 0
	jl	SHORT $LN3@CL_GetPlay
	mov	eax, DWORD PTR _playerIndex$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jl	SHORT $LN2@CL_GetPlay
$LN3@CL_GetPlay:

; 157  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetPlay
$LN2@CL_GetPlay:

; 158  : 
; 159  : 	return &cl.players[playerIndex];

	imul	eax, DWORD PTR _playerIndex$[ebp], 584
	add	eax, OFFSET _cl+2184940
$LN1@CL_GetPlay:

; 160  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetPlayerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_GetEntityByIndex
_TEXT	SEGMENT
_index$ = 8						; size = 4
_CL_GetEntityByIndex PROC				; COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 105  : 	if( !clgame.entities ) // not in game yet

	cmp	DWORD PTR _clgame+996, 0
	jne	SHORT $LN2@CL_GetEnti

; 106  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetEnti
$LN2@CL_GetEnti:

; 107  : 
; 108  : 	if( index < 0 || index >= clgame.maxEntities )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN4@CL_GetEnti
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jl	SHORT $LN3@CL_GetEnti
$LN4@CL_GetEnti:

; 109  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CL_GetEnti
$LN3@CL_GetEnti:

; 110  : 
; 111  : 	if( index == 0 )

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN5@CL_GetEnti

; 112  : 		return clgame.entities;

	mov	eax, DWORD PTR _clgame+996
	jmp	SHORT $LN1@CL_GetEnti
$LN5@CL_GetEnti:

; 113  : 
; 114  : 	return CL_EDICT_NUM( index );

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
$LN1@CL_GetEnti:

; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetEntityByIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_PointContents
_TEXT	SEGMENT
_cont$ = -4						; size = 4
_p$ = 8							; size = 4
_CL_PointContents PROC					; COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 171  : 	int cont = CL_TruePointContents( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_CL_TruePointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 172  : 
; 173  : 	if( cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _cont$[ebp], -9		; fffffff7H
	jg	SHORT $LN2@CL_PointCo
	cmp	DWORD PTR _cont$[ebp], -14		; fffffff2H
	jl	SHORT $LN2@CL_PointCo

; 174  : 		cont = CONTENTS_WATER;

	mov	DWORD PTR _cont$[ebp], -3		; fffffffdH
$LN2@CL_PointCo:

; 175  : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]

; 176  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _CL_IsThirdPerson
_TEXT	SEGMENT
_CL_IsThirdPerson PROC					; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 140  : 	cl.local.thirdperson = clgame.dllFuncs.CL_IsThirdPerson();

	call	DWORD PTR _clgame+64
	mov	DWORD PTR _cl+2212636, eax

; 141  : 
; 142  : 	if( cl.local.thirdperson )

	cmp	DWORD PTR _cl+2212636, 0
	je	SHORT $LN2@CL_IsThird

; 143  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_IsThird
$LN2@CL_IsThird:

; 144  : 	return false;

	xor	eax, eax
$LN1@CL_IsThird:

; 145  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsThirdPerson ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnDrawConsoleStringLen
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_length$ = 12						; size = 4
_height$ = 16						; size = 4
_pfnDrawConsoleStringLen PROC				; COMDAT

; 2215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2216 : 	Con_SetFont( con_fontsize->value );

	mov	eax, DWORD PTR _con_fontsize
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	call	_Con_SetFont
	add	esp, 4

; 2217 : 	Con_DrawStringLen( pText, length, height );

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	push	edx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 2218 : 	Con_RestoreFont();

	call	_Con_RestoreFont

; 2219 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawConsoleStringLen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnDrawSetTextColor
_TEXT	SEGMENT
tv133 = -72						; size = 4
tv88 = -72						; size = 4
tv75 = -72						; size = 4
tv132 = -68						; size = 4
tv87 = -68						; size = 4
tv74 = -68						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_pfnDrawSetTextColor PROC				; COMDAT

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2200 : 	// bound color and convert to byte
; 2201 : 	clgame.ds.textColor[0] = (byte)bound( 0, r * 255, 255 );

	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN5@pfnDrawSet
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN3@pfnDrawSet
	movss	xmm0, DWORD PTR _r$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN4@pfnDrawSet
$LN3@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv74[ebp], xmm0
$LN4@pfnDrawSet:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN6@pfnDrawSet
$LN5@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN6@pfnDrawSet:
	cvttss2si eax, DWORD PTR tv75[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _clgame[edx+214880], al

; 2202 : 	clgame.ds.textColor[1] = (byte)bound( 0, g * 255, 255 );

	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN9@pfnDrawSet
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@pfnDrawSet
	movss	xmm0, DWORD PTR _g$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN8@pfnDrawSet
$LN7@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv87[ebp], xmm0
$LN8@pfnDrawSet:
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN10@pfnDrawSet
$LN9@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv88[ebp], xmm0
$LN10@pfnDrawSet:
	cvttss2si eax, DWORD PTR tv88[ebp]
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _clgame[ecx+214880], al

; 2203 : 	clgame.ds.textColor[2] = (byte)bound( 0, b * 255, 255 );

	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@pfnDrawSet
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@pfnDrawSet
	movss	xmm0, DWORD PTR _b$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN12@pfnDrawSet
$LN11@pfnDrawSet:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv132[ebp], xmm0
$LN12@pfnDrawSet:
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN14@pfnDrawSet
$LN13@pfnDrawSet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv133[ebp], xmm0
$LN14@pfnDrawSet:
	cvttss2si eax, DWORD PTR tv133[ebp]
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _clgame[ecx+214880], al

; 2204 : 	clgame.ds.textColor[3] = (byte)0xFF;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _clgame[ecx+214880], 255	; 000000ffH

; 2205 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawSetTextColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_game.c
;	COMDAT _pfnDrawConsoleString
_TEXT	SEGMENT
_drawLen$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_pfnDrawConsoleString PROC				; COMDAT

; 2174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2175 : 	int	drawLen;
; 2176 : 
; 2177 : 	if( !COM_CheckString( string ))

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnDrawCon

; 2178 : 		return 0; // silent ignore

	xor	eax, eax
	jmp	$LN1@pfnDrawCon
$LN2@pfnDrawCon:

; 2179 : 	Con_SetFont( con_fontsize->value );

	mov	eax, DWORD PTR _con_fontsize
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	call	_Con_SetFont
	add	esp, 4

; 2180 : 
; 2181 : 	clgame.ds.adjust_size = true;

	mov	DWORD PTR _clgame+214868, 1

; 2182 : 	drawLen = Con_DrawString( x, y, string, clgame.ds.textColor );

	push	OFFSET _clgame+214880
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_DrawString
	add	esp, 16					; 00000010H
	mov	DWORD PTR _drawLen$[ebp], eax

; 2183 : 	MakeRGBA( clgame.ds.textColor, 255, 255, 255, 255 );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _clgame[ecx+214880], 255	; 000000ffH
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _clgame[edx+214880], 255	; 000000ffH
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _clgame[eax+214880], 255	; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _clgame[edx+214880], 255	; 000000ffH

; 2184 : 	clgame.ds.adjust_size = false;

	mov	DWORD PTR _clgame+214868, 0

; 2185 : 
; 2186 : 	Con_RestoreFont();

	call	_Con_RestoreFont

; 2187 : 
; 2188 : 	return (x + drawLen); // exclude color prexfixes

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _drawLen$[ebp]
$LN1@pfnDrawCon:

; 2189 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawConsoleString ENDP
_TEXT	ENDS
END
