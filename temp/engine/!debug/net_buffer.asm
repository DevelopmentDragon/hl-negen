; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\net_buffer.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_MSG_InitExt
PUBLIC	_MSG_InitMasks
PUBLIC	_MSG_SeekToBit
PUBLIC	_MSG_ExciseBits
PUBLIC	_MSG_CheckOverflow
PUBLIC	_MSG_BigShort
PUBLIC	_MSG_StartWriting
PUBLIC	_MSG_Clear
PUBLIC	_MSG_WriteOneBit
PUBLIC	_MSG_WriteUBitLong
PUBLIC	_MSG_WriteSBitLong
PUBLIC	_MSG_WriteBitLong
PUBLIC	_MSG_WriteBits
PUBLIC	_MSG_WriteBitAngle
PUBLIC	_MSG_WriteBitFloat
PUBLIC	_MSG_WriteBitFlag
PUBLIC	_MSG_WriteCmdExt
PUBLIC	_MSG_WriteChar
PUBLIC	_MSG_WriteByte
PUBLIC	_MSG_WriteShort
PUBLIC	_MSG_WriteWord
PUBLIC	_MSG_WriteLong
PUBLIC	_MSG_WriteFlag
PUBLIC	_MSG_WriteDword
PUBLIC	_MSG_WriteCoord
PUBLIC	_MSG_WriteFloat
PUBLIC	_MSG_WriteFloatAlt
PUBLIC	_MSG_WriteVec3Coord
PUBLIC	_MSG_WriteVec3Angles
PUBLIC	_MSG_WriteBytes
PUBLIC	_MSG_WriteString
PUBLIC	_MSG_GetMaxBytes
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_ReadOneBit
PUBLIC	_MSG_ReadBitFloat
PUBLIC	_MSG_ReadBits
PUBLIC	_MSG_ReadBitAngle
PUBLIC	_MSG_ReadSBitLong
PUBLIC	_MSG_ReadUBitLong
PUBLIC	_MSG_ReadBitLong
PUBLIC	_MSG_ReadBitFlag
PUBLIC	_MSG_ReadCmd
PUBLIC	_MSG_ReadChar
PUBLIC	_MSG_ReadByte
PUBLIC	_MSG_ReadShort
PUBLIC	_MSG_ReadWord
PUBLIC	_MSG_ReadLong
PUBLIC	_MSG_ReadFlag
PUBLIC	_MSG_ReadDword
PUBLIC	_MSG_ReadCoord
PUBLIC	_MSG_ReadFloat
PUBLIC	_MSG_ReadVec3Coord
PUBLIC	_MSG_ReadVec3Angles
PUBLIC	_MSG_ReadBytes
PUBLIC	_MSG_ReadStringExt
PUBLIC	_MSG_SeekToByte
PUBLIC	_MSG_ReadFloatAlt
PUBLIC	?__LINE__Var@?0??MSG_StartWriting@@9@9		; `MSG_StartWriting'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BJ@FBLGOBAN@?$CI?$CIdword?$CJpData?5?$CG?53?5?$CJ?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_07EMPPFCON@Unnamed@			; `string'
PUBLIC	??_C@_0BE@MJGBLALK@nBits?5?$DM?$DN?5nBytes?5?$CK?58@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_WriteUBitLong@@9@9		; `MSG_WriteUBitLong'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@EALHLEDC@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@ ; `string'
PUBLIC	??_C@_0DO@FHEHONFM@?$CI?5iDWord?5?$CK?54?5?$CL?5sizeof?$CI?5long?5?$CJ?$CJ?5@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_WriteBitFlag@@9@9		; `MSG_WriteBitFlag'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@BACGNBFP@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@ ; `string'
PUBLIC	??_C@_0DJ@CAJEBDMD@?$CIiDWord?5?$CK?54?5?$CL?5sizeof?$CIlong?$CJ?$CJ?5?$DM?$DN?5@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_WriteSBitLong@@9@9		; `MSG_WriteSBitLong'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@JHFFDEGK@numbits?5?$DO?$DN?51?5?$CG?$CG?5numbits?5?$DM?$DN?532@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_WriteBitFloat@@9@9		; `MSG_WriteBitFloat'::`1'::__LINE__Var
PUBLIC	??_C@_0CC@PBEIJHLL@sizeof?$CI?5long?5?$CJ?5?$DN?$DN?5sizeof?$CI?5float@ ; `string'
PUBLIC	??_C@_0BF@MGIFIPCH@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?54@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_ReadUBitLong@@9@9		; `MSG_ReadUBitLong'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@FPDLJEFO@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_ReadBitFloat@@9@9		; `MSG_ReadBitFloat'::`1'::__LINE__Var
PUBLIC	??_C@_0CC@HKKEEPBE@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?5sizeof?$CI?5long@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_ReadBitFlag@@9@9		; `MSG_ReadBitFlag'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@PKKPBDD@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@ ; `string'
PUBLIC	?__LINE__Var@?0??MSG_ReadFloat@@9@9		; `MSG_ReadFloat'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@CHGFMFCE@sizeof?$CI?5ret?5?$CJ?5?$DN?$DN?54@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3e000000
PUBLIC	__real@3f000000
PUBLIC	__real@4076800000000000
PUBLIC	__real@41000000
PUBLIC	__real@43340000
PUBLIC	__real@43b40000
PUBLIC	__real@c3340000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_fmod:PROC
EXTRN	__allshl:PROC
EXTRN	__aullshr:PROC
EXTRN	_host:BYTE
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_BitWriteMasks DD 0420H DUP (?)
_ExtraMasks DD	020H DUP (?)
?string@?1??MSG_ReadStringExt@@9@9 DB 0800H DUP (?)	; `MSG_ReadStringExt'::`2'::string
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BD@CHGFMFCE@sizeof?$CI?5ret?5?$CJ?5?$DN?$DN?54@
CONST	SEGMENT
??_C@_0BD@CHGFMFCE@sizeof?$CI?5ret?5?$CJ?5?$DN?$DN?54@ DB 'sizeof( ret ) '
	DB	'== 4', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_ReadFloat@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_ReadFloat@@9@9 DD 02dfH		; `MSG_ReadFloat'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@PKKPBDD@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@
CONST	SEGMENT
??_C@_0BN@PKKPBDD@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@ DB 'n'
	DB	'umbits > 0 && numbits <= 64', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_ReadBitFlag@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_ReadBitFlag@@9@9 DD 0264H		; `MSG_ReadBitFlag'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CC@HKKEEPBE@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?5sizeof?$CI?5long@
CONST	SEGMENT
??_C@_0CC@HKKEEPBE@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?5sizeof?$CI?5long@ DB 's'
	DB	'izeof( float ) == sizeof( long )', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_ReadBitFloat@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_ReadBitFloat@@9@9 DD 01fdH		; `MSG_ReadBitFloat'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@FPDLJEFO@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@
CONST	SEGMENT
??_C@_0BN@FPDLJEFO@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@ DB 'n'
	DB	'umbits > 0 && numbits <= 32', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_ReadUBitLong@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_ReadUBitLong@@9@9 DD 01cdH		; `MSG_ReadUBitLong'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@MGIFIPCH@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?54@
CONST	SEGMENT
??_C@_0BF@MGIFIPCH@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?54@ DB 'sizeof( floa'
	DB	't ) == 4', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PBEIJHLL@sizeof?$CI?5long?5?$CJ?5?$DN?$DN?5sizeof?$CI?5float@
CONST	SEGMENT
??_C@_0CC@PBEIJHLL@sizeof?$CI?5long?5?$CJ?5?$DN?$DN?5sizeof?$CI?5float@ DB 's'
	DB	'izeof( long ) == sizeof( float )', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_WriteBitFloat@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_WriteBitFloat@@9@9 DD 015bH	; `MSG_WriteBitFloat'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@JHFFDEGK@numbits?5?$DO?$DN?51?5?$CG?$CG?5numbits?5?$DM?$DN?532@
CONST	SEGMENT
??_C@_0BO@JHFFDEGK@numbits?5?$DO?$DN?51?5?$CG?$CG?5numbits?5?$DM?$DN?532@ DB 'n'
	DB	'umbits >= 1 && numbits <= 32', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_WriteSBitLong@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_WriteSBitLong@@9@9 DD 0f0H		; `MSG_WriteSBitLong'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DJ@CAJEBDMD@?$CIiDWord?5?$CK?54?5?$CL?5sizeof?$CIlong?$CJ?$CJ?5?$DM?$DN?5@
CONST	SEGMENT
??_C@_0DJ@CAJEBDMD@?$CIiDWord?5?$CK?54?5?$CL?5sizeof?$CIlong?$CJ?$CJ?5?$DM?$DN?5@ DB '('
	DB	'iDWord * 4 + sizeof(long)) <= (uint)MSG_GetMaxBytes(sb)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BACGNBFP@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@
CONST	SEGMENT
??_C@_0BO@BACGNBFP@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@ DB 'n'
	DB	'umbits >= 0 && numbits <= 64', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_WriteBitFlag@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_WriteBitFlag@@9@9 DD 0c0H		; `MSG_WriteBitFlag'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DO@FHEHONFM@?$CI?5iDWord?5?$CK?54?5?$CL?5sizeof?$CI?5long?5?$CJ?$CJ?5@
CONST	SEGMENT
??_C@_0DO@FHEHONFM@?$CI?5iDWord?5?$CK?54?5?$CL?5sizeof?$CI?5long?5?$CJ?$CJ?5@ DB '('
	DB	' iDWord * 4 + sizeof( long )) <= (uint)MSG_GetMaxBytes( sb )', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EALHLEDC@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@
CONST	SEGMENT
??_C@_0BO@EALHLEDC@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@ DB 'n'
	DB	'umbits >= 0 && numbits <= 32', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_WriteUBitLong@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_WriteUBitLong@@9@9 DD 097H		; `MSG_WriteUBitLong'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@MJGBLALK@nBits?5?$DM?$DN?5nBytes?5?$CK?58@
CONST	SEGMENT
??_C@_0BE@MJGBLALK@nBits?5?$DM?$DN?5nBytes?5?$CK?58@ DB 'nBits <= nBytes '
	DB	'* 8', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07EMPPFCON@Unnamed@
CONST	SEGMENT
??_C@_07EMPPFCON@Unnamed@ DB 'Unnamed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FBLGOBAN@?$CI?$CIdword?$CJpData?5?$CG?53?5?$CJ?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0BJ@FBLGOBAN@?$CI?$CIdword?$CJpData?5?$CG?53?5?$CJ?5?$DN?$DN?50@ DB '('
	DB	'(dword)pData & 3 ) == 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\net_buffer.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MSG_StartWriting@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MSG_StartWriting@@9@9 DD 03fH		; `MSG_StartWriting'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadFloatAlt
_TEXT	SEGMENT
tv71 = -72						; size = 4
tv70 = -68						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadFloatAlt PROC					; COMDAT

; 746  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 747  : 	return MSG_ReadSBitLong(sb, sizeof(float) << 3);

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8
	mov	DWORD PTR tv70[ebp], eax
	fild	DWORD PTR tv70[ebp]
	fstp	DWORD PTR tv71[ebp]
	fld	DWORD PTR tv71[ebp]

; 748  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadFloatAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_SeekToByte
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_bytePos$ = 12						; size = 4
_MSG_SeekToByte PROC					; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 136  : 	sb->iCurBit = bytePos << 3;

	mov	eax, DWORD PTR _bytePos$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_SeekToByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_Overflow
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_nBits$ = 12						; size = 4
_MSG_Overflow PROC					; COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 99   : 	if( sb->iCurBit + nBits > sb->nDataBits )

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _nBits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN2@MSG_Overfl

; 100  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1
$LN2@MSG_Overfl:

; 101  : 	return sb->bOverflow;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax]

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_Overflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadStringExt
_TEXT	SEGMENT
$T1 = -76						; size = 4
_c$ = -8						; size = 4
_l$ = -4						; size = 4
_sb$ = 8						; size = 4
_bLine$ = 12						; size = 4
_MSG_ReadStringExt PROC					; COMDAT

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 757  : 	static char	string[2048];
; 758  : 	int		l = 0, c;

	mov	DWORD PTR _l$[ebp], 0
$LN4@MSG_ReadSt:

; 759  : 	
; 760  : 	do
; 761  : 	{
; 762  : 		// use MSG_ReadByte so -1 is out of bounds
; 763  : 		c = MSG_ReadByte( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 764  : 
; 765  : 		if( c == 0 ) break;

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $LN5@MSG_ReadSt
	jmp	SHORT $LN3@MSG_ReadSt
	jmp	SHORT $LN6@MSG_ReadSt
$LN5@MSG_ReadSt:

; 766  : 		else if( bLine && c == '\n' )

	cmp	DWORD PTR _bLine$[ebp], 0
	je	SHORT $LN6@MSG_ReadSt
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN6@MSG_ReadSt

; 767  : 			break;

	jmp	SHORT $LN3@MSG_ReadSt
$LN6@MSG_ReadSt:

; 768  : 
; 769  : 		// translate all fmt spec to avoid crash bugs
; 770  : 		// NOTE: but game strings leave unchanged. see pfnWriteString for details
; 771  : 		if( c == '%' ) c = '.';

	cmp	DWORD PTR _c$[ebp], 37			; 00000025H
	jne	SHORT $LN8@MSG_ReadSt
	mov	DWORD PTR _c$[ebp], 46			; 0000002eH
$LN8@MSG_ReadSt:

; 772  : 
; 773  : 		string[l] = c;

	mov	eax, DWORD PTR _l$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR ?string@?1??MSG_ReadStringExt@@9@9[eax], cl

; 774  : 		l++;

	mov	eax, DWORD PTR _l$[ebp]
	add	eax, 1
	mov	DWORD PTR _l$[ebp], eax

; 775  : 	} while( l < sizeof( string ) - 1 );

	cmp	DWORD PTR _l$[ebp], 2047		; 000007ffH
	jb	SHORT $LN4@MSG_ReadSt
$LN3@MSG_ReadSt:

; 776  : 	string[l] = 0; // terminator

	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN10@MSG_ReadSt
	jmp	SHORT $LN11@MSG_ReadSt
$LN10@MSG_ReadSt:
	call	___report_rangecheckfailure
$LN11@MSG_ReadSt:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR ?string@?1??MSG_ReadStringExt@@9@9[ecx], 0

; 777  : 
; 778  : 	return string;

	mov	eax, OFFSET ?string@?1??MSG_ReadStringExt@@9@9
$LN9@MSG_ReadSt:

; 779  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadStringExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pOut$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_MSG_ReadBytes PROC					; COMDAT

; 751  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 752  : 	return MSG_ReadBits( sb, pOut, nBytes << 3 );

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_ReadBits
	add	esp, 12					; 0000000cH

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadVec3Angles
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_ReadVec3Angles PROC				; COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 713  : 	fa[0] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 714  : 	fa[1] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 715  : 	fa[2] = MSG_ReadBitAngle( sb, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadBitAngle
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadVec3Angles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadVec3Coord
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_ReadVec3Coord PROC					; COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 706  : 	fa[0] = MSG_ReadCoord( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [eax+edx]

; 707  : 	fa[1] = MSG_ReadCoord( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 708  : 	fa[2] = MSG_ReadCoord( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _fa$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 709  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadVec3Coord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadFloat
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadFloat PROC					; COMDAT

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 736  : 	float	ret;
; 737  : 
; 738  : 	Assert( sizeof( ret ) == 4 );

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_ReadFloat@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BD@CHGFMFCE@sizeof?$CI?5ret?5?$CJ?5?$DN?$DN?54@
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 739  : 
; 740  : 	MSG_ReadBits( sb, &ret, 32 );

	push	32					; 00000020H
	lea	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadBits
	add	esp, 12					; 0000000cH

; 741  : 
; 742  : 	return ret;

	fld	DWORD PTR _ret$[ebp]

; 743  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadCoord
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv85 = -68						; size = 4
tv78 = -68						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadCoord PROC					; COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 698  : 	// g-cont. we loose precision here but keep old size of coord variable!
; 699  : 	if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 1
	je	SHORT $LN2@MSG_ReadCo

; 700  : 		return (float)(MSG_ReadShort( sb ));

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	fild	DWORD PTR tv78[ebp]
	fstp	DWORD PTR tv79[ebp]
	fld	DWORD PTR tv79[ebp]
	jmp	SHORT $LN1@MSG_ReadCo
$LN2@MSG_ReadCo:

; 701  : 	return (float)(MSG_ReadShort( sb ) * ( 1.0f / 8.0f ));

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3e000000
	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]
$LN1@MSG_ReadCo:

; 702  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadDword
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadDword PROC					; COMDAT

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 731  : 	return MSG_ReadUBitLong( sb, sizeof( dword ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 732  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadDword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadFlag
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadFlag PROC					; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 726  : 	return MSG_ReadBitFlag(sb, sizeof(flag) << 3);

	push	64					; 00000040H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadBitFlag
	add	esp, 8

; 727  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadLong
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadLong PROC					; COMDAT

; 720  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 721  : 	return MSG_ReadSBitLong( sb, sizeof( long ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 722  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadWord
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadWord PROC					; COMDAT

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 693  : 	return MSG_ReadUBitLong( sb, sizeof( word ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadShort
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadShort PROC					; COMDAT

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 688  : 	return MSG_ReadSBitLong( sb, sizeof( short ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 689  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadByte
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadByte PROC					; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 683  : 	return MSG_ReadUBitLong( sb, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8

; 684  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadChar
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_ReadChar PROC					; COMDAT

; 677  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 678  : 	return MSG_ReadSBitLong( sb, sizeof( char ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadSBitLong
	add	esp, 8

; 679  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadCmd
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_sb$ = 8						; size = 4
_type$ = 12						; size = 4
_MSG_ReadCmd PROC					; COMDAT

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 661  : 	int	cmd = MSG_ReadUBitLong( sb, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 662  : 
; 663  : #ifdef DEBUG_NET_MESSAGES_READ
; 664  : 	if( type == NS_SERVER )
; 665  : 	{
; 666  : 		Con_Printf( "^1cl^7 read: %s\n", CL_MsgInfo( cmd ));
; 667  : 	}
; 668  : 	else if( cmd >= 0 && cmd <= clc_lastmsg )
; 669  : 	{
; 670  : 		Con_Printf( "^1sv^7 read: %s\n", clc_strings[cmd] );
; 671  : 	}
; 672  : #endif
; 673  : 	return cmd;

	mov	eax, DWORD PTR _cmd$[ebp]

; 674  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBitFlag
_TEXT	SEGMENT
tv83 = -92						; size = 4
_dword2$1 = -24						; size = 4
_nExtraBits$2 = -20					; size = 4
_leftBits$3 = -16					; size = 4
_ret$ = -12						; size = 4
_dword1$ = -8						; size = 4
_idword1$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadBitFlag PROC					; COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 613  : 	int	idword1;
; 614  : 	uint	dword1, ret;
; 615  : 
; 616  : 	if (numbits == 8)

	cmp	DWORD PTR _numbits$[ebp], 8
	jne	SHORT $LN2@MSG_ReadBi

; 617  : 	{
; 618  : 		int leftBits = MSG_GetNumBitsLeft(sb);

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	mov	DWORD PTR _leftBits$3[ebp], eax

; 619  : 
; 620  : 		if (leftBits >= 0 && leftBits < 8)

	cmp	DWORD PTR _leftBits$3[ebp], 0
	jl	SHORT $LN2@MSG_ReadBi
	cmp	DWORD PTR _leftBits$3[ebp], 8
	jge	SHORT $LN2@MSG_ReadBi

; 621  : 			return 0;	// end of message

	xor	eax, eax
	xor	edx, edx
	jmp	$LN1@MSG_ReadBi
$LN2@MSG_ReadBi:

; 622  : 	}
; 623  : 
; 624  : 	if ((sb->iCurBit + numbits) > sb->nDataBits)

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN4@MSG_ReadBi

; 625  : 	{
; 626  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1

; 627  : 		sb->iCurBit = sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx

; 628  : 		return 0;

	xor	eax, eax
	xor	edx, edx
	jmp	$LN1@MSG_ReadBi
$LN4@MSG_ReadBi:

; 629  : 	}
; 630  : 
; 631  : 	Assert(numbits > 0 && numbits <= 64);

	cmp	DWORD PTR _numbits$[ebp], 0
	jle	SHORT $LN9@MSG_ReadBi
	cmp	DWORD PTR _numbits$[ebp], 64		; 00000040H
	jg	SHORT $LN9@MSG_ReadBi
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN10@MSG_ReadBi
$LN9@MSG_ReadBi:
	mov	DWORD PTR tv83[ebp], 0
$LN10@MSG_ReadBi:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_ReadBitFlag@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BN@PKKPBDD@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@
	mov	ecx, DWORD PTR tv83[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 632  : 
; 633  : 	// Read the current dword.
; 634  : 	idword1 = sb->iCurBit >> 5;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	mov	DWORD PTR _idword1$[ebp], ecx

; 635  : 	dword1 = ((uint*)sb->pData)[idword1];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _idword1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dword1$[ebp], eax

; 636  : 	dword1 >>= (sb->iCurBit & 63);	// get the bits we're interested in.

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _dword1$[ebp]
	shr	edx, cl
	mov	DWORD PTR _dword1$[ebp], edx

; 637  : 
; 638  : 	sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 639  : 	ret = dword1;

	mov	eax, DWORD PTR _dword1$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 640  : 
; 641  : 	// Does it span this dword?
; 642  : 	if ((sb->iCurBit - 1) >> 5 == idword1)

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	sar	ecx, 5
	cmp	ecx, DWORD PTR _idword1$[ebp]
	jne	SHORT $LN5@MSG_ReadBi

; 643  : 	{
; 644  : 		if (numbits != 63)

	cmp	DWORD PTR _numbits$[ebp], 63		; 0000003fH
	je	SHORT $LN7@MSG_ReadBi

; 645  : 			ret &= ExtraMasks[numbits];

	mov	eax, DWORD PTR _numbits$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	and	ecx, DWORD PTR _ExtraMasks[eax*4]
	mov	DWORD PTR _ret$[ebp], ecx
$LN7@MSG_ReadBi:

; 646  : 	}

	jmp	SHORT $LN6@MSG_ReadBi
$LN5@MSG_ReadBi:

; 647  : 	else
; 648  : 	{
; 649  : 		int	nExtraBits = sb->iCurBit & 63;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _nExtraBits$2[ebp], ecx

; 650  : 		uint	dword2 = ((uint*)sb->pData)[idword1 + 1] & ExtraMasks[nExtraBits];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _idword1$[ebp]
	mov	eax, DWORD PTR _nExtraBits$2[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	and	ecx, DWORD PTR _ExtraMasks[eax*4]
	mov	DWORD PTR _dword2$1[ebp], ecx

; 651  : 
; 652  : 		// no need to mask since we hit the end of the dword.
; 653  : 		// shift the second dword's part into the high bits.
; 654  : 		ret |= (dword2 << (numbits - nExtraBits));

	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, DWORD PTR _nExtraBits$2[ebp]
	mov	eax, DWORD PTR _dword2$1[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN6@MSG_ReadBi:

; 655  : 	}
; 656  : 	return ret;

	xor	edx, edx
	mov	eax, DWORD PTR _ret$[ebp]
$LN1@MSG_ReadBi:

; 657  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBitLong
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_bSigned$ = 16						; size = 4
_MSG_ReadBitLong PROC					; COMDAT

; 605  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 606  : 	if( bSigned )

	cmp	DWORD PTR _bSigned$[ebp], 0
	je	SHORT $LN2@MSG_ReadBi

; 607  : 		return (uint)MSG_ReadSBitLong( sb, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadSBitLong
	add	esp, 8
	jmp	SHORT $LN1@MSG_ReadBi
$LN2@MSG_ReadBi:

; 608  : 	return MSG_ReadUBitLong( sb, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
$LN1@MSG_ReadBi:

; 609  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadUBitLong
_TEXT	SEGMENT
tv83 = -92						; size = 4
_dword2$1 = -24						; size = 4
_nExtraBits$2 = -20					; size = 4
_leftBits$3 = -16					; size = 4
_ret$ = -12						; size = 4
_dword1$ = -8						; size = 4
_idword1$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadUBitLong PROC					; COMDAT

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 462  : 	int	idword1;
; 463  : 	uint	dword1, ret;
; 464  : 
; 465  : 	if( numbits == 8 )

	cmp	DWORD PTR _numbits$[ebp], 8
	jne	SHORT $LN2@MSG_ReadUB

; 466  : 	{
; 467  : 		int leftBits = MSG_GetNumBitsLeft( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	mov	DWORD PTR _leftBits$3[ebp], eax

; 468  : 
; 469  : 		if( leftBits >= 0 && leftBits < 8 )

	cmp	DWORD PTR _leftBits$3[ebp], 0
	jl	SHORT $LN2@MSG_ReadUB
	cmp	DWORD PTR _leftBits$3[ebp], 8
	jge	SHORT $LN2@MSG_ReadUB

; 470  : 			return 0;	// end of message

	xor	eax, eax
	jmp	$LN1@MSG_ReadUB
$LN2@MSG_ReadUB:

; 471  : 	}
; 472  : 
; 473  : 	if(( sb->iCurBit + numbits ) > sb->nDataBits )

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN4@MSG_ReadUB

; 474  : 	{
; 475  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1

; 476  : 		sb->iCurBit = sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx

; 477  : 		return 0;

	xor	eax, eax
	jmp	$LN1@MSG_ReadUB
$LN4@MSG_ReadUB:

; 478  : 	}
; 479  : 
; 480  : 	Assert( numbits > 0 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 0
	jle	SHORT $LN9@MSG_ReadUB
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN9@MSG_ReadUB
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN10@MSG_ReadUB
$LN9@MSG_ReadUB:
	mov	DWORD PTR tv83[ebp], 0
$LN10@MSG_ReadUB:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_ReadUBitLong@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BN@FPDLJEFO@numbits?5?$DO?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@
	mov	ecx, DWORD PTR tv83[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 481  : 
; 482  : 	// Read the current dword.
; 483  : 	idword1 = sb->iCurBit >> 5;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	mov	DWORD PTR _idword1$[ebp], ecx

; 484  : 	dword1 = ((uint *)sb->pData)[idword1];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _idword1$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _dword1$[ebp], eax

; 485  : 	dword1 >>= ( sb->iCurBit & 31 );	// get the bits we're interested in.

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 31					; 0000001fH
	mov	edx, DWORD PTR _dword1$[ebp]
	shr	edx, cl
	mov	DWORD PTR _dword1$[ebp], edx

; 486  : 
; 487  : 	sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 488  : 	ret = dword1;

	mov	eax, DWORD PTR _dword1$[ebp]
	mov	DWORD PTR _ret$[ebp], eax

; 489  : 
; 490  : 	// Does it span this dword?
; 491  : 	if(( sb->iCurBit - 1 ) >> 5 == idword1 )

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	sar	ecx, 5
	cmp	ecx, DWORD PTR _idword1$[ebp]
	jne	SHORT $LN5@MSG_ReadUB

; 492  : 	{
; 493  : 		if( numbits != 32 )

	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	je	SHORT $LN7@MSG_ReadUB

; 494  : 			ret &= ExtraMasks[numbits];

	mov	eax, DWORD PTR _numbits$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	and	ecx, DWORD PTR _ExtraMasks[eax*4]
	mov	DWORD PTR _ret$[ebp], ecx
$LN7@MSG_ReadUB:

; 495  : 	}

	jmp	SHORT $LN6@MSG_ReadUB
$LN5@MSG_ReadUB:

; 496  : 	else
; 497  : 	{
; 498  : 		int	nExtraBits = sb->iCurBit & 31;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _nExtraBits$2[ebp], ecx

; 499  : 		uint	dword2 = ((uint *)sb->pData)[idword1+1] & ExtraMasks[nExtraBits];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _idword1$[ebp]
	mov	eax, DWORD PTR _nExtraBits$2[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	and	ecx, DWORD PTR _ExtraMasks[eax*4]
	mov	DWORD PTR _dword2$1[ebp], ecx

; 500  : 		
; 501  : 		// no need to mask since we hit the end of the dword.
; 502  : 		// shift the second dword's part into the high bits.
; 503  : 		ret |= (dword2 << ( numbits - nExtraBits ));

	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, DWORD PTR _nExtraBits$2[ebp]
	mov	eax, DWORD PTR _dword2$1[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN6@MSG_ReadUB:

; 504  : 	}
; 505  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]
$LN1@MSG_ReadUB:

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadUBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadSBitLong
_TEXT	SEGMENT
_sign$ = -8						; size = 4
_r$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadSBitLong PROC					; COMDAT

; 591  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 592  : 	int	r, sign;
; 593  : 
; 594  : 	r = MSG_ReadUBitLong( sb, numbits - 1 );

	mov	eax, DWORD PTR _numbits$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 595  : 
; 596  : 	// NOTE: it does this wierdness here so it's bit-compatible with regular integer data in the buffer.
; 597  : 	// (Some old code writes direct integers right into the buffer).
; 598  : 	sign = MSG_ReadOneBit( sb );

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	mov	DWORD PTR _sign$[ebp], eax

; 599  : 	if( sign ) r = -( BIT( numbits - 1 ) - r );

	cmp	DWORD PTR _sign$[ebp], 0
	je	SHORT $LN2@MSG_ReadSB
	mov	ecx, DWORD PTR _numbits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	sub	eax, DWORD PTR _r$[ebp]
	neg	eax
	mov	DWORD PTR _r$[ebp], eax
$LN2@MSG_ReadSB:

; 600  : 
; 601  : 	return r;

	mov	eax, DWORD PTR _r$[ebp]

; 602  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadSBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBitAngle
_TEXT	SEGMENT
_i$ = -12						; size = 4
_shift$ = -8						; size = 4
_fReturn$ = -4						; size = 4
_sb$ = 8						; size = 4
_numbits$ = 12						; size = 4
_MSG_ReadBitAngle PROC					; COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 574  : 	float	fReturn, shift;
; 575  : 	int	i;
; 576  : 
; 577  : 	shift = (float)( 1 << numbits );

	mov	eax, 1
	mov	ecx, DWORD PTR _numbits$[ebp]
	shl	eax, cl
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _shift$[ebp], xmm0

; 578  : 
; 579  : 	i = MSG_ReadUBitLong( sb, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax

; 580  : 	fReturn = (float)i * ( 360.0f / shift );

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	movss	xmm1, DWORD PTR __real@43b40000
	divss	xmm1, DWORD PTR _shift$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR _fReturn$[ebp], xmm0

; 581  : 
; 582  : 	// clamp the finale angle
; 583  : 	if( fReturn < -180.0f ) fReturn += 360.0f; 

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _fReturn$[ebp]
	jbe	SHORT $LN2@MSG_ReadBi
	movss	xmm0, DWORD PTR _fReturn$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fReturn$[ebp], xmm0
	jmp	SHORT $LN4@MSG_ReadBi
$LN2@MSG_ReadBi:

; 584  : 	else if( fReturn > 180.0f ) fReturn -= 360.0f;

	movss	xmm0, DWORD PTR _fReturn$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN4@MSG_ReadBi
	movss	xmm0, DWORD PTR _fReturn$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fReturn$[ebp], xmm0
$LN4@MSG_ReadBi:

; 585  : 
; 586  : 	return fReturn;

	fld	DWORD PTR _fReturn$[ebp]

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBits
_TEXT	SEGMENT
tv93 = -76						; size = 4
_nBitsLeft$ = -8					; size = 4
_pOut$ = -4						; size = 4
_sb$ = 8						; size = 4
_pOutData$ = 12						; size = 4
_nBits$ = 16						; size = 4
_MSG_ReadBits PROC					; COMDAT

; 535  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 536  : 	byte	*pOut = (byte *)pOutData;

	mov	eax, DWORD PTR _pOutData$[ebp]
	mov	DWORD PTR _pOut$[ebp], eax

; 537  : 	int	nBitsLeft = nBits;

	mov	eax, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR _nBitsLeft$[ebp], eax
$LN2@MSG_ReadBi:

; 538  : 	
; 539  : 	// get output dword-aligned.
; 540  : 	while((( dword )pOut & 3) != 0 && nBitsLeft >= 8 )

	mov	eax, DWORD PTR _pOut$[ebp]
	and	eax, 3
	je	SHORT $LN4@MSG_ReadBi
	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN4@MSG_ReadBi

; 541  : 	{
; 542  : 		*pOut = (byte)MSG_ReadUBitLong( sb, 8 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [ecx], al

; 543  : 		++pOut;

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOut$[ebp], eax

; 544  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 545  : 	}

	jmp	SHORT $LN2@MSG_ReadBi
$LN4@MSG_ReadBi:

; 546  : 
; 547  : 	// read dwords.
; 548  : 	while( nBitsLeft >= 32 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 32		; 00000020H
	jl	SHORT $LN6@MSG_ReadBi

; 549  : 	{
; 550  : 		*((dword *)pOut) = MSG_ReadUBitLong( sb, 32 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	DWORD PTR [ecx], eax

; 551  : 		pOut += sizeof( dword );

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 4
	mov	DWORD PTR _pOut$[ebp], eax

; 552  : 		nBitsLeft -= 32;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 553  : 	}

	jmp	SHORT $LN4@MSG_ReadBi
$LN6@MSG_ReadBi:

; 554  : 
; 555  : 	// read the remaining bytes.
; 556  : 	while( nBitsLeft >= 8 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN7@MSG_ReadBi

; 557  : 	{
; 558  : 		*pOut = MSG_ReadUBitLong( sb, 8 );

	push	8
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	ecx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [ecx], al

; 559  : 		++pOut;

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOut$[ebp], eax

; 560  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 561  : 	}

	jmp	SHORT $LN6@MSG_ReadBi
$LN7@MSG_ReadBi:

; 562  : 	
; 563  : 	// read the remaining bits.
; 564  : 	if( nBitsLeft )

	cmp	DWORD PTR _nBitsLeft$[ebp], 0
	je	SHORT $LN8@MSG_ReadBi

; 565  : 	{
; 566  : 		*pOut = MSG_ReadUBitLong( sb, nBitsLeft );

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	edx, DWORD PTR _pOut$[ebp]
	mov	BYTE PTR [edx], al
$LN8@MSG_ReadBi:

; 567  : 	}
; 568  : 
; 569  : 	return !sb->bOverflow;

	mov	eax, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@MSG_ReadBi
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN11@MSG_ReadBi
$LN10@MSG_ReadBi:
	mov	DWORD PTR tv93[ebp], 0
$LN11@MSG_ReadBi:
	mov	eax, DWORD PTR tv93[ebp]

; 570  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadBitFloat
_TEXT	SEGMENT
_byte$ = -12						; size = 4
_bit$ = -8						; size = 4
_val$ = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadBitFloat PROC					; COMDAT

; 509  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 510  : 	long	val;
; 511  : 	int	bit, byte;
; 512  : 
; 513  : 	Assert( sizeof( float ) == sizeof( long ));

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_ReadBitFloat@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CC@HKKEEPBE@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?5sizeof?$CI?5long@
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 514  : 	Assert( sizeof( float ) == 4 );

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_ReadBitFloat@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BF@MGIFIPCH@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?54@
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 515  : 
; 516  : 	if( MSG_Overflow( sb, 32 ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@MSG_ReadBi

; 517  : 		return 0.0f;

	fldz
	jmp	$LN1@MSG_ReadBi
$LN2@MSG_ReadBi:

; 518  : 
; 519  : 	bit = sb->iCurBit & 0x7;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 7
	mov	DWORD PTR _bit$[ebp], ecx

; 520  : 	byte = sb->iCurBit >> 3;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	DWORD PTR _byte$[ebp], ecx

; 521  : 
; 522  : 	val = sb->pData[byte] >> bit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _bit$[ebp]
	sar	eax, cl
	mov	DWORD PTR _val$[ebp], eax

; 523  : 	val |= ((int)sb->pData[byte + 1]) << ( 8 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+1]
	mov	ecx, 8
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 524  : 	val |= ((int)sb->pData[byte + 2]) << ( 16 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+2]
	mov	ecx, 16					; 00000010H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 525  : 	val |= ((int)sb->pData[byte + 3]) << ( 24 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+3]
	mov	ecx, 24					; 00000018H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 526  : 
; 527  : 	if( bit != 0 )

	cmp	DWORD PTR _bit$[ebp], 0
	je	SHORT $LN3@MSG_ReadBi

; 528  : 		val |= ((int)sb->pData[byte + 4]) << ( 32 - bit );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _byte$[ebp]
	movzx	eax, BYTE PTR [ecx+edx+4]
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bit$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax
$LN3@MSG_ReadBi:

; 529  : 	sb->iCurBit += 32;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 530  : 
; 531  : 	return *((float *)&val);

	fld	DWORD PTR _val$[ebp]
$LN1@MSG_ReadBi:

; 532  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadBitFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ReadOneBit
_TEXT	SEGMENT
tv83 = -72						; size = 4
_value$1 = -4						; size = 4
_sb$ = 8						; size = 4
_MSG_ReadOneBit PROC					; COMDAT

; 450  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 451  : 	if( !MSG_Overflow( sb, 1 ))

	push	1
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@MSG_ReadOn

; 452  : 	{
; 453  : 		int value = sb->pData[sb->iCurBit >> 3] & (1 << ( sb->iCurBit & 7 ));

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	mov	DWORD PTR _value$1[ebp], edx

; 454  : 		sb->iCurBit++;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 455  : 		return !!value;

	cmp	DWORD PTR _value$1[ebp], 0
	je	SHORT $LN4@MSG_ReadOn
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN5@MSG_ReadOn
$LN4@MSG_ReadOn:
	mov	DWORD PTR tv83[ebp], 0
$LN5@MSG_ReadOn:
	mov	eax, DWORD PTR tv83[ebp]
	jmp	SHORT $LN1@MSG_ReadOn
$LN2@MSG_ReadOn:

; 456  : 	}
; 457  : 	return 0;

	xor	eax, eax
$LN1@MSG_ReadOn:

; 458  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ReadOneBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetMaxBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetMaxBytes PROC					; COMDAT

; 106  : _inline int MSG_GetMaxBytes( sizebuf_t *sb ) { return sb->nDataBits >> 3; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetMaxBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteString
_TEXT	SEGMENT
tv76 = -68						; size = 4
_sb$ = 8						; size = 4
_pStr$ = 12						; size = 4
_MSG_WriteString PROC					; COMDAT

; 435  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 436  : 	if( pStr )

	cmp	DWORD PTR _pStr$[ebp], 0
	je	SHORT $LN5@MSG_WriteS
$LN4@MSG_WriteS:

; 437  : 	{
; 438  : 		do
; 439  : 		{
; 440  : 			MSG_WriteChar( sb, *pStr );

	mov	eax, DWORD PTR _pStr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteChar
	add	esp, 8

; 441  : 			pStr++;

	mov	eax, DWORD PTR _pStr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pStr$[ebp], eax

; 442  : 		} while( *( pStr - 1 ));

	mov	eax, DWORD PTR _pStr$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	test	ecx, ecx
	jne	SHORT $LN4@MSG_WriteS

; 443  : 	}

	jmp	SHORT $LN6@MSG_WriteS
$LN5@MSG_WriteS:

; 444  : 	else MSG_WriteChar( sb, 0 );

	push	0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8
$LN6@MSG_WriteS:

; 445  : 	
; 446  : 	return !sb->bOverflow;

	mov	eax, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@MSG_WriteS
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN9@MSG_WriteS
$LN8@MSG_WriteS:
	mov	DWORD PTR tv76[ebp], 0
$LN9@MSG_WriteS:
	mov	eax, DWORD PTR tv76[ebp]

; 447  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBytes
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pBuf$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_MSG_WriteBytes PROC					; COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 431  : 	return MSG_WriteBits( sb, pBuf, nBytes << 3 );

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 432  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteVec3Angles
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_WriteVec3Angles PROC				; COMDAT

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 341  : 	MSG_WriteBitAngle( sb, fa[0], 16 );

	push	16					; 00000010H
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 342  : 	MSG_WriteBitAngle( sb, fa[1], 16 );

	push	16					; 00000010H
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 343  : 	MSG_WriteBitAngle( sb, fa[2], 16 );

	push	16					; 00000010H
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteBitAngle
	add	esp, 12					; 0000000cH

; 344  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteVec3Angles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteVec3Coord
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_fa$ = 12						; size = 4
_MSG_WriteVec3Coord PROC				; COMDAT

; 333  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 334  : 	MSG_WriteCoord( sb, fa[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteCoord
	add	esp, 8

; 335  : 	MSG_WriteCoord( sb, fa[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteCoord
	add	esp, 8

; 336  : 	MSG_WriteCoord( sb, fa[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _fa$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteCoord
	add	esp, 8

; 337  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteVec3Coord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteFloatAlt
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteFloatAlt PROC					; COMDAT

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 426  : 	MSG_WriteSBitLong(sb, &val, sizeof(float) << 3);

	push	32					; 00000020H
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteFloatAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteFloat
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteFloat PROC					; COMDAT

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 421  : 	MSG_WriteBits( sb, &val, sizeof( val ) << 3 );

	push	32					; 00000020H
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 422  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteCoord
_TEXT	SEGMENT
tv73 = -68						; size = 4
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteCoord PROC					; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 326  : 	// g-cont. we loose precision here but keep old size of coord variable!
; 327  : 	if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 1
	je	SHORT $LN2@MSG_WriteC

; 328  : 		MSG_WriteShort( sb, Q_rint( val ));

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _val$[ebp]
	jbe	SHORT $LN5@MSG_WriteC
	movss	xmm0, DWORD PTR _val$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN6@MSG_WriteC
$LN5@MSG_WriteC:
	movss	xmm0, DWORD PTR _val$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR tv73[ebp], ecx
$LN6@MSG_WriteC:
	mov	edx, DWORD PTR tv73[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteShort
	add	esp, 8
	jmp	SHORT $LN3@MSG_WriteC
$LN2@MSG_WriteC:

; 329  : 	else MSG_WriteShort( sb, (int)( val * 8.0f ));

	movss	xmm0, DWORD PTR _val$[ebp]
	mulss	xmm0, DWORD PTR __real@41000000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteShort
	add	esp, 8
$LN3@MSG_WriteC:

; 330  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteCoord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteDword
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteDword PROC					; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 416  : 	MSG_WriteUBitLong( sb, val, sizeof( dword ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 417  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteDword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteFlag
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 8
_MSG_WriteFlag PROC					; COMDAT

; 410  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 411  : 	MSG_WriteBitFlag(sb, val, sizeof(flag) << 3);

	push	64					; 00000040H
	mov	eax, DWORD PTR _val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteBitFlag
	add	esp, 16					; 00000010H

; 412  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteLong
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteLong PROC					; COMDAT

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 406  : 	MSG_WriteSBitLong( sb, val, sizeof( long ) << 3 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 407  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteWord
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteWord PROC					; COMDAT

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 401  : 	MSG_WriteUBitLong( sb, val, sizeof( word ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 402  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteShort
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteShort PROC					; COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 396  : 	MSG_WriteSBitLong( sb, val, sizeof(short ) << 3 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteByte
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteByte PROC					; COMDAT

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 391  : 	MSG_WriteUBitLong( sb, val, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteChar
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteChar PROC					; COMDAT

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 386  : 	MSG_WriteSBitLong( sb, val, sizeof( char ) << 3 );

	push	8
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteCmdExt
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_cmd$ = 12						; size = 4
_type$ = 16						; size = 4
_name$ = 20						; size = 4
_MSG_WriteCmdExt PROC					; COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 359  : #ifdef DEBUG_NET_MESSAGES_SEND
; 360  : 	if( name != NULL )
; 361  : 	{
; 362  : 		// get custom name
; 363  : 		Con_Printf( "^1sv^7 write: %s\n", name );
; 364  : 	}
; 365  : 	else if( type == NS_SERVER )
; 366  : 	{
; 367  : 		if( cmd >= 0 && cmd <= svc_lastmsg )
; 368  : 		{
; 369  : 			// get engine message name
; 370  : 			Con_Printf( "^1sv^7 write: %s\n", svc_strings[cmd] );
; 371  : 		}
; 372  : 	}
; 373  : 	else if( type == NS_CLIENT )
; 374  : 	{
; 375  : 		if( cmd >= 0 && cmd <= clc_lastmsg )
; 376  : 		{
; 377  : 			Con_Printf( "^1cl^7 write: %s\n", clc_strings[cmd] );
; 378  : 		}
; 379  : 	}
; 380  : #endif
; 381  : 	MSG_WriteUBitLong( sb, cmd, sizeof( byte ) << 3 );

	push	8
	mov	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteCmdExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBitFlag
_TEXT	SEGMENT
tv92 = -88						; size = 4
tv71 = -88						; size = 4
_nBitsWritten$1 = -20					; size = 4
_iCurBitMasked$2 = -16					; size = 4
_iDWord$3 = -12						; size = 4
_iCurBit$4 = -8						; size = 4
_nBitsLeft$5 = -4					; size = 4
_sb$ = 8						; size = 4
_curData$ = 12						; size = 8
_numbits$ = 20						; size = 4
_MSG_WriteBitFlag PROC					; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 193  : 	Assert(numbits >= 0 && numbits <= 64);

	cmp	DWORD PTR _numbits$[ebp], 0
	jl	SHORT $LN6@MSG_WriteB
	cmp	DWORD PTR _numbits$[ebp], 64		; 00000040H
	jg	SHORT $LN6@MSG_WriteB
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN7@MSG_WriteB
$LN6@MSG_WriteB:
	mov	DWORD PTR tv71[ebp], 0
$LN7@MSG_WriteB:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_WriteBitFlag@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BO@BACGNBFP@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?564@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 194  : 
; 195  : 	// bounds checking..
; 196  : 	if ((sb->iCurBit + numbits) > sb->nDataBits)

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN2@MSG_WriteB

; 197  : 	{
; 198  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1

; 199  : 		sb->iCurBit = sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx

; 200  : 	}

	jmp	$LN1@MSG_WriteB
$LN2@MSG_WriteB:

; 201  : 	else
; 202  : 	{
; 203  : 		int	nBitsLeft = numbits;

	mov	eax, DWORD PTR _numbits$[ebp]
	mov	DWORD PTR _nBitsLeft$5[ebp], eax

; 204  : 		int	iCurBit = sb->iCurBit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iCurBit$4[ebp], ecx

; 205  : 		uint	iDWord = iCurBit >> 5;	// Mask in a dword.

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	sar	eax, 5
	mov	DWORD PTR _iDWord$3[ebp], eax

; 206  : 		dword	iCurBitMasked;
; 207  : 		int	nBitsWritten;
; 208  : 
; 209  : 		Assert((iDWord * 4 + sizeof(long)) <= (uint)MSG_GetMaxBytes(sb));

	mov	eax, DWORD PTR _iDWord$3[ebp]
	lea	esi, DWORD PTR [eax*4+4]
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	esi, eax
	ja	SHORT $LN8@MSG_WriteB
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN9@MSG_WriteB
$LN8@MSG_WriteB:
	mov	DWORD PTR tv92[ebp], 0
$LN9@MSG_WriteB:
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??MSG_WriteBitFlag@@9@9
	add	edx, 17					; 00000011H
	push	edx
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0DJ@CAJEBDMD@?$CIiDWord?5?$CK?54?5?$CL?5sizeof?$CIlong?$CJ?$CJ?5?$DM?$DN?5@
	mov	eax, DWORD PTR tv92[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 210  : 
; 211  : 		iCurBitMasked = iCurBit & 63;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _iCurBitMasked$2[ebp], eax

; 212  : 		((dword*)sb->pData)[iDWord] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR _iCurBitMasked$2[ebp], 132
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	esi, DWORD PTR _nBitsLeft$5[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	and	ecx, DWORD PTR _BitWriteMasks[edx+esi*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 213  : 		((dword*)sb->pData)[iDWord] |= curData << iCurBitMasked;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	edx, DWORD PTR _curData$[ebp+4]
	mov	ecx, DWORD PTR _iCurBitMasked$2[ebp]
	call	__allshl
	mov	ecx, DWORD PTR _iDWord$3[ebp]
	mov	edx, DWORD PTR [esi+ecx*4]
	or	edx, eax
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 214  : 
; 215  : 		// did it span a dword?
; 216  : 		nBitsWritten = 32 - iCurBitMasked;

	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR _iCurBitMasked$2[ebp]
	mov	DWORD PTR _nBitsWritten$1[ebp], eax

; 217  : 
; 218  : 		if (nBitsWritten < nBitsLeft)

	mov	eax, DWORD PTR _nBitsWritten$1[ebp]
	cmp	eax, DWORD PTR _nBitsLeft$5[ebp]
	jge	$LN4@MSG_WriteB

; 219  : 		{
; 220  : 			nBitsLeft -= nBitsWritten;

	mov	eax, DWORD PTR _nBitsLeft$5[ebp]
	sub	eax, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _nBitsLeft$5[ebp], eax

; 221  : 			iCurBit += nBitsWritten;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	add	eax, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _iCurBit$4[ebp], eax

; 222  : 			curData >>= nBitsWritten;

	mov	eax, DWORD PTR _curData$[ebp]
	mov	edx, DWORD PTR _curData$[ebp+4]
	mov	ecx, DWORD PTR _nBitsWritten$1[ebp]
	call	__aullshr
	mov	DWORD PTR _curData$[ebp], eax
	mov	DWORD PTR _curData$[ebp+4], edx

; 223  : 
; 224  : 			iCurBitMasked = iCurBit & 63;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _iCurBitMasked$2[ebp], eax

; 225  : 			((dword*)sb->pData)[iDWord + 1] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR _iCurBitMasked$2[ebp], 132
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	esi, DWORD PTR _nBitsLeft$5[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	and	ecx, DWORD PTR _BitWriteMasks[edx+esi*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 226  : 			((dword*)sb->pData)[iDWord + 1] |= curData << iCurBitMasked;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	edx, DWORD PTR _curData$[ebp+4]
	mov	ecx, DWORD PTR _iCurBitMasked$2[ebp]
	call	__allshl
	mov	ecx, DWORD PTR _iDWord$3[ebp]
	mov	edx, DWORD PTR [esi+ecx*4+4]
	or	edx, eax
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx
$LN4@MSG_WriteB:

; 227  : 		}
; 228  : 		sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN1@MSG_WriteB:

; 229  : 	}
; 230  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBitFloat
_TEXT	SEGMENT
_intVal$ = -4						; size = 4
_sb$ = 8						; size = 4
_val$ = 12						; size = 4
_MSG_WriteBitFloat PROC					; COMDAT

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 348  : 	long	intVal;
; 349  : 
; 350  : 	Assert( sizeof( long ) == sizeof( float ));

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_WriteBitFloat@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CC@PBEIJHLL@sizeof?$CI?5long?5?$CJ?5?$DN?$DN?5sizeof?$CI?5float@
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 351  : 	Assert( sizeof( float ) == 4 );

	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_WriteBitFloat@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BF@MGIFIPCH@sizeof?$CI?5float?5?$CJ?5?$DN?$DN?54@
	push	1
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 352  : 
; 353  : 	intVal = *((long *)&val );

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _intVal$[ebp], eax

; 354  : 	MSG_WriteUBitLong( sb, intVal, 32 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _intVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBitAngle
_TEXT	SEGMENT
tv131 = -88						; size = 8
tv95 = -80						; size = 4
_d$ = -12						; size = 4
_shift$ = -8						; size = 4
_mask$ = -4						; size = 4
_sb$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteBitAngle PROC					; COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 308  : 	uint	mask, shift;
; 309  : 	int	d;
; 310  : 
; 311  : 	// clamp the angle before receiving
; 312  : 	fAngle = fmod( fAngle, 360.0f );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _fAngle$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _fAngle$[ebp]

; 313  : 	if( fAngle < 0 ) fAngle += 360.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _fAngle$[ebp]
	jbe	SHORT $LN2@MSG_WriteB
	movss	xmm0, DWORD PTR _fAngle$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _fAngle$[ebp], xmm0
$LN2@MSG_WriteB:

; 314  : 
; 315  : 	shift = ( 1 << numbits );

	mov	eax, 1
	mov	ecx, DWORD PTR _numbits$[ebp]
	shl	eax, cl
	mov	DWORD PTR _shift$[ebp], eax

; 316  : 	mask = shift - 1;

	mov	eax, DWORD PTR _shift$[ebp]
	sub	eax, 1
	mov	DWORD PTR _mask$[ebp], eax

; 317  : 
; 318  : 	d = (int)(( fAngle * shift ) / 360.0f );

	mov	eax, DWORD PTR _shift$[ebp]
	mov	DWORD PTR tv95[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv95[ebp]
	mov	ecx, DWORD PTR tv95[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv131[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv131[ebp]
	mulss	xmm0, DWORD PTR _fAngle$[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si edx, xmm0
	mov	DWORD PTR _d$[ebp], edx

; 319  : 	d &= mask;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 320  : 
; 321  : 	MSG_WriteUBitLong( sb, (uint)d, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 322  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitAngle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBits
_TEXT	SEGMENT
tv93 = -76						; size = 4
_nBitsLeft$ = -8					; size = 4
_pOut$ = -4						; size = 4
_sb$ = 8						; size = 4
_pData$ = 12						; size = 4
_nBits$ = 16						; size = 4
_MSG_WriteBits PROC					; COMDAT

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 267  : 	byte	*pOut = (byte *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pOut$[ebp], eax

; 268  : 	int	nBitsLeft = nBits;

	mov	eax, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR _nBitsLeft$[ebp], eax
$LN2@MSG_WriteB:

; 269  : 
; 270  : 	// get output dword-aligned.
; 271  : 	while((( dword )pOut & 3 ) != 0 && nBitsLeft >= 8 )

	mov	eax, DWORD PTR _pOut$[ebp]
	and	eax, 3
	je	SHORT $LN4@MSG_WriteB
	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN4@MSG_WriteB

; 272  : 	{
; 273  : 		MSG_WriteUBitLong( sb, *pOut, 8 );

	push	8
	mov	eax, DWORD PTR _pOut$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 274  : 
; 275  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 276  : 		++pOut;

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOut$[ebp], eax

; 277  : 	}

	jmp	SHORT $LN2@MSG_WriteB
$LN4@MSG_WriteB:

; 278  : 
; 279  : 	// read dwords.
; 280  : 	while( nBitsLeft >= 32 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 32		; 00000020H
	jl	SHORT $LN6@MSG_WriteB

; 281  : 	{
; 282  : 		MSG_WriteUBitLong( sb, *(( dword *)pOut ), 32 );

	push	32					; 00000020H
	mov	eax, DWORD PTR _pOut$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 283  : 
; 284  : 		pOut += sizeof( dword );

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 4
	mov	DWORD PTR _pOut$[ebp], eax

; 285  : 		nBitsLeft -= 32;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 286  : 	}

	jmp	SHORT $LN4@MSG_WriteB
$LN6@MSG_WriteB:

; 287  : 
; 288  : 	// read the remaining bytes.
; 289  : 	while( nBitsLeft >= 8 )

	cmp	DWORD PTR _nBitsLeft$[ebp], 8
	jl	SHORT $LN7@MSG_WriteB

; 290  : 	{
; 291  : 		MSG_WriteUBitLong( sb, *pOut, 8 );

	push	8
	mov	eax, DWORD PTR _pOut$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 292  : 
; 293  : 		nBitsLeft -= 8;

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nBitsLeft$[ebp], eax

; 294  : 		++pOut;

	mov	eax, DWORD PTR _pOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pOut$[ebp], eax

; 295  : 	}

	jmp	SHORT $LN6@MSG_WriteB
$LN7@MSG_WriteB:

; 296  : 	
; 297  : 	// Read the remaining bits.
; 298  : 	if( nBitsLeft )

	cmp	DWORD PTR _nBitsLeft$[ebp], 0
	je	SHORT $LN8@MSG_WriteB

; 299  : 	{
; 300  : 		MSG_WriteUBitLong( sb, *pOut, nBitsLeft );

	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOut$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN8@MSG_WriteB:

; 301  : 	}
; 302  : 
; 303  : 	return !sb->bOverflow;

	mov	eax, DWORD PTR _sb$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@MSG_WriteB
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN11@MSG_WriteB
$LN10@MSG_WriteB:
	mov	DWORD PTR tv93[ebp], 0
$LN11@MSG_WriteB:
	mov	eax, DWORD PTR tv93[ebp]

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteBitLong
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_data$ = 12						; size = 4
_numbits$ = 16						; size = 4
_bSigned$ = 20						; size = 4
_MSG_WriteBitLong PROC					; COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 260  : 	if( bSigned )

	cmp	DWORD PTR _bSigned$[ebp], 0
	je	SHORT $LN2@MSG_WriteB

; 261  : 		MSG_WriteSBitLong( sb, (int)data, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteSBitLong
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@MSG_WriteB
$LN2@MSG_WriteB:

; 262  : 	else MSG_WriteUBitLong( sb, data, numbits );

	mov	eax, DWORD PTR _numbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH
$LN1@MSG_WriteB:

; 263  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteSBitLong
_TEXT	SEGMENT
tv71 = -68						; size = 4
_sb$ = 8						; size = 4
_data$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteSBitLong PROC					; COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 241  : 	// do we have a valid # of bits to encode with?
; 242  : 	Assert( numbits >= 1 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 1
	jl	SHORT $LN5@MSG_WriteS
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN5@MSG_WriteS
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@MSG_WriteS
$LN5@MSG_WriteS:
	mov	DWORD PTR tv71[ebp], 0
$LN6@MSG_WriteS:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_WriteSBitLong@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BO@JHFFDEGK@numbits?5?$DO?$DN?51?5?$CG?$CG?5numbits?5?$DM?$DN?532@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 243  : 
; 244  : 	// NOTE: it does this wierdness here so it's bit-compatible with regular integer data in the buffer.
; 245  : 	// (Some old code writes direct integers right into the buffer).
; 246  : 	if( data < 0 )

	cmp	DWORD PTR _data$[ebp], 0
	jge	SHORT $LN2@MSG_WriteS

; 247  : 	{
; 248  : 		MSG_WriteUBitLong( sb, (uint)( 0x80000000 + data ), numbits - 1 );

	mov	eax, DWORD PTR _numbits$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	ecx, -2147483648			; 80000000H
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 249  : 		MSG_WriteOneBit( sb, 1 );

	push	1
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 250  : 	}

	jmp	SHORT $LN1@MSG_WriteS
$LN2@MSG_WriteS:

; 251  : 	else
; 252  : 	{
; 253  : 		MSG_WriteUBitLong( sb, (uint)data, numbits - 1 );

	mov	eax, DWORD PTR _numbits$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sb$[ebp]
	push	edx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 254  : 		MSG_WriteOneBit( sb, 0 );

	push	0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@MSG_WriteS:

; 255  : 	}
; 256  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteSBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteUBitLong
_TEXT	SEGMENT
tv92 = -88						; size = 4
tv71 = -88						; size = 4
_nBitsWritten$1 = -20					; size = 4
_iCurBitMasked$2 = -16					; size = 4
_iDWord$3 = -12						; size = 4
_iCurBit$4 = -8						; size = 4
_nBitsLeft$5 = -4					; size = 4
_sb$ = 8						; size = 4
_curData$ = 12						; size = 4
_numbits$ = 16						; size = 4
_MSG_WriteUBitLong PROC					; COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 152  : 	Assert( numbits >= 0 && numbits <= 32 );

	cmp	DWORD PTR _numbits$[ebp], 0
	jl	SHORT $LN6@MSG_WriteU
	cmp	DWORD PTR _numbits$[ebp], 32		; 00000020H
	jg	SHORT $LN6@MSG_WriteU
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN7@MSG_WriteU
$LN6@MSG_WriteU:
	mov	DWORD PTR tv71[ebp], 0
$LN7@MSG_WriteU:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MSG_WriteUBitLong@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BO@EALHLEDC@numbits?5?$DO?$DN?50?5?$CG?$CG?5numbits?5?$DM?$DN?532@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 153  : 
; 154  : 	// bounds checking..
; 155  : 	if(( sb->iCurBit + numbits ) > sb->nDataBits )

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	cmp	ecx, DWORD PTR [edx+16]
	jle	SHORT $LN2@MSG_WriteU

; 156  : 	{
; 157  : 		sb->bOverflow = true;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 1

; 158  : 		sb->iCurBit = sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+12], edx

; 159  : 	}

	jmp	$LN1@MSG_WriteU
$LN2@MSG_WriteU:

; 160  : 	else
; 161  : 	{
; 162  : 		int	nBitsLeft = numbits;

	mov	eax, DWORD PTR _numbits$[ebp]
	mov	DWORD PTR _nBitsLeft$5[ebp], eax

; 163  : 		int	iCurBit = sb->iCurBit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iCurBit$4[ebp], ecx

; 164  : 		uint	iDWord = iCurBit >> 5;	// Mask in a dword.

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	sar	eax, 5
	mov	DWORD PTR _iDWord$3[ebp], eax

; 165  : 		dword	iCurBitMasked;
; 166  : 		int	nBitsWritten;
; 167  : 
; 168  : 		Assert(( iDWord * 4 + sizeof( long )) <= (uint)MSG_GetMaxBytes( sb ));

	mov	eax, DWORD PTR _iDWord$3[ebp]
	lea	esi, DWORD PTR [eax*4+4]
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	cmp	esi, eax
	ja	SHORT $LN8@MSG_WriteU
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN9@MSG_WriteU
$LN8@MSG_WriteU:
	mov	DWORD PTR tv92[ebp], 0
$LN9@MSG_WriteU:
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??MSG_WriteUBitLong@@9@9
	add	edx, 17					; 00000011H
	push	edx
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0DO@FHEHONFM@?$CI?5iDWord?5?$CK?54?5?$CL?5sizeof?$CI?5long?5?$CJ?$CJ?5@
	mov	eax, DWORD PTR tv92[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 169  : 
; 170  : 		iCurBitMasked = iCurBit & 31;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _iCurBitMasked$2[ebp], eax

; 171  : 		((dword *)sb->pData)[iDWord] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR _iCurBitMasked$2[ebp], 132
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	esi, DWORD PTR _nBitsLeft$5[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	and	ecx, DWORD PTR _BitWriteMasks[edx+esi*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 172  : 		((dword *)sb->pData)[iDWord] |= curData << iCurBitMasked;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _iCurBitMasked$2[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iDWord$3[ebp]
	or	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 173  : 
; 174  : 		// did it span a dword?
; 175  : 		nBitsWritten = 32 - iCurBitMasked;

	mov	eax, 32					; 00000020H
	sub	eax, DWORD PTR _iCurBitMasked$2[ebp]
	mov	DWORD PTR _nBitsWritten$1[ebp], eax

; 176  : 
; 177  : 		if( nBitsWritten < nBitsLeft )

	mov	eax, DWORD PTR _nBitsWritten$1[ebp]
	cmp	eax, DWORD PTR _nBitsLeft$5[ebp]
	jge	SHORT $LN4@MSG_WriteU

; 178  : 		{
; 179  : 			nBitsLeft -= nBitsWritten;

	mov	eax, DWORD PTR _nBitsLeft$5[ebp]
	sub	eax, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _nBitsLeft$5[ebp], eax

; 180  : 			iCurBit += nBitsWritten;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	add	eax, DWORD PTR _nBitsWritten$1[ebp]
	mov	DWORD PTR _iCurBit$4[ebp], eax

; 181  : 			curData >>= nBitsWritten;

	mov	eax, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _nBitsWritten$1[ebp]
	shr	eax, cl
	mov	DWORD PTR _curData$[ebp], eax

; 182  : 
; 183  : 			iCurBitMasked = iCurBit & 31;

	mov	eax, DWORD PTR _iCurBit$4[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _iCurBitMasked$2[ebp], eax

; 184  : 			((dword *)sb->pData)[iDWord+1] &= BitWriteMasks[iCurBitMasked][nBitsLeft];

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR _iCurBitMasked$2[ebp], 132
	mov	eax, DWORD PTR _iDWord$3[ebp]
	mov	esi, DWORD PTR _nBitsLeft$5[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	and	ecx, DWORD PTR _BitWriteMasks[edx+esi*4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [eax+edx*4+4], ecx

; 185  : 			((dword *)sb->pData)[iDWord+1] |= curData << iCurBitMasked;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _curData$[ebp]
	mov	ecx, DWORD PTR _iCurBitMasked$2[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _iDWord$3[ebp]
	or	eax, DWORD PTR [edx+ecx*4+4]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _iDWord$3[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax
$LN4@MSG_WriteU:

; 186  : 		}
; 187  : 		sb->iCurBit += numbits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _numbits$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN1@MSG_WriteU:

; 188  : 	}
; 189  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteUBitLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_WriteOneBit
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_nValue$ = 12						; size = 4
_MSG_WriteOneBit PROC					; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 141  : 	if( !MSG_Overflow( sb, 1 ))

	push	1
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8
	test	eax, eax
	jne	$LN1@MSG_WriteO

; 142  : 	{
; 143  : 		if( nValue ) sb->pData[sb->iCurBit>>3] |= BIT( sb->iCurBit & 7 );

	cmp	DWORD PTR _nValue$[ebp], 0
	je	SHORT $LN3@MSG_WriteO
	mov	eax, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sar	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, 7
	mov	esi, 1
	shl	esi, cl
	movzx	edx, BYTE PTR [eax+edx]
	or	edx, esi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN4@MSG_WriteO
$LN3@MSG_WriteO:

; 144  : 		else sb->pData[sb->iCurBit>>3] &= ~BIT( sb->iCurBit & 7 );

	mov	eax, DWORD PTR _sb$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sar	edx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, 7
	mov	esi, 1
	shl	esi, cl
	not	esi
	movzx	edx, BYTE PTR [eax+edx]
	and	edx, esi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR [eax+ecx], dl
$LN4@MSG_WriteO:

; 145  : 
; 146  : 		sb->iCurBit++;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN1@MSG_WriteO:

; 147  : 	}
; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_WriteOneBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_Clear
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_Clear PROC						; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 93   : 	sb->iCurBit = 0;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+12], 0

; 94   : 	sb->bOverflow = false;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 0

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_StartWriting
_TEXT	SEGMENT
tv85 = -68						; size = 4
tv71 = -68						; size = 4
_sb$ = 8						; size = 4
_pData$ = 12						; size = 4
_nBytes$ = 16						; size = 4
_iStartBit$ = 20					; size = 4
_nBits$ = 24						; size = 4
_MSG_StartWriting PROC					; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 64   : 	// make sure it's dword aligned and padded.
; 65   : 	Assert(((dword)pData & 3 ) == 0 );

	mov	eax, DWORD PTR _pData$[ebp]
	and	eax, 3
	jne	SHORT $LN5@MSG_StartW
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@MSG_StartW
$LN5@MSG_StartW:
	mov	DWORD PTR tv71[ebp], 0
$LN6@MSG_StartW:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??MSG_StartWriting@@9@9
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@FBLGOBAN@?$CI?$CIdword?$CJpData?5?$CG?53?5?$CJ?5?$DN?$DN?50@
	mov	edx, DWORD PTR tv71[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 66   : 
; 67   : 	sb->pDebugName = "Unnamed";

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax+4], OFFSET ??_C@_07EMPPFCON@Unnamed@

; 68   : 	sb->pData = (byte *)pData;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 69   : 
; 70   : 	if( nBits == -1 )

	cmp	DWORD PTR _nBits$[ebp], -1
	jne	SHORT $LN2@MSG_StartW

; 71   : 	{
; 72   : 		sb->nDataBits = nBytes << 3;

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 73   : 	}

	jmp	SHORT $LN3@MSG_StartW
$LN2@MSG_StartW:

; 74   : 	else
; 75   : 	{
; 76   : 		Assert( nBits <= nBytes * 8 );

	mov	eax, DWORD PTR _nBytes$[ebp]
	shl	eax, 3
	cmp	DWORD PTR _nBits$[ebp], eax
	jg	SHORT $LN7@MSG_StartW
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN8@MSG_StartW
$LN7@MSG_StartW:
	mov	DWORD PTR tv85[ebp], 0
$LN8@MSG_StartW:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??MSG_StartWriting@@9@9
	add	ecx, 13					; 0000000dH
	push	ecx
	push	OFFSET ??_C@_0DH@BENADNPK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BE@MJGBLALK@nBits?5?$DM?$DN?5nBytes?5?$CK?58@
	mov	edx, DWORD PTR tv85[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 77   : 		sb->nDataBits = nBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _nBits$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN3@MSG_StartW:

; 78   : 	}
; 79   : 
; 80   : 	sb->iCurBit = iStartBit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _iStartBit$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 81   : 	sb->bOverflow = false;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [eax], 0

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_StartWriting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_BigShort
_TEXT	SEGMENT
_swap$ = 8						; size = 2
_MSG_BigShort PROC					; COMDAT

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 32   : 	return (swap >> 8)|(swap << 8);

	movsx	eax, WORD PTR _swap$[ebp]
	sar	eax, 8
	movsx	ecx, WORD PTR _swap$[ebp]
	shl	ecx, 8
	or	eax, ecx

; 33   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_BigShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_CheckOverflow
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_CheckOverflow PROC					; COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 106  : 	return MSG_Overflow( sb, 0 );

	push	0
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_Overflow
	add	esp, 8

; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_CheckOverflow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_ExciseBits
_TEXT	SEGMENT
_temp$ = -32						; size = 20
_remaining_to_end$ = -12				; size = 4
_endbit$ = -8						; size = 4
_i$ = -4						; size = 4
_sb$ = 8						; size = 4
_startbit$ = 12						; size = 4
_bitstoremove$ = 16					; size = 4
_MSG_ExciseBits PROC					; COMDAT

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 783  : 	int	i, endbit = startbit + bitstoremove;

	mov	eax, DWORD PTR _startbit$[ebp]
	add	eax, DWORD PTR _bitstoremove$[ebp]
	mov	DWORD PTR _endbit$[ebp], eax

; 784  : 	int	remaining_to_end = sb->nDataBits - endbit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _endbit$[ebp]
	mov	DWORD PTR _remaining_to_end$[ebp], ecx

; 785  : 	sizebuf_t	temp;
; 786  : 
; 787  : 	MSG_StartWriting( &temp, sb->pData, MSG_GetMaxBytes( sb ), startbit, -1 );

	push	-1
	mov	eax, DWORD PTR _startbit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_GetMaxBytes
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 788  : 	MSG_SeekToBit( sb, endbit, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _endbit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 789  : 
; 790  : 	for( i = 0; i < remaining_to_end; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MSG_Excise
$LN2@MSG_Excise:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MSG_Excise:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _remaining_to_end$[ebp]
	jge	SHORT $LN3@MSG_Excise

; 791  : 	{
; 792  : 		MSG_WriteOneBit( &temp, MSG_ReadOneBit( sb ));

	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 793  : 	}

	jmp	SHORT $LN2@MSG_Excise
$LN3@MSG_Excise:

; 794  : 
; 795  : 	MSG_SeekToBit( sb, startbit, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _startbit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sb$[ebp]
	push	ecx
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 796  : 	sb->nDataBits -= bitstoremove;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _bitstoremove$[ebp]
	mov	edx, DWORD PTR _sb$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 797  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_ExciseBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_SeekToBit
_TEXT	SEGMENT
tv64 = -68						; size = 4
_sb$ = 8						; size = 4
_bitPos$ = 12						; size = 4
_whence$ = 16						; size = 4
_MSG_SeekToBit PROC					; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 111  : 	// compute the file offset
; 112  : 	switch( whence )

	mov	eax, DWORD PTR _whence$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN5@MSG_SeekTo
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN4@MSG_SeekTo
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN6@MSG_SeekTo
	jmp	SHORT $LN7@MSG_SeekTo
$LN4@MSG_SeekTo:

; 113  : 	{
; 114  : 	case SEEK_CUR:
; 115  : 		bitPos += sb->iCurBit;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _bitPos$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _bitPos$[ebp], ecx

; 116  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN5@MSG_SeekTo:

; 117  : 	case SEEK_SET:
; 118  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN6@MSG_SeekTo:

; 119  : 	case SEEK_END:
; 120  : 		bitPos += sb->nDataBits;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _bitPos$[ebp]
	add	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _bitPos$[ebp], ecx

; 121  : 		break;

	jmp	SHORT $LN2@MSG_SeekTo
$LN7@MSG_SeekTo:

; 122  : 	default: 
; 123  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@MSG_SeekTo
$LN2@MSG_SeekTo:

; 124  : 	}
; 125  : 
; 126  : 	if( bitPos < 0 || bitPos > sb->nDataBits )

	cmp	DWORD PTR _bitPos$[ebp], 0
	jl	SHORT $LN9@MSG_SeekTo
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _bitPos$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jle	SHORT $LN8@MSG_SeekTo
$LN9@MSG_SeekTo:

; 127  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@MSG_SeekTo
$LN8@MSG_SeekTo:

; 128  : 
; 129  : 	sb->iCurBit = bitPos;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _bitPos$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 130  : 
; 131  : 	return 0;

	xor	eax, eax
$LN1@MSG_SeekTo:

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_SeekToBit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_InitMasks
_TEXT	SEGMENT
_nBitsLeft$ = -16					; size = 4
_maskBit$ = -12						; size = 4
_endbit$ = -8						; size = 4
_startbit$ = -4						; size = 4
_MSG_InitMasks PROC					; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 37   : 	uint	startbit, endbit;
; 38   : 	uint	maskBit, nBitsLeft;
; 39   : 
; 40   : 	for( startbit = 0; startbit < 32; startbit++ )

	mov	DWORD PTR _startbit$[ebp], 0
	jmp	SHORT $LN4@MSG_InitMa
$LN2@MSG_InitMa:
	mov	eax, DWORD PTR _startbit$[ebp]
	add	eax, 1
	mov	DWORD PTR _startbit$[ebp], eax
$LN4@MSG_InitMa:
	cmp	DWORD PTR _startbit$[ebp], 32		; 00000020H
	jae	SHORT $LN3@MSG_InitMa

; 41   : 	{
; 42   : 		for( nBitsLeft = 0; nBitsLeft < 33; nBitsLeft++ )

	mov	DWORD PTR _nBitsLeft$[ebp], 0
	jmp	SHORT $LN7@MSG_InitMa
$LN5@MSG_InitMa:
	mov	eax, DWORD PTR _nBitsLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _nBitsLeft$[ebp], eax
$LN7@MSG_InitMa:
	cmp	DWORD PTR _nBitsLeft$[ebp], 33		; 00000021H
	jae	SHORT $LN6@MSG_InitMa

; 43   : 		{
; 44   : 			endbit = startbit + nBitsLeft;

	mov	eax, DWORD PTR _startbit$[ebp]
	add	eax, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _endbit$[ebp], eax

; 45   : 
; 46   : 			BitWriteMasks[startbit][nBitsLeft] = (uint)BIT( startbit ) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _startbit$[ebp]
	shl	eax, cl
	sub	eax, 1
	imul	ecx, DWORD PTR _startbit$[ebp], 132
	mov	edx, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _BitWriteMasks[ecx+edx*4], eax

; 47   : 			if( endbit < 32 ) BitWriteMasks[startbit][nBitsLeft] |= ~((uint)BIT( endbit ) - 1 );

	cmp	DWORD PTR _endbit$[ebp], 32		; 00000020H
	jae	SHORT $LN11@MSG_InitMa
	imul	eax, DWORD PTR _startbit$[ebp], 132
	mov	edx, 1
	mov	ecx, DWORD PTR _endbit$[ebp]
	shl	edx, cl
	sub	edx, 1
	not	edx
	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	or	edx, DWORD PTR _BitWriteMasks[eax+ecx*4]
	imul	eax, DWORD PTR _startbit$[ebp], 132
	mov	ecx, DWORD PTR _nBitsLeft$[ebp]
	mov	DWORD PTR _BitWriteMasks[eax+ecx*4], edx
$LN11@MSG_InitMa:

; 48   : 		}

	jmp	SHORT $LN5@MSG_InitMa
$LN6@MSG_InitMa:

; 49   : 	}

	jmp	$LN2@MSG_InitMa
$LN3@MSG_InitMa:

; 50   : 
; 51   : 	for( maskBit = 0; maskBit < 32; maskBit++ )

	mov	DWORD PTR _maskBit$[ebp], 0
	jmp	SHORT $LN10@MSG_InitMa
$LN8@MSG_InitMa:
	mov	eax, DWORD PTR _maskBit$[ebp]
	add	eax, 1
	mov	DWORD PTR _maskBit$[ebp], eax
$LN10@MSG_InitMa:
	cmp	DWORD PTR _maskBit$[ebp], 32		; 00000020H
	jae	SHORT $LN1@MSG_InitMa

; 52   : 		ExtraMasks[maskBit] = (uint)BIT( maskBit ) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _maskBit$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR _maskBit$[ebp]
	mov	DWORD PTR _ExtraMasks[ecx*4], eax
	jmp	SHORT $LN8@MSG_InitMa
$LN1@MSG_InitMa:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_InitMasks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.c
;	COMDAT _MSG_InitExt
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_pDebugName$ = 12					; size = 4
_pData$ = 16						; size = 4
_nBytes$ = 20						; size = 4
_nMaxBits$ = 24						; size = 4
_MSG_InitExt PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 57   : 	MSG_StartWriting( sb, pData, nBytes, 0, nMaxBits );

	mov	eax, DWORD PTR _nMaxBits$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _nBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	eax, DWORD PTR _sb$[ebp]
	push	eax
	call	_MSG_StartWriting
	add	esp, 20					; 00000014H

; 58   : 
; 59   : 	sb->pDebugName = pDebugName;

	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _pDebugName$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_InitExt ENDP
_TEXT	ENDS
END
