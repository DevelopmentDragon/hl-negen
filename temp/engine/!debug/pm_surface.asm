; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\pm_surface.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_PM_TraceTexture
PUBLIC	_PM_RecursiveSurfCheck
PUBLIC	_PM_TraceSurface
PUBLIC	_PM_TestLineExt
PUBLIC	_PM_TestLine_r
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bdcccccd
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_PM_HullForBsp:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_vec3_origin:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	043bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	038dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05bbH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_surface.c
;	COMDAT _PM_TestLine_r
_TEXT	SEGMENT
tv203 = -120						; size = 8
tv202 = -112						; size = 8
tv265 = -108						; size = 4
tv240 = -108						; size = 4
tv193 = -108						; size = 4
tv177 = -108						; size = 4
tv139 = -108						; size = 4
_mid$ = -40						; size = 12
_side$ = -28						; size = 4
_r$ = -24						; size = 4
_midf$ = -20						; size = 4
_frac$ = -16						; size = 4
_back$ = -12						; size = 4
_front$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_p1f$ = 12						; size = 4
_p2f$ = 16						; size = 4
_start$ = 20						; size = 4
_stop$ = 24						; size = 4
_trace$ = 28						; size = 4
_PM_TestLine_r PROC					; COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
$loc0$23:

; 165  : 	float	front, back;
; 166  : 	float	frac, midf;
; 167  : 	int	r, side;
; 168  : 	vec3_t	mid;
; 169  : loc0:
; 170  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN2@PM_TestLin

; 171  : 		trace->contents = node->contents;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
$LN2@PM_TestLin:

; 172  : 	if( node->contents == CONTENTS_SOLID )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN3@PM_TestLin

; 173  : 		return CONTENTS_SOLID;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@PM_TestLin
$LN3@PM_TestLin:

; 174  : 	if( node->contents == CONTENTS_SKY )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], -6			; fffffffaH
	jne	SHORT $LN4@PM_TestLin

; 175  : 		return CONTENTS_SKY;

	mov	eax, -6					; fffffffaH
	jmp	$LN1@PM_TestLin
$LN4@PM_TestLin:

; 176  : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@PM_TestLin

; 177  : 		return CONTENTS_EMPTY;

	or	eax, -1
	jmp	$LN1@PM_TestLin
$LN5@PM_TestLin:

; 178  : 
; 179  : 	front = PlaneDiff( start, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN10@PM_TestLin
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN11@PM_TestLin
$LN10@PM_TestLin:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv139[ebp], xmm0
$LN11@PM_TestLin:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv139[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _front$[ebp], xmm0

; 180  : 	back = PlaneDiff( stop, node->plane );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN12@PM_TestLin
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	movzx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR _stop$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv177[ebp], xmm0
	jmp	SHORT $LN13@PM_TestLin
$LN12@PM_TestLin:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _stop$[ebp]
	movss	xmm1, DWORD PTR [esi+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR tv177[ebp], xmm0
$LN13@PM_TestLin:
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+36]
	movss	xmm0, DWORD PTR tv177[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _back$[ebp], xmm0

; 181  : 
; 182  : 	if( front >= -ON_EPSILON && back >= -ON_EPSILON )

	movss	xmm0, DWORD PTR _front$[ebp]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jb	SHORT $LN6@PM_TestLin
	movss	xmm0, DWORD PTR _back$[ebp]
	comiss	xmm0, DWORD PTR __real@bdcccccd
	jb	SHORT $LN6@PM_TestLin

; 183  : 	{
; 184  : 		node = node->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+ecx+40]
	mov	DWORD PTR _node$[ebp], eax

; 185  : 		goto loc0;

	jmp	$loc0$23
$LN6@PM_TestLin:

; 186  : 	}
; 187  : 
; 188  : 	if( front < ON_EPSILON && back < ON_EPSILON )

	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN7@PM_TestLin
	movss	xmm0, DWORD PTR __real@3dcccccd
	comiss	xmm0, DWORD PTR _back$[ebp]
	jbe	SHORT $LN7@PM_TestLin

; 189  : 	{
; 190  : 		node = node->children[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	mov	DWORD PTR _node$[ebp], edx

; 191  : 		goto loc0;

	jmp	$loc0$23
$LN7@PM_TestLin:

; 192  : 	}
; 193  : 
; 194  : 	side = (front < 0);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _front$[ebp]
	jbe	SHORT $LN14@PM_TestLin
	mov	DWORD PTR tv193[ebp], 1
	jmp	SHORT $LN15@PM_TestLin
$LN14@PM_TestLin:
	mov	DWORD PTR tv193[ebp], 0
$LN15@PM_TestLin:
	mov	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 195  : 	frac = front / (front - back);

	movss	xmm0, DWORD PTR _front$[ebp]
	subss	xmm0, DWORD PTR _back$[ebp]
	movss	xmm1, DWORD PTR _front$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 196  : 	frac = bound( 0.0, frac, 1.0 );

	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN18@PM_TestLin
	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN16@PM_TestLin
	cvtss2sd xmm0, DWORD PTR _frac$[ebp]
	movsd	QWORD PTR tv202[ebp], xmm0
	jmp	SHORT $LN17@PM_TestLin
$LN16@PM_TestLin:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv202[ebp], xmm0
$LN17@PM_TestLin:
	movsd	xmm0, QWORD PTR tv202[ebp]
	movsd	QWORD PTR tv203[ebp], xmm0
	jmp	SHORT $LN19@PM_TestLin
$LN18@PM_TestLin:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv203[ebp], xmm0
$LN19@PM_TestLin:
	cvtsd2ss xmm0, QWORD PTR tv203[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 197  : 
; 198  : 	VectorLerp( start, frac, stop, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _stop$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv240[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv240[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 199  : 	midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 200  : 
; 201  : 	r = PM_TestLine_r( node->children[side], p1f, midf, start, mid, trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	push	edx
	call	_PM_TestLine_r
	add	esp, 24					; 00000018H
	mov	DWORD PTR _r$[ebp], eax

; 202  : 
; 203  : 	if( r != CONTENTS_EMPTY )

	cmp	DWORD PTR _r$[ebp], -1
	je	SHORT $LN8@PM_TestLin

; 204  : 	{
; 205  : 		trace->fraction = midf;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [eax], xmm0

; 206  : 		return r;

	mov	eax, DWORD PTR _r$[ebp]
	jmp	SHORT $LN1@PM_TestLin
$LN8@PM_TestLin:

; 207  : 	}
; 208  : 
; 209  : 	return PM_TestLine_r( node->children[!side], midf, p2f, mid, stop, trace );

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN20@PM_TestLin
	mov	DWORD PTR tv265[ebp], 1
	jmp	SHORT $LN21@PM_TestLin
$LN20@PM_TestLin:
	mov	DWORD PTR tv265[ebp], 0
$LN21@PM_TestLin:
	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stop$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mid$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR tv265[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	push	edx
	call	_PM_TestLine_r
	add	esp, 24					; 00000018H
$LN1@PM_TestLin:

; 210  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestLine_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_surface.c
;	COMDAT _PM_TestLineExt
_TEXT	SEGMENT
tv193 = -204						; size = 4
tv169 = -204						; size = 4
_i$ = -136						; size = 4
_pe$ = -132						; size = 4
_rotated$ = -128					; size = 4
_end_l$ = -124						; size = 12
_start_l$ = -112					; size = 12
_offset$ = -100						; size = 12
_hull$ = -88						; size = 4
_matrix$ = -84						; size = 64
_trace_bbox$ = -20					; size = 8
_trace$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_ents$ = 12						; size = 4
_numents$ = 16						; size = 4
_start$ = 20						; size = 4
_end$ = 24						; size = 4
_flags$ = 28						; size = 4
_PM_TestLineExt PROC					; COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 214  : 	linetrace_t	trace, trace_bbox;
; 215  : 	matrix4x4		matrix;
; 216  : 	hull_t		*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 217  : 	vec3_t		offset, start_l, end_l;
; 218  : 	qboolean		rotated;
; 219  : 	physent_t		*pe;
; 220  : 	int		i;
; 221  : 
; 222  : 	trace.contents = CONTENTS_EMPTY;

	mov	DWORD PTR _trace$[ebp+4], -1

; 223  : 	trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace$[ebp], xmm0

; 224  : 
; 225  : 	for( i = 0; i < numents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_TestLin
$LN2@PM_TestLin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_TestLin:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numents$[ebp]
	jge	$LN3@PM_TestLin

; 226  : 	{
; 227  : 		pe = &ents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	add	eax, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pe$[ebp], eax

; 228  : 
; 229  : 		if( i != 0 && ( flags & PM_WORLD_ONLY ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN5@PM_TestLin
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN5@PM_TestLin

; 230  : 			break;

	jmp	$LN3@PM_TestLin
$LN5@PM_TestLin:

; 231  : 
; 232  : 		if( !pe->model || pe->model->type != mod_brush || pe->solid != SOLID_BSP )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN7@PM_TestLin
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN7@PM_TestLin
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	je	SHORT $LN6@PM_TestLin
$LN7@PM_TestLin:

; 233  : 			continue;

	jmp	SHORT $LN2@PM_TestLin
$LN6@PM_TestLin:

; 234  : 
; 235  : 		if( pe->rendermode != kRenderNormal )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN8@PM_TestLin

; 236  : 			continue;

	jmp	SHORT $LN2@PM_TestLin
$LN8@PM_TestLin:

; 237  : 
; 238  : 		hull = &pe->model->hulls[0];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx

; 239  : 
; 240  : 		hull = PM_HullForBsp( pe, pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 241  : 
; 242  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	SHORT $LN9@PM_TestLin
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_TestLin
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PM_TestLin
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@PM_TestLin
$LN11@PM_TestLin:

; 243  : 			rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN10@PM_TestLin
$LN9@PM_TestLin:

; 244  : 		else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN10@PM_TestLin:

; 245  : 
; 246  : 		if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN12@PM_TestLin

; 247  : 		{
; 248  : 			Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 249  : 			Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 250  : 			Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 251  : 		}

	jmp	$LN13@PM_TestLin
$LN12@PM_TestLin:

; 252  : 		else
; 253  : 		{
; 254  : 			VectorSubtract( start, pe->origin, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+36]
	movss	DWORD PTR tv169[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 255  : 			VectorSubtract( end, pe->origin, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+36]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN13@PM_TestLin:

; 256  : 		}
; 257  : 
; 258  : 		trace_bbox.contents = CONTENTS_EMPTY;

	mov	DWORD PTR _trace_bbox$[ebp+4], -1

; 259  : 		trace_bbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_bbox$[ebp], xmm0

; 260  : 
; 261  : 		PM_TestLine_r( &pe->model->nodes[hull->firstclipnode], 0.0f, 1.0f, start_l, end_l, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _hull$[ebp]
	imul	eax, DWORD PTR [edx+8], 52
	add	eax, DWORD PTR [ecx+164]
	push	eax
	call	_PM_TestLine_r
	add	esp, 24					; 00000018H

; 262  : 
; 263  : 		if( trace_bbox.contents != CONTENTS_EMPTY || trace_bbox.fraction < trace.fraction )

	cmp	DWORD PTR _trace_bbox$[ebp+4], -1
	jne	SHORT $LN15@PM_TestLin
	movss	xmm0, DWORD PTR _trace$[ebp]
	comiss	xmm0, DWORD PTR _trace_bbox$[ebp]
	jbe	SHORT $LN14@PM_TestLin
$LN15@PM_TestLin:

; 264  : 		{
; 265  : 			trace = trace_bbox;

	mov	eax, DWORD PTR _trace_bbox$[ebp]
	mov	ecx, DWORD PTR _trace_bbox$[ebp+4]
	mov	DWORD PTR _trace$[ebp], eax
	mov	DWORD PTR _trace$[ebp+4], ecx
$LN14@PM_TestLin:

; 266  : 		}
; 267  : 	}

	jmp	$LN2@PM_TestLin
$LN3@PM_TestLin:

; 268  : 
; 269  : 	return trace.contents;

	mov	eax, DWORD PTR _trace$[ebp+4]

; 270  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestLineExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_surface.c
;	COMDAT _PM_TraceSurface
_TEXT	SEGMENT
tv193 = -180						; size = 4
tv172 = -180						; size = 4
tv151 = -180						; size = 4
tv95 = -180						; size = 4
_offset$ = -112						; size = 12
_end_l$ = -100						; size = 12
_start_l$ = -88						; size = 12
_hull$ = -76						; size = 4
_bmodel$ = -72						; size = 4
_matrix$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_PM_TraceSurface PROC					; COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 109  : 	matrix4x4		matrix;
; 110  : 	model_t		*bmodel;
; 111  : 	hull_t		*hull;
; 112  : 	vec3_t		start_l, end_l;
; 113  : 	vec3_t		offset;
; 114  : 
; 115  : 	bmodel = pe->model;

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _bmodel$[ebp], ecx

; 116  : 
; 117  : 	if( !bmodel || bmodel->type != mod_brush )

	cmp	DWORD PTR _bmodel$[ebp], 0
	je	SHORT $LN3@PM_TraceSu
	mov	eax, DWORD PTR _bmodel$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN2@PM_TraceSu
$LN3@PM_TraceSu:

; 118  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@PM_TraceSu
$LN2@PM_TraceSu:

; 119  : 
; 120  : 	hull = &pe->model->hulls[0];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx

; 121  : 	VectorSubtract( hull->clip_mins, vec3_origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR _vec3_origin[eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _vec3_origin[eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _vec3_origin[ecx]
	movss	DWORD PTR tv95[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv95[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 122  : 	VectorAdd( offset, pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+36]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR _offset$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+36]
	movss	DWORD PTR tv151[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv151[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 123  : 
; 124  : 	VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 125  : 	VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0

; 126  : 
; 127  : 	// rotate start and end into the models frame of reference
; 128  : 	if( !VectorIsNull( pe->angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PM_TraceSu
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PM_TraceSu
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@PM_TraceSu
$LN5@PM_TraceSu:

; 129  : 	{
; 130  : 		Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 131  : 		Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 132  : 		Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH
$LN4@PM_TraceSu:

; 133  : 	}
; 134  : 
; 135  : 	return PM_RecursiveSurfCheck( bmodel, &bmodel->nodes[hull->firstclipnode], start_l, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_l$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	imul	eax, DWORD PTR [edx+8], 52
	mov	ecx, DWORD PTR _bmodel$[ebp]
	add	eax, DWORD PTR [ecx+164]
	push	eax
	mov	edx, DWORD PTR _bmodel$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
$LN1@PM_TraceSu:

; 136  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TraceSurface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_surface.c
;	COMDAT _PM_RecursiveSurfCheck
_TEXT	SEGMENT
tv222 = -128						; size = 4
tv220 = -128						; size = 4
_t$1 = -60						; size = 4
_s$2 = -56						; size = 4
_i$ = -52						; size = 4
_mid$ = -48						; size = 12
_surf$ = -36						; size = 4
_plane$ = -32						; size = 4
_dt$ = -28						; size = 4
_ds$ = -24						; size = 4
_side$ = -20						; size = 4
_frac$ = -16						; size = 4
_t2$ = -12						; size = 4
_t1$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_model$ = 8						; size = 4
_node$ = 12						; size = 4
_p1$ = 16						; size = 4
_p2$ = 20						; size = 4
_PM_RecursiveSurfCheck PROC				; COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 34   : 	float		t1, t2, frac;
; 35   : 	int		side, ds, dt;
; 36   : 	mplane_t		*plane;
; 37   : 	msurface_t	*surf;
; 38   : 	vec3_t		mid;
; 39   : 	int		i;
; 40   : 
; 41   : 	if( node->contents < 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN5@PM_Recursi

; 42   : 		return NULL;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN5@PM_Recursi:

; 43   : 
; 44   : 	plane = node->plane;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _plane$[ebp], ecx

; 45   : 
; 46   : 	if( plane->type < 3 )

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN6@PM_Recursi

; 47   : 	{
; 48   : 		t1 = p1[plane->type] - plane->dist;

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _t1$[ebp], xmm0

; 49   : 		t2 = p2[plane->type] - plane->dist;

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	mov	edx, DWORD PTR _p2$[ebp]
	mov	eax, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx*4]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _t2$[ebp], xmm0

; 50   : 	}

	jmp	$LN7@PM_Recursi
$LN6@PM_Recursi:

; 51   : 	else
; 52   : 	{
; 53   : 		t1 = DotProduct( plane->normal, p1 ) - plane->dist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _plane$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _t1$[ebp], xmm0

; 54   : 		t2 = DotProduct( plane->normal, p2 ) - plane->dist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane$[ebp]
	mov	esi, DWORD PTR _p2$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _plane$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _t2$[ebp], xmm0
$LN7@PM_Recursi:

; 55   : 	}
; 56   : 
; 57   : 	if( t1 >= 0.0f && t2 >= 0.0f )

	movss	xmm0, DWORD PTR _t1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@PM_Recursi
	movss	xmm0, DWORD PTR _t2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@PM_Recursi

; 58   : 		return PM_RecursiveSurfCheck( model, node->children[0], p1, p2 );

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
	jmp	$LN1@PM_Recursi
$LN8@PM_Recursi:

; 59   : 	if( t1 < 0.0f && t2 < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN9@PM_Recursi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t2$[ebp]
	jbe	SHORT $LN9@PM_Recursi

; 60   : 		return PM_RecursiveSurfCheck( model, node->children[1], p1, p2 );

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
	jmp	$LN1@PM_Recursi
$LN9@PM_Recursi:

; 61   : 
; 62   : 	frac = t1 / ( t1 - t2 );

	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR _t2$[ebp]
	movss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _frac$[ebp], xmm1

; 63   : 
; 64   : 	if( frac < 0.0f ) frac = 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN10@PM_Recursi
	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0
$LN10@PM_Recursi:

; 65   : 	if( frac > 1.0f ) frac = 1.0f;

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@PM_Recursi
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN11@PM_Recursi:

; 66   : 
; 67   : 	VectorLerp( p1, frac, p2, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv220[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 68   : 
; 69   : 	side = (t1 < 0.0f);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN18@PM_Recursi
	mov	DWORD PTR tv222[ebp], 1
	jmp	SHORT $LN19@PM_Recursi
$LN18@PM_Recursi:
	mov	DWORD PTR tv222[ebp], 0
$LN19@PM_Recursi:
	mov	eax, DWORD PTR tv222[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 70   : 
; 71   : 	// now this is weird.
; 72   : 	surf = PM_RecursiveSurfCheck( model, node->children[side], p1, mid );

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _side$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
	mov	DWORD PTR _surf$[ebp], eax

; 73   : 
; 74   : 	if( surf != NULL || ( t1 >= 0.0f && t2 >= 0.0f ) || ( t1 < 0.0f && t2 < 0.0f ))

	cmp	DWORD PTR _surf$[ebp], 0
	jne	SHORT $LN13@PM_Recursi
	movss	xmm0, DWORD PTR _t1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN14@PM_Recursi
	movss	xmm0, DWORD PTR _t2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jae	SHORT $LN13@PM_Recursi
$LN14@PM_Recursi:
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN12@PM_Recursi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t2$[ebp]
	jbe	SHORT $LN12@PM_Recursi
$LN13@PM_Recursi:

; 75   : 	{
; 76   : 		return surf;

	mov	eax, DWORD PTR _surf$[ebp]
	jmp	$LN1@PM_Recursi
$LN12@PM_Recursi:

; 77   : 	}
; 78   : 
; 79   : 	surf = model->surfaces + node->firstsurface;

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+48]
	imul	edx, ecx, 92
	mov	eax, DWORD PTR _model$[ebp]
	add	edx, DWORD PTR [eax+180]
	mov	DWORD PTR _surf$[ebp], edx

; 80   : 
; 81   : 	for( i = 0; i < node->numsurfaces; i++, surf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_Recursi
$LN2@PM_Recursi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _surf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _surf$[ebp], ecx
$LN4@PM_Recursi:
	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, WORD PTR [eax+50]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN3@PM_Recursi

; 82   : 	{
; 83   : 		ds = (int)((float)DotProduct( mid, surf->texinfo->vecs[0] ) + surf->texinfo->vecs[0][3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	imul	ecx, ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	imul	ecx, eax, 3
	addss	xmm0, DWORD PTR [edx+ecx]
	cvttss2si edx, xmm0
	mov	DWORD PTR _ds$[ebp], edx

; 84   : 		dt = (int)((float)DotProduct( mid, surf->texinfo->vecs[1] ) + surf->texinfo->vecs[1][3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	eax, edx
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	edx, ecx
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	ecx, eax
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _mid$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _surf$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 3
	addss	xmm0, DWORD PTR [edx+eax]
	cvttss2si ecx, xmm0
	mov	DWORD PTR _dt$[ebp], ecx

; 85   : 
; 86   : 		if( ds >= surf->texturemins[0] && dt >= surf->texturemins[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx+20]
	cmp	DWORD PTR _ds$[ebp], eax
	jl	SHORT $LN16@PM_Recursi
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax+20]
	cmp	DWORD PTR _dt$[ebp], edx
	jl	SHORT $LN16@PM_Recursi

; 87   : 		{
; 88   : 			int s = ds - surf->texturemins[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _ds$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _s$2[ebp], ecx

; 89   : 			int t = dt - surf->texturemins[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax+20]
	mov	eax, DWORD PTR _dt$[ebp]
	sub	eax, edx
	mov	DWORD PTR _t$1[ebp], eax

; 90   : 
; 91   : 			if( s <= surf->extents[0] && t <= surf->extents[1] )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _surf$[ebp]
	movsx	eax, WORD PTR [edx+ecx+24]
	cmp	DWORD PTR _s$2[ebp], eax
	jg	SHORT $LN16@PM_Recursi
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _surf$[ebp]
	movsx	edx, WORD PTR [ecx+eax+24]
	cmp	DWORD PTR _t$1[ebp], edx
	jg	SHORT $LN16@PM_Recursi

; 92   : 				return surf;

	mov	eax, DWORD PTR _surf$[ebp]
	jmp	SHORT $LN1@PM_Recursi
$LN16@PM_Recursi:

; 93   : 		}
; 94   : 	}

	jmp	$LN2@PM_Recursi
$LN3@PM_Recursi:

; 95   : 
; 96   : 	return PM_RecursiveSurfCheck( model, node->children[side^1], mid, p2 );

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _side$[ebp]
	xor	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	_PM_RecursiveSurfCheck
	add	esp, 16					; 00000010H
$LN1@PM_Recursi:

; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_RecursiveSurfCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_surface.c
;	COMDAT _PM_TraceTexture
_TEXT	SEGMENT
_surf$ = -4						; size = 4
_pe$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_PM_TraceTexture PROC					; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 148  : 	msurface_t	*surf = PM_TraceSurface( pe, start, end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _surf$[ebp], eax

; 149  : 
; 150  : 	if( !surf || !surf->texinfo || !surf->texinfo->texture )

	cmp	DWORD PTR _surf$[ebp], 0
	je	SHORT $LN3@PM_TraceTe
	mov	eax, DWORD PTR _surf$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN3@PM_TraceTe
	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	DWORD PTR [ecx+36], 0
	jne	SHORT $LN2@PM_TraceTe
$LN3@PM_TraceTe:

; 151  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@PM_TraceTe
$LN2@PM_TraceTe:

; 152  : 
; 153  : 	return surf->texinfo->texture->name;

	mov	eax, DWORD PTR _surf$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+36]
$LN1@PM_TraceTe:

; 154  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TraceTexture ENDP
_TEXT	ENDS
END
