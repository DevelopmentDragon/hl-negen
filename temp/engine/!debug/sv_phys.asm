; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_phys.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SV_GetServerTime
PUBLIC	_SV_GetFrameTime
PUBLIC	_SV_GetHeadNode
PUBLIC	_SV_ServerState
PUBLIC	_SV_UpdateFogSettings
PUBLIC	_pfnLoadImagePixels
PUBLIC	_pfnGetModelName
EXTRN	_Host_Error:PROC
EXTRN	_COM_SaveFile:PROC
EXTRN	_pfnDrawConsoleString:PROC
EXTRN	_pfnDrawSetTextColor:PROC
EXTRN	_pfnDrawConsoleStringLen:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_GL_TextureData:PROC
EXTRN	_Mod_CheckLump:PROC
EXTRN	_Mod_ReadLump:PROC
EXTRN	_Mod_SaveLump:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_BoxInPVS:PROC
EXTRN	_pfnWriteBytes:PROC
EXTRN	_SV_MoveNoEnts:PROC
EXTRN	_SV_MoveNormal:PROC
EXTRN	_SV_TraceSurface:PROC
EXTRN	_SV_LinkEdict:PROC
EXTRN	_SV_GetLightStyle:PROC
EXTRN	_gTriApi:BYTE
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
CONST	SEGMENT
_current_table DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0bf800000r			; -1
CONST	ENDS
PUBLIC	_SV_DrawDebugTriangles
PUBLIC	_SV_DrawOrthoTriangles
PUBLIC	_SV_Physics
PUBLIC	_SV_InitPhysicsAPI
PUBLIC	_SV_CheckVelocity
PUBLIC	_SV_CheckWater
PUBLIC	_SV_RunThink
PUBLIC	_SV_PlayerRunThink
PUBLIC	_SV_Impact
PUBLIC	_SV_CanPushed
PUBLIC	_SV_CheckAllEnts
PUBLIC	_SV_UpdateBaseVelocity
PUBLIC	_SV_AngularMove
PUBLIC	_SV_LinearMove
PUBLIC	_SV_RecursiveWaterLevel
PUBLIC	_SV_Submerged
PUBLIC	_SV_CheckMover
PUBLIC	_SV_ClipVelocity
PUBLIC	_SV_FlyMove
PUBLIC	_SV_AddGravity
PUBLIC	_SV_AddHalfGravity
PUBLIC	_SV_AllowPushRotate
PUBLIC	_SV_PushEntity
PUBLIC	_SV_Physics_Pusher
PUBLIC	_SV_Physics_Follow
PUBLIC	_SV_Physics_Compound
PUBLIC	_SV_Physics_Noclip
PUBLIC	_SV_CheckWaterTransition
PUBLIC	_SV_Physics_Toss
PUBLIC	_SV_Physics_Step
PUBLIC	_SV_Physics_None
PUBLIC	?__LINE__Var@?0??SV_CheckAllEnts@@9@9		; `SV_CheckAllEnts'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@ILHMIKIC@?$FO1Error?3?$FO7?5Freed?5entity?5?$CFs?5?$CI?$CFi?$CJ@ ; `string'
PUBLIC	??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0DJ@ENHLGMCN@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5has?5i@ ; `string'
PUBLIC	??_C@_0DB@LHHIOHKC@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5trash@ ; `string'
PUBLIC	??_C@_0BK@FPJNFHPF@Got?5a?5NaN?5velocity?5on?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@JOACCKMB@Got?5a?5NaN?5origin?5on?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CP@COFEPPBP@Got?5a?5velocity?5too?5high?5on?5?$CFs?5?$CI@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_UpdateBaseVelocity@@9@9	; `SV_UpdateBaseVelocity'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_CheckMover@@9@9		; `SV_CheckMover'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_FlyMove@@9@9		; `SV_FlyMove'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_PushEntity@@9@9		; `SV_PushEntity'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_PushMove@@9@9		; `SV_PushMove'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_PushRotate@@9@9		; `SV_PushRotate'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_Physics_Follow@@9@9		; `SV_Physics_Follow'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_Physics_Compound@@9@9	; `SV_Physics_Compound'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@	; `string'
PUBLIC	??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@	; `string'
PUBLIC	?__LINE__Var@?0??SV_Physics_Toss@@9@9		; `SV_Physics_Toss'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??SV_Physics_Step@@9@9		; `SV_Physics_Step'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@DEJHFKPP@SV_Physics?3?5bad?5movetype?5?$CFi?6@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_Physics@@9@9		; `SV_Physics'::`1'::__LINE__Var
PUBLIC	??_C@_0M@KODFIOCL@sv_skyangle@			; `string'
PUBLIC	?__LINE__Var@?0??pfnGetFilesList@@9@9		; `pfnGetFilesList'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??pfnLoadImagePixels@@9@9	; `pfnLoadImagePixels'::`1'::__LINE__Var
PUBLIC	??_C@_0BL@MAPOEFPK@Server_GetPhysicsInterface@	; `string'
PUBLIC	??_C@_0DK@HEIDKLFD@SV_LoadProgs?3?5?$FO2initailized?5ext@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fdd70a4
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@40400000
PUBLIC	__real@40ac200000000000
PUBLIC	__real@41200000
PUBLIC	__real@43160000
PUBLIC	__real@44610000
PUBLIC	__real@45610000
PUBLIC	__real@bf800000
PUBLIC	__real@c5610000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Mem_IsAllocatedExt:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_FS_Search:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Host_PrintEngineFeatures:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_SV_StartSound:PROC
EXTRN	_fabs:PROC
EXTRN	_fmod:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_VectorCompareEpsilon:PROC
EXTRN	_Matrix4x4_VectorTransform:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_ConcatTransforms:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_ConvertToEntity:PROC
EXTRN	_Matrix4x4_Invert_Simple:PROC
EXTRN	_SV_TestEntityPosition:PROC
EXTRN	_SV_CheckBottom:PROC
EXTRN	_SV_WaterMove:PROC
EXTRN	_SV_FreeEdict:PROC
EXTRN	_SV_ClassName:PROC
EXTRN	_SV_CopyTraceToGlobal:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_Move:PROC
EXTRN	_SV_TruePointContents:PROC
EXTRN	_SV_PointContents:PROC
EXTRN	_SV_RunLightStyles:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_areanodes:BYTE
EXTRN	_sv_friction:BYTE
EXTRN	_sv_gravity:BYTE
EXTRN	_sv_stopspeed:BYTE
EXTRN	_sv_maxvelocity:BYTE
EXTRN	_sv_skyspeed:BYTE
EXTRN	_sv_skyangle:BYTE
EXTRN	_sv_check_errors:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?nextcheck@?1??SV_CheckAllEnts@@9@9 DQ 01H DUP (?)	; `SV_CheckAllEnts'::`2'::nextcheck
?t@?1??pfnGetFilesList@@9@9 DD 01H DUP (?)		; `pfnGetFilesList'::`2'::t
?pPhysIface@?1??SV_InitPhysicsAPI@@9@9 DD 01H DUP (?)	; `SV_InitPhysicsAPI'::`2'::pPhysIface
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c5610000
CONST	SEGMENT
__real@c5610000 DD 0c5610000r			; -3600
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@45610000
CONST	SEGMENT
__real@45610000 DD 045610000r			; 3600
CONST	ENDS
;	COMDAT __real@44610000
CONST	SEGMENT
__real@44610000 DD 044610000r			; 900
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40ac200000000000
CONST	SEGMENT
__real@40ac200000000000 DQ 040ac200000000000r	; 3600
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdd70a4
CONST	SEGMENT
__real@3fdd70a4 DD 03fdd70a4r			; 1.73
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DK@HEIDKLFD@SV_LoadProgs?3?5?$FO2initailized?5ext@
CONST	SEGMENT
??_C@_0DK@HEIDKLFD@SV_LoadProgs?3?5?$FO2initailized?5ext@ DB 'SV_LoadProg'
	DB	's: ^2initailized extended PhysicAPI ^7ver. %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAPOEFPK@Server_GetPhysicsInterface@
CONST	SEGMENT
??_C@_0BL@MAPOEFPK@Server_GetPhysicsInterface@ DB 'Server_GetPhysicsInter'
	DB	'face', 00H					; `string'
CONST	ENDS
_DATA	SEGMENT
_gPhysicsAPI DD	FLAT:_SV_LinkEdict
	DD	FLAT:_SV_GetServerTime
	DD	FLAT:_SV_GetFrameTime
	DD	FLAT:_SV_ModelHandle
	DD	FLAT:_SV_GetHeadNode
	DD	FLAT:_SV_ServerState
	DD	FLAT:_Host_Error
	DD	FLAT:_gTriApi
	DD	FLAT:_pfnDrawConsoleString
	DD	FLAT:_pfnDrawSetTextColor
	DD	FLAT:_pfnDrawConsoleStringLen
	DD	FLAT:_Con_NPrintf
	DD	FLAT:_Con_NXPrintf
	DD	FLAT:_SV_GetLightStyle
	DD	FLAT:_SV_UpdateFogSettings
	DD	FLAT:_pfnGetFilesList
	DD	FLAT:_SV_TraceSurface
	DD	FLAT:_GL_TextureData
	DD	FLAT:_pfnMem_Alloc
	DD	FLAT:_pfnMem_Free
	DD	FLAT:_pfnPointContents
	DD	FLAT:_SV_MoveNormal
	DD	FLAT:_SV_MoveNoEnts
	DD	FLAT:_SV_BoxInPVS
	DD	FLAT:_pfnWriteBytes
	DD	FLAT:_Mod_CheckLump
	DD	FLAT:_Mod_ReadLump
	DD	FLAT:_Mod_SaveLump
	DD	FLAT:_COM_SaveFile
	DD	FLAT:_pfnLoadImagePixels
	DD	FLAT:_pfnGetModelName
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnLoadImagePixels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnLoadImagePixels@@9@9 DD 07c4H	; `pfnLoadImagePixels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetFilesList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetFilesList@@9@9 DD 0793H		; `pfnGetFilesList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@KODFIOCL@sv_skyangle@
CONST	SEGMENT
??_C@_0M@KODFIOCL@sv_skyangle@ DB 'sv_skyangle', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Physics@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Physics@@9@9 DD 06f0H		; `SV_Physics'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@DEJHFKPP@SV_Physics?3?5bad?5movetype?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@DEJHFKPP@SV_Physics?3?5bad?5movetype?5?$CFi?6@ DB 'SV_Physics: '
	DB	'bad movetype %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Physics_Step@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Physics_Step@@9@9 DD 0622H		; `SV_Physics_Step'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Physics_Toss@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Physics_Toss@@9@9 DD 0590H		; `SV_Physics_Toss'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@
CONST	SEGMENT
??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@
CONST	SEGMENT
??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Physics_Compound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Physics_Compound@@9@9 DD 04dcH	; `SV_Physics_Compound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Physics_Follow@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Physics_Follow@@9@9 DD 04c0H	; `SV_Physics_Follow'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_PushRotate@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_PushRotate@@9@9 DD 03ecH		; `SV_PushRotate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_PushMove@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_PushMove@@9@9 DD 0377H		; `SV_PushMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_PushEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_PushEntity@@9@9 DD 030dH		; `SV_PushEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FlyMove@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FlyMove@@9@9 DD 022eH		; `SV_FlyMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_CheckMover@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_CheckMover@@9@9 DD 01ecH		; `SV_CheckMover'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??SV_UpdateBaseVelocity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_UpdateBaseVelocity@@9@9 DD 0a1H	; `SV_UpdateBaseVelocity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CP@COFEPPBP@Got?5a?5velocity?5too?5high?5on?5?$CFs?5?$CI@
CONST	SEGMENT
??_C@_0CP@COFEPPBP@Got?5a?5velocity?5too?5high?5on?5?$CFs?5?$CI@ DB 'Got '
	DB	'a velocity too high on %s ( %.2f > %.2f )', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JOACCKMB@Got?5a?5NaN?5origin?5on?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@JOACCKMB@Got?5a?5NaN?5origin?5on?5?$CFs?6@ DB 'Got a NaN origin'
	DB	' on %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FPJNFHPF@Got?5a?5NaN?5velocity?5on?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@FPJNFHPF@Got?5a?5NaN?5velocity?5on?5?$CFs?6@ DB 'Got a NaN velo'
	DB	'city on %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LHHIOHKC@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5trash@
CONST	SEGMENT
??_C@_0DB@LHHIOHKC@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5trash@ DB '^'
	DB	'1Error:^7 Entity %s (%i) trashed private data.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@ENHLGMCN@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5has?5i@
CONST	SEGMENT
??_C@_0DJ@ENHLGMCN@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5has?5i@ DB '^'
	DB	'1Error:^7 Entity %s (%i) has invalid container, fixed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_phys.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ILHMIKIC@?$FO1Error?3?$FO7?5Freed?5entity?5?$CFs?5?$CI?$CFi?$CJ@
CONST	SEGMENT
??_C@_0DD@ILHMIKIC@?$FO1Error?3?$FO7?5Freed?5entity?5?$CFs?5?$CI?$CFi?$CJ@ DB '^'
	DB	'1Error:^7 Freed entity %s (%i) has private data.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_CheckAllEnts@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_CheckAllEnts@@9@9 DD 043H		; `SV_CheckAllEnts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	09d0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0ab2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0381H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0546H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0b13H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	06e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0389H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0b6cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	027fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	011bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0216H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03ecH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnGetModelName
_TEXT	SEGMENT
_modelindex$ = 8					; size = 4
_pfnGetModelName PROC					; COMDAT

; 2004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2005 : 	if( modelindex < 0 || modelindex >= MAX_MODELS )

	cmp	DWORD PTR _modelindex$[ebp], 0
	jl	SHORT $LN3@pfnGetMode
	cmp	DWORD PTR _modelindex$[ebp], 1024	; 00000400H
	jl	SHORT $LN2@pfnGetMode
$LN3@pfnGetMode:

; 2006 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetMode
$LN2@pfnGetMode:

; 2007 : 	return sv.model_precache[modelindex];

	mov	eax, DWORD PTR _modelindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _sv+196
$LN1@pfnGetMode:

; 2008 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnLoadImagePixels
_TEXT	SEGMENT
_buffer$ = -8						; size = 4
_pic$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_pfnLoadImagePixels PROC				; COMDAT

; 1988 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1989 : 	rgbdata_t	*pic = FS_LoadImage( filename, NULL, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax

; 1990 : 	byte	*buffer;
; 1991 : 
; 1992 : 	if( !pic ) return NULL;

	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN2@pfnLoadIma
	xor	eax, eax
	jmp	SHORT $LN1@pfnLoadIma
$LN2@pfnLoadIma:

; 1993 : 
; 1994 : 	buffer = Mem_Malloc( svgame.mempool, pic->size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnLoadImagePixels@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _svgame+19588
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 1995 : 	if( buffer ) memcpy( buffer, pic->buffer, pic->size );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@pfnLoadIma
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@pfnLoadIma:

; 1996 : 	if( width ) *width = pic->width;

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN4@pfnLoadIma
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@pfnLoadIma:

; 1997 : 	if( height ) *height = pic->height;

	cmp	DWORD PTR _height$[ebp], 0
	je	SHORT $LN5@pfnLoadIma
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@pfnLoadIma:

; 1998 : 	FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1999 : 
; 2000 : 	return buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
$LN1@pfnLoadIma:

; 2001 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnLoadImagePixels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnPointContents
_TEXT	SEGMENT
_cont$ = -8						; size = 4
_oldmask$ = -4						; size = 4
_pos$ = 8						; size = 4
_groupmask$ = 12					; size = 4
_pfnPointContents PROC					; COMDAT

; 1974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1975 : 	int	oldmask, cont;
; 1976 : 
; 1977 : 	if( !pos ) return CONTENTS_NONE;

	cmp	DWORD PTR _pos$[ebp], 0
	jne	SHORT $LN2@pfnPointCo
	xor	eax, eax
	jmp	SHORT $LN1@pfnPointCo
$LN2@pfnPointCo:

; 1978 : 	oldmask = svs.groupmask;

	mov	eax, DWORD PTR _svs+20
	mov	DWORD PTR _oldmask$[ebp], eax

; 1979 : 
; 1980 : 	svs.groupmask = groupmask;

	mov	eax, DWORD PTR _groupmask$[ebp]
	mov	DWORD PTR _svs+20, eax

; 1981 : 	cont = SV_PointContents( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1982 : 	svs.groupmask = oldmask; // restore old mask

	mov	eax, DWORD PTR _oldmask$[ebp]
	mov	DWORD PTR _svs+20, eax

; 1983 : 
; 1984 : 	return cont;

	mov	eax, DWORD PTR _cont$[ebp]
$LN1@pfnPointCo:

; 1985 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnMem_Free
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_pfnMem_Free PROC					; COMDAT

; 1962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1963 : 	if( !mem ) return;

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN2@pfnMem_Fre
	jmp	SHORT $LN1@pfnMem_Fre
$LN2@pfnMem_Fre:

; 1964 : 	_Mem_Free( mem, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@pfnMem_Fre:

; 1965 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMem_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnMem_Alloc
_TEXT	SEGMENT
_cb$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_pfnMem_Alloc PROC					; COMDAT

; 1957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1958 : 	return _Mem_Alloc( svgame.mempool, cb, true, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _svgame+19588
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H

; 1959 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMem_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _pfnGetFilesList
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_numFiles$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_pfnGetFilesList PROC					; COMDAT

; 1939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1940 : 	static search_t	*t = NULL;
; 1941 : 
; 1942 : 	if( t ) Mem_Free( t ); // release prev search

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	je	SHORT $LN2@pfnGetFile
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetFilesList@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@pfnGetFile:

; 1943 : 
; 1944 : 	t = FS_Search( pattern, true, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, eax

; 1945 : 
; 1946 : 	if( !t )

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	jne	SHORT $LN3@pfnGetFile

; 1947 : 	{
; 1948 : 		if( numFiles ) *numFiles = 0;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN4@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@pfnGetFile:

; 1949 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetFile
$LN3@pfnGetFile:

; 1950 : 	}
; 1951 : 
; 1952 : 	if( numFiles ) *numFiles = t->numfilenames;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN5@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@pfnGetFile:

; 1953 : 	return t->filenames;

	mov	eax, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	eax, DWORD PTR [eax+4]
$LN1@pfnGetFile:

; 1954 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetFilesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_UpdateFogSettings
_TEXT	SEGMENT
_packed_fog$ = 8					; size = 4
_SV_UpdateFogSettings PROC				; COMDAT

; 1927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1928 : 	svgame.movevars.fog_settings = packed_fog;

	mov	eax, DWORD PTR _packed_fog$[ebp]
	mov	DWORD PTR _svgame+8088, eax

; 1929 : 	host.movevars_changed = true; // force to transmit

	mov	DWORD PTR _host+34416, 1

; 1930 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateFogSettings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_ServerState
_TEXT	SEGMENT
_SV_ServerState PROC					; COMDAT

; 1869 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1870 : 	return sv.state;

	mov	eax, DWORD PTR _sv

; 1871 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ServerState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_GetHeadNode
_TEXT	SEGMENT
_SV_GetHeadNode PROC					; COMDAT

; 1857 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1858 : 	return sv_areanodes;

	mov	eax, OFFSET _sv_areanodes

; 1859 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetHeadNode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_GetFrameTime
_TEXT	SEGMENT
_SV_GetFrameTime PROC					; COMDAT

; 1845 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1846 : 	return sv.frametime;

	fld	DWORD PTR _sv+32

; 1847 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetFrameTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_GetServerTime
_TEXT	SEGMENT
_SV_GetServerTime PROC					; COMDAT

; 1833 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1834 : 	return sv.time;

	fld	QWORD PTR _sv+16

; 1835 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetServerTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Entity
_TEXT	SEGMENT
tv178 = -68						; size = 4
tv160 = -68						; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Entity PROC					; COMDAT

; 1708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1709 : 	// user dll can override movement type (Xash3D extension)
; 1710 : 	if( svgame.physFuncs.SV_PhysicsEntity && svgame.physFuncs.SV_PhysicsEntity( ent ))

	cmp	DWORD PTR _svgame+19500, 0
	je	SHORT $LN4@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19500
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@SV_Physics

; 1711 : 		return; // overrided

	jmp	$LN21@SV_Physics
$LN4@SV_Physics:

; 1712 : 
; 1713 : 	SV_UpdateBaseVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_UpdateBaseVelocity
	add	esp, 4

; 1714 : 
; 1715 : 	if( !FBitSet( ent->v.flags, FL_BASEVELOCITY ) && !VectorIsNull( ent->v.basevelocity ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 4194304				; 00400000H
	jne	$LN5@SV_Physics
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@SV_Physics
$LN6@SV_Physics:

; 1716 : 	{
; 1717 : 		// Apply momentum (add in half of the previous frame of velocity first)
; 1718 : 		VectorMA( ent->v.velocity, 1.0f + (sv.frametime * 0.5f), ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+172]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+160]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+172]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+160]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f000000
	addss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+172]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+160]
	addss	xmm1, xmm0
	movss	DWORD PTR tv160[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv160[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0

; 1719 : 		VectorClear( ent->v.basevelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+172], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+172], xmm0
$LN5@SV_Physics:

; 1720 : 	}
; 1721 : 
; 1722 : 	ent->v.flags &= ~FL_BASEVELOCITY;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -4194305				; ffbfffffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1723 : 
; 1724 : 	if( svgame.globals->force_retouch != 0.0f )

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_Physics

; 1725 : 	{
; 1726 : 		// force retouch even for stationary
; 1727 : 		SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN7@SV_Physics:

; 1728 : 	}
; 1729 : 
; 1730 : 	switch( ent->v.movetype )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv178[ebp], ecx
	cmp	DWORD PTR tv178[ebp], 14		; 0000000eH
	ja	$LN2@SV_Physics
	mov	edx, DWORD PTR tv178[ebp]
	jmp	DWORD PTR $LN23@SV_Physics[edx*4]
$LN8@SV_Physics:

; 1731 : 	{
; 1732 : 	case MOVETYPE_NONE:
; 1733 : 		SV_Physics_None( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_None
	add	esp, 4

; 1734 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN9@SV_Physics:

; 1735 : 	case MOVETYPE_NOCLIP:
; 1736 : 		SV_Physics_Noclip( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Noclip
	add	esp, 4

; 1737 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN10@SV_Physics:

; 1738 : 	case MOVETYPE_FOLLOW:
; 1739 : 		SV_Physics_Follow( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Follow
	add	esp, 4

; 1740 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN11@SV_Physics:

; 1741 : 	case MOVETYPE_COMPOUND:
; 1742 : 		SV_Physics_Compound( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Compound
	add	esp, 4

; 1743 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN12@SV_Physics:

; 1744 : 	case MOVETYPE_STEP:
; 1745 : 	case MOVETYPE_PUSHSTEP:
; 1746 : 		SV_Physics_Step( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Step
	add	esp, 4

; 1747 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN14@SV_Physics:

; 1748 : 	case MOVETYPE_FLY:
; 1749 : 	case MOVETYPE_TOSS:
; 1750 : 	case MOVETYPE_BOUNCE:
; 1751 : 	case MOVETYPE_FLYMISSILE:
; 1752 : 	case MOVETYPE_BOUNCEMISSILE:
; 1753 : 		SV_Physics_Toss( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Toss
	add	esp, 4

; 1754 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN19@SV_Physics:

; 1755 : 	case MOVETYPE_PUSH:
; 1756 : 		SV_Physics_Pusher( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Pusher
	add	esp, 4

; 1757 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN20@SV_Physics:

; 1758 : 	case MOVETYPE_WALK:
; 1759 : 		Host_Error( "SV_Physics: bad movetype %i\n", ent->v.movetype );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	push	ecx
	push	OFFSET ??_C@_0BN@DEJHFKPP@SV_Physics?3?5bad?5movetype?5?$CFi?6@
	call	_Host_Error
	add	esp, 8
$LN2@SV_Physics:

; 1760 : 		break;
; 1761 : 	}
; 1762 : 
; 1763 : 	// g-cont. don't alow free entities during loading because
; 1764 : 	// this produce a corrupted baselines
; 1765 : 	if( sv.state == ss_active && FBitSet( ent->v.flags, FL_KILLME ))

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN21@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN21@SV_Physics

; 1766 : 		SV_FreeEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4
$LN21@SV_Physics:

; 1767 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@SV_Physics:
	DD	$LN8@SV_Physics
	DD	$LN2@SV_Physics
	DD	$LN2@SV_Physics
	DD	$LN20@SV_Physics
	DD	$LN12@SV_Physics
	DD	$LN14@SV_Physics
	DD	$LN14@SV_Physics
	DD	$LN19@SV_Physics
	DD	$LN9@SV_Physics
	DD	$LN14@SV_Physics
	DD	$LN14@SV_Physics
	DD	$LN14@SV_Physics
	DD	$LN10@SV_Physics
	DD	$LN12@SV_Physics
	DD	$LN11@SV_Physics
_SV_Physics_Entity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_None
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_SV_Physics_None PROC					; COMDAT

; 1702 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1703 : 	SV_RunThink( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4

; 1704 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_None ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Step
_TEXT	SEGMENT
tv438 = -324						; size = 4
tv384 = -324						; size = 4
tv360 = -324						; size = 4
tv352 = -324						; size = 4
tv332 = -324						; size = 4
tv305 = -324						; size = 4
tv277 = -324						; size = 4
tv240 = -324						; size = 4
tv194 = -324						; size = 4
$T1 = -320						; size = 56
$T2 = -264						; size = 56
_monsterClip$3 = -144					; size = 4
_friction$4 = -140					; size = 4
_newspeed$5 = -136					; size = 4
_speed$6 = -132						; size = 4
_control$7 = -128					; size = 4
_vel$8 = -124						; size = 4
_buoyancy$9 = -120					; size = 4
_y$ = -116						; size = 4
_x$ = -112						; size = 4
_trace$ = -108						; size = 56
_point$ = -52						; size = 12
_maxs$ = -40						; size = 12
_mins$ = -28						; size = 12
_wasonmover$ = -16					; size = 4
_wasonground$ = -12					; size = 4
_inwater$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Step PROC					; COMDAT

; 1570 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1571 : 	qboolean	inwater;
; 1572 : 	qboolean	wasonground;
; 1573 : 	qboolean	wasonmover;
; 1574 : 	vec3_t	mins, maxs;
; 1575 : 	vec3_t	point;
; 1576 : 	trace_t	trace;
; 1577 : 	int	x, y;
; 1578 : 
; 1579 : 	SV_WaterMove( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_WaterMove
	add	esp, 4

; 1580 : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1581 : 
; 1582 : 	wasonground = (ent->v.flags & FL_ONGROUND);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	mov	DWORD PTR _wasonground$[ebp], ecx

; 1583 : 	wasonmover = SV_CheckMover( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckMover
	add	esp, 4
	mov	DWORD PTR _wasonmover$[ebp], eax

; 1584 : 	inwater = SV_CheckWater( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWater
	add	esp, 4
	mov	DWORD PTR _inwater$[ebp], eax

; 1585 : 
; 1586 : 	if( FBitSet( ent->v.flags, FL_FLOAT ) && ent->v.waterlevel > 0 )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN8@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+672], 0
	jle	SHORT $LN8@SV_Physics

; 1587 : 	{
; 1588 : 		float buoyancy = SV_Submerged( ent ) * ent->v.skin * sv.frametime;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Submerged
	add	esp, 4
	fstp	DWORD PTR tv438[ebp]
	movss	xmm0, DWORD PTR tv438[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+404]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR _buoyancy$9[ebp], xmm0

; 1589 : 
; 1590 : 		SV_AddGravity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AddGravity
	add	esp, 4

; 1591 : 		ent->v.velocity[2] += buoyancy;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	addss	xmm0, DWORD PTR _buoyancy$9[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
$LN8@SV_Physics:

; 1592 : 	}
; 1593 : 
; 1594 : 	if( !wasonground )

	cmp	DWORD PTR _wasonground$[ebp], 0
	jne	SHORT $LN13@SV_Physics

; 1595 : 	{
; 1596 : 		if( !FBitSet( ent->v.flags, FL_FLY ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1
	jne	SHORT $LN13@SV_Physics

; 1597 : 		{
; 1598 : 			if( !FBitSet( ent->v.flags, FL_SWIM ) || ( ent->v.waterlevel <= 0 ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 2
	je	SHORT $LN12@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+672], 0
	jg	SHORT $LN13@SV_Physics
$LN12@SV_Physics:

; 1599 : 			{
; 1600 : 				if( !inwater )

	cmp	DWORD PTR _inwater$[ebp], 0
	jne	SHORT $LN13@SV_Physics

; 1601 : 					SV_AddGravity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AddGravity
	add	esp, 4
$LN13@SV_Physics:

; 1602 : 			}
; 1603 : 		}
; 1604 : 	}
; 1605 : 
; 1606 : 	if( !VectorIsNull( ent->v.velocity ) || !VectorIsNull( ent->v.basevelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN17@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN17@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_Physics
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN14@SV_Physics
$LN17@SV_Physics:

; 1607 : 	{
; 1608 : 		ent->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1609 : 
; 1610 : 		if(( wasonground || wasonmover ) && ( ent->v.health > 0 || SV_CheckBottom( ent, MOVE_NORMAL )))

	cmp	DWORD PTR _wasonground$[ebp], 0
	jne	SHORT $LN19@SV_Physics
	cmp	DWORD PTR _wasonmover$[ebp], 0
	je	$LN21@SV_Physics
$LN19@SV_Physics:
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+520]
	comiss	xmm0, DWORD PTR __real@00000000
	ja	SHORT $LN20@SV_Physics
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckBottom
	add	esp, 8
	test	eax, eax
	je	$LN21@SV_Physics
$LN20@SV_Physics:

; 1611 : 		{
; 1612 : 			float	*vel = ent->v.velocity;

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR _vel$8[ebp], eax

; 1613 : 			float	control, speed, newspeed;
; 1614 : 			float	friction;
; 1615 : 
; 1616 : 			speed = sqrt(( vel[0] * vel[0] ) + ( vel[1] * vel[1] ));	// DotProduct2D

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vel$8[ebp]
	mov	esi, DWORD PTR _vel$8[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _vel$8[ebp]
	mov	esi, DWORD PTR _vel$8[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _speed$6[ebp]

; 1617 : 
; 1618 : 			if( speed )

	movss	xmm0, DWORD PTR _speed$6[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN21@SV_Physics

; 1619 : 			{
; 1620 : 				friction = sv_friction.value * ent->v.friction;	// factor

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv_friction+12
	mulss	xmm0, DWORD PTR [eax+456]
	movss	DWORD PTR _friction$4[ebp], xmm0

; 1621 : 				ent->v.friction = 1.0f; // g-cont. ???

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+456], xmm0

; 1622 : 				if( wasonmover ) friction *= 0.5f; // add a little friction

	cmp	DWORD PTR _wasonmover$[ebp], 0
	je	SHORT $LN22@SV_Physics
	movss	xmm0, DWORD PTR _friction$4[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _friction$4[ebp], xmm0
$LN22@SV_Physics:

; 1623 : 
; 1624 : 				control = (speed < sv_stopspeed.value) ? sv_stopspeed.value : speed;

	movss	xmm0, DWORD PTR _sv_stopspeed+12
	comiss	xmm0, DWORD PTR _speed$6[ebp]
	jbe	SHORT $LN33@SV_Physics
	movss	xmm0, DWORD PTR _sv_stopspeed+12
	movss	DWORD PTR tv194[ebp], xmm0
	jmp	SHORT $LN34@SV_Physics
$LN33@SV_Physics:
	movss	xmm0, DWORD PTR _speed$6[ebp]
	movss	DWORD PTR tv194[ebp], xmm0
$LN34@SV_Physics:
	movss	xmm0, DWORD PTR tv194[ebp]
	movss	DWORD PTR _control$7[ebp], xmm0

; 1625 : 				newspeed = speed - (sv.frametime * control * friction);

	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR _control$7[ebp]
	mulss	xmm0, DWORD PTR _friction$4[ebp]
	movss	xmm1, DWORD PTR _speed$6[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _newspeed$5[ebp], xmm1

; 1626 : 				if( newspeed < 0 ) newspeed = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _newspeed$5[ebp]
	jbe	SHORT $LN23@SV_Physics
	xorps	xmm0, xmm0
	movss	DWORD PTR _newspeed$5[ebp], xmm0
$LN23@SV_Physics:

; 1627 : 				newspeed /= speed;

	movss	xmm0, DWORD PTR _newspeed$5[ebp]
	divss	xmm0, DWORD PTR _speed$6[ebp]
	movss	DWORD PTR _newspeed$5[ebp], xmm0

; 1628 : 
; 1629 : 				vel[0] = vel[0] * newspeed;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vel$8[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _newspeed$5[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vel$8[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1630 : 				vel[1] = vel[1] * newspeed;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vel$8[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _newspeed$5[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _vel$8[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN21@SV_Physics:

; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : 		VectorAdd( ent->v.velocity, ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+160]
	addss	xmm0, DWORD PTR [esi+ecx+172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	movss	DWORD PTR tv240[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv240[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 1635 : 		SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1636 : 
; 1637 : 		SV_FlyMove( ent, sv.frametime, NULL );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FlyMove
	add	esp, 12					; 0000000cH

; 1638 : 		if( ent->free ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN24@SV_Physics
	jmp	$LN1@SV_Physics
$LN24@SV_Physics:

; 1639 : 
; 1640 : 		SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1641 : 		VectorSubtract( ent->v.velocity, ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	subss	xmm0, DWORD PTR [esi+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+160]
	subss	xmm0, DWORD PTR [esi+ecx+172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+160]
	subss	xmm0, DWORD PTR [esi+eax+172]
	movss	DWORD PTR tv277[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 1642 : 		SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1643 : 
; 1644 : 		VectorAdd( ent->v.origin, ent->v.mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+352]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+352]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mins$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+352]
	movss	DWORD PTR tv305[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv305[ebp]
	movss	DWORD PTR _mins$[ebp+eax], xmm0

; 1645 : 		VectorAdd( ent->v.origin, ent->v.maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+364]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+364]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _maxs$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+364]
	movss	DWORD PTR tv332[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv332[ebp]
	movss	DWORD PTR _maxs$[ebp+eax], xmm0

; 1646 : 
; 1647 : 		point[2] = mins[2] - 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 1648 : 
; 1649 : 		for( x = 0; x <= 1; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN4@SV_Physics
$LN2@SV_Physics:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN4@SV_Physics:
	cmp	DWORD PTR _x$[ebp], 1
	jg	$LN3@SV_Physics

; 1650 : 		{
; 1651 : 			if( FBitSet( ent->v.flags, FL_ONGROUND ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	je	SHORT $LN25@SV_Physics

; 1652 : 				break;

	jmp	$LN3@SV_Physics
$LN25@SV_Physics:

; 1653 : 
; 1654 : 			for( y = 0; y <= 1; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@SV_Physics
$LN5@SV_Physics:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN7@SV_Physics:
	cmp	DWORD PTR _y$[ebp], 1
	jg	$LN6@SV_Physics

; 1655 : 			{
; 1656 : 				point[0] = x ? maxs[0] : mins[0];

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN35@SV_Physics
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	movss	DWORD PTR tv352[ebp], xmm0
	jmp	SHORT $LN36@SV_Physics
$LN35@SV_Physics:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	movss	DWORD PTR tv352[ebp], xmm0
$LN36@SV_Physics:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv352[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 1657 : 				point[1] = y ? maxs[1] : mins[1];

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN37@SV_Physics
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+eax]
	movss	DWORD PTR tv360[ebp], xmm0
	jmp	SHORT $LN38@SV_Physics
$LN37@SV_Physics:
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv360[ebp], xmm0
$LN38@SV_Physics:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv360[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 1658 : 
; 1659 : 				trace = SV_Move( point, vec3_origin, vec3_origin, point, MOVE_NORMAL, ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _point$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1660 : 
; 1661 : 				if( trace.startsolid )

	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN26@SV_Physics

; 1662 : 				{
; 1663 : 					SetBits( ent->v.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1664 : 					ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 1665 : 					ent->v.friction = 1.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+456], xmm0

; 1666 : 					break;

	jmp	SHORT $LN6@SV_Physics
$LN26@SV_Physics:

; 1667 : 				}
; 1668 : 			}

	jmp	$LN5@SV_Physics
$LN6@SV_Physics:

; 1669 : 		}

	jmp	$LN2@SV_Physics
$LN3@SV_Physics:

; 1670 : 
; 1671 : 		SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 1672 : 	}

	jmp	$LN30@SV_Physics
$LN14@SV_Physics:

; 1673 : 	else
; 1674 : 	{
; 1675 : 		if( svgame.globals->force_retouch != 0 )

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN30@SV_Physics

; 1676 : 		{
; 1677 : 			qboolean monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN39@SV_Physics
	mov	DWORD PTR tv384[ebp], 1
	jmp	SHORT $LN40@SV_Physics
$LN39@SV_Physics:
	mov	DWORD PTR tv384[ebp], 0
$LN40@SV_Physics:
	mov	edx, DWORD PTR tv384[ebp]
	mov	DWORD PTR _monsterClip$3[ebp], edx

; 1678 : 			trace = SV_Move( ent->v.origin, ent->v.mins, ent->v.maxs, ent->v.origin, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1679 : 
; 1680 : 			// hentacle impact code
; 1681 : 			if(( trace.fraction < 1.0f || trace.startsolid ) && SV_IsValidEdict( trace.ent ))

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _trace$[ebp+16]
	ja	SHORT $LN29@SV_Physics
	cmp	DWORD PTR _trace$[ebp+4], 0
	je	SHORT $LN30@SV_Physics
$LN29@SV_Physics:
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Physics_Step@@9@9
	add	eax, 111				; 0000006fH
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN30@SV_Physics

; 1682 : 			{
; 1683 : 				SV_Impact( ent, trace.ent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_Impact
	add	esp, 12					; 0000000cH

; 1684 : 				if( ent->free ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN30@SV_Physics
	jmp	SHORT $LN1@SV_Physics
$LN30@SV_Physics:

; 1685 : 			}
; 1686 : 		}
; 1687 : 	}
; 1688 : 
; 1689 : 	if( !SV_RunThink( ent )) return;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@SV_Physics
	jmp	SHORT $LN1@SV_Physics
$LN31@SV_Physics:

; 1690 : 	SV_CheckWaterTransition( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWaterTransition
	add	esp, 4
$LN1@SV_Physics:

; 1691 : 
; 1692 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Step ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Toss
_TEXT	SEGMENT
tv458 = -264						; size = 4
tv416 = -264						; size = 4
tv326 = -264						; size = 4
tv252 = -264						; size = 4
tv222 = -264						; size = 4
tv203 = -264						; size = 4
tv164 = -264						; size = 4
tv158 = -264						; size = 4
$T1 = -260						; size = 56
$T2 = -204						; size = 56
_vel$3 = -84						; size = 4
_ground$ = -80						; size = 4
_backoff$ = -76						; size = 4
_move$ = -72						; size = 12
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Toss PROC					; COMDAT

; 1424 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1425 : 	trace_t	trace;
; 1426 : 	vec3_t	move;
; 1427 : 	float	backoff;
; 1428 : 	edict_t	*ground;
; 1429 : 
; 1430 : 	SV_CheckWater( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWater
	add	esp, 4

; 1431 : 
; 1432 : 	// regular thinking
; 1433 : 	if( !SV_RunThink( ent )) return;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_Physics
	jmp	$LN1@SV_Physics
$LN6@SV_Physics:

; 1434 : 
; 1435 : 	ground = ent->v.groundentity;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	DWORD PTR _ground$[ebp], ecx

; 1436 : 
; 1437 : 	if( ent->v.velocity[2] > 0 )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN7@SV_Physics

; 1438 : 		ClearBits( ent->v.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN7@SV_Physics:

; 1439 : 
; 1440 : 	if( !SV_IsValidEdict( ground ) || FBitSet( ground->v.flags, FL_MONSTER|FL_CLIENT ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Physics_Toss@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ground$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@SV_Physics
	mov	eax, DWORD PTR _ground$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 40					; 00000028H
	je	SHORT $LN8@SV_Physics
$LN9@SV_Physics:

; 1441 : 		ClearBits( ent->v.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN8@SV_Physics:

; 1442 : 
; 1443 : 	// if on ground and not moving, return.
; 1444 : 	if( FBitSet( ent->v.flags, FL_ONGROUND ) && VectorIsNull( ent->v.velocity ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	je	$LN11@SV_Physics
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@SV_Physics

; 1445 : 	{
; 1446 : 		VectorClear( ent->v.avelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+220], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0

; 1447 : 
; 1448 : 		if( VectorIsNull( ent->v.basevelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Physics

; 1449 : 			return;	// at rest

	jmp	$LN1@SV_Physics
$LN11@SV_Physics:

; 1450 : 	}
; 1451 : 
; 1452 : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1453 : 
; 1454 : 	// add gravity
; 1455 : 	switch( ent->v.movetype )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv158[ebp], ecx
	cmp	DWORD PTR tv158[ebp], 5
	je	SHORT $LN12@SV_Physics
	cmp	DWORD PTR tv158[ebp], 9
	je	SHORT $LN12@SV_Physics
	cmp	DWORD PTR tv158[ebp], 11		; 0000000bH
	je	SHORT $LN12@SV_Physics
	jmp	SHORT $LN15@SV_Physics
$LN12@SV_Physics:

; 1456 : 	{
; 1457 : 	case MOVETYPE_FLY:
; 1458 : 	case MOVETYPE_FLYMISSILE:
; 1459 : 	case MOVETYPE_BOUNCEMISSILE:
; 1460 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN15@SV_Physics:

; 1461 : 	default:
; 1462 : 		SV_AddGravity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AddGravity
	add	esp, 4
$LN2@SV_Physics:

; 1463 : 		break;
; 1464 : 	}
; 1465 : 
; 1466 : 	// move angles (with friction)
; 1467 : 	switch( ent->v.movetype )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv164[ebp], ecx
	cmp	DWORD PTR tv164[ebp], 6
	je	SHORT $LN16@SV_Physics
	cmp	DWORD PTR tv164[ebp], 10		; 0000000aH
	je	SHORT $LN16@SV_Physics
	jmp	SHORT $LN18@SV_Physics
$LN16@SV_Physics:

; 1468 : 	{
; 1469 : 	case MOVETYPE_TOSS:
; 1470 : 	case MOVETYPE_BOUNCE:
; 1471 : 		SV_AngularMove( ent, sv.frametime, ent->v.friction );

	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+456]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_AngularMove
	add	esp, 12					; 0000000cH

; 1472 : 		break;         

	jmp	SHORT $LN4@SV_Physics
$LN18@SV_Physics:

; 1473 : 	default:
; 1474 : 		SV_AngularMove( ent, sv.frametime, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AngularMove
	add	esp, 12					; 0000000cH
$LN4@SV_Physics:

; 1475 : 		break;
; 1476 : 	}
; 1477 : 
; 1478 : 	// move origin
; 1479 : 	// Base velocity is not properly accounted for since this entity will move again
; 1480 : 	// after the bounce without taking it into account
; 1481 : 	VectorAdd( ent->v.velocity, ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+160]
	addss	xmm0, DWORD PTR [esi+ecx+172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	movss	DWORD PTR tv203[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 1482 : 
; 1483 : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1484 : 	VectorScale( ent->v.velocity, sv.frametime, move );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR _sv+32
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+160]
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+160]
	mulss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR tv222[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv222[ebp]
	movss	DWORD PTR _move$[ebp+ecx], xmm0

; 1485 : 
; 1486 : 	VectorSubtract( ent->v.velocity, ent->v.basevelocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	subss	xmm0, DWORD PTR [esi+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+160]
	subss	xmm0, DWORD PTR [esi+ecx+172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+160]
	subss	xmm0, DWORD PTR [esi+eax+172]
	movss	DWORD PTR tv252[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv252[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 1487 : 
; 1488 : 	trace = SV_PushEntity( ent, move, vec3_origin, NULL, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	0
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	_SV_PushEntity
	add	esp, 24					; 00000018H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1489 : 	if( ent->free ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN19@SV_Physics
	jmp	$LN1@SV_Physics
$LN19@SV_Physics:

; 1490 : 
; 1491 : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 1492 : 
; 1493 : 	if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	$LN20@SV_Physics

; 1494 : 	{
; 1495 : 		// entity is trapped in another solid
; 1496 : 		VectorClear( ent->v.avelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+220], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0

; 1497 : 		VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 1498 : 		return;

	jmp	$LN1@SV_Physics
$LN20@SV_Physics:

; 1499 : 	}
; 1500 : 
; 1501 : 	if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@SV_Physics

; 1502 : 	{
; 1503 : 		SV_CheckWaterTransition( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWaterTransition
	add	esp, 4

; 1504 : 		return;

	jmp	$LN1@SV_Physics
$LN21@SV_Physics:

; 1505 : 	}
; 1506 : 
; 1507 : 	if( ent->v.movetype == MOVETYPE_BOUNCE )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 10			; 0000000aH
	jne	SHORT $LN22@SV_Physics

; 1508 : 		backoff = 2.0f - ent->v.friction;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	subss	xmm0, DWORD PTR [eax+456]
	movss	DWORD PTR _backoff$[ebp], xmm0
	jmp	SHORT $LN25@SV_Physics
$LN22@SV_Physics:

; 1509 : 	else if( ent->v.movetype == MOVETYPE_BOUNCEMISSILE )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 11			; 0000000bH
	jne	SHORT $LN24@SV_Physics

; 1510 : 		backoff = 2.0f;

	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _backoff$[ebp], xmm0
	jmp	SHORT $LN25@SV_Physics
$LN24@SV_Physics:

; 1511 : 	else backoff = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _backoff$[ebp], xmm0
$LN25@SV_Physics:

; 1512 : 
; 1513 : 	SV_ClipVelocity( ent->v.velocity, trace.plane.normal, ent->v.velocity, backoff );

	push	ecx
	movss	xmm0, DWORD PTR _backoff$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	lea	ecx, DWORD PTR _trace$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 160				; 000000a0H
	push	edx
	call	_SV_ClipVelocity
	add	esp, 16					; 00000010H

; 1514 : 
; 1515 : 	// stop if on ground
; 1516 : 	if( trace.plane.normal[2] > 0.7f )

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+32]
	comiss	xmm0, DWORD PTR __real@3f333333
	jbe	$LN31@SV_Physics

; 1517 : 	{		
; 1518 : 		float	vel;
; 1519 : 
; 1520 : 		VectorAdd( ent->v.velocity, ent->v.basevelocity, move );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+160]
	addss	xmm0, DWORD PTR [esi+eax+172]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _move$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+160]
	addss	xmm0, DWORD PTR [esi+ecx+172]
	movss	DWORD PTR tv326[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv326[ebp]
	movss	DWORD PTR _move$[ebp+eax], xmm0

; 1521 : 		vel = DotProduct( move, move );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _move$[ebp+ecx]
	mulss	xmm0, DWORD PTR _move$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _move$[ebp+ecx]
	mulss	xmm1, DWORD PTR _move$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _move$[ebp+eax]
	mulss	xmm1, DWORD PTR _move$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _vel$3[ebp], xmm0

; 1522 : 
; 1523 : 		if( ent->v.velocity[2] < sv_gravity.value * sv.frametime )

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _sv_gravity+12
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _ent$[ebp]
	comiss	xmm0, DWORD PTR [ecx+eax+160]
	jbe	SHORT $LN27@SV_Physics

; 1524 : 		{
; 1525 : 			// we're rolling on the ground, add static friction.
; 1526 : 			ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 1527 : 			ent->v.flags |= FL_ONGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1528 : 			ent->v.velocity[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
$LN27@SV_Physics:

; 1529 : 		}
; 1530 : 
; 1531 : 		if( vel < 900.0f || ( ent->v.movetype != MOVETYPE_BOUNCE && ent->v.movetype != MOVETYPE_BOUNCEMISSILE ))

	movss	xmm0, DWORD PTR __real@44610000
	comiss	xmm0, DWORD PTR _vel$3[ebp]
	ja	SHORT $LN30@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 10			; 0000000aH
	je	$LN28@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 11			; 0000000bH
	je	$LN28@SV_Physics
$LN30@SV_Physics:

; 1532 : 		{
; 1533 : 			ent->v.flags |= FL_ONGROUND;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1534 : 			ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx

; 1535 : 			VectorClear( ent->v.avelocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+220], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+220], xmm0

; 1536 : 			VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 1537 : 		}

	jmp	$LN31@SV_Physics
$LN28@SV_Physics:

; 1538 : 		else
; 1539 : 		{
; 1540 : 			VectorScale( ent->v.velocity, (1.0f - trace.fraction) * sv.frametime * 0.9f, move );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+160]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	eax, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+160]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+160]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv416[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv416[ebp]
	movss	DWORD PTR _move$[ebp+ecx], xmm0

; 1541 : 			VectorMA( move, (1.0f - trace.fraction) * sv.frametime * 0.9f, ent->v.basevelocity, move );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+172]
	addss	xmm0, DWORD PTR _move$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _move$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+172]
	addss	xmm0, DWORD PTR _move$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _move$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+172]
	movss	xmm1, DWORD PTR _move$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv458[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv458[ebp]
	movss	DWORD PTR _move$[ebp+eax], xmm0

; 1542 : 			trace = SV_PushEntity( ent, move, vec3_origin, NULL, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	0
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _move$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_PushEntity
	add	esp, 24					; 00000018H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1543 : 			if( ent->free ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN31@SV_Physics
	jmp	SHORT $LN1@SV_Physics
$LN31@SV_Physics:

; 1544 : 		}
; 1545 : 	}
; 1546 : 	
; 1547 : 	// check for in water
; 1548 : 	SV_CheckWaterTransition( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWaterTransition
	add	esp, 4
$LN1@SV_Physics:

; 1549 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Toss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CheckWaterTransition
_TEXT	SEGMENT
tv201 = -88						; size = 4
_cont$ = -20						; size = 4
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_CheckWaterTransition PROC				; COMDAT

; 1351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1352 : 	vec3_t	point;
; 1353 : 	int	cont;
; 1354 : 
; 1355 : 	point[0] = (ent->v.absmax[0] + ent->v.absmin[0]) * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+340]
	addss	xmm0, DWORD PTR [esi+eax+328]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 1356 : 	point[1] = (ent->v.absmax[1] + ent->v.absmin[1]) * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+340]
	addss	xmm0, DWORD PTR [esi+ecx+328]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 1357 : 	point[2] = (ent->v.absmin[2] + 1.0f);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+328]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 1358 : 
; 1359 : 	svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 1360 : 	cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1361 : 
; 1362 : 	if( !ent->v.watertype )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+676], 0
	jne	SHORT $LN2@SV_CheckWa

; 1363 : 	{
; 1364 : 		// just spawned here
; 1365 : 		ent->v.watertype = cont;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [eax+676], ecx

; 1366 : 		ent->v.waterlevel = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 1

; 1367 : 		return;

	jmp	$LN4@SV_CheckWa
$LN2@SV_CheckWa:

; 1368 : 	}
; 1369 : 
; 1370 : 	if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	$LN3@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	$LN3@SV_CheckWa

; 1371 : 	{
; 1372 : 		if( ent->v.watertype == CONTENTS_EMPTY )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+676], -1
	jne	SHORT $LN5@SV_CheckWa

; 1373 : 		{	
; 1374 : 			// just crossed into water
; 1375 : 			SV_StartSound( ent, CHAN_AUTO, "player/pl_wade1.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@BGADGGEJ@player?1pl_wade1?4wav@
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH

; 1376 : 			ent->v.velocity[2] *= 0.5;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax+160]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 1
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
$LN5@SV_CheckWa:

; 1377 : 		}		
; 1378 : 
; 1379 : 		ent->v.watertype = cont;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [eax+676], ecx

; 1380 : 		ent->v.waterlevel = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 1

; 1381 : 
; 1382 : 		if( ent->v.absmin[2] != ent->v.absmax[2] )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	ucomiss	xmm0, DWORD PTR [esi+ecx+340]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@SV_CheckWa

; 1383 : 		{
; 1384 : 			point[2] = (ent->v.absmin[2] + ent->v.absmax[2]) * 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	addss	xmm0, DWORD PTR [esi+ecx+340]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 1385 : 			svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 1386 : 			cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1387 : 
; 1388 : 			if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	$LN9@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	$LN9@SV_CheckWa

; 1389 : 			{
; 1390 : 				ent->v.waterlevel = 2;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 2

; 1391 : 				VectorAdd( point, ent->v.view_ofs, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+608]
	movss	DWORD PTR tv201[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 1392 : 				svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 1393 : 				cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 1394 : 				if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $LN9@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	SHORT $LN9@SV_CheckWa

; 1395 : 					ent->v.waterlevel = 3;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 3
$LN9@SV_CheckWa:

; 1396 : 			}
; 1397 : 		}

	jmp	SHORT $LN7@SV_CheckWa
$LN6@SV_CheckWa:

; 1398 : 		else
; 1399 : 		{
; 1400 : 			// point entity
; 1401 : 			ent->v.waterlevel = 3;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 3
$LN7@SV_CheckWa:

; 1402 : 		}
; 1403 : 	}

	jmp	SHORT $LN4@SV_CheckWa
$LN3@SV_CheckWa:

; 1404 : 	else
; 1405 : 	{
; 1406 : 		if( ent->v.watertype != CONTENTS_EMPTY )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+676], -1
	je	SHORT $LN10@SV_CheckWa

; 1407 : 		{	
; 1408 : 			// just crossed into water
; 1409 : 			SV_StartSound( ent, CHAN_AUTO, "player/pl_wade2.wav", 1.0f, ATTN_NORM, 0, 100 );

	push	100					; 00000064H
	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@JAJHBEOH@player?1pl_wade2?4wav@
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_StartSound
	add	esp, 28					; 0000001cH
$LN10@SV_CheckWa:

; 1410 : 		}		
; 1411 : 		ent->v.watertype = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+676], -1

; 1412 : 		ent->v.waterlevel = 0;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 0
$LN4@SV_CheckWa:

; 1413 : 	}
; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckWaterTransition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Noclip
_TEXT	SEGMENT
tv165 = -68						; size = 4
tv132 = -68						; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Noclip PROC					; COMDAT

; 1324 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1325 : 	// regular thinking
; 1326 : 	if( !SV_RunThink( ent )) return;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_Physics
	jmp	$LN1@SV_Physics
$LN2@SV_Physics:

; 1327 : 
; 1328 : 	SV_CheckWater( ent );	

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckWater
	add	esp, 4

; 1329 : 
; 1330 : 	VectorMA( ent->v.origin, sv.frametime, ent->v.velocity,  ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [edx+eax+160]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+136]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [eax+edx+160]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+136]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [ecx+eax+160]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+136]
	addss	xmm1, xmm0
	movss	DWORD PTR tv132[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0

; 1331 : 	VectorMA( ent->v.angles, sv.frametime, ent->v.avelocity, ent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [edx+eax+220]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+208]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [eax+edx+220]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+208]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	mulss	xmm0, DWORD PTR [ecx+eax+220]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+208]
	addss	xmm1, xmm0
	movss	DWORD PTR tv165[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0

; 1332 : 
; 1333 : 	// noclip ents never touch triggers
; 1334 : 	SV_LinkEdict( ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN1@SV_Physics:

; 1335 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Noclip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Compound
_TEXT	SEGMENT
tv246 = -332						; size = 4
tv79 = -332						; size = 4
_child$1 = -264						; size = 64
_temp_l$2 = -200					; size = 64
_end_l$3 = -136						; size = 64
_start_l$4 = -72					; size = 64
_parent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Compound PROC				; COMDAT

; 1244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1245 : 	edict_t	*parent;
; 1246 : 	
; 1247 : 	// regular thinking
; 1248 : 	if( !SV_RunThink( ent )) return;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@SV_Physics
	jmp	$LN1@SV_Physics
$LN4@SV_Physics:

; 1249 : 
; 1250 : 	parent = ent->v.aiment;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	DWORD PTR _parent$[ebp], ecx

; 1251 : 
; 1252 : 	if( !SV_IsValidEdict( parent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Physics_Compound@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_Physics

; 1253 : 	{
; 1254 : 		ent->v.movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+396], 0

; 1255 : 		return;

	jmp	$LN1@SV_Physics
$LN5@SV_Physics:

; 1256 : 	}
; 1257 : 
; 1258 : 	if( ent->v.solid != SOLID_TRIGGER )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 1
	je	SHORT $LN6@SV_Physics

; 1259 : 		ent->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+400], 0
$LN6@SV_Physics:

; 1260 : 
; 1261 : 	switch( parent->v.movetype )

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 7
	je	SHORT $LN7@SV_Physics
	cmp	DWORD PTR tv79[ebp], 13			; 0000000dH
	je	SHORT $LN7@SV_Physics
	jmp	SHORT $LN9@SV_Physics
$LN7@SV_Physics:

; 1262 : 	{
; 1263 : 	case MOVETYPE_PUSH:
; 1264 : 	case MOVETYPE_PUSHSTEP:
; 1265 : 		break;

	jmp	SHORT $LN2@SV_Physics
$LN9@SV_Physics:

; 1266 : 	default: return;

	jmp	$LN1@SV_Physics
$LN2@SV_Physics:

; 1267 : 	}
; 1268 : 
; 1269 : 	// not initialized ?
; 1270 : 	if( ent->v.ltime == 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@SV_Physics

; 1271 : 	{
; 1272 : 		VectorCopy( parent->v.origin, ent->v.oldorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+148], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+148], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+148], eax

; 1273 : 		VectorCopy( parent->v.angles, ent->v.avelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+220], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+220], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+220], eax

; 1274 : 		ent->v.ltime = sv.frametime;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR [eax+388], xmm0

; 1275 : 		return;

	jmp	$LN1@SV_Physics
$LN10@SV_Physics:

; 1276 : 	}
; 1277 : 
; 1278 : 	if( !VectorCompare( parent->v.origin, ent->v.oldorigin ) || !VectorCompare( parent->v.angles, ent->v.avelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	ucomiss	xmm0, DWORD PTR [esi+eax+148]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	ucomiss	xmm0, DWORD PTR [esi+ecx+148]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	ucomiss	xmm0, DWORD PTR [esi+ecx+148]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@SV_Physics
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	ucomiss	xmm0, DWORD PTR [esi+eax+220]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+208]
	ucomiss	xmm0, DWORD PTR [esi+ecx+220]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+208]
	ucomiss	xmm0, DWORD PTR [esi+ecx+220]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN15@SV_Physics
$LN13@SV_Physics:

; 1279 : 	{
; 1280 : 		matrix4x4	start_l, end_l, temp_l, child;
; 1281 : 
; 1282 : 		// create parent old position
; 1283 : 		Matrix4x4_CreateFromEntity( temp_l, ent->v.avelocity, ent->v.oldorigin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 220				; 000000dcH
	push	ecx
	lea	edx, DWORD PTR _temp_l$2[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1284 : 		Matrix4x4_Invert_Simple( start_l, temp_l );

	lea	eax, DWORD PTR _temp_l$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_l$4[ebp]
	push	ecx
	call	_Matrix4x4_Invert_Simple
	add	esp, 8

; 1285 : 
; 1286 : 		// create parent actual position
; 1287 : 		Matrix4x4_CreateFromEntity( end_l, parent->v.angles, parent->v.origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _parent$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _end_l$3[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1288 : 
; 1289 : 		// stupid quake bug!!!
; 1290 : 		if( !( host.features & ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN14@SV_Physics

; 1291 : 			ent->v.angles[PITCH] = -ent->v.angles[PITCH];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0
$LN14@SV_Physics:

; 1292 : 
; 1293 : 		// create child actual position
; 1294 : 		Matrix4x4_CreateFromEntity( child, ent->v.angles, ent->v.origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _child$1[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1295 : 
; 1296 : 		// transform child from start to end
; 1297 : 		Matrix4x4_ConcatTransforms( temp_l, start_l, child );

	lea	eax, DWORD PTR _child$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _start_l$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_l$2[ebp]
	push	edx
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1298 : 		Matrix4x4_ConcatTransforms( child, end_l, temp_l );

	lea	eax, DWORD PTR _temp_l$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _child$1[ebp]
	push	edx
	call	_Matrix4x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1299 : 
; 1300 : 		// create child final position
; 1301 : 		Matrix4x4_ConvertToEntity( child, ent->v.angles, ent->v.origin );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _child$1[ebp]
	push	edx
	call	_Matrix4x4_ConvertToEntity
	add	esp, 12					; 0000000cH

; 1302 : 
; 1303 : 		// stupid quake bug!!!
; 1304 : 		if( !( host.features & ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN15@SV_Physics

; 1305 : 			ent->v.angles[PITCH] = -ent->v.angles[PITCH];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+208]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0
$LN15@SV_Physics:

; 1306 : 	}
; 1307 : 
; 1308 : 	// notsolid ents never touch triggers
; 1309 : 	SV_LinkEdict( ent, (ent->v.solid == SOLID_NOT) ? false : true );

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN17@SV_Physics
	mov	DWORD PTR tv246[ebp], 0
	jmp	SHORT $LN18@SV_Physics
$LN17@SV_Physics:
	mov	DWORD PTR tv246[ebp], 1
$LN18@SV_Physics:
	mov	ecx, DWORD PTR tv246[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_LinkEdict
	add	esp, 8

; 1310 : 
; 1311 : 	// shuffle states
; 1312 : 	VectorCopy( parent->v.origin, ent->v.oldorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+148], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+148], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+148], eax

; 1313 : 	VectorCopy( parent->v.angles, ent->v.avelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+220], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+220], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+220], eax
$LN1@SV_Physics:

; 1314 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Compound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Follow
_TEXT	SEGMENT
tv136 = -72						; size = 4
_parent$ = -4						; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Follow PROC					; COMDAT

; 1216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1217 : 	edict_t	*parent;
; 1218 : 
; 1219 : 	// regular thinking
; 1220 : 	if( !SV_RunThink( ent )) return;

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_RunThink
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_Physics
	jmp	$LN1@SV_Physics
$LN2@SV_Physics:

; 1221 : 
; 1222 : 	parent = ent->v.aiment;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+640]
	mov	DWORD PTR _parent$[ebp], ecx

; 1223 : 
; 1224 : 	if( !SV_IsValidEdict( parent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Physics_Follow@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@SV_Physics

; 1225 : 	{
; 1226 : 		ent->v.movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+396], 0

; 1227 : 		return;

	jmp	$LN1@SV_Physics
$LN3@SV_Physics:

; 1228 : 	}
; 1229 : 
; 1230 : 	VectorAdd( parent->v.origin, ent->v.v_angle, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax+244]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx+244]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax+244]
	movss	DWORD PTR tv136[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv136[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0

; 1231 : 	VectorCopy( parent->v.angles, ent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+208], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+208], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+208], eax

; 1232 : 
; 1233 : 	SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8
$LN1@SV_Physics:

; 1234 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Follow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics_Pusher
_TEXT	SEGMENT
_i$ = -24						; size = 4
_pBlocker$ = -20					; size = 4
_movetime$ = -16					; size = 4
_thinktime$ = -12					; size = 4
_oldtime2$ = -8						; size = 4
_oldtime$ = -4						; size = 4
_ent$ = 8						; size = 4
_SV_Physics_Pusher PROC					; COMDAT

; 1142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1143 : 	float	oldtime, oldtime2;
; 1144 : 	float	thinktime, movetime;
; 1145 : 	edict_t	*pBlocker;
; 1146 : 	int	i;
; 1147 : 
; 1148 : 	pBlocker = NULL;

	mov	DWORD PTR _pBlocker$[ebp], 0

; 1149 : 	oldtime = ent->v.ltime;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	movss	DWORD PTR _oldtime$[ebp], xmm0

; 1150 : 	thinktime = ent->v.nextthink;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+392]
	movss	DWORD PTR _thinktime$[ebp], xmm0

; 1151 : 
; 1152 : 	if( thinktime < oldtime + sv.frametime )

	movss	xmm0, DWORD PTR _oldtime$[ebp]
	addss	xmm0, DWORD PTR _sv+32
	comiss	xmm0, DWORD PTR _thinktime$[ebp]
	jbe	SHORT $LN5@SV_Physics

; 1153 : 	{
; 1154 : 		movetime = thinktime - oldtime;

	movss	xmm0, DWORD PTR _thinktime$[ebp]
	subss	xmm0, DWORD PTR _oldtime$[ebp]
	movss	DWORD PTR _movetime$[ebp], xmm0

; 1155 : 		if( movetime < 0.0f ) movetime = 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _movetime$[ebp]
	jbe	SHORT $LN7@SV_Physics
	xorps	xmm0, xmm0
	movss	DWORD PTR _movetime$[ebp], xmm0
$LN7@SV_Physics:

; 1156 : 	}

	jmp	SHORT $LN6@SV_Physics
$LN5@SV_Physics:

; 1157 : 	else movetime = sv.frametime;

	movss	xmm0, DWORD PTR _sv+32
	movss	DWORD PTR _movetime$[ebp], xmm0
$LN6@SV_Physics:

; 1158 : 
; 1159 : 	if( movetime )

	movss	xmm0, DWORD PTR _movetime$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN10@SV_Physics

; 1160 : 	{
; 1161 : 		if( !VectorIsNull( ent->v.avelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@SV_Physics
$LN11@SV_Physics:

; 1162 : 		{
; 1163 : 			if( !VectorIsNull( ent->v.velocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@SV_Physics
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@SV_Physics
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_Physics
$LN14@SV_Physics:

; 1164 : 			{
; 1165 : 				pBlocker = SV_PushRotate( ent, movetime );

	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax

; 1166 : 
; 1167 : 				if( !pBlocker )

	cmp	DWORD PTR _pBlocker$[ebp], 0
	jne	SHORT $LN16@SV_Physics

; 1168 : 				{
; 1169 : 					oldtime2 = ent->v.ltime;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	movss	DWORD PTR _oldtime2$[ebp], xmm0

; 1170 : 
; 1171 : 					// reset the local time to what it was before we rotated
; 1172 : 					ent->v.ltime = oldtime;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _oldtime$[ebp]
	movss	DWORD PTR [eax+388], xmm0

; 1173 : 					pBlocker = SV_PushMove( ent, movetime );

	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax

; 1174 : 					if( ent->v.ltime < oldtime2 )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _oldtime2$[ebp]
	comiss	xmm0, DWORD PTR [eax+388]
	jbe	SHORT $LN16@SV_Physics

; 1175 : 						ent->v.ltime = oldtime2;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _oldtime2$[ebp]
	movss	DWORD PTR [eax+388], xmm0
$LN16@SV_Physics:

; 1176 : 				}
; 1177 : 			}

	jmp	SHORT $LN13@SV_Physics
$LN12@SV_Physics:

; 1178 : 			else
; 1179 : 			{
; 1180 : 				pBlocker = SV_PushRotate( ent, movetime );

	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_PushRotate
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax
$LN13@SV_Physics:

; 1181 : 			}
; 1182 : 		}

	jmp	SHORT $LN10@SV_Physics
$LN9@SV_Physics:

; 1183 : 		else 
; 1184 : 		{
; 1185 : 			pBlocker = SV_PushMove( ent, movetime );

	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_PushMove
	add	esp, 8
	mov	DWORD PTR _pBlocker$[ebp], eax
$LN10@SV_Physics:

; 1186 : 		}
; 1187 : 	}
; 1188 : 
; 1189 : 	// if the pusher has a "blocked" function, call it
; 1190 : 	// otherwise, just stay in place until the obstacle is gone
; 1191 : 	if( pBlocker ) svgame.dllFuncs.pfnBlocked( ent, pBlocker );

	cmp	DWORD PTR _pBlocker$[ebp], 0
	je	SHORT $LN17@SV_Physics
	mov	eax, DWORD PTR _pBlocker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19292
	add	esp, 8
$LN17@SV_Physics:

; 1192 : 
; 1193 : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Physics
$LN2@SV_Physics:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Physics:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_Physics

; 1194 : 	{
; 1195 : 		if( ent->v.angles[i] < -3600.0f || ent->v.angles[i] > 3600.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@c5610000
	comiss	xmm0, DWORD PTR [ecx+eax*4+208]
	ja	SHORT $LN19@SV_Physics
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+208]
	comiss	xmm0, DWORD PTR __real@45610000
	jbe	SHORT $LN18@SV_Physics
$LN19@SV_Physics:

; 1196 : 			ent->v.angles[i] = fmod( ent->v.angles[i], 3600.0f );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40ac200000000000
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4+208]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [eax+edx*4+208]
$LN18@SV_Physics:

; 1197 : 	}

	jmp	SHORT $LN2@SV_Physics
$LN3@SV_Physics:

; 1198 : 
; 1199 : 	if( thinktime > oldtime && (( ent->v.flags & FL_ALWAYSTHINK ) || thinktime <= ent->v.ltime ))

	movss	xmm0, DWORD PTR _thinktime$[ebp]
	comiss	xmm0, DWORD PTR _oldtime$[ebp]
	jbe	SHORT $LN20@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 2097152				; 00200000H
	jne	SHORT $LN21@SV_Physics
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	comiss	xmm0, DWORD PTR _thinktime$[ebp]
	jb	SHORT $LN20@SV_Physics
$LN21@SV_Physics:

; 1200 : 	{
; 1201 : 		ent->v.nextthink = 0.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+392], xmm0

; 1202 : 		svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 1203 : 		svgame.dllFuncs.pfnThink( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 4
$LN20@SV_Physics:

; 1204 : 	}
; 1205 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics_Pusher ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_PushRotate
_TEXT	SEGMENT
tv465 = -344						; size = 4
tv377 = -344						; size = 4
tv335 = -344						; size = 4
$T1 = -340						; size = 56
_check$ = -220						; size = 4
_temp$ = -216						; size = 12
_org2$ = -204						; size = 12
_org$ = -192						; size = 12
_pushed_p$ = -180					; size = 4
_p$ = -176						; size = 4
_amove$ = -172						; size = 12
_lmove$ = -160						; size = 12
_end_l$ = -148						; size = 64
_start_l$ = -84						; size = 64
_oldsolid$ = -20					; size = 4
_block$ = -16						; size = 4
_e$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pusher$ = 8						; size = 4
_movetime$ = 12						; size = 4
_SV_PushRotate PROC					; COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1005 : 	int		i, e, block, oldsolid;
; 1006 : 	matrix4x4		start_l, end_l;
; 1007 : 	vec3_t		lmove, amove;
; 1008 : 	sv_pushed_t	*p, *pushed_p;
; 1009 : 	vec3_t		org, org2, temp;
; 1010 : 	edict_t		*check;
; 1011 : 
; 1012 : 	if( svgame.globals->changelevel || VectorIsNull( pusher->v.avelocity ))

	mov	eax, DWORD PTR _svgame+19268
	cmp	DWORD PTR [eax+136], 0
	jne	SHORT $LN12@SV_PushRot
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushRot
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushRot
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushRot
$LN12@SV_PushRot:

; 1013 : 	{
; 1014 : 		pusher->v.ltime += movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 1015 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_PushRot
$LN11@SV_PushRot:

; 1016 : 	}
; 1017 : 
; 1018 : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_PushRot
$LN2@SV_PushRot:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_PushRot:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_PushRot

; 1019 : 		amove[i] = pusher->v.avelocity[i] * movetime;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+220]
	mulss	xmm0, DWORD PTR _movetime$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _amove$[ebp+edx*4], xmm0
	jmp	SHORT $LN2@SV_PushRot
$LN3@SV_PushRot:

; 1020 : 
; 1021 : 	// create pusher initial position
; 1022 : 	Matrix4x4_CreateFromEntity( start_l, pusher->v.angles, pusher->v.origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pusher$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _pusher$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1023 : 
; 1024 : 	pushed_p = svgame.pushed;

	mov	DWORD PTR _pushed_p$[ebp], OFFSET _svgame+11076

; 1025 : 
; 1026 : 	// save the pusher's original position
; 1027 : 	pushed_p->ent = pusher;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax], ecx

; 1028 : 	VectorCopy( pusher->v.origin, pushed_p->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+4], eax

; 1029 : 	VectorCopy( pusher->v.angles, pushed_p->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+16], eax

; 1030 : 	pushed_p++;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pushed_p$[ebp], eax

; 1031 : 	
; 1032 : 	// move the pusher to it's final position
; 1033 : 	SV_AngularMove( pusher, movetime, pusher->v.friction );

	mov	eax, DWORD PTR _pusher$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+456]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pusher$[ebp]
	push	ecx
	call	_SV_AngularMove
	add	esp, 12					; 0000000cH

; 1034 : 	SV_LinkEdict( pusher, false );

	push	0
	mov	eax, DWORD PTR _pusher$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 1035 : 	pusher->v.ltime += movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 1036 : 	oldsolid = pusher->v.solid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _oldsolid$[ebp], ecx

; 1037 : 
; 1038 : 	// non-solid pushers can't push anything
; 1039 : 	if( pusher->v.solid == SOLID_NOT )

	mov	eax, DWORD PTR _pusher$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN13@SV_PushRot

; 1040 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_PushRot
$LN13@SV_PushRot:

; 1041 : 
; 1042 : 	// create pusher final position
; 1043 : 	Matrix4x4_CreateFromEntity( end_l, pusher->v.angles, pusher->v.origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pusher$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _pusher$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	lea	edx, DWORD PTR _end_l$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1044 : 
; 1045 : 	// see if any solid entities are inside the final position
; 1046 : 	for( e = 1; e < svgame.numEntities; e++ )

	mov	DWORD PTR _e$[ebp], 1
	jmp	SHORT $LN7@SV_PushRot
$LN5@SV_PushRot:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$LN7@SV_PushRot:
	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN6@SV_PushRot

; 1047 : 	{
; 1048 : 		check = EDICT_NUM( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 1049 : 		if( !SV_IsValidEdict( check ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PushRotate@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_PushRot

; 1050 : 			continue;

	jmp	SHORT $LN5@SV_PushRot
$LN14@SV_PushRot:

; 1051 : 
; 1052 : 		// filter movetypes to collide with
; 1053 : 		if( !SV_CanPushed( check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_CanPushed
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@SV_PushRot

; 1054 : 			continue;

	jmp	SHORT $LN5@SV_PushRot
$LN15@SV_PushRot:

; 1055 : 
; 1056 : 		pusher->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax+400], 0

; 1057 : 		block = SV_TestEntityPosition( check, pusher );

	mov	eax, DWORD PTR _pusher$[ebp]
	push	eax
	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	call	_SV_TestEntityPosition
	add	esp, 8
	mov	DWORD PTR _block$[ebp], eax

; 1058 : 		pusher->v.solid = oldsolid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR _oldsolid$[ebp]
	mov	DWORD PTR [eax+400], ecx

; 1059 : 		if( block ) continue;

	cmp	DWORD PTR _block$[ebp], 0
	je	SHORT $LN16@SV_PushRot
	jmp	$LN5@SV_PushRot
$LN16@SV_PushRot:

; 1060 : 
; 1061 : 		// if the entity is standing on the pusher, it will definately be moved
; 1062 : 		if( !(( check->v.flags & FL_ONGROUND ) && check->v.groundentity == pusher ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	je	SHORT $LN18@SV_PushRot
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	cmp	ecx, DWORD PTR _pusher$[ebp]
	je	$LN21@SV_PushRot
$LN18@SV_PushRot:

; 1063 : 		{
; 1064 : 			if( check->v.absmin[0] >= pusher->v.absmax[0]
; 1065 : 			|| check->v.absmin[1] >= pusher->v.absmax[1]
; 1066 : 			|| check->v.absmin[2] >= pusher->v.absmax[2]
; 1067 : 			|| check->v.absmax[0] <= pusher->v.absmin[0]
; 1068 : 			|| check->v.absmax[1] <= pusher->v.absmin[1]
; 1069 : 			|| check->v.absmax[2] <= pusher->v.absmin[2] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	comiss	xmm0, DWORD PTR [esi+eax+340]
	jae	$LN20@SV_PushRot
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	comiss	xmm0, DWORD PTR [esi+ecx+340]
	jae	$LN20@SV_PushRot
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	comiss	xmm0, DWORD PTR [esi+ecx+340]
	jae	$LN20@SV_PushRot
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pusher$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	comiss	xmm0, DWORD PTR [esi+ecx+340]
	jae	SHORT $LN20@SV_PushRot
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pusher$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	comiss	xmm0, DWORD PTR [esi+eax+340]
	jae	SHORT $LN20@SV_PushRot
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pusher$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	comiss	xmm0, DWORD PTR [esi+eax+340]
	jb	SHORT $LN19@SV_PushRot
$LN20@SV_PushRot:

; 1070 : 				continue;

	jmp	$LN5@SV_PushRot
$LN19@SV_PushRot:

; 1071 : 
; 1072 : 			// see if the ent's bbox is inside the pusher's final position
; 1073 : 			if( !SV_TestEntityPosition( check, NULL ))

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_TestEntityPosition
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@SV_PushRot

; 1074 : 				continue;

	jmp	$LN5@SV_PushRot
$LN21@SV_PushRot:

; 1075 : 		}
; 1076 : 
; 1077 : 		// save original position of contacted entity
; 1078 : 		pushed_p->ent = check;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [eax], ecx

; 1079 : 		VectorCopy( check->v.origin, pushed_p->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+4], eax

; 1080 : 		VectorCopy( check->v.angles, pushed_p->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+16], eax

; 1081 : 		pushed_p->fixangle = check->v.fixangle;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	DWORD PTR [eax+28], edx

; 1082 : 		pushed_p++;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pushed_p$[ebp], eax

; 1083 : 
; 1084 : 		// calculate destination position
; 1085 : 		if( check->v.movetype == MOVETYPE_PUSHSTEP || check->v.movetype == MOVETYPE_STEP )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 13			; 0000000dH
	je	SHORT $LN24@SV_PushRot
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 4
	jne	$LN22@SV_PushRot
$LN24@SV_PushRot:

; 1086 : 			VectorAverage( check->v.absmin, check->v.absmax, org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	addss	xmm0, DWORD PTR [esi+ecx+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv335[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv335[ebp]
	movss	DWORD PTR _org$[ebp+eax], xmm0
	jmp	SHORT $LN23@SV_PushRot
$LN22@SV_PushRot:

; 1087 : 		else VectorCopy( check->v.origin, org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+136]
	mov	DWORD PTR _org$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+edx+136]
	mov	DWORD PTR _org$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+eax+136]
	mov	DWORD PTR _org$[ebp+ecx], eax
$LN23@SV_PushRot:

; 1088 : 
; 1089 : 		Matrix4x4_VectorITransform( start_l, org, temp );

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _org$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 1090 : 		Matrix4x4_VectorTransform( end_l, temp, org2 );

	lea	eax, DWORD PTR _org2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _end_l$[ebp]
	push	edx
	call	_Matrix4x4_VectorTransform
	add	esp, 12					; 0000000cH

; 1091 : 		VectorSubtract( org2, org, lmove );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org2$[ebp+ecx]
	subss	xmm0, DWORD PTR _org$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lmove$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _org2$[ebp+eax]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lmove$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _org2$[ebp+eax]
	subss	xmm0, DWORD PTR _org$[ebp+ecx]
	movss	DWORD PTR tv377[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv377[ebp]
	movss	DWORD PTR _lmove$[ebp+edx], xmm0

; 1092 : 
; 1093 : 		// i can't clear FL_ONGROUND in all cases because many bad things may be happen
; 1094 : 		if( check->v.movetype != MOVETYPE_WALK )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 3
	je	SHORT $LN27@SV_PushRot

; 1095 : 		{
; 1096 : 			if( lmove[2] != 0.0f ) check->v.flags &= ~FL_ONGROUND;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lmove$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@SV_PushRot
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN26@SV_PushRot:

; 1097 : 			if( lmove[2] < 0.0f && !pusher->v.dmg )

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _lmove$[ebp+eax]
	jbe	SHORT $LN27@SV_PushRot
	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+704]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN27@SV_PushRot

; 1098 : 				lmove[2] = 0.0f; // let's the free falling

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _lmove$[ebp+eax], xmm0
$LN27@SV_PushRot:

; 1099 :                     }
; 1100 : 
; 1101 : 		// try moving the contacted entity 
; 1102 : 		pusher->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax+400], 0

; 1103 : 		SV_PushEntity( check, lmove, amove, &block, pusher->v.dmg );

	mov	eax, DWORD PTR _pusher$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+704]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _block$[ebp]
	push	ecx
	lea	edx, DWORD PTR _amove$[ebp]
	push	edx
	lea	eax, DWORD PTR _lmove$[ebp]
	push	eax
	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_SV_PushEntity
	add	esp, 24					; 00000018H

; 1104 : 		pusher->v.solid = oldsolid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR _oldsolid$[ebp]
	mov	DWORD PTR [eax+400], ecx

; 1105 : 
; 1106 : 		// pushed entity blocked by wall
; 1107 : 		if( block && check->v.movetype != MOVETYPE_WALK )

	cmp	DWORD PTR _block$[ebp], 0
	je	SHORT $LN28@SV_PushRot
	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 3
	je	SHORT $LN28@SV_PushRot

; 1108 : 			check->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN28@SV_PushRot:

; 1109 : 
; 1110 : 		// if it is still inside the pusher, block
; 1111 : 		if( SV_TestEntityPosition( check, NULL ) && block )

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_TestEntityPosition
	add	esp, 8
	test	eax, eax
	je	$LN29@SV_PushRot
	cmp	DWORD PTR _block$[ebp], 0
	je	$LN29@SV_PushRot

; 1112 : 		{	
; 1113 : 			if( !SV_CanBlock( check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_CanBlock
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN30@SV_PushRot

; 1114 : 				continue;

	jmp	$LN5@SV_PushRot
$LN30@SV_PushRot:

; 1115 : 
; 1116 : 			pusher->v.ltime -= movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	subss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 1117 : 
; 1118 : 			// move back any entities we already moved
; 1119 : 			// go backwards, so if the same entity was pushed
; 1120 : 			// twice, it goes back to the original position
; 1121 : 			for( p = pushed_p - 1; p >= svgame.pushed; p-- )

	mov	eax, DWORD PTR _pushed_p$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN10@SV_PushRot
$LN8@SV_PushRot:
	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _p$[ebp], eax
$LN10@SV_PushRot:
	cmp	DWORD PTR _p$[ebp], OFFSET _svgame+11076
	jb	$LN9@SV_PushRot

; 1122 : 			{
; 1123 : 				VectorCopy( p->origin, p->ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+136], eax

; 1124 : 				VectorCopy( p->angles, p->ent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+208], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+208], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+208], eax

; 1125 : 				SV_LinkEdict( p->ent, (p->ent == check) ? true : false );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _check$[ebp]
	jne	SHORT $LN32@SV_PushRot
	mov	DWORD PTR tv465[ebp], 1
	jmp	SHORT $LN33@SV_PushRot
$LN32@SV_PushRot:
	mov	DWORD PTR tv465[ebp], 0
$LN33@SV_PushRot:
	mov	edx, DWORD PTR tv465[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SV_LinkEdict
	add	esp, 8

; 1126 : 				p->ent->v.fixangle = p->fixangle;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+288], eax

; 1127 : 			}

	jmp	$LN8@SV_PushRot
$LN9@SV_PushRot:

; 1128 : 			return check;

	mov	eax, DWORD PTR _check$[ebp]
	jmp	SHORT $LN1@SV_PushRot
$LN29@SV_PushRot:

; 1129 : 		}
; 1130 : 	}

	jmp	$LN5@SV_PushRot
$LN6@SV_PushRot:

; 1131 : 
; 1132 : 	return NULL;

	xor	eax, eax
$LN1@SV_PushRot:

; 1133 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PushRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_PushMove
_TEXT	SEGMENT
tv359 = -196						; size = 4
$T1 = -192						; size = 56
_check$ = -72						; size = 4
_pushed_p$ = -68					; size = 4
_p$ = -64						; size = 4
_lmove$ = -60						; size = 12
_maxs$ = -48						; size = 12
_mins$ = -36						; size = 12
_oldsolid$ = -24					; size = 4
_num_moved$ = -20					; size = 4
_block$ = -16						; size = 4
_e$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pusher$ = 8						; size = 4
_movetime$ = 12						; size = 4
_SV_PushMove PROC					; COMDAT

; 887  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 888  : 	int		i, e, block;
; 889  : 	int		num_moved, oldsolid;
; 890  : 	vec3_t		mins, maxs, lmove;
; 891  : 	sv_pushed_t	*p, *pushed_p;
; 892  : 	edict_t		*check;	
; 893  : 
; 894  : 	if( svgame.globals->changelevel || VectorIsNull( pusher->v.velocity ))

	mov	eax, DWORD PTR _svgame+19268
	cmp	DWORD PTR [eax+136], 0
	jne	SHORT $LN12@SV_PushMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushMov
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_PushMov
$LN12@SV_PushMov:

; 895  : 	{
; 896  : 		pusher->v.ltime += movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 897  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_PushMov
$LN11@SV_PushMov:

; 898  : 	}
; 899  : 
; 900  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_PushMov
$LN2@SV_PushMov:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_PushMov:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_PushMov

; 901  : 	{
; 902  : 		lmove[i] = pusher->v.velocity[i] * movetime;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+160]
	mulss	xmm0, DWORD PTR _movetime$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	DWORD PTR _lmove$[ebp+edx*4], xmm0

; 903  : 		mins[i] = pusher->v.absmin[i] + lmove[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+328]
	addss	xmm0, DWORD PTR _lmove$[ebp+edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _mins$[ebp+eax*4], xmm0

; 904  : 		maxs[i] = pusher->v.absmax[i] + lmove[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+340]
	addss	xmm0, DWORD PTR _lmove$[ebp+edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	movss	DWORD PTR _maxs$[ebp+eax*4], xmm0

; 905  : 	}

	jmp	SHORT $LN2@SV_PushMov
$LN3@SV_PushMov:

; 906  : 
; 907  : 	pushed_p = svgame.pushed;

	mov	DWORD PTR _pushed_p$[ebp], OFFSET _svgame+11076

; 908  : 
; 909  : 	// save the pusher's original position
; 910  : 	pushed_p->ent = pusher;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax], ecx

; 911  : 	VectorCopy( pusher->v.origin, pushed_p->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+4], eax

; 912  : 	VectorCopy( pusher->v.angles, pushed_p->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _pusher$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+16], eax

; 913  : 	pushed_p++;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pushed_p$[ebp], eax

; 914  : 	
; 915  : 	// move the pusher to it's final position
; 916  : 	SV_LinearMove( pusher, movetime, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _movetime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pusher$[ebp]
	push	eax
	call	_SV_LinearMove
	add	esp, 12					; 0000000cH

; 917  : 	SV_LinkEdict( pusher, false );

	push	0
	mov	eax, DWORD PTR _pusher$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 918  : 	pusher->v.ltime += movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 919  : 	oldsolid = pusher->v.solid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR [eax+400]
	mov	DWORD PTR _oldsolid$[ebp], ecx

; 920  : 
; 921  : 	// non-solid pushers can't push anything
; 922  : 	if( pusher->v.solid == SOLID_NOT )

	mov	eax, DWORD PTR _pusher$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN13@SV_PushMov

; 923  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SV_PushMov
$LN13@SV_PushMov:

; 924  : 
; 925  : 	// see if any solid entities are inside the final position
; 926  : 	num_moved = 0;

	mov	DWORD PTR _num_moved$[ebp], 0

; 927  : 
; 928  : 	for( e = 1; e < svgame.numEntities; e++ )

	mov	DWORD PTR _e$[ebp], 1
	jmp	SHORT $LN7@SV_PushMov
$LN5@SV_PushMov:
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax
$LN7@SV_PushMov:
	mov	eax, DWORD PTR _e$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN6@SV_PushMov

; 929  : 	{
; 930  : 		check = EDICT_NUM( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _check$[ebp], eax

; 931  : 		if( !SV_IsValidEdict( check )) continue;

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PushMove@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_PushMov
	jmp	SHORT $LN5@SV_PushMov
$LN14@SV_PushMov:

; 932  : 
; 933  : 		// filter movetypes to collide with
; 934  : 		if( !SV_CanPushed( check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_CanPushed
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@SV_PushMov

; 935  : 			continue;

	jmp	SHORT $LN5@SV_PushMov
$LN15@SV_PushMov:

; 936  : 
; 937  : 		pusher->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax+400], 0

; 938  : 		block = SV_TestEntityPosition( check, pusher );

	mov	eax, DWORD PTR _pusher$[ebp]
	push	eax
	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	call	_SV_TestEntityPosition
	add	esp, 8
	mov	DWORD PTR _block$[ebp], eax

; 939  : 		pusher->v.solid = oldsolid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR _oldsolid$[ebp]
	mov	DWORD PTR [eax+400], ecx

; 940  : 		if( block ) continue;

	cmp	DWORD PTR _block$[ebp], 0
	je	SHORT $LN16@SV_PushMov
	jmp	$LN5@SV_PushMov
$LN16@SV_PushMov:

; 941  : 
; 942  : 		// if the entity is standing on the pusher, it will definately be moved
; 943  : 		if( !( FBitSet( check->v.flags, FL_ONGROUND ) && check->v.groundentity == pusher ))

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	je	SHORT $LN18@SV_PushMov
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	cmp	ecx, DWORD PTR _pusher$[ebp]
	je	$LN21@SV_PushMov
$LN18@SV_PushMov:

; 944  : 		{
; 945  : 			if( check->v.absmin[0] >= maxs[0]
; 946  : 			 || check->v.absmin[1] >= maxs[1]
; 947  : 			 || check->v.absmin[2] >= maxs[2]
; 948  : 			 || check->v.absmax[0] <= mins[0]
; 949  : 			 || check->v.absmax[1] <= mins[1]
; 950  : 			 || check->v.absmax[2] <= mins[2] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	comiss	xmm0, DWORD PTR _maxs$[ebp+eax]
	jae	$LN20@SV_PushMov
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	comiss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	jae	$LN20@SV_PushMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	comiss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	jae	SHORT $LN20@SV_PushMov
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+eax]
	comiss	xmm0, DWORD PTR [edx+ecx+340]
	jae	SHORT $LN20@SV_PushMov
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	comiss	xmm0, DWORD PTR [edx+eax+340]
	jae	SHORT $LN20@SV_PushMov
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _check$[ebp]
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	comiss	xmm0, DWORD PTR [edx+eax+340]
	jb	SHORT $LN19@SV_PushMov
$LN20@SV_PushMov:

; 951  : 				continue;

	jmp	$LN5@SV_PushMov
$LN19@SV_PushMov:

; 952  : 
; 953  : 			// see if the ent's bbox is inside the pusher's final position
; 954  : 			if( !SV_TestEntityPosition( check, NULL ))

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_TestEntityPosition
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN21@SV_PushMov

; 955  : 				continue;

	jmp	$LN5@SV_PushMov
$LN21@SV_PushMov:

; 956  : 		}
; 957  : 
; 958  : 		// remove the onground flag for non-players
; 959  : 		if( check->v.movetype != MOVETYPE_WALK )

	mov	eax, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [eax+396], 3
	je	SHORT $LN22@SV_PushMov

; 960  : 			check->v.flags &= ~FL_ONGROUND;

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN22@SV_PushMov:

; 961  : 
; 962  : 		// save original position of contacted entity
; 963  : 		pushed_p->ent = check;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [eax], ecx

; 964  : 		VectorCopy( check->v.origin, pushed_p->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [esi+edx+136]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+ecx+4], eax

; 965  : 		VectorCopy( check->v.angles, pushed_p->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+208]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [esi+edx+208]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pushed_p$[ebp]
	mov	esi, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [esi+eax+208]
	mov	DWORD PTR [edx+ecx+16], eax

; 966  : 		pushed_p++;

	mov	eax, DWORD PTR _pushed_p$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR _pushed_p$[ebp], eax

; 967  : 
; 968  : 		// try moving the contacted entity 
; 969  : 		pusher->v.solid = SOLID_NOT;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	DWORD PTR [eax+400], 0

; 970  : 		SV_PushEntity( check, lmove, vec3_origin, &block, pusher->v.dmg );

	mov	eax, DWORD PTR _pusher$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+704]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _block$[ebp]
	push	ecx
	push	OFFSET _vec3_origin
	lea	edx, DWORD PTR _lmove$[ebp]
	push	edx
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_PushEntity
	add	esp, 24					; 00000018H

; 971  : 		pusher->v.solid = oldsolid;

	mov	eax, DWORD PTR _pusher$[ebp]
	mov	ecx, DWORD PTR _oldsolid$[ebp]
	mov	DWORD PTR [eax+400], ecx

; 972  : 
; 973  : 		// if it is still inside the pusher, block
; 974  : 		if( SV_TestEntityPosition( check, NULL ) && block )

	push	0
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_TestEntityPosition
	add	esp, 8
	test	eax, eax
	je	$LN23@SV_PushMov
	cmp	DWORD PTR _block$[ebp], 0
	je	$LN23@SV_PushMov

; 975  : 		{	
; 976  : 			if( !SV_CanBlock( check ))

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_SV_CanBlock
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@SV_PushMov

; 977  : 				continue;

	jmp	$LN5@SV_PushMov
$LN24@SV_PushMov:

; 978  : 
; 979  : 			pusher->v.ltime -= movetime;

	mov	eax, DWORD PTR _pusher$[ebp]
	movss	xmm0, DWORD PTR [eax+388]
	subss	xmm0, DWORD PTR _movetime$[ebp]
	mov	ecx, DWORD PTR _pusher$[ebp]
	movss	DWORD PTR [ecx+388], xmm0

; 980  : 
; 981  : 			// move back any entities we already moved
; 982  : 			// go backwards, so if the same entity was pushed
; 983  : 			// twice, it goes back to the original position
; 984  : 			for( p = pushed_p - 1; p >= svgame.pushed; p-- )

	mov	eax, DWORD PTR _pushed_p$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN10@SV_PushMov
$LN8@SV_PushMov:
	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _p$[ebp], eax
$LN10@SV_PushMov:
	cmp	DWORD PTR _p$[ebp], OFFSET _svgame+11076
	jb	$LN9@SV_PushMov

; 985  : 			{
; 986  : 				VectorCopy( p->origin, p->ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [eax+edx+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+136], eax

; 987  : 				VectorCopy( p->angles, p->ent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [eax+edx+208], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+208], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+208], eax

; 988  : 				SV_LinkEdict( p->ent, (p->ent == check) ? true : false );

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _check$[ebp]
	jne	SHORT $LN26@SV_PushMov
	mov	DWORD PTR tv359[ebp], 1
	jmp	SHORT $LN27@SV_PushMov
$LN26@SV_PushMov:
	mov	DWORD PTR tv359[ebp], 0
$LN27@SV_PushMov:
	mov	edx, DWORD PTR tv359[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SV_LinkEdict
	add	esp, 8

; 989  : 			}

	jmp	$LN8@SV_PushMov
$LN9@SV_PushMov:

; 990  : 			return check;

	mov	eax, DWORD PTR _check$[ebp]
	jmp	SHORT $LN1@SV_PushMov
$LN23@SV_PushMov:

; 991  : 		}	
; 992  : 	}

	jmp	$LN5@SV_PushMov
$LN6@SV_PushMov:

; 993  : 
; 994  : 	return NULL;

	xor	eax, eax
$LN1@SV_PushMov:

; 995  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PushMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CanBlock
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_SV_CanBlock PROC					; COMDAT

; 865  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 866  : 	if( ent->v.mins[0] == ent->v.maxs[0] )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+352]
	ucomiss	xmm0, DWORD PTR [esi+eax+364]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SV_CanBloc

; 867  :       		return false;

	xor	eax, eax
	jmp	$LN1@SV_CanBloc
$LN2@SV_CanBloc:

; 868  : 
; 869  : 	if( ent->v.solid == SOLID_NOT || ent->v.solid == SOLID_TRIGGER )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	SHORT $LN4@SV_CanBloc
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 1
	jne	$LN3@SV_CanBloc
$LN4@SV_CanBloc:

; 870  : 	{
; 871  : 		// clear bounds for deadbody
; 872  : 		ent->v.mins[0] = ent->v.mins[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+352], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+352], xmm0

; 873  : 		VectorCopy( ent->v.mins, ent->v.maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+352]
	mov	DWORD PTR [edx+eax+364], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+352]
	mov	DWORD PTR [ecx+eax+364], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+352]
	mov	DWORD PTR [edx+ecx+364], eax

; 874  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CanBloc
$LN3@SV_CanBloc:

; 875  :           }
; 876  : 
; 877  : 	return true;

	mov	eax, 1
$LN1@SV_CanBloc:

; 878  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CanBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_PushEntity
_TEXT	SEGMENT
tv205 = -208						; size = 4
tv91 = -208						; size = 4
tv67 = -208						; size = 4
$T1 = -204						; size = 56
_end$ = -84						; size = 12
_type$ = -72						; size = 4
_monsterClip$ = -68					; size = 4
_monsterBlock$ = -64					; size = 4
_trace$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_ent$ = 12						; size = 4
_lpush$ = 16						; size = 4
_apush$ = 20						; size = 4
_blocked$ = 24						; size = 4
_flDamage$ = 28						; size = 4
_SV_PushEntity PROC					; COMDAT

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 782  : 	trace_t	trace;
; 783  : 	qboolean	monsterBlock;
; 784  : 	qboolean	monsterClip;
; 785  : 	int	type;
; 786  : 	vec3_t	end;
; 787  : 
; 788  : 	monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN18@SV_PushEnt
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN19@SV_PushEnt
$LN18@SV_PushEnt:
	mov	DWORD PTR tv67[ebp], 0
$LN19@SV_PushEnt:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 789  : 	VectorAdd( ent->v.origin, lpush, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _lpush$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _lpush$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+136]
	addss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _lpush$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+136]
	addss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv91[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR _end$[ebp+eax], xmm0

; 790  : 
; 791  : 	if( ent->v.movetype == MOVETYPE_FLYMISSILE )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 9
	jne	SHORT $LN2@SV_PushEnt

; 792  : 		type = MOVE_MISSILE;

	mov	DWORD PTR _type$[ebp], 2
	jmp	SHORT $LN5@SV_PushEnt
$LN2@SV_PushEnt:

; 793  : 	else if( ent->v.solid == SOLID_TRIGGER || ent->v.solid == SOLID_NOT )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 1
	je	SHORT $LN6@SV_PushEnt
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+400], 0
	jne	SHORT $LN4@SV_PushEnt
$LN6@SV_PushEnt:

; 794  : 		type = MOVE_NOMONSTERS; // only clip against bmodels

	mov	DWORD PTR _type$[ebp], 1
	jmp	SHORT $LN5@SV_PushEnt
$LN4@SV_PushEnt:

; 795  : 	else type = MOVE_NORMAL;

	mov	DWORD PTR _type$[ebp], 0
$LN5@SV_PushEnt:

; 796  : 
; 797  : 	trace = SV_Move( ent->v.origin, ent->v.mins, ent->v.maxs, end, type, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _type$[ebp]
	push	edx
	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 364				; 0000016cH
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 352				; 00000160H
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 798  : 
; 799  : 	if( trace.fraction != 0.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN9@SV_PushEnt

; 800  : 	{
; 801  : 		VectorCopy( trace.endpos, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 802  : 
; 803  : 		if( sv.state == ss_active && apush[YAW] && ( ent->v.flags & FL_CLIENT ))

	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN8@SV_PushEnt
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _apush$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SV_PushEnt
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN8@SV_PushEnt

; 804  : 		{
; 805  : 			ent->v.avelocity[1] += apush[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _apush$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+220]
	addss	xmm0, DWORD PTR [esi+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+220], xmm0

; 806  : 			ent->v.fixangle = 2;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+288], 2
$LN8@SV_PushEnt:

; 807  : 		}
; 808  : 
; 809  : 		// don't rotate pushables!
; 810  : 		if( SV_AllowPushRotate( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_AllowPushRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@SV_PushEnt

; 811  : 			ent->v.angles[YAW] += trace.fraction * apush[YAW];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _apush$[ebp]
	movss	xmm0, DWORD PTR _trace$[ebp+16]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+208]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+208], xmm0
$LN9@SV_PushEnt:

; 812  : 	}
; 813  : 
; 814  : 	SV_LinkEdict( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_LinkEdict
	add	esp, 8

; 815  : 
; 816  : 	if( ent->v.movetype == MOVETYPE_WALK || ent->v.movetype == MOVETYPE_STEP || ent->v.movetype == MOVETYPE_PUSHSTEP )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 3
	je	SHORT $LN12@SV_PushEnt
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 4
	je	SHORT $LN12@SV_PushEnt
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+396], 13			; 0000000dH
	jne	SHORT $LN10@SV_PushEnt
$LN12@SV_PushEnt:

; 817  : 		monsterBlock = true;

	mov	DWORD PTR _monsterBlock$[ebp], 1
	jmp	SHORT $LN11@SV_PushEnt
$LN10@SV_PushEnt:

; 818  : 	else monsterBlock = false;

	mov	DWORD PTR _monsterBlock$[ebp], 0
$LN11@SV_PushEnt:

; 819  : 
; 820  : 	if( blocked )

	cmp	DWORD PTR _blocked$[ebp], 0
	je	SHORT $LN15@SV_PushEnt

; 821  : 	{
; 822  : 		// more accuracy blocking code
; 823  : 		if( monsterBlock )

	cmp	DWORD PTR _monsterBlock$[ebp], 0
	je	SHORT $LN14@SV_PushEnt

; 824  : 			*blocked = !VectorCompareEpsilon( ent->v.origin, end, ON_EPSILON ); // can't move full distance

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	call	_VectorCompareEpsilon
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@SV_PushEnt
	mov	DWORD PTR tv205[ebp], 1
	jmp	SHORT $LN21@SV_PushEnt
$LN20@SV_PushEnt:
	mov	DWORD PTR tv205[ebp], 0
$LN21@SV_PushEnt:
	mov	edx, DWORD PTR _blocked$[ebp]
	mov	eax, DWORD PTR tv205[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN15@SV_PushEnt
$LN14@SV_PushEnt:

; 825  : 		else *blocked = true;

	mov	eax, DWORD PTR _blocked$[ebp]
	mov	DWORD PTR [eax], 1
$LN15@SV_PushEnt:

; 826  : 	}
; 827  : 
; 828  : 	// so we can run impact function afterwards.
; 829  : 	if( SV_IsValidEdict( trace.ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_PushEntity@@9@9
	add	eax, 48					; 00000030H
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@SV_PushEnt

; 830  : 		SV_Impact( ent, trace.ent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_Impact
	add	esp, 12					; 0000000cH
$LN16@SV_PushEnt:

; 831  : 
; 832  : 	return trace;

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PushEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_AllowPushRotate
_TEXT	SEGMENT
_mod$ = -4						; size = 4
_ent$ = 8						; size = 4
_SV_AllowPushRotate PROC				; COMDAT

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 757  : 	model_t	*mod;
; 758  : 
; 759  : 	mod = SV_ModelHandle( ent->v.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax

; 760  : 
; 761  : 	if( !mod || mod->type != mod_brush )

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN3@SV_AllowPu
	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN2@SV_AllowPu
$LN3@SV_AllowPu:

; 762  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_AllowPu
$LN2@SV_AllowPu:

; 763  : 
; 764  : 	if( !FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 8
	jne	SHORT $LN4@SV_AllowPu

; 765  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_AllowPu
$LN4@SV_AllowPu:

; 766  : 
; 767  : 	if( FBitSet( mod->flags, MODEL_HAS_ORIGIN ))

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 2
	je	SHORT $LN5@SV_AllowPu

; 768  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_AllowPu
$LN5@SV_AllowPu:

; 769  : 
; 770  : 	return false;

	xor	eax, eax
$LN1@SV_AllowPu:

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AllowPushRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_AddHalfGravity
_TEXT	SEGMENT
_ent_gravity$ = -4					; size = 4
_ent$ = 8						; size = 4
_timestep$ = 12						; size = 4
_SV_AddHalfGravity PROC					; COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 726  : 	float	ent_gravity;
; 727  : 
; 728  : 	if( ent->v.gravity )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+452]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_AddHalf

; 729  : 		ent_gravity = ent->v.gravity;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+452]
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
	jmp	SHORT $LN3@SV_AddHalf
$LN2@SV_AddHalf:

; 730  : 	else ent_gravity = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
$LN3@SV_AddHalf:

; 731  : 
; 732  : 	// Add 1/2 of the total gravitational effects over this timestep
; 733  : 	ent->v.velocity[2] -= ( 0.5f * ent_gravity * sv_gravity.value * timestep );

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, DWORD PTR _ent_gravity$[ebp]
	mulss	xmm0, DWORD PTR _sv_gravity+12
	mulss	xmm0, DWORD PTR _timestep$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+160]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm1

; 734  : 	ent->v.velocity[2] += ( ent->v.basevelocity[2] * sv.frametime );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+160]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 735  : 	ent->v.basevelocity[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0

; 736  : 	
; 737  : 	// bound velocity
; 738  : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 739  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddHalfGravity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_AddGravity
_TEXT	SEGMENT
_ent_gravity$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_AddGravity PROC					; COMDAT

; 702  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 703  : 	float	ent_gravity;
; 704  : 
; 705  : 	if( ent->v.gravity )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+452]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@SV_AddGrav

; 706  : 		ent_gravity = ent->v.gravity;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+452]
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
	jmp	SHORT $LN3@SV_AddGrav
$LN2@SV_AddGrav:

; 707  : 	else ent_gravity = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _ent_gravity$[ebp], xmm0
$LN3@SV_AddGrav:

; 708  : 
; 709  : 	// add gravity incorrectly
; 710  : 	ent->v.velocity[2] -= ( ent_gravity * sv_gravity.value * sv.frametime );

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _ent_gravity$[ebp]
	mulss	xmm0, DWORD PTR _sv_gravity+12
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+160]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm1

; 711  : 	ent->v.velocity[2] += ( ent->v.basevelocity[2] * sv.frametime );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+172]
	mulss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+160]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0

; 712  : 	ent->v.basevelocity[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+172], xmm0

; 713  : 
; 714  : 	// bound velocity
; 715  : 	SV_CheckVelocity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 716  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AddGravity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_FlyMove
_TEXT	SEGMENT
tv458 = -340						; size = 4
tv419 = -340						; size = 4
tv173 = -340						; size = 4
tv67 = -340						; size = 4
$T1 = -336						; size = 56
_trace$ = -216						; size = 56
_monsterClip$ = -160					; size = 4
_allFraction$ = -156					; size = 4
_time_left$ = -152					; size = 4
_d$ = -148						; size = 4
_new_velocity$ = -144					; size = 12
_original_velocity$ = -132				; size = 12
_primal_velocity$ = -120				; size = 12
_planes$ = -108						; size = 60
_end$ = -48						; size = 12
_dir$ = -36						; size = 12
_blocked$ = -24						; size = 4
_bumpcount$ = -20					; size = 4
_numplanes$ = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_time$ = 12						; size = 4
_steptrace$ = 16					; size = 4
_SV_FlyMove PROC					; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 559  : 	int	i, j, numplanes, bumpcount, blocked;
; 560  : 	vec3_t	dir, end, planes[MAX_CLIP_PLANES];
; 561  : 	vec3_t	primal_velocity, original_velocity, new_velocity;
; 562  : 	float	d, time_left, allFraction;
; 563  : 	qboolean	monsterClip;
; 564  : 	trace_t	trace;
; 565  : 
; 566  : 	blocked = 0;

	mov	DWORD PTR _blocked$[ebp], 0

; 567  : 	monsterClip = FBitSet( ent->v.flags, FL_MONSTERCLIP ) ? true : false;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8388608				; 00800000H
	je	SHORT $LN32@SV_FlyMove
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN33@SV_FlyMove
$LN32@SV_FlyMove:
	mov	DWORD PTR tv67[ebp], 0
$LN33@SV_FlyMove:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _monsterClip$[ebp], edx

; 568  : 	VectorCopy( ent->v.velocity, original_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _original_velocity$[ebp+ecx], eax

; 569  : 	VectorCopy( ent->v.velocity, primal_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _primal_velocity$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _primal_velocity$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _primal_velocity$[ebp+ecx], eax

; 570  : 	numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0

; 571  : 
; 572  : 	allFraction = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _allFraction$[ebp], xmm0

; 573  : 	time_left = time;

	movss	xmm0, DWORD PTR _time$[ebp]
	movss	DWORD PTR _time_left$[ebp], xmm0

; 574  : 
; 575  : 	for( bumpcount = 0; bumpcount < MAX_CLIP_PLANES - 1; bumpcount++ )

	mov	DWORD PTR _bumpcount$[ebp], 0
	jmp	SHORT $LN4@SV_FlyMove
$LN2@SV_FlyMove:
	mov	eax, DWORD PTR _bumpcount$[ebp]
	add	eax, 1
	mov	DWORD PTR _bumpcount$[ebp], eax
$LN4@SV_FlyMove:
	cmp	DWORD PTR _bumpcount$[ebp], 4
	jge	$LN3@SV_FlyMove

; 576  : 	{
; 577  : 		if( VectorIsNull( ent->v.velocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_FlyMove
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_FlyMove
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@SV_FlyMove

; 578  : 			break;

	jmp	$LN3@SV_FlyMove
$LN11@SV_FlyMove:

; 579  : 
; 580  : 		VectorMA( ent->v.origin, time_left, ent->v.velocity, end );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+160]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+136]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+160]
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+136]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+160]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+136]
	addss	xmm1, xmm0
	movss	DWORD PTR tv173[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR _end$[ebp+edx], xmm0

; 581  : 		trace = SV_Move( ent->v.origin, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent, monsterClip );

	mov	eax, DWORD PTR _monsterClip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	_SV_Move
	add	esp, 32					; 00000020H
	mov	ecx, 14					; 0000000eH
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 582  : 
; 583  : 		allFraction += trace.fraction;

	movss	xmm0, DWORD PTR _allFraction$[ebp]
	addss	xmm0, DWORD PTR _trace$[ebp+16]
	movss	DWORD PTR _allFraction$[ebp], xmm0

; 584  : 
; 585  : 		if( trace.allsolid )

	cmp	DWORD PTR _trace$[ebp], 0
	je	SHORT $LN12@SV_FlyMove

; 586  : 		{	
; 587  : 			// entity is trapped in another solid
; 588  : 			VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 589  : 			return 4;

	mov	eax, 4
	jmp	$LN1@SV_FlyMove
$LN12@SV_FlyMove:

; 590  : 		}
; 591  : 
; 592  : 		if( trace.fraction > 0.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN13@SV_FlyMove

; 593  : 		{	
; 594  : 			// actually covered some distance
; 595  : 			VectorCopy( trace.endpos, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+ecx+20]
	mov	DWORD PTR [edx+eax+136], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _trace$[ebp+edx+20]
	mov	DWORD PTR [ecx+eax+136], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _trace$[ebp+eax+20]
	mov	DWORD PTR [edx+ecx+136], eax

; 596  : 			VectorCopy( ent->v.velocity, original_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+160]
	mov	DWORD PTR _original_velocity$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+160]
	mov	DWORD PTR _original_velocity$[ebp+ecx], eax

; 597  : 			numplanes = 0;

	mov	DWORD PTR _numplanes$[ebp], 0
$LN13@SV_FlyMove:

; 598  : 		}
; 599  : 
; 600  : 		if( trace.fraction == 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@SV_FlyMove

; 601  : 			 break; // moved the entire distance

	jmp	$LN3@SV_FlyMove
$LN14@SV_FlyMove:

; 602  : 
; 603  : 		if( !SV_IsValidEdict( trace.ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FlyMove@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@SV_FlyMove

; 604  : 			break; // g-cont. this should never happens

	jmp	$LN3@SV_FlyMove
$LN15@SV_FlyMove:

; 605  : 
; 606  : 		if( trace.plane.normal[2] > 0.7f )

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+32]
	comiss	xmm0, DWORD PTR __real@3f333333
	jbe	SHORT $LN17@SV_FlyMove

; 607  : 		{
; 608  : 			blocked |= 1; // floor

	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 1
	mov	DWORD PTR _blocked$[ebp], eax

; 609  : 
; 610  :          			if( trace.ent->v.solid == SOLID_BSP || trace.ent->v.solid == SOLID_SLIDEBOX ||
; 611  : 			trace.ent->v.movetype == MOVETYPE_PUSHSTEP || (trace.ent->v.flags & FL_CLIENT))

	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [eax+400], 4
	je	SHORT $LN18@SV_FlyMove
	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [eax+400], 3
	je	SHORT $LN18@SV_FlyMove
	mov	eax, DWORD PTR _trace$[ebp+48]
	cmp	DWORD PTR [eax+396], 13			; 0000000dH
	je	SHORT $LN18@SV_FlyMove
	mov	eax, DWORD PTR _trace$[ebp+48]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 8
	je	SHORT $LN17@SV_FlyMove
$LN18@SV_FlyMove:

; 612  : 			{
; 613  : 				SetBits( ent->v.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 614  : 				ent->v.groundentity = trace.ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _trace$[ebp+48]
	mov	DWORD PTR [eax+648], ecx
$LN17@SV_FlyMove:

; 615  : 			}
; 616  : 		}
; 617  : 
; 618  : 		if( trace.plane.normal[2] == 0.0f )

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _trace$[ebp+eax+32]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@SV_FlyMove

; 619  : 		{
; 620  : 			blocked |= 2; // step

	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 2
	mov	DWORD PTR _blocked$[ebp], eax

; 621  : 			if( steptrace ) *steptrace = trace; // save for player extrafriction

	cmp	DWORD PTR _steptrace$[ebp], 0
	je	SHORT $LN20@SV_FlyMove
	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR _steptrace$[ebp]
	rep movsd
$LN20@SV_FlyMove:

; 622  : 		}
; 623  : 
; 624  : 		// run the impact function
; 625  : 		SV_Impact( ent, trace.ent, &trace );

	lea	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _trace$[ebp+48]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_SV_Impact
	add	esp, 12					; 0000000cH

; 626  : 
; 627  : 		// break if removed by the impact function
; 628  : 		if( ent->free ) break;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN21@SV_FlyMove
	jmp	$LN3@SV_FlyMove
$LN21@SV_FlyMove:

; 629  : 
; 630  : 		time_left -= time_left * trace.fraction;

	movss	xmm0, DWORD PTR _time_left$[ebp]
	mulss	xmm0, DWORD PTR _trace$[ebp+16]
	movss	xmm1, DWORD PTR _time_left$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _time_left$[ebp], xmm1

; 631  : 
; 632  : 		// clipped to another plane
; 633  : 		if( numplanes >= MAX_CLIP_PLANES )

	cmp	DWORD PTR _numplanes$[ebp], 5
	jl	SHORT $LN22@SV_FlyMove

; 634  : 		{
; 635  : 			// this shouldn't really happen
; 636  : 			VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 637  : 			break;

	jmp	$LN3@SV_FlyMove
$LN22@SV_FlyMove:

; 638  : 		}
; 639  : 
; 640  : 		VectorCopy( trace.plane.normal, planes[numplanes] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _numplanes$[ebp], 12
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	ecx, DWORD PTR _trace$[ebp+ecx+32]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _numplanes$[ebp], 12
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _trace$[ebp+edx+32]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _numplanes$[ebp], 12
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _trace$[ebp+eax+32]
	mov	DWORD PTR [edx+ecx], eax

; 641  : 		numplanes++;

	mov	eax, DWORD PTR _numplanes$[ebp]
	add	eax, 1
	mov	DWORD PTR _numplanes$[ebp], eax

; 642  : 
; 643  : 		// modify original_velocity so it parallels all of the clip planes
; 644  : 		for( i = 0; i < numplanes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_FlyMove
$LN5@SV_FlyMove:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_FlyMove:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jge	$LN6@SV_FlyMove

; 645  : 		{
; 646  : 			SV_ClipVelocity( original_velocity, planes[i], new_velocity, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _new_velocity$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _original_velocity$[ebp]
	push	eax
	call	_SV_ClipVelocity
	add	esp, 16					; 00000010H

; 647  : 
; 648  : 			for( j = 0; j < numplanes; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@SV_FlyMove
$LN8@SV_FlyMove:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@SV_FlyMove:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jge	$LN9@SV_FlyMove

; 649  : 			{
; 650  : 				if( j != i )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	je	$LN24@SV_FlyMove

; 651  : 				{
; 652  : 					if( DotProduct( new_velocity, planes[j] ) < 0.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _j$[ebp], 12
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _new_velocity$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _j$[ebp], 12
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _new_velocity$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _j$[ebp], 12
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR _new_velocity$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm0, xmm1
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN24@SV_FlyMove

; 653  : 						break; // not ok

	jmp	SHORT $LN9@SV_FlyMove
$LN24@SV_FlyMove:

; 654  : 				}
; 655  : 			}

	jmp	$LN8@SV_FlyMove
$LN9@SV_FlyMove:

; 656  : 
; 657  : 			if( j == numplanes )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	jne	SHORT $LN25@SV_FlyMove

; 658  : 				break;

	jmp	SHORT $LN6@SV_FlyMove
$LN25@SV_FlyMove:

; 659  : 		}

	jmp	$LN5@SV_FlyMove
$LN6@SV_FlyMove:

; 660  : 
; 661  : 		if( i != numplanes )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numplanes$[ebp]
	je	SHORT $LN26@SV_FlyMove

; 662  : 		{
; 663  : 			// go along this plane
; 664  : 			VectorCopy( new_velocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _new_velocity$[ebp+ecx]
	mov	DWORD PTR [edx+eax+160], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _new_velocity$[ebp+edx]
	mov	DWORD PTR [ecx+eax+160], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _new_velocity$[ebp+eax]
	mov	DWORD PTR [edx+ecx+160], eax

; 665  : 		}

	jmp	$LN27@SV_FlyMove
$LN26@SV_FlyMove:

; 666  : 		else
; 667  : 		{
; 668  : 			// go along the crease
; 669  : 			if( numplanes != 2 )

	cmp	DWORD PTR _numplanes$[ebp], 2
	je	SHORT $LN28@SV_FlyMove

; 670  : 			{
; 671  : 				VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 672  : 				break;

	jmp	$LN3@SV_FlyMove
$LN28@SV_FlyMove:

; 673  : 			}
; 674  : 
; 675  : 			CrossProduct( planes[0], planes[1], dir );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	ecx, DWORD PTR _planes$[ebp+ecx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	eax, DWORD PTR _planes$[ebp+eax]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _planes$[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	ecx, DWORD PTR _planes$[ebp+ecx]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	edx, DWORD PTR _planes$[ebp+edx]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [ecx+eax]
	mulss	xmm1, DWORD PTR [edx+esi]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _planes$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	ecx, DWORD PTR _planes$[ebp+ecx]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _planes$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	eax, DWORD PTR _planes$[ebp+eax]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [eax+esi]
	subss	xmm0, xmm1
	movss	DWORD PTR tv419[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv419[ebp]
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 676  : 			d = DotProduct( dir, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax+160]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+160]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx+160]
	addss	xmm0, xmm1
	movss	DWORD PTR _d$[ebp], xmm0

; 677  : 			VectorScale( dir, d, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _d$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _d$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _d$[ebp]
	movss	DWORD PTR tv458[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv458[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
$LN27@SV_FlyMove:

; 678  : 		}
; 679  : 
; 680  : 		// if current velocity is against the original velocity,
; 681  : 		// stop dead to avoid tiny occilations in sloping corners
; 682  : 		if( DotProduct( ent->v.velocity, primal_velocity ) <= 0.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR _primal_velocity$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+160]
	mulss	xmm1, DWORD PTR _primal_velocity$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+160]
	mulss	xmm1, DWORD PTR _primal_velocity$[ebp+ecx]
	addss	xmm0, xmm1
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jb	SHORT $LN29@SV_FlyMove

; 683  : 		{
; 684  : 			VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0

; 685  : 			break;

	jmp	SHORT $LN3@SV_FlyMove
$LN29@SV_FlyMove:

; 686  : 		}
; 687  : 	}

	jmp	$LN2@SV_FlyMove
$LN3@SV_FlyMove:

; 688  : 
; 689  : 	if( allFraction == 0.0f )

	movss	xmm0, DWORD PTR _allFraction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@SV_FlyMove

; 690  : 		VectorClear( ent->v.velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+160], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx+160], xmm0
$LN30@SV_FlyMove:

; 691  : 
; 692  : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]
$LN1@SV_FlyMove:

; 693  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FlyMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_ClipVelocity
_TEXT	SEGMENT
_blocked$ = -16						; size = 4
_i$ = -12						; size = 4
_change$ = -8						; size = 4
_backoff$ = -4						; size = 4
_in$ = 8						; size = 4
_normal$ = 12						; size = 4
_out$ = 16						; size = 4
_overbounce$ = 20					; size = 4
_SV_ClipVelocity PROC					; COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 516  : 	float	backoff;
; 517  : 	float	change;
; 518  : 	int	i, blocked;
; 519  : 
; 520  : 	blocked = 0;

	mov	DWORD PTR _blocked$[ebp], 0

; 521  : 	if( normal[2] > 0.0f ) blocked |= 1;	// floor

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@SV_ClipVel
	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 1
	mov	DWORD PTR _blocked$[ebp], eax
$LN5@SV_ClipVel:

; 522  : 	if( !normal[2] ) blocked |= 2;	// step

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SV_ClipVel
	mov	eax, DWORD PTR _blocked$[ebp]
	or	eax, 2
	mov	DWORD PTR _blocked$[ebp], eax
$LN6@SV_ClipVel:

; 523  : 	
; 524  : 	backoff = DotProduct( in, normal ) * overbounce;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _in$[ebp]
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _in$[ebp]
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _overbounce$[ebp]
	movss	DWORD PTR _backoff$[ebp], xmm0

; 525  : 
; 526  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_ClipVel
$LN2@SV_ClipVel:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ClipVel:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@SV_ClipVel

; 527  : 	{
; 528  : 		change = normal[i] * backoff;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	mulss	xmm0, DWORD PTR _backoff$[ebp]
	movss	DWORD PTR _change$[ebp], xmm0

; 529  : 		out[i] = in[i] - change;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR _change$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0

; 530  : 
; 531  : 		if( out[i] > -1.0f && out[i] < 1.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	comiss	xmm0, DWORD PTR __real@bf800000
	jbe	SHORT $LN7@SV_ClipVel
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx+eax*4]
	jbe	SHORT $LN7@SV_ClipVel

; 532  : 			out[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN7@SV_ClipVel:

; 533  : 	}

	jmp	SHORT $LN2@SV_ClipVel
$LN3@SV_ClipVel:

; 534  : 
; 535  : 	return blocked;

	mov	eax, DWORD PTR _blocked$[ebp]

; 536  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ClipVelocity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CheckMover
_TEXT	SEGMENT
_gnd$ = -4						; size = 4
_ent$ = 8						; size = 4
_SV_CheckMover PROC					; COMDAT

; 492  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 493  : 	edict_t	*gnd = ent->v.groundentity;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	DWORD PTR _gnd$[ebp], ecx

; 494  : 
; 495  : 	if( !SV_IsValidEdict( gnd ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_CheckMover@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _gnd$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_CheckMo

; 496  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CheckMo
$LN2@SV_CheckMo:

; 497  : 
; 498  : 	if( gnd->v.movetype != MOVETYPE_PUSH )

	mov	eax, DWORD PTR _gnd$[ebp]
	cmp	DWORD PTR [eax+396], 7
	je	SHORT $LN3@SV_CheckMo

; 499  : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_CheckMo
$LN3@SV_CheckMo:

; 500  : 
; 501  : 	if( VectorIsNull( gnd->v.velocity ) && VectorIsNull( gnd->v.avelocity ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@SV_CheckMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@SV_CheckMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_CheckMo
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_CheckMo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_CheckMo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _gnd$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+220]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_CheckMo

; 502  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckMo
$LN4@SV_CheckMo:

; 503  : 
; 504  : 	return true;

	mov	eax, 1
$LN1@SV_CheckMo:

; 505  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckMover ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Submerged
_TEXT	SEGMENT
tv267 = -104						; size = 4
tv253 = -104						; size = 4
tv232 = -104						; size = 4
tv164 = -104						; size = 4
tv142 = -104						; size = 4
tv134 = -104						; size = 4
_center$ = -36						; size = 12
_point$ = -24						; size = 12
_bottom$ = -12						; size = 4
_start$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_Submerged PROC					; COMDAT

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 393  : 	float	start, bottom;
; 394  : 	vec3_t	point;
; 395  : 	vec3_t	center;
; 396  : 
; 397  : 	VectorAverage( ent->v.absmin, ent->v.absmax, center );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _center$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+328]
	addss	xmm0, DWORD PTR [esi+eax+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, 4
	shl	edx, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _center$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	addss	xmm0, DWORD PTR [esi+ecx+340]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv134[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _center$[ebp+eax], xmm0

; 398  : 	start = ent->v.absmin[2] - center[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	subss	xmm0, DWORD PTR _center$[ebp+ecx]
	movss	DWORD PTR _start$[ebp], xmm0

; 399  : 
; 400  : 	switch( ent->v.waterlevel )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR tv142[ebp], ecx
	cmp	DWORD PTR tv142[ebp], 1
	je	SHORT $LN4@SV_Submerg
	cmp	DWORD PTR tv142[ebp], 2
	je	$LN6@SV_Submerg
	cmp	DWORD PTR tv142[ebp], 3
	je	SHORT $LN5@SV_Submerg
	jmp	$LN2@SV_Submerg
$LN4@SV_Submerg:

; 401  : 	{
; 402  : 	case 1:
; 403  : 		bottom = SV_RecursiveWaterLevel( center, 0.0f, start, 0 );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _center$[ebp]
	push	eax
	call	_SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _bottom$[ebp]

; 404  : 		return bottom - start;

	movss	xmm0, DWORD PTR _bottom$[ebp]
	subss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR tv232[ebp], xmm0
	fld	DWORD PTR tv232[ebp]
	jmp	$LN1@SV_Submerg
$LN5@SV_Submerg:

; 405  : 	case 3:
; 406  : 		VectorSet( point, center[0], center[1], ent->v.absmax[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _center$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _point$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _center$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+340]
	movss	DWORD PTR tv164[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv164[ebp]
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 407  : 		svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 408  : 		if( SV_PointContents( point ) == CONTENTS_WATER )

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN6@SV_Submerg

; 409  : 			return (ent->v.maxs[2] - ent->v.mins[2]);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+364]
	subss	xmm0, DWORD PTR [esi+ecx+352]
	movss	DWORD PTR tv253[ebp], xmm0
	fld	DWORD PTR tv253[ebp]
	jmp	SHORT $LN1@SV_Submerg
$LN6@SV_Submerg:

; 410  : 	case 2:	// intentionally fallthrough
; 411  : 		bottom = SV_RecursiveWaterLevel( center, ent->v.absmax[2] - center[2], 0.0f, 0 );

	push	0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+340]
	subss	xmm0, DWORD PTR _center$[ebp+ecx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _center$[ebp]
	push	eax
	call	_SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _bottom$[ebp]

; 412  : 		return bottom - start;

	movss	xmm0, DWORD PTR _bottom$[ebp]
	subss	xmm0, DWORD PTR _start$[ebp]
	movss	DWORD PTR tv267[ebp], xmm0
	fld	DWORD PTR tv267[ebp]
	jmp	SHORT $LN1@SV_Submerg
$LN2@SV_Submerg:

; 413  : 	}
; 414  : 
; 415  : 	return 0.0f;

	fldz
$LN1@SV_Submerg:

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Submerged ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_RecursiveWaterLevel
_TEXT	SEGMENT
tv89 = -88						; size = 4
_offset$ = -20						; size = 4
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_out$ = 12						; size = 4
_in$ = 16						; size = 4
_count$ = 20						; size = 4
_SV_RecursiveWaterLevel PROC				; COMDAT

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 371  : 	vec3_t	point;
; 372  : 	float	offset;
; 373  : 
; 374  : 	offset = ((out - in) * 0.5) + in;

	movss	xmm0, DWORD PTR _out$[ebp]
	subss	xmm0, DWORD PTR _in$[ebp]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtss2sd xmm1, DWORD PTR _in$[ebp]
	addsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _offset$[ebp], xmm0

; 375  : 	if( ++count > 5 ) return offset;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	cmp	DWORD PTR _count$[ebp], 5
	jle	SHORT $LN2@SV_Recursi
	fld	DWORD PTR _offset$[ebp]
	jmp	$LN1@SV_Recursi
$LN2@SV_Recursi:

; 376  : 
; 377  : 	VectorSet( point, origin[0], origin[1], origin[2] + offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _offset$[ebp]
	movss	DWORD PTR tv89[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv89[ebp]
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 378  : 
; 379  : 	if( SV_PointContents( point ) == CONTENTS_WATER )

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN3@SV_Recursi

; 380  : 		return SV_RecursiveWaterLevel( origin, out, offset, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _out$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@SV_Recursi
$LN3@SV_Recursi:

; 381  : 	return SV_RecursiveWaterLevel( origin, offset, in, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _in$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_SV_RecursiveWaterLevel
	add	esp, 16					; 00000010H
$LN1@SV_Recursi:

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RecursiveWaterLevel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_LinearMove
_TEXT	SEGMENT
tv211 = -88						; size = 8
tv239 = -80						; size = 8
tv128 = -76						; size = 4
_adjustment$ = -8					; size = 4
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
_frametime$ = 12					; size = 4
_friction$ = 16						; size = 4
_SV_LinearMove PROC					; COMDAT

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 337  : 	int	i;
; 338  : 	float	adjustment;
; 339  : 
; 340  : 	VectorMA( ent->v.origin, frametime, ent->v.velocity, ent->v.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+160]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+136]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+160]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+136]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+160]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+136]
	addss	xmm1, xmm0
	movss	DWORD PTR tv128[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0

; 341  : 	if( friction == 0.0f ) return;

	movss	xmm0, DWORD PTR _friction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SV_LinearM
	jmp	$LN3@SV_LinearM
$LN5@SV_LinearM:

; 342  : 
; 343  : 	adjustment = frametime * (sv_stopspeed.value / 10.0f) * sv_friction.value * fabs( friction );

	movss	xmm0, DWORD PTR _sv_stopspeed+12
	divss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR _sv_friction+12
	cvtss2sd xmm0, xmm0
	cvtss2sd xmm1, DWORD PTR _friction$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv239[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv211[ebp]
	movsd	xmm0, QWORD PTR tv239[ebp]
	mulsd	xmm0, QWORD PTR tv211[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _adjustment$[ebp], xmm0

; 344  : 
; 345  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_LinearM
$LN2@SV_LinearM:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_LinearM:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@SV_LinearM

; 346  : 	{
; 347  : 		if( ent->v.velocity[i] > 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+160]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@SV_LinearM

; 348  : 		{
; 349  : 			ent->v.velocity[i] -= adjustment;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+160]
	subss	xmm0, DWORD PTR _adjustment$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx*4+160], xmm0

; 350  : 			if( ent->v.velocity[i] < 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+eax*4+160]
	jbe	SHORT $LN8@SV_LinearM

; 351  : 				ent->v.velocity[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+160], xmm0
$LN8@SV_LinearM:

; 352  : 		}

	jmp	SHORT $LN9@SV_LinearM
$LN6@SV_LinearM:

; 353  : 		else
; 354  : 		{
; 355  : 			ent->v.velocity[i] += adjustment;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+160]
	addss	xmm0, DWORD PTR _adjustment$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx*4+160], xmm0

; 356  : 			if( ent->v.velocity[i] > 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+160]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@SV_LinearM

; 357  : 				ent->v.velocity[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+160], xmm0
$LN9@SV_LinearM:

; 358  : 		}
; 359  : 	}

	jmp	$LN2@SV_LinearM
$LN3@SV_LinearM:

; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_LinearMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_AngularMove
_TEXT	SEGMENT
tv211 = -88						; size = 8
tv239 = -80						; size = 8
tv128 = -76						; size = 4
_i$ = -8						; size = 4
_adjustment$ = -4					; size = 4
_ent$ = 8						; size = 4
_frametime$ = 12					; size = 4
_friction$ = 16						; size = 4
_SV_AngularMove PROC					; COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 303  : 	float	adjustment;
; 304  : 	int	i;
; 305  : 
; 306  : 	VectorMA( ent->v.angles, frametime, ent->v.avelocity, ent->v.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax+220]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+208]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+208], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+220]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+208]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+208], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+220]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+208]
	addss	xmm1, xmm0
	movss	DWORD PTR tv128[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR [edx+ecx+208], xmm0

; 307  : 	if( friction == 0.0f ) return;

	movss	xmm0, DWORD PTR _friction$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@SV_Angular
	jmp	$LN3@SV_Angular
$LN5@SV_Angular:

; 308  : 
; 309  : 	adjustment = frametime * (sv_stopspeed.value / 10.0f) * sv_friction.value * fabs( friction );

	movss	xmm0, DWORD PTR _sv_stopspeed+12
	divss	xmm0, DWORD PTR __real@41200000
	mulss	xmm0, DWORD PTR _frametime$[ebp]
	mulss	xmm0, DWORD PTR _sv_friction+12
	cvtss2sd xmm0, xmm0
	cvtss2sd xmm1, DWORD PTR _friction$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv239[ebp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv211[ebp]
	movsd	xmm0, QWORD PTR tv239[ebp]
	mulsd	xmm0, QWORD PTR tv211[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _adjustment$[ebp], xmm0

; 310  : 
; 311  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Angular
$LN2@SV_Angular:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Angular:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@SV_Angular

; 312  : 	{
; 313  : 		if( ent->v.avelocity[i] > 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+220]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@SV_Angular

; 314  : 		{
; 315  : 			ent->v.avelocity[i] -= adjustment;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+220]
	subss	xmm0, DWORD PTR _adjustment$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx*4+220], xmm0

; 316  : 			if( ent->v.avelocity[i] < 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+eax*4+220]
	jbe	SHORT $LN8@SV_Angular

; 317  : 				ent->v.avelocity[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+220], xmm0
$LN8@SV_Angular:

; 318  : 		}

	jmp	SHORT $LN9@SV_Angular
$LN6@SV_Angular:

; 319  : 		else
; 320  : 		{
; 321  : 			ent->v.avelocity[i] += adjustment;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+220]
	addss	xmm0, DWORD PTR _adjustment$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx*4+220], xmm0

; 322  : 			if( ent->v.avelocity[i] > 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4+220]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@SV_Angular

; 323  : 				ent->v.avelocity[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+220], xmm0
$LN9@SV_Angular:

; 324  : 		}
; 325  : 	}

	jmp	$LN2@SV_Angular
$LN3@SV_Angular:

; 326  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_AngularMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_UpdateBaseVelocity
_TEXT	SEGMENT
tv159 = -88						; size = 4
tv132 = -88						; size = 4
_new_basevel$1 = -20					; size = 12
_groundentity$2 = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_UpdateBaseVelocity PROC				; COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 162  : 	if( ent->v.flags & FL_ONGROUND )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 512				; 00000200H
	je	$LN4@SV_UpdateB

; 163  : 	{
; 164  : 		edict_t	*groundentity = ent->v.groundentity;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	DWORD PTR _groundentity$2[ebp], ecx

; 165  : 
; 166  : 		if( SV_IsValidEdict( groundentity ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_UpdateBaseVelocity@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _groundentity$2[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@SV_UpdateB

; 167  : 		{
; 168  : 			// On conveyor belt that's moving?
; 169  : 			if( groundentity->v.flags & FL_CONVEYOR )

	mov	eax, DWORD PTR _groundentity$2[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 4
	je	$LN4@SV_UpdateB

; 170  : 			{
; 171  : 				vec3_t	new_basevel;
; 172  : 
; 173  : 				VectorScale( groundentity->v.movedir, groundentity->v.speed, new_basevel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _groundentity$2[ebp]
	mov	eax, DWORD PTR _groundentity$2[ebp]
	movss	xmm0, DWORD PTR [edx+728]
	mulss	xmm0, DWORD PTR [eax+ecx+196]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _new_basevel$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _groundentity$2[ebp]
	mov	edx, DWORD PTR _groundentity$2[ebp]
	movss	xmm0, DWORD PTR [ecx+728]
	mulss	xmm0, DWORD PTR [edx+eax+196]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _new_basevel$1[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _groundentity$2[ebp]
	mov	eax, DWORD PTR _groundentity$2[ebp]
	movss	xmm0, DWORD PTR [eax+ecx+196]
	mulss	xmm0, DWORD PTR [edx+728]
	movss	DWORD PTR tv132[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _new_basevel$1[ebp+ecx], xmm0

; 174  : 				if( ent->v.flags & FL_BASEVELOCITY )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 4194304				; 00400000H
	je	$LN5@SV_UpdateB

; 175  : 					VectorAdd( new_basevel, ent->v.basevelocity, new_basevel );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _new_basevel$1[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+172]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _new_basevel$1[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _new_basevel$1[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+172]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _new_basevel$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _new_basevel$1[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+172]
	movss	DWORD PTR tv159[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR _new_basevel$1[ebp+eax], xmm0
$LN5@SV_UpdateB:

; 176  : 
; 177  : 				ent->v.flags |= FL_BASEVELOCITY;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 178  : 				VectorCopy( new_basevel, ent->v.basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _new_basevel$1[ebp+ecx]
	mov	DWORD PTR [edx+eax+172], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _new_basevel$1[ebp+edx]
	mov	DWORD PTR [ecx+eax+172], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _new_basevel$1[ebp+eax]
	mov	DWORD PTR [edx+ecx+172], eax
$LN4@SV_UpdateB:

; 179  : 			}
; 180  : 		}
; 181  : 	}
; 182  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateBaseVelocity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CheckAllEnts
_TEXT	SEGMENT
tv162 = -80						; size = 8
tv157 = -80						; size = 8
_i$ = -8						; size = 4
_e$ = -4						; size = 4
_SV_CheckAllEnts PROC					; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 68   : 	static double	nextcheck;
; 69   : 	edict_t		*e;
; 70   : 	int		i;
; 71   : 
; 72   : 	if( !sv_check_errors->value || sv.state != ss_active )

	mov	eax, DWORD PTR _sv_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_CheckAl
	cmp	DWORD PTR _sv, 2
	je	SHORT $LN5@SV_CheckAl
$LN6@SV_CheckAl:

; 73   : 		return;

	jmp	$LN3@SV_CheckAl
$LN5@SV_CheckAl:

; 74   : 
; 75   : 	if(( nextcheck - Sys_DoubleTime()) > 0.0 )

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR ?nextcheck@?1??SV_CheckAllEnts@@9@9
	subsd	xmm0, QWORD PTR tv157[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN7@SV_CheckAl

; 76   : 		return;

	jmp	$LN3@SV_CheckAl
$LN7@SV_CheckAl:

; 77   : 
; 78   : 	// don't check entities every frame (but every 5 secs)
; 79   : 	nextcheck = Sys_DoubleTime() + 5.0;

	call	_Sys_DoubleTime
	fstp	QWORD PTR tv162[ebp]
	movsd	xmm0, QWORD PTR tv162[ebp]
	addsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	QWORD PTR ?nextcheck@?1??SV_CheckAllEnts@@9@9, xmm0

; 80   : 
; 81   : 	// check edicts errors
; 82   : 	for( i = svs.maxclients + 1; i < svgame.numEntities; i++ )

	mov	eax, DWORD PTR _svs+16
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_CheckAl
$LN2@SV_CheckAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckAl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	$LN3@SV_CheckAl

; 83   : 	{
; 84   : 		e = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _e$[ebp], eax

; 85   : 
; 86   : 		if( e->free && e->pvPrivateData != NULL )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@SV_CheckAl
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN8@SV_CheckAl

; 87   : 		{
; 88   : 			Con_Printf( S_ERROR "Freed entity %s (%i) has private data.\n", SV_ClassName( e ), i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DD@ILHMIKIC@?$FO1Error?3?$FO7?5Freed?5entity?5?$CFs?5?$CI?$CFi?$CJ@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 89   : 			continue;

	jmp	SHORT $LN2@SV_CheckAl
$LN8@SV_CheckAl:

; 90   : 		}
; 91   : 
; 92   : 		if( !SV_IsValidEdict( e ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_CheckAllEnts@@9@9
	add	eax, 25					; 00000019H
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_CheckAl

; 93   : 			continue;

	jmp	SHORT $LN2@SV_CheckAl
$LN9@SV_CheckAl:

; 94   : 
; 95   : 		if( !e->v.pContainingEntity || e->v.pContainingEntity != e )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+744], 0
	je	SHORT $LN11@SV_CheckAl
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+744]
	cmp	ecx, DWORD PTR _e$[ebp]
	je	SHORT $LN10@SV_CheckAl
$LN11@SV_CheckAl:

; 96   : 		{
; 97   : 			Con_Printf( S_ERROR "Entity %s (%i) has invalid container, fixed.\n", SV_ClassName( e ), i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DJ@ENHLGMCN@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5has?5i@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 98   : 			e->v.pContainingEntity = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+744], ecx

; 99   : 			continue;

	jmp	$LN2@SV_CheckAl
$LN10@SV_CheckAl:

; 100  : 		}
; 101  : 
; 102  : 		if( !e->pvPrivateData || !Mem_IsAllocatedExt( svgame.mempool, e->pvPrivateData ))

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $LN13@SV_CheckAl
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _svgame+19588
	push	edx
	call	_Mem_IsAllocatedExt
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@SV_CheckAl
$LN13@SV_CheckAl:

; 103  : 		{
; 104  : 			Con_Printf( S_ERROR "Entity %s (%i) trashed private data.\n", SV_ClassName( e ), i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_SV_ClassName
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0DB@LHHIOHKC@?$FO1Error?3?$FO7?5Entity?5?$CFs?5?$CI?$CFi?$CJ?5trash@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 105  : 			e->pvPrivateData = NULL;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+124], 0

; 106  : 			continue;

	jmp	$LN2@SV_CheckAl
$LN12@SV_CheckAl:

; 107  : 		}
; 108  : 
; 109  : 		SV_CheckVelocity( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_SV_CheckVelocity
	add	esp, 4

; 110  : 	}

	jmp	$LN2@SV_CheckAl
$LN3@SV_CheckAl:

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckAllEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CanPushed
_TEXT	SEGMENT
tv65 = -68						; size = 4
_ent$ = 8						; size = 4
_SV_CanPushed PROC					; COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 844  : 	// filter movetypes to collide with
; 845  : 	switch( ent->v.movetype )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 14			; 0000000eH
	ja	SHORT $LN2@SV_CanPush
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN10@SV_CanPush[edx]
	jmp	DWORD PTR $LN11@SV_CanPush[eax*4]
$LN8@SV_CanPush:

; 846  : 	{
; 847  : 	case MOVETYPE_NONE:
; 848  : 	case MOVETYPE_PUSH:
; 849  : 	case MOVETYPE_FOLLOW:
; 850  : 	case MOVETYPE_NOCLIP:
; 851  : 	case MOVETYPE_COMPOUND:
; 852  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CanPush
$LN2@SV_CanPush:

; 853  : 	}
; 854  : 	return true;

	mov	eax, 1
$LN1@SV_CanPush:

; 855  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@SV_CanPush:
	DD	$LN8@SV_CanPush
	DD	$LN2@SV_CanPush
$LN10@SV_CanPush:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
_SV_CanPushed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Impact
_TEXT	SEGMENT
_e1$ = 8						; size = 4
_e2$ = 12						; size = 4
_trace$ = 16						; size = 4
_SV_Impact PROC						; COMDAT

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 267  : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 268  : 
; 269  : 	if(( e1->v.flags|e2->v.flags ) & FL_KILLME )

	mov	eax, DWORD PTR _e1$[ebp]
	mov	ecx, DWORD PTR _e2$[ebp]
	mov	edx, DWORD PTR [eax+656]
	or	edx, DWORD PTR [ecx+656]
	and	edx, 1073741824				; 40000000H
	je	SHORT $LN2@SV_Impact

; 270  : 		return;

	jmp	$LN7@SV_Impact
$LN2@SV_Impact:

; 271  : 
; 272  : 	if( e1->v.groupinfo && e2->v.groupinfo )

	mov	eax, DWORD PTR _e1$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN5@SV_Impact
	mov	eax, DWORD PTR _e2$[ebp]
	cmp	DWORD PTR [eax+800], 0
	je	SHORT $LN5@SV_Impact

; 273  : 	{
; 274  : 		if( svs.groupop == GROUP_OP_AND && !FBitSet( e1->v.groupinfo, e2->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 0
	jne	SHORT $LN4@SV_Impact
	mov	eax, DWORD PTR _e1$[ebp]
	mov	ecx, DWORD PTR _e2$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	jne	SHORT $LN4@SV_Impact

; 275  : 			return;

	jmp	SHORT $LN7@SV_Impact
$LN4@SV_Impact:

; 276  : 
; 277  : 		if( svs.groupop == GROUP_OP_NAND && FBitSet( e1->v.groupinfo, e2->v.groupinfo ))

	cmp	DWORD PTR _svs+24, 1
	jne	SHORT $LN5@SV_Impact
	mov	eax, DWORD PTR _e1$[ebp]
	mov	ecx, DWORD PTR _e2$[ebp]
	mov	edx, DWORD PTR [eax+800]
	and	edx, DWORD PTR [ecx+800]
	je	SHORT $LN5@SV_Impact

; 278  : 			return;

	jmp	SHORT $LN7@SV_Impact
$LN5@SV_Impact:

; 279  : 	}
; 280  : 
; 281  : 	if( e1->v.solid != SOLID_NOT )

	mov	eax, DWORD PTR _e1$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	SHORT $LN6@SV_Impact

; 282  : 	{
; 283  : 		SV_CopyTraceToGlobal( trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	_SV_CopyTraceToGlobal
	add	esp, 4

; 284  : 		svgame.dllFuncs.pfnTouch( e1, e2 );

	mov	eax, DWORD PTR _e2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e1$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19288
	add	esp, 8
$LN6@SV_Impact:

; 285  : 	}
; 286  : 
; 287  : 	if( e2->v.solid != SOLID_NOT )

	mov	eax, DWORD PTR _e2$[ebp]
	cmp	DWORD PTR [eax+400], 0
	je	SHORT $LN7@SV_Impact

; 288  : 	{
; 289  : 		SV_CopyTraceToGlobal( trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	call	_SV_CopyTraceToGlobal
	add	esp, 4

; 290  : 		svgame.dllFuncs.pfnTouch( e2, e1 );

	mov	eax, DWORD PTR _e1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e2$[ebp]
	push	ecx
	call	DWORD PTR _svgame+19288
	add	esp, 8
$LN7@SV_Impact:

; 291  : 	}
; 292  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Impact ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_PlayerRunThink
_TEXT	SEGMENT
tv93 = -72						; size = 4
_thinktime$ = -4					; size = 4
_ent$ = 8						; size = 4
_frametime$ = 12					; size = 4
_time$ = 16						; size = 8
_SV_PlayerRunThink PROC					; COMDAT

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 231  : 	float	thinktime;
; 232  : 
; 233  : 	if( svgame.physFuncs.SV_PlayerThink )

	cmp	DWORD PTR _svgame+19584, 0
	je	SHORT $LN2@SV_PlayerR

; 234  : 		return svgame.physFuncs.SV_PlayerThink( ent, frametime, time );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _time$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _frametime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19584
	add	esp, 16					; 00000010H
	jmp	$LN1@SV_PlayerR
$LN2@SV_PlayerR:

; 235  : 
; 236  : 	if( !FBitSet( ent->v.flags, FL_KILLME|FL_DORMANT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -1073741824			; c0000000H
	jne	SHORT $LN3@SV_PlayerR

; 237  : 	{
; 238  : 		thinktime = ent->v.nextthink;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+392]
	movss	DWORD PTR _thinktime$[ebp], xmm0

; 239  : 		if( thinktime <= 0.0f || thinktime > (time + frametime))

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _thinktime$[ebp]
	jae	SHORT $LN5@SV_PlayerR
	cvtss2sd xmm0, DWORD PTR _thinktime$[ebp]
	cvtss2sd xmm1, DWORD PTR _frametime$[ebp]
	addsd	xmm1, QWORD PTR _time$[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN4@SV_PlayerR
$LN5@SV_PlayerR:

; 240  : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_PlayerR
$LN4@SV_PlayerR:

; 241  : 
; 242  : 		if( thinktime < time )

	cvtss2sd xmm0, DWORD PTR _thinktime$[ebp]
	movsd	xmm1, QWORD PTR _time$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN6@SV_PlayerR

; 243  : 			thinktime = time;	// don't let things stay in the past.

	cvtsd2ss xmm0, QWORD PTR _time$[ebp]
	movss	DWORD PTR _thinktime$[ebp], xmm0
$LN6@SV_PlayerR:

; 244  : 					// it is possible to start that way
; 245  : 					// by a trigger with a local time.
; 246  : 
; 247  : 		ent->v.nextthink = 0.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+392], xmm0

; 248  : 		svgame.globals->time = thinktime;

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR _thinktime$[ebp]
	movss	DWORD PTR [eax], xmm0

; 249  : 		svgame.dllFuncs.pfnThink( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 4
$LN3@SV_PlayerR:

; 250  : 	}
; 251  : 
; 252  : 	if( FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN7@SV_PlayerR

; 253  : 		ClearBits( ent->v.flags, FL_KILLME );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, -1073741825			; bfffffffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN7@SV_PlayerR:

; 254  : 
; 255  : 	return !ent->free;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@SV_PlayerR
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN10@SV_PlayerR
$LN9@SV_PlayerR:
	mov	DWORD PTR tv93[ebp], 0
$LN10@SV_PlayerR:
	mov	eax, DWORD PTR tv93[ebp]
$LN1@SV_PlayerR:

; 256  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PlayerRunThink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_RunThink
_TEXT	SEGMENT
tv86 = -72						; size = 4
_thinktime$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_RunThink PROC					; COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 196  : 	float	thinktime;
; 197  : 
; 198  : 	if( !FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	jne	$LN2@SV_RunThin

; 199  : 	{
; 200  : 		thinktime = ent->v.nextthink;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+392]
	movss	DWORD PTR _thinktime$[ebp], xmm0

; 201  : 		if( thinktime <= 0.0f || thinktime > (sv.time + sv.frametime))

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _thinktime$[ebp]
	jae	SHORT $LN4@SV_RunThin
	cvtss2sd xmm0, DWORD PTR _thinktime$[ebp]
	cvtss2sd xmm1, DWORD PTR _sv+32
	addsd	xmm1, QWORD PTR _sv+16
	comisd	xmm0, xmm1
	jbe	SHORT $LN3@SV_RunThin
$LN4@SV_RunThin:

; 202  : 			return true;

	mov	eax, 1
	jmp	$LN1@SV_RunThin
$LN3@SV_RunThin:

; 203  : 		
; 204  : 		if( thinktime < sv.time )

	cvtss2sd xmm0, DWORD PTR _thinktime$[ebp]
	movsd	xmm1, QWORD PTR _sv+16
	comisd	xmm1, xmm0
	jbe	SHORT $LN5@SV_RunThin

; 205  : 			thinktime = sv.time;	// don't let things stay in the past.

	cvtsd2ss xmm0, QWORD PTR _sv+16
	movss	DWORD PTR _thinktime$[ebp], xmm0
$LN5@SV_RunThin:

; 206  : 						// it is possible to start that way
; 207  : 						// by a trigger with a local time.
; 208  : 		ent->v.nextthink = 0.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+392], xmm0

; 209  : 		svgame.globals->time = thinktime;

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR _thinktime$[ebp]
	movss	DWORD PTR [eax], xmm0

; 210  : 		svgame.dllFuncs.pfnThink( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19280
	add	esp, 4
$LN2@SV_RunThin:

; 211  : 	}
; 212  : 
; 213  : 	if( FBitSet( ent->v.flags, FL_KILLME ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN6@SV_RunThin

; 214  : 		SV_FreeEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_FreeEdict
	add	esp, 4
$LN6@SV_RunThin:

; 215  : 
; 216  : 	return !ent->free;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@SV_RunThin
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN9@SV_RunThin
$LN8@SV_RunThin:
	mov	DWORD PTR tv86[ebp], 0
$LN9@SV_RunThin:
	mov	eax, DWORD PTR tv86[ebp]
$LN1@SV_RunThin:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RunThink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CheckWater
_TEXT	SEGMENT
tv233 = -100						; size = 4
tv230 = -100						; size = 4
tv184 = -100						; size = 4
_dir$1 = -32						; size = 4
_speed$2 = -28						; size = 4
_point$ = -24						; size = 12
_truecont$ = -12					; size = 4
_cont$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_SV_CheckWater PROC					; COMDAT

; 424  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 425  : 	int	cont, truecont;
; 426  : 	vec3_t	point;
; 427  : 
; 428  : 	point[0] = (ent->v.absmax[0] + ent->v.absmin[0]) * 0.5f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+340]
	addss	xmm0, DWORD PTR [esi+eax+328]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 429  : 	point[1] = (ent->v.absmax[1] + ent->v.absmin[1]) * 0.5f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+340]
	addss	xmm0, DWORD PTR [esi+ecx+328]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 430  : 	point[2] = (ent->v.absmin[2] + 1.0f);

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+328]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 431  : 
; 432  : 	ent->v.watertype = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+676], -1

; 433  : 	svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 434  : 	ent->v.waterlevel = 0;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 0

; 435  : 
; 436  : 	cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 437  : 
; 438  : 	if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	$LN7@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	$LN7@SV_CheckWa

; 439  : 	{
; 440  : 		svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 441  : 		truecont = SV_TruePointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_TruePointContents
	add	esp, 4
	mov	DWORD PTR _truecont$[ebp], eax

; 442  : 
; 443  : 		ent->v.watertype = cont;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cont$[ebp]
	mov	DWORD PTR [eax+676], ecx

; 444  : 		ent->v.waterlevel = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 1

; 445  : 
; 446  : 		if( ent->v.absmin[2] != ent->v.absmax[2] )

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	ucomiss	xmm0, DWORD PTR [esi+ecx+340]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@SV_CheckWa

; 447  : 		{
; 448  : 			point[2] = (ent->v.absmin[2] + ent->v.absmax[2]) * 0.5f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+328]
	addss	xmm0, DWORD PTR [esi+ecx+340]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 449  : 
; 450  : 			svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 451  : 			cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 452  : 
; 453  : 			if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	$LN6@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	$LN6@SV_CheckWa

; 454  : 			{
; 455  : 				ent->v.waterlevel = 2;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 2

; 456  : 
; 457  : 				VectorAdd( point, ent->v.view_ofs, point );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax+608]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+edx]
	addss	xmm0, DWORD PTR [ecx+eax+608]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _point$[ebp+eax]
	addss	xmm0, DWORD PTR [edx+ecx+608]
	movss	DWORD PTR tv184[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv184[ebp]
	movss	DWORD PTR _point$[ebp+eax], xmm0

; 458  : 				svs.groupmask = ent->v.groupinfo;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _svs+20, ecx

; 459  : 				cont = SV_PointContents( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	_SV_PointContents
	add	esp, 4
	mov	DWORD PTR _cont$[ebp], eax

; 460  : 
; 461  : 				if( cont <= CONTENTS_WATER && cont > CONTENTS_TRANSLUCENT )

	cmp	DWORD PTR _cont$[ebp], -3		; fffffffdH
	jg	SHORT $LN6@SV_CheckWa
	cmp	DWORD PTR _cont$[ebp], -15		; fffffff1H
	jle	SHORT $LN6@SV_CheckWa

; 462  : 					ent->v.waterlevel = 3;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 3
$LN6@SV_CheckWa:

; 463  : 			}
; 464  : 		}

	jmp	SHORT $LN4@SV_CheckWa
$LN3@SV_CheckWa:

; 465  : 		else
; 466  : 		{
; 467  : 			// a point entity
; 468  : 			ent->v.waterlevel = 3;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+672], 3
$LN4@SV_CheckWa:

; 469  : 		}
; 470  : 
; 471  : 		// Quake2 feature. Probably never was used in Half-Life...
; 472  : 		if( truecont <= CONTENTS_CURRENT_0 && truecont >= CONTENTS_CURRENT_DOWN )

	cmp	DWORD PTR _truecont$[ebp], -9		; fffffff7H
	jg	$LN7@SV_CheckWa
	cmp	DWORD PTR _truecont$[ebp], -14		; fffffff2H
	jl	$LN7@SV_CheckWa

; 473  : 		{
; 474  : 			float speed = 150.0f * ent->v.waterlevel / 3.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+672]
	mulss	xmm0, DWORD PTR __real@43160000
	divss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _speed$2[ebp], xmm0

; 475  : 			const float *dir = current_table[CONTENTS_CURRENT_0 - truecont];

	mov	eax, -9					; fffffff7H
	sub	eax, DWORD PTR _truecont$[ebp]
	imul	ecx, eax, 12
	add	ecx, OFFSET _current_table
	mov	DWORD PTR _dir$1[ebp], ecx

; 476  : 
; 477  : 			VectorMA( ent->v.basevelocity, speed, dir, ent->v.basevelocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dir$1[ebp]
	movss	xmm0, DWORD PTR _speed$2[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+172]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+172], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _dir$1[ebp]
	movss	xmm0, DWORD PTR _speed$2[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+172], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dir$1[ebp]
	movss	xmm0, DWORD PTR _speed$2[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+172]
	addss	xmm1, xmm0
	movss	DWORD PTR tv230[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv230[ebp]
	movss	DWORD PTR [edx+ecx+172], xmm0
$LN7@SV_CheckWa:

; 478  : 		}
; 479  : 	}
; 480  : 
; 481  : 	return (ent->v.waterlevel > 1);

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+672], 1
	jle	SHORT $LN9@SV_CheckWa
	mov	DWORD PTR tv233[ebp], 1
	jmp	SHORT $LN10@SV_CheckWa
$LN9@SV_CheckWa:
	mov	DWORD PTR tv233[ebp], 0
$LN10@SV_CheckWa:
	mov	eax, DWORD PTR tv233[ebp]

; 482  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckWater ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_CheckVelocity
_TEXT	SEGMENT
tv193 = -80						; size = 4
_i$ = -12						; size = 4
_maxspd$ = -8						; size = 4
_wishspd$ = -4						; size = 4
_ent$ = 8						; size = 4
_SV_CheckVelocity PROC					; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 120  : 	float	wishspd;
; 121  : 	float	maxspd;
; 122  : 	int	i;
; 123  : 
; 124  : 	// bound velocity
; 125  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckVe
$LN2@SV_CheckVe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckVe:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@SV_CheckVe

; 126  : 	{
; 127  : 		if( IS_NAN( ent->v.velocity[i] ))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+160]
	and	edx, 2139095040				; 7f800000H
	cmp	edx, 2139095040				; 7f800000H
	jne	SHORT $LN5@SV_CheckVe

; 128  : 		{
; 129  : 			if( sv_check_errors->value )

	mov	eax, DWORD PTR _sv_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@SV_CheckVe

; 130  : 				Con_Printf( "Got a NaN velocity on %s\n", STRING( ent->v.classname ));

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BK@FPJNFHPF@Got?5a?5NaN?5velocity?5on?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN6@SV_CheckVe:

; 131  : 			ent->v.velocity[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+160], xmm0
$LN5@SV_CheckVe:

; 132  : 		}
; 133  : 
; 134  : 		if( IS_NAN( ent->v.origin[i] ))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	and	edx, 2139095040				; 7f800000H
	cmp	edx, 2139095040				; 7f800000H
	jne	SHORT $LN7@SV_CheckVe

; 135  : 		{
; 136  : 			if( sv_check_errors->value )

	mov	eax, DWORD PTR _sv_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@SV_CheckVe

; 137  : 				Con_Printf( "Got a NaN origin on %s\n", STRING( ent->v.classname ));

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BI@JOACCKMB@Got?5a?5NaN?5origin?5on?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN8@SV_CheckVe:

; 138  : 			ent->v.origin[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+136], xmm0
$LN7@SV_CheckVe:

; 139  : 		}
; 140  : 	}

	jmp	$LN2@SV_CheckVe
$LN3@SV_CheckVe:

; 141  : 
; 142  : 	wishspd = DotProduct( ent->v.velocity, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR [esi+eax+160]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+160]
	mulss	xmm1, DWORD PTR [esi+ecx+160]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+160]
	mulss	xmm1, DWORD PTR [esi+ecx+160]
	addss	xmm0, xmm1
	movss	DWORD PTR _wishspd$[ebp], xmm0

; 143  : 	maxspd = sv_maxvelocity.value * sv_maxvelocity.value * 1.73f; // half-diagonal

	movss	xmm0, DWORD PTR _sv_maxvelocity+12
	mulss	xmm0, DWORD PTR _sv_maxvelocity+12
	mulss	xmm0, DWORD PTR __real@3fdd70a4
	movss	DWORD PTR _maxspd$[ebp], xmm0

; 144  : 
; 145  : 	if( wishspd > maxspd )

	movss	xmm0, DWORD PTR _wishspd$[ebp]
	comiss	xmm0, DWORD PTR _maxspd$[ebp]
	jbe	$LN9@SV_CheckVe

; 146  : 	{
; 147  : 		wishspd = sqrt( wishspd );

	cvtss2sd xmm0, DWORD PTR _wishspd$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _wishspd$[ebp]

; 148  : 		if( sv_check_errors->value )

	mov	eax, DWORD PTR _sv_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@SV_CheckVe

; 149  : 			Con_Printf( "Got a velocity too high on %s ( %.2f > %.2f )\n", STRING( ent->v.classname ), wishspd, sqrt( maxspd ));

	cvtss2sd xmm0, DWORD PTR _maxspd$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	fstp	QWORD PTR [esp]
	cvtss2sd xmm0, DWORD PTR _wishspd$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CP@COFEPPBP@Got?5a?5velocity?5too?5high?5on?5?$CFs?5?$CI@
	call	_Con_Printf
	add	esp, 24					; 00000018H
$LN10@SV_CheckVe:

; 150  : 		wishspd = sv_maxvelocity.value / wishspd;

	movss	xmm0, DWORD PTR _sv_maxvelocity+12
	divss	xmm0, DWORD PTR _wishspd$[ebp]
	movss	DWORD PTR _wishspd$[ebp], xmm0

; 151  : 		VectorScale( ent->v.velocity, wishspd, ent->v.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR _wishspd$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+160], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+160]
	mulss	xmm0, DWORD PTR _wishspd$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+160], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+160]
	mulss	xmm0, DWORD PTR _wishspd$[ebp]
	movss	DWORD PTR tv193[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR [ecx+eax+160], xmm0
$LN9@SV_CheckVe:

; 152  : 	}
; 153  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckVelocity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_InitPhysicsAPI
_TEXT	SEGMENT
_SV_InitPhysicsAPI PROC					; COMDAT

; 2053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2054 : 	static PHYSICAPI	pPhysIface;
; 2055 : 
; 2056 : 	pPhysIface = (PHYSICAPI)COM_GetProcAddress( svgame.hInstance, "Server_GetPhysicsInterface" );

	push	OFFSET ??_C@_0BL@MAPOEFPK@Server_GetPhysicsInterface@
	mov	eax, DWORD PTR _svgame+7920
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR ?pPhysIface@?1??SV_InitPhysicsAPI@@9@9, eax

; 2057 : 	if( pPhysIface )

	cmp	DWORD PTR ?pPhysIface@?1??SV_InitPhysicsAPI@@9@9, 0
	je	SHORT $LN2@SV_InitPhy

; 2058 : 	{
; 2059 : 		if( pPhysIface( SV_PHYSICS_INTERFACE_VERSION, &gPhysicsAPI, &svgame.physFuncs ))

	push	OFFSET _svgame+19492
	push	OFFSET _gPhysicsAPI
	push	6
	call	DWORD PTR ?pPhysIface@?1??SV_InitPhysicsAPI@@9@9
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@SV_InitPhy

; 2060 : 		{
; 2061 : 			Con_Reportf( "SV_LoadProgs: ^2initailized extended PhysicAPI ^7ver. %i\n", SV_PHYSICS_INTERFACE_VERSION );

	push	6
	push	OFFSET ??_C@_0DK@HEIDKLFD@SV_LoadProgs?3?5?$FO2initailized?5ext@
	call	_Con_Reportf
	add	esp, 8

; 2062 : 
; 2063 : 			if( svgame.physFuncs.SV_CheckFeatures != NULL )

	cmp	DWORD PTR _svgame+19520, 0
	je	SHORT $LN4@SV_InitPhy

; 2064 : 			{
; 2065 : 				// grab common engine features (it will be shared across the network)
; 2066 : 				host.features = svgame.physFuncs.SV_CheckFeatures();

	call	DWORD PTR _svgame+19520
	mov	DWORD PTR _host+34752, eax

; 2067 : 				Host_PrintEngineFeatures ();

	call	_Host_PrintEngineFeatures
$LN4@SV_InitPhy:

; 2068 : 			}
; 2069 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_InitPhy
$LN3@SV_InitPhy:

; 2070 : 		}
; 2071 : 
; 2072 : 		// make sure what physic functions is cleared
; 2073 : 		memset( &svgame.physFuncs, 0, sizeof( svgame.physFuncs ));

	push	96					; 00000060H
	push	0
	push	OFFSET _svgame+19492
	call	_memset
	add	esp, 12					; 0000000cH

; 2074 : 
; 2075 : 		return false; // just tell user about problems

	xor	eax, eax
	jmp	SHORT $LN1@SV_InitPhy
$LN2@SV_InitPhy:

; 2076 : 	}
; 2077 : 
; 2078 : 	// physic interface is missed
; 2079 : 	return true;

	mov	eax, 1
$LN1@SV_InitPhy:

; 2080 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_InitPhysicsAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_Physics
_TEXT	SEGMENT
_skyAngle$1 = -12					; size = 4
_i$ = -8						; size = 4
_ent$ = -4						; size = 4
_SV_Physics PROC					; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1777 : 	edict_t	*ent;
; 1778 : 	int    	i;
; 1779 : 	
; 1780 : 	SV_CheckAllEnts ();

	call	_SV_CheckAllEnts

; 1781 : 
; 1782 : 	svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 1783 : 
; 1784 : 	// let the progs know that a new frame has started
; 1785 : 	svgame.dllFuncs.pfnStartFrame();

	call	DWORD PTR _svgame+19372

; 1786 : 
; 1787 : 	// treat each object in turn
; 1788 : 	for( i = 0; i < svgame.numEntities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Physics
$LN2@SV_Physics:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Physics:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svgame+7932
	jge	SHORT $LN3@SV_Physics

; 1789 : 	{
; 1790 : 		ent = EDICT_NUM( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1791 : 
; 1792 : 		if( !SV_IsValidEdict( ent ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Physics@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DE@BEBKOIKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_Physics

; 1793 : 			continue;

	jmp	SHORT $LN2@SV_Physics
$LN8@SV_Physics:

; 1794 : 
; 1795 : 		if( i > 0 && i <= svs.maxclients )

	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN9@SV_Physics
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN9@SV_Physics

; 1796 :                    		continue;

	jmp	SHORT $LN2@SV_Physics
$LN9@SV_Physics:

; 1797 : 
; 1798 : 		SV_Physics_Entity( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_Physics_Entity
	add	esp, 4

; 1799 : 	}

	jmp	SHORT $LN2@SV_Physics
$LN3@SV_Physics:

; 1800 : 
; 1801 : 	if( svgame.globals->force_retouch != 0.0f )

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@SV_Physics

; 1802 : 		svgame.globals->force_retouch--;

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR _svgame+19268
	movss	DWORD PTR [ecx+8], xmm0
$LN10@SV_Physics:

; 1803 : 
; 1804 : 	if( svgame.physFuncs.SV_EndFrame != NULL )

	cmp	DWORD PTR _svgame+19544, 0
	je	SHORT $LN11@SV_Physics

; 1805 : 		svgame.physFuncs.SV_EndFrame();

	call	DWORD PTR _svgame+19544
$LN11@SV_Physics:

; 1806 : 
; 1807 : 	// animate lightstyles (used for GetEntityIllum)
; 1808 : 	SV_RunLightStyles ();

	call	_SV_RunLightStyles

; 1809 : 
; 1810 : 	// Restored rotating skyboxes
; 1811 : 	if (sv_skyspeed.value)

	movss	xmm0, DWORD PTR _sv_skyspeed+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SV_Physics

; 1812 : 	{
; 1813 : 		// evaluate sky rotation.
; 1814 : 		float skyAngle = sv_skyangle.value + sv_skyspeed.value * sv.frametime;

	movss	xmm0, DWORD PTR _sv_skyspeed+12
	mulss	xmm0, DWORD PTR _sv+32
	addss	xmm0, DWORD PTR _sv_skyangle+12
	movss	DWORD PTR _skyAngle$1[ebp], xmm0

; 1815 : 		Cvar_SetValue("sv_skyangle", anglemod(skyAngle));

	push	ecx
	movss	xmm0, DWORD PTR _skyAngle$1[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0M@KODFIOCL@sv_skyangle@
	call	_Cvar_SetValue
	add	esp, 8
$LN12@SV_Physics:

; 1816 : 	}
; 1817 : 
; 1818 : 	// increase framecount
; 1819 : 	sv.framecount++;

	mov	eax, DWORD PTR _sv+36
	add	eax, 1
	mov	DWORD PTR _sv+36, eax
	jmp	SHORT $LN7@SV_Physics
$LN5@SV_Physics:

; 1820 : 
; 1821 : 	// decrement svgame.numEntities if the highest number entities died
; 1822 : 	for( ; EDICT_NUM( svgame.numEntities - 1 )->free; svgame.numEntities-- );

	mov	eax, DWORD PTR _svgame+7932
	sub	eax, 1
	mov	DWORD PTR _svgame+7932, eax
$LN7@SV_Physics:
	mov	eax, DWORD PTR _svgame+7932
	sub	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@SV_Physics
	jmp	SHORT $LN5@SV_Physics
$LN6@SV_Physics:

; 1823 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Physics ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_DrawOrthoTriangles
_TEXT	SEGMENT
_SV_DrawOrthoTriangles PROC				; COMDAT

; 1915 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1916 : 	if( host.type != HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	je	SHORT $LN2@SV_DrawOrt

; 1917 : 		return;

	jmp	SHORT $LN1@SV_DrawOrt
$LN2@SV_DrawOrt:

; 1918 : 
; 1919 : 	if( svgame.physFuncs.DrawOrthoTriangles != NULL )

	cmp	DWORD PTR _svgame+19532, 0
	je	SHORT $LN1@SV_DrawOrt

; 1920 : 	{
; 1921 : 		// draw solid overlay
; 1922 : 		svgame.physFuncs.DrawOrthoTriangles ();

	call	DWORD PTR _svgame+19532
$LN1@SV_DrawOrt:

; 1923 : 	}
; 1924 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DrawOrthoTriangles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_phys.c
;	COMDAT _SV_DrawDebugTriangles
_TEXT	SEGMENT
_SV_DrawDebugTriangles PROC				; COMDAT

; 1881 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1882 : 	if( host.type != HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	je	SHORT $LN2@SV_DrawDeb

; 1883 : 		return;

	jmp	SHORT $LN1@SV_DrawDeb
$LN2@SV_DrawDeb:

; 1884 : 
; 1885 : 	if( svgame.physFuncs.DrawNormalTriangles != NULL )

	cmp	DWORD PTR _svgame+19528, 0
	je	SHORT $LN3@SV_DrawDeb

; 1886 : 	{
; 1887 : 		// draw solid overlay
; 1888 : 		svgame.physFuncs.DrawNormalTriangles ();

	call	DWORD PTR _svgame+19528
$LN3@SV_DrawDeb:

; 1889 : 	}
; 1890 : 
; 1891 : 	if( svgame.physFuncs.DrawDebugTriangles != NULL )

	cmp	DWORD PTR _svgame+19524, 0
	je	SHORT $LN1@SV_DrawDeb

; 1892 : 	{
; 1893 : 		// debug draws only
; 1894 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1895 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 1896 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1897 : 
; 1898 : 		// draw wireframe overlay
; 1899 : 		svgame.physFuncs.DrawDebugTriangles ();

	call	DWORD PTR _svgame+19524

; 1900 : 
; 1901 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1902 : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 1903 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable
$LN1@SV_DrawDeb:

; 1904 : 	}
; 1905 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DrawDebugTriangles ENDP
_TEXT	ENDS
END
