; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\net_ws.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04NPNJNMMP@bind@				; `string'
PUBLIC	??_C@_04MIIPNNEF@send@				; `string'
PUBLIC	??_C@_04IFMDBHHF@recv@				; `string'
PUBLIC	??_C@_05FBACCBIB@ntohs@				; `string'
PUBLIC	??_C@_05IDNGLOCO@htons@				; `string'
PUBLIC	??_C@_05JMFICPBP@ntohl@				; `string'
PUBLIC	??_C@_06HBELJPBO@socket@			; `string'
PUBLIC	??_C@_06LGNCCACI@select@			; `string'
PUBLIC	??_C@_06MEPBGKEC@sendto@			; `string'
PUBLIC	??_C@_07KAIBNCHO@connect@			; `string'
PUBLIC	??_C@_08HMBBGFHE@recvfrom@			; `string'
PUBLIC	??_C@_09JKBDEEOB@inet_addr@			; `string'
PUBLIC	??_C@_09CFOACKNM@inet_ntoa@			; `string'
PUBLIC	??_C@_0L@EEFLCHHA@WSAStartup@			; `string'
PUBLIC	??_C@_0L@OPKENMEN@WSACleanup@			; `string'
PUBLIC	??_C@_0L@CKHNIFCM@setsockopt@			; `string'
PUBLIC	??_C@_0M@PBPOCKDG@ioctlsocket@			; `string'
PUBLIC	??_C@_0M@ODDJDCDK@closesocket@			; `string'
PUBLIC	??_C@_0M@FIJPCJJO@gethostname@			; `string'
PUBLIC	??_C@_0M@ODFENJLC@getsockname@			; `string'
PUBLIC	??_C@_0O@BFBCKHPD@gethostbyname@		; `string'
PUBLIC	??_C@_0BA@ONBHHGGB@WSAGetLastError@		; `string'
PUBLIC	_winsock_dll
PUBLIC	??_C@_0M@OJLCMFNP@wsock32?4dll@			; `string'
_DATA	SEGMENT
COMM	_net_clockwindow:DWORD
COMM	_net_local:BYTE:014H
_DATA	ENDS
_BSS	SEGMENT
_pWSACleanup DD	01H DUP (?)
_pNtohs	DD	01H DUP (?)
_pWSAGetLastError DD 01H DUP (?)
_pCloseSocket DD 01H DUP (?)
_pHtons	DD	01H DUP (?)
_pInet_Addr DD	01H DUP (?)
_pInet_Ntoa DD	01H DUP (?)
_pSocket DD	01H DUP (?)
_pGetHostByName DD 01H DUP (?)
_pIoctlSocket DD 01H DUP (?)
_pWSAStartup DD	01H DUP (?)
_pBind	DD	01H DUP (?)
_pSetSockopt DD	01H DUP (?)
_pRecvFrom DD	01H DUP (?)
_pSendTo DD	01H DUP (?)
_pSelect DD	01H DUP (?)
_pConnect DD	01H DUP (?)
_pGetSockName DD 01H DUP (?)
_pSend	DD	01H DUP (?)
_pRecv	DD	01H DUP (?)
_pGetHostName DD 01H DUP (?)
_pNtohl	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@OJLCMFNP@wsock32?4dll@
CONST	SEGMENT
??_C@_0M@OJLCMFNP@wsock32?4dll@ DB 'wsock32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ONBHHGGB@WSAGetLastError@
CONST	SEGMENT
??_C@_0BA@ONBHHGGB@WSAGetLastError@ DB 'WSAGetLastError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFBCKHPD@gethostbyname@
CONST	SEGMENT
??_C@_0O@BFBCKHPD@gethostbyname@ DB 'gethostbyname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ODFENJLC@getsockname@
CONST	SEGMENT
??_C@_0M@ODFENJLC@getsockname@ DB 'getsockname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FIJPCJJO@gethostname@
CONST	SEGMENT
??_C@_0M@FIJPCJJO@gethostname@ DB 'gethostname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ODDJDCDK@closesocket@
CONST	SEGMENT
??_C@_0M@ODDJDCDK@closesocket@ DB 'closesocket', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBPOCKDG@ioctlsocket@
CONST	SEGMENT
??_C@_0M@PBPOCKDG@ioctlsocket@ DB 'ioctlsocket', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CKHNIFCM@setsockopt@
CONST	SEGMENT
??_C@_0L@CKHNIFCM@setsockopt@ DB 'setsockopt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPKENMEN@WSACleanup@
CONST	SEGMENT
??_C@_0L@OPKENMEN@WSACleanup@ DB 'WSACleanup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EEFLCHHA@WSAStartup@
CONST	SEGMENT
??_C@_0L@EEFLCHHA@WSAStartup@ DB 'WSAStartup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFOACKNM@inet_ntoa@
CONST	SEGMENT
??_C@_09CFOACKNM@inet_ntoa@ DB 'inet_ntoa', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKBDEEOB@inet_addr@
CONST	SEGMENT
??_C@_09JKBDEEOB@inet_addr@ DB 'inet_addr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMBBGFHE@recvfrom@
CONST	SEGMENT
??_C@_08HMBBGFHE@recvfrom@ DB 'recvfrom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KAIBNCHO@connect@
CONST	SEGMENT
??_C@_07KAIBNCHO@connect@ DB 'connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MEPBGKEC@sendto@
CONST	SEGMENT
??_C@_06MEPBGKEC@sendto@ DB 'sendto', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGNCCACI@select@
CONST	SEGMENT
??_C@_06LGNCCACI@select@ DB 'select', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBELJPBO@socket@
CONST	SEGMENT
??_C@_06HBELJPBO@socket@ DB 'socket', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JMFICPBP@ntohl@
CONST	SEGMENT
??_C@_05JMFICPBP@ntohl@ DB 'ntohl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IDNGLOCO@htons@
CONST	SEGMENT
??_C@_05IDNGLOCO@htons@ DB 'htons', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBACCBIB@ntohs@
CONST	SEGMENT
??_C@_05FBACCBIB@ntohs@ DB 'ntohs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFMDBHHF@recv@
CONST	SEGMENT
??_C@_04IFMDBHHF@recv@ DB 'recv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIIPNNEF@send@
CONST	SEGMENT
??_C@_04MIIPNNEF@send@ DB 'send', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NPNJNMMP@bind@
CONST	SEGMENT
??_C@_04NPNJNMMP@bind@ DB 'bind', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_winsock_funcs DD FLAT:??_C@_04NPNJNMMP@bind@
	DD	FLAT:_pBind
	DD	FLAT:??_C@_04MIIPNNEF@send@
	DD	FLAT:_pSend
	DD	FLAT:??_C@_04IFMDBHHF@recv@
	DD	FLAT:_pRecv
	DD	FLAT:??_C@_05FBACCBIB@ntohs@
	DD	FLAT:_pNtohs
	DD	FLAT:??_C@_05IDNGLOCO@htons@
	DD	FLAT:_pHtons
	DD	FLAT:??_C@_05JMFICPBP@ntohl@
	DD	FLAT:_pNtohl
	DD	FLAT:??_C@_06HBELJPBO@socket@
	DD	FLAT:_pSocket
	DD	FLAT:??_C@_06LGNCCACI@select@
	DD	FLAT:_pSelect
	DD	FLAT:??_C@_06MEPBGKEC@sendto@
	DD	FLAT:_pSendTo
	DD	FLAT:??_C@_07KAIBNCHO@connect@
	DD	FLAT:_pConnect
	DD	FLAT:??_C@_08HMBBGFHE@recvfrom@
	DD	FLAT:_pRecvFrom
	DD	FLAT:??_C@_09JKBDEEOB@inet_addr@
	DD	FLAT:_pInet_Addr
	DD	FLAT:??_C@_09CFOACKNM@inet_ntoa@
	DD	FLAT:_pInet_Ntoa
	DD	FLAT:??_C@_0L@EEFLCHHA@WSAStartup@
	DD	FLAT:_pWSAStartup
	DD	FLAT:??_C@_0L@OPKENMEN@WSACleanup@
	DD	FLAT:_pWSACleanup
	DD	FLAT:??_C@_0L@CKHNIFCM@setsockopt@
	DD	FLAT:_pSetSockopt
	DD	FLAT:??_C@_0M@PBPOCKDG@ioctlsocket@
	DD	FLAT:_pIoctlSocket
	DD	FLAT:??_C@_0M@ODDJDCDK@closesocket@
	DD	FLAT:_pCloseSocket
	DD	FLAT:??_C@_0M@FIJPCJJO@gethostname@
	DD	FLAT:_pGetHostName
	DD	FLAT:??_C@_0M@ODFENJLC@getsockname@
	DD	FLAT:_pGetSockName
	DD	FLAT:??_C@_0O@BFBCKHPD@gethostbyname@
	DD	FLAT:_pGetHostByName
	DD	FLAT:??_C@_0BA@ONBHHGGB@WSAGetLastError@
	DD	FLAT:_pWSAGetLastError
	DD	00H
	DD	00H
_winsock_dll DD	FLAT:??_C@_0M@OJLCMFNP@wsock32?4dll@
	DD	FLAT:_winsock_funcs
	DD	00H
	ORG $+4
_DATA	ENDS
PUBLIC	_NET_Init
PUBLIC	_NET_Shutdown
PUBLIC	_NET_Sleep
PUBLIC	_NET_IsActive
PUBLIC	_NET_IsConfigured
PUBLIC	_NET_Config
PUBLIC	_NET_IsLocalAddress
PUBLIC	_NET_AdrToString
PUBLIC	_NET_BaseAdrToString
PUBLIC	_NET_IsReservedAdr
PUBLIC	_NET_CompareClassBAdr
PUBLIC	_NET_StringToAdr
PUBLIC	_NET_CompareAdr
PUBLIC	_NET_CompareBaseAdr
PUBLIC	_NET_GetPacket
PUBLIC	_NET_BufferToBufferCompress
PUBLIC	_NET_BufferToBufferDecompress
PUBLIC	_NET_SendPacket
PUBLIC	_NET_ClearLagData
PUBLIC	_NET_OpenWinSock
PUBLIC	_NET_FreeWinSock
PUBLIC	_NET_ErrorString
PUBLIC	_NET_GetLong
PUBLIC	_NET_QueuePacket
PUBLIC	_NET_SendLong
PUBLIC	_NET_GetLocalAddress
PUBLIC	??_C@_08KEJFHKFF@WSAEINTR@			; `string'
PUBLIC	??_C@_08LJKOCPDH@WSAEBADF@			; `string'
PUBLIC	??_C@_09EKFHKCJJ@WSAEACCES@			; `string'
PUBLIC	??_C@_0L@EEHHIAEC@WSAEDISCON@			; `string'
PUBLIC	??_C@_09BIHAGEEK@WSAEFAULT@			; `string'
PUBLIC	??_C@_09PDAAOFKK@WSAEINVAL@			; `string'
PUBLIC	??_C@_09IJIBIDKO@WSAEMFILE@			; `string'
PUBLIC	??_C@_0P@BLDHJENA@WSAEWOULDBLOCK@		; `string'
PUBLIC	??_C@_0P@FHEJEBJC@WSAEINPROGRESS@		; `string'
PUBLIC	??_C@_0M@EAGDEEAC@WSAEALREADY@			; `string'
PUBLIC	??_C@_0M@MDGNMGJ@WSAENOTSOCK@			; `string'
PUBLIC	??_C@_0BA@BLGPIJAD@WSAEDESTADDRREQ@		; `string'
PUBLIC	??_C@_0M@PJKLHKI@WSAEMSGSIZE@			; `string'
PUBLIC	??_C@_0O@HCKGAENP@WSAEPROTOTYPE@		; `string'
PUBLIC	??_C@_0P@KODINEND@WSAENOPROTOOPT@		; `string'
PUBLIC	??_C@_0BD@EDJBJFH@WSAEPROTONOSUPPORT@		; `string'
PUBLIC	??_C@_0BD@KNONLHOA@WSAESOCKTNOSUPPORT@		; `string'
PUBLIC	??_C@_0O@IFNEEJHC@WSAEOPNOTSUPP@		; `string'
PUBLIC	??_C@_0BA@KKILJDEG@WSAEPFNOSUPPORT@		; `string'
PUBLIC	??_C@_0BA@DNDGDCNF@WSAEAFNOSUPPORT@		; `string'
PUBLIC	??_C@_0O@OPDDJBEB@WSAEADDRINUSE@		; `string'
PUBLIC	??_C@_0BB@MBBPJMGK@WSAEADDRNOTAVAIL@		; `string'
PUBLIC	??_C@_0M@BMNODHFM@WSAENETDOWN@			; `string'
PUBLIC	??_C@_0P@MMGFNLEA@WSAENETUNREACH@		; `string'
PUBLIC	??_C@_0N@KABONKCJ@WSAENETRESET@			; `string'
PUBLIC	??_C@_0BI@NPIHFCBB@WSWSAECONNABORTEDAEINTR@	; `string'
PUBLIC	??_C@_0O@CIPFFFJE@WSAECONNRESET@		; `string'
PUBLIC	??_C@_0L@OOBBNNPD@WSAENOBUFS@			; `string'
PUBLIC	??_C@_0L@KMBJICHC@WSAEISCONN@			; `string'
PUBLIC	??_C@_0M@BJHJCMPN@WSAENOTCONN@			; `string'
PUBLIC	??_C@_0N@JOJKMOCF@WSAESHUTDOWN@			; `string'
PUBLIC	??_C@_0BA@COKPFEMB@WSAETOOMANYREFS@		; `string'
PUBLIC	??_C@_0N@BJEDIOFA@WSAETIMEDOUT@			; `string'
PUBLIC	??_C@_0BA@ECEEDLKJ@WSAECONNREFUSED@		; `string'
PUBLIC	??_C@_08PGIMLMFD@WSAELOOP@			; `string'
PUBLIC	??_C@_0BA@PCKIJCGI@WSAENAMETOOLONG@		; `string'
PUBLIC	??_C@_0N@NJBKCOKK@WSAEHOSTDOWN@			; `string'
PUBLIC	??_C@_0P@MDJAKAKC@WSASYSNOTREADY@		; `string'
PUBLIC	??_C@_0BD@PKACBPOA@WSAVERNOTSUPPORTED@		; `string'
PUBLIC	??_C@_0BC@CLCHBKPK@WSANOTINITIALISED@		; `string'
PUBLIC	??_C@_0BC@JCJCFNAO@WSAHOST_NOT_FOUND@		; `string'
PUBLIC	??_C@_0N@LHDAEOPK@WSATRY_AGAIN@			; `string'
PUBLIC	??_C@_0P@HLNEBJNJ@WSANO_RECOVERY@		; `string'
PUBLIC	??_C@_0L@CBLHPKCP@WSANO_DATA@			; `string'
PUBLIC	??_C@_08LPKPOPGP@NO?5ERROR@			; `string'
PUBLIC	??_C@_08HAEGGJGF@loopback@			; `string'
PUBLIC	??_C@_0P@EMMOIPDD@?$CFi?4?$CFi?4?$CFi?4?$CFi?3?$CFi@ ; `string'
PUBLIC	??_C@_0M@OPOCDNEK@?$CFi?4?$CFi?4?$CFi?4?$CFi@	; `string'
PUBLIC	??_C@_0CN@JMPIKEJK@?$FO1Error?3?$FO7?5NET_CompareAdr?3?5bad?5@ ; `string'
PUBLIC	??_C@_09IPAEKDAI@localhost@			; `string'
PUBLIC	?__LINE__Var@?0??NET_ClearLaggedList@@9@9	; `NET_ClearLaggedList'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??NET_AddToLagged@@9@9		; `NET_AddToLagged'::`1'::__LINE__Var
PUBLIC	??_C@_0DB@EBBJJPD@Server?5must?5enable?5dev?9mode?5to?5@ ; `string'
PUBLIC	??_C@_07IACANNJD@fakelag@			; `string'
PUBLIC	?__LINE__Var@?0??NET_LagPacket@@9@9		; `NET_LagPacket'::`1'::__LINE__Var
PUBLIC	??_C@_08JGGELEIJ@fakeloss@			; `string'
PUBLIC	??_C@_0CL@BMIMDJDM@?$FO1Error?3?$FO7?5invalid?5split?5packet@ ; `string'
PUBLIC	??_C@_0CM@IPHEAALC@?$FO1Error?3?$FO7?5malformed?5packet?5num@ ; `string'
PUBLIC	??_C@_0CK@PICMNCON@?$DM?9?9?5Split?5packet?5restart?5?$CFi?5cou@ ; `string'
PUBLIC	??_C@_0CM@OMNIKBFE@?$DM?9?9?5Split?5packet?5?$CFi?5of?5?$CFi?0?5?$CFi?5b@ ; `string'
PUBLIC	??_C@_0EF@DBOGKHBM@NET_GetLong?3?5Ignoring?5duplicate@ ; `string'
PUBLIC	??_C@_0CC@NGAPOLMP@Split?5packet?5too?5large?$CB?5?$CFd?5byte@ ; `string'
PUBLIC	??_C@_0CK@NFBIJOL@NET_QueuePacket?3?5oversize?5packe@ ; `string'
PUBLIC	??_C@_0CI@OABGCFFO@?$FO1Error?3?$FO7?5NET_QueuePacket?3?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0CF@NEFJAJAB@NET_SendPacket?3?5bad?5address?5typ@ ; `string'
PUBLIC	??_C@_0CF@PJDCFGMN@?$FO1Error?3?$FO7?5NET_SendPacket?3?5?$CFs?5t@ ; `string'
PUBLIC	??_C@_0BK@DNLMFBPF@NET_SendPacket?3?5?$CFs?5to?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DB@JKCNMEC@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_0DI@ILEEFCJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_0EC@ELCMEKON@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_06MJBNDFGP@?9reuse@			; `string'
PUBLIC	??_C@_0EC@PIAILHCL@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_04KDEIHCLE@?9tos@				; `string'
PUBLIC	??_C@_0BO@PJFIIKH@Enabling?5LOWDELAY?5TOS?5option?6@ ; `string'
PUBLIC	??_C@_0DN@KCGHDMFM@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_0CP@MKNFKJJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_09MPGGJNNN@?9loopback@			; `string'
PUBLIC	??_C@_0EG@GJFBOBCN@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ ; `string'
PUBLIC	??_C@_0DA@JJBBAKPD@Couldn?8t?5allocate?5dedicated?5ser@ ; `string'
PUBLIC	??_C@_0DG@BNLJKKDO@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@ ; `string'
PUBLIC	??_C@_0BG@OIJCFNEJ@Server?5IP?5address?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0M@BLBBNKIE@net_address@			; `string'
PUBLIC	??_C@_0EB@POOLBKGA@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@ ; `string'
PUBLIC	??_C@_0BC@DDEHLHOF@TCP?1IP?5Disabled?4?6@	; `string'
PUBLIC	??_C@_0CD@GDFEJLKD@timewindow?5to?5execute?5client?5mo@ ; `string'
PUBLIC	??_C@_03LOHCHBBO@0?45@				; `string'
PUBLIC	??_C@_0M@POCMKHIF@clockwindow@			; `string'
PUBLIC	??_C@_0CI@BEJNDEBJ@contain?5local?5address?5of?5curren@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BD@HCBLJMHF@network?5ip?5address@	; `string'
PUBLIC	??_C@_02GIIHKPLE@ip@				; `string'
PUBLIC	??_C@_0BF@NOMDJBDM@network?5ip?5host?5port@	; `string'
PUBLIC	??_C@_0M@KCBOPDKD@ip_hostport@			; `string'
PUBLIC	??_C@_0BK@KIIKHHFP@network?5default?5host?5port@ ; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi@				; `string'
PUBLIC	??_C@_08DMAEPIMN@hostport@			; `string'
PUBLIC	??_C@_0BH@EABEEOLF@network?5ip?5client?5port@	; `string'
PUBLIC	??_C@_0O@FPHJLNHG@ip_clientport@		; `string'
PUBLIC	??_C@_0BM@EHKNEHNF@network?5default?5client?5port@ ; `string'
PUBLIC	??_C@_0L@DDNFLMMN@clientport@			; `string'
PUBLIC	??_C@_0DO@CDGJDNFN@lag?5all?5incoming?5network?5data?5?$CI@ ; `string'
PUBLIC	??_C@_0DD@JBLMCFNB@act?5like?5we?5dropped?5the?5packet?5@ ; `string'
PUBLIC	??_C@_0DA@DPBCEML@?$FO1Error?3?$FO7?5network?5failed?5to?5lo@ ; `string'
PUBLIC	??_C@_0CL@DHGLFKAH@?$FO1Error?3?$FO7?5network?5initializati@ ; `string'
PUBLIC	??_C@_05NIHBOPJE@?9noip@			; `string'
PUBLIC	??_C@_05HDLOEPOC@?9port@			; `string'
PUBLIC	??_C@_0N@HONPAMOD@?9clockwindow@		; `string'
PUBLIC	??_C@_0BO@KLIIDKPD@Base?5networking?5initialized?4?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@4069000000000000
PUBLIC	__real@40800000
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_LoadLibrary:PROC
EXTRN	_Sys_FreeLibrary:PROC
EXTRN	__Sys_GetParmFromCmdLine:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_LZSS_IsCompressed:PROC
EXTRN	_LZSS_GetActualSize:PROC
EXTRN	_LZSS_Compress:PROC
EXTRN	_LZSS_Decompress:PROC
EXTRN	_fabs:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host_developer:BYTE
EXTRN	_net_showpackets:DWORD
EXTRN	_host:BYTE
EXTRN	_net_from:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_net	DB	01103fcH DUP (?)
_net_ipname DD	01H DUP (?)
_net_hostport DD 01H DUP (?)
_net_iphostport DD 01H DUP (?)
_net_clientport DD 01H DUP (?)
_net_ipclientport DD 01H DUP (?)
_net_fakelag DD	01H DUP (?)
_net_fakeloss DD 01H DUP (?)
_net_address DD	01H DUP (?)
	ALIGN	8

?lasttime@?1??NET_AdjustLag@@9@9 DQ 01H DUP (?)		; `NET_AdjustLag'::`2'::lasttime
?old_config@?1??NET_Config@@9@9 DD 01H DUP (?)		; `NET_Config'::`2'::old_config
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BO@KLIIDKPD@Base?5networking?5initialized?4?6@
CONST	SEGMENT
??_C@_0BO@KLIIDKPD@Base?5networking?5initialized?4?6@ DB 'Base networking'
	DB	' initialized.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HONPAMOD@?9clockwindow@
CONST	SEGMENT
??_C@_0N@HONPAMOD@?9clockwindow@ DB '-clockwindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDLOEPOC@?9port@
CONST	SEGMENT
??_C@_05HDLOEPOC@?9port@ DB '-port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NIHBOPJE@?9noip@
CONST	SEGMENT
??_C@_05NIHBOPJE@?9noip@ DB '-noip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DHGLFKAH@?$FO1Error?3?$FO7?5network?5initializati@
CONST	SEGMENT
??_C@_0CL@DHGLFKAH@?$FO1Error?3?$FO7?5network?5initializati@ DB '^1Error:'
	DB	'^7 network initialization failed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DPBCEML@?$FO1Error?3?$FO7?5network?5failed?5to?5lo@
CONST	SEGMENT
??_C@_0DA@DPBCEML@?$FO1Error?3?$FO7?5network?5failed?5to?5lo@ DB '^1Error'
	DB	':^7 network failed to load wsock32.dll.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JBLMCFNB@act?5like?5we?5dropped?5the?5packet?5@
CONST	SEGMENT
??_C@_0DD@JBLMCFNB@act?5like?5we?5dropped?5the?5packet?5@ DB 'act like we'
	DB	' dropped the packet this % of the time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CDGJDNFN@lag?5all?5incoming?5network?5data?5?$CI@
CONST	SEGMENT
??_C@_0DO@CDGJDNFN@lag?5all?5incoming?5network?5data?5?$CI@ DB 'lag all i'
	DB	'ncoming network data (including loopback) by xxx ms.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DDNFLMMN@clientport@
CONST	SEGMENT
??_C@_0L@DDNFLMMN@clientport@ DB 'clientport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EHKNEHNF@network?5default?5client?5port@
CONST	SEGMENT
??_C@_0BM@EHKNEHNF@network?5default?5client?5port@ DB 'network default cl'
	DB	'ient port', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPHJLNHG@ip_clientport@
CONST	SEGMENT
??_C@_0O@FPHJLNHG@ip_clientport@ DB 'ip_clientport', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EABEEOLF@network?5ip?5client?5port@
CONST	SEGMENT
??_C@_0BH@EABEEOLF@network?5ip?5client?5port@ DB 'network ip client port', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMAEPIMN@hostport@
CONST	SEGMENT
??_C@_08DMAEPIMN@hostport@ DB 'hostport', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KIIKHHFP@network?5default?5host?5port@
CONST	SEGMENT
??_C@_0BK@KIIKHHFP@network?5default?5host?5port@ DB 'network default host'
	DB	' port', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KCBOPDKD@ip_hostport@
CONST	SEGMENT
??_C@_0M@KCBOPDKD@ip_hostport@ DB 'ip_hostport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NOMDJBDM@network?5ip?5host?5port@
CONST	SEGMENT
??_C@_0BF@NOMDJBDM@network?5ip?5host?5port@ DB 'network ip host port', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIIHKPLE@ip@
CONST	SEGMENT
??_C@_02GIIHKPLE@ip@ DB 'ip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCBLJMHF@network?5ip?5address@
CONST	SEGMENT
??_C@_0BD@HCBLJMHF@network?5ip?5address@ DB 'network ip address', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BEJNDEBJ@contain?5local?5address?5of?5curren@
CONST	SEGMENT
??_C@_0CI@BEJNDEBJ@contain?5local?5address?5of?5curren@ DB 'contain local'
	DB	' address of current client', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POCMKHIF@clockwindow@
CONST	SEGMENT
??_C@_0M@POCMKHIF@clockwindow@ DB 'clockwindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOHCHBBO@0?45@
CONST	SEGMENT
??_C@_03LOHCHBBO@0?45@ DB '0.5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GDFEJLKD@timewindow?5to?5execute?5client?5mo@
CONST	SEGMENT
??_C@_0CD@GDFEJLKD@timewindow?5to?5execute?5client?5mo@ DB 'timewindow to'
	DB	' execute client moves', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?bFirst@?1??NET_Config@@9@9 DD 01H			; `NET_Config'::`2'::bFirst
_DATA	ENDS
;	COMDAT ??_C@_0BC@DDEHLHOF@TCP?1IP?5Disabled?4?6@
CONST	SEGMENT
??_C@_0BC@DDEHLHOF@TCP?1IP?5Disabled?4?6@ DB 'TCP/IP Disabled.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@POOLBKGA@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@
CONST	SEGMENT
??_C@_0EB@POOLBKGA@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@ DB '^1Err'
	DB	'or:^7 Could not get TCP/IP address, Invalid hostname: ''%s''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BLBBNKIE@net_address@
CONST	SEGMENT
??_C@_0M@BLBBNKIE@net_address@ DB 'net_address', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OIJCFNEJ@Server?5IP?5address?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@OIJCFNEJ@Server?5IP?5address?5?$CFs?6@ DB 'Server IP address %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BNLJKKDO@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@
CONST	SEGMENT
??_C@_0DG@BNLJKKDO@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@ DB '^1Err'
	DB	'or:^7 Could not get TCP/IP address. Reason:  %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JJBBAKPD@Couldn?8t?5allocate?5dedicated?5ser@
CONST	SEGMENT
??_C@_0DA@JJBBAKPD@Couldn?8t?5allocate?5dedicated?5ser@ DB 'Couldn''t all'
	DB	'ocate dedicated server IP port %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GJFBOBCN@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0EG@GJFBOBCN@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port %d setsockopt IP_MULTICAST_LOOP: %s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09MPGGJNNN@?9loopback@
CONST	SEGMENT
??_C@_09MPGGJNNN@?9loopback@ DB '-loopback', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MKNFKJJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0CP@MKNFKJJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port: %d bind: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KCGHDMFM@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0DN@KCGHDMFM@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port: %d  setsockopt IP_TOS: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PJFIIKH@Enabling?5LOWDELAY?5TOS?5option?6@
CONST	SEGMENT
??_C@_0BO@PJFIIKH@Enabling?5LOWDELAY?5TOS?5option?6@ DB 'Enabling LOWDELA'
	DB	'Y TOS option', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDEIHCLE@?9tos@
CONST	SEGMENT
??_C@_04KDEIHCLE@?9tos@ DB '-tos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@PIAILHCL@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0EC@PIAILHCL@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port: %d setsockopt SO_REUSEADDR: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJBNDFGP@?9reuse@
CONST	SEGMENT
??_C@_06MJBNDFGP@?9reuse@ DB '-reuse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@ELCMEKON@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0EC@ELCMEKON@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port: %d setsockopt SO_BROADCAST: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@ILEEFCJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0DI@ILEEFCJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warni'
	DB	'ng:^7 NET_UDPSocket: port: %d ioctl FIONBIO: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JKCNMEC@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
CONST	SEGMENT
??_C@_0DB@JKCNMEC@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@ DB '^3Warnin'
	DB	'g:^7 NET_UDPSocket: port: %d socket: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DNLMFBPF@NET_SendPacket?3?5?$CFs?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@DNLMFBPF@NET_SendPacket?3?5?$CFs?5to?5?$CFs?6@ DB 'NET_SendPack'
	DB	'et: %s to %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PJDCFGMN@?$FO1Error?3?$FO7?5NET_SendPacket?3?5?$CFs?5t@
CONST	SEGMENT
??_C@_0CF@PJDCFGMN@?$FO1Error?3?$FO7?5NET_SendPacket?3?5?$CFs?5t@ DB '^1E'
	DB	'rror:^7 NET_SendPacket: %s to %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NEFJAJAB@NET_SendPacket?3?5bad?5address?5typ@
CONST	SEGMENT
??_C@_0CF@NEFJAJAB@NET_SendPacket?3?5bad?5address?5typ@ DB 'NET_SendPacke'
	DB	't: bad address type %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OABGCFFO@?$FO1Error?3?$FO7?5NET_QueuePacket?3?5?$CFs?5@
CONST	SEGMENT
??_C@_0CI@OABGCFFO@?$FO1Error?3?$FO7?5NET_QueuePacket?3?5?$CFs?5@ DB '^1E'
	DB	'rror:^7 NET_QueuePacket: %s from %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NFBIJOL@NET_QueuePacket?3?5oversize?5packe@
CONST	SEGMENT
??_C@_0CK@NFBIJOL@NET_QueuePacket?3?5oversize?5packe@ DB 'NET_QueuePacket'
	DB	': oversize packet from %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NGAPOLMP@Split?5packet?5too?5large?$CB?5?$CFd?5byte@
CONST	SEGMENT
??_C@_0CC@NGAPOLMP@Split?5packet?5too?5large?$CB?5?$CFd?5byte@ DB 'Split '
	DB	'packet too large! %d bytes', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DBOGKHBM@NET_GetLong?3?5Ignoring?5duplicate@
CONST	SEGMENT
??_C@_0EF@DBOGKHBM@NET_GetLong?3?5Ignoring?5duplicate@ DB 'NET_GetLong: I'
	DB	'gnoring duplicated split packet %i of %i ( %i bytes )', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OMNIKBFE@?$DM?9?9?5Split?5packet?5?$CFi?5of?5?$CFi?0?5?$CFi?5b@
CONST	SEGMENT
??_C@_0CM@OMNIKBFE@?$DM?9?9?5Split?5packet?5?$CFi?5of?5?$CFi?0?5?$CFi?5b@ DB '<'
	DB	'-- Split packet %i of %i, %i bytes %i seq', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PICMNCON@?$DM?9?9?5Split?5packet?5restart?5?$CFi?5cou@
CONST	SEGMENT
??_C@_0CK@PICMNCON@?$DM?9?9?5Split?5packet?5restart?5?$CFi?5cou@ DB '<-- '
	DB	'Split packet restart %i count %i seq', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IPHEAALC@?$FO1Error?3?$FO7?5malformed?5packet?5num@
CONST	SEGMENT
??_C@_0CM@IPHEAALC@?$FO1Error?3?$FO7?5malformed?5packet?5num@ DB '^1Error'
	DB	':^7 malformed packet number (%i/%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BMIMDJDM@?$FO1Error?3?$FO7?5invalid?5split?5packet@
CONST	SEGMENT
??_C@_0CL@BMIMDJDM@?$FO1Error?3?$FO7?5invalid?5split?5packet@ DB '^1Error'
	DB	':^7 invalid split packet length %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JGGELEIJ@fakeloss@
CONST	SEGMENT
??_C@_08JGGELEIJ@fakeloss@ DB 'fakeloss', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NET_LagPacket@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??NET_LagPacket@@9@9 DD 02b2H		; `NET_LagPacket'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07IACANNJD@fakelag@
CONST	SEGMENT
??_C@_07IACANNJD@fakelag@ DB 'fakelag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EBBJJPD@Server?5must?5enable?5dev?9mode?5to?5@
CONST	SEGMENT
??_C@_0DB@EBBJJPD@Server?5must?5enable?5dev?9mode?5to?5@ DB 'Server must '
	DB	'enable dev-mode to activate fakelag', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NET_AddToLagged@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??NET_AddToLagged@@9@9 DD 0271H		; `NET_AddToLagged'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\net_ws.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??NET_ClearLaggedList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??NET_ClearLaggedList@@9@9 DD 0251H	; `NET_ClearLaggedList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost@
CONST	SEGMENT
??_C@_09IPAEKDAI@localhost@ DB 'localhost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JMPIKEJK@?$FO1Error?3?$FO7?5NET_CompareAdr?3?5bad?5@
CONST	SEGMENT
??_C@_0CN@JMPIKEJK@?$FO1Error?3?$FO7?5NET_CompareAdr?3?5bad?5@ DB '^1Erro'
	DB	'r:^7 NET_CompareAdr: bad address type', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPOCDNEK@?$CFi?4?$CFi?4?$CFi?4?$CFi@
CONST	SEGMENT
??_C@_0M@OPOCDNEK@?$CFi?4?$CFi?4?$CFi?4?$CFi@ DB '%i.%i.%i.%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMMOIPDD@?$CFi?4?$CFi?4?$CFi?4?$CFi?3?$CFi@
CONST	SEGMENT
??_C@_0P@EMMOIPDD@?$CFi?4?$CFi?4?$CFi?4?$CFi?3?$CFi@ DB '%i.%i.%i.%i:%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAEGGJGF@loopback@
CONST	SEGMENT
??_C@_08HAEGGJGF@loopback@ DB 'loopback', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPKPOPGP@NO?5ERROR@
CONST	SEGMENT
??_C@_08LPKPOPGP@NO?5ERROR@ DB 'NO ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CBLHPKCP@WSANO_DATA@
CONST	SEGMENT
??_C@_0L@CBLHPKCP@WSANO_DATA@ DB 'WSANO_DATA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLNEBJNJ@WSANO_RECOVERY@
CONST	SEGMENT
??_C@_0P@HLNEBJNJ@WSANO_RECOVERY@ DB 'WSANO_RECOVERY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHDAEOPK@WSATRY_AGAIN@
CONST	SEGMENT
??_C@_0N@LHDAEOPK@WSATRY_AGAIN@ DB 'WSATRY_AGAIN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCJCFNAO@WSAHOST_NOT_FOUND@
CONST	SEGMENT
??_C@_0BC@JCJCFNAO@WSAHOST_NOT_FOUND@ DB 'WSAHOST_NOT_FOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CLCHBKPK@WSANOTINITIALISED@
CONST	SEGMENT
??_C@_0BC@CLCHBKPK@WSANOTINITIALISED@ DB 'WSANOTINITIALISED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PKACBPOA@WSAVERNOTSUPPORTED@
CONST	SEGMENT
??_C@_0BD@PKACBPOA@WSAVERNOTSUPPORTED@ DB 'WSAVERNOTSUPPORTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MDJAKAKC@WSASYSNOTREADY@
CONST	SEGMENT
??_C@_0P@MDJAKAKC@WSASYSNOTREADY@ DB 'WSASYSNOTREADY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NJBKCOKK@WSAEHOSTDOWN@
CONST	SEGMENT
??_C@_0N@NJBKCOKK@WSAEHOSTDOWN@ DB 'WSAEHOSTDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCKIJCGI@WSAENAMETOOLONG@
CONST	SEGMENT
??_C@_0BA@PCKIJCGI@WSAENAMETOOLONG@ DB 'WSAENAMETOOLONG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PGIMLMFD@WSAELOOP@
CONST	SEGMENT
??_C@_08PGIMLMFD@WSAELOOP@ DB 'WSAELOOP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ECEEDLKJ@WSAECONNREFUSED@
CONST	SEGMENT
??_C@_0BA@ECEEDLKJ@WSAECONNREFUSED@ DB 'WSAECONNREFUSED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BJEDIOFA@WSAETIMEDOUT@
CONST	SEGMENT
??_C@_0N@BJEDIOFA@WSAETIMEDOUT@ DB 'WSAETIMEDOUT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@COKPFEMB@WSAETOOMANYREFS@
CONST	SEGMENT
??_C@_0BA@COKPFEMB@WSAETOOMANYREFS@ DB 'WSAETOOMANYREFS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOJKMOCF@WSAESHUTDOWN@
CONST	SEGMENT
??_C@_0N@JOJKMOCF@WSAESHUTDOWN@ DB 'WSAESHUTDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BJHJCMPN@WSAENOTCONN@
CONST	SEGMENT
??_C@_0M@BJHJCMPN@WSAENOTCONN@ DB 'WSAENOTCONN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMBJICHC@WSAEISCONN@
CONST	SEGMENT
??_C@_0L@KMBJICHC@WSAEISCONN@ DB 'WSAEISCONN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOBBNNPD@WSAENOBUFS@
CONST	SEGMENT
??_C@_0L@OOBBNNPD@WSAENOBUFS@ DB 'WSAENOBUFS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIPFFFJE@WSAECONNRESET@
CONST	SEGMENT
??_C@_0O@CIPFFFJE@WSAECONNRESET@ DB 'WSAECONNRESET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NPIHFCBB@WSWSAECONNABORTEDAEINTR@
CONST	SEGMENT
??_C@_0BI@NPIHFCBB@WSWSAECONNABORTEDAEINTR@ DB 'WSWSAECONNABORTEDAEINTR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KABONKCJ@WSAENETRESET@
CONST	SEGMENT
??_C@_0N@KABONKCJ@WSAENETRESET@ DB 'WSAENETRESET', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MMGFNLEA@WSAENETUNREACH@
CONST	SEGMENT
??_C@_0P@MMGFNLEA@WSAENETUNREACH@ DB 'WSAENETUNREACH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMNODHFM@WSAENETDOWN@
CONST	SEGMENT
??_C@_0M@BMNODHFM@WSAENETDOWN@ DB 'WSAENETDOWN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MBBPJMGK@WSAEADDRNOTAVAIL@
CONST	SEGMENT
??_C@_0BB@MBBPJMGK@WSAEADDRNOTAVAIL@ DB 'WSAEADDRNOTAVAIL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPDDJBEB@WSAEADDRINUSE@
CONST	SEGMENT
??_C@_0O@OPDDJBEB@WSAEADDRINUSE@ DB 'WSAEADDRINUSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DNDGDCNF@WSAEAFNOSUPPORT@
CONST	SEGMENT
??_C@_0BA@DNDGDCNF@WSAEAFNOSUPPORT@ DB 'WSAEAFNOSUPPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KKILJDEG@WSAEPFNOSUPPORT@
CONST	SEGMENT
??_C@_0BA@KKILJDEG@WSAEPFNOSUPPORT@ DB 'WSAEPFNOSUPPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFNEEJHC@WSAEOPNOTSUPP@
CONST	SEGMENT
??_C@_0O@IFNEEJHC@WSAEOPNOTSUPP@ DB 'WSAEOPNOTSUPP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNONLHOA@WSAESOCKTNOSUPPORT@
CONST	SEGMENT
??_C@_0BD@KNONLHOA@WSAESOCKTNOSUPPORT@ DB 'WSAESOCKTNOSUPPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EDJBJFH@WSAEPROTONOSUPPORT@
CONST	SEGMENT
??_C@_0BD@EDJBJFH@WSAEPROTONOSUPPORT@ DB 'WSAEPROTONOSUPPORT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KODINEND@WSAENOPROTOOPT@
CONST	SEGMENT
??_C@_0P@KODINEND@WSAENOPROTOOPT@ DB 'WSAENOPROTOOPT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HCKGAENP@WSAEPROTOTYPE@
CONST	SEGMENT
??_C@_0O@HCKGAENP@WSAEPROTOTYPE@ DB 'WSAEPROTOTYPE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJKLHKI@WSAEMSGSIZE@
CONST	SEGMENT
??_C@_0M@PJKLHKI@WSAEMSGSIZE@ DB 'WSAEMSGSIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLGPIJAD@WSAEDESTADDRREQ@
CONST	SEGMENT
??_C@_0BA@BLGPIJAD@WSAEDESTADDRREQ@ DB 'WSAEDESTADDRREQ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDGNMGJ@WSAENOTSOCK@
CONST	SEGMENT
??_C@_0M@MDGNMGJ@WSAENOTSOCK@ DB 'WSAENOTSOCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EAGDEEAC@WSAEALREADY@
CONST	SEGMENT
??_C@_0M@EAGDEEAC@WSAEALREADY@ DB 'WSAEALREADY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHEJEBJC@WSAEINPROGRESS@
CONST	SEGMENT
??_C@_0P@FHEJEBJC@WSAEINPROGRESS@ DB 'WSAEINPROGRESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BLDHJENA@WSAEWOULDBLOCK@
CONST	SEGMENT
??_C@_0P@BLDHJENA@WSAEWOULDBLOCK@ DB 'WSAEWOULDBLOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IJIBIDKO@WSAEMFILE@
CONST	SEGMENT
??_C@_09IJIBIDKO@WSAEMFILE@ DB 'WSAEMFILE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDAAOFKK@WSAEINVAL@
CONST	SEGMENT
??_C@_09PDAAOFKK@WSAEINVAL@ DB 'WSAEINVAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIHAGEEK@WSAEFAULT@
CONST	SEGMENT
??_C@_09BIHAGEEK@WSAEFAULT@ DB 'WSAEFAULT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EEHHIAEC@WSAEDISCON@
CONST	SEGMENT
??_C@_0L@EEHHIAEC@WSAEDISCON@ DB 'WSAEDISCON', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKFHKCJJ@WSAEACCES@
CONST	SEGMENT
??_C@_09EKFHKCJJ@WSAEACCES@ DB 'WSAEACCES', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJKOCPDH@WSAEBADF@
CONST	SEGMENT
??_C@_08LJKOCPDH@WSAEBADF@ DB 'WSAEBADF', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEJFHKFF@WSAEINTR@
CONST	SEGMENT
??_C@_08KEJFHKFF@WSAEINTR@ DB 'WSAEINTR', 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	021cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02b0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0127H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01f7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	07dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02b3H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_GetLocalAddress
_TEXT	SEGMENT
$T1 = -672						; size = 4
$T2 = -668						; size = 4
_namelen$ = -536					; size = 4
_address$ = -532					; size = 16
_buff$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_NET_GetLocalAddress PROC				; COMDAT

; 1267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 672				; 000002a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1268 : 	char		buff[512];
; 1269 : 	struct sockaddr_in	address;
; 1270 : 	int		namelen;
; 1271 : 
; 1272 : 	memset( &net_local, 0, sizeof( netadr_t ));

	push	20					; 00000014H
	push	0
	push	OFFSET _net_local
	call	_memset
	add	esp, 12					; 0000000cH

; 1273 : 	buff[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 512			; 00000200H
	jae	SHORT $LN11@NET_GetLoc
	jmp	SHORT $LN12@NET_GetLoc
$LN11@NET_GetLoc:
	call	___report_rangecheckfailure
$LN12@NET_GetLoc:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0

; 1274 : 
; 1275 : 	if( net.allow_ip )

	cmp	DWORD PTR _net+1115128, 0
	je	$LN2@NET_GetLoc

; 1276 : 	{
; 1277 : 		// If we have changed the ip var from the command line, use that instead.
; 1278 : 		if( Q_strcmp( net_ipname->string, "localhost" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09IPAEKDAI@localhost@
	mov	eax, DWORD PTR _net_ipname
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@NET_GetLoc

; 1279 : 		{
; 1280 : 			Q_strcpy( buff, net_ipname->string );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _net_ipname
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _buff$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1281 : 		}

	jmp	SHORT $LN5@NET_GetLoc
$LN4@NET_GetLoc:

; 1282 : 		else
; 1283 : 		{
; 1284 : 			pGetHostName( buff, 512 );

	push	512					; 00000200H
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	DWORD PTR _pGetHostName
$LN5@NET_GetLoc:

; 1285 : 		}
; 1286 : 
; 1287 : 		// ensure that it doesn't overrun the buffer
; 1288 : 		buff[511] = 0;

	mov	eax, 1
	imul	ecx, eax, 511
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN13@NET_GetLoc
	jmp	SHORT $LN14@NET_GetLoc
$LN13@NET_GetLoc:
	call	___report_rangecheckfailure
$LN14@NET_GetLoc:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0

; 1289 : 
; 1290 : 		if( NET_StringToAdr( buff, &net_local ))

	push	OFFSET _net_local
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_NET_StringToAdr
	add	esp, 8
	test	eax, eax
	je	$LN6@NET_GetLoc

; 1291 : 		{
; 1292 : 			namelen = sizeof( address );

	mov	DWORD PTR _namelen$[ebp], 16		; 00000010H

; 1293 : 
; 1294 : 			if( pGetSockName( net.ip_sockets[NS_SERVER], (struct sockaddr *)&address, &namelen ) == SOCKET_ERROR )

	lea	eax, DWORD PTR _namelen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _address$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _net[edx+1114712]
	push	eax
	call	DWORD PTR _pGetSockName
	cmp	eax, -1
	jne	SHORT $LN8@NET_GetLoc

; 1295 : 			{
; 1296 : 				// this may happens if multiple clients running on single machine
; 1297 : 				Con_DPrintf( S_ERROR "Could not get TCP/IP address. Reason:  %s\n", NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	push	OFFSET ??_C@_0DG@BNLJKKDO@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@
	call	_Con_DPrintf
	add	esp, 8

; 1298 : //				net.allow_ip = false;
; 1299 : 			}

	jmp	$LN9@NET_GetLoc
$LN8@NET_GetLoc:

; 1300 : 			else
; 1301 : 			{
; 1302 : 				net_local.port = address.sin_port;

	mov	ax, WORD PTR _address$[ebp+2]
	mov	WORD PTR _net_local+18, ax

; 1303 : 				Con_Printf( "Server IP address %s\n", NET_AdrToString( net_local ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BG@OIJCFNEJ@Server?5IP?5address?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1304 : 				Cvar_FullSet( "net_address", va( NET_AdrToString( net_local )), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_va
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0M@BLBBNKIE@net_address@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN9@NET_GetLoc:

; 1305 : 			}
; 1306 : 		}

	jmp	SHORT $LN7@NET_GetLoc
$LN6@NET_GetLoc:

; 1307 : 		else
; 1308 : 		{
; 1309 : 			Con_DPrintf( S_ERROR "Could not get TCP/IP address, Invalid hostname: '%s'\n", buff );

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	OFFSET ??_C@_0EB@POOLBKGA@?$FO1Error?3?$FO7?5Could?5not?5get?5TCP?1IP@
	call	_Con_DPrintf
	add	esp, 8
$LN7@NET_GetLoc:

; 1310 : 		}
; 1311 : 	}

	jmp	SHORT $LN10@NET_GetLoc
$LN2@NET_GetLoc:

; 1312 : 	else
; 1313 : 	{
; 1314 : 		Con_Printf( "TCP/IP Disabled.\n" );

	push	OFFSET ??_C@_0BC@DDEHLHOF@TCP?1IP?5Disabled?4?6@
	call	_Con_Printf
	add	esp, 4
$LN10@NET_GetLoc:

; 1315 : 	}
; 1316 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLocalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_OpenIP
_TEXT	SEGMENT
_cl_port$ = -12						; size = 4
_sv_port$ = -8						; size = 4
_port$ = -4						; size = 4
_NET_OpenIP PROC					; COMDAT

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1229 : 	int	port, sv_port = 0, cl_port = 0;

	mov	DWORD PTR _sv_port$[ebp], 0
	mov	DWORD PTR _cl_port$[ebp], 0

; 1230 : 
; 1231 : 	if( net.ip_sockets[NS_SERVER] == INVALID_SOCKET )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114712], -1
	jne	$LN2@NET_OpenIP

; 1232 : 	{
; 1233 : 		port = net_iphostport->value;

	mov	eax, DWORD PTR _net_iphostport
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _port$[ebp], ecx

; 1234 : 		if( !port ) port = net_hostport->value;

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN3@NET_OpenIP
	mov	eax, DWORD PTR _net_hostport
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _port$[ebp], ecx
$LN3@NET_OpenIP:

; 1235 : 		if( !port ) port = PORT_SERVER; // forcing to default

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN4@NET_OpenIP
	mov	DWORD PTR _port$[ebp], 27015		; 00006987H
$LN4@NET_OpenIP:

; 1236 : 		net.ip_sockets[NS_SERVER] = NET_IPSocket( net_ipname->string, port, false );

	push	0
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_ipname
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR _net[ecx+1114712], eax

; 1237 : 
; 1238 : 		if( net.ip_sockets[NS_SERVER] == INVALID_SOCKET && host.type == HOST_DEDICATED )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114712], -1
	jne	SHORT $LN5@NET_OpenIP
	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@NET_OpenIP

; 1239 : 			Host_Error( "Couldn't allocate dedicated server IP port %d.\n", port );

	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@JJBBAKPD@Couldn?8t?5allocate?5dedicated?5ser@
	call	_Host_Error
	add	esp, 8
$LN5@NET_OpenIP:

; 1240 : 		sv_port = port;

	mov	eax, DWORD PTR _port$[ebp]
	mov	DWORD PTR _sv_port$[ebp], eax
$LN2@NET_OpenIP:

; 1241 : 	}
; 1242 : 
; 1243 : 	// dedicated servers don't need client ports
; 1244 : 	if( host.type == HOST_DEDICATED ) return;

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN6@NET_OpenIP
	jmp	$LN7@NET_OpenIP
$LN6@NET_OpenIP:

; 1245 : 
; 1246 : 	if( net.ip_sockets[NS_CLIENT] == INVALID_SOCKET )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _net[ecx+1114712], -1
	jne	$LN7@NET_OpenIP

; 1247 : 	{
; 1248 : 		port = net_ipclientport->value;

	mov	eax, DWORD PTR _net_ipclientport
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _port$[ebp], ecx

; 1249 : 		if( !port ) port = net_clientport->value;

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN8@NET_OpenIP
	mov	eax, DWORD PTR _net_clientport
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _port$[ebp], ecx
$LN8@NET_OpenIP:

; 1250 : 		if( !port ) port = PORT_ANY; // forcing to default

	cmp	DWORD PTR _port$[ebp], 0
	jne	SHORT $LN9@NET_OpenIP
	mov	DWORD PTR _port$[ebp], -1
$LN9@NET_OpenIP:

; 1251 : 		net.ip_sockets[NS_CLIENT] = NET_IPSocket( net_ipname->string, port, false );

	push	0
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_ipname
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _net[edx+1114712], eax

; 1252 : 
; 1253 : 		if( net.ip_sockets[NS_CLIENT] == INVALID_SOCKET )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _net[ecx+1114712], -1
	jne	SHORT $LN10@NET_OpenIP

; 1254 : 			net.ip_sockets[NS_CLIENT] = NET_IPSocket( net_ipname->string, PORT_ANY, false );

	push	0
	push	-1
	mov	eax, DWORD PTR _net_ipname
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_NET_IPSocket
	add	esp, 12					; 0000000cH
	mov	edx, 4
	imul	ecx, edx, 0
	mov	DWORD PTR _net[ecx+1114712], eax
$LN10@NET_OpenIP:

; 1255 : 		cl_port = port;

	mov	eax, DWORD PTR _port$[ebp]
	mov	DWORD PTR _cl_port$[ebp], eax
$LN7@NET_OpenIP:

; 1256 : 	}
; 1257 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_OpenIP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_IPSocket
_TEXT	SEGMENT
_addr$ = -32						; size = 16
_optval$ = -16						; size = 4
_net_socket$ = -12					; size = 4
_err$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_net_interface$ = 8					; size = 4
_port$ = 12						; size = 4
_multicast$ = 16					; size = 4
_NET_IPSocket PROC					; COMDAT

; 1143 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1144 : 	int		err, net_socket;
; 1145 : 	uint		optval = 1;

	mov	DWORD PTR _optval$[ebp], 1

; 1146 : 	struct sockaddr_in	addr;
; 1147 : 
; 1148 : 	if(( net_socket = pSocket( PF_INET, SOCK_DGRAM, IPPROTO_UDP )) == SOCKET_ERROR )

	push	17					; 00000011H
	push	2
	push	2
	call	DWORD PTR _pSocket
	mov	DWORD PTR _net_socket$[ebp], eax
	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN2@NET_IPSock

; 1149 : 	{
; 1150 : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1151 : 		if( err != WSAEAFNOSUPPORT )

	cmp	DWORD PTR _err$[ebp], 10047		; 0000273fH
	je	SHORT $LN3@NET_IPSock

; 1152 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port: %d socket: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@JKCNMEC@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN3@NET_IPSock:

; 1153 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN2@NET_IPSock:

; 1154 : 	}
; 1155 : 
; 1156 : 	if( pIoctlSocket( net_socket, FIONBIO, &optval ) == SOCKET_ERROR )

	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	-2147195266				; 8004667eH
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pIoctlSocket
	cmp	eax, -1
	jne	SHORT $LN4@NET_IPSock

; 1157 : 	{
; 1158 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d ioctl FIONBIO: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@ILEEFCJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1159 : 		pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1160 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN4@NET_IPSock:

; 1161 : 	}
; 1162 : 
; 1163 : 	// make it broadcast capable
; 1164 : 	if( pSetSockopt( net_socket, SOL_SOCKET, SO_BROADCAST, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	32					; 00000020H
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN5@NET_IPSock

; 1165 : 	{
; 1166 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d setsockopt SO_BROADCAST: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@ELCMEKON@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1167 : 		pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1168 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN5@NET_IPSock:

; 1169 : 	}
; 1170 : 
; 1171 : 	if( Sys_CheckParm( "-reuse" ) || multicast )

	push	OFFSET ??_C@_06MJBNDFGP@?9reuse@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@NET_IPSock
	cmp	DWORD PTR _multicast$[ebp], 0
	je	SHORT $LN6@NET_IPSock
$LN7@NET_IPSock:

; 1172 : 	{
; 1173 : 		if( pSetSockopt( net_socket, SOL_SOCKET, SO_REUSEADDR, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	4
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN6@NET_IPSock

; 1174 : 		{
; 1175 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port: %d setsockopt SO_REUSEADDR: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@PIAILHCL@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1176 : 			pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1177 : 			return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN6@NET_IPSock:

; 1178 : 		}
; 1179 : 	}
; 1180 : 
; 1181 : 	if( Sys_CheckParm( "-tos" ))

	push	OFFSET ??_C@_04KDEIHCLE@?9tos@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@NET_IPSock

; 1182 : 	{
; 1183 : 		optval = 16;

	mov	DWORD PTR _optval$[ebp], 16		; 00000010H

; 1184 : 		Con_Printf( "Enabling LOWDELAY TOS option\n" );

	push	OFFSET ??_C@_0BO@PJFIIKH@Enabling?5LOWDELAY?5TOS?5option?6@
	call	_Con_Printf
	add	esp, 4

; 1185 : 
; 1186 : 		if( pSetSockopt( net_socket, IPPROTO_IP, IP_TOS, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	8
	push	0
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN9@NET_IPSock

; 1187 : 		{
; 1188 : 			err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1189 : 			if( err != WSAENOPROTOOPT )

	cmp	DWORD PTR _err$[ebp], 10042		; 0000273aH
	je	SHORT $LN11@NET_IPSock

; 1190 : 				Con_Printf( S_WARN "NET_UDPSocket: port: %d  setsockopt IP_TOS: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@KCGHDMFM@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN11@NET_IPSock:

; 1191 : 			pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1192 : 			return INVALID_SOCKET;

	or	eax, -1
	jmp	$LN1@NET_IPSock
$LN9@NET_IPSock:

; 1193 : 		}
; 1194 : 	}
; 1195 : 
; 1196 : 	if( !net_interface[0] || !Q_stricmp( net_interface, "localhost" ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _net_interface$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN14@NET_IPSock
	push	99999					; 0001869fH
	push	OFFSET ??_C@_09IPAEKDAI@localhost@
	mov	eax, DWORD PTR _net_interface$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@NET_IPSock
$LN14@NET_IPSock:

; 1197 : 		addr.sin_addr.s_addr = INADDR_ANY;

	mov	DWORD PTR _addr$[ebp+4], 0
	jmp	SHORT $LN13@NET_IPSock
$LN12@NET_IPSock:

; 1198 : 	else NET_StringToSockaddr( net_interface, (struct sockaddr *)&addr );

	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_interface$[ebp]
	push	ecx
	call	_NET_StringToSockaddr
	add	esp, 8
$LN13@NET_IPSock:

; 1199 : 
; 1200 : 	if( port == PORT_ANY ) addr.sin_port = 0;

	cmp	DWORD PTR _port$[ebp], -1
	jne	SHORT $LN15@NET_IPSock
	xor	eax, eax
	mov	WORD PTR _addr$[ebp+2], ax
	jmp	SHORT $LN16@NET_IPSock
$LN15@NET_IPSock:

; 1201 : 	else addr.sin_port = pHtons((short)port);

	movzx	eax, WORD PTR _port$[ebp]
	push	eax
	call	DWORD PTR _pHtons
	mov	WORD PTR _addr$[ebp+2], ax
$LN16@NET_IPSock:

; 1202 : 
; 1203 : 	addr.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR _addr$[ebp], ax

; 1204 : 
; 1205 : 	if( pBind( net_socket, (void *)&addr, sizeof( addr )) == SOCKET_ERROR )

	push	16					; 00000010H
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pBind
	cmp	eax, -1
	jne	SHORT $LN17@NET_IPSock

; 1206 : 	{
; 1207 : 		Con_DPrintf( S_WARN "NET_UDPSocket: port: %d bind: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@MKNFKJJA@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1208 : 		pCloseSocket( net_socket );

	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pCloseSocket

; 1209 : 		return INVALID_SOCKET;

	or	eax, -1
	jmp	SHORT $LN1@NET_IPSock
$LN17@NET_IPSock:

; 1210 : 	}
; 1211 : 
; 1212 : 	if( Sys_CheckParm( "-loopback" ))

	push	OFFSET ??_C@_09MPGGJNNN@?9loopback@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@NET_IPSock

; 1213 : 	{
; 1214 : 		optval = 1;

	mov	DWORD PTR _optval$[ebp], 1

; 1215 : 		if( pSetSockopt( net_socket, IPPROTO_IP, IP_MULTICAST_LOOP, (const char *)&optval, sizeof( optval )) == SOCKET_ERROR )

	push	4
	lea	eax, DWORD PTR _optval$[ebp]
	push	eax
	push	4
	push	0
	mov	ecx, DWORD PTR _net_socket$[ebp]
	push	ecx
	call	DWORD PTR _pSetSockopt
	cmp	eax, -1
	jne	SHORT $LN18@NET_IPSock

; 1216 : 			Con_DPrintf( S_WARN "NET_UDPSocket: port %d setsockopt IP_MULTICAST_LOOP: %s\n", port, NET_ErrorString( ));

	call	_NET_ErrorString
	push	eax
	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	push	OFFSET ??_C@_0EG@GJFBOBCN@?$FO3Warning?3?$FO7?5NET_UDPSocket?3?5por@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN18@NET_IPSock:

; 1217 : 	}
; 1218 : 
; 1219 : 	return net_socket;

	mov	eax, DWORD PTR _net_socket$[ebp]
$LN1@NET_IPSock:

; 1220 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IPSocket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_SendLong
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_net_socket$ = 12					; size = 4
_buf$ = 16						; size = 4
_len$ = 20						; size = 4
_flags$ = 24						; size = 4
_to$ = 28						; size = 4
_tolen$ = 32						; size = 4
_NET_SendLong PROC					; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 953  : #ifdef NET_USE_FRAGMENTS
; 954  : 	// do we need to break this packet up?
; 955  : 	if( sock == NS_SERVER && len > MAX_ROUTEABLE_PACKET )
; 956  : 	{
; 957  : 		char		packet[MAX_ROUTEABLE_PACKET];
; 958  : 		int		total_sent, size, packet_count;
; 959  : 		int		ret, packet_number;
; 960  : 		SPLITPACKET	*pPacket;
; 961  : 
; 962  : 		net.sequence_number++;
; 963  : 		if( net.sequence_number <= 0 )
; 964  : 			net.sequence_number = 1;
; 965  : 
; 966  : 		pPacket = (SPLITPACKET *)packet;
; 967  : 		pPacket->sequence_number = net.sequence_number;
; 968  : 		pPacket->net_id = NET_HEADER_SPLITPACKET;
; 969  : 		packet_number = 0;
; 970  : 		total_sent = 0;
; 971  : 		packet_count = (len + SPLIT_SIZE - 1) / SPLIT_SIZE;
; 972  : 
; 973  : 		while( len > 0 )
; 974  : 		{
; 975  : 			size = Q_min( SPLIT_SIZE, len );
; 976  : 			pPacket->packet_id = (packet_number << 8) + packet_count;
; 977  : 			memcpy( packet + sizeof( SPLITPACKET ), buf + ( packet_number * SPLIT_SIZE ), size );
; 978  : 
; 979  : 			if( net_showpackets && net_showpackets->value == 3.0f )
; 980  : 			{
; 981  : 				netadr_t	adr;
; 982  : 
; 983  : 				memset( &adr, 0, sizeof( adr ));
; 984  : 				NET_SockadrToNetadr((struct sockaddr *)to, &adr );
; 985  : 
; 986  : 				Con_Printf( "Sending split %i of %i with %i bytes and seq %i to %s\n",
; 987  : 					packet_number + 1, packet_count, size, net.sequence_number, NET_AdrToString( adr ));
; 988  : 			}
; 989  : 
; 990  : 			ret = pSendTo( net_socket, packet, size + sizeof( SPLITPACKET ), flags, to, tolen );
; 991  : 			if( ret < 0 ) return ret; // error
; 992  : 
; 993  : 			if( ret >= size )
; 994  : 				total_sent += size;
; 995  : 			len -= size;
; 996  : 			packet_number++;
; 997  : 			Sleep( 1 );
; 998  : 		}
; 999  : 
; 1000 : 		return total_sent;
; 1001 : 	}
; 1002 : 	else
; 1003 : #endif
; 1004 : 	{
; 1005 : 		// no fragmenantion for client connection
; 1006 : 		return pSendTo( net_socket, buf, len, flags, to, tolen );

	mov	eax, DWORD PTR _tolen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_socket$[ebp]
	push	edx
	call	DWORD PTR _pSendTo

; 1007 : 	}
; 1008 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SendLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_QueuePacket
_TEXT	SEGMENT
tv129 = -66088						; size = 4
_err$1 = -65572						; size = 4
_addr$ = -65568						; size = 16
_addr_len$ = -65552					; size = 4
_net_socket$ = -65548					; size = 4
_ret$ = -65544						; size = 4
_buf$ = -65540						; size = 65536
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_QueuePacket PROC					; COMDAT

; 859  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 66088				; 00010228H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 860  : 	byte		buf[NET_MAX_FRAGMENT];
; 861  : 	int		ret = SOCKET_ERROR;

	mov	DWORD PTR _ret$[ebp], -1

; 862  : 	int		net_socket;
; 863  : 	int		addr_len;
; 864  : 	struct sockaddr	addr;
; 865  : 
; 866  : 	*length = 0;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 867  : 
; 868  : 	net_socket = net.ip_sockets[sock];

	mov	eax, DWORD PTR _sock$[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1114712]
	mov	DWORD PTR _net_socket$[ebp], ecx

; 869  : 
; 870  : 	if( net_socket != INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	je	$LN4@NET_QueueP

; 871  : 	{
; 872  : 		addr_len = sizeof( addr );

	mov	DWORD PTR _addr_len$[ebp], 16		; 00000010H

; 873  : 		ret = pRecvFrom( net_socket, buf, sizeof( buf ), 0, (struct sockaddr *)&addr, &addr_len );

	lea	eax, DWORD PTR _addr_len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	push	0
	push	65536					; 00010000H
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	call	DWORD PTR _pRecvFrom
	mov	DWORD PTR _ret$[ebp], eax

; 874  : 
; 875  : 		if( ret != SOCKET_ERROR )

	cmp	DWORD PTR _ret$[ebp], -1
	je	$LN5@NET_QueueP

; 876  : 		{
; 877  : 			NET_SockadrToNetadr( &addr, from );

	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	lea	ecx, DWORD PTR _addr$[ebp]
	push	ecx
	call	_NET_SockadrToNetadr
	add	esp, 8

; 878  : 
; 879  : 			if( ret < NET_MAX_FRAGMENT )

	cmp	DWORD PTR _ret$[ebp], 65536		; 00010000H
	jge	SHORT $LN7@NET_QueueP

; 880  : 			{
; 881  : 				// Transfer data
; 882  : 				memcpy( data, buf, ret );

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 883  : 				*length = ret;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx

; 884  : 
; 885  : 				// check for split message
; 886  : 				if( *(int *)data == NET_HEADER_SPLITPACKET )

	mov	eax, DWORD PTR _data$[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN9@NET_QueueP

; 887  : 				{
; 888  : 					return NET_GetLong( data, ret, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ret$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_NET_GetLong
	add	esp, 12					; 0000000cH
	jmp	$LN1@NET_QueueP
$LN9@NET_QueueP:

; 889  : 				}
; 890  : 
; 891  : 				// lag the packet, if needed
; 892  : 				return NET_LagPacket( true, sock, from, length, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	push	1
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
	jmp	$LN1@NET_QueueP

; 893  : 			}

	jmp	SHORT $LN8@NET_QueueP
$LN7@NET_QueueP:

; 894  : 			else
; 895  : 			{
; 896  : 				Con_Reportf( "NET_QueuePacket: oversize packet from %s\n", NET_AdrToString( *from ));

	mov	eax, DWORD PTR _from$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CK@NFBIJOL@NET_QueuePacket?3?5oversize?5packe@
	call	_Con_Reportf
	add	esp, 8
$LN8@NET_QueueP:

; 897  : 			}
; 898  : 		}

	jmp	$LN4@NET_QueueP
$LN5@NET_QueueP:

; 899  : 		else
; 900  : 		{
; 901  : 			int	err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$1[ebp], eax

; 902  : 
; 903  : 			switch( err )

	mov	eax, DWORD PTR _err$1[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	sub	ecx, 10035				; 00002733H
	mov	DWORD PTR tv129[ebp], ecx
	cmp	DWORD PTR tv129[ebp], 26		; 0000001aH
	ja	SHORT $LN14@NET_QueueP
	mov	edx, DWORD PTR tv129[ebp]
	movzx	eax, BYTE PTR $LN16@NET_QueueP[edx]
	jmp	DWORD PTR $LN17@NET_QueueP[eax*4]
$LN13@NET_QueueP:

; 904  : 			{
; 905  : 			case WSAEWOULDBLOCK:
; 906  : 			case WSAECONNRESET:
; 907  : 			case WSAECONNREFUSED:
; 908  : 			case WSAEMSGSIZE:
; 909  : 				break;

	jmp	SHORT $LN4@NET_QueueP
$LN14@NET_QueueP:

; 910  : 			default:	// let's continue even after errors
; 911  : 				Con_DPrintf( S_ERROR "NET_QueuePacket: %s from %s\n", NET_ErrorString(), NET_AdrToString( *from ));

	mov	eax, DWORD PTR _from$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET ??_C@_0CI@OABGCFFO@?$FO1Error?3?$FO7?5NET_QueuePacket?3?5?$CFs?5@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN4@NET_QueueP:

; 912  : 				break;
; 913  : 			}
; 914  : 		}
; 915  : 	}
; 916  : 
; 917  : 	return NET_LagPacket( false, sock, from, length, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	push	0
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
$LN1@NET_QueueP:

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@NET_QueueP:
	DD	$LN13@NET_QueueP
	DD	$LN14@NET_QueueP
$LN16@NET_QueueP:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_NET_QueuePacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_GetLong
_TEXT	SEGMENT
_packet_id$ = -28					; size = 2
_packet_count$ = -24					; size = 4
_packet_number$ = -20					; size = 4
_pHeader$ = -16						; size = 4
_offset$ = -12						; size = 4
_sequence_number$ = -8					; size = 4
_i$ = -4						; size = 4
_pData$ = 8						; size = 4
_size$ = 12						; size = 4
_outSize$ = 16						; size = 4
_NET_GetLong PROC					; COMDAT

; 772  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 773  : 	int		i, sequence_number, offset;
; 774  : 	SPLITPACKET	*pHeader = (SPLITPACKET *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pHeader$[ebp], eax

; 775  : 	int		packet_number;
; 776  : 	int		packet_count;
; 777  : 	short		packet_id;
; 778  : 
; 779  : 	if( size < sizeof( SPLITPACKET ))

	cmp	DWORD PTR _size$[ebp], 10		; 0000000aH
	jae	SHORT $LN5@NET_GetLon

; 780  : 	{
; 781  : 		Con_Printf( S_ERROR "invalid split packet length %i\n", size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@BMIMDJDM@?$FO1Error?3?$FO7?5invalid?5split?5packet@
	call	_Con_Printf
	add	esp, 8

; 782  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLon
$LN5@NET_GetLon:

; 783  : 	}
; 784  : 
; 785  : 	sequence_number = pHeader->sequence_number;

	mov	eax, DWORD PTR _pHeader$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _sequence_number$[ebp], ecx

; 786  : 	packet_id = pHeader->packet_id;

	mov	eax, DWORD PTR _pHeader$[ebp]
	mov	cx, WORD PTR [eax+8]
	mov	WORD PTR _packet_id$[ebp], cx

; 787  : 	packet_count = ( packet_id & 0xFF );

	movsx	eax, WORD PTR _packet_id$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _packet_count$[ebp], eax

; 788  : 	packet_number = ( packet_id >> 8 );

	movsx	eax, WORD PTR _packet_id$[ebp]
	sar	eax, 8
	mov	DWORD PTR _packet_number$[ebp], eax

; 789  : 
; 790  : 	if( packet_number >= NET_MAX_FRAGMENTS || packet_count > NET_MAX_FRAGMENTS )

	cmp	DWORD PTR _packet_number$[ebp], 47	; 0000002fH
	jae	SHORT $LN7@NET_GetLon
	cmp	DWORD PTR _packet_count$[ebp], 47	; 0000002fH
	jbe	SHORT $LN6@NET_GetLon
$LN7@NET_GetLon:

; 791  : 	{
; 792  : 		Con_Printf( S_ERROR "malformed packet number (%i/%i)\n", packet_number + 1, packet_count );

	mov	eax, DWORD PTR _packet_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet_number$[ebp]
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0CM@IPHEAALC@?$FO1Error?3?$FO7?5malformed?5packet?5num@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 793  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLon
$LN6@NET_GetLon:

; 794  : 	}
; 795  : 
; 796  : 	if( net.split.current_sequence == -1 || sequence_number != net.split.current_sequence )

	cmp	DWORD PTR _net+1048972, -1
	je	SHORT $LN9@NET_GetLon
	mov	eax, DWORD PTR _sequence_number$[ebp]
	cmp	eax, DWORD PTR _net+1048972
	je	SHORT $LN10@NET_GetLon
$LN9@NET_GetLon:

; 797  : 	{
; 798  : 		net.split.current_sequence = sequence_number;

	mov	eax, DWORD PTR _sequence_number$[ebp]
	mov	DWORD PTR _net+1048972, eax

; 799  : 		net.split.split_count = packet_count;

	mov	eax, DWORD PTR _packet_count$[ebp]
	mov	DWORD PTR _net+1048976, eax

; 800  : 		net.split.total_size = 0;

	mov	DWORD PTR _net+1048980, 0

; 801  : 
; 802  : 		// clear part's sequence
; 803  : 		for( i = 0; i < NET_MAX_FRAGMENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NET_GetLon
$LN2@NET_GetLon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NET_GetLon:
	cmp	DWORD PTR _i$[ebp], 47			; 0000002fH
	jae	SHORT $LN3@NET_GetLon

; 804  : 			net.split_flags[i] = -1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _net[eax*4+1114520], -1
	jmp	SHORT $LN2@NET_GetLon
$LN3@NET_GetLon:

; 805  : 
; 806  : 		if( net_showpackets && net_showpackets->value == 4.0f )

	cmp	DWORD PTR _net_showpackets, 0
	je	SHORT $LN10@NET_GetLon
	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@NET_GetLon

; 807  : 			Con_Printf( "<-- Split packet restart %i count %i seq\n", net.split.split_count, sequence_number );

	mov	eax, DWORD PTR _sequence_number$[ebp]
	push	eax
	mov	ecx, DWORD PTR _net+1048976
	push	ecx
	push	OFFSET ??_C@_0CK@PICMNCON@?$DM?9?9?5Split?5packet?5restart?5?$CFi?5cou@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN10@NET_GetLon:

; 808  : 	}
; 809  : 
; 810  : 	size -= sizeof( SPLITPACKET );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR _size$[ebp], eax

; 811  : 
; 812  : 	if( net.split_flags[packet_number] != sequence_number )

	mov	eax, DWORD PTR _packet_number$[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1114520]
	cmp	ecx, DWORD PTR _sequence_number$[ebp]
	je	SHORT $LN11@NET_GetLon

; 813  : 	{
; 814  : 		if( packet_number == ( packet_count - 1 ))

	mov	eax, DWORD PTR _packet_count$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _packet_number$[ebp], eax
	jne	SHORT $LN13@NET_GetLon

; 815  : 			net.split.total_size = size + SPLIT_SIZE * ( packet_count - 1 );

	mov	eax, DWORD PTR _packet_count$[ebp]
	sub	eax, 1
	imul	ecx, eax, 1390
	add	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _net+1048980, ecx
$LN13@NET_GetLon:

; 816  : 
; 817  : 		net.split.split_count--;

	mov	eax, DWORD PTR _net+1048976
	sub	eax, 1
	mov	DWORD PTR _net+1048976, eax

; 818  : 		net.split_flags[packet_number] = sequence_number;

	mov	eax, DWORD PTR _packet_number$[ebp]
	mov	ecx, DWORD PTR _sequence_number$[ebp]
	mov	DWORD PTR _net[eax*4+1114520], ecx

; 819  : 
; 820  : 		if( net_showpackets && net_showpackets->value == 4.0f )

	cmp	DWORD PTR _net_showpackets, 0
	je	SHORT $LN14@NET_GetLon
	mov	eax, DWORD PTR _net_showpackets
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@NET_GetLon

; 821  : 			Con_Printf( "<-- Split packet %i of %i, %i bytes %i seq\n", packet_number + 1, packet_count, size, sequence_number );

	mov	eax, DWORD PTR _sequence_number$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _packet_number$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0CM@OMNIKBFE@?$DM?9?9?5Split?5packet?5?$CFi?5of?5?$CFi?0?5?$CFi?5b@
	call	_Con_Printf
	add	esp, 20					; 00000014H
$LN14@NET_GetLon:

; 822  : 	}

	jmp	SHORT $LN12@NET_GetLon
$LN11@NET_GetLon:

; 823  : 	else
; 824  : 	{
; 825  : 		Con_DPrintf( "NET_GetLong: Ignoring duplicated split packet %i of %i ( %i bytes )\n", packet_number + 1, packet_count, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet_number$[ebp]
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_0EF@DBOGKHBM@NET_GetLong?3?5Ignoring?5duplicate@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN12@NET_GetLon:

; 826  : 	}
; 827  : 
; 828  : 	offset = (packet_number * SPLIT_SIZE);

	imul	eax, DWORD PTR _packet_number$[ebp], 1390
	mov	DWORD PTR _offset$[ebp], eax

; 829  : 	memcpy( net.split.buffer + offset, pData + sizeof( SPLITPACKET ), size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, OFFSET _net+1048984
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 830  : 
; 831  : 	// have we received all of the pieces to the packet?
; 832  : 	if( net.split.split_count <= 0 )

	cmp	DWORD PTR _net+1048976, 0
	jg	SHORT $LN15@NET_GetLon

; 833  : 	{
; 834  : 		net.split.current_sequence = -1; // Clear packet

	mov	DWORD PTR _net+1048972, -1

; 835  : 
; 836  : 		if( net.split.total_size > sizeof( net.split.buffer ))

	cmp	DWORD PTR _net+1048980, 65536		; 00010000H
	jbe	SHORT $LN16@NET_GetLon

; 837  : 		{
; 838  : 			Con_Printf( "Split packet too large! %d bytes\n", net.split.total_size );

	mov	eax, DWORD PTR _net+1048980
	push	eax
	push	OFFSET ??_C@_0CC@NGAPOLMP@Split?5packet?5too?5large?$CB?5?$CFd?5byte@
	call	_Con_Printf
	add	esp, 8

; 839  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_GetLon
$LN16@NET_GetLon:

; 840  : 		}
; 841  : 
; 842  : 		memcpy( pData, net.split.buffer, net.split.total_size );

	mov	eax, DWORD PTR _net+1048980
	push	eax
	push	OFFSET _net+1048984
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 843  : 		*outSize = net.split.total_size;

	mov	eax, DWORD PTR _outSize$[ebp]
	mov	ecx, DWORD PTR _net+1048980
	mov	DWORD PTR [eax], ecx

; 844  : 
; 845  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_GetLon
$LN15@NET_GetLon:

; 846  : 	}
; 847  : 
; 848  : 	return false;

	xor	eax, eax
$LN1@NET_GetLon:

; 849  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_LagPacket
_TEXT	SEGMENT
_curtime$ = -16						; size = 4
_ninterval$ = -12					; size = 4
_pPacket$ = -8						; size = 4
_pNewPacketLag$ = -4					; size = 4
_newdata$ = 8						; size = 4
_sock$ = 12						; size = 4
_from$ = 16						; size = 4
_length$ = 20						; size = 4
_data$ = 24						; size = 4
_NET_LagPacket PROC					; COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 691  : 	packetlag_t	*pNewPacketLag;
; 692  : 	packetlag_t	*pPacket;
; 693  : 	int		ninterval;
; 694  : 	float		curtime;
; 695  : 
; 696  : 	if( net.fakelag <= 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _net+1048968
	jb	SHORT $LN4@NET_LagPac

; 697  : 	{
; 698  : 		NET_ClearLagData( true, true );

	push	1
	push	1
	call	_NET_ClearLagData
	add	esp, 8

; 699  : 		return newdata;

	mov	eax, DWORD PTR _newdata$[ebp]
	jmp	$LN1@NET_LagPac
$LN4@NET_LagPac:

; 700  : 	}
; 701  : 
; 702  : 	curtime = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _curtime$[ebp], xmm0

; 703  : 
; 704  : 	if( newdata )

	cmp	DWORD PTR _newdata$[ebp], 0
	je	$LN5@NET_LagPac

; 705  : 	{
; 706  : 		if( net_fakeloss->value != 0.0f )

	mov	eax, DWORD PTR _net_fakeloss
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@NET_LagPac

; 707  : 		{
; 708  : 			if( host_developer.value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@NET_LagPac

; 709  : 			{
; 710  : 				net.losscount[sock]++;

	mov	eax, DWORD PTR _sock$[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1048960]
	add	ecx, 1
	mov	edx, DWORD PTR _sock$[ebp]
	mov	DWORD PTR _net[edx*4+1048960], ecx

; 711  : 				if( net_fakeloss->value <= 0.0f )

	mov	eax, DWORD PTR _net_fakeloss
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jb	SHORT $LN9@NET_LagPac

; 712  : 				{
; 713  : 					ninterval = fabs( net_fakeloss->value );

	mov	eax, DWORD PTR _net_fakeloss
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _ninterval$[ebp], eax

; 714  : 					if( ninterval < 2 ) ninterval = 2;

	cmp	DWORD PTR _ninterval$[ebp], 2
	jge	SHORT $LN11@NET_LagPac
	mov	DWORD PTR _ninterval$[ebp], 2
$LN11@NET_LagPac:

; 715  : 
; 716  : 					if(( net.losscount[sock] % ninterval ) == 0 )

	mov	eax, DWORD PTR _sock$[ebp]
	mov	eax, DWORD PTR _net[eax*4+1048960]
	cdq
	idiv	DWORD PTR _ninterval$[ebp]
	test	edx, edx
	jne	SHORT $LN12@NET_LagPac

; 717  : 						return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN12@NET_LagPac:

; 718  : 				}

	jmp	SHORT $LN13@NET_LagPac
$LN9@NET_LagPac:

; 719  : 				else
; 720  : 				{
; 721  : 					if( COM_RandomLong( 0, 100 ) <= net_fakeloss->value )

	push	100					; 00000064H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	eax, DWORD PTR _net_fakeloss
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jb	SHORT $LN13@NET_LagPac

; 722  : 						return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN13@NET_LagPac:

; 723  : 				}
; 724  : 			}

	jmp	SHORT $LN8@NET_LagPac
$LN7@NET_LagPac:

; 725  : 			else
; 726  : 			{
; 727  : 				Cvar_SetValue( "fakeloss", 0.0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08JGGELEIJ@fakeloss@
	call	_Cvar_SetValue
	add	esp, 8
$LN8@NET_LagPac:

; 728  : 			}
; 729  : 		}
; 730  : 
; 731  : 		pNewPacketLag = (packetlag_t *)Z_Malloc( sizeof( packetlag_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_LagPacket@@9@9
	add	eax, 41					; 00000029H
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	40					; 00000028H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pNewPacketLag$[ebp], eax

; 732  : 		// queue packet to simulate fake lag
; 733  : 		NET_AddToLagged( sock, &net.lagdata[sock], pNewPacketLag, from, *length, data, curtime );

	push	ecx
	movss	xmm0, DWORD PTR _curtime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewPacketLag$[ebp]
	push	ecx
	imul	edx, DWORD PTR _sock$[ebp], 40
	add	edx, OFFSET _net+1048880
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_NET_AddToLagged
	add	esp, 28					; 0000001cH
$LN5@NET_LagPac:

; 734  : 	}
; 735  : 
; 736  : 	pPacket = net.lagdata[sock].next;

	imul	eax, DWORD PTR _sock$[ebp], 40
	mov	ecx, DWORD PTR _net[eax+1048912]
	mov	DWORD PTR _pPacket$[ebp], ecx
$LN2@NET_LagPac:

; 737  : 
; 738  : 	while( pPacket != &net.lagdata[sock] )

	imul	eax, DWORD PTR _sock$[ebp], 40
	add	eax, OFFSET _net+1048880
	cmp	DWORD PTR _pPacket$[ebp], eax
	je	SHORT $LN3@NET_LagPac

; 739  : 	{
; 740  : 		if( pPacket->receivedtime <= curtime - ( net.fakelag / 1000.0 ))

	mov	eax, DWORD PTR _pPacket$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+28]
	cvtss2sd xmm1, DWORD PTR _curtime$[ebp]
	cvtss2sd xmm2, DWORD PTR _net+1048968
	divsd	xmm2, QWORD PTR __real@408f400000000000
	subsd	xmm1, xmm2
	comisd	xmm1, xmm0
	jb	SHORT $LN14@NET_LagPac

; 741  : 			break;

	jmp	SHORT $LN3@NET_LagPac
$LN14@NET_LagPac:

; 742  : 
; 743  : 		pPacket = pPacket->next;

	mov	eax, DWORD PTR _pPacket$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _pPacket$[ebp], ecx

; 744  : 	}

	jmp	SHORT $LN2@NET_LagPac
$LN3@NET_LagPac:

; 745  : 
; 746  : 	if( pPacket == &net.lagdata[sock] )

	imul	eax, DWORD PTR _sock$[ebp], 40
	add	eax, OFFSET _net+1048880
	cmp	DWORD PTR _pPacket$[ebp], eax
	jne	SHORT $LN15@NET_LagPac

; 747  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_LagPac
$LN15@NET_LagPac:

; 748  : 
; 749  : 	NET_RemoveFromPacketList( pPacket );

	mov	eax, DWORD PTR _pPacket$[ebp]
	push	eax
	call	_NET_RemoveFromPacketList
	add	esp, 4

; 750  : 
; 751  : 	// delivery packet from fake lag queue
; 752  : 	memcpy( data, pPacket->data, pPacket->size );

	mov	eax, DWORD PTR _pPacket$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pPacket$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 753  : 	memcpy( &net_from, &pPacket->from, sizeof( netadr_t ));

	push	20					; 00000014H
	mov	eax, DWORD PTR _pPacket$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET _net_from
	call	_memcpy
	add	esp, 12					; 0000000cH

; 754  : 	*length = pPacket->size;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _pPacket$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 755  : 
; 756  : 	if( pPacket->data )

	mov	eax, DWORD PTR _pPacket$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@NET_LagPac

; 757  : 		Mem_Free( pPacket->data );

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_LagPacket@@9@9
	add	eax, 67					; 00000043H
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pPacket$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN16@NET_LagPac:

; 758  : 
; 759  : 	Mem_Free( pPacket );

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_LagPacket@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pPacket$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 760  : 
; 761  : 	return TRUE;

	mov	eax, 1
$LN1@NET_LagPac:

; 762  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_LagPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_AdjustLag
_TEXT	SEGMENT
tv68 = -96						; size = 8
tv155 = -88						; size = 8
tv67 = -88						; size = 8
_dt$ = -16						; size = 8
_converge$ = -8						; size = 4
_diff$ = -4						; size = 4
_NET_AdjustLag PROC					; COMDAT

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 653  : 	static double	lasttime = 0.0;
; 654  : 	float		diff, converge;
; 655  : 	double		dt;
; 656  : 
; 657  : 	dt = host.realtime - lasttime;

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR ?lasttime@?1??NET_AdjustLag@@9@9
	movsd	QWORD PTR _dt$[ebp], xmm0

; 658  : 	dt = bound( 0.0, dt, 0.1 );

	movsd	xmm0, QWORD PTR _dt$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN11@NET_Adjust
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	comisd	xmm0, QWORD PTR _dt$[ebp]
	jbe	SHORT $LN9@NET_Adjust
	movsd	xmm0, QWORD PTR _dt$[ebp]
	movsd	QWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN10@NET_Adjust
$LN9@NET_Adjust:
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	movsd	QWORD PTR tv67[ebp], xmm0
$LN10@NET_Adjust:
	movsd	xmm0, QWORD PTR tv67[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN12@NET_Adjust
$LN11@NET_Adjust:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv68[ebp], xmm0
$LN12@NET_Adjust:
	movsd	xmm0, QWORD PTR tv68[ebp]
	movsd	QWORD PTR _dt$[ebp], xmm0

; 659  : 	lasttime = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR ?lasttime@?1??NET_AdjustLag@@9@9, xmm0

; 660  : 
; 661  : 	if( host_developer.value || !net_fakelag->value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@NET_Adjust
	mov	eax, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN2@NET_Adjust
$LN4@NET_Adjust:

; 662  : 	{
; 663  : 		if( net_fakelag->value != net.fakelag )

	mov	eax, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR _net+1048968
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@NET_Adjust

; 664  : 		{
; 665  : 			diff = net_fakelag->value - net.fakelag;

	mov	eax, DWORD PTR _net_fakelag
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR _net+1048968
	movss	DWORD PTR _diff$[ebp], xmm0

; 666  : 			converge = dt * 200.0f;

	movsd	xmm0, QWORD PTR _dt$[ebp]
	mulsd	xmm0, QWORD PTR __real@4069000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _converge$[ebp], xmm0

; 667  : 			if( fabs( diff ) < converge )

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv155[ebp]
	cvtss2sd xmm0, DWORD PTR _converge$[ebp]
	comisd	xmm0, QWORD PTR tv155[ebp]
	jbe	SHORT $LN6@NET_Adjust

; 668  : 				converge = fabs( diff );

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _converge$[ebp]
$LN6@NET_Adjust:

; 669  : 			if( diff < 0.0 )

	cvtss2sd xmm0, DWORD PTR _diff$[ebp]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@NET_Adjust

; 670  : 				converge = -converge;

	movss	xmm0, DWORD PTR _converge$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _converge$[ebp], xmm0
$LN7@NET_Adjust:

; 671  : 			net.fakelag += converge;

	movss	xmm0, DWORD PTR _net+1048968
	addss	xmm0, DWORD PTR _converge$[ebp]
	movss	DWORD PTR _net+1048968, xmm0
$LN5@NET_Adjust:

; 672  : 		}
; 673  : 	}

	jmp	SHORT $LN3@NET_Adjust
$LN2@NET_Adjust:

; 674  : 	else
; 675  : 	{
; 676  : 		Con_Printf( "Server must enable dev-mode to activate fakelag\n" );

	push	OFFSET ??_C@_0DB@EBBJJPD@Server?5must?5enable?5dev?9mode?5to?5@
	call	_Con_Printf
	add	esp, 4

; 677  : 		Cvar_SetValue( "fakelag", 0.0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_07IACANNJD@fakelag@
	call	_Cvar_SetValue
	add	esp, 8

; 678  : 		net.fakelag = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _net+1048968, xmm0
$LN3@NET_Adjust:

; 679  : 	}
; 680  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_AdjustLag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_AddToLagged
_TEXT	SEGMENT
_pStart$ = -4						; size = 4
_sock$ = 8						; size = 4
_list$ = 12						; size = 4
_packet$ = 16						; size = 4
_from$ = 20						; size = 4
_length$ = 24						; size = 4
_data$ = 28						; size = 4
_timestamp$ = 32					; size = 4
_NET_AddToLagged PROC					; COMDAT

; 625  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 626  : 	byte	*pStart;
; 627  : 
; 628  : 	if( packet->prev || packet->next )

	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN3@NET_AddToL
	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN2@NET_AddToL
$LN3@NET_AddToL:

; 629  : 		return;

	jmp	$LN1@NET_AddToL
$LN2@NET_AddToL:

; 630  : 
; 631  : 	packet->prev = list->prev;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx

; 632  : 	list->prev->next = packet;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 633  : 	list->prev = packet;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 634  : 	packet->next = list;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 635  : 
; 636  : 	pStart = (byte *)Z_Malloc( length );

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_AddToLagged@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pStart$[ebp], eax

; 637  : 	memcpy( pStart, data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStart$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 638  : 	packet->data = pStart;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _pStart$[ebp]
	mov	DWORD PTR [eax], ecx

; 639  : 	packet->size = length;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 640  : 	packet->receivedtime = timestamp;

	mov	eax, DWORD PTR _packet$[ebp]
	movss	xmm0, DWORD PTR _timestamp$[ebp]
	movss	DWORD PTR [eax+28], xmm0

; 641  : 	memcpy( &packet->from, from, sizeof( netadr_t ));

	push	20					; 00000014H
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@NET_AddToL:

; 642  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_AddToLagged ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_ClearLaggedList
_TEXT	SEGMENT
_n$ = -8						; size = 4
_p$ = -4						; size = 4
_list$ = 8						; size = 4
_NET_ClearLaggedList PROC				; COMDAT

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 594  : 	packetlag_t	*p, *n;
; 595  : 
; 596  : 	p = list->next;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _p$[ebp], ecx
$LN2@NET_ClearL:

; 597  : 	while( p && p != list )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@NET_ClearL
	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _list$[ebp]
	je	SHORT $LN3@NET_ClearL

; 598  : 	{
; 599  : 		n = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _n$[ebp], ecx

; 600  : 
; 601  : 		NET_RemoveFromPacketList( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_NET_RemoveFromPacketList
	add	esp, 4

; 602  : 
; 603  : 		if( p->data )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@NET_ClearL

; 604  : 		{
; 605  : 			Mem_Free( p->data );

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_ClearLaggedList@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 606  : 			p->data = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@NET_ClearL:

; 607  : 		}
; 608  : 
; 609  : 		Mem_Free( p );

	mov	eax, DWORD PTR ?__LINE__Var@?0??NET_ClearLaggedList@@9@9
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DD@FLFBJHAP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 610  : 		p = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 611  : 	}

	jmp	SHORT $LN2@NET_ClearL
$LN3@NET_ClearL:

; 612  : 
; 613  : 	list->prev = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 614  : 	list->next = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 615  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_ClearLaggedList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_RemoveFromPacketList
_TEXT	SEGMENT
_p$ = 8							; size = 4
_NET_RemoveFromPacketList PROC				; COMDAT

; 578  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 579  : 	p->prev->next = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax

; 580  : 	p->next->prev = p->prev;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax

; 581  : 	p->prev = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+36], 0

; 582  : 	p->next = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+32], 0

; 583  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_RemoveFromPacketList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_ClearLoopback
_TEXT	SEGMENT
_NET_ClearLoopback PROC					; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 559  : 	net.loopbacks[0].send = net.loopbacks[0].get = 0;

	mov	eax, 524440				; 00080098H
	imul	ecx, eax, 0
	mov	DWORD PTR _net[ecx+524432], 0
	mov	edx, 524440				; 00080098H
	imul	eax, edx, 0
	mov	DWORD PTR _net[eax+524436], 0

; 560  : 	net.loopbacks[1].send = net.loopbacks[1].get = 0;

	mov	eax, 524440				; 00080098H
	shl	eax, 0
	mov	DWORD PTR _net[eax+524432], 0
	mov	ecx, 524440				; 00080098H
	shl	ecx, 0
	mov	DWORD PTR _net[ecx+524436], 0

; 561  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_ClearLoopback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_SendLoopPacket
_TEXT	SEGMENT
_i$ = -8						; size = 4
_loop$ = -4						; size = 4
_sock$ = 8						; size = 4
_length$ = 12						; size = 4
_data$ = 16						; size = 4
_to$ = 20						; size = 20
_NET_SendLoopPacket PROC				; COMDAT

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 540  : 	net_loopback_t	*loop;
; 541  : 	int		i;
; 542  : 
; 543  : 	loop = &net.loopbacks[sock^1];

	mov	eax, DWORD PTR _sock$[ebp]
	xor	eax, 1
	imul	ecx, eax, 524440
	add	ecx, OFFSET _net
	mov	DWORD PTR _loop$[ebp], ecx

; 544  : 
; 545  : 	i = loop->send & MASK_LOOPBACK;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524436]
	and	ecx, 3
	mov	DWORD PTR _i$[ebp], ecx

; 546  : 	loop->send++;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524436]
	add	ecx, 1
	mov	edx, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [edx+524436], ecx

; 547  : 
; 548  : 	memcpy( loop->msgs[i].data, data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 131108
	add	edx, DWORD PTR _loop$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 549  : 	loop->msgs[i].datalen = length;

	imul	eax, DWORD PTR _i$[ebp], 131108
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR _length$[ebp]
	mov	DWORD PTR [ecx+eax+131104], edx

; 550  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SendLoopPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_GetLoopPacket
_TEXT	SEGMENT
_i$ = -8						; size = 4
_loop$ = -4						; size = 4
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_GetLoopPacket PROC					; COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 508  : 	net_loopback_t	*loop;
; 509  : 	int		i;
; 510  : 
; 511  : 	if( !data || !length )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@NET_GetLoo
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN2@NET_GetLoo
$LN3@NET_GetLoo:

; 512  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLoo
$LN2@NET_GetLoo:

; 513  : 
; 514  : 	loop = &net.loopbacks[sock];

	imul	eax, DWORD PTR _sock$[ebp], 524440
	add	eax, OFFSET _net
	mov	DWORD PTR _loop$[ebp], eax

; 515  : 
; 516  : 	if( loop->send - loop->get > MAX_LOOPBACK )

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [eax+524436]
	sub	edx, DWORD PTR [ecx+524432]
	cmp	edx, 4
	jle	SHORT $LN4@NET_GetLoo

; 517  : 		loop->get = loop->send - MAX_LOOPBACK;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524436]
	sub	ecx, 4
	mov	edx, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [edx+524432], ecx
$LN4@NET_GetLoo:

; 518  : 
; 519  : 	if( loop->get >= loop->send )

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [eax+524432]
	cmp	edx, DWORD PTR [ecx+524436]
	jl	SHORT $LN5@NET_GetLoo

; 520  : 		return false;

	xor	eax, eax
	jmp	$LN1@NET_GetLoo
$LN5@NET_GetLoo:

; 521  : 	i = loop->get & MASK_LOOPBACK;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524432]
	and	ecx, 3
	mov	DWORD PTR _i$[ebp], ecx

; 522  : 	loop->get++;

	mov	eax, DWORD PTR _loop$[ebp]
	mov	ecx, DWORD PTR [eax+524432]
	add	ecx, 1
	mov	edx, DWORD PTR _loop$[ebp]
	mov	DWORD PTR [edx+524432], ecx

; 523  : 
; 524  : 	memcpy( data, loop->msgs[i].data, loop->msgs[i].datalen );

	imul	eax, DWORD PTR _i$[ebp], 131108
	mov	ecx, DWORD PTR _loop$[ebp]
	mov	edx, DWORD PTR [ecx+eax+131104]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 131108
	add	eax, DWORD PTR _loop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 525  : 	*length = loop->msgs[i].datalen;

	imul	eax, DWORD PTR _i$[ebp], 131108
	mov	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _loop$[ebp]
	mov	eax, DWORD PTR [edx+eax+131104]
	mov	DWORD PTR [ecx], eax

; 526  : 
; 527  : 	memset( from, 0, sizeof( *from ));

	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 528  : 	from->type = NA_LOOPBACK;

	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], 1

; 529  : 
; 530  : 	return true;

	mov	eax, 1
$LN1@NET_GetLoo:

; 531  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetLoopPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_StringToSockaddr
_TEXT	SEGMENT
_h$1 = -140						; size = 4
_copy$ = -136						; size = 128
_colon$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
_sadr$ = 12						; size = 4
_NET_StringToSockaddr PROC				; COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 294  : 	char	*colon;
; 295  : 	char	copy[128];
; 296  : 
; 297  : 	if( !net.initialized ) return false;

	cmp	DWORD PTR _net+1115120, 0
	jne	SHORT $LN5@NET_String
	xor	eax, eax
	jmp	$LN1@NET_String
$LN5@NET_String:

; 298  : 	
; 299  : 	memset( sadr, 0, sizeof( *sadr ));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _sadr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 300  : 
; 301  : 	((struct sockaddr_in *)sadr)->sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [ecx], ax

; 302  : 	((struct sockaddr_in *)sadr)->sin_port = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [ecx+2], ax

; 303  : 
; 304  : 	Q_strncpy( copy, s, sizeof( copy ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _copy$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 305  : 
; 306  : 	// strip off a trailing :port if present
; 307  : 	for( colon = copy; *colon; colon++ )

	lea	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR _colon$[ebp], eax
	jmp	SHORT $LN4@NET_String
$LN2@NET_String:
	mov	eax, DWORD PTR _colon$[ebp]
	add	eax, 1
	mov	DWORD PTR _colon$[ebp], eax
$LN4@NET_String:
	mov	eax, DWORD PTR _colon$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@NET_String

; 308  : 	{
; 309  : 		if( *colon == ':' )

	mov	eax, DWORD PTR _colon$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN6@NET_String

; 310  : 		{
; 311  : 			*colon = 0;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	BYTE PTR [eax], 0

; 312  : 			((struct sockaddr_in *)sadr)->sin_port = pHtons((short)Q_atoi( colon + 1 ));	

	mov	eax, DWORD PTR _colon$[ebp]
	add	eax, 1
	push	eax
	call	_Q_atoi
	add	esp, 4
	push	eax
	call	DWORD PTR _pHtons
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	WORD PTR [ecx+2], ax
$LN6@NET_String:

; 313  : 		}
; 314  : 	}

	jmp	SHORT $LN2@NET_String
$LN3@NET_String:

; 315  : 
; 316  : 	((struct sockaddr_in *)sadr)->sin_addr.s_addr = pInet_Addr( copy );

	lea	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	DWORD PTR _pInet_Addr
	mov	ecx, DWORD PTR _sadr$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 317  : 
; 318  : 	if(((struct sockaddr_in *)sadr)->sin_addr.s_addr == INADDR_NONE )

	mov	eax, DWORD PTR _sadr$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN7@NET_String

; 319  : 	{
; 320  : 		struct hostent	*h = pGetHostByName( copy );

	lea	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	DWORD PTR _pGetHostByName
	mov	DWORD PTR _h$1[ebp], eax

; 321  : 
; 322  : 		if( h == NULL || h->h_addr == NULL )

	cmp	DWORD PTR _h$1[ebp], 0
	je	SHORT $LN9@NET_String
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _h$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN8@NET_String
$LN9@NET_String:

; 323  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_String
$LN8@NET_String:

; 324  : 
; 325  : 		((struct sockaddr_in *)sadr)->sin_addr.s_addr = *(uint *)h->h_addr;	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _h$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _sadr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], eax
$LN7@NET_String:

; 326  : 	}
; 327  : 	return true;

	mov	eax, 1
$LN1@NET_String:

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_StringToSockaddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_SockadrToNetadr
_TEXT	SEGMENT
_s$ = 8							; size = 4
_a$ = 12						; size = 4
_NET_SockadrToNetadr PROC				; COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 273  : 	if( s->sa_family == AF_INET )

	mov	eax, DWORD PTR _s$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 2
	jne	SHORT $LN1@NET_Sockad

; 274  : 	{
; 275  : 		a->type = NA_IP;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax], 3

; 276  : 		*(int *)&a->ip = ((struct sockaddr_in *)s)->sin_addr.s_addr;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 277  : 		a->port = ((struct sockaddr_in *)s)->sin_port;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR [eax+18], dx
$LN1@NET_Sockad:

; 278  : 	}
; 279  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SockadrToNetadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_NetadrToSockadr
_TEXT	SEGMENT
_a$ = 8							; size = 4
_s$ = 12						; size = 4
_NET_NetadrToSockadr PROC				; COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 250  : 	memset( s, 0, sizeof( *s ));

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 	if( a->type == NA_BROADCAST )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN2@NET_Netadr

; 253  : 	{
; 254  : 		((struct sockaddr_in *)s)->sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax

; 255  : 		((struct sockaddr_in *)s)->sin_port = a->port;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	dx, WORD PTR [ecx+18]
	mov	WORD PTR [eax+2], dx

; 256  : 		((struct sockaddr_in *)s)->sin_addr.s_addr = INADDR_BROADCAST;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax+4], -1

; 257  : 	}

	jmp	SHORT $LN1@NET_Netadr
$LN2@NET_Netadr:

; 258  : 	else if( a->type == NA_IP )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN1@NET_Netadr

; 259  : 	{
; 260  : 		((struct sockaddr_in *)s)->sin_family = AF_INET;

	mov	eax, 2
	mov	ecx, DWORD PTR _s$[ebp]
	mov	WORD PTR [ecx], ax

; 261  : 		((struct sockaddr_in *)s)->sin_addr.s_addr = *(int *)&a->ip;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 262  : 		((struct sockaddr_in *)s)->sin_port = a->port;

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	dx, WORD PTR [ecx+18]
	mov	WORD PTR [eax+2], dx
$LN1@NET_Netadr:

; 263  : 	}
; 264  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_NetadrToSockadr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_ErrorString
_TEXT	SEGMENT
tv66 = -72						; size = 4
_err$ = -4						; size = 4
_NET_ErrorString PROC					; COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 188  : 	int	err = WSANOTINITIALISED;

	mov	DWORD PTR _err$[ebp], 10093		; 0000276dH

; 189  : 
; 190  : 	if( net.initialized )

	cmp	DWORD PTR _net+1115120, 0
	je	SHORT $LN4@NET_ErrorS

; 191  : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax
$LN4@NET_ErrorS:

; 192  : 
; 193  : 	switch( err )

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 11001		; 00002af9H
	jg	SHORT $LN51@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11001		; 00002af9H
	je	$LN45@NET_ErrorS
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 10004				; 00002714H
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 97			; 00000061H
	ja	$LN49@NET_ErrorS
	mov	edx, DWORD PTR tv66[ebp]
	movzx	eax, BYTE PTR $LN52@NET_ErrorS[edx]
	jmp	DWORD PTR $LN53@NET_ErrorS[eax*4]
$LN51@NET_ErrorS:
	cmp	DWORD PTR tv66[ebp], 11002		; 00002afaH
	je	$LN46@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11003		; 00002afbH
	je	$LN47@NET_ErrorS
	cmp	DWORD PTR tv66[ebp], 11004		; 00002afcH
	je	$LN48@NET_ErrorS
	jmp	$LN49@NET_ErrorS
$LN5@NET_ErrorS:

; 194  : 	{
; 195  : 	case WSAEINTR: return "WSAEINTR";

	mov	eax, OFFSET ??_C@_08KEJFHKFF@WSAEINTR@
	jmp	$LN1@NET_ErrorS
$LN6@NET_ErrorS:

; 196  : 	case WSAEBADF: return "WSAEBADF";

	mov	eax, OFFSET ??_C@_08LJKOCPDH@WSAEBADF@
	jmp	$LN1@NET_ErrorS
$LN7@NET_ErrorS:

; 197  : 	case WSAEACCES: return "WSAEACCES";

	mov	eax, OFFSET ??_C@_09EKFHKCJJ@WSAEACCES@
	jmp	$LN1@NET_ErrorS
$LN8@NET_ErrorS:

; 198  : 	case WSAEDISCON: return "WSAEDISCON";

	mov	eax, OFFSET ??_C@_0L@EEHHIAEC@WSAEDISCON@
	jmp	$LN1@NET_ErrorS
$LN9@NET_ErrorS:

; 199  : 	case WSAEFAULT: return "WSAEFAULT";

	mov	eax, OFFSET ??_C@_09BIHAGEEK@WSAEFAULT@
	jmp	$LN1@NET_ErrorS
$LN10@NET_ErrorS:

; 200  : 	case WSAEINVAL: return "WSAEINVAL";

	mov	eax, OFFSET ??_C@_09PDAAOFKK@WSAEINVAL@
	jmp	$LN1@NET_ErrorS
$LN11@NET_ErrorS:

; 201  : 	case WSAEMFILE: return "WSAEMFILE";

	mov	eax, OFFSET ??_C@_09IJIBIDKO@WSAEMFILE@
	jmp	$LN1@NET_ErrorS
$LN12@NET_ErrorS:

; 202  : 	case WSAEWOULDBLOCK: return "WSAEWOULDBLOCK";

	mov	eax, OFFSET ??_C@_0P@BLDHJENA@WSAEWOULDBLOCK@
	jmp	$LN1@NET_ErrorS
$LN13@NET_ErrorS:

; 203  : 	case WSAEINPROGRESS: return "WSAEINPROGRESS";

	mov	eax, OFFSET ??_C@_0P@FHEJEBJC@WSAEINPROGRESS@
	jmp	$LN1@NET_ErrorS
$LN14@NET_ErrorS:

; 204  : 	case WSAEALREADY: return "WSAEALREADY";

	mov	eax, OFFSET ??_C@_0M@EAGDEEAC@WSAEALREADY@
	jmp	$LN1@NET_ErrorS
$LN15@NET_ErrorS:

; 205  : 	case WSAENOTSOCK: return "WSAENOTSOCK";

	mov	eax, OFFSET ??_C@_0M@MDGNMGJ@WSAENOTSOCK@
	jmp	$LN1@NET_ErrorS
$LN16@NET_ErrorS:

; 206  : 	case WSAEDESTADDRREQ: return "WSAEDESTADDRREQ";

	mov	eax, OFFSET ??_C@_0BA@BLGPIJAD@WSAEDESTADDRREQ@
	jmp	$LN1@NET_ErrorS
$LN17@NET_ErrorS:

; 207  : 	case WSAEMSGSIZE: return "WSAEMSGSIZE";

	mov	eax, OFFSET ??_C@_0M@PJKLHKI@WSAEMSGSIZE@
	jmp	$LN1@NET_ErrorS
$LN18@NET_ErrorS:

; 208  : 	case WSAEPROTOTYPE: return "WSAEPROTOTYPE";

	mov	eax, OFFSET ??_C@_0O@HCKGAENP@WSAEPROTOTYPE@
	jmp	$LN1@NET_ErrorS
$LN19@NET_ErrorS:

; 209  : 	case WSAENOPROTOOPT: return "WSAENOPROTOOPT";

	mov	eax, OFFSET ??_C@_0P@KODINEND@WSAENOPROTOOPT@
	jmp	$LN1@NET_ErrorS
$LN20@NET_ErrorS:

; 210  : 	case WSAEPROTONOSUPPORT: return "WSAEPROTONOSUPPORT";

	mov	eax, OFFSET ??_C@_0BD@EDJBJFH@WSAEPROTONOSUPPORT@
	jmp	$LN1@NET_ErrorS
$LN21@NET_ErrorS:

; 211  : 	case WSAESOCKTNOSUPPORT: return "WSAESOCKTNOSUPPORT";

	mov	eax, OFFSET ??_C@_0BD@KNONLHOA@WSAESOCKTNOSUPPORT@
	jmp	$LN1@NET_ErrorS
$LN22@NET_ErrorS:

; 212  : 	case WSAEOPNOTSUPP: return "WSAEOPNOTSUPP";

	mov	eax, OFFSET ??_C@_0O@IFNEEJHC@WSAEOPNOTSUPP@
	jmp	$LN1@NET_ErrorS
$LN23@NET_ErrorS:

; 213  : 	case WSAEPFNOSUPPORT: return "WSAEPFNOSUPPORT";

	mov	eax, OFFSET ??_C@_0BA@KKILJDEG@WSAEPFNOSUPPORT@
	jmp	$LN1@NET_ErrorS
$LN24@NET_ErrorS:

; 214  : 	case WSAEAFNOSUPPORT: return "WSAEAFNOSUPPORT";

	mov	eax, OFFSET ??_C@_0BA@DNDGDCNF@WSAEAFNOSUPPORT@
	jmp	$LN1@NET_ErrorS
$LN25@NET_ErrorS:

; 215  : 	case WSAEADDRINUSE: return "WSAEADDRINUSE";

	mov	eax, OFFSET ??_C@_0O@OPDDJBEB@WSAEADDRINUSE@
	jmp	$LN1@NET_ErrorS
$LN26@NET_ErrorS:

; 216  : 	case WSAEADDRNOTAVAIL: return "WSAEADDRNOTAVAIL";

	mov	eax, OFFSET ??_C@_0BB@MBBPJMGK@WSAEADDRNOTAVAIL@
	jmp	$LN1@NET_ErrorS
$LN27@NET_ErrorS:

; 217  : 	case WSAENETDOWN: return "WSAENETDOWN";

	mov	eax, OFFSET ??_C@_0M@BMNODHFM@WSAENETDOWN@
	jmp	$LN1@NET_ErrorS
$LN28@NET_ErrorS:

; 218  : 	case WSAENETUNREACH: return "WSAENETUNREACH";

	mov	eax, OFFSET ??_C@_0P@MMGFNLEA@WSAENETUNREACH@
	jmp	$LN1@NET_ErrorS
$LN29@NET_ErrorS:

; 219  : 	case WSAENETRESET: return "WSAENETRESET";

	mov	eax, OFFSET ??_C@_0N@KABONKCJ@WSAENETRESET@
	jmp	$LN1@NET_ErrorS
$LN30@NET_ErrorS:

; 220  : 	case WSAECONNABORTED: return "WSWSAECONNABORTEDAEINTR";

	mov	eax, OFFSET ??_C@_0BI@NPIHFCBB@WSWSAECONNABORTEDAEINTR@
	jmp	$LN1@NET_ErrorS
$LN31@NET_ErrorS:

; 221  : 	case WSAECONNRESET: return "WSAECONNRESET";

	mov	eax, OFFSET ??_C@_0O@CIPFFFJE@WSAECONNRESET@
	jmp	SHORT $LN1@NET_ErrorS
$LN32@NET_ErrorS:

; 222  : 	case WSAENOBUFS: return "WSAENOBUFS";

	mov	eax, OFFSET ??_C@_0L@OOBBNNPD@WSAENOBUFS@
	jmp	SHORT $LN1@NET_ErrorS
$LN33@NET_ErrorS:

; 223  : 	case WSAEISCONN: return "WSAEISCONN";

	mov	eax, OFFSET ??_C@_0L@KMBJICHC@WSAEISCONN@
	jmp	SHORT $LN1@NET_ErrorS
$LN34@NET_ErrorS:

; 224  : 	case WSAENOTCONN: return "WSAENOTCONN";

	mov	eax, OFFSET ??_C@_0M@BJHJCMPN@WSAENOTCONN@
	jmp	SHORT $LN1@NET_ErrorS
$LN35@NET_ErrorS:

; 225  : 	case WSAESHUTDOWN: return "WSAESHUTDOWN";

	mov	eax, OFFSET ??_C@_0N@JOJKMOCF@WSAESHUTDOWN@
	jmp	SHORT $LN1@NET_ErrorS
$LN36@NET_ErrorS:

; 226  : 	case WSAETOOMANYREFS: return "WSAETOOMANYREFS";

	mov	eax, OFFSET ??_C@_0BA@COKPFEMB@WSAETOOMANYREFS@
	jmp	SHORT $LN1@NET_ErrorS
$LN37@NET_ErrorS:

; 227  : 	case WSAETIMEDOUT: return "WSAETIMEDOUT";

	mov	eax, OFFSET ??_C@_0N@BJEDIOFA@WSAETIMEDOUT@
	jmp	SHORT $LN1@NET_ErrorS
$LN38@NET_ErrorS:

; 228  : 	case WSAECONNREFUSED: return "WSAECONNREFUSED";

	mov	eax, OFFSET ??_C@_0BA@ECEEDLKJ@WSAECONNREFUSED@
	jmp	SHORT $LN1@NET_ErrorS
$LN39@NET_ErrorS:

; 229  : 	case WSAELOOP: return "WSAELOOP";

	mov	eax, OFFSET ??_C@_08PGIMLMFD@WSAELOOP@
	jmp	SHORT $LN1@NET_ErrorS
$LN40@NET_ErrorS:

; 230  : 	case WSAENAMETOOLONG: return "WSAENAMETOOLONG";

	mov	eax, OFFSET ??_C@_0BA@PCKIJCGI@WSAENAMETOOLONG@
	jmp	SHORT $LN1@NET_ErrorS
$LN41@NET_ErrorS:

; 231  : 	case WSAEHOSTDOWN: return "WSAEHOSTDOWN";

	mov	eax, OFFSET ??_C@_0N@NJBKCOKK@WSAEHOSTDOWN@
	jmp	SHORT $LN1@NET_ErrorS
$LN42@NET_ErrorS:

; 232  : 	case WSASYSNOTREADY: return "WSASYSNOTREADY";

	mov	eax, OFFSET ??_C@_0P@MDJAKAKC@WSASYSNOTREADY@
	jmp	SHORT $LN1@NET_ErrorS
$LN43@NET_ErrorS:

; 233  : 	case WSAVERNOTSUPPORTED: return "WSAVERNOTSUPPORTED";

	mov	eax, OFFSET ??_C@_0BD@PKACBPOA@WSAVERNOTSUPPORTED@
	jmp	SHORT $LN1@NET_ErrorS
$LN44@NET_ErrorS:

; 234  : 	case WSANOTINITIALISED: return "WSANOTINITIALISED";

	mov	eax, OFFSET ??_C@_0BC@CLCHBKPK@WSANOTINITIALISED@
	jmp	SHORT $LN1@NET_ErrorS
$LN45@NET_ErrorS:

; 235  : 	case WSAHOST_NOT_FOUND: return "WSAHOST_NOT_FOUND";

	mov	eax, OFFSET ??_C@_0BC@JCJCFNAO@WSAHOST_NOT_FOUND@
	jmp	SHORT $LN1@NET_ErrorS
$LN46@NET_ErrorS:

; 236  : 	case WSATRY_AGAIN: return "WSATRY_AGAIN";

	mov	eax, OFFSET ??_C@_0N@LHDAEOPK@WSATRY_AGAIN@
	jmp	SHORT $LN1@NET_ErrorS
$LN47@NET_ErrorS:

; 237  : 	case WSANO_RECOVERY: return "WSANO_RECOVERY";

	mov	eax, OFFSET ??_C@_0P@HLNEBJNJ@WSANO_RECOVERY@
	jmp	SHORT $LN1@NET_ErrorS
$LN48@NET_ErrorS:

; 238  : 	case WSANO_DATA: return "WSANO_DATA";

	mov	eax, OFFSET ??_C@_0L@CBLHPKCP@WSANO_DATA@
	jmp	SHORT $LN1@NET_ErrorS
$LN49@NET_ErrorS:

; 239  : 	default: return "NO ERROR";

	mov	eax, OFFSET ??_C@_08LPKPOPGP@NO?5ERROR@
$LN1@NET_ErrorS:

; 240  : 	}
; 241  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN53@NET_ErrorS:
	DD	$LN5@NET_ErrorS
	DD	$LN6@NET_ErrorS
	DD	$LN7@NET_ErrorS
	DD	$LN9@NET_ErrorS
	DD	$LN10@NET_ErrorS
	DD	$LN11@NET_ErrorS
	DD	$LN12@NET_ErrorS
	DD	$LN13@NET_ErrorS
	DD	$LN14@NET_ErrorS
	DD	$LN15@NET_ErrorS
	DD	$LN16@NET_ErrorS
	DD	$LN17@NET_ErrorS
	DD	$LN18@NET_ErrorS
	DD	$LN19@NET_ErrorS
	DD	$LN20@NET_ErrorS
	DD	$LN21@NET_ErrorS
	DD	$LN22@NET_ErrorS
	DD	$LN23@NET_ErrorS
	DD	$LN24@NET_ErrorS
	DD	$LN25@NET_ErrorS
	DD	$LN26@NET_ErrorS
	DD	$LN27@NET_ErrorS
	DD	$LN28@NET_ErrorS
	DD	$LN29@NET_ErrorS
	DD	$LN30@NET_ErrorS
	DD	$LN31@NET_ErrorS
	DD	$LN32@NET_ErrorS
	DD	$LN33@NET_ErrorS
	DD	$LN34@NET_ErrorS
	DD	$LN35@NET_ErrorS
	DD	$LN36@NET_ErrorS
	DD	$LN37@NET_ErrorS
	DD	$LN38@NET_ErrorS
	DD	$LN39@NET_ErrorS
	DD	$LN40@NET_ErrorS
	DD	$LN41@NET_ErrorS
	DD	$LN42@NET_ErrorS
	DD	$LN43@NET_ErrorS
	DD	$LN44@NET_ErrorS
	DD	$LN8@NET_ErrorS
	DD	$LN49@NET_ErrorS
$LN52@NET_ErrorS:
	DB	0
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	1
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	2
	DB	3
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	4
	DB	40					; 00000028H
	DB	5
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	39					; 00000027H
_NET_ErrorString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_FreeWinSock
_TEXT	SEGMENT
_NET_FreeWinSock PROC					; COMDAT

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 178  : 	Sys_FreeLibrary( &winsock_dll );

	push	OFFSET _winsock_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 179  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_FreeWinSock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_OpenWinSock
_TEXT	SEGMENT
_NET_OpenWinSock PROC					; COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 162  : 	// initialize the Winsock function vectors (we do this instead of statically linking
; 163  : 	// so we can run on Win 3.1, where there isn't necessarily Winsock)
; 164  : 	if( Sys_LoadLibrary( &winsock_dll ))

	push	OFFSET _winsock_dll
	call	_Sys_LoadLibrary
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@NET_OpenWi

; 165  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_OpenWi
$LN2@NET_OpenWi:

; 166  : 	return false;

	xor	eax, eax
$LN1@NET_OpenWi:

; 167  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_OpenWinSock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_ClearLagData
_TEXT	SEGMENT
_bClient$ = 8						; size = 4
_bServer$ = 12						; size = 4
_NET_ClearLagData PROC					; COMDAT

; 1429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1430 : 	if( bClient ) NET_ClearLaggedList( &net.lagdata[NS_CLIENT] );

	cmp	DWORD PTR _bClient$[ebp], 0
	je	SHORT $LN2@NET_ClearL
	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	add	ecx, OFFSET _net+1048880
	push	ecx
	call	_NET_ClearLaggedList
	add	esp, 4
$LN2@NET_ClearL:

; 1431 : 	if( bServer ) NET_ClearLaggedList( &net.lagdata[NS_SERVER] );

	cmp	DWORD PTR _bServer$[ebp], 0
	je	SHORT $LN1@NET_ClearL
	mov	eax, 40					; 00000028H
	shl	eax, 0
	add	eax, OFFSET _net+1048880
	push	eax
	call	_NET_ClearLaggedList
	add	esp, 4
$LN1@NET_ClearL:

; 1432 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_ClearLagData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_SendPacket
_TEXT	SEGMENT
_net_socket$ = -32					; size = 4
_addr$ = -28						; size = 16
_err$ = -12						; size = 4
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_length$ = 12						; size = 4
_data$ = 16						; size = 4
_to$ = 20						; size = 20
_NET_SendPacket PROC					; COMDAT

; 1016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1017 : 	int		ret, err;
; 1018 : 	struct sockaddr	addr;
; 1019 : 	SOCKET		net_socket;
; 1020 : 
; 1021 : 	if( !net.initialized || to.type == NA_LOOPBACK )

	cmp	DWORD PTR _net+1115120, 0
	je	SHORT $LN4@NET_SendPa
	cmp	DWORD PTR _to$[ebp], 1
	jne	SHORT $LN2@NET_SendPa
$LN4@NET_SendPa:

; 1022 : 	{
; 1023 : 		NET_SendLoopPacket( sock, length, data, to );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	_NET_SendLoopPacket
	add	esp, 32					; 00000020H

; 1024 : 		return;

	jmp	$LN1@NET_SendPa

; 1025 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN2@NET_SendPa:

; 1026 : 	else if( to.type == NA_BROADCAST )

	cmp	DWORD PTR _to$[ebp], 2
	jne	SHORT $LN5@NET_SendPa

; 1027 : 	{
; 1028 : 		net_socket = net.ip_sockets[sock];

	mov	eax, DWORD PTR _sock$[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1114712]
	mov	DWORD PTR _net_socket$[ebp], ecx

; 1029 : 		if( net_socket == INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN7@NET_SendPa

; 1030 : 			return;

	jmp	$LN1@NET_SendPa
$LN7@NET_SendPa:

; 1031 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN5@NET_SendPa:

; 1032 : 	else if( to.type == NA_IP )

	cmp	DWORD PTR _to$[ebp], 3
	jne	SHORT $LN8@NET_SendPa

; 1033 : 	{
; 1034 : 		net_socket = net.ip_sockets[sock];

	mov	eax, DWORD PTR _sock$[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1114712]
	mov	DWORD PTR _net_socket$[ebp], ecx

; 1035 : 		if( net_socket == INVALID_SOCKET )

	cmp	DWORD PTR _net_socket$[ebp], -1
	jne	SHORT $LN10@NET_SendPa

; 1036 : 			return;

	jmp	$LN1@NET_SendPa
$LN10@NET_SendPa:

; 1037 : 	}

	jmp	SHORT $LN3@NET_SendPa
$LN8@NET_SendPa:

; 1038 : 	else
; 1039 : 	{
; 1040 : 		Host_Error( "NET_SendPacket: bad address type %i\n", to.type );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@NEFJAJAB@NET_SendPacket?3?5bad?5address?5typ@
	call	_Host_Error
	add	esp, 8
$LN3@NET_SendPa:

; 1041 : 	}
; 1042 : 
; 1043 : 	NET_NetadrToSockadr( &to, &addr );

	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _to$[ebp]
	push	ecx
	call	_NET_NetadrToSockadr
	add	esp, 8

; 1044 : 
; 1045 : 	ret = NET_SendLong( sock, net_socket, data, length, 0, &addr, sizeof( addr ));

	push	16					; 00000010H
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _net_socket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	_NET_SendLong
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret$[ebp], eax

; 1046 : 
; 1047 : 	if( ret == SOCKET_ERROR )

	cmp	DWORD PTR _ret$[ebp], -1
	jne	$LN1@NET_SendPa

; 1048 : 	{
; 1049 : 		err = pWSAGetLastError();

	call	DWORD PTR _pWSAGetLastError
	mov	DWORD PTR _err$[ebp], eax

; 1050 : 
; 1051 : 		// WSAEWOULDBLOCK is silent
; 1052 : 		if( err == WSAEWOULDBLOCK )

	cmp	DWORD PTR _err$[ebp], 10035		; 00002733H
	jne	SHORT $LN12@NET_SendPa

; 1053 : 			return;

	jmp	$LN1@NET_SendPa
$LN12@NET_SendPa:

; 1054 : 
; 1055 : 		// some PPP links don't allow broadcasts
; 1056 : 		if( err == WSAEADDRNOTAVAIL && to.type == NA_BROADCAST )

	cmp	DWORD PTR _err$[ebp], 10049		; 00002741H
	jne	SHORT $LN13@NET_SendPa
	cmp	DWORD PTR _to$[ebp], 2
	jne	SHORT $LN13@NET_SendPa

; 1057 : 			return;

	jmp	$LN1@NET_SendPa
$LN13@NET_SendPa:

; 1058 : 
; 1059 : 		// let dedicated servers continue after errors
; 1060 : 		if( host.type == HOST_DEDICATED )

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN14@NET_SendPa

; 1061 : 		{
; 1062 : 			Con_DPrintf( S_ERROR "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET ??_C@_0CF@PJDCFGMN@?$FO1Error?3?$FO7?5NET_SendPacket?3?5?$CFs?5t@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1063 : 		}

	jmp	$LN1@NET_SendPa
$LN14@NET_SendPa:

; 1064 : 		else if( err == WSAEADDRNOTAVAIL || err == WSAENOBUFS )

	cmp	DWORD PTR _err$[ebp], 10049		; 00002741H
	je	SHORT $LN18@NET_SendPa
	cmp	DWORD PTR _err$[ebp], 10055		; 00002747H
	jne	SHORT $LN16@NET_SendPa
$LN18@NET_SendPa:

; 1065 : 		{
; 1066 : 			Con_DPrintf( S_ERROR "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET ??_C@_0CF@PJDCFGMN@?$FO1Error?3?$FO7?5NET_SendPacket?3?5?$CFs?5t@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1067 : 		}

	jmp	SHORT $LN1@NET_SendPa
$LN16@NET_SendPa:

; 1068 : 		else
; 1069 : 		{
; 1070 : 			Host_Error( "NET_SendPacket: %s to %s\n", NET_ErrorString(), NET_AdrToString( to ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _to$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _to$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _to$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _to$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _to$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	call	_NET_ErrorString
	push	eax
	push	OFFSET ??_C@_0BK@DNLMFBPF@NET_SendPacket?3?5?$CFs?5to?5?$CFs?6@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN1@NET_SendPa:

; 1071 : 		}
; 1072 : 	}
; 1073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_SendPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_BufferToBufferDecompress
_TEXT	SEGMENT
_uDecompressedLen$1 = -4				; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_NET_BufferToBufferDecompress PROC			; COMDAT

; 1114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1115 : 	if( LZSS_IsCompressed( source ))

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_LZSS_IsCompressed
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@NET_Buffer

; 1116 : 	{
; 1117 : 		uint	uDecompressedLen = LZSS_GetActualSize( source );

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_LZSS_GetActualSize
	add	esp, 4
	mov	DWORD PTR _uDecompressedLen$1[ebp], eax

; 1118 : 
; 1119 : 		if( uDecompressedLen <= *destLen )

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _uDecompressedLen$1[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	SHORT $LN4@NET_Buffer

; 1120 : 		{
; 1121 : 			*destLen = LZSS_Decompress( source, dest );

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_LZSS_Decompress
	add	esp, 8
	mov	edx, DWORD PTR _destLen$[ebp]
	mov	DWORD PTR [edx], eax

; 1122 : 		}

	jmp	SHORT $LN5@NET_Buffer
$LN4@NET_Buffer:

; 1123 : 		else
; 1124 : 		{
; 1125 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Buffer
$LN5@NET_Buffer:

; 1126 : 		}
; 1127 : 	}

	jmp	SHORT $LN3@NET_Buffer
$LN2@NET_Buffer:

; 1128 : 	else
; 1129 : 	{
; 1130 : 		memcpy( dest, source, sourceLen );

	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1131 : 		*destLen = sourceLen;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@NET_Buffer:

; 1132 : 	}
; 1133 : 
; 1134 : 	return true;

	mov	eax, 1
$LN1@NET_Buffer:

; 1135 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_BufferToBufferDecompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_BufferToBufferCompress
_TEXT	SEGMENT
_pbOut$ = -8						; size = 4
_uCompressedLen$ = -4					; size = 4
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_NET_BufferToBufferCompress PROC			; COMDAT

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1084 : 	uint	uCompressedLen = 0;

	mov	DWORD PTR _uCompressedLen$[ebp], 0

; 1085 : 	byte	*pbOut = NULL;

	mov	DWORD PTR _pbOut$[ebp], 0

; 1086 : 
; 1087 : 	memcpy( dest, source, sourceLen );

	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1088 : 	pbOut = LZSS_Compress( source, sourceLen, &uCompressedLen );

	lea	eax, DWORD PTR _uCompressedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	_LZSS_Compress
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pbOut$[ebp], eax

; 1089 : 
; 1090 : 	if( pbOut && uCompressedLen > 0 && uCompressedLen <= *destLen )

	cmp	DWORD PTR _pbOut$[ebp], 0
	je	SHORT $LN2@NET_Buffer
	cmp	DWORD PTR _uCompressedLen$[ebp], 0
	jbe	SHORT $LN2@NET_Buffer
	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _uCompressedLen$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	SHORT $LN2@NET_Buffer

; 1091 : 	{
; 1092 : 		memcpy( dest, pbOut, uCompressedLen );

	mov	eax, DWORD PTR _uCompressedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1093 : 		*destLen = uCompressedLen;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _uCompressedLen$[ebp]
	mov	DWORD PTR [eax], ecx

; 1094 : 		free( pbOut );

	mov	eax, DWORD PTR _pbOut$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 1095 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Buffer

; 1096 : 	}

	jmp	SHORT $LN1@NET_Buffer
$LN2@NET_Buffer:

; 1097 : 	else
; 1098 : 	{
; 1099 : 		if( pbOut ) free( pbOut );

	cmp	DWORD PTR _pbOut$[ebp], 0
	je	SHORT $LN4@NET_Buffer
	mov	eax, DWORD PTR _pbOut$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN4@NET_Buffer:

; 1100 : 		memcpy( dest, source, sourceLen );

	mov	eax, DWORD PTR _sourceLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1101 : 		*destLen = sourceLen;

	mov	eax, DWORD PTR _destLen$[ebp]
	mov	ecx, DWORD PTR _sourceLen$[ebp]
	mov	DWORD PTR [eax], ecx

; 1102 : 		return false;

	xor	eax, eax
$LN1@NET_Buffer:

; 1103 : 	}
; 1104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_BufferToBufferCompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_GetPacket
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_from$ = 12						; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_NET_GetPacket PROC					; COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 929  : 	if( !data || !length )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@NET_GetPac
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN2@NET_GetPac
$LN3@NET_GetPac:

; 930  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_GetPac
$LN2@NET_GetPac:

; 931  : 
; 932  : 	NET_AdjustLag();

	call	_NET_AdjustLag

; 933  : 
; 934  : 	if( NET_GetLoopPacket( sock, from, data, length ))

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_NET_GetLoopPacket
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN4@NET_GetPac

; 935  : 	{
; 936  : 		return NET_LagPacket( true, sock, from, length, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	push	1
	call	_NET_LagPacket
	add	esp, 20					; 00000014H
	jmp	SHORT $LN1@NET_GetPac

; 937  : 	}

	jmp	SHORT $LN1@NET_GetPac
$LN4@NET_GetPac:

; 938  : 	else
; 939  : 	{
; 940  : 		return NET_QueuePacket( sock, from, data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _from$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_NET_QueuePacket
	add	esp, 16					; 00000010H
$LN1@NET_GetPac:

; 941  : 	}
; 942  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_GetPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_CompareBaseAdr
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareBaseAdr PROC				; COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 363  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 364  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 365  : 
; 366  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 367  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 368  : 
; 369  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 370  : 	{
; 371  : 		if( !memcmp( a.ip, b.ip, 4 ))

	push	4
	lea	eax, DWORD PTR _b$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp+4]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@NET_Compar

; 372  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 373  : 	}
; 374  : 
; 375  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_CompareBaseAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_CompareAdr
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareAdr PROC					; COMDAT

; 440  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 441  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 442  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 443  : 
; 444  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 445  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 446  : 
; 447  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 448  : 	{
; 449  : 		if(!memcmp( a.ip, b.ip, 4 ) && a.port == b.port )

	push	4
	lea	eax, DWORD PTR _b$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp+4]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@NET_Compar
	movzx	eax, WORD PTR _a$[ebp+18]
	movzx	ecx, WORD PTR _b$[ebp+18]
	cmp	eax, ecx
	jne	SHORT $LN5@NET_Compar

; 450  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN5@NET_Compar:

; 451  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 452  : 	}
; 453  : 
; 454  : 	Con_DPrintf( S_ERROR "NET_CompareAdr: bad address type\n" );

	push	OFFSET ??_C@_0CN@JMPIKEJK@?$FO1Error?3?$FO7?5NET_CompareAdr?3?5bad?5@
	call	_Con_DPrintf
	add	esp, 4

; 455  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_CompareAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_StringToAdr
_TEXT	SEGMENT
_s$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_string$ = 8						; size = 4
_adr$ = 12						; size = 4
_NET_StringToAdr PROC					; COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 478  : 	struct sockaddr s;
; 479  : 
; 480  : 	if( !Q_stricmp( string, "localhost" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09IPAEKDAI@localhost@
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@NET_String

; 481  : 	{
; 482  : 		memset( adr, 0, sizeof( netadr_t ));

	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _adr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 483  : 		adr->type = NA_LOOPBACK;

	mov	eax, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], 1

; 484  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_String
$LN2@NET_String:

; 485  : 	}
; 486  : 
; 487  : 	if( !NET_StringToSockaddr( string, &s ))

	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_NET_StringToSockaddr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@NET_String

; 488  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_String
$LN3@NET_String:

; 489  : 	NET_SockadrToNetadr( &s, adr );

	mov	eax, DWORD PTR _adr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_NET_SockadrToNetadr
	add	esp, 8

; 490  : 
; 491  : 	return true;

	mov	eax, 1
$LN1@NET_String:

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_StringToAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_CompareClassBAdr
_TEXT	SEGMENT
_a$ = 8							; size = 20
_b$ = 28						; size = 20
_NET_CompareClassBAdr PROC				; COMDAT

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 387  : 	if( a.type != b.type )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _b$[ebp]
	je	SHORT $LN2@NET_Compar

; 388  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_Compar
$LN2@NET_Compar:

; 389  : 
; 390  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN3@NET_Compar

; 391  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN3@NET_Compar:

; 392  : 
; 393  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	SHORT $LN4@NET_Compar

; 394  : 	{
; 395  : 		if( a.ip[0] == b.ip[0] && a.ip[1] == b.ip[1] )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR _b$[ebp+ecx+4]
	cmp	edx, eax
	jne	SHORT $LN4@NET_Compar
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _b$[ebp+edx+4]
	cmp	ecx, eax
	jne	SHORT $LN4@NET_Compar

; 396  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_Compar
$LN4@NET_Compar:

; 397  : 	}
; 398  : 	return false;

	xor	eax, eax
$LN1@NET_Compar:

; 399  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_CompareClassBAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_IsReservedAdr
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_IsReservedAdr PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 410  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_IsRese

; 411  : 		return true;

	mov	eax, 1
	jmp	$LN1@NET_IsRese
$LN2@NET_IsRese:

; 412  : 
; 413  : 	if( a.type == NA_IP )

	cmp	DWORD PTR _a$[ebp], 3
	jne	$LN3@NET_IsRese

; 414  : 	{
; 415  : 		if( a.ip[0] == 10 || a.ip[0] == 127 )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN5@NET_IsRese
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 127				; 0000007fH
	jne	SHORT $LN4@NET_IsRese
$LN5@NET_IsRese:

; 416  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN4@NET_IsRese:

; 417  : 
; 418  : 		if( a.ip[0] == 172 && a.ip[1] >= 16 )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 172				; 000000acH
	jne	SHORT $LN6@NET_IsRese
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	cmp	ecx, 16					; 00000010H
	jl	SHORT $LN6@NET_IsRese

; 419  : 		{
; 420  : 			if( a.ip[1] >= 32 )

	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN7@NET_IsRese

; 421  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@NET_IsRese
$LN7@NET_IsRese:

; 422  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN6@NET_IsRese:

; 423  : 		}
; 424  : 
; 425  : 		if( a.ip[0] == 192 && a.ip[1] >= 168 )

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	cmp	edx, 192				; 000000c0H
	jne	SHORT $LN3@NET_IsRese
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	cmp	ecx, 168				; 000000a8H
	jl	SHORT $LN3@NET_IsRese

; 426  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@NET_IsRese
$LN3@NET_IsRese:

; 427  : 	}
; 428  : 
; 429  : 	return false;

	xor	eax, eax
$LN1@NET_IsRese:

; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IsReservedAdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_BaseAdrToString
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_BaseAdrToString PROC				; COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 349  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_BaseAd

; 350  : 		return "loopback";

	mov	eax, OFFSET ??_C@_08HAEGGJGF@loopback@
	jmp	SHORT $LN1@NET_BaseAd
$LN2@NET_BaseAd:

; 351  : 	return va( "%i.%i.%i.%i", a.ip[0], a.ip[1], a.ip[2], a.ip[3] );

	mov	eax, 1
	imul	ecx, eax, 3
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	push	ecx
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	push	OFFSET ??_C@_0M@OPOCDNEK@?$CFi?4?$CFi?4?$CFi?4?$CFi@
	call	_va
	add	esp, 20					; 00000014H
$LN1@NET_BaseAd:

; 352  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_BaseAdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_AdrToString
_TEXT	SEGMENT
_a$ = 8							; size = 20
_NET_AdrToString PROC					; COMDAT

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 337  : 	if( a.type == NA_LOOPBACK )

	cmp	DWORD PTR _a$[ebp], 1
	jne	SHORT $LN2@NET_AdrToS

; 338  : 		return "loopback";

	mov	eax, OFFSET ??_C@_08HAEGGJGF@loopback@
	jmp	SHORT $LN1@NET_AdrToS
$LN2@NET_AdrToS:

; 339  : 	return va( "%i.%i.%i.%i:%i", a.ip[0], a.ip[1], a.ip[2], a.ip[3], pNtohs( a.port ));

	movzx	eax, WORD PTR _a$[ebp+18]
	push	eax
	call	DWORD PTR _pNtohs
	movzx	ecx, ax
	push	ecx
	mov	edx, 1
	imul	eax, edx, 3
	movzx	ecx, BYTE PTR _a$[ebp+eax+4]
	push	ecx
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _a$[ebp+edx+4]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _a$[ebp+ecx+4]
	push	edx
	push	OFFSET ??_C@_0P@EMMOIPDD@?$CFi?4?$CFi?4?$CFi?4?$CFi?3?$CFi@
	call	_va
	add	esp, 24					; 00000018H
$LN1@NET_AdrToS:

; 340  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_AdrToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_IsLocalAddress
_TEXT	SEGMENT
tv65 = -68						; size = 4
_adr$ = 8						; size = 20
_NET_IsLocalAddress PROC				; COMDAT

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 465  : 	return (adr.type == NA_LOOPBACK) ? true : false;

	cmp	DWORD PTR _adr$[ebp], 1
	jne	SHORT $LN3@NET_IsLoca
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@NET_IsLoca
$LN3@NET_IsLoca:
	mov	DWORD PTR tv65[ebp], 0
$LN4@NET_IsLoca:
	mov	eax, DWORD PTR tv65[ebp]

; 466  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IsLocalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_Config
_TEXT	SEGMENT
tv80 = -72						; size = 4
_i$1 = -4						; size = 4
_multiplayer$ = 8					; size = 4
_NET_Config PROC					; COMDAT

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1327 : 	static qboolean	bFirst = true;
; 1328 : 	static qboolean	old_config;
; 1329 : 
; 1330 : 	if( !net.initialized )

	cmp	DWORD PTR _net+1115120, 0
	jne	SHORT $LN5@NET_Config

; 1331 : 		return;

	jmp	$LN1@NET_Config
$LN5@NET_Config:

; 1332 : 
; 1333 : 	if( old_config == multiplayer )

	mov	eax, DWORD PTR ?old_config@?1??NET_Config@@9@9
	cmp	eax, DWORD PTR _multiplayer$[ebp]
	jne	SHORT $LN6@NET_Config

; 1334 : 		return;

	jmp	$LN1@NET_Config
$LN6@NET_Config:

; 1335 : 
; 1336 : 	old_config = multiplayer;

	mov	eax, DWORD PTR _multiplayer$[ebp]
	mov	DWORD PTR ?old_config@?1??NET_Config@@9@9, eax

; 1337 : 
; 1338 : 	if( multiplayer )

	cmp	DWORD PTR _multiplayer$[ebp], 0
	je	SHORT $LN7@NET_Config

; 1339 : 	{	
; 1340 : 		// open sockets
; 1341 : 		if( net.allow_ip ) NET_OpenIP();

	cmp	DWORD PTR _net+1115128, 0
	je	SHORT $LN9@NET_Config
	call	_NET_OpenIP
$LN9@NET_Config:

; 1342 : 
; 1343 : 		// get our local address, if possible
; 1344 : 		if( bFirst )

	cmp	DWORD PTR ?bFirst@?1??NET_Config@@9@9, 0
	je	SHORT $LN10@NET_Config

; 1345 : 		{
; 1346 : 			NET_GetLocalAddress();

	call	_NET_GetLocalAddress

; 1347 : 			bFirst = false;

	mov	DWORD PTR ?bFirst@?1??NET_Config@@9@9, 0
$LN10@NET_Config:

; 1348 : 		}
; 1349 : 	}

	jmp	SHORT $LN8@NET_Config
$LN7@NET_Config:

; 1350 : 	else
; 1351 : 	{	
; 1352 : 		int	i;
; 1353 : 
; 1354 : 		// shut down any existing sockets
; 1355 : 		for( i = 0; i < NS_COUNT; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@NET_Config
$LN2@NET_Config:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@NET_Config:
	cmp	DWORD PTR _i$1[ebp], 2
	jge	SHORT $LN8@NET_Config

; 1356 : 		{
; 1357 : 			if( net.ip_sockets[i] != INVALID_SOCKET )

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR _net[eax*4+1114712], -1
	je	SHORT $LN11@NET_Config

; 1358 : 			{
; 1359 : 				pCloseSocket( net.ip_sockets[i] );

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _net[eax*4+1114712]
	push	ecx
	call	DWORD PTR _pCloseSocket

; 1360 : 				net.ip_sockets[i] = INVALID_SOCKET;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _net[eax*4+1114712], -1
$LN11@NET_Config:

; 1361 : 			}
; 1362 : 		}

	jmp	SHORT $LN2@NET_Config
$LN8@NET_Config:

; 1363 : 	}
; 1364 : 
; 1365 : 	NET_ClearLoopback ();

	call	_NET_ClearLoopback

; 1366 : 
; 1367 : 	net.configured = multiplayer ? true : false;

	cmp	DWORD PTR _multiplayer$[ebp], 0
	je	SHORT $LN13@NET_Config
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN14@NET_Config
$LN13@NET_Config:
	mov	DWORD PTR tv80[ebp], 0
$LN14@NET_Config:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR _net+1115124, eax
$LN1@NET_Config:

; 1368 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Config ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_IsConfigured
_TEXT	SEGMENT
_NET_IsConfigured PROC					; COMDAT

; 1378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1379 : 	return net.configured;

	mov	eax, DWORD PTR _net+1115124

; 1380 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IsConfigured ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_IsActive
_TEXT	SEGMENT
_NET_IsActive PROC					; COMDAT

; 1388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1389 : 	return net.initialized;

	mov	eax, DWORD PTR _net+1115120

; 1390 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_IsActive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_Sleep
_TEXT	SEGMENT
_i$ = -276						; size = 4
_fdset$ = -272						; size = 260
_timeout$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_msec$ = 8						; size = 4
_NET_Sleep PROC						; COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1401 : 	struct timeval	timeout;
; 1402 : 	fd_set		fdset;
; 1403 : 	int		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1404 : 
; 1405 : 	if( !net.initialized || host.type == HOST_NORMAL )

	cmp	DWORD PTR _net+1115120, 0
	je	SHORT $LN6@NET_Sleep
	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN5@NET_Sleep
$LN6@NET_Sleep:

; 1406 : 		return; // we're not a dedicated server, just run full speed

	jmp	$LN1@NET_Sleep
$LN5@NET_Sleep:

; 1407 : 
; 1408 : 	FD_ZERO( &fdset );

	mov	DWORD PTR _fdset$[ebp], 0

; 1409 : 
; 1410 : 	if( net.ip_sockets[NS_SERVER] != INVALID_SOCKET )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _net[eax+1114712], -1
	je	SHORT $LN7@NET_Sleep
$LN4@NET_Sleep:

; 1411 : 	{
; 1412 : 		FD_SET( net.ip_sockets[NS_SERVER], &fdset ); // network socket

	cmp	DWORD PTR _fdset$[ebp], 64		; 00000040H
	jae	SHORT $LN2@NET_Sleep
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _fdset$[ebp]
	mov	edx, DWORD PTR _net[eax+1114712]
	mov	DWORD PTR _fdset$[ebp+ecx*4+4], edx
	mov	eax, DWORD PTR _fdset$[ebp]
	add	eax, 1
	mov	DWORD PTR _fdset$[ebp], eax
$LN2@NET_Sleep:
	xor	eax, eax
	jne	SHORT $LN4@NET_Sleep

; 1413 : 		i = net.ip_sockets[NS_SERVER];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _net[eax+1114712]
	mov	DWORD PTR _i$[ebp], ecx
$LN7@NET_Sleep:

; 1414 : 	}
; 1415 : 
; 1416 : 	timeout.tv_sec = msec / 1000;

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _timeout$[ebp], eax

; 1417 : 	timeout.tv_usec = (msec % 1000) * 1000;

	mov	eax, DWORD PTR _msec$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	imul	edx, edx, 1000
	mov	DWORD PTR _timeout$[ebp+4], edx

; 1418 : 	pSelect( i+1, &fdset, NULL, NULL, &timeout );

	lea	eax, DWORD PTR _timeout$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _fdset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR _pSelect
$LN1@NET_Sleep:

; 1419 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Sleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_Shutdown
_TEXT	SEGMENT
_NET_Shutdown PROC					; COMDAT

; 1501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1502 : 	if( !net.initialized )

	cmp	DWORD PTR _net+1115120, 0
	jne	SHORT $LN2@NET_Shutdo

; 1503 : 		return;

	jmp	SHORT $LN1@NET_Shutdo
$LN2@NET_Shutdo:

; 1504 : 
; 1505 : 	NET_ClearLagData( true, true );

	push	1
	push	1
	call	_NET_ClearLagData
	add	esp, 8

; 1506 : 
; 1507 : 	NET_Config( false );

	push	0
	call	_NET_Config
	add	esp, 4

; 1508 : 	pWSACleanup();

	call	DWORD PTR _pWSACleanup

; 1509 : 	NET_FreeWinSock();

	call	_NET_FreeWinSock

; 1510 : 	net.initialized = false;

	mov	DWORD PTR _net+1115120, 0
$LN1@NET_Shutdo:

; 1511 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_ws.c
;	COMDAT _NET_Init
_TEXT	SEGMENT
_i$ = -72						; size = 4
_cmd$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_NET_Init PROC						; COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1441 : 	char	cmd[64];
; 1442 : 	int	i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 1443 : 
; 1444 : 	if( net.initialized ) return;

	cmp	DWORD PTR _net+1115120, 0
	je	SHORT $LN5@NET_Init
	jmp	$LN1@NET_Init
$LN5@NET_Init:

; 1445 : 
; 1446 : 	net_clockwindow = Cvar_Get( "clockwindow", "0.5", 0, "timewindow to execute client moves" );

	push	OFFSET ??_C@_0CD@GDFEJLKD@timewindow?5to?5execute?5client?5mo@
	push	0
	push	OFFSET ??_C@_03LOHCHBBO@0?45@
	push	OFFSET ??_C@_0M@POCMKHIF@clockwindow@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_clockwindow, eax

; 1447 : 	net_address = Cvar_Get( "net_address", "0", FCVAR_READ_ONLY, "contain local address of current client" );

	push	OFFSET ??_C@_0CI@BEJNDEBJ@contain?5local?5address?5of?5curren@
	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@BLBBNKIE@net_address@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_address, eax

; 1448 : 	net_ipname = Cvar_Get( "ip", "localhost", FCVAR_READ_ONLY, "network ip address" );

	push	OFFSET ??_C@_0BD@HCBLJMHF@network?5ip?5address@
	push	131072					; 00020000H
	push	OFFSET ??_C@_09IPAEKDAI@localhost@
	push	OFFSET ??_C@_02GIIHKPLE@ip@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_ipname, eax

; 1449 : 	net_iphostport = Cvar_Get( "ip_hostport", "0", FCVAR_READ_ONLY, "network ip host port" );

	push	OFFSET ??_C@_0BF@NOMDJBDM@network?5ip?5host?5port@
	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@KCBOPDKD@ip_hostport@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_iphostport, eax

; 1450 : 	net_hostport = Cvar_Get( "hostport", va( "%i", PORT_SERVER ), FCVAR_READ_ONLY, "network default host port" );

	push	OFFSET ??_C@_0BK@KIIKHHFP@network?5default?5host?5port@
	push	131072					; 00020000H
	push	27015					; 00006987H
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_08DMAEPIMN@hostport@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_hostport, eax

; 1451 : 	net_ipclientport = Cvar_Get( "ip_clientport", "0", FCVAR_READ_ONLY, "network ip client port" );

	push	OFFSET ??_C@_0BH@EABEEOLF@network?5ip?5client?5port@
	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@FPHJLNHG@ip_clientport@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_ipclientport, eax

; 1452 : 	net_clientport = Cvar_Get( "clientport", va( "%i", PORT_CLIENT ), FCVAR_READ_ONLY, "network default client port" );

	push	OFFSET ??_C@_0BM@EHKNEHNF@network?5default?5client?5port@
	push	131072					; 00020000H
	push	27005					; 0000697dH
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0L@DDNFLMMN@clientport@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_clientport, eax

; 1453 : 	net_fakelag = Cvar_Get( "fakelag", "0", 0, "lag all incoming network data (including loopback) by xxx ms." );

	push	OFFSET ??_C@_0DO@CDGJDNFN@lag?5all?5incoming?5network?5data?5?$CI@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_07IACANNJD@fakelag@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_fakelag, eax

; 1454 : 	net_fakeloss = Cvar_Get( "fakeloss", "0", 0, "act like we dropped the packet this % of the time." );

	push	OFFSET ??_C@_0DD@JBLMCFNB@act?5like?5we?5dropped?5the?5packet?5@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08JGGELEIJ@fakeloss@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _net_fakeloss, eax

; 1455 : 
; 1456 : 	// prepare some network data
; 1457 : 	for( i = 0; i < NS_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NET_Init
$LN2@NET_Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@NET_Init:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN3@NET_Init

; 1458 : 	{
; 1459 : 		net.lagdata[i].prev = &net.lagdata[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _net+1048880
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _net[ecx+1048916], eax

; 1460 : 		net.lagdata[i].next = &net.lagdata[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _net+1048880
	imul	ecx, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _net[ecx+1048912], eax

; 1461 : 		net.ip_sockets[i] = INVALID_SOCKET;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _net[eax*4+1114712], -1

; 1462 : 	}

	jmp	SHORT $LN2@NET_Init
$LN3@NET_Init:

; 1463 : 
; 1464 : 	if( !NET_OpenWinSock( ))	// loading wsock32.dll

	call	_NET_OpenWinSock
	test	eax, eax
	jne	SHORT $LN6@NET_Init

; 1465 : 	{
; 1466 : 		Con_DPrintf( S_ERROR "network failed to load wsock32.dll.\n" );

	push	OFFSET ??_C@_0DA@DPBCEML@?$FO1Error?3?$FO7?5network?5failed?5to?5lo@
	call	_Con_DPrintf
	add	esp, 4

; 1467 : 		return;

	jmp	$LN1@NET_Init
$LN6@NET_Init:

; 1468 : 	}
; 1469 : 
; 1470 : 	if( pWSAStartup( MAKEWORD( 1, 1 ), &net.winsockdata ))

	push	OFFSET _net+1114720
	push	257					; 00000101H
	call	DWORD PTR _pWSAStartup
	test	eax, eax
	je	SHORT $LN7@NET_Init

; 1471 : 	{
; 1472 : 		Con_DPrintf( S_ERROR "network initialization failed.\n" );

	push	OFFSET ??_C@_0CL@DHGLFKAH@?$FO1Error?3?$FO7?5network?5initializati@
	call	_Con_DPrintf
	add	esp, 4

; 1473 : 		NET_FreeWinSock();

	call	_NET_FreeWinSock

; 1474 : 		return;

	jmp	$LN1@NET_Init
$LN7@NET_Init:

; 1475 : 	}
; 1476 : 
; 1477 : 	if( Sys_CheckParm( "-noip" ))

	push	OFFSET ??_C@_05NIHBOPJE@?9noip@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@NET_Init

; 1478 : 		net.allow_ip = false;

	mov	DWORD PTR _net+1115128, 0
	jmp	SHORT $LN9@NET_Init
$LN8@NET_Init:

; 1479 : 	else net.allow_ip = true;

	mov	DWORD PTR _net+1115128, 1
$LN9@NET_Init:

; 1480 : 
; 1481 : 	// specify custom host port
; 1482 : 	if( Sys_GetParmFromCmdLine( "-port", cmd ) && Q_isdigit( cmd ))

	push	64					; 00000040H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	push	OFFSET ??_C@_05HDLOEPOC@?9port@
	call	__Sys_GetParmFromCmdLine
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@NET_Init
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@NET_Init

; 1483 : 		Cvar_FullSet( "hostport", cmd, FCVAR_READ_ONLY );

	push	131072					; 00020000H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	push	OFFSET ??_C@_08DMAEPIMN@hostport@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN10@NET_Init:

; 1484 : 
; 1485 : 	// adjust clockwindow
; 1486 : 	if( Sys_GetParmFromCmdLine( "-clockwindow", cmd ))

	push	64					; 00000040H
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@HONPAMOD@?9clockwindow@
	call	__Sys_GetParmFromCmdLine
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@NET_Init

; 1487 : 		Cvar_SetValue( "clockwindow", Q_atof( cmd ));

	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_atof
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0M@POCMKHIF@clockwindow@
	call	_Cvar_SetValue
	add	esp, 8
$LN11@NET_Init:

; 1488 : 
; 1489 : 	net.sequence_number = 1;

	mov	DWORD PTR _net+1114708, 1

; 1490 : 	net.initialized = true;

	mov	DWORD PTR _net+1115120, 1

; 1491 : 	Con_Reportf( "Base networking initialized.\n" );

	push	OFFSET ??_C@_0BO@KLIIDKPD@Base?5networking?5initialized?4?6@
	call	_Con_Reportf
	add	esp, 4
$LN1@NET_Init:

; 1492 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_NET_Init ENDP
_TEXT	ENDS
END
