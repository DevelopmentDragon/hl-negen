; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_studio.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_R_StudioSetRemapColors
PUBLIC	_pfnPlayerInfo
PUBLIC	_R_StudioGetPlayerState
PUBLIC	_R_StudioDynamicLight
PUBLIC	_R_StudioEntityLight
PUBLIC	_R_StudioSetupLighting
PUBLIC	_R_StudioSetRenderamt
PUBLIC	_R_StudioSetCullState
PUBLIC	_R_StudioRenderShadow
PUBLIC	_R_StudioGetForceFaceFlags
PUBLIC	_R_StudioSetForceFaceFlags
PUBLIC	_R_StudioSetHeader
PUBLIC	_R_StudioSetRenderModel
PUBLIC	_R_StudioSetChromeOrigin
PUBLIC	_GL_StudioSetRenderMode
PUBLIC	_cl_righthand
PUBLIC	_r_glowshellfreq
PUBLIC	??_C@_0BA@JPIHAGPE@r_glowshellfreq@		; `string'
PUBLIC	??_C@_03FLDKCPFC@2?42@				; `string'
PUBLIC	??_C@_0BP@MIKEMGPC@glowing?5shell?5frequency?5update@ ; `string'
PUBLIC	_r_shadows
PUBLIC	??_C@_09EAFHGGLN@r_shadows@			; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BJ@HHDEOBE@cast?5shadows?5from?5models@	; `string'
EXTRN	_pfnCVarGetPointer:PROC
EXTRN	_Mod_Calloc:PROC
EXTRN	_Mod_CacheCheck:PROC
EXTRN	_Mod_LoadCacheFile:PROC
EXTRN	_Mod_StudioExtradata:PROC
EXTRN	_CL_ModelHandle:PROC
_BSS	SEGMENT
_cl_righthand DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_studio_sort_textures:DWORD
COMM	_r_drawviewmodel:DWORD
COMM	_cl_himodels:DWORD
COMM	_m_pSubModel:DWORD
COMM	_m_pBodyPart:DWORD
COMM	_m_pPlayerInfo:DWORD
COMM	_m_pStudioHeader:DWORD
COMM	_m_flGaitMovement:DWORD
COMM	_g_iBackFaceCull:DWORD
COMM	_g_nTopColor:DWORD
COMM	_g_nBottomColor:DWORD
COMM	_g_nFaceFlags:DWORD
COMM	_g_nForceFaceFlags:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HHDEOBE@cast?5shadows?5from?5models@
CONST	SEGMENT
??_C@_0BJ@HHDEOBE@cast?5shadows?5from?5models@ DB 'cast shadows from mode'
	DB	'ls', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09EAFHGGLN@r_shadows@
CONST	SEGMENT
??_C@_09EAFHGGLN@r_shadows@ DB 'r_shadows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MIKEMGPC@glowing?5shell?5frequency?5update@
CONST	SEGMENT
??_C@_0BP@MIKEMGPC@glowing?5shell?5frequency?5update@ DB 'glowing shell f'
	DB	'requency update', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLDKCPFC@2?42@
CONST	SEGMENT
??_C@_03FLDKCPFC@2?42@ DB '2.2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JPIHAGPE@r_glowshellfreq@
CONST	SEGMENT
??_C@_0BA@JPIHAGPE@r_glowshellfreq@ DB 'r_glowshellfreq', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_r_glowshellfreq DD FLAT:??_C@_0BA@JPIHAGPE@r_glowshellfreq@
	DD	FLAT:??_C@_03FLDKCPFC@2?42@
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BP@MIKEMGPC@glowing?5shell?5frequency?5update@
	ORG $+4
_r_shadows DD	FLAT:??_C@_09EAFHGGLN@r_shadows@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	00H
	DD	000000000r			; 0
	DD	0deadbeefH
	DD	FLAT:??_C@_0BJ@HHDEOBE@cast?5shadows?5from?5models@
	ORG $+4
_DATA	ENDS
PUBLIC	_R_StudioSlerpBones
PUBLIC	_R_StudioCalcBoneQuaternion
PUBLIC	_R_StudioCalcBonePosition
PUBLIC	_R_StudioGetAnim
PUBLIC	_Mod_StudioLoadTextures
PUBLIC	_Mod_StudioUnloadTextures
PUBLIC	_CL_InitStudioAPI
PUBLIC	_R_StudioInit
PUBLIC	_R_StudioLerpMovement
PUBLIC	_CL_GetSequenceDuration
PUBLIC	_R_StudioGetTexture
PUBLIC	_CL_GetStudioEstimatedFrame
PUBLIC	_R_GetEntityRenderMode
PUBLIC	_R_DrawStudioModel
PUBLIC	_R_GatherPlayerLight
PUBLIC	_R_RunViewmodelEvents
PUBLIC	_R_DrawViewModel
PUBLIC	_R_StudioComputeSkinMatrix
PUBLIC	_R_StudioPlayerBlend
PUBLIC	_R_StudioSetUpTransform
PUBLIC	_R_StudioEstimateFrame
PUBLIC	_R_StudioEstimateInterpolant
PUBLIC	_R_StudioFxTransform
PUBLIC	_R_StudioCalcBoneAdj
PUBLIC	_R_StudioCalcRotations
PUBLIC	_R_StudioMergeBones
PUBLIC	_R_StudioSetupBones
PUBLIC	_R_StudioBuildNormalTable
PUBLIC	_R_StudioGenerateNormals
PUBLIC	_R_StudioSetupChrome
PUBLIC	_R_StudioLighting
PUBLIC	_R_LightLambert
PUBLIC	_R_LightStrength
PUBLIC	_R_StudioRenderFinal
PUBLIC	_R_StudioRenderModel
PUBLIC	_R_StudioEstimateGait
PUBLIC	_R_StudioProcessGait
PUBLIC	_R_StudioDrawModelInternal
PUBLIC	??_C@_0DC@IAMPGLIE@draw?5high?9resolution?5player?5mod@ ; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0M@NHHOJIBJ@cl_himodels@			; `string'
PUBLIC	??_C@_0CG@OFCMNBJG@change?5draw?5order?5for?5additive?5@ ; `string'
PUBLIC	??_C@_0BH@GPOHDMMN@r_studio_sort_textures@	; `string'
PUBLIC	??_C@_0BO@JEINLOM@draw?5firstperson?5weapon?5model@ ; `string'
PUBLIC	??_C@_0BA@JMOPJIOD@r_drawviewmodel@		; `string'
PUBLIC	?__LINE__Var@?0??R_StudioGetAnim@@9@9		; `R_StudioGetAnim'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0O@GEDKBEHJ@?$CFs?1?$CFs?$CFi?$CFi?4mdl@	; `string'
PUBLIC	??_C@_0BO@HKBJCNDJ@StudioGetAnim?3?5can?8t?5load?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CA@PFOMPIEP@StudioGetAnim?3?5?$CFs?5is?5corrupted?6@ ; `string'
PUBLIC	??_C@_0N@FDHGFJAO@loading?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0M@ECGMMMKA@Bip01?5Spine@			; `string'
PUBLIC	??_C@_0N@OECCGFMA@Bip01?5Pelvis@		; `string'
PUBLIC	?__LINE__Var@?0??R_StudioBuildNormalTable@@9@9	; `R_StudioBuildNormalTable'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@LCGNDHPO@m_pSubModel?5?$CB?$DN?5NULL@	; `string'
PUBLIC	?__LINE__Var@?0??R_StudioGenerateNormals@@9@9	; `R_StudioGenerateNormals'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@FJCKJLAM@models?1player?1?$CFs?1?$CFs?4mdl@ ; `string'
PUBLIC	?__LINE__Var@?0??R_StudioLoadTexture@@9@9	; `R_StudioLoadTexture'::`1'::__LINE__Var
PUBLIC	??_C@_07JKJALO@DM_Base@				; `string'
PUBLIC	??_C@_05PGGDPNJE@remap@				; `string'
PUBLIC	??_C@_07DFGCBPGM@DM_User@			; `string'
PUBLIC	??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@	; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3b808081
PUBLIC	__real@3c000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e70f0f1
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f333333
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fa99999a0000000
PUBLIC	__real@3fb40000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fbdf3b6
PUBLIC	__real@3fbf5c29
PUBLIC	__real@3fc99999a0000000
PUBLIC	__real@3fd51eb860000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff004189374bc6a
PUBLIC	__real@40000000
PUBLIC	__real@400921fb60000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4066800000000000
PUBLIC	__real@4070000000000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40af400000000000
PUBLIC	__real@40c00000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41c00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@42800000
PUBLIC	__real@42f00000
PUBLIC	__real@43000000
PUBLIC	__real@43340000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43a00000
PUBLIC	__real@43b40000
PUBLIC	__real@44400000
PUBLIC	__real@45000000
PUBLIC	__real@45f00800
PUBLIC	__real@46000000
PUBLIC	__real@46040000
PUBLIC	__real@47800000
PUBLIC	__real@49742400
PUBLIC	__real@bc23d70a
PUBLIC	__real@bf800000
PUBLIC	__real@c1200000
PUBLIC	__real@c2800000
PUBLIC	__real@c2f00000
PUBLIC	__real@c3340000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	__imp__qsort:PROC
EXTRN	_abs:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_RegisterVariable:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_ExtractFilePath:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Host_IsLocalGame:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_IsThirdPerson:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_atan2:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_rsqrt:PROC
EXTRN	_HalfToFloat:PROC
EXTRN	_VectorCompareEpsilon:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_AngleQuaternion:PROC
EXTRN	_QuaternionAngle:PROC
EXTRN	_QuaternionSlerp:PROC
EXTRN	_Matrix3x4_VectorTransform:PROC
EXTRN	_Matrix3x4_VectorITransform:PROC
EXTRN	_Matrix3x4_VectorRotate:PROC
EXTRN	_Matrix3x4_VectorIRotate:PROC
EXTRN	_Matrix3x4_ConcatTransforms:PROC
EXTRN	_Matrix3x4_FromOriginQuat:PROC
EXTRN	_Matrix3x4_CreateFromEntity:PROC
EXTRN	_Matrix3x4_OriginFromMatrix:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_GetRemapInfoForEntity:PROC
EXTRN	_CL_AllocRemapInfo:PROC
EXTRN	_CL_UpdateRemapInfo:PROC
EXTRN	_CL_FxBlend:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_R_CullModel:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_LightVec:PROC
EXTRN	_R_LightPoint:PROC
EXTRN	_R_AllowFog:PROC
EXTRN	_R_DrawAliasModel:PROC
EXTRN	_CL_AllocElight:PROC
EXTRN	_TriBegin:PROC
EXTRN	_TriVertex3fv:PROC
EXTRN	_TriColor4f:PROC
EXTRN	_TriSpriteTexture:PROC
EXTRN	_TriColor4ub:PROC
EXTRN	_TriBrightness:PROC
EXTRN	_TriRenderMode:PROC
EXTRN	_TriEnd:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_boxpnt:BYTE
EXTRN	_matrix3x4_identity:BYTE
EXTRN	_com_studiocache:DWORD
EXTRN	_cl:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_gldepthmin:DWORD
EXTRN	_gldepthmax:DWORD
EXTRN	_cl_dlights:BYTE
EXTRN	_cl_elights:BYTE
EXTRN	_glState:BYTE
EXTRN	_r_fullbright:DWORD
EXTRN	_r_drawentities:DWORD
EXTRN	_r_dynamic:DWORD
EXTRN	_r_lightmap:DWORD
EXTRN	_cl_sprite_shell:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_pStudioDraw DD	01H DUP (?)
_g_studio DB	01cbec0H DUP (?)
_m_fDoRemap DD	01H DUP (?)
?q@?1??R_StudioMergeBones@@9@9 DD 0200H DUP (?)		; `R_StudioMergeBones'::`2'::q
?pos@?1??R_StudioMergeBones@@9@9 DD 0180H DUP (?)	; `R_StudioMergeBones'::`2'::pos
?pos@?1??R_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `R_StudioSetupBones'::`2'::pos
?q@?1??R_StudioSetupBones@@9@9 DD 0200H DUP (?)		; `R_StudioSetupBones'::`2'::q
?pos2@?1??R_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `R_StudioSetupBones'::`2'::pos2
?q2@?1??R_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `R_StudioSetupBones'::`2'::q2
?pos3@?1??R_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `R_StudioSetupBones'::`2'::pos3
?q3@?1??R_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `R_StudioSetupBones'::`2'::q3
?pos4@?1??R_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `R_StudioSetupBones'::`2'::pos4
?q4@?1??R_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `R_StudioSetupBones'::`2'::q4
?pos1b@?4??R_StudioSetupBones@@9@9 DD 0180H DUP (?)	; `R_StudioSetupBones'::`5'::pos1b
?q1b@?4??R_StudioSetupBones@@9@9 DD 0200H DUP (?)	; `R_StudioSetupBones'::`5'::q1b
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c3340000
CONST	SEGMENT
__real@c3340000 DD 0c3340000r			; -180
CONST	ENDS
;	COMDAT __real@c2f00000
CONST	SEGMENT
__real@c2f00000 DD 0c2f00000r			; -120
CONST	ENDS
;	COMDAT __real@c2800000
CONST	SEGMENT
__real@c2800000 DD 0c2800000r			; -64
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bc23d70a
CONST	SEGMENT
__real@bc23d70a DD 0bc23d70ar			; -0.01
CONST	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+06
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@46040000
CONST	SEGMENT
__real@46040000 DD 046040000r			; 8448
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@45f00800
CONST	SEGMENT
__real@45f00800 DD 045f00800r			; 7681
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@44400000
CONST	SEGMENT
__real@44400000 DD 044400000r			; 768
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43a00000
CONST	SEGMENT
__real@43a00000 DD 043a00000r			; 320
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40af400000000000
CONST	SEGMENT
__real@40af400000000000 DQ 040af400000000000r	; 4000
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@400921fb60000000
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff004189374bc6a
CONST	SEGMENT
__real@3ff004189374bc6a DQ 03ff004189374bc6ar	; 1.001
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd51eb860000000
CONST	SEGMENT
__real@3fd51eb860000000 DQ 03fd51eb860000000r	; 0.33
CONST	ENDS
;	COMDAT __real@3fc99999a0000000
CONST	SEGMENT
__real@3fc99999a0000000 DQ 03fc99999a0000000r	; 0.2
CONST	ENDS
;	COMDAT __real@3fbf5c29
CONST	SEGMENT
__real@3fbf5c29 DD 03fbf5c29r			; 1.495
CONST	ENDS
;	COMDAT __real@3fbdf3b6
CONST	SEGMENT
__real@3fbdf3b6 DD 03fbdf3b6r			; 1.484
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3fa99999a0000000
CONST	SEGMENT
__real@3fa99999a0000000 DQ 03fa99999a0000000r	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e70f0f1
CONST	SEGMENT
__real@3e70f0f1 DD 03e70f0f1r			; 0.235294
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3c000000
CONST	SEGMENT
__real@3c000000 DD 03c000000r			; 0.0078125
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@
CONST	SEGMENT
??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@ DB '#%s/%s.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFGCBPGM@DM_User@
CONST	SEGMENT
??_C@_07DFGCBPGM@DM_User@ DB 'DM_User', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PGGDPNJE@remap@
CONST	SEGMENT
??_C@_05PGGDPNJE@remap@ DB 'remap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKJALO@DM_Base@
CONST	SEGMENT
??_C@_07JKJALO@DM_Base@ DB 'DM_Base', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_StudioLoadTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_StudioLoadTexture@@9@9 DD 0ed0H	; `R_StudioLoadTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@FJCKJLAM@models?1player?1?$CFs?1?$CFs?4mdl@
CONST	SEGMENT
??_C@_0BI@FJCKJLAM@models?1player?1?$CFs?1?$CFs?4mdl@ DB 'models/player/%'
	DB	's/%s.mdl', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_StudioGenerateNormals@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_StudioGenerateNormals@@9@9 DD 0588H	; `R_StudioGenerateNormals'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@LCGNDHPO@m_pSubModel?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BE@LCGNDHPO@m_pSubModel?5?$CB?$DN?5NULL@ DB 'm_pSubModel != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_StudioBuildNormalTable@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_StudioBuildNormalTable@@9@9 DD 0555H	; `R_StudioBuildNormalTable'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@OECCGFMA@Bip01?5Pelvis@
CONST	SEGMENT
??_C@_0N@OECCGFMA@Bip01?5Pelvis@ DB 'Bip01 Pelvis', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ECGMMMKA@Bip01?5Spine@
CONST	SEGMENT
??_C@_0M@ECGMMMKA@Bip01?5Spine@ DB 'Bip01 Spine', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDHGFJAO@loading?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0N@FDHGFJAO@loading?3?5?$CFs?6@ DB 'loading: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PFOMPIEP@StudioGetAnim?3?5?$CFs?5is?5corrupted?6@
CONST	SEGMENT
??_C@_0CA@PFOMPIEP@StudioGetAnim?3?5?$CFs?5is?5corrupted?6@ DB 'StudioGet'
	DB	'Anim: %s is corrupted', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HKBJCNDJ@StudioGetAnim?3?5can?8t?5load?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@HKBJCNDJ@StudioGetAnim?3?5can?8t?5load?5?$CFs?6@ DB 'StudioGetA'
	DB	'nim: can''t load %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GEDKBEHJ@?$CFs?1?$CFs?$CFi?$CFi?4mdl@
CONST	SEGMENT
??_C@_0O@GEDKBEHJ@?$CFs?1?$CFs?$CFi?$CFi?4mdl@ DB '%s/%s%i%i.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_studio.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_StudioGetAnim@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_StudioGetAnim@@9@9 DD 02d8H		; `R_StudioGetAnim'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@JMOPJIOD@r_drawviewmodel@
CONST	SEGMENT
??_C@_0BA@JMOPJIOD@r_drawviewmodel@ DB 'r_drawviewmodel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JEINLOM@draw?5firstperson?5weapon?5model@
CONST	SEGMENT
??_C@_0BO@JEINLOM@draw?5firstperson?5weapon?5model@ DB 'draw firstperson '
	DB	'weapon model', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPOHDMMN@r_studio_sort_textures@
CONST	SEGMENT
??_C@_0BH@GPOHDMMN@r_studio_sort_textures@ DB 'r_studio_sort_textures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFCMNBJG@change?5draw?5order?5for?5additive?5@
CONST	SEGMENT
??_C@_0CG@OFCMNBJG@change?5draw?5order?5for?5additive?5@ DB 'change draw '
	DB	'order for additive meshes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHHOJIBJ@cl_himodels@
CONST	SEGMENT
??_C@_0M@NHHOJIBJ@cl_himodels@ DB 'cl_himodels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IAMPGLIE@draw?5high?9resolution?5player?5mod@
CONST	SEGMENT
??_C@_0DC@IAMPGLIE@draw?5high?9resolution?5player?5mod@ DB 'draw high-res'
	DB	'olution player models in multiplayer', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_hullcolor DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
_gStudioAPI DD	FLAT:_Mod_Calloc
	DD	FLAT:_Mod_CacheCheck
	DD	FLAT:_Mod_LoadCacheFile
	DD	FLAT:_pfnMod_ForName
	DD	FLAT:_Mod_StudioExtradata
	DD	FLAT:_CL_ModelHandle
	DD	FLAT:_pfnGetCurrentEntity
	DD	FLAT:_pfnPlayerInfo
	DD	FLAT:_R_StudioGetPlayerState
	DD	FLAT:_pfnGetViewEntity
	DD	FLAT:_pfnGetEngineTimes
	DD	FLAT:_pfnCVarGetPointer
	DD	FLAT:_pfnGetViewInfo
	DD	FLAT:_R_GetChromeSprite
	DD	FLAT:_pfnGetModelCounters
	DD	FLAT:_pfnGetAliasScale
	DD	FLAT:_pfnStudioGetBoneTransform
	DD	FLAT:_pfnStudioGetLightTransform
	DD	FLAT:_pfnStudioGetAliasTransform
	DD	FLAT:_pfnStudioGetRotationMatrix
	DD	FLAT:_R_StudioSetupModel
	DD	FLAT:_R_StudioCheckBBox
	DD	FLAT:_R_StudioDynamicLight
	DD	FLAT:_R_StudioEntityLight
	DD	FLAT:_R_StudioSetupLighting
	DD	FLAT:_R_StudioDrawPoints
	DD	FLAT:_R_StudioDrawHulls
	DD	FLAT:_R_StudioDrawAbsBBox
	DD	FLAT:_R_StudioDrawBones
	DD	FLAT:_R_StudioSetupSkin
	DD	FLAT:_R_StudioSetRemapColors
	DD	FLAT:_R_StudioSetupPlayerModel
	DD	FLAT:_R_StudioClientEvents
	DD	FLAT:_R_StudioGetForceFaceFlags
	DD	FLAT:_R_StudioSetForceFaceFlags
	DD	FLAT:_R_StudioSetHeader
	DD	FLAT:_R_StudioSetRenderModel
	DD	FLAT:_R_StudioSetupRenderer
	DD	FLAT:_R_StudioRestoreRenderer
	DD	FLAT:_R_StudioSetChromeOrigin
	DD	FLAT:_pfnIsHardware
	DD	FLAT:_GL_StudioDrawShadow
	DD	FLAT:_GL_StudioSetRenderMode
	DD	FLAT:_R_StudioSetRenderamt
	DD	FLAT:_R_StudioSetCullState
	DD	FLAT:_R_StudioRenderShadow
_gStudioDraw DD	01H
	DD	FLAT:_R_StudioDrawModel
	DD	FLAT:_R_StudioDrawPlayer
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04b7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0338H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0581H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	04d0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0349H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	025cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0357H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0225H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0409H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	08edH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0324H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	068dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0479H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01847H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0313H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0798H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0d0aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	09d2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	025eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01c4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0222H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03b1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03d1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	074H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0289H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	020fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03f0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0333H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioLoadTexture
_TEXT	SEGMENT
tv206 = -492						; size = 4
tv190 = -492						; size = 4
tv174 = -492						; size = 4
tv205 = -488						; size = 4
tv189 = -488						; size = 4
tv173 = -488						; size = 4
_pixels$1 = -420					; size = 4
_val$2 = -416						; size = 6
_size$3 = -408						; size = 4
_i$4 = -404						; size = 4
_tx$ = -400						; size = 4
_mdlname$ = -396					; size = 128
_name$ = -268						; size = 128
_texname$ = -140					; size = 128
_flags$ = -12						; size = 4
_size$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_phdr$ = 12						; size = 4
_ptexture$ = 16						; size = 4
_R_StudioLoadTexture PROC				; COMDAT

; 3792 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 492				; 000001ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3793 : 	size_t		size;
; 3794 : 	int		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 3795 : 	char		texname[128], name[128], mdlname[128];
; 3796 : 	texture_t		*tx = NULL;

	mov	DWORD PTR _tx$[ebp], 0

; 3797 : 	
; 3798 : 	if( ptexture->flags & STUDIO_NF_NORMALMAP )

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 128				; 00000080H
	je	SHORT $LN2@R_StudioLo

; 3799 : 		flags |= (TF_NORMALMAP);

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 32768				; 00008000H
	mov	DWORD PTR _flags$[ebp], eax
$LN2@R_StudioLo:

; 3800 : 
; 3801 : 	// store some textures for remapping
; 3802 : 	if( !Q_strnicmp( ptexture->name, "DM_Base", 7 ) || !Q_strnicmp( ptexture->name, "remap", 5 ))

	push	7
	push	OFFSET ??_C@_07JKJALO@DM_Base@
	mov	eax, DWORD PTR _ptexture$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@R_StudioLo
	push	5
	push	OFFSET ??_C@_05PGGDPNJE@remap@
	mov	eax, DWORD PTR _ptexture$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN3@R_StudioLo
$LN4@R_StudioLo:

; 3803 : 	{
; 3804 : 		int	i, size;
; 3805 : 		char	val[6];
; 3806 : 		byte	*pixels;
; 3807 : 
; 3808 : 		i = mod->numtextures;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+368]
	mov	DWORD PTR _i$4[ebp], ecx

; 3809 : 		mod->textures = (texture_t **)Mem_Realloc( mod->mempool, mod->textures, ( i + 1 ) * sizeof( texture_t* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioLoadTexture@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _i$4[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 3810 : 		size = ptexture->width * ptexture->height + 768;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [eax+68]
	imul	edx, DWORD PTR [ecx+72]
	add	edx, 768				; 00000300H
	mov	DWORD PTR _size$3[ebp], edx

; 3811 : 		tx = Mem_Calloc( mod->mempool, sizeof( *tx ) + size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioLoadTexture@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$3[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$[ebp], eax

; 3812 : 		mod->textures[i] = tx;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3813 : 
; 3814 : 		// store ranges into anim_min, anim_max etc
; 3815 : 		if( !Q_strnicmp( ptexture->name, "DM_Base", 7 ))

	push	7
	push	OFFSET ??_C@_07JKJALO@DM_Base@
	mov	eax, DWORD PTR _ptexture$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@R_StudioLo

; 3816 : 		{
; 3817 : 			Q_strncpy( tx->name, "DM_Base", sizeof( tx->name ));

	push	16					; 00000010H
	push	OFFSET ??_C@_07JKJALO@DM_Base@
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3818 : 			tx->anim_min = PLATE_HUE_START; // topcolor start

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+36], 160			; 000000a0H

; 3819 : 			tx->anim_max = PLATE_HUE_END; // topcolor end

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+40], 191			; 000000bfH

; 3820 : 			// bottomcolor start always equal is (topcolor end + 1)
; 3821 : 			tx->anim_total = SUIT_HUE_END;// bottomcolor end 

	mov	eax, DWORD PTR _tx$[ebp]
	mov	DWORD PTR [eax+32], 223			; 000000dfH

; 3822 : 		}

	jmp	$LN6@R_StudioLo
$LN5@R_StudioLo:

; 3823 : 		else
; 3824 : 		{
; 3825 : 			Q_strncpy( tx->name, "DM_User", sizeof( tx->name )); // custom remapped

	push	16					; 00000010H
	push	OFFSET ??_C@_07DFGCBPGM@DM_User@
	mov	eax, DWORD PTR _tx$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3826 : 			Q_strncpy( val, ptexture->name + 7, 4 );  

	push	4
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, 7
	push	eax
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3827 : 			tx->anim_min = bound( 0, Q_atoi( val ), 255 ); // topcolor start

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN15@R_StudioLo
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN13@R_StudioLo
	lea	edx, DWORD PTR _val$2[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN14@R_StudioLo
$LN13@R_StudioLo:
	mov	DWORD PTR tv173[ebp], 255		; 000000ffH
$LN14@R_StudioLo:
	mov	eax, DWORD PTR tv173[ebp]
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN16@R_StudioLo
$LN15@R_StudioLo:
	mov	DWORD PTR tv174[ebp], 0
$LN16@R_StudioLo:
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR [ecx+36], edx

; 3828 : 			Q_strncpy( val, ptexture->name + 11, 4 ); 

	push	4
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3829 : 			tx->anim_max = bound( 0, Q_atoi( val ), 255 ); // topcolor end

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN19@R_StudioLo
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN17@R_StudioLo
	lea	edx, DWORD PTR _val$2[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN18@R_StudioLo
$LN17@R_StudioLo:
	mov	DWORD PTR tv189[ebp], 255		; 000000ffH
$LN18@R_StudioLo:
	mov	eax, DWORD PTR tv189[ebp]
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN20@R_StudioLo
$LN19@R_StudioLo:
	mov	DWORD PTR tv190[ebp], 0
$LN20@R_StudioLo:
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR [ecx+40], edx

; 3830 : 			// bottomcolor start always equal is (topcolor end + 1)
; 3831 : 			Q_strncpy( val, ptexture->name + 15, 4 ); 

	push	4
	mov	eax, DWORD PTR _ptexture$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3832 : 			tx->anim_total = bound( 0, Q_atoi( val ), 255 ); // bottomcolor end

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN23@R_StudioLo
	lea	ecx, DWORD PTR _val$2[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN21@R_StudioLo
	lea	edx, DWORD PTR _val$2[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv205[ebp], eax
	jmp	SHORT $LN22@R_StudioLo
$LN21@R_StudioLo:
	mov	DWORD PTR tv205[ebp], 255		; 000000ffH
$LN22@R_StudioLo:
	mov	eax, DWORD PTR tv205[ebp]
	mov	DWORD PTR tv206[ebp], eax
	jmp	SHORT $LN24@R_StudioLo
$LN23@R_StudioLo:
	mov	DWORD PTR tv206[ebp], 0
$LN24@R_StudioLo:
	mov	ecx, DWORD PTR _tx$[ebp]
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN6@R_StudioLo:

; 3833 : 		}
; 3834 : 
; 3835 : 		tx->width = ptexture->width;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+16], edx

; 3836 : 		tx->height = ptexture->height;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+20], edx

; 3837 : 
; 3838 : 		// the pixels immediately follow the structures
; 3839 : 		pixels = (byte *)phdr + ptexture->index;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _pixels$1[ebp], ecx

; 3840 : 		memcpy( tx+1, pixels, size );

	mov	eax, DWORD PTR _size$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pixels$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _tx$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3841 : 
; 3842 : 		ptexture->flags |= STUDIO_NF_COLORMAP;	// yes, this is colormap image

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 3843 : 		flags |= TF_FORCE_COLOR;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 131072				; 00020000H
	mov	DWORD PTR _flags$[ebp], eax

; 3844 : 
; 3845 : 		mod->numtextures++;	// done

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+368]
	add	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+368], ecx
$LN3@R_StudioLo:

; 3846 : 	}
; 3847 : 
; 3848 : 	Q_strncpy( mdlname, mod->name, sizeof( mdlname ));

	push	128					; 00000080H
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mdlname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3849 : 	COM_FileBase( ptexture->name, name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptexture$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 3850 : 	COM_StripExtension( mdlname );

	lea	eax, DWORD PTR _mdlname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 3851 : 
; 3852 : 	if( FBitSet( ptexture->flags, STUDIO_NF_NOMIPS ))

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 8
	je	SHORT $LN7@R_StudioLo

; 3853 : 		SetBits( flags, TF_NOMIPMAP );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 4096				; 00001000H
	mov	DWORD PTR _flags$[ebp], eax
$LN7@R_StudioLo:

; 3854 : 
; 3855 : 	// NOTE: replace index with pointer to start of imagebuffer, ImageLib expected it
; 3856 : 	ptexture->index = (int)((byte *)phdr) + ptexture->index;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [edx+76], ecx

; 3857 : 	size = sizeof( mstudiotexture_t ) + ptexture->width * ptexture->height + 768;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [eax+68]
	imul	edx, DWORD PTR [ecx+72]
	add	edx, 848				; 00000350H
	mov	DWORD PTR _size$[ebp], edx

; 3858 : 
; 3859 : 	if( FBitSet( host.features, ENGINE_LOAD_DELUXEDATA ) && FBitSet( ptexture->flags, STUDIO_NF_MASKED ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 4
	je	SHORT $LN8@R_StudioLo
	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 64					; 00000040H
	je	SHORT $LN8@R_StudioLo

; 3860 : 		flags |= TF_KEEP_SOURCE; // Paranoia2 texture alpha-tracing

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 2
	mov	DWORD PTR _flags$[ebp], eax
$LN8@R_StudioLo:

; 3861 : 
; 3862 : 	// build the texname
; 3863 : 	Q_snprintf( texname, sizeof( texname ), "#%s/%s.mdl", mdlname, name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mdlname$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@OKBCHAAD@?$CD?$CFs?1?$CFs?4mdl@
	push	128					; 00000080H
	lea	edx, DWORD PTR _texname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 3864 : 	ptexture->index = GL_LoadTexture( texname, (byte *)ptexture, size, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptexture$[ebp]
	push	edx
	lea	eax, DWORD PTR _texname$[ebp]
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 3865 : 
; 3866 : 	if( !ptexture->index )

	mov	eax, DWORD PTR _ptexture$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN9@R_StudioLo

; 3867 : 	{
; 3868 : 		ptexture->index = tr.defaultTexture;

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR _tr
	mov	DWORD PTR [eax+76], ecx

; 3869 : 	}

	jmp	SHORT $LN1@R_StudioLo
$LN9@R_StudioLo:

; 3870 : 	else if( tx )

	cmp	DWORD PTR _tx$[ebp], 0
	je	SHORT $LN1@R_StudioLo

; 3871 : 	{
; 3872 : 		// duplicate texnum for easy acess 
; 3873 : 		tx->gl_texturenum = ptexture->index;

	mov	eax, DWORD PTR _tx$[ebp]
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+24], edx
$LN1@R_StudioLo:

; 3874 : 	}
; 3875 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioLoadTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawModelInternal
_TEXT	SEGMENT
_e$ = 8							; size = 4
_flags$ = 12						; size = 4
_R_StudioDrawModelInternal PROC				; COMDAT

; 3567 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3568 : 	if( !RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN2@R_StudioDr

; 3569 : 	{
; 3570 : 		if( e->player )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@R_StudioDr

; 3571 : 			R_StudioDrawPlayer( flags, &e->curstate );

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 912				; 00000390H
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	call	_R_StudioDrawPlayer
	add	esp, 8
	jmp	SHORT $LN5@R_StudioDr
$LN4@R_StudioDr:

; 3572 : 		else R_StudioDrawModel( flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	call	_R_StudioDrawModel
	add	esp, 4
$LN5@R_StudioDr:

; 3573 : 	}

	jmp	SHORT $LN1@R_StudioDr
$LN2@R_StudioDr:

; 3574 : 	else
; 3575 : 	{
; 3576 : 		// select the properly method
; 3577 : 		if( e->player )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@R_StudioDr

; 3578 : 			pStudioDraw->StudioDrawPlayer( flags, R_StudioGetPlayerState( e->index - 1 ));

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	push	ecx
	call	_R_StudioGetPlayerState
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _pStudioDraw
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	add	esp, 8
	jmp	SHORT $LN1@R_StudioDr
$LN6@R_StudioDr:

; 3579 : 		else pStudioDraw->StudioDrawModel( flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStudioDraw
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 4
$LN1@R_StudioDr:

; 3580 : 	}
; 3581 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawModelInternal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawModel
_TEXT	SEGMENT
_ent$1 = -500						; size = 4
_result$2 = -496					; size = 4
_deadplayer$3 = -492					; size = 452
_dir$ = -40						; size = 12
_lighting$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
_R_StudioDrawModel PROC					; COMDAT

; 3472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 564				; 00000234H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3473 : 	alight_t	lighting;
; 3474 : 	vec3_t	dir;
; 3475 : 
; 3476 : 	if( RI.currententity->curstate.renderfx == kRenderFxDeadPlayer )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+996], 17			; 00000011H
	jne	$LN2@R_StudioDr

; 3477 : 	{
; 3478 : 		entity_state_t	deadplayer;
; 3479 : 		int		result;
; 3480 : 
; 3481 : 		if( RI.currententity->curstate.renderamt <= 0 || RI.currententity->curstate.renderamt > cl.maxclients )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+988], 0
	jle	SHORT $LN4@R_StudioDr
	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+988]
	cmp	ecx, DWORD PTR _cl+2213004
	jle	SHORT $LN3@R_StudioDr
$LN4@R_StudioDr:

; 3482 : 			return 0;

	xor	eax, eax
	jmp	$LN1@R_StudioDr
$LN3@R_StudioDr:

; 3483 : 
; 3484 : 		// get copy of player
; 3485 : 		deadplayer = *R_StudioGetPlayerState( RI.currententity->curstate.renderamt - 1 );

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+988]
	sub	ecx, 1
	push	ecx
	call	_R_StudioGetPlayerState
	add	esp, 4
	mov	ecx, 113				; 00000071H
	mov	esi, eax
	lea	edi, DWORD PTR _deadplayer$3[ebp]
	rep movsd

; 3486 : 
; 3487 : 		// clear weapon, movement state
; 3488 : 		deadplayer.number = RI.currententity->curstate.renderamt;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _deadplayer$3[ebp+4], ecx

; 3489 : 		deadplayer.weaponmodel = 0;

	mov	DWORD PTR _deadplayer$3[ebp+292], 0

; 3490 : 		deadplayer.gaitsequence = 0;

	mov	DWORD PTR _deadplayer$3[ebp+296], 0

; 3491 : 
; 3492 : 		deadplayer.movetype = MOVETYPE_NONE;

	mov	DWORD PTR _deadplayer$3[ebp+88], 0

; 3493 : 		VectorCopy( RI.currententity->curstate.angles, deadplayer.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [edx+ecx+940]
	mov	DWORD PTR _deadplayer$3[ebp+eax+28], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+edx+940]
	mov	DWORD PTR _deadplayer$3[ebp+eax+28], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	eax, DWORD PTR [edx+eax+940]
	mov	DWORD PTR _deadplayer$3[ebp+ecx+28], eax

; 3494 : 		VectorCopy( RI.currententity->curstate.origin, deadplayer.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [edx+ecx+928]
	mov	DWORD PTR _deadplayer$3[ebp+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+edx+928]
	mov	DWORD PTR _deadplayer$3[ebp+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	eax, DWORD PTR [edx+eax+928]
	mov	DWORD PTR _deadplayer$3[ebp+ecx+16], eax

; 3495 : 
; 3496 : 		g_studio.interpolate = false;

	mov	DWORD PTR _g_studio+20, 0

; 3497 : 		result = R_StudioDrawPlayer( flags, &deadplayer ); // draw as though it were a player

	lea	eax, DWORD PTR _deadplayer$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	call	_R_StudioDrawPlayer
	add	esp, 8
	mov	DWORD PTR _result$2[ebp], eax

; 3498 : 		g_studio.interpolate = true;

	mov	DWORD PTR _g_studio+20, 1

; 3499 : 
; 3500 : 		return result;

	mov	eax, DWORD PTR _result$2[ebp]
	jmp	$LN1@R_StudioDr
$LN2@R_StudioDr:

; 3501 : 	}
; 3502 : 
; 3503 : 	R_StudioSetHeader((studiohdr_t *)Mod_StudioExtradata( RI.currentmodel ));

	mov	eax, DWORD PTR _RI+32
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	push	eax
	call	_R_StudioSetHeader
	add	esp, 4

; 3504 : 
; 3505 : 	R_StudioSetUpTransform( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetUpTransform
	add	esp, 4

; 3506 : 
; 3507 : 	if( flags & STUDIO_RENDER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN7@R_StudioDr

; 3508 : 	{
; 3509 : 		// see if the bounding box lets us trivially reject, also sets
; 3510 : 		if( !R_StudioCheckBBox( ))

	call	_R_StudioCheckBBox
	test	eax, eax
	jne	SHORT $LN6@R_StudioDr

; 3511 : 			return 0;

	xor	eax, eax
	jmp	$LN1@R_StudioDr
$LN6@R_StudioDr:

; 3512 : 
; 3513 : 		r_stats.c_studio_models_drawn++;

	mov	eax, DWORD PTR _r_stats+32
	add	eax, 1
	mov	DWORD PTR _r_stats+32, eax

; 3514 : 		g_studio.framecount++; // render data cache cookie

	mov	eax, DWORD PTR _g_studio+16
	add	eax, 1
	mov	DWORD PTR _g_studio+16, eax

; 3515 : 
; 3516 : 		if( m_pStudioHeader->numbodyparts == 0 )

	mov	eax, DWORD PTR _m_pStudioHeader
	cmp	DWORD PTR [eax+204], 0
	jne	SHORT $LN7@R_StudioDr

; 3517 : 			return 1;

	mov	eax, 1
	jmp	$LN1@R_StudioDr
$LN7@R_StudioDr:

; 3518 : 	}
; 3519 : 
; 3520 : 	if( RI.currententity->curstate.movetype == MOVETYPE_FOLLOW )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1000], 12		; 0000000cH
	jne	SHORT $LN8@R_StudioDr

; 3521 : 		R_StudioMergeBones( RI.currententity, RI.currentmodel );

	mov	eax, DWORD PTR _RI+32
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioMergeBones
	add	esp, 8
	jmp	SHORT $LN9@R_StudioDr
$LN8@R_StudioDr:

; 3522 : 	else R_StudioSetupBones( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetupBones
	add	esp, 4
$LN9@R_StudioDr:

; 3523 : 
; 3524 : 	R_StudioSaveBones();

	call	_R_StudioSaveBones

; 3525 : 
; 3526 : 	if( flags & STUDIO_EVENTS )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN11@R_StudioDr

; 3527 : 	{
; 3528 : 		R_StudioCalcAttachments( );

	call	_R_StudioCalcAttachments

; 3529 : 		R_StudioClientEvents( );

	call	_R_StudioClientEvents

; 3530 : 
; 3531 : 		// copy attachments into global entity array
; 3532 : 		if( RI.currententity->index > 0 )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN11@R_StudioDr

; 3533 : 		{
; 3534 : 			cl_entity_t *ent = CL_GetEntityByIndex( RI.currententity->index );

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$1[ebp], eax

; 3535 : 			memcpy( ent->attachment, RI.currententity->attachment, sizeof( vec3_t ) * 4 );

	push	48					; 00000030H
	mov	eax, DWORD PTR _RI+28
	add	eax, 3248				; 00000cb0H
	push	eax
	mov	ecx, DWORD PTR _ent$1[ebp]
	add	ecx, 3248				; 00000cb0H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN11@R_StudioDr:

; 3536 : 		}
; 3537 : 	}
; 3538 : 
; 3539 : 	if( flags & STUDIO_RENDER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN12@R_StudioDr

; 3540 : 	{
; 3541 : 		lighting.plightvec = dir;

	lea	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR _lighting$[ebp+20], eax

; 3542 : 		R_StudioDynamicLight( RI.currententity, &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioDynamicLight
	add	esp, 8

; 3543 : 
; 3544 : 		R_StudioEntityLight( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_StudioEntityLight
	add	esp, 4

; 3545 : 
; 3546 : 		// model and frame independant
; 3547 : 		R_StudioSetupLighting( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_StudioSetupLighting
	add	esp, 4

; 3548 : 
; 3549 : 		// get remap colors
; 3550 : 		g_nTopColor = RI.currententity->curstate.colormap & 0xFF;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _g_nTopColor, ecx

; 3551 : 		g_nBottomColor = (RI.currententity->curstate.colormap & 0xFF00) >> 8;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+964]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	mov	DWORD PTR _g_nBottomColor, ecx

; 3552 : 
; 3553 : 		R_StudioSetRemapColors( g_nTopColor, g_nBottomColor );

	mov	eax, DWORD PTR _g_nBottomColor
	push	eax
	mov	ecx, DWORD PTR _g_nTopColor
	push	ecx
	call	_R_StudioSetRemapColors
	add	esp, 8

; 3554 : 
; 3555 : 		R_StudioRenderModel();

	call	_R_StudioRenderModel
$LN12@R_StudioDr:

; 3556 : 	}
; 3557 : 
; 3558 : 	return 1;

	mov	eax, 1
$LN1@R_StudioDr:

; 3559 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawPlayer
_TEXT	SEGMENT
_pweaponmodel$1 = -3400					; size = 4
_saveent$2 = -3396					; size = 3336
_ent$3 = -60						; size = 4
_orig_angles$4 = -56					; size = 12
_dir$ = -44						; size = 12
_lighting$ = -32					; size = 24
_m_nPlayerIndex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
_pplayer$ = 12						; size = 4
_R_StudioDrawPlayer PROC				; COMDAT

; 3330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3848				; 00000f08H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3331 : 	int	m_nPlayerIndex;
; 3332 : 	alight_t	lighting;
; 3333 : 	vec3_t	dir;
; 3334 : 
; 3335 : 	m_nPlayerIndex = pplayer->number - 1;

	mov	eax, DWORD PTR _pplayer$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	DWORD PTR _m_nPlayerIndex$[ebp], ecx

; 3336 : 
; 3337 : 	if( m_nPlayerIndex < 0 || m_nPlayerIndex >= cl.maxclients )

	js	SHORT $LN3@R_StudioDr
	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jl	SHORT $LN2@R_StudioDr
$LN3@R_StudioDr:

; 3338 : 		return 0;

	xor	eax, eax
	jmp	$LN1@R_StudioDr
$LN2@R_StudioDr:

; 3339 : 
; 3340 : 	RI.currentmodel = R_StudioSetupPlayerModel( m_nPlayerIndex );

	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	push	eax
	call	_R_StudioSetupPlayerModel
	add	esp, 4
	mov	DWORD PTR _RI+32, eax

; 3341 : 	if( RI.currentmodel == NULL )

	cmp	DWORD PTR _RI+32, 0
	jne	SHORT $LN4@R_StudioDr

; 3342 : 		return 0;

	xor	eax, eax
	jmp	$LN1@R_StudioDr
$LN4@R_StudioDr:

; 3343 : 
; 3344 : 	R_StudioSetHeader((studiohdr_t *)Mod_StudioExtradata( RI.currentmodel ));

	mov	eax, DWORD PTR _RI+32
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	push	eax
	call	_R_StudioSetHeader
	add	esp, 4

; 3345 : 
; 3346 : 	if( pplayer->gaitsequence )

	mov	eax, DWORD PTR _pplayer$[ebp]
	cmp	DWORD PTR [eax+296], 0
	je	$LN5@R_StudioDr

; 3347 : 	{
; 3348 : 		vec3_t orig_angles;
; 3349 : 
; 3350 : 		m_pPlayerInfo = pfnPlayerInfo( m_nPlayerIndex );

	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	push	eax
	call	_pfnPlayerInfo
	add	esp, 4
	mov	DWORD PTR _m_pPlayerInfo, eax

; 3351 : 		VectorCopy( RI.currententity->angles, orig_angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [edx+ecx+3236]
	mov	DWORD PTR _orig_angles$4[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+edx+3236]
	mov	DWORD PTR _orig_angles$4[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	eax, DWORD PTR [edx+eax+3236]
	mov	DWORD PTR _orig_angles$4[ebp+ecx], eax

; 3352 : 	
; 3353 : 		R_StudioProcessGait( pplayer );

	mov	eax, DWORD PTR _pplayer$[ebp]
	push	eax
	call	_R_StudioProcessGait
	add	esp, 4

; 3354 : 
; 3355 : 		m_pPlayerInfo->gaitsequence = pplayer->gaitsequence;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR _pplayer$[ebp]
	mov	edx, DWORD PTR [ecx+296]
	mov	DWORD PTR [eax+380], edx

; 3356 : 		m_pPlayerInfo = NULL;

	mov	DWORD PTR _m_pPlayerInfo, 0

; 3357 : 
; 3358 : 		R_StudioSetUpTransform( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetUpTransform
	add	esp, 4

; 3359 : 		VectorCopy( orig_angles, RI.currententity->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _orig_angles$4[ebp+ecx]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR _orig_angles$4[ebp+edx]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	eax, DWORD PTR _orig_angles$4[ebp+eax]
	mov	DWORD PTR [edx+ecx+3236], eax

; 3360 : 	}

	jmp	$LN6@R_StudioDr
$LN5@R_StudioDr:

; 3361 : 	else
; 3362 : 	{
; 3363 : 		RI.currententity->curstate.controller[0] = 127;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	mov	BYTE PTR [edx+ecx+1012], 127		; 0000007fH

; 3364 : 		RI.currententity->curstate.controller[1] = 127;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	BYTE PTR [ecx+eax+1012], 127		; 0000007fH

; 3365 : 		RI.currententity->curstate.controller[2] = 127;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _RI+28
	mov	BYTE PTR [ecx+eax+1012], 127		; 0000007fH

; 3366 : 		RI.currententity->curstate.controller[3] = 127;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _RI+28
	mov	BYTE PTR [edx+ecx+1012], 127		; 0000007fH

; 3367 : 		RI.currententity->latched.prevcontroller[0] = RI.currententity->curstate.controller[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1012]
	mov	BYTE PTR [edx+eax+3212], cl

; 3368 : 		RI.currententity->latched.prevcontroller[1] = RI.currententity->curstate.controller[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	al, BYTE PTR [esi+eax+1012]
	mov	BYTE PTR [edx+ecx+3212], al

; 3369 : 		RI.currententity->latched.prevcontroller[2] = RI.currententity->curstate.controller[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	al, BYTE PTR [esi+eax+1012]
	mov	BYTE PTR [edx+ecx+3212], al

; 3370 : 		RI.currententity->latched.prevcontroller[3] = RI.currententity->curstate.controller[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1012]
	mov	BYTE PTR [edx+eax+3212], cl

; 3371 : 		
; 3372 : 		m_pPlayerInfo = pfnPlayerInfo( m_nPlayerIndex );

	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	push	eax
	call	_pfnPlayerInfo
	add	esp, 4
	mov	DWORD PTR _m_pPlayerInfo, eax

; 3373 : 		m_pPlayerInfo->gaitsequence = 0;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	DWORD PTR [eax+380], 0

; 3374 : 
; 3375 : 		R_StudioSetUpTransform( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetUpTransform
	add	esp, 4
$LN6@R_StudioDr:

; 3376 : 	}
; 3377 : 
; 3378 : 	if( flags & STUDIO_RENDER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN9@R_StudioDr

; 3379 : 	{
; 3380 : 		// see if the bounding box lets us trivially reject, also sets
; 3381 : 		if( !R_StudioCheckBBox( ))

	call	_R_StudioCheckBBox
	test	eax, eax
	jne	SHORT $LN8@R_StudioDr

; 3382 : 			return 0;

	xor	eax, eax
	jmp	$LN1@R_StudioDr
$LN8@R_StudioDr:

; 3383 : 
; 3384 : 		r_stats.c_studio_models_drawn++;

	mov	eax, DWORD PTR _r_stats+32
	add	eax, 1
	mov	DWORD PTR _r_stats+32, eax

; 3385 : 		g_studio.framecount++; // render data cache cookie

	mov	eax, DWORD PTR _g_studio+16
	add	eax, 1
	mov	DWORD PTR _g_studio+16, eax

; 3386 : 
; 3387 : 		if( m_pStudioHeader->numbodyparts == 0 )

	mov	eax, DWORD PTR _m_pStudioHeader
	cmp	DWORD PTR [eax+204], 0
	jne	SHORT $LN9@R_StudioDr

; 3388 : 			return 1;

	mov	eax, 1
	jmp	$LN1@R_StudioDr
$LN9@R_StudioDr:

; 3389 : 	}
; 3390 : 
; 3391 : 	m_pPlayerInfo = pfnPlayerInfo( m_nPlayerIndex );

	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	push	eax
	call	_pfnPlayerInfo
	add	esp, 4
	mov	DWORD PTR _m_pPlayerInfo, eax

; 3392 : 	R_StudioSetupBones( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetupBones
	add	esp, 4

; 3393 : 	R_StudioSaveBones( );

	call	_R_StudioSaveBones

; 3394 : 
; 3395 : 	m_pPlayerInfo->renderframe = tr.realframecount;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR _tr+83196
	mov	DWORD PTR [eax+376], ecx

; 3396 : 	m_pPlayerInfo = NULL;

	mov	DWORD PTR _m_pPlayerInfo, 0

; 3397 : 
; 3398 : 	if( flags & STUDIO_EVENTS )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN11@R_StudioDr

; 3399 : 	{
; 3400 : 		R_StudioCalcAttachments( );

	call	_R_StudioCalcAttachments

; 3401 : 		R_StudioClientEvents( );

	call	_R_StudioClientEvents

; 3402 : 
; 3403 : 		// copy attachments into global entity array
; 3404 : 		if( RI.currententity->index > 0 )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN11@R_StudioDr

; 3405 : 		{
; 3406 : 			cl_entity_t *ent = CL_GetEntityByIndex( RI.currententity->index );

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$3[ebp], eax

; 3407 : 			memcpy( ent->attachment, RI.currententity->attachment, sizeof( vec3_t ) * 4 );

	push	48					; 00000030H
	mov	eax, DWORD PTR _RI+28
	add	eax, 3248				; 00000cb0H
	push	eax
	mov	ecx, DWORD PTR _ent$3[ebp]
	add	ecx, 3248				; 00000cb0H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN11@R_StudioDr:

; 3408 : 		}
; 3409 : 	}
; 3410 : 
; 3411 : 	if( flags & STUDIO_RENDER )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	$LN20@R_StudioDr

; 3412 : 	{
; 3413 : 		if( cl_himodels->value && RI.currentmodel != RI.currententity->model  )

	mov	eax, DWORD PTR _cl_himodels
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@R_StudioDr
	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _RI+32
	cmp	ecx, DWORD PTR [eax+3300]
	je	SHORT $LN13@R_StudioDr

; 3414 : 		{
; 3415 : 			// show highest resolution multiplayer model
; 3416 : 			RI.currententity->curstate.body = 255;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+1032], 255		; 000000ffH
$LN13@R_StudioDr:

; 3417 : 		}
; 3418 : 
; 3419 : 		if( !( !host_developer.value && cl.maxclients == 1 ) && ( RI.currentmodel == RI.currententity->model ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@R_StudioDr
	cmp	DWORD PTR _cl+2213004, 1
	je	SHORT $LN14@R_StudioDr
$LN15@R_StudioDr:
	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _RI+32
	cmp	ecx, DWORD PTR [eax+3300]
	jne	SHORT $LN14@R_StudioDr

; 3420 : 			RI.currententity->curstate.body = 1; // force helmet

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+1032], 1
$LN14@R_StudioDr:

; 3421 : 
; 3422 : 		lighting.plightvec = dir;

	lea	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR _lighting$[ebp+20], eax

; 3423 : 		R_StudioDynamicLight( RI.currententity, &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioDynamicLight
	add	esp, 8

; 3424 : 
; 3425 : 		R_StudioEntityLight( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_StudioEntityLight
	add	esp, 4

; 3426 : 
; 3427 : 		// model and frame independant
; 3428 : 		R_StudioSetupLighting( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_StudioSetupLighting
	add	esp, 4

; 3429 : 
; 3430 : 		m_pPlayerInfo = pfnPlayerInfo( m_nPlayerIndex );

	mov	eax, DWORD PTR _m_nPlayerIndex$[ebp]
	push	eax
	call	_pfnPlayerInfo
	add	esp, 4
	mov	DWORD PTR _m_pPlayerInfo, eax

; 3431 : 
; 3432 : 		// get remap colors
; 3433 : 		g_nTopColor = m_pPlayerInfo->topcolor;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR [eax+368]
	mov	DWORD PTR _g_nTopColor, ecx

; 3434 : 		g_nBottomColor = m_pPlayerInfo->bottomcolor;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR [eax+372]
	mov	DWORD PTR _g_nBottomColor, ecx

; 3435 : 
; 3436 : 		if( g_nTopColor < 0 ) g_nTopColor = 0;

	cmp	DWORD PTR _g_nTopColor, 0
	jge	SHORT $LN16@R_StudioDr
	mov	DWORD PTR _g_nTopColor, 0
$LN16@R_StudioDr:

; 3437 : 		if( g_nTopColor > 360 ) g_nTopColor = 360;

	cmp	DWORD PTR _g_nTopColor, 360		; 00000168H
	jle	SHORT $LN17@R_StudioDr
	mov	DWORD PTR _g_nTopColor, 360		; 00000168H
$LN17@R_StudioDr:

; 3438 : 		if( g_nBottomColor < 0 ) g_nBottomColor = 0;

	cmp	DWORD PTR _g_nBottomColor, 0
	jge	SHORT $LN18@R_StudioDr
	mov	DWORD PTR _g_nBottomColor, 0
$LN18@R_StudioDr:

; 3439 : 		if( g_nBottomColor > 360 ) g_nBottomColor = 360;

	cmp	DWORD PTR _g_nBottomColor, 360		; 00000168H
	jle	SHORT $LN19@R_StudioDr
	mov	DWORD PTR _g_nBottomColor, 360		; 00000168H
$LN19@R_StudioDr:

; 3440 : 
; 3441 : 		R_StudioSetRemapColors( g_nTopColor, g_nBottomColor );

	mov	eax, DWORD PTR _g_nBottomColor
	push	eax
	mov	ecx, DWORD PTR _g_nTopColor
	push	ecx
	call	_R_StudioSetRemapColors
	add	esp, 8

; 3442 : 
; 3443 : 		R_StudioRenderModel( );

	call	_R_StudioRenderModel

; 3444 : 		m_pPlayerInfo = NULL;

	mov	DWORD PTR _m_pPlayerInfo, 0

; 3445 : 
; 3446 : 		if( pplayer->weaponmodel )

	mov	eax, DWORD PTR _pplayer$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $LN20@R_StudioDr

; 3447 : 		{
; 3448 : 			cl_entity_t	saveent = *RI.currententity;

	mov	ecx, 834				; 00000342H
	mov	esi, DWORD PTR _RI+28
	lea	edi, DWORD PTR _saveent$2[ebp]
	rep movsd

; 3449 : 			model_t		*pweaponmodel = CL_ModelHandle( pplayer->weaponmodel );

	mov	eax, DWORD PTR _pplayer$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$1[ebp], eax

; 3450 : 
; 3451 : 			m_pStudioHeader = (studiohdr_t *)Mod_StudioExtradata( pweaponmodel );

	mov	eax, DWORD PTR _pweaponmodel$1[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _m_pStudioHeader, eax

; 3452 : 
; 3453 : 			R_StudioMergeBones( RI.currententity, pweaponmodel );

	mov	eax, DWORD PTR _pweaponmodel$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioMergeBones
	add	esp, 8

; 3454 : 			R_StudioSetupLighting( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_StudioSetupLighting
	add	esp, 4

; 3455 : 			R_StudioRenderModel( );

	call	_R_StudioRenderModel

; 3456 : 			R_StudioCalcAttachments( );

	call	_R_StudioCalcAttachments

; 3457 : 
; 3458 : 			*RI.currententity = saveent;

	mov	ecx, 834				; 00000342H
	lea	esi, DWORD PTR _saveent$2[ebp]
	mov	edi, DWORD PTR _RI+28
	rep movsd
$LN20@R_StudioDr:

; 3459 : 		}
; 3460 : 	}
; 3461 : 
; 3462 : 	return 1;

	mov	eax, 1
$LN1@R_StudioDr:

; 3463 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioProcessGait
_TEXT	SEGMENT
tv71 = -96						; size = 8
tv70 = -88						; size = 8
_flYaw$ = -16						; size = 4
_dt$ = -12						; size = 4
_iBlend$ = -8						; size = 4
_pseqdesc$ = -4						; size = 4
_pplayer$ = 8						; size = 4
_R_StudioProcessGait PROC				; COMDAT

; 3255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 3256 : 	mstudioseqdesc_t	*pseqdesc;
; 3257 : 	int		iBlend;
; 3258 : 	float		dt, flYaw; // view direction relative to movement
; 3259 : 
; 3260 : 	if( RI.currententity->curstate.sequence >= m_pStudioHeader->numseq ) 

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+956]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN2@R_StudioPr

; 3261 : 		RI.currententity->curstate.sequence = 0;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+956], 0
$LN2@R_StudioPr:

; 3262 : 
; 3263 : 	dt = bound( 0.0f, g_studio.frametime, 1.0f );

	movsd	xmm0, QWORD PTR _g_studio+8
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN16@R_StudioPr
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR _g_studio+8
	jbe	SHORT $LN14@R_StudioPr
	movsd	xmm0, QWORD PTR _g_studio+8
	movsd	QWORD PTR tv70[ebp], xmm0
	jmp	SHORT $LN15@R_StudioPr
$LN14@R_StudioPr:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv70[ebp], xmm0
$LN15@R_StudioPr:
	movsd	xmm0, QWORD PTR tv70[ebp]
	movsd	QWORD PTR tv71[ebp], xmm0
	jmp	SHORT $LN17@R_StudioPr
$LN16@R_StudioPr:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv71[ebp], xmm0
$LN17@R_StudioPr:
	cvtsd2ss xmm0, QWORD PTR tv71[ebp]
	movss	DWORD PTR _dt$[ebp], xmm0

; 3264 : 
; 3265 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + RI.currententity->curstate.sequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _RI+28
	imul	eax, DWORD PTR [edx+956], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 3266 : 
; 3267 : 	R_StudioPlayerBlend( pseqdesc, &iBlend, &RI.currententity->angles[PITCH] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	lea	eax, DWORD PTR [edx+ecx+3236]
	push	eax
	lea	ecx, DWORD PTR _iBlend$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	call	_R_StudioPlayerBlend
	add	esp, 12					; 0000000cH

; 3268 : 
; 3269 : 	RI.currententity->latched.prevangles[PITCH] = RI.currententity->angles[PITCH];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [esi+ecx+3236]
	mov	DWORD PTR [edx+eax+3192], ecx

; 3270 : 	RI.currententity->curstate.blending[0] = iBlend;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+28
	mov	al, BYTE PTR _iBlend$[ebp]
	mov	BYTE PTR [edx+ecx+1016], al

; 3271 : 	RI.currententity->latched.prevblending[0] = RI.currententity->curstate.blending[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1016]
	mov	BYTE PTR [edx+eax+3216], cl

; 3272 : 	RI.currententity->latched.prevseqblending[0] = RI.currententity->curstate.blending[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1016]
	mov	BYTE PTR [edx+eax+3176], cl

; 3273 : 	R_StudioEstimateGait( pplayer );

	mov	eax, DWORD PTR _pplayer$[ebp]
	push	eax
	call	_R_StudioEstimateGait
	add	esp, 4

; 3274 : 
; 3275 : 	// calc side to side turning
; 3276 : 	flYaw = RI.currententity->angles[YAW] - m_pPlayerInfo->gaityaw;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	subss	xmm0, DWORD PTR [edx+388]
	movss	DWORD PTR _flYaw$[ebp], xmm0

; 3277 : 	flYaw = flYaw - (int)(flYaw / 360) * 360;

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si eax, xmm0
	imul	ecx, eax, 360
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _flYaw$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _flYaw$[ebp], xmm1

; 3278 : 	if( flYaw < -180.0f ) flYaw = flYaw + 360.0f;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _flYaw$[ebp]
	jbe	SHORT $LN3@R_StudioPr
	movss	xmm0, DWORD PTR _flYaw$[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _flYaw$[ebp], xmm0
$LN3@R_StudioPr:

; 3279 : 	if( flYaw > 180.0f ) flYaw = flYaw - 360.0f;

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN4@R_StudioPr
	movss	xmm0, DWORD PTR _flYaw$[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _flYaw$[ebp], xmm0
$LN4@R_StudioPr:

; 3280 : 
; 3281 : 	if( flYaw > 120.0f )

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	comiss	xmm0, DWORD PTR __real@42f00000
	jbe	SHORT $LN5@R_StudioPr

; 3282 : 	{
; 3283 : 		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - 180.0f;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [eax+388]
	subss	xmm0, DWORD PTR __real@43340000
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [ecx+388], xmm0

; 3284 : 		m_flGaitMovement = -m_flGaitMovement;

	movss	xmm0, DWORD PTR _m_flGaitMovement
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _m_flGaitMovement, xmm0

; 3285 : 		flYaw = flYaw - 180.0f;

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	subss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR _flYaw$[ebp], xmm0

; 3286 : 	}

	jmp	SHORT $LN7@R_StudioPr
$LN5@R_StudioPr:

; 3287 : 	else if( flYaw < -120.0f )

	movss	xmm0, DWORD PTR __real@c2f00000
	comiss	xmm0, DWORD PTR _flYaw$[ebp]
	jbe	SHORT $LN7@R_StudioPr

; 3288 : 	{
; 3289 : 		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw + 180.0f;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR __real@43340000
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [ecx+388], xmm0

; 3290 : 		m_flGaitMovement = -m_flGaitMovement;

	movss	xmm0, DWORD PTR _m_flGaitMovement
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _m_flGaitMovement, xmm0

; 3291 : 		flYaw = flYaw + 180.0f;

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	addss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR _flYaw$[ebp], xmm0
$LN7@R_StudioPr:

; 3292 : 	}
; 3293 : 
; 3294 : 	// adjust torso
; 3295 : 	RI.currententity->curstate.controller[0] = ((flYaw / 4.0f) + 30.0f) / (60.0f / 255.0f);

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	addss	xmm0, DWORD PTR __real@41f00000
	divss	xmm0, DWORD PTR __real@3e70f0f1
	mov	eax, 1
	imul	ecx, eax, 0
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _RI+28
	mov	BYTE PTR [eax+ecx+1012], dl

; 3296 : 	RI.currententity->curstate.controller[1] = ((flYaw / 4.0f) + 30.0f) / (60.0f / 255.0f);

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	addss	xmm0, DWORD PTR __real@41f00000
	divss	xmm0, DWORD PTR __real@3e70f0f1
	mov	eax, 1
	shl	eax, 0
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _RI+28
	mov	BYTE PTR [edx+eax+1012], cl

; 3297 : 	RI.currententity->curstate.controller[2] = ((flYaw / 4.0f) + 30.0f) / (60.0f / 255.0f);

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	addss	xmm0, DWORD PTR __real@41f00000
	divss	xmm0, DWORD PTR __real@3e70f0f1
	mov	eax, 1
	shl	eax, 1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _RI+28
	mov	BYTE PTR [edx+eax+1012], cl

; 3298 : 	RI.currententity->curstate.controller[3] = ((flYaw / 4.0f) + 30.0f) / (60.0f / 255.0f);

	movss	xmm0, DWORD PTR _flYaw$[ebp]
	divss	xmm0, DWORD PTR __real@40800000
	addss	xmm0, DWORD PTR __real@41f00000
	divss	xmm0, DWORD PTR __real@3e70f0f1
	mov	eax, 1
	imul	ecx, eax, 3
	cvttss2si edx, xmm0
	mov	eax, DWORD PTR _RI+28
	mov	BYTE PTR [eax+ecx+1012], dl

; 3299 : 	RI.currententity->latched.prevcontroller[0] = RI.currententity->curstate.controller[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1012]
	mov	BYTE PTR [edx+eax+3212], cl

; 3300 : 	RI.currententity->latched.prevcontroller[1] = RI.currententity->curstate.controller[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	al, BYTE PTR [esi+eax+1012]
	mov	BYTE PTR [edx+ecx+3212], al

; 3301 : 	RI.currententity->latched.prevcontroller[2] = RI.currententity->curstate.controller[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	al, BYTE PTR [esi+eax+1012]
	mov	BYTE PTR [edx+ecx+3212], al

; 3302 : 	RI.currententity->latched.prevcontroller[3] = RI.currententity->curstate.controller[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	cl, BYTE PTR [esi+ecx+1012]
	mov	BYTE PTR [edx+eax+3212], cl

; 3303 : 
; 3304 : 	RI.currententity->angles[YAW] = m_pPlayerInfo->gaityaw;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR _m_pPlayerInfo
	mov	edx, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+eax+3236], edx

; 3305 : 	if( RI.currententity->angles[YAW] < -0 ) RI.currententity->angles[YAW] += 360.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+eax+3236]
	jbe	SHORT $LN8@R_StudioPr
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _RI+28
	movss	DWORD PTR [eax+edx+3236], xmm0
$LN8@R_StudioPr:

; 3306 : 	RI.currententity->latched.prevangles[YAW] = RI.currententity->angles[YAW];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _RI+28
	mov	eax, DWORD PTR [esi+eax+3236]
	mov	DWORD PTR [edx+ecx+3192], eax

; 3307 : 
; 3308 : 	if( pplayer->gaitsequence >= m_pStudioHeader->numseq ) 

	mov	eax, DWORD PTR _pplayer$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+296]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN9@R_StudioPr

; 3309 : 		pplayer->gaitsequence = 0;

	mov	eax, DWORD PTR _pplayer$[ebp]
	mov	DWORD PTR [eax+296], 0
$LN9@R_StudioPr:

; 3310 : 
; 3311 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + pplayer->gaitsequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _pplayer$[ebp]
	imul	eax, DWORD PTR [edx+296], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 3312 : 
; 3313 : 	// calc gait frame
; 3314 : 	if( pseqdesc->linearmovement[0] > 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+76]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@R_StudioPr

; 3315 : 		m_pPlayerInfo->gaitframe += (m_flGaitMovement / pseqdesc->linearmovement[0]) * pseqdesc->numframes;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR _m_flGaitMovement
	divss	xmm0, DWORD PTR [edx+ecx+76]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2ss xmm1, DWORD PTR [eax+56]
	mulss	xmm0, xmm1
	mov	ecx, DWORD PTR _m_pPlayerInfo
	addss	xmm0, DWORD PTR [ecx+384]
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [edx+384], xmm0
	jmp	SHORT $LN11@R_StudioPr
$LN10@R_StudioPr:

; 3316 : 	else m_pPlayerInfo->gaitframe += pseqdesc->fps * dt;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	mov	ecx, DWORD PTR _m_pPlayerInfo
	addss	xmm0, DWORD PTR [ecx+384]
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [edx+384], xmm0
$LN11@R_StudioPr:

; 3317 : 
; 3318 : 	// do modulo
; 3319 : 	m_pPlayerInfo->gaitframe = m_pPlayerInfo->gaitframe - (int)(m_pPlayerInfo->gaitframe / pseqdesc->numframes) * pseqdesc->numframes;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	xmm1, DWORD PTR [ecx+384]
	divss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	edx, DWORD PTR [eax+56]
	cvtsi2ss xmm0, edx
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	xmm1, DWORD PTR [ecx+384]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [edx+384], xmm1

; 3320 : 	if( m_pPlayerInfo->gaitframe < 0 ) m_pPlayerInfo->gaitframe += pseqdesc->numframes;

	mov	eax, DWORD PTR _m_pPlayerInfo
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+384]
	jbe	SHORT $LN12@R_StudioPr
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _m_pPlayerInfo
	addss	xmm0, DWORD PTR [ecx+384]
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [edx+384], xmm0
$LN12@R_StudioPr:

; 3321 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioProcessGait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioEstimateGait
_TEXT	SEGMENT
tv67 = -104						; size = 8
tv347 = -96						; size = 8
tv66 = -96						; size = 8
tv130 = -92						; size = 4
_flYawDiff$1 = -24					; size = 4
_dt$ = -20						; size = 4
_est_velocity$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_pplayer$ = 8						; size = 4
_R_StudioEstimateGait PROC				; COMDAT

; 3199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3200 : 	vec3_t	est_velocity;
; 3201 : 	float	dt;
; 3202 : 
; 3203 : 	dt = bound( 0.0f, g_studio.frametime, 1.0f );

	movsd	xmm0, QWORD PTR _g_studio+8
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN17@R_StudioEs
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR _g_studio+8
	jbe	SHORT $LN15@R_StudioEs
	movsd	xmm0, QWORD PTR _g_studio+8
	movsd	QWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN16@R_StudioEs
$LN15@R_StudioEs:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv66[ebp], xmm0
$LN16@R_StudioEs:
	movsd	xmm0, QWORD PTR tv66[ebp]
	movsd	QWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN18@R_StudioEs
$LN17@R_StudioEs:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv67[ebp], xmm0
$LN18@R_StudioEs:
	cvtsd2ss xmm0, QWORD PTR tv67[ebp]
	movss	DWORD PTR _dt$[ebp], xmm0

; 3204 : 
; 3205 : 	if( dt == 0.0f || m_pPlayerInfo->renderframe == tr.realframecount )

	movss	xmm0, DWORD PTR _dt$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@R_StudioEs
	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR [eax+376]
	cmp	ecx, DWORD PTR _tr+83196
	jne	SHORT $LN2@R_StudioEs
$LN3@R_StudioEs:

; 3206 : 	{
; 3207 : 		m_flGaitMovement = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _m_flGaitMovement, xmm0

; 3208 : 		return;

	jmp	$LN13@R_StudioEs
$LN2@R_StudioEs:

; 3209 : 	}
; 3210 : 
; 3211 : 	VectorSubtract( RI.currententity->origin, m_pPlayerInfo->prevgaitorigin, est_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	subss	xmm0, DWORD PTR [esi+eax+392]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _est_velocity$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	subss	xmm0, DWORD PTR [esi+eax+392]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _est_velocity$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+28
	mov	esi, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [edx+eax+3224]
	subss	xmm0, DWORD PTR [esi+ecx+392]
	movss	DWORD PTR tv130[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv130[ebp]
	movss	DWORD PTR _est_velocity$[ebp+eax], xmm0

; 3212 : 	VectorCopy( RI.currententity->origin, m_pPlayerInfo->prevgaitorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _m_pPlayerInfo
	mov	esi, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+392], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _m_pPlayerInfo
	mov	esi, DWORD PTR _RI+28
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+392], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _m_pPlayerInfo
	mov	esi, DWORD PTR _RI+28
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+392], eax

; 3213 : 	m_flGaitMovement = VectorLength( est_velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _est_velocity$[ebp+ecx]
	mulss	xmm0, DWORD PTR _est_velocity$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _est_velocity$[ebp+ecx]
	mulss	xmm1, DWORD PTR _est_velocity$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _est_velocity$[ebp+eax]
	mulss	xmm1, DWORD PTR _est_velocity$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _m_flGaitMovement

; 3214 : 
; 3215 : 	if( dt <= 0.0f || m_flGaitMovement / dt < 5.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dt$[ebp]
	jae	SHORT $LN5@R_StudioEs
	movss	xmm0, DWORD PTR _m_flGaitMovement
	divss	xmm0, DWORD PTR _dt$[ebp]
	movss	xmm1, DWORD PTR __real@40a00000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@R_StudioEs
$LN5@R_StudioEs:

; 3216 : 	{
; 3217 : 		m_flGaitMovement = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _m_flGaitMovement, xmm0

; 3218 : 		est_velocity[0] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _est_velocity$[ebp+ecx], xmm0

; 3219 : 		est_velocity[1] = 0.0f;

	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _est_velocity$[ebp+eax], xmm0
$LN4@R_StudioEs:

; 3220 : 	}
; 3221 : 
; 3222 : 	if( est_velocity[1] == 0.0f && est_velocity[0] == 0.0f )

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _est_velocity$[ebp+eax]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@R_StudioEs
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _est_velocity$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN6@R_StudioEs

; 3223 : 	{
; 3224 : 		float	flYawDiff = RI.currententity->angles[YAW] - m_pPlayerInfo->gaityaw;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	subss	xmm0, DWORD PTR [edx+388]
	movss	DWORD PTR _flYawDiff$1[ebp], xmm0

; 3225 : 
; 3226 : 		flYawDiff = flYawDiff - (int)(flYawDiff / 360) * 360;

	movss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si eax, xmm0
	imul	ecx, eax, 360
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _flYawDiff$1[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _flYawDiff$1[ebp], xmm1

; 3227 : 		if( flYawDiff > 180.0f ) flYawDiff -= 360.0f;

	movss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN8@R_StudioEs
	movss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	subss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _flYawDiff$1[ebp], xmm0
$LN8@R_StudioEs:

; 3228 : 		if( flYawDiff < -180.0f ) flYawDiff += 360.0f;

	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	jbe	SHORT $LN9@R_StudioEs
	movss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	addss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _flYawDiff$1[ebp], xmm0
$LN9@R_StudioEs:

; 3229 : 
; 3230 : 		if( dt < 0.25f )

	movss	xmm0, DWORD PTR __real@3e800000
	comiss	xmm0, DWORD PTR _dt$[ebp]
	jbe	SHORT $LN10@R_StudioEs

; 3231 : 			flYawDiff *= dt * 4.0f;

	movss	xmm0, DWORD PTR _dt$[ebp]
	mulss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	movss	DWORD PTR _flYawDiff$1[ebp], xmm0
	jmp	SHORT $LN11@R_StudioEs
$LN10@R_StudioEs:

; 3232 : 		else flYawDiff *= dt;

	movss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	mulss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR _flYawDiff$1[ebp], xmm0
$LN11@R_StudioEs:

; 3233 : 
; 3234 : 		m_pPlayerInfo->gaityaw += flYawDiff;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [eax+388]
	addss	xmm0, DWORD PTR _flYawDiff$1[ebp]
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [ecx+388], xmm0

; 3235 : 		m_pPlayerInfo->gaityaw = m_pPlayerInfo->gaityaw - (int)(m_pPlayerInfo->gaityaw / 360) * 360;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [eax+388]
	divss	xmm0, DWORD PTR __real@43b40000
	cvttss2si ecx, xmm0
	imul	edx, ecx, 360
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm1, DWORD PTR [eax+388]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [ecx+388], xmm1

; 3236 : 
; 3237 : 		m_flGaitMovement = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _m_flGaitMovement, xmm0

; 3238 : 	}

	jmp	$LN13@R_StudioEs
$LN6@R_StudioEs:

; 3239 : 	else
; 3240 : 	{
; 3241 : 		m_pPlayerInfo->gaityaw = ( atan2( est_velocity[1], est_velocity[0] ) * 180 / M_PI );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _est_velocity$[ebp+ecx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _est_velocity$[ebp+edx]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv347[ebp]
	movsd	xmm0, QWORD PTR tv347[ebp]
	mulsd	xmm0, QWORD PTR __real@4066800000000000
	divsd	xmm0, QWORD PTR __real@400921fb60000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	DWORD PTR [eax+388], xmm0

; 3242 : 		if( m_pPlayerInfo->gaityaw > 180.0f ) m_pPlayerInfo->gaityaw = 180.0f;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR [eax+388]
	comiss	xmm0, DWORD PTR __real@43340000
	jbe	SHORT $LN12@R_StudioEs
	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR [eax+388], xmm0
$LN12@R_StudioEs:

; 3243 : 		if( m_pPlayerInfo->gaityaw < -180.0f ) m_pPlayerInfo->gaityaw = -180.0f;

	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR __real@c3340000
	comiss	xmm0, DWORD PTR [eax+388]
	jbe	SHORT $LN13@R_StudioEs
	mov	eax, DWORD PTR _m_pPlayerInfo
	movss	xmm0, DWORD PTR __real@c3340000
	movss	DWORD PTR [eax+388], xmm0
$LN13@R_StudioEs:

; 3244 : 	}
; 3245 : 
; 3246 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioEstimateGait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioRenderModel
_TEXT	SEGMENT
_R_StudioRenderModel PROC				; COMDAT

; 3170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3171 : 	R_StudioSetChromeOrigin();

	call	_R_StudioSetChromeOrigin

; 3172 : 	R_StudioSetForceFaceFlags( 0 );

	push	0
	call	_R_StudioSetForceFaceFlags
	add	esp, 4

; 3173 : 
; 3174 : 	if( RI.currententity->curstate.renderfx == kRenderFxGlowShell )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+996], 19			; 00000013H
	jne	SHORT $LN2@R_StudioRe

; 3175 : 	{
; 3176 : 		RI.currententity->curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+996], 0

; 3177 : 
; 3178 : 		R_StudioRenderFinal( );

	call	_R_StudioRenderFinal

; 3179 : 
; 3180 : 		R_StudioSetForceFaceFlags( STUDIO_NF_CHROME );

	push	2
	call	_R_StudioSetForceFaceFlags
	add	esp, 4

; 3181 : 		TriSpriteTexture( R_GetChromeSprite(), 0 );

	push	0
	call	_R_GetChromeSprite
	push	eax
	call	_TriSpriteTexture
	add	esp, 8

; 3182 : 		RI.currententity->curstate.renderfx = kRenderFxGlowShell;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR [eax+996], 19			; 00000013H

; 3183 : 
; 3184 : 		R_StudioRenderFinal( );

	call	_R_StudioRenderFinal

; 3185 : 	}

	jmp	SHORT $LN1@R_StudioRe
$LN2@R_StudioRe:

; 3186 : 	else
; 3187 : 	{
; 3188 : 		R_StudioRenderFinal( );

	call	_R_StudioRenderFinal
$LN1@R_StudioRe:

; 3189 : 	}
; 3190 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioRenderModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioRenderFinal
_TEXT	SEGMENT
tv159 = -92						; size = 4
tv67 = -92						; size = 4
_origin$1 = -24						; size = 12
_rendermode$ = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioRenderFinal PROC				; COMDAT

; 3084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3085 : 	int	i, rendermode;
; 3086 : 
; 3087 : 	rendermode = R_StudioGetForceFaceFlags() ? kRenderTransAdd : RI.currententity->curstate.rendermode;

	call	_R_StudioGetForceFaceFlags
	test	eax, eax
	je	SHORT $LN14@R_StudioRe
	mov	DWORD PTR tv67[ebp], 5
	jmp	SHORT $LN15@R_StudioRe
$LN14@R_StudioRe:
	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+984]
	mov	DWORD PTR tv67[ebp], ecx
$LN15@R_StudioRe:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _rendermode$[ebp], edx

; 3088 : 	R_StudioSetupRenderer( rendermode );

	mov	eax, DWORD PTR _rendermode$[ebp]
	push	eax
	call	_R_StudioSetupRenderer
	add	esp, 4

; 3089 : 	
; 3090 : 	if( r_drawentities->value == 2 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_StudioRe

; 3091 : 	{
; 3092 : 		R_StudioDrawBones();

	call	_R_StudioDrawBones

; 3093 : 	}

	jmp	SHORT $LN3@R_StudioRe
$LN5@R_StudioRe:

; 3094 : 	else if( r_drawentities->value == 3 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40400000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@R_StudioRe

; 3095 : 	{
; 3096 : 		R_StudioDrawHulls();

	call	_R_StudioDrawHulls

; 3097 : 	}

	jmp	SHORT $LN3@R_StudioRe
$LN7@R_StudioRe:

; 3098 : 	else
; 3099 : 	{
; 3100 : 		for( i = 0; i < m_pStudioHeader->numbodyparts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioRe
$LN2@R_StudioRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioRe:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+204]
	jge	SHORT $LN3@R_StudioRe

; 3101 : 		{
; 3102 : 			R_StudioSetupModel( i, &m_pBodyPart, &m_pSubModel );

	push	OFFSET _m_pSubModel
	push	OFFSET _m_pBodyPart
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_R_StudioSetupModel
	add	esp, 12					; 0000000cH

; 3103 : 
; 3104 : 			GL_StudioSetRenderMode( rendermode );

	mov	eax, DWORD PTR _rendermode$[ebp]
	push	eax
	call	_GL_StudioSetRenderMode
	add	esp, 4

; 3105 : 			R_StudioDrawPoints();

	call	_R_StudioDrawPoints

; 3106 : 			GL_StudioDrawShadow();

	call	_GL_StudioDrawShadow

; 3107 : 		}

	jmp	SHORT $LN2@R_StudioRe
$LN3@R_StudioRe:

; 3108 : 	}
; 3109 : 
; 3110 : 	if( r_drawentities->value == 4 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@R_StudioRe

; 3111 : 	{
; 3112 : 		TriRenderMode( kRenderTransAdd );

	push	5
	call	_TriRenderMode
	add	esp, 4

; 3113 : 		R_StudioDrawHulls( );

	call	_R_StudioDrawHulls

; 3114 : 		TriRenderMode( kRenderNormal );

	push	0
	call	_TriRenderMode
	add	esp, 4
$LN9@R_StudioRe:

; 3115 : 	}
; 3116 : 
; 3117 : 	if( r_drawentities->value == 5 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40a00000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_StudioRe

; 3118 : 	{
; 3119 : 		R_StudioDrawAbsBBox( );

	call	_R_StudioDrawAbsBBox
$LN10@R_StudioRe:

; 3120 : 	}
; 3121 : 
; 3122 : 	if( r_drawentities->value == 6 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40c00000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@R_StudioRe

; 3123 : 	{
; 3124 : 		R_StudioDrawAttachments();

	call	_R_StudioDrawAttachments
$LN11@R_StudioRe:

; 3125 : 	}
; 3126 : 
; 3127 : 	if( r_drawentities->value == 7 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40e00000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@R_StudioRe

; 3128 : 	{
; 3129 : 		vec3_t	origin;
; 3130 : 
; 3131 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 3132 : 		pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 3133 : 
; 3134 : 		Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, origin );

	lea	eax, DWORD PTR _origin$1[ebp]
	push	eax
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 3135 : 
; 3136 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 3137 : 		pglColor3f( 1, 0.5, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 3138 : 		pglVertex3fv( origin );

	lea	eax, DWORD PTR _origin$1[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 3139 : 		pglVertex3fv( g_studio.lightspot );

	push	OFFSET _g_studio+430184
	call	DWORD PTR _pglVertex3fv

; 3140 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 3141 : 
; 3142 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 3143 : 		pglColor3f( 0, 0.5, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 3144 : 		VectorMA( g_studio.lightspot, -64.0f, g_studio.lightvec, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_studio[eax+430172]
	addss	xmm0, DWORD PTR _g_studio[ecx+430184]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_studio[ecx+430172]
	addss	xmm0, DWORD PTR _g_studio[eax+430184]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_studio[ecx+430172]
	movss	xmm1, DWORD PTR _g_studio[eax+430184]
	addss	xmm1, xmm0
	movss	DWORD PTR tv159[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR _origin$1[ebp+edx], xmm0

; 3145 : 		pglVertex3fv( g_studio.lightspot );

	push	OFFSET _g_studio+430184
	call	DWORD PTR _pglVertex3fv

; 3146 : 		pglVertex3fv( origin );

	lea	eax, DWORD PTR _origin$1[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 3147 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 3148 : 
; 3149 : 		pglPointSize( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 3150 : 		pglColor3f( 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 3151 : 		pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR _pglBegin

; 3152 : 		pglVertex3fv( g_studio.lightspot );

	push	OFFSET _g_studio+430184
	call	DWORD PTR _pglVertex3fv

; 3153 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 3154 : 		pglPointSize( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 3155 : 
; 3156 : 		pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable

; 3157 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN12@R_StudioRe:

; 3158 : 	}
; 3159 : 
; 3160 : 	R_StudioRestoreRenderer();

	call	_R_StudioRestoreRenderer

; 3161 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioRenderFinal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _GL_StudioDrawShadow
_TEXT	SEGMENT
_color$1 = -4						; size = 4
_GL_StudioDrawShadow PROC				; COMDAT

; 3054 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3055 : 	pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 3056 : 
; 3057 : 	if( r_shadows.value && g_studio.rendermode != kRenderTransAdd && !FBitSet( RI.currentmodel->flags, STUDIO_AMBIENT_LIGHT ))

	movss	xmm0, DWORD PTR _r_shadows+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@GL_StudioD
	cmp	DWORD PTR _g_studio+24, 5
	je	$LN2@GL_StudioD
	mov	eax, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 256				; 00000100H
	jne	$LN2@GL_StudioD

; 3058 : 	{
; 3059 : 		float	color = 1.0 - (tr.blend * 0.5);

	cvtss2sd xmm0, DWORD PTR _tr+87592
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _color$1[ebp], xmm0

; 3060 : 
; 3061 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 3062 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3063 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3064 : 		pglColor4f( 0.0f, 0.0f, 0.0f, 1.0f - color );

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _color$1[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3065 : 
; 3066 : 		pglDepthFunc( GL_LESS );

	push	513					; 00000201H
	call	DWORD PTR _pglDepthFunc

; 3067 : 		R_StudioDrawPointsShadow();

	call	_R_StudioDrawPointsShadow

; 3068 : 		pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 3069 : 
; 3070 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 3071 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 3072 : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3073 : 		pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR _pglShadeModel
$LN2@GL_StudioD:

; 3074 : 	}
; 3075 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_StudioDrawShadow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _GL_StudioSetRenderMode
_TEXT	SEGMENT
tv64 = -68						; size = 4
_rendermode$ = 8					; size = 4
_GL_StudioSetRenderMode PROC				; COMDAT

; 3017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3018 : 	switch( rendermode )

	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN4@GL_StudioS
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN5@GL_StudioS
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN6@GL_StudioS
	jmp	$LN7@GL_StudioS
$LN4@GL_StudioS:

; 3019 : 	{
; 3020 : 	case kRenderNormal:
; 3021 : 		break;

	jmp	$LN2@GL_StudioS
$LN5@GL_StudioS:

; 3022 : 	case kRenderTransColor:
; 3023 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3024 : 		pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	8448					; 00002100H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 3025 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3026 : 		break;

	jmp	$LN2@GL_StudioS
$LN6@GL_StudioS:

; 3027 : 	case kRenderTransAdd:
; 3028 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 3029 : 		pglColor4f( tr.blend, tr.blend, tr.blend, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3030 : 		pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 3031 : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 3032 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 3033 : 		break;

	jmp	SHORT $LN2@GL_StudioS
$LN7@GL_StudioS:

; 3034 : 	default:
; 3035 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 3036 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 3037 : 		pglColor4f( 1.0f, 1.0f, 1.0f, tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 3038 : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 3039 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable
$LN2@GL_StudioS:

; 3040 : 		break;
; 3041 : 	}
; 3042 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_StudioSetRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawPointsShadow
_TEXT	SEGMENT
tv94 = -116						; size = 4
_ptricmds$1 = -48					; size = 4
_k$ = -44						; size = 4
_i$ = -40						; size = 4
_point$ = -36						; size = 12
_pmesh$ = -24						; size = 4
_vec_y$ = -20						; size = 4
_vec_x$ = -16						; size = 4
_height$ = -12						; size = 4
_av$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawPointsShadow PROC				; COMDAT

; 2952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2953 : 	float		*av, height;
; 2954 : 	float		vec_x, vec_y;
; 2955 : 	mstudiomesh_t	*pmesh;
; 2956 : 	vec3_t		point;
; 2957 : 	int		i, k;
; 2958 : 
; 2959 : 	if( FBitSet( RI.currententity->curstate.effects, EF_NOSHADOW ))

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN10@R_StudioDr

; 2960 : 		return;

	jmp	$LN14@R_StudioDr
$LN10@R_StudioDr:

; 2961 : 
; 2962 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN11@R_StudioDr

; 2963 : 		pglEnable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglEnable
$LN11@R_StudioDr:

; 2964 : 
; 2965 : 	height = g_studio.lightspot[2] + 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[eax+430184]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _height$[ebp], xmm0

; 2966 : 	vec_x = -g_studio.lightvec[0] * 8.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+430172]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vec_x$[ebp], xmm0

; 2967 : 	vec_y = -g_studio.lightvec[1] * 8.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_studio[eax+430172]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vec_y$[ebp], xmm0

; 2968 : 
; 2969 : 	for( k = 0; k < m_pSubModel->nummesh; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN3@R_StudioDr

; 2970 : 	{
; 2971 : 		short	*ptricmds;
; 2972 : 
; 2973 : 		pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + k;

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+76]
	imul	edx, DWORD PTR _k$[ebp], 20
	add	ecx, edx
	mov	DWORD PTR _pmesh$[ebp], ecx

; 2974 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$1[ebp], ecx

; 2975 : 
; 2976 : 		r_stats.c_studio_polys += pmesh->numtris;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _r_stats+4
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _r_stats+4, ecx
$LN5@R_StudioDr:

; 2977 : 
; 2978 : 		while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$1[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _ptricmds$1[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$1[ebp], eax
	cmp	DWORD PTR tv94[ebp], 0
	je	$LN6@R_StudioDr

; 2979 : 		{
; 2980 : 			if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN12@R_StudioDr

; 2981 : 			{
; 2982 : 				pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 2983 : 				i = -i;

	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax

; 2984 : 			}

	jmp	SHORT $LN13@R_StudioDr
$LN12@R_StudioDr:

; 2985 : 			else
; 2986 : 			{
; 2987 : 				pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN13@R_StudioDr:

; 2988 : 			}
; 2989 : 
; 2990 : 
; 2991 : 			for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $LN9@R_StudioDr
$LN7@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$1[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$1[ebp], ecx
$LN9@R_StudioDr:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN8@R_StudioDr

; 2992 : 			{
; 2993 : 				av = g_studio.verts[ptricmds[0]];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$1[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+36948
	mov	DWORD PTR _av$[ebp], ecx

; 2994 : 				point[0] = av[0] - (vec_x * ( av[2] - g_studio.lightspot[2] ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _av$[ebp]
	movss	xmm0, DWORD PTR [esi+edx]
	subss	xmm0, DWORD PTR _g_studio[eax+430184]
	mulss	xmm0, DWORD PTR _vec_x$[ebp]
	mov	edx, DWORD PTR _av$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm1

; 2995 : 				point[1] = av[1] - (vec_y * ( av[2] - g_studio.lightspot[2] ));

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _av$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR _g_studio[edx+430184]
	mulss	xmm0, DWORD PTR _vec_y$[ebp]
	mov	ecx, DWORD PTR _av$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm1

; 2996 : 				point[2] = g_studio.lightspot[2] + 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[eax+430184]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 2997 : 
; 2998 : 				pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2999 : 			}

	jmp	$LN7@R_StudioDr
$LN8@R_StudioDr:

; 3000 : 
; 3001 : 			pglEnd();	

	call	DWORD PTR _pglEnd

; 3002 : 		}

	jmp	$LN5@R_StudioDr
$LN6@R_StudioDr:

; 3003 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 3004 : 
; 3005 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN14@R_StudioDr

; 3006 : 		pglDisable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglDisable
$LN14@R_StudioDr:

; 3007 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawPointsShadow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnIsHardware
_TEXT	SEGMENT
_pfnIsHardware PROC					; COMDAT

; 2941 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2942 : 	return 1;	// 0 is Software, 1 is OpenGL, 2 is Direct3D

	mov	eax, 1

; 2943 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnIsHardware ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetChromeOrigin
_TEXT	SEGMENT
_R_StudioSetChromeOrigin PROC				; COMDAT

; 2929 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2930 : 	VectorCopy( RI.vieworg, g_studio.chrome_origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR _g_studio[eax+628352], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR _g_studio[eax+628352], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR _g_studio[eax+628352], ecx

; 2931 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetChromeOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioRestoreRenderer
_TEXT	SEGMENT
_R_StudioRestoreRenderer PROC				; COMDAT

; 2913 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2914 : 	if( g_studio.rendermode != kRenderNormal )

	cmp	DWORD PTR _g_studio+24, 0
	je	SHORT $LN2@R_StudioRe

; 2915 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable
$LN2@R_StudioRe:

; 2916 : 
; 2917 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	ecx
	movss	xmm0, DWORD PTR __real@45f00800
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 2918 : 	pglShadeModel( GL_FLAT );

	push	7424					; 00001d00H
	call	DWORD PTR _pglShadeModel

; 2919 : 	m_fDoRemap = false;

	mov	DWORD PTR _m_fDoRemap, 0

; 2920 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioRestoreRenderer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupRenderer
_TEXT	SEGMENT
tv68 = -84						; size = 4
tv67 = -80						; size = 4
_boneinfo$1 = -12					; size = 4
_i$ = -8						; size = 4
_phdr$ = -4						; size = 4
_rendermode$ = 8					; size = 4
_R_StudioSetupRenderer PROC				; COMDAT

; 2884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2885 : 	studiohdr_t	*phdr = m_pStudioHeader;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	DWORD PTR _phdr$[ebp], eax

; 2886 : 	int		i;
; 2887 : 
; 2888 : 	if( rendermode > kRenderTransAdd ) rendermode = 0;

	cmp	DWORD PTR _rendermode$[ebp], 5
	jle	SHORT $LN5@R_StudioSe
	mov	DWORD PTR _rendermode$[ebp], 0
$LN5@R_StudioSe:

; 2889 : 	g_studio.rendermode = bound( 0, rendermode, kRenderTransAdd );

	cmp	DWORD PTR _rendermode$[ebp], 0
	jl	SHORT $LN10@R_StudioSe
	cmp	DWORD PTR _rendermode$[ebp], 5
	jge	SHORT $LN8@R_StudioSe
	mov	eax, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN9@R_StudioSe
$LN8@R_StudioSe:
	mov	DWORD PTR tv67[ebp], 5
$LN9@R_StudioSe:
	mov	ecx, DWORD PTR tv67[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN11@R_StudioSe
$LN10@R_StudioSe:
	mov	DWORD PTR tv68[ebp], 0
$LN11@R_StudioSe:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _g_studio+24, edx

; 2890 : 
; 2891 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 2892 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 2893 : 	pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR _pglShadeModel

; 2894 : 
; 2895 : 	// a point to setup local to world transform for boneweighted models
; 2896 : 	if( phdr && FBitSet( phdr->flags, STUDIO_HAS_BONEINFO ))

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $LN3@R_StudioSe
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN3@R_StudioSe

; 2897 : 	{
; 2898 : 		// NOTE: extended boneinfo goes immediately after bones
; 2899 : 		mstudioboneinfo_t *boneinfo = (mstudioboneinfo_t *)((byte *)phdr + phdr->boneindex + phdr->numbones * sizeof( mstudiobone_t ));

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _phdr$[ebp]
	imul	eax, DWORD PTR [edx+140], 112
	add	ecx, eax
	mov	DWORD PTR _boneinfo$1[ebp], ecx

; 2900 : 
; 2901 : 		for( i = 0; i < phdr->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioSe
$LN2@R_StudioSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioSe:
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN3@R_StudioSe

; 2902 : 			Matrix3x4_ConcatTransforms( g_studio.worldtransform[i], g_studio.bonestransform[i], boneinfo[i].poseToBone );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 7
	add	eax, DWORD PTR _boneinfo$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 48
	add	edx, OFFSET _g_studio+12368
	push	edx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@R_StudioSe
$LN3@R_StudioSe:

; 2903 : 	}
; 2904 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupRenderer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetRenderModel
_TEXT	SEGMENT
_model$ = 8						; size = 4
_R_StudioSetRenderModel PROC				; COMDAT

; 2873 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2874 : 	RI.currentmodel = model;

	mov	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR _RI+32, eax

; 2875 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetRenderModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetHeader
_TEXT	SEGMENT
_pheader$ = 8						; size = 4
_R_StudioSetHeader PROC					; COMDAT

; 2861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2862 : 	m_pStudioHeader = pheader;

	mov	eax, DWORD PTR _pheader$[ebp]
	mov	DWORD PTR _m_pStudioHeader, eax

; 2863 : 	m_fDoRemap = false;

	mov	DWORD PTR _m_fDoRemap, 0

; 2864 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetForceFaceFlags
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_R_StudioSetForceFaceFlags PROC				; COMDAT

; 2850 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2851 : 	g_nForceFaceFlags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _g_nForceFaceFlags, eax

; 2852 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetForceFaceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioGetForceFaceFlags
_TEXT	SEGMENT
_R_StudioGetForceFaceFlags PROC				; COMDAT

; 2839 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2840 : 	return g_nForceFaceFlags;

	mov	eax, DWORD PTR _g_nForceFaceFlags

; 2841 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioGetForceFaceFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioClientEvents
_TEXT	SEGMENT
tv169 = -104						; size = 4
tv168 = -100						; size = 4
_el$1 = -32						; size = 4
_start$ = -28						; size = 4
_end$ = -24						; size = 4
_sequence$ = -20					; size = 4
_i$ = -16						; size = 4
_e$ = -12						; size = 4
_pevent$ = -8						; size = 4
_pseqdesc$ = -4						; size = 4
_R_StudioClientEvents PROC				; COMDAT

; 2771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 2772 : 	mstudioseqdesc_t	*pseqdesc;
; 2773 : 	mstudioevent_t	*pevent;
; 2774 : 	cl_entity_t	*e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 2775 : 	int		i, sequence;
; 2776 : 	float		end, start;
; 2777 : 
; 2778 : 	if( g_studio.frametime == 0.0 )

	movsd	xmm0, QWORD PTR _g_studio+8
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_StudioCl

; 2779 : 		return; // gamepaused

	jmp	$LN3@R_StudioCl
$LN5@R_StudioCl:

; 2780 : 
; 2781 : 	// fill attachments with interpolated origin
; 2782 : 	if( m_pStudioHeader->numattachments <= 0 )

	mov	eax, DWORD PTR _m_pStudioHeader
	cmp	DWORD PTR [eax+212], 0
	jg	SHORT $LN6@R_StudioCl

; 2783 : 	{
; 2784 : 		Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, e->attachment[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	push	eax
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2785 : 		Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, e->attachment[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3248]
	push	edx
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2786 : 		Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, e->attachment[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _e$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3248]
	push	edx
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2787 : 		Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, e->attachment[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	push	eax
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8
$LN6@R_StudioCl:

; 2788 : 	}
; 2789 : 
; 2790 : 	if( FBitSet( e->curstate.effects, EF_MUZZLEFLASH ))

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 2
	je	$LN7@R_StudioCl

; 2791 : 	{
; 2792 : 		dlight_t	*el = CL_AllocElight( 0 );

	push	0
	call	_CL_AllocElight
	add	esp, 4
	mov	DWORD PTR _el$1[ebp], eax

; 2793 : 
; 2794 : 		ClearBits( e->curstate.effects, EF_MUZZLEFLASH );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+972], ecx

; 2795 : 		VectorCopy( e->attachment[0], el->origin );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _el$1[ebp]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [esi+ecx], edx
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [edx+ecx+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _el$1[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [esi+edx], eax
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _el$1[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx

; 2796 : 		el->die = cl.time + 0.05f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fa99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _el$1[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2797 : 		el->color.r = 255;

	mov	eax, DWORD PTR _el$1[ebp]
	mov	BYTE PTR [eax+16], 255			; 000000ffH

; 2798 : 		el->color.g = 192;

	mov	eax, DWORD PTR _el$1[ebp]
	mov	BYTE PTR [eax+17], 192			; 000000c0H

; 2799 : 		el->color.b = 64;

	mov	eax, DWORD PTR _el$1[ebp]
	mov	BYTE PTR [eax+18], 64			; 00000040H

; 2800 : 		el->decay = 320;

	mov	eax, DWORD PTR _el$1[ebp]
	movss	xmm0, DWORD PTR __real@43a00000
	movss	DWORD PTR [eax+24], xmm0

; 2801 : 		el->radius = 24;

	mov	eax, DWORD PTR _el$1[ebp]
	movss	xmm0, DWORD PTR __real@41c00000
	movss	DWORD PTR [eax+12], xmm0
$LN7@R_StudioCl:

; 2802 : 	}
; 2803 : 
; 2804 : 	sequence = bound( 0, e->curstate.sequence, m_pStudioHeader->numseq - 1 );

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+956], 0
	jl	SHORT $LN16@R_StudioCl
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [ecx+164]
	sub	edx, 1
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+956], edx
	jge	SHORT $LN14@R_StudioCl
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR tv168[ebp], edx
	jmp	SHORT $LN15@R_StudioCl
$LN14@R_StudioCl:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+164]
	sub	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
$LN15@R_StudioCl:
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv169[ebp], edx
	jmp	SHORT $LN17@R_StudioCl
$LN16@R_StudioCl:
	mov	DWORD PTR tv169[ebp], 0
$LN17@R_StudioCl:
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR _sequence$[ebp], eax

; 2805 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + sequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _sequence$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 2806 : 
; 2807 : 	// no events for this animation
; 2808 : 	if( pseqdesc->numevents == 0 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN8@R_StudioCl

; 2809 : 		return;

	jmp	$LN3@R_StudioCl
$LN8@R_StudioCl:

; 2810 : 
; 2811 : 	end = R_StudioEstimateFrame( e, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_StudioEstimateFrame
	add	esp, 8
	fstp	DWORD PTR _end$[ebp]

; 2812 : 	start = end - e->curstate.framerate * host.frametime * pseqdesc->fps;

	cvtss2sd xmm0, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm1, DWORD PTR [eax+1008]
	mulsd	xmm1, QWORD PTR _host+1448
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm2, DWORD PTR [ecx+32]
	mulsd	xmm1, xmm2
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _start$[ebp], xmm0

; 2813 : 	pevent = (mstudioevent_t *)((byte *)m_pStudioHeader + pseqdesc->eventindex);

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _pevent$[ebp], ecx

; 2814 : 
; 2815 : 	if( e->latched.sequencetime == e->curstate.animtime )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+3172]
	ucomiss	xmm0, DWORD PTR [ecx+1004]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_StudioCl

; 2816 : 	{
; 2817 : 		if( !FBitSet( pseqdesc->flags, STUDIO_LOOPING ))

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	jne	SHORT $LN10@R_StudioCl

; 2818 : 			start = -0.01f;

	movss	xmm0, DWORD PTR __real@bc23d70a
	movss	DWORD PTR _start$[ebp], xmm0
$LN10@R_StudioCl:

; 2819 : 	}
; 2820 : 
; 2821 : 	for( i = 0; i < pseqdesc->numevents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioCl
$LN2@R_StudioCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioCl:
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	SHORT $LN3@R_StudioCl

; 2822 : 	{
; 2823 : 		// ignore all non-client-side events
; 2824 : 		if( pevent[i].event < EVENT_CLIENT )

	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pevent$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 5000		; 00001388H
	jge	SHORT $LN11@R_StudioCl

; 2825 : 			continue;

	jmp	SHORT $LN2@R_StudioCl
$LN11@R_StudioCl:

; 2826 : 
; 2827 : 		if( (float)pevent[i].frame > start && pevent[i].frame <= end )

	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pevent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax]
	comiss	xmm0, DWORD PTR _start$[ebp]
	jbe	SHORT $LN12@R_StudioCl
	imul	eax, DWORD PTR _i$[ebp], 76
	mov	ecx, DWORD PTR _pevent$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax]
	movss	xmm1, DWORD PTR _end$[ebp]
	comiss	xmm1, xmm0
	jb	SHORT $LN12@R_StudioCl

; 2828 : 			clgame.dllFuncs.pfnStudioEvent( &pevent[i], e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 76
	add	ecx, DWORD PTR _pevent$[ebp]
	push	ecx
	call	DWORD PTR _clgame+100
	add	esp, 8
$LN12@R_StudioCl:

; 2829 : 	}

	jmp	SHORT $LN2@R_StudioCl
$LN3@R_StudioCl:

; 2830 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioClientEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupPlayerModel
_TEXT	SEGMENT
_state$ = -8						; size = 4
_info$ = -4						; size = 4
_index$ = 8						; size = 4
_R_StudioSetupPlayerModel PROC				; COMDAT

; 2668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2669 : 	player_info_t	*info;
; 2670 : 	player_model_t	*state;
; 2671 : 
; 2672 : 	if( !RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN2@R_StudioSe

; 2673 : 	{
; 2674 : 		// we are in gameui.
; 2675 : 		info = &gameui.playerinfo;

	mov	DWORD PTR _info$[ebp], OFFSET _gameui+3408

; 2676 : 	}

	jmp	SHORT $LN3@R_StudioSe
$LN2@R_StudioSe:

; 2677 : 	else
; 2678 : 	{
; 2679 : 		if( index < 0 || index >= cl.maxclients )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN5@R_StudioSe
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jl	SHORT $LN4@R_StudioSe
$LN5@R_StudioSe:

; 2680 : 			return NULL; // bad client ?

	xor	eax, eax
	jmp	$LN1@R_StudioSe
$LN4@R_StudioSe:

; 2681 : 		info = &cl.players[index];

	imul	eax, DWORD PTR _index$[ebp], 584
	add	eax, OFFSET _cl+2184940
	mov	DWORD PTR _info$[ebp], eax
$LN3@R_StudioSe:

; 2682 : 	}
; 2683 : 
; 2684 : 	state = &cl.player_models[index];

	imul	eax, DWORD PTR _index$[ebp], 524
	add	eax, OFFSET _cl+2168172
	mov	DWORD PTR _state$[ebp], eax

; 2685 : 
; 2686 : 	// g-cont: force for "dev-mode", non-local games and menu preview
; 2687 : 	if(( host_developer.value || !Host_IsLocalGame( ) || !RI.drawWorld ) && info->model[0] )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@R_StudioSe
	call	_Host_IsLocalGame
	test	eax, eax
	je	SHORT $LN8@R_StudioSe
	cmp	DWORD PTR _RI+4, 0
	jne	$LN6@R_StudioSe
$LN8@R_StudioSe:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _info$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+304]
	test	eax, eax
	je	$LN6@R_StudioSe

; 2688 : 	{
; 2689 : 		if( Q_strcmp( state->name, info->model ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN12@R_StudioSe

; 2690 : 		{
; 2691 : 			Q_strncpy( state->name, info->model, sizeof( state->name ));

	push	260					; 00000104H
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2692 : 			state->name[sizeof( state->name ) - 1] = 0;

	mov	eax, 1
	imul	ecx, eax, 259
	mov	edx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 2693 : 
; 2694 : 			Q_snprintf( state->modelname, sizeof( state->modelname ), "models/player/%s/%s.mdl", info->model, info->model );

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	push	OFFSET ??_C@_0BI@FJCKJLAM@models?1player?1?$CFs?1?$CFs?4mdl@
	push	260					; 00000104H
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2695 : 
; 2696 : 			if( FS_FileExists( state->modelname, false ))

	push	0
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@R_StudioSe

; 2697 : 				state->model = Mod_ForName( state->modelname, false, true );

	push	1
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+520], eax
	jmp	SHORT $LN11@R_StudioSe
$LN10@R_StudioSe:

; 2698 : 			else state->model = NULL;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+520], 0
$LN11@R_StudioSe:

; 2699 : 
; 2700 : 			if( !state->model )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+520], 0
	jne	SHORT $LN12@R_StudioSe

; 2701 : 				state->model = RI.currententity->model;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+3300]
	mov	DWORD PTR [eax+520], edx
$LN12@R_StudioSe:

; 2702 : 		}
; 2703 : 	}

	jmp	SHORT $LN7@R_StudioSe
$LN6@R_StudioSe:

; 2704 : 	else
; 2705 : 	{
; 2706 : 		if( state->model != RI.currententity->model )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [eax+520]
	cmp	edx, DWORD PTR [ecx+3300]
	je	SHORT $LN13@R_StudioSe

; 2707 : 			state->model = RI.currententity->model;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+3300]
	mov	DWORD PTR [eax+520], edx
$LN13@R_StudioSe:

; 2708 : 		state->name[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN7@R_StudioSe:

; 2709 : 	}
; 2710 : 
; 2711 : 	return state->model;

	mov	eax, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [eax+520]
$LN1@R_StudioSe:

; 2712 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupPlayerModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawAttachments
_TEXT	SEGMENT
_v$1 = -60						; size = 48
_pattachments$2 = -12					; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawAttachments PROC				; COMDAT

; 2600 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2601 : 	int	i;
; 2602 : 	
; 2603 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 2604 : 	pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 2605 : 	
; 2606 : 	for( i = 0; i < m_pStudioHeader->numattachments; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+212]
	jge	$LN3@R_StudioDr

; 2607 : 	{
; 2608 : 		mstudioattachment_t	*pattachments;
; 2609 : 		vec3_t		v[4];
; 2610 : 
; 2611 : 		pattachments = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);		

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR _pattachments$2[ebp], ecx

; 2612 : 		Matrix3x4_VectorTransform( g_studio.bonestransform[pattachments[i].bone], pattachments[i].org, v[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pattachments$2[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pattachments$2[ebp]
	imul	edx, DWORD PTR [ecx+eax+36], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2613 : 		Matrix3x4_VectorTransform( g_studio.bonestransform[pattachments[i].bone], pattachments[i].vectors[0], v[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _v$1[ebp+eax]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 88
	add	edx, DWORD PTR _pattachments$2[ebp]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+52]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pattachments$2[ebp]
	imul	edx, DWORD PTR [ecx+eax+36], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2614 : 		Matrix3x4_VectorTransform( g_studio.bonestransform[pattachments[i].bone], pattachments[i].vectors[1], v[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _v$1[ebp+eax]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 88
	add	edx, DWORD PTR _pattachments$2[ebp]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+52]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 88
	mov	eax, DWORD PTR _pattachments$2[ebp]
	imul	ecx, DWORD PTR [eax+edx+36], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2615 : 		Matrix3x4_VectorTransform( g_studio.bonestransform[pattachments[i].bone], pattachments[i].vectors[2], v[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, DWORD PTR _pattachments$2[ebp]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR [eax+ecx+52]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pattachments$2[ebp]
	imul	edx, DWORD PTR [ecx+eax+36], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2616 : 		
; 2617 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 2618 : 		pglColor3f( 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2619 : 		pglVertex3fv( v[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 2620 : 		pglColor3f( 1, 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2621 : 		pglVertex3fv (v[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _v$1[ebp+eax]
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 2622 : 		pglColor3f( 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2623 : 		pglVertex3fv (v[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 2624 : 		pglColor3f( 1, 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2625 : 		pglVertex3fv (v[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _v$1[ebp+eax]
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 2626 : 		pglColor3f( 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2627 : 		pglVertex3fv (v[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 2628 : 		pglColor3f( 1, 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2629 : 		pglVertex3fv( v[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 2630 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2631 : 
; 2632 : 		pglPointSize( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 2633 : 		pglColor3f( 0, 1, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2634 : 		pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR _pglBegin

; 2635 : 		pglVertex3fv( v[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _v$1[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 2636 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2637 : 		pglPointSize( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 2638 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2639 : 
; 2640 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 2641 : 	pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable

; 2642 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawAttachments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawBones
_TEXT	SEGMENT
_i$ = -24						; size = 4
_point$ = -20						; size = 12
_pbones$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawBones PROC					; COMDAT

; 2550 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2551 : 	mstudiobone_t	*pbones = (mstudiobone_t *) ((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 2552 : 	vec3_t		point;
; 2553 : 	int		i;
; 2554 : 
; 2555 : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 2556 : 
; 2557 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN3@R_StudioDr

; 2558 : 	{
; 2559 : 		if( pbones[i].parent >= 0 )

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [ecx+eax+32], 0
	jl	$LN5@R_StudioDr

; 2560 : 		{
; 2561 : 			pglPointSize( 3.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 2562 : 			pglColor3f( 1, 0.7f, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2563 : 			pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 2564 : 			
; 2565 : 			Matrix3x4_OriginFromMatrix( g_studio.bonestransform[pbones[i].parent], point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2566 : 			pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2567 : 			Matrix3x4_OriginFromMatrix( g_studio.bonestransform[i], point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2568 : 			pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2569 : 			
; 2570 : 			pglEnd();

	call	DWORD PTR _pglEnd

; 2571 : 
; 2572 : 			pglColor3f( 0, 0, 0.8f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2573 : 			pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR _pglBegin

; 2574 : 			if( pbones[pbones[i].parent].parent != -1 )

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	imul	edx, DWORD PTR [ecx+eax+32], 112
	mov	eax, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	je	SHORT $LN7@R_StudioDr

; 2575 : 			{
; 2576 : 				Matrix3x4_OriginFromMatrix( g_studio.bonestransform[pbones[i].parent], point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2577 : 				pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv
$LN7@R_StudioDr:

; 2578 : 			}
; 2579 : 			Matrix3x4_OriginFromMatrix( g_studio.bonestransform[i], point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2580 : 			pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2581 : 			pglEnd();

	call	DWORD PTR _pglEnd

; 2582 : 		}

	jmp	SHORT $LN6@R_StudioDr
$LN5@R_StudioDr:

; 2583 : 		else
; 2584 : 		{
; 2585 : 			// draw parent bone node
; 2586 : 			pglPointSize( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 2587 : 			pglColor3f( 0.8f, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 2588 : 			pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR _pglBegin

; 2589 : 			Matrix3x4_OriginFromMatrix( g_studio.bonestransform[i], point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 2590 : 			pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2591 : 			pglEnd();

	call	DWORD PTR _pglEnd
$LN6@R_StudioDr:

; 2592 : 		}
; 2593 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2594 : 
; 2595 : 	pglPointSize( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 2596 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 2597 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawAbsBBox
_TEXT	SEGMENT
tv88 = -188						; size = 4
_i$ = -120						; size = 4
_lv$ = -116						; size = 4
_tmp$ = -112						; size = 12
_p$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawAbsBBox PROC				; COMDAT

; 2510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2511 : 	vec3_t	p[8], tmp;
; 2512 : 	float	lv;
; 2513 : 	int	i;
; 2514 : 
; 2515 : 	// looks ugly, skip
; 2516 : 	if( RI.currententity == &clgame.viewent )

	cmp	DWORD PTR _RI+28, OFFSET _clgame+260432
	jne	SHORT $LN5@R_StudioDr

; 2517 : 		return;

	jmp	$LN1@R_StudioDr
$LN5@R_StudioDr:

; 2518 : 
; 2519 : 	if( !R_StudioComputeBBox( p ))

	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_R_StudioComputeBBox
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@R_StudioDr

; 2520 : 		return;

	jmp	$LN1@R_StudioDr
$LN6@R_StudioDr:

; 2521 : 
; 2522 : 	GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 2523 : 	TriColor4f( 0.5f, 0.5f, 1.0f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_TriColor4f
	add	esp, 16					; 00000010H

; 2524 : 	TriRenderMode( kRenderTransAdd );

	push	5
	call	_TriRenderMode
	add	esp, 4

; 2525 : 
; 2526 : 	TriBegin( TRI_QUADS );

	push	2
	call	_TriBegin
	add	esp, 4

; 2527 : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioDr:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@R_StudioDr

; 2528 : 	{
; 2529 : 		VectorClear( tmp );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$[ebp+eax], xmm0

; 2530 : 		tmp[i % 3] = (i < 3) ? 1.0f : -1.0f;

	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN8@R_StudioDr
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN9@R_StudioDr
$LN8@R_StudioDr:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv88[ebp], xmm0
$LN9@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR _tmp$[ebp+edx*4], xmm0

; 2531 : 		R_StudioLighting( &lv, -1, 0, tmp );

	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	push	0
	push	-1
	lea	ecx, DWORD PTR _lv$[ebp]
	push	ecx
	call	_R_StudioLighting
	add	esp, 16					; 00000010H

; 2532 : 
; 2533 : 		TriBrightness( lv );

	push	ecx
	movss	xmm0, DWORD PTR _lv$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_TriBrightness
	add	esp, 4

; 2534 : 		TriVertex3fv( p[boxpnt[i][0]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 2535 : 		TriVertex3fv( p[boxpnt[i][1]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 2536 : 		TriVertex3fv( p[boxpnt[i][2]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 2537 : 		TriVertex3fv( p[boxpnt[i][3]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 3
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 2538 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2539 : 	TriEnd();

	call	_TriEnd

; 2540 : 	TriRenderMode( kRenderNormal );

	push	0
	call	_TriRenderMode
	add	esp, 4
$LN1@R_StudioDr:

; 2541 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawAbsBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawHulls
_TEXT	SEGMENT
tv198 = -200						; size = 4
tv154 = -200						; size = 4
tv139 = -200						; size = 4
tv92 = -200						; size = 4
_p$1 = -132						; size = 96
_tmp$2 = -36						; size = 12
_pbbox$3 = -24						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_lv$ = -12						; size = 4
_alpha$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawHulls PROC					; COMDAT

; 2457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2458 : 	float	alpha, lv;
; 2459 : 	int	i, j;
; 2460 : 
; 2461 : 	if( r_drawentities->value == 4 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@R_StudioDr

; 2462 : 		alpha = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _alpha$[ebp], xmm0
	jmp	SHORT $LN12@R_StudioDr
$LN11@R_StudioDr:

; 2463 : 	else alpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$[ebp], xmm0
$LN12@R_StudioDr:

; 2464 : 
; 2465 : 	GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 2466 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 2467 : 
; 2468 : 	for( i = 0; i < m_pStudioHeader->numhitboxes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+156]
	jge	$LN3@R_StudioDr

; 2469 : 	{
; 2470 : 		mstudiobbox_t	*pbbox = (mstudiobbox_t *)((byte *)m_pStudioHeader + m_pStudioHeader->hitboxindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+160]
	mov	DWORD PTR _pbbox$3[ebp], ecx

; 2471 : 		vec3_t		tmp, p[8];
; 2472 : 
; 2473 : 		for( j = 0; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@R_StudioDr
$LN5@R_StudioDr:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_StudioDr:
	cmp	DWORD PTR _j$[ebp], 8
	jge	$LN6@R_StudioDr

; 2474 : 		{
; 2475 : 			tmp[0] = (j & 1) ? pbbox[i].bbmin[0] : pbbox[i].bbmax[0];

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 1
	je	SHORT $LN14@R_StudioDr
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pbbox$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN15@R_StudioDr
$LN14@R_StudioDr:
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pbbox$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax+20]
	movss	DWORD PTR tv92[ebp], xmm0
$LN15@R_StudioDr:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv92[ebp]
	movss	DWORD PTR _tmp$2[ebp+edx], xmm0

; 2476 : 			tmp[1] = (j & 2) ? pbbox[i].bbmin[1] : pbbox[i].bbmax[1];

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 2
	je	SHORT $LN16@R_StudioDr
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pbbox$3[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx+8]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN17@R_StudioDr
$LN16@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _pbbox$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx+20]
	movss	DWORD PTR tv139[ebp], xmm0
$LN17@R_StudioDr:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _tmp$2[ebp+edx], xmm0

; 2477 : 			tmp[2] = (j & 4) ? pbbox[i].bbmin[2] : pbbox[i].bbmax[2];

	mov	eax, DWORD PTR _j$[ebp]
	and	eax, 4
	je	SHORT $LN18@R_StudioDr
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pbbox$3[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx+8]
	movss	DWORD PTR tv154[ebp], xmm0
	jmp	SHORT $LN19@R_StudioDr
$LN18@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _pbbox$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx+20]
	movss	DWORD PTR tv154[ebp], xmm0
$LN19@R_StudioDr:
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv154[ebp]
	movss	DWORD PTR _tmp$2[ebp+edx], xmm0

; 2478 : 
; 2479 : 			Matrix3x4_VectorTransform( g_studio.bonestransform[pbbox[i].bone], tmp, p[j] );

	imul	eax, DWORD PTR _j$[ebp], 12
	lea	ecx, DWORD PTR _p$1[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _tmp$2[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$3[ebp]
	imul	edx, DWORD PTR [ecx+eax], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2480 : 		}

	jmp	$LN5@R_StudioDr
$LN6@R_StudioDr:

; 2481 : 
; 2482 : 		j = (pbbox[i].group % 8);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pbbox$3[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, -2147483641			; 80000007H
	jns	SHORT $LN22@R_StudioDr
	dec	edx
	or	edx, -8					; fffffff8H
	inc	edx
$LN22@R_StudioDr:
	mov	DWORD PTR _j$[ebp], edx

; 2483 : 
; 2484 : 		TriBegin( TRI_QUADS );

	push	2
	call	_TriBegin
	add	esp, 4

; 2485 : 		TriColor4f( hullcolor[j][0], hullcolor[j][1], hullcolor[j][2], alpha );

	push	ecx
	movss	xmm0, DWORD PTR _alpha$[ebp]
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	push	ecx
	movss	xmm0, DWORD PTR _hullcolor[eax+ecx]
	movss	DWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _hullcolor[edx+eax]
	movss	DWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _j$[ebp], 12
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _hullcolor[ecx+eax]
	movss	DWORD PTR [esp], xmm0
	call	_TriColor4f
	add	esp, 16					; 00000010H

; 2486 : 
; 2487 : 		for( j = 0; j < 6; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@R_StudioDr
$LN8@R_StudioDr:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@R_StudioDr:
	cmp	DWORD PTR _j$[ebp], 6
	jge	$LN9@R_StudioDr

; 2488 : 		{
; 2489 : 			VectorClear( tmp );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$2[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$2[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _tmp$2[ebp+eax], xmm0

; 2490 : 			tmp[j % 3] = (j < 3) ? 1.0f : -1.0f;

	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN20@R_StudioDr
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv198[ebp], xmm0
	jmp	SHORT $LN21@R_StudioDr
$LN20@R_StudioDr:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv198[ebp], xmm0
$LN21@R_StudioDr:
	mov	eax, DWORD PTR _j$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	movss	xmm0, DWORD PTR tv198[ebp]
	movss	DWORD PTR _tmp$2[ebp+edx*4], xmm0

; 2491 : 			R_StudioLighting( &lv, pbbox[i].bone, 0, tmp );

	lea	eax, DWORD PTR _tmp$2[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pbbox$3[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	lea	ecx, DWORD PTR _lv$[ebp]
	push	ecx
	call	_R_StudioLighting
	add	esp, 16					; 00000010H

; 2492 : 
; 2493 : 			TriBrightness( lv );

	push	ecx
	movss	xmm0, DWORD PTR _lv$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_TriBrightness
	add	esp, 4

; 2494 : 			TriVertex3fv( p[boxpnt[j][0]] );

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$1[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 2495 : 			TriVertex3fv( p[boxpnt[j][1]] );

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$1[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 2496 : 			TriVertex3fv( p[boxpnt[j][2]] );

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$1[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 2497 : 			TriVertex3fv( p[boxpnt[j][3]] );

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 3
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$1[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 2498 : 		}

	jmp	$LN8@R_StudioDr
$LN9@R_StudioDr:

; 2499 : 		TriEnd();

	call	_TriEnd

; 2500 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2501 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawHulls ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawPoints
_TEXT	SEGMENT
tv75 = -208						; size = 4
tv316 = -204						; size = 4
tv212 = -204						; size = 4
tv74 = -204						; size = 4
_t$1 = -136						; size = 4
_s$2 = -132						; size = 4
_ptricmds$3 = -128					; size = 4
_oldblend$4 = -124					; size = 4
_factor$5 = -120					; size = 4
_skinMat$6 = -116					; size = 48
_pnormweight$7 = -68					; size = 4
_pvertweight$8 = -64					; size = 4
_lv_tmp$ = -60						; size = 4
_pskinref$ = -56					; size = 4
_pmesh$ = -52						; size = 4
_ptexture$ = -48					; size = 4
_pstudionorms$ = -44					; size = 4
_pstudioverts$ = -40					; size = 4
_pnormbone$ = -36					; size = 4
_pvertbone$ = -32					; size = 4
_need_sort$ = -28					; size = 4
_shellscale$ = -24					; size = 4
_m_skinnum$ = -20					; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioDrawPoints PROC				; COMDAT

; 2282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2283 : 	int		i, j, k, m_skinnum;
; 2284 : 	float		shellscale = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _shellscale$[ebp], xmm0

; 2285 : 	qboolean		need_sort = false;

	mov	DWORD PTR _need_sort$[ebp], 0

; 2286 : 	byte		*pvertbone;
; 2287 : 	byte		*pnormbone;
; 2288 : 	vec3_t		*pstudioverts;
; 2289 : 	vec3_t		*pstudionorms;
; 2290 : 	mstudiotexture_t	*ptexture;
; 2291 : 	mstudiomesh_t	*pmesh;
; 2292 : 	short		*pskinref;
; 2293 : 	float		lv_tmp;
; 2294 : 
; 2295 : 	if( !m_pStudioHeader ) return;

	cmp	DWORD PTR _m_pStudioHeader, 0
	jne	SHORT $LN23@R_StudioDr
	jmp	$LN21@R_StudioDr
$LN23@R_StudioDr:

; 2296 : 
; 2297 : 	// safety bounding the skinnum
; 2298 : 	m_skinnum = bound( 0, RI.currententity->curstate.skin, ( m_pStudioHeader->numskinfamilies - 1 ));	    

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1048], 0
	jl	SHORT $LN52@R_StudioDr
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [ecx+196]
	sub	edx, 1
	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1048], edx
	jge	SHORT $LN50@R_StudioDr
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+1048]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN51@R_StudioDr
$LN50@R_StudioDr:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+196]
	sub	ecx, 1
	mov	DWORD PTR tv74[ebp], ecx
$LN51@R_StudioDr:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], edx
	jmp	SHORT $LN53@R_StudioDr
$LN52@R_StudioDr:
	mov	DWORD PTR tv75[ebp], 0
$LN53@R_StudioDr:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _m_skinnum$[ebp], eax

; 2299 : 	ptexture = (mstudiotexture_t *)((byte *)m_pStudioHeader + m_pStudioHeader->textureindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx

; 2300 : 	pvertbone = ((byte *)m_pStudioHeader + m_pSubModel->vertinfoindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _pvertbone$[ebp], ecx

; 2301 : 	pnormbone = ((byte *)m_pStudioHeader + m_pSubModel->norminfoindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pnormbone$[ebp], ecx

; 2302 : 
; 2303 : 	pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _pmesh$[ebp], ecx

; 2304 : 	pstudioverts = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->vertindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _pstudioverts$[ebp], ecx

; 2305 : 	pstudionorms = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->normindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _pstudionorms$[ebp], ecx

; 2306 : 
; 2307 : 	pskinref = (short *)((byte *)m_pStudioHeader + m_pStudioHeader->skinindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR _pskinref$[ebp], ecx

; 2308 : 	if( m_skinnum != 0 ) pskinref += (m_skinnum * m_pStudioHeader->numskinref);

	cmp	DWORD PTR _m_skinnum$[ebp], 0
	je	SHORT $LN24@R_StudioDr
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_skinnum$[ebp]
	imul	ecx, DWORD PTR [eax+192]
	mov	edx, DWORD PTR _pskinref$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pskinref$[ebp], eax
$LN24@R_StudioDr:

; 2309 : 
; 2310 : 	if( FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEWEIGHTS ) && m_pSubModel->blendvertinfoindex != 0 && m_pSubModel->blendnorminfoindex != 0 )

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+136]
	and	ecx, -2147483648			; 80000000H
	je	$LN25@R_StudioDr
	mov	eax, DWORD PTR _m_pSubModel
	cmp	DWORD PTR [eax+104], 0
	je	$LN25@R_StudioDr
	mov	eax, DWORD PTR _m_pSubModel
	cmp	DWORD PTR [eax+108], 0
	je	$LN25@R_StudioDr

; 2311 : 	{
; 2312 : 		mstudioboneweight_t	*pvertweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + m_pSubModel->blendvertinfoindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _pvertweight$8[ebp], ecx

; 2313 : 		mstudioboneweight_t	*pnormweight = (mstudioboneweight_t *)((byte *)m_pStudioHeader + m_pSubModel->blendnorminfoindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _pnormweight$7[ebp], ecx

; 2314 : 		matrix3x4		skinMat;
; 2315 : 
; 2316 : 		for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioDr
$LN2@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $LN3@R_StudioDr

; 2317 : 		{
; 2318 : 			R_StudioComputeSkinMatrix( &pvertweight[i], skinMat );

	lea	eax, DWORD PTR _skinMat$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pvertweight$8[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_R_StudioComputeSkinMatrix
	add	esp, 8

; 2319 : 			Matrix3x4_VectorTransform( skinMat, pstudioverts[i], g_studio.verts[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _g_studio+36948
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pstudioverts$[ebp]
	push	ecx
	lea	edx, DWORD PTR _skinMat$6[ebp]
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2320 : 			R_LightStrength( pvertbone[i], pstudioverts[i], g_studio.lightpos[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _g_studio+829100
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pstudioverts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvertbone$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_R_LightStrength
	add	esp, 12					; 0000000cH

; 2321 : 		}

	jmp	SHORT $LN2@R_StudioDr
$LN3@R_StudioDr:

; 2322 : 
; 2323 : 		for( i = 0; i < m_pSubModel->numnorms; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_StudioDr
$LN5@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+92]
	jge	SHORT $LN6@R_StudioDr

; 2324 : 		{
; 2325 : 			R_StudioComputeSkinMatrix( &pnormweight[i], skinMat );

	lea	eax, DWORD PTR _skinMat$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pnormweight$7[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_R_StudioComputeSkinMatrix
	add	esp, 8

; 2326 : 			Matrix3x4_VectorRotate( skinMat, pstudionorms[i], g_studio.norms[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _g_studio+233556
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pstudionorms$[ebp]
	push	ecx
	lea	edx, DWORD PTR _skinMat$6[ebp]
	push	edx
	call	_Matrix3x4_VectorRotate
	add	esp, 12					; 0000000cH

; 2327 : 		}

	jmp	SHORT $LN5@R_StudioDr
$LN6@R_StudioDr:

; 2328 : 	}

	jmp	SHORT $LN9@R_StudioDr
$LN25@R_StudioDr:

; 2329 : 	else
; 2330 : 	{
; 2331 : 		for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@R_StudioDr
$LN8@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $LN9@R_StudioDr

; 2332 : 		{
; 2333 : 			Matrix3x4_VectorTransform( g_studio.bonestransform[pvertbone[i]], pstudioverts[i], g_studio.verts[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _g_studio+36948
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pstudioverts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvertbone$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 2334 : 			R_LightStrength( pvertbone[i], pstudioverts[i], g_studio.lightpos[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _g_studio+829100
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pstudioverts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvertbone$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	_R_LightStrength
	add	esp, 12					; 0000000cH

; 2335 : 		}

	jmp	SHORT $LN8@R_StudioDr
$LN9@R_StudioDr:

; 2336 : 	}
; 2337 : 
; 2338 : 	// generate shared normals for properly scaling glowing shell
; 2339 : 	if( RI.currententity->curstate.renderfx == kRenderFxGlowShell )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+996], 19			; 00000013H
	jne	SHORT $LN27@R_StudioDr

; 2340 : 	{
; 2341 : 		float factor = (1.0f / 128.0f);

	movss	xmm0, DWORD PTR __real@3c000000
	movss	DWORD PTR _factor$5[ebp], xmm0

; 2342 : 		shellscale = Q_max( factor, RI.currententity->curstate.renderamt * factor );

	mov	eax, DWORD PTR _RI+28
	cvtsi2ss xmm0, DWORD PTR [eax+988]
	mulss	xmm0, DWORD PTR _factor$5[ebp]
	movss	xmm1, DWORD PTR _factor$5[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN54@R_StudioDr
	movss	xmm0, DWORD PTR _factor$5[ebp]
	movss	DWORD PTR tv212[ebp], xmm0
	jmp	SHORT $LN55@R_StudioDr
$LN54@R_StudioDr:
	mov	ecx, DWORD PTR _RI+28
	cvtsi2ss xmm0, DWORD PTR [ecx+988]
	mulss	xmm0, DWORD PTR _factor$5[ebp]
	movss	DWORD PTR tv212[ebp], xmm0
$LN55@R_StudioDr:
	movss	xmm0, DWORD PTR tv212[ebp]
	movss	DWORD PTR _shellscale$[ebp], xmm0

; 2343 : 		R_StudioBuildNormalTable();

	call	_R_StudioBuildNormalTable

; 2344 : 		R_StudioGenerateNormals();

	call	_R_StudioGenerateNormals
$LN27@R_StudioDr:

; 2345 : 	}
; 2346 : 
; 2347 : 	for( j = k = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _k$[ebp], 0
	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN13@R_StudioDr
$LN11@R_StudioDr:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN12@R_StudioDr

; 2348 : 	{
; 2349 : 		g_nFaceFlags = ptexture[pskinref[pmesh[j].skinref]].flags | g_nForceFaceFlags;

	imul	eax, DWORD PTR _j$[ebp], 20
	mov	ecx, DWORD PTR _pmesh$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	eax, DWORD PTR _pskinref$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	imul	edx, ecx, 80
	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+edx+64]
	or	ecx, DWORD PTR _g_nForceFaceFlags
	mov	DWORD PTR _g_nFaceFlags, ecx

; 2350 : 
; 2351 : 		// fill in sortedmesh info
; 2352 : 		g_studio.meshes[j].flags = g_nFaceFlags;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _g_nFaceFlags
	mov	DWORD PTR _g_studio[eax*8+34904], ecx

; 2353 : 		g_studio.meshes[j].mesh = &pmesh[j];

	imul	eax, DWORD PTR _j$[ebp], 20
	add	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_studio[ecx*8+34900], eax

; 2354 : 
; 2355 : 		if( FBitSet( g_nFaceFlags, STUDIO_NF_MASKED|STUDIO_NF_ADDITIVE ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 96					; 00000060H
	je	SHORT $LN28@R_StudioDr

; 2356 : 			need_sort = true;

	mov	DWORD PTR _need_sort$[ebp], 1
$LN28@R_StudioDr:

; 2357 : 
; 2358 : 		if( RI.currententity->curstate.rendermode == kRenderTransAdd )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 5
	jne	$LN29@R_StudioDr

; 2359 : 		{
; 2360 : 			for( i = 0; i < pmesh[j].numnorms; i++, k++, pstudionorms++, pnormbone++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@R_StudioDr
$LN14@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	mov	edx, DWORD PTR _pstudionorms$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pstudionorms$[ebp], edx
	mov	eax, DWORD PTR _pnormbone$[ebp]
	add	eax, 1
	mov	DWORD PTR _pnormbone$[ebp], eax
$LN16@R_StudioDr:
	imul	eax, DWORD PTR _j$[ebp], 20
	mov	ecx, DWORD PTR _pmesh$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+12]
	jge	$LN15@R_StudioDr

; 2361 : 			{
; 2362 : 				if( FBitSet( g_nFaceFlags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 2
	je	SHORT $LN31@R_StudioDr

; 2363 : 					R_StudioSetupChrome( g_studio.chrome[k], *pnormbone, (float *)pstudionorms );

	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnormbone$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _g_studio[eax*8+628364]
	push	ecx
	call	_R_StudioSetupChrome
	add	esp, 12					; 0000000cH
$LN31@R_StudioDr:

; 2364 : 				VectorSet( g_studio.lightvalues[k], tr.blend, tr.blend, tr.blend );

	imul	eax, DWORD PTR _k$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR _g_studio[eax+edx+431744], xmm0
	imul	eax, DWORD PTR _k$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR _g_studio[eax+ecx+431744], xmm0
	imul	edx, DWORD PTR _k$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR _g_studio[edx+eax+431744], xmm0

; 2365 : 			}

	jmp	$LN14@R_StudioDr
$LN15@R_StudioDr:

; 2366 : 		}

	jmp	$LN18@R_StudioDr
$LN29@R_StudioDr:

; 2367 : 		else
; 2368 : 		{
; 2369 : 			for( i = 0; i < pmesh[j].numnorms; i++, k++, pstudionorms++, pnormbone++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@R_StudioDr
$LN17@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	mov	edx, DWORD PTR _pstudionorms$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pstudionorms$[ebp], edx
	mov	eax, DWORD PTR _pnormbone$[ebp]
	add	eax, 1
	mov	DWORD PTR _pnormbone$[ebp], eax
$LN19@R_StudioDr:
	imul	eax, DWORD PTR _j$[ebp], 20
	mov	ecx, DWORD PTR _pmesh$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+12]
	jge	$LN18@R_StudioDr

; 2370 : 			{
; 2371 : 				if( FBitSet( m_pStudioHeader->flags, STUDIO_HAS_BONEWEIGHTS ))

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+136]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN32@R_StudioDr

; 2372 : 					R_StudioLighting( &lv_tmp, -1, g_nFaceFlags, g_studio.norms[k] );

	imul	eax, DWORD PTR _k$[ebp], 12
	add	eax, OFFSET _g_studio+233556
	push	eax
	mov	ecx, DWORD PTR _g_nFaceFlags
	push	ecx
	push	-1
	lea	edx, DWORD PTR _lv_tmp$[ebp]
	push	edx
	call	_R_StudioLighting
	add	esp, 16					; 00000010H
	jmp	SHORT $LN33@R_StudioDr
$LN32@R_StudioDr:

; 2373 : 				else R_StudioLighting( &lv_tmp, *pnormbone, g_nFaceFlags, (float *)pstudionorms );

	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_nFaceFlags
	push	ecx
	mov	edx, DWORD PTR _pnormbone$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _lv_tmp$[ebp]
	push	ecx
	call	_R_StudioLighting
	add	esp, 16					; 00000010H
$LN33@R_StudioDr:

; 2374 : 
; 2375 : 				if( FBitSet( g_nFaceFlags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 2
	je	SHORT $LN34@R_StudioDr

; 2376 : 					R_StudioSetupChrome( g_studio.chrome[k], *pnormbone, (float *)pstudionorms );

	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnormbone$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _g_studio[eax*8+628364]
	push	ecx
	call	_R_StudioSetupChrome
	add	esp, 12					; 0000000cH
$LN34@R_StudioDr:

; 2377 : 				VectorScale( g_studio.lightcolor, lv_tmp, g_studio.lightvalues[k] );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+430196]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	imul	edx, DWORD PTR _k$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+431744], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+430196]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	imul	eax, DWORD PTR _k$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _g_studio[eax+ecx+431744], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _g_studio[edx+430196]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	movss	DWORD PTR tv316[ebp], xmm0
	imul	eax, DWORD PTR _k$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv316[ebp]
	movss	DWORD PTR _g_studio[eax+ecx+431744], xmm0

; 2378 : 			}

	jmp	$LN17@R_StudioDr
$LN18@R_StudioDr:

; 2379 : 		}
; 2380 : 	}

	jmp	$LN11@R_StudioDr
$LN12@R_StudioDr:

; 2381 : 
; 2382 : 	if( r_studio_sort_textures->value && need_sort )

	mov	eax, DWORD PTR _r_studio_sort_textures
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN35@R_StudioDr
	cmp	DWORD PTR _need_sort$[ebp], 0
	je	SHORT $LN35@R_StudioDr

; 2383 : 	{
; 2384 : 		// resort opaque and translucent meshes draw order
; 2385 : 		qsort( g_studio.meshes, m_pSubModel->nummesh, sizeof( sortedmesh_t ), R_StudioMeshCompare );

	push	OFFSET _R_StudioMeshCompare
	push	8
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	push	OFFSET _g_studio+34900
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H
$LN35@R_StudioDr:

; 2386 : 	}
; 2387 : 
; 2388 : 	// NOTE: rewind normals at start
; 2389 : 	pstudionorms = (vec3_t *)((byte *)m_pStudioHeader + m_pSubModel->normindex);

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _pstudionorms$[ebp], ecx

; 2390 : 
; 2391 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@R_StudioDr
$LN20@R_StudioDr:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@R_StudioDr:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN21@R_StudioDr

; 2392 : 	{
; 2393 : 		float	oldblend = tr.blend;

	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR _oldblend$4[ebp], xmm0

; 2394 : 		short	*ptricmds;
; 2395 : 		float	s, t;
; 2396 : 
; 2397 : 		pmesh = g_studio.meshes[j].mesh;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _g_studio[eax*8+34900]
	mov	DWORD PTR _pmesh$[ebp], ecx

; 2398 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$3[ebp], ecx

; 2399 : 
; 2400 : 		g_nFaceFlags = ptexture[pskinref[pmesh->skinref]].flags | g_nForceFaceFlags;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 80
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+ecx+64]
	or	eax, DWORD PTR _g_nForceFaceFlags
	mov	DWORD PTR _g_nFaceFlags, eax

; 2401 : 
; 2402 : 		s = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].width;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 80
	mov	edx, DWORD PTR _ptexture$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+68]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _s$2[ebp], xmm1

; 2403 : 		t = 1.0f / (float)ptexture[pskinref[pmesh->skinref]].height;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	ecx, eax, 80
	mov	edx, DWORD PTR _ptexture$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+72]
	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR _t$1[ebp], xmm1

; 2404 : 
; 2405 : 		if( FBitSet( g_nFaceFlags, STUDIO_NF_MASKED ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 64					; 00000040H
	je	SHORT $LN36@R_StudioDr

; 2406 : 		{
; 2407 : 			pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 2408 : 			pglAlphaFunc( GL_GREATER, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 2409 : 			pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 2410 : 			if( R_ModelOpaque( RI.currententity->curstate.rendermode ))

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN38@R_StudioDr

; 2411 : 				tr.blend = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+87592, xmm0
$LN38@R_StudioDr:

; 2412 : 		}

	jmp	SHORT $LN41@R_StudioDr
$LN36@R_StudioDr:

; 2413 : 		else if( FBitSet( g_nFaceFlags, STUDIO_NF_ADDITIVE ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 32					; 00000020H
	je	SHORT $LN41@R_StudioDr

; 2414 : 		{
; 2415 : 			if( R_ModelOpaque( RI.currententity->curstate.rendermode ))

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN40@R_StudioDr

; 2416 : 			{
; 2417 : 				pglBlendFunc( GL_ONE, GL_ONE );

	push	1
	push	1
	call	DWORD PTR _pglBlendFunc

; 2418 : 				pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 2419 : 				pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 2420 : 				R_AllowFog( false );

	push	0
	call	_R_AllowFog
	add	esp, 4

; 2421 : 			}

	jmp	SHORT $LN41@R_StudioDr
$LN40@R_StudioDr:

; 2422 : 			else pglBlendFunc( GL_SRC_ALPHA, GL_ONE );

	push	1
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc
$LN41@R_StudioDr:

; 2423 : 		}
; 2424 : 
; 2425 : 		R_StudioSetupSkin( m_pStudioHeader, pskinref[pmesh->skinref] );

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _m_pStudioHeader
	push	ecx
	call	_R_StudioSetupSkin
	add	esp, 8

; 2426 : 
; 2427 : 		if( FBitSet( g_nFaceFlags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 2
	je	SHORT $LN42@R_StudioDr

; 2428 : 			R_StudioDrawChromeMesh( ptricmds, pstudionorms, s, t, shellscale );

	push	ecx
	movss	xmm0, DWORD PTR _shellscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	push	ecx
	call	_R_StudioDrawChromeMesh
	add	esp, 20					; 00000014H
	jmp	SHORT $LN45@R_StudioDr
$LN42@R_StudioDr:

; 2429 : 		else if( FBitSet( g_nFaceFlags, STUDIO_NF_UV_COORDS ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN44@R_StudioDr

; 2430 : 			R_StudioDrawFloatMesh( ptricmds, pstudionorms );

	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	push	ecx
	call	_R_StudioDrawFloatMesh
	add	esp, 8
	jmp	SHORT $LN45@R_StudioDr
$LN44@R_StudioDr:

; 2431 : 		else R_StudioDrawNormalMesh( ptricmds, pstudionorms, s, t );

	push	ecx
	movss	xmm0, DWORD PTR _t$1[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pstudionorms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	push	ecx
	call	_R_StudioDrawNormalMesh
	add	esp, 16					; 00000010H
$LN45@R_StudioDr:

; 2432 : 
; 2433 : 		if( FBitSet( g_nFaceFlags, STUDIO_NF_MASKED ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 64					; 00000040H
	je	SHORT $LN46@R_StudioDr

; 2434 : 		{
; 2435 : 			pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 2436 : 			pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 2437 : 		}

	jmp	SHORT $LN48@R_StudioDr
$LN46@R_StudioDr:

; 2438 : 		else if( FBitSet( g_nFaceFlags, STUDIO_NF_ADDITIVE ) && R_ModelOpaque( RI.currententity->curstate.rendermode ))

	mov	eax, DWORD PTR _g_nFaceFlags
	and	eax, 32					; 00000020H
	je	SHORT $LN48@R_StudioDr
	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN48@R_StudioDr

; 2439 : 		{
; 2440 : 			pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 2441 : 			pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 2442 : 			R_AllowFog( true );

	push	1
	call	_R_AllowFog
	add	esp, 4
$LN48@R_StudioDr:

; 2443 : 		}
; 2444 : 
; 2445 : 		r_stats.c_studio_polys += pmesh->numtris;

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _r_stats+4
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _r_stats+4, ecx

; 2446 : 		tr.blend = oldblend;

	movss	xmm0, DWORD PTR _oldblend$4[ebp]
	movss	DWORD PTR _tr+87592, xmm0

; 2447 : 	}

	jmp	$LN20@R_StudioDr
$LN21@R_StudioDr:

; 2448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawPoints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawChromeMesh
_TEXT	SEGMENT
tv148 = -104						; size = 4
tv69 = -104						; size = 4
tv65 = -104						; size = 4
_vert$ = -36						; size = 12
_glowShell$ = -24					; size = 4
_idx$ = -20						; size = 4
_i$ = -16						; size = 4
_av$ = -12						; size = 4
_lv$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ptricmds$ = 8						; size = 4
_pstudionorms$ = 12					; size = 4
_s$ = 16						; size = 4
_t$ = 20						; size = 4
_scale$ = 24						; size = 4
_R_StudioDrawChromeMesh PROC				; COMDAT

; 2233 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2234 : 	float	*lv, *av;
; 2235 : 	int	i, idx;
; 2236 : 	qboolean	glowShell = (scale > 0.0f) ? true : false;

	movss	xmm0, DWORD PTR _scale$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN14@R_StudioDr
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN15@R_StudioDr
$LN14@R_StudioDr:
	mov	DWORD PTR tv65[ebp], 0
$LN15@R_StudioDr:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _glowShell$[ebp], eax
$LN2@R_StudioDr:

; 2237 : 	vec3_t	vert;
; 2238 : 
; 2239 : 	while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$[ebp], eax
	cmp	DWORD PTR tv69[ebp], 0
	je	$LN3@R_StudioDr

; 2240 : 	{
; 2241 : 		if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN7@R_StudioDr

; 2242 : 		{
; 2243 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 2244 : 			i = -i;

	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax

; 2245 : 		}

	jmp	SHORT $LN8@R_StudioDr
$LN7@R_StudioDr:

; 2246 : 		else pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN8@R_StudioDr:

; 2247 : 
; 2248 : 		for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $LN6@R_StudioDr
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$[ebp], ecx
$LN6@R_StudioDr:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN5@R_StudioDr

; 2249 : 		{
; 2250 : 			if( glowShell )

	cmp	DWORD PTR _glowShell$[ebp], 0
	je	$LN9@R_StudioDr

; 2251 : 			{
; 2252 : 				idx = g_studio.normaltable[ptricmds[0]];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _g_studio[eax*4+763020]
	mov	DWORD PTR _idx$[ebp], ecx

; 2253 : 				av = g_studio.verts[ptricmds[0]];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+36948
	mov	DWORD PTR _av$[ebp], ecx

; 2254 : 				lv = g_studio.norms[ptricmds[0]];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+233556
	mov	DWORD PTR _lv$[ebp], ecx

; 2255 : 				VectorMA( av, scale, lv, vert );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _lv$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _av$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vert$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lv$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _av$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vert$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lv$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _av$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv148[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv148[ebp]
	movss	DWORD PTR _vert$[ebp+edx], xmm0

; 2256 : 				pglTexCoord2f( g_studio.chrome[idx][0] * s, g_studio.chrome[idx][1] * t );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _g_studio[eax+ecx*8+628364]
	mulss	xmm0, DWORD PTR _t$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _g_studio[eax+ecx*8+628364]
	mulss	xmm0, DWORD PTR _s$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2257 : 				pglVertex3fv( vert );

	lea	eax, DWORD PTR _vert$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2258 : 			}

	jmp	$LN10@R_StudioDr
$LN9@R_StudioDr:

; 2259 : 			else
; 2260 : 			{
; 2261 : 				idx = ptricmds[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	mov	DWORD PTR _idx$[ebp], edx

; 2262 : 				lv = (float *)g_studio.lightvalues[ptricmds[1]];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	add	eax, OFFSET _g_studio+431744
	mov	DWORD PTR _lv$[ebp], eax

; 2263 : 				if( g_studio.numlocallights )

	cmp	DWORD PTR _g_studio+828556, 0
	je	SHORT $LN11@R_StudioDr

; 2264 : 					R_LightLambert( g_studio.lightpos[ptricmds[0]], pstudionorms[ptricmds[1]], lv );

	mov	eax, DWORD PTR _lv$[ebp]
	push	eax
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _pstudionorms$[ebp]
	push	ecx
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	shl	edx, 6
	add	edx, OFFSET _g_studio+829100
	push	edx
	call	_R_LightLambert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@R_StudioDr
$LN11@R_StudioDr:

; 2265 : 				else pglColor4f( lv[0], lv[1], lv[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN12@R_StudioDr:

; 2266 : 				pglTexCoord2f( g_studio.chrome[idx][0] * s, g_studio.chrome[idx][1] * t );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _g_studio[eax+ecx*8+628364]
	mulss	xmm0, DWORD PTR _t$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _g_studio[eax+ecx*8+628364]
	mulss	xmm0, DWORD PTR _s$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2267 : 				pglVertex3fv( g_studio.verts[ptricmds[0]] );

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+36948
	push	ecx
	call	DWORD PTR _pglVertex3fv
$LN10@R_StudioDr:

; 2268 : 			}
; 2269 : 		}

	jmp	$LN4@R_StudioDr
$LN5@R_StudioDr:

; 2270 : 
; 2271 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2272 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawChromeMesh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawFloatMesh
_TEXT	SEGMENT
tv67 = -76						; size = 4
_i$ = -8						; size = 4
_lv$ = -4						; size = 4
_ptricmds$ = 8						; size = 4
_pstudionorms$ = 12					; size = 4
_R_StudioDrawFloatMesh PROC				; COMDAT

; 2198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
$LN2@R_StudioDr:

; 2199 : 	float	*lv;
; 2200 : 	int	i;
; 2201 : 
; 2202 : 	while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$[ebp], eax
	cmp	DWORD PTR tv67[ebp], 0
	je	$LN3@R_StudioDr

; 2203 : 	{
; 2204 : 		if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN7@R_StudioDr

; 2205 : 		{
; 2206 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 2207 : 			i = -i;

	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax

; 2208 : 		}

	jmp	SHORT $LN8@R_StudioDr
$LN7@R_StudioDr:

; 2209 : 		else pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN8@R_StudioDr:

; 2210 : 
; 2211 : 		for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $LN6@R_StudioDr
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$[ebp], ecx
$LN6@R_StudioDr:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN5@R_StudioDr

; 2212 : 		{
; 2213 : 			lv = (float *)g_studio.lightvalues[ptricmds[1]];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	add	eax, OFFSET _g_studio+431744
	mov	DWORD PTR _lv$[ebp], eax

; 2214 : 			if( g_studio.numlocallights )

	cmp	DWORD PTR _g_studio+828556, 0
	je	SHORT $LN9@R_StudioDr

; 2215 : 				R_LightLambert( g_studio.lightpos[ptricmds[0]], pstudionorms[ptricmds[1]], lv );

	mov	eax, DWORD PTR _lv$[ebp]
	push	eax
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _pstudionorms$[ebp]
	push	ecx
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	shl	edx, 6
	add	edx, OFFSET _g_studio+829100
	push	edx
	call	_R_LightLambert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@R_StudioDr
$LN9@R_StudioDr:

; 2216 : 			else pglColor4f( lv[0], lv[1], lv[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN10@R_StudioDr:

; 2217 : 			pglTexCoord2f( HalfToFloat( ptricmds[2] ), HalfToFloat( ptricmds[3] ));

	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_HalfToFloat
	fstp	DWORD PTR [esp]
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	_HalfToFloat
	fstp	DWORD PTR [esp]
	call	DWORD PTR _pglTexCoord2f

; 2218 : 			pglVertex3fv( g_studio.verts[ptricmds[0]] );

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+36948
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 2219 : 		}

	jmp	$LN4@R_StudioDr
$LN5@R_StudioDr:

; 2220 : 
; 2221 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2222 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2223 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawFloatMesh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDrawNormalMesh
_TEXT	SEGMENT
tv67 = -76						; size = 4
_i$ = -8						; size = 4
_lv$ = -4						; size = 4
_ptricmds$ = 8						; size = 4
_pstudionorms$ = 12					; size = 4
_s$ = 16						; size = 4
_t$ = 20						; size = 4
_R_StudioDrawNormalMesh PROC				; COMDAT

; 2162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
$LN2@R_StudioDr:

; 2163 : 	float	*lv;
; 2164 : 	int	i;
; 2165 : 
; 2166 : 	while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR _ptricmds$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$[ebp], eax
	cmp	DWORD PTR tv67[ebp], 0
	je	$LN3@R_StudioDr

; 2167 : 	{
; 2168 : 		if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN7@R_StudioDr

; 2169 : 		{
; 2170 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 2171 : 			i = -i;

	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax

; 2172 : 		}

	jmp	SHORT $LN8@R_StudioDr
$LN7@R_StudioDr:

; 2173 : 		else pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN8@R_StudioDr:

; 2174 : 
; 2175 : 		for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $LN6@R_StudioDr
$LN4@R_StudioDr:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$[ebp], ecx
$LN6@R_StudioDr:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN5@R_StudioDr

; 2176 : 		{
; 2177 : 			lv = (float *)g_studio.lightvalues[ptricmds[1]];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	imul	eax, edx, 12
	add	eax, OFFSET _g_studio+431744
	mov	DWORD PTR _lv$[ebp], eax

; 2178 : 
; 2179 : 			if( g_studio.numlocallights )

	cmp	DWORD PTR _g_studio+828556, 0
	je	SHORT $LN9@R_StudioDr

; 2180 : 				R_LightLambert( g_studio.lightpos[ptricmds[0]], pstudionorms[ptricmds[1]], lv );

	mov	eax, DWORD PTR _lv$[ebp]
	push	eax
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _pstudionorms$[ebp]
	push	ecx
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ptricmds$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	shl	edx, 6
	add	edx, OFFSET _g_studio+829100
	push	edx
	call	_R_LightLambert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@R_StudioDr
$LN9@R_StudioDr:

; 2181 : 			else pglColor4f( lv[0], lv[1], lv[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lv$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f
$LN10@R_StudioDr:

; 2182 : 			pglTexCoord2f( ptricmds[2] * s, ptricmds[3] * t );

	mov	eax, 2
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _t$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _s$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2183 : 			pglVertex3fv( g_studio.verts[ptricmds[0]] );

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	imul	ecx, eax, 12
	add	ecx, OFFSET _g_studio+36948
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 2184 : 		}

	jmp	$LN4@R_StudioDr
$LN5@R_StudioDr:

; 2185 : 
; 2186 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2187 : 	}

	jmp	$LN2@R_StudioDr
$LN3@R_StudioDr:

; 2188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDrawNormalMesh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioMeshCompare
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_R_StudioMeshCompare PROC				; COMDAT

; 2144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2145 : 	if( FBitSet( a->flags, STUDIO_NF_ADDITIVE ))

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 32					; 00000020H
	je	SHORT $LN2@R_StudioMe

; 2146 : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@R_StudioMe
$LN2@R_StudioMe:

; 2147 : 
; 2148 : 	if( FBitSet( a->flags, STUDIO_NF_MASKED ))

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 64					; 00000040H
	je	SHORT $LN3@R_StudioMe

; 2149 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@R_StudioMe
$LN3@R_StudioMe:

; 2150 : 
; 2151 : 	return 0;

	xor	eax, eax
$LN1@R_StudioMe:

; 2152 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioMeshCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioRenderShadow
_TEXT	SEGMENT
_iSprite$ = 8						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
_p3$ = 20						; size = 4
_p4$ = 24						; size = 4
_R_StudioRenderShadow PROC				; COMDAT

; 2112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2113 : 	if( !p1 || !p2 || !p3 || !p4 )

	cmp	DWORD PTR _p1$[ebp], 0
	je	SHORT $LN3@R_StudioRe
	cmp	DWORD PTR _p2$[ebp], 0
	je	SHORT $LN3@R_StudioRe
	cmp	DWORD PTR _p3$[ebp], 0
	je	SHORT $LN3@R_StudioRe
	cmp	DWORD PTR _p4$[ebp], 0
	jne	SHORT $LN2@R_StudioRe
$LN3@R_StudioRe:

; 2114 : 		return;

	jmp	$LN4@R_StudioRe
$LN2@R_StudioRe:

; 2115 : 
; 2116 : 	if( TriSpriteTexture( CL_ModelHandle( iSprite ), 0 ))

	push	0
	mov	eax, DWORD PTR _iSprite$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	call	_TriSpriteTexture
	add	esp, 8
	test	eax, eax
	je	$LN4@R_StudioRe

; 2117 : 	{
; 2118 : 		TriRenderMode( kRenderTransAlpha );

	push	4
	call	_TriRenderMode
	add	esp, 4

; 2119 : 		TriColor4f( 0.0f, 0.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_TriColor4f
	add	esp, 16					; 00000010H

; 2120 : 
; 2121 : 		pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 2122 : 			pglTexCoord2f( 0.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2123 : 			pglVertex3fv( p1 );

	mov	eax, DWORD PTR _p1$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2124 : 			pglTexCoord2f( 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2125 : 			pglVertex3fv( p2 );

	mov	eax, DWORD PTR _p2$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2126 : 			pglTexCoord2f( 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2127 : 			pglVertex3fv( p3 );

	mov	eax, DWORD PTR _p3$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2128 : 			pglTexCoord2f( 1.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 2129 : 			pglVertex3fv( p4 );

	mov	eax, DWORD PTR _p4$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 2130 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 2131 : 
; 2132 : 		TriRenderMode( kRenderNormal );

	push	0
	call	_TriRenderMode
	add	esp, 4
$LN4@R_StudioRe:

; 2133 : 	}
; 2134 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioRenderShadow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetCullState
_TEXT	SEGMENT
_iCull$ = 8						; size = 4
_R_StudioSetCullState PROC				; COMDAT

; 2100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2101 : 	g_iBackFaceCull = iCull;

	mov	eax, DWORD PTR _iCull$[ebp]
	mov	DWORD PTR _g_iBackFaceCull, eax

; 2102 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetCullState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetRenderamt
_TEXT	SEGMENT
_iRenderamt$ = 8					; size = 4
_R_StudioSetRenderamt PROC				; COMDAT

; 2085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2086 : 	if( !RI.currententity ) return;

	cmp	DWORD PTR _RI+28, 0
	jne	SHORT $LN2@R_StudioSe
	jmp	SHORT $LN1@R_StudioSe
$LN2@R_StudioSe:

; 2087 : 
; 2088 : 	RI.currententity->curstate.renderamt = iRenderamt;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _iRenderamt$[ebp]
	mov	DWORD PTR [eax+988], ecx

; 2089 : 	tr.blend = CL_FxBlend( RI.currententity ) / 255.0f;

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_CL_FxBlend
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tr+87592, xmm0
$LN1@R_StudioSe:

; 2090 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetRenderamt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupSkin
_TEXT	SEGMENT
_ptexture$ = -4						; size = 4
_ptexturehdr$ = 8					; size = 4
_index$ = 12						; size = 4
_R_StudioSetupSkin PROC					; COMDAT

; 2042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2043 : 	mstudiotexture_t	*ptexture = NULL;

	mov	DWORD PTR _ptexture$[ebp], 0

; 2044 : 
; 2045 : 	if( FBitSet( g_nForceFaceFlags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _g_nForceFaceFlags
	and	eax, 2
	je	SHORT $LN2@R_StudioSe

; 2046 : 		return;

	jmp	$LN7@R_StudioSe
$LN2@R_StudioSe:

; 2047 : 
; 2048 : 	if( ptexturehdr == NULL )

	cmp	DWORD PTR _ptexturehdr$[ebp], 0
	jne	SHORT $LN3@R_StudioSe

; 2049 : 		return;

	jmp	$LN7@R_StudioSe
$LN3@R_StudioSe:

; 2050 : 
; 2051 : 	// NOTE: user may ignore to call StudioRemapColors and remap_info will be unavailable
; 2052 : 	if( m_fDoRemap ) ptexture = CL_GetRemapInfoForEntity( RI.currententity )->ptexture;

	cmp	DWORD PTR _m_fDoRemap, 0
	je	SHORT $LN4@R_StudioSe
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_CL_GetRemapInfoForEntity
	add	esp, 4
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _ptexture$[ebp], ecx
$LN4@R_StudioSe:

; 2053 : 	if( !ptexture ) ptexture = (mstudiotexture_t *)((byte *)ptexturehdr + ptexturehdr->textureindex); // fallback

	cmp	DWORD PTR _ptexture$[ebp], 0
	jne	SHORT $LN5@R_StudioSe
	mov	eax, DWORD PTR _ptexturehdr$[ebp]
	mov	ecx, DWORD PTR _ptexturehdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx
$LN5@R_StudioSe:

; 2054 : 
; 2055 : 	if( r_lightmap->value && !r_fullbright->value )

	mov	eax, DWORD PTR _r_lightmap
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_StudioSe
	mov	eax, DWORD PTR _r_fullbright
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_StudioSe

; 2056 : 		GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8
	jmp	SHORT $LN7@R_StudioSe
$LN6@R_StudioSe:

; 2057 : 	else GL_Bind( GL_TEXTURE0, ptexture[index].index );

	imul	eax, DWORD PTR _index$[ebp], 80
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+eax+76]
	push	edx
	push	0
	call	_GL_Bind
	add	esp, 8
$LN7@R_StudioSe:

; 2058 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupSkin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_LightStrength
_TEXT	SEGMENT
tv155 = -76						; size = 4
_el$1 = -8						; size = 4
_i$ = -4						; size = 4
_bone$ = 8						; size = 4
_localpos$ = 12						; size = 4
_light$ = 16						; size = 4
_R_LightStrength PROC					; COMDAT

; 2014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2015 : 	int	i;
; 2016 : 
; 2017 : 	if( g_studio.lightage[bone] != g_studio.framecount )

	mov	eax, DWORD PTR _bone$[ebp]
	mov	ecx, DWORD PTR _g_studio[eax*4+828560]
	cmp	ecx, DWORD PTR _g_studio+16
	je	SHORT $LN8@R_LightStr

; 2018 : 	{
; 2019 : 		for( i = 0; i < g_studio.numlocallights; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_LightStr
$LN2@R_LightStr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_LightStr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _g_studio+828556
	jge	SHORT $LN3@R_LightStr

; 2020 : 		{
; 2021 : 			dlight_t *el = g_studio.locallight[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_studio[eax*4+829072]
	mov	DWORD PTR _el$1[ebp], ecx

; 2022 : 			Matrix3x4_VectorITransform( g_studio.lighttransform[bone], el->origin, g_studio.lightbonepos[bone][i] );

	imul	eax, DWORD PTR _bone$[ebp], 48
	imul	ecx, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _g_studio[eax+ecx+1877676]
	push	edx
	mov	eax, DWORD PTR _el$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _bone$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_Matrix3x4_VectorITransform
	add	esp, 12					; 0000000cH

; 2023 : 		}

	jmp	SHORT $LN2@R_LightStr
$LN3@R_LightStr:

; 2024 : 
; 2025 : 		g_studio.lightage[bone] = g_studio.framecount;

	mov	eax, DWORD PTR _bone$[ebp]
	mov	ecx, DWORD PTR _g_studio+16
	mov	DWORD PTR _g_studio[eax*4+828560], ecx
$LN8@R_LightStr:

; 2026 : 	}
; 2027 : 
; 2028 : 	for( i = 0; i < g_studio.numlocallights; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_LightStr
$LN5@R_LightStr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_LightStr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _g_studio+828556
	jge	$LN6@R_LightStr

; 2029 : 	{
; 2030 : 		VectorSubtract( localpos, g_studio.lightbonepos[bone][i], light[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	imul	eax, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _g_studio[edx+eax+1877676]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _localpos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	imul	eax, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _g_studio[edx+eax+1877676]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _localpos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _bone$[ebp], 48
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	ecx, DWORD PTR _g_studio[ecx+edx+1877676]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _localpos$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [ecx+edx]
	movss	DWORD PTR tv155[ebp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _light$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv155[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 2031 : 		light[i][3] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _light$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 2032 : 	}

	jmp	$LN5@R_LightStr
$LN6@R_LightStr:

; 2033 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LightStrength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_LightLambert
_TEXT	SEGMENT
tv451 = -128						; size = 8
tv537 = -120						; size = 8
tv535 = -112						; size = 8
tv362 = -108						; size = 4
tv346 = -108						; size = 4
tv330 = -108						; size = 4
tv314 = -108						; size = 4
tv299 = -108						; size = 4
tv271 = -108						; size = 4
tv243 = -108						; size = 4
_r2$1 = -40						; size = 4
_r$2 = -36						; size = 4
_i$ = -32						; size = 4
_localLight$ = -28					; size = 12
_finalLight$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_light$ = 8						; size = 4
_normal$ = 12						; size = 4
_color$ = 16						; size = 4
_R_LightLambert PROC					; COMDAT

; 1967 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1968 : 	vec3_t	finalLight;
; 1969 : 	vec3_t	localLight;
; 1970 : 	int	i;
; 1971 : 
; 1972 : 	VectorCopy( color, finalLight );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _finalLight$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _color$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _finalLight$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _finalLight$[ebp+ecx], eax

; 1973 : 
; 1974 : 	for( i = 0; i < g_studio.numlocallights; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_LightLam
$LN2@R_LightLam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_LightLam:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _g_studio+828556
	jge	$LN3@R_LightLam

; 1975 : 	{
; 1976 : 		float	r, r2;
; 1977 : 
; 1978 : 		if( tr.fFlipViewModel )

	cmp	DWORD PTR _tr+83216, 0
	je	$LN5@R_LightLam

; 1979 : 			r = DotProduct( normal, light[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _r$2[ebp], xmm0
	jmp	$LN6@R_LightLam
$LN5@R_LightLam:

; 1980 : 		else r = -DotProduct( normal, light[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	addss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _r$2[ebp], xmm0
$LN6@R_LightLam:

; 1981 : 
; 1982 : 		if( r > 0.0f )

	movss	xmm0, DWORD PTR _r$2[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN7@R_LightLam

; 1983 : 		{
; 1984 : 			if( light[i][3] == 0.0f )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _light$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@R_LightLam

; 1985 : 			{
; 1986 : 				r2 = DotProduct( light[i], light[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _light$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	movss	DWORD PTR _r2$1[ebp], xmm0

; 1987 : 
; 1988 : 				if( r2 > 0.0f )

	movss	xmm0, DWORD PTR _r2$1[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN9@R_LightLam

; 1989 : 					light[i][3] = g_studio.locallightR2[i] / ( r2 * sqrt( r2 ));

	mov	eax, DWORD PTR _i$[ebp]
	cvtss2sd xmm0, DWORD PTR _g_studio[eax*4+1883820]
	cvtss2sd xmm1, DWORD PTR _r2$1[ebp]
	cvtss2sd xmm2, DWORD PTR _r2$1[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv535[ebp], xmm0
	movsd	QWORD PTR tv537[ebp], xmm1
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv451[ebp]
	movsd	xmm0, QWORD PTR tv537[ebp]
	mulsd	xmm0, QWORD PTR tv451[ebp]
	movsd	xmm1, QWORD PTR tv535[ebp]
	divsd	xmm1, xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR [ecx+eax], xmm0
	jmp	SHORT $LN10@R_LightLam
$LN9@R_LightLam:

; 1990 : 				else light[i][3] = 0.0001f;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _light$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR __real@38d1b717
	movss	DWORD PTR [eax+edx], xmm0
$LN10@R_LightLam:

; 1991 : 			}
; 1992 : 
; 1993 : 			localLight[0] = Q_min( g_studio.locallightcolor[i].r * r * light[i][3], 255.0f );

	imul	eax, DWORD PTR _i$[ebp], 3
	movzx	ecx, BYTE PTR _g_studio[eax+829088]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	mulss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@R_LightLam
	imul	edx, DWORD PTR _i$[ebp], 3
	movzx	eax, BYTE PTR _g_studio[edx+829088]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mulss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv243[ebp], xmm0
	jmp	SHORT $LN13@R_LightLam
$LN12@R_LightLam:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv243[ebp], xmm0
$LN13@R_LightLam:
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR tv243[ebp]
	movss	DWORD PTR _localLight$[ebp+edx], xmm0

; 1994 : 			localLight[1] = Q_min( g_studio.locallightcolor[i].g * r * light[i][3], 255.0f );

	imul	eax, DWORD PTR _i$[ebp], 3
	movzx	ecx, BYTE PTR _g_studio[eax+829089]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	mulss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@R_LightLam
	imul	edx, DWORD PTR _i$[ebp], 3
	movzx	eax, BYTE PTR _g_studio[edx+829089]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mulss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv271[ebp], xmm0
	jmp	SHORT $LN15@R_LightLam
$LN14@R_LightLam:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv271[ebp], xmm0
$LN15@R_LightLam:
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv271[ebp]
	movss	DWORD PTR _localLight$[ebp+ecx], xmm0

; 1995 : 			localLight[2] = Q_min( g_studio.locallightcolor[i].b * r * light[i][3], 255.0f );

	imul	eax, DWORD PTR _i$[ebp], 3
	movzx	ecx, BYTE PTR _g_studio[eax+829090]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _light$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	mulss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@R_LightLam
	imul	edx, DWORD PTR _i$[ebp], 3
	movzx	eax, BYTE PTR _g_studio[edx+829090]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _r$2[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _light$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mulss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv299[ebp], xmm0
	jmp	SHORT $LN17@R_LightLam
$LN16@R_LightLam:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv299[ebp], xmm0
$LN17@R_LightLam:
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv299[ebp]
	movss	DWORD PTR _localLight$[ebp+ecx], xmm0

; 1996 : 			VectorScale( localLight, ( 1.0f / 255.0f ), localLight );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _localLight$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _localLight$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _localLight$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _localLight$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _localLight$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3b808081
	movss	DWORD PTR tv314[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv314[ebp]
	movss	DWORD PTR _localLight$[ebp+ecx], xmm0

; 1997 : 
; 1998 : 			finalLight[0] = Q_min( finalLight[0] + localLight[0], 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	addss	xmm0, DWORD PTR _localLight$[ebp+eax]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@R_LightLam
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	addss	xmm0, DWORD PTR _localLight$[ebp+ecx]
	movss	DWORD PTR tv330[ebp], xmm0
	jmp	SHORT $LN19@R_LightLam
$LN18@R_LightLam:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv330[ebp], xmm0
$LN19@R_LightLam:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR tv330[ebp]
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0

; 1999 : 			finalLight[1] = Q_min( finalLight[1] + localLight[1], 1.0f );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	addss	xmm0, DWORD PTR _localLight$[ebp+ecx]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@R_LightLam
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	addss	xmm0, DWORD PTR _localLight$[ebp+eax]
	movss	DWORD PTR tv346[ebp], xmm0
	jmp	SHORT $LN21@R_LightLam
$LN20@R_LightLam:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv346[ebp], xmm0
$LN21@R_LightLam:
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv346[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0

; 2000 : 			finalLight[2] = Q_min( finalLight[2] + localLight[2], 1.0f );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	addss	xmm0, DWORD PTR _localLight$[ebp+ecx]
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN22@R_LightLam
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	addss	xmm0, DWORD PTR _localLight$[ebp+eax]
	movss	DWORD PTR tv362[ebp], xmm0
	jmp	SHORT $LN23@R_LightLam
$LN22@R_LightLam:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv362[ebp], xmm0
$LN23@R_LightLam:
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv362[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0
$LN7@R_LightLam:

; 2001 : 		}
; 2002 : 	}

	jmp	$LN2@R_LightLam
$LN3@R_LightLam:

; 2003 : 
; 2004 : 	pglColor4f( finalLight[0], finalLight[1], finalLight[2], tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	push	ecx
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	push	ecx
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	push	ecx
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 2005 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_LightLambert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioLighting
_TEXT	SEGMENT
tv168 = -80						; size = 4
tv166 = -80						; size = 4
_lightcos$1 = -12					; size = 4
_r$2 = -8						; size = 4
_illum$ = -4						; size = 4
_lv$ = 8						; size = 4
_bone$ = 12						; size = 4
_flags$ = 16						; size = 4
_normal$ = 20						; size = 4
_R_StudioLighting PROC					; COMDAT

; 1911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1912 : 	float 	illum;
; 1913 : 
; 1914 : 	if( FBitSet( flags, STUDIO_NF_FULLBRIGHT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN2@R_StudioLi

; 1915 : 	{
; 1916 : 		*lv = 1.0f;

	mov	eax, DWORD PTR _lv$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0

; 1917 : 		return;

	jmp	$LN1@R_StudioLi
$LN2@R_StudioLi:

; 1918 : 	}
; 1919 : 
; 1920 : 	illum = g_studio.ambientlight;

	movss	xmm0, DWORD PTR _g_studio+430164
	movss	DWORD PTR _illum$[ebp], xmm0

; 1921 : 
; 1922 : 	if( FBitSet( flags, STUDIO_NF_FLATSHADE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN3@R_StudioLi

; 1923 : 	{
; 1924 : 		illum += g_studio.shadelight * 0.8f;

	movss	xmm0, DWORD PTR _g_studio+430168
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	addss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0

; 1925 : 	} 

	jmp	$LN4@R_StudioLi
$LN3@R_StudioLi:

; 1926 : 	else 
; 1927 : 	{
; 1928 : 		float	r, lightcos;
; 1929 : 
; 1930 : 		if( bone != -1 ) lightcos = DotProduct( normal, g_studio.blightvec[bone] );

	cmp	DWORD PTR _bone$[ebp], -1
	je	SHORT $LN5@R_StudioLi
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR _g_studio[edx+eax+430208]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+430208]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+430208]
	addss	xmm0, xmm1
	movss	DWORD PTR _lightcos$1[ebp], xmm0
	jmp	SHORT $LN6@R_StudioLi
$LN5@R_StudioLi:

; 1931 : 		else lightcos = DotProduct( normal, g_studio.lightvec ); // -1 colinear, 1 opposite

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _g_studio[eax+430172]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _g_studio[ecx+430172]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _g_studio[ecx+430172]
	addss	xmm0, xmm1
	movss	DWORD PTR _lightcos$1[ebp], xmm0
$LN6@R_StudioLi:

; 1932 : 		if( lightcos > 1.0f ) lightcos = 1.0f;

	movss	xmm0, DWORD PTR _lightcos$1[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@R_StudioLi
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lightcos$1[ebp], xmm0
$LN7@R_StudioLi:

; 1933 : 
; 1934 : 		illum += g_studio.shadelight;

	movss	xmm0, DWORD PTR _illum$[ebp]
	addss	xmm0, DWORD PTR _g_studio+430168
	movss	DWORD PTR _illum$[ebp], xmm0

; 1935 : 
; 1936 : 		r = SHADE_LAMBERT;

	movss	xmm0, DWORD PTR __real@3fbf5c29
	movss	DWORD PTR _r$2[ebp], xmm0

; 1937 : 
; 1938 :  		// do modified hemispherical lighting
; 1939 : 		if( r <= 1.0f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _r$2[ebp]
	jb	SHORT $LN8@R_StudioLi

; 1940 : 		{
; 1941 : 			r += 1.0f;

	movss	xmm0, DWORD PTR _r$2[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _r$2[ebp], xmm0

; 1942 : 			lightcos = (( r - 1.0f ) - lightcos) / r;

	movss	xmm0, DWORD PTR _r$2[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _lightcos$1[ebp]
	divss	xmm0, DWORD PTR _r$2[ebp]
	movss	DWORD PTR _lightcos$1[ebp], xmm0

; 1943 : 			if( lightcos > 0.0f ) 

	movss	xmm0, DWORD PTR _lightcos$1[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@R_StudioLi

; 1944 : 				illum += g_studio.shadelight * lightcos; 

	movss	xmm0, DWORD PTR _g_studio+430168
	mulss	xmm0, DWORD PTR _lightcos$1[ebp]
	addss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0
$LN10@R_StudioLi:

; 1945 : 		}

	jmp	SHORT $LN11@R_StudioLi
$LN8@R_StudioLi:

; 1946 : 		else
; 1947 : 		{
; 1948 : 			lightcos = (lightcos + ( r - 1.0f )) / r;

	movss	xmm0, DWORD PTR _r$2[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _lightcos$1[ebp]
	divss	xmm0, DWORD PTR _r$2[ebp]
	movss	DWORD PTR _lightcos$1[ebp], xmm0

; 1949 : 			if( lightcos > 0.0f )

	movss	xmm0, DWORD PTR _lightcos$1[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@R_StudioLi

; 1950 : 				illum -= g_studio.shadelight * lightcos; 

	movss	xmm0, DWORD PTR _g_studio+430168
	mulss	xmm0, DWORD PTR _lightcos$1[ebp]
	movss	xmm1, DWORD PTR _illum$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _illum$[ebp], xmm1
$LN11@R_StudioLi:

; 1951 : 		}
; 1952 : 
; 1953 : 		illum = Q_max( illum, 0.0f );

	movss	xmm0, DWORD PTR _illum$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN13@R_StudioLi
	movss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR tv166[ebp], xmm0
	jmp	SHORT $LN14@R_StudioLi
$LN13@R_StudioLi:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv166[ebp], xmm0
$LN14@R_StudioLi:
	movss	xmm0, DWORD PTR tv166[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0
$LN4@R_StudioLi:

; 1954 : 	}
; 1955 : 
; 1956 : 	illum = Q_min( illum, 255.0f );

	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _illum$[ebp]
	jbe	SHORT $LN15@R_StudioLi
	movss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR tv168[ebp], xmm0
	jmp	SHORT $LN16@R_StudioLi
$LN15@R_StudioLi:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv168[ebp], xmm0
$LN16@R_StudioLi:
	movss	xmm0, DWORD PTR tv168[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0

; 1957 : 	*lv = illum * (1.0f / 255.0f);

	movss	xmm0, DWORD PTR _illum$[ebp]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	eax, DWORD PTR _lv$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN1@R_StudioLi:

; 1958 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupLighting
_TEXT	SEGMENT
_ilength$1 = -12					; size = 4
_i$ = -8						; size = 4
_scale$ = -4						; size = 4
_plight$ = 8						; size = 4
_R_StudioSetupLighting PROC				; COMDAT

; 1881 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1882 : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 1883 : 	int	i;
; 1884 : 
; 1885 : 	if( !m_pStudioHeader || !plight )

	cmp	DWORD PTR _m_pStudioHeader, 0
	je	SHORT $LN6@R_StudioSe
	cmp	DWORD PTR _plight$[ebp], 0
	jne	SHORT $LN5@R_StudioSe
$LN6@R_StudioSe:

; 1886 : 		return;

	jmp	$LN1@R_StudioSe
$LN5@R_StudioSe:

; 1887 : 
; 1888 : 	if( RI.currententity != NULL )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN7@R_StudioSe

; 1889 : 		scale = RI.currententity->curstate.scale;

	mov	eax, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [eax+976]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN7@R_StudioSe:

; 1890 : 
; 1891 : 	g_studio.ambientlight = plight->ambientlight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	movss	DWORD PTR _g_studio+430164, xmm0

; 1892 : 	g_studio.shadelight = plight->shadelight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _g_studio+430168, xmm0

; 1893 : 	VectorCopy( plight->plightvec, g_studio.lightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_studio[edx+430172], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_studio[edx+430172], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_studio[edx+430172], eax

; 1894 : 
; 1895 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioSe
$LN2@R_StudioSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioSe:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN3@R_StudioSe

; 1896 : 	{
; 1897 : 		Matrix3x4_VectorIRotate( g_studio.lighttransform[i], plight->plightvec, g_studio.blightvec[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET _g_studio+430208
	push	eax
	mov	ecx, DWORD PTR _plight$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+6224
	push	eax
	call	_Matrix3x4_VectorIRotate
	add	esp, 12					; 0000000cH

; 1898 : 		if( scale > 1.0f ) VectorNormalize( g_studio.blightvec[i] ); // in case model may be scaled

	movss	xmm0, DWORD PTR _scale$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN8@R_StudioSe
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+430208]
	mulss	xmm0, DWORD PTR _g_studio[ecx+esi+430208]
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR _g_studio[edx+eax+430208]
	mulss	xmm1, DWORD PTR _g_studio[ecx+esi+430208]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR _g_studio[edx+eax+430208]
	mulss	xmm1, DWORD PTR _g_studio[ecx+esi+430208]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@R_StudioSe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN9@R_StudioSe:
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+430208]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[edx+ecx+430208], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+430208]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[eax+edx+430208], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+430208]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[eax+edx+430208], xmm0
$LN8@R_StudioSe:

; 1899 : 	}

	jmp	$LN2@R_StudioSe
$LN3@R_StudioSe:

; 1900 : 
; 1901 : 	VectorCopy( plight->color, g_studio.lightcolor );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _g_studio[eax+430196], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR _g_studio[eax+430196], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _g_studio[ecx+430196], eax
$LN1@R_StudioSe:

; 1902 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioEntityLight
_TEXT	SEGMENT
tv201 = -168						; size = 4
_att$1 = -100						; size = 4
_el$ = -96						; size = 4
_pos$ = -92						; size = 12
_origin$ = -80						; size = 12
_mid$ = -68						; size = 12
_ent$ = -56						; size = 4
_lstrength$ = -52					; size = 16
_r2$ = -36						; size = 4
_f$ = -32						; size = 4
_dist2$ = -28						; size = 4
_minstrength$ = -24					; size = 4
_k$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_lnum$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lightinfo$ = 8						; size = 4
_R_StudioEntityLight PROC				; COMDAT

; 1801 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1802 : 	int		lnum, i, j, k;
; 1803 : 	float		minstrength, dist2, f, r2;
; 1804 : 	float		lstrength[MAX_LOCALLIGHTS];
; 1805 : 	cl_entity_t	*ent = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _ent$[ebp], eax

; 1806 : 	vec3_t		mid, origin, pos;
; 1807 : 	dlight_t		*el;
; 1808 : 
; 1809 : 	g_studio.numlocallights = 0;

	mov	DWORD PTR _g_studio+828556, 0

; 1810 : 
; 1811 : 	if( !ent || !r_dynamic->value )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN12@R_StudioEn
	mov	eax, DWORD PTR _r_dynamic
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@R_StudioEn
$LN12@R_StudioEn:

; 1812 : 		return;

	jmp	$LN6@R_StudioEn
$LN11@R_StudioEn:

; 1813 : 
; 1814 : 	for( i = 0; i < MAX_LOCALLIGHTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioEn
$LN2@R_StudioEn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioEn:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@R_StudioEn

; 1815 : 		lstrength[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR _lstrength$[ebp+eax*4], xmm0
	jmp	SHORT $LN2@R_StudioEn
$LN3@R_StudioEn:

; 1816 : 
; 1817 : 	Matrix3x4_OriginFromMatrix( g_studio.rotationmatrix, origin );

	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	push	OFFSET _g_studio+32
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 1818 : 	dist2 = 1000000.0f;

	movss	xmm0, DWORD PTR __real@49742400
	movss	DWORD PTR _dist2$[ebp], xmm0

; 1819 : 	k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 1820 : 
; 1821 : 	for( lnum = 0, el = cl_elights; lnum < MAX_ELIGHTS; lnum++, el++ )

	mov	DWORD PTR _lnum$[ebp], 0
	mov	DWORD PTR _el$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN7@R_StudioEn
$LN5@R_StudioEn:
	mov	eax, DWORD PTR _lnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _lnum$[ebp], eax
	mov	ecx, DWORD PTR _el$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _el$[ebp], ecx
$LN7@R_StudioEn:
	cmp	DWORD PTR _lnum$[ebp], 64		; 00000040H
	jge	$LN6@R_StudioEn

; 1822 : 	{
; 1823 : 		if( el->die < g_studio.time || el->radius <= 0.0f )

	mov	eax, DWORD PTR _el$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _g_studio
	comisd	xmm1, xmm0
	ja	SHORT $LN14@R_StudioEn
	mov	eax, DWORD PTR _el$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jb	SHORT $LN13@R_StudioEn
$LN14@R_StudioEn:

; 1824 : 			continue;

	jmp	SHORT $LN5@R_StudioEn
$LN13@R_StudioEn:

; 1825 : 
; 1826 : 		if(( el->key & 0xFFF ) == ent->index )

	mov	eax, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4095				; 00000fffH
	mov	edx, DWORD PTR _ent$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jne	$LN17@R_StudioEn

; 1827 : 		{
; 1828 : 			int	att = (el->key >> 12) & 0xF;

	mov	eax, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	sar	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	mov	DWORD PTR _att$1[ebp], ecx

; 1829 : 
; 1830 : 			if( att ) VectorCopy( ent->attachment[att], el->origin );

	je	SHORT $LN16@R_StudioEn
	imul	eax, DWORD PTR _att$1[ebp], 12
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3248]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _att$1[ebp], 12
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3248]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
	imul	edx, DWORD PTR _att$1[ebp], 12
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [esi+eax], ecx
	jmp	SHORT $LN17@R_StudioEn
$LN16@R_StudioEn:

; 1831 : 			else VectorCopy( ent->origin, el->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _el$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _el$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _el$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax
$LN17@R_StudioEn:

; 1832 : 		}
; 1833 : 
; 1834 : 		VectorCopy( el->origin, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _el$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _el$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$[ebp+ecx], eax

; 1835 : 		VectorSubtract( origin, el->origin, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mid$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv201[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR _mid$[ebp+eax], xmm0

; 1836 : 
; 1837 : 		f = DotProduct( mid, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm0, DWORD PTR _mid$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _mid$[ebp+ecx]
	mulss	xmm1, DWORD PTR _mid$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _mid$[ebp+eax]
	mulss	xmm1, DWORD PTR _mid$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _f$[ebp], xmm0

; 1838 : 		r2 = el->radius * el->radius;

	mov	eax, DWORD PTR _el$[ebp]
	mov	ecx, DWORD PTR _el$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _r2$[ebp], xmm0

; 1839 : 
; 1840 : 		if( f > r2 ) minstrength = r2 / f;

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR _r2$[ebp]
	jbe	SHORT $LN18@R_StudioEn
	movss	xmm0, DWORD PTR _r2$[ebp]
	divss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _minstrength$[ebp], xmm0
	jmp	SHORT $LN19@R_StudioEn
$LN18@R_StudioEn:

; 1841 : 		else minstrength = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _minstrength$[ebp], xmm0
$LN19@R_StudioEn:

; 1842 : 
; 1843 : 		if( minstrength > 0.05f )

	movss	xmm0, DWORD PTR _minstrength$[ebp]
	comiss	xmm0, DWORD PTR __real@3d4ccccd
	jbe	$LN25@R_StudioEn

; 1844 : 		{
; 1845 : 			if( g_studio.numlocallights >= MAX_LOCALLIGHTS )

	cmp	DWORD PTR _g_studio+828556, 4
	jl	SHORT $LN21@R_StudioEn

; 1846 : 			{
; 1847 : 				for( j = 0, k = -1; j < g_studio.numlocallights; j++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _k$[ebp], -1
	jmp	SHORT $LN10@R_StudioEn
$LN8@R_StudioEn:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@R_StudioEn:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _g_studio+828556
	jge	SHORT $LN9@R_StudioEn

; 1848 : 				{
; 1849 : 					if( lstrength[j] < dist2 && lstrength[j] < minstrength )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _dist2$[ebp]
	comiss	xmm0, DWORD PTR _lstrength$[ebp+eax*4]
	jbe	SHORT $LN23@R_StudioEn
	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _minstrength$[ebp]
	comiss	xmm0, DWORD PTR _lstrength$[ebp+eax*4]
	jbe	SHORT $LN23@R_StudioEn

; 1850 : 					{
; 1851 : 						dist2 = lstrength[j];

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _lstrength$[ebp+eax*4]
	movss	DWORD PTR _dist2$[ebp], xmm0

; 1852 : 						k = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _k$[ebp], eax
$LN23@R_StudioEn:

; 1853 : 					}
; 1854 : 				}

	jmp	SHORT $LN8@R_StudioEn
$LN9@R_StudioEn:

; 1855 : 			}

	jmp	SHORT $LN22@R_StudioEn
$LN21@R_StudioEn:

; 1856 : 			else k = g_studio.numlocallights;

	mov	eax, DWORD PTR _g_studio+828556
	mov	DWORD PTR _k$[ebp], eax
$LN22@R_StudioEn:

; 1857 : 
; 1858 : 			if( k != -1 )

	cmp	DWORD PTR _k$[ebp], -1
	je	$LN25@R_StudioEn

; 1859 : 			{
; 1860 : 				g_studio.locallightcolor[k].r = LightToTexGamma( el->color.r );

	mov	eax, DWORD PTR _el$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	imul	edx, DWORD PTR _k$[ebp], 3
	mov	BYTE PTR _g_studio[edx+829088], al

; 1861 : 				g_studio.locallightcolor[k].g = LightToTexGamma( el->color.g );

	mov	eax, DWORD PTR _el$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	imul	edx, DWORD PTR _k$[ebp], 3
	mov	BYTE PTR _g_studio[edx+829089], al

; 1862 : 				g_studio.locallightcolor[k].b = LightToTexGamma( el->color.b );

	mov	eax, DWORD PTR _el$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	imul	edx, DWORD PTR _k$[ebp], 3
	mov	BYTE PTR _g_studio[edx+829090], al

; 1863 : 				g_studio.locallightR2[k] = r2;

	mov	eax, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR _r2$[ebp]
	movss	DWORD PTR _g_studio[eax*4+1883820], xmm0

; 1864 : 				g_studio.locallight[k] = el;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _el$[ebp]
	mov	DWORD PTR _g_studio[eax*4+829072], ecx

; 1865 : 				lstrength[k] = minstrength;

	mov	eax, DWORD PTR _k$[ebp]
	movss	xmm0, DWORD PTR _minstrength$[ebp]
	movss	DWORD PTR _lstrength$[ebp+eax*4], xmm0

; 1866 : 
; 1867 : 				if( k >= g_studio.numlocallights )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _g_studio+828556
	jl	SHORT $LN25@R_StudioEn

; 1868 : 					g_studio.numlocallights = k + 1;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _g_studio+828556, eax
$LN25@R_StudioEn:

; 1869 : 			}
; 1870 : 		}
; 1871 : 	}

	jmp	$LN5@R_StudioEn
$LN6@R_StudioEn:

; 1872 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioEntityLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioDynamicLight
_TEXT	SEGMENT
tv581 = -480						; size = 4
tv1386 = -476						; size = 8
tv1382 = -468						; size = 4
tv1419 = -464						; size = 8
tv1377 = -464						; size = 8
tv1415 = -456						; size = 4
tv1373 = -456						; size = 4
tv1367 = -452						; size = 8
tv1309 = -452						; size = 8
tv1279 = -452						; size = 8
tv1249 = -452						; size = 8
tv1219 = -452						; size = 8
tv855 = -452						; size = 4
tv588 = -452						; size = 4
tv851 = -448						; size = 4
tv587 = -448						; size = 4
tv303 = -448						; size = 4
tv289 = -448						; size = 4
tv275 = -448						; size = 4
tv1363 = -444						; size = 4
tv1306 = -444						; size = 4
tv1276 = -444						; size = 4
tv1246 = -444						; size = 4
tv1216 = -444						; size = 4
tv833 = -444						; size = 4
tv790 = -444						; size = 4
tv729 = -444						; size = 4
tv708 = -444						; size = 4
tv693 = -444						; size = 4
tv640 = -444						; size = 4
tv605 = -444						; size = 4
tv584 = -444						; size = 4
tv345 = -444						; size = 4
tv324 = -444						; size = 4
tv302 = -444						; size = 4
tv288 = -444						; size = 4
tv274 = -444						; size = 4
tv264 = -444						; size = 4
tv174 = -444						; size = 4
$T1 = -440						; size = 16
$T2 = -424						; size = 16
$T3 = -408						; size = 16
$T4 = -392						; size = 16
$T5 = -376						; size = 16
$T6 = -360						; size = 68
_ilength$7 = -228					; size = 4
_ilength$8 = -224					; size = 4
_grad$9 = -220						; size = 16
_gcolor$10 = -204					; size = 16
_trace$11 = -188					; size = 68
_psurf$12 = -120					; size = 4
_dl$ = -116						; size = 4
_lnum$ = -112						; size = 4
_light$ = -108						; size = 16
_total$ = -92						; size = 4
_radius$ = -88						; size = 4
_add$ = -84						; size = 4
_finalLight$ = -80					; size = 12
_dist$ = -68						; size = 12
_origin$ = -56						; size = 12
_vecEnd$ = -44						; size = 12
_vecSrc$ = -32						; size = 12
_lightDir$ = -20					; size = 12
_mv$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_plight$ = 12						; size = 4
_R_StudioDynamicLight PROC				; COMDAT

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1620 : 	movevars_t	*mv = &clgame.movevars;

	mov	DWORD PTR _mv$[ebp], OFFSET _clgame+1024

; 1621 : 	vec3_t		lightDir, vecSrc, vecEnd;
; 1622 : 	vec3_t		origin, dist, finalLight;
; 1623 : 	float		add, radius, total;
; 1624 : 	colorVec		light;
; 1625 : 	uint		lnum;
; 1626 : 	dlight_t		*dl;
; 1627 : 
; 1628 : 	if( !plight || !ent || !ent->model )

	cmp	DWORD PTR _plight$[ebp], 0
	je	SHORT $LN6@R_StudioDy
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN6@R_StudioDy
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN5@R_StudioDy
$LN6@R_StudioDy:

; 1629 : 		return;

	jmp	$LN1@R_StudioDy
$LN5@R_StudioDy:

; 1630 : 
; 1631 : 	if( !RI.drawWorld || r_fullbright->value || FBitSet( ent->curstate.effects, EF_FULLBRIGHT ))

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN8@R_StudioDy
	mov	eax, DWORD PTR _r_fullbright
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@R_StudioDy
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 134217728				; 08000000H
	je	$LN7@R_StudioDy
$LN8@R_StudioDy:

; 1632 : 	{
; 1633 : 		plight->shadelight = 0;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1634 : 		plight->ambientlight = 192;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax], 192			; 000000c0H

; 1635 : 
; 1636 : 		VectorSet( plight->plightvec, 0.0f, 0.0f, -1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+eax], xmm0

; 1637 : 		VectorSet( plight->color, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax+8], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx+8], xmm0

; 1638 : 		return;

	jmp	$LN1@R_StudioDy
$LN7@R_StudioDy:

; 1639 : 	}
; 1640 : 
; 1641 : 	// determine plane to get lightvalues from: ceil or floor
; 1642 : 	if( FBitSet( ent->curstate.effects, EF_INVLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 16					; 00000010H
	je	SHORT $LN9@R_StudioDy

; 1643 : 		VectorSet( lightDir, 0.0f, 0.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	jmp	SHORT $LN10@R_StudioDy
$LN9@R_StudioDy:

; 1644 : 	else VectorSet( lightDir, 0.0f, 0.0f, -1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
$LN10@R_StudioDy:

; 1645 : 
; 1646 : 	VectorCopy( ent->origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 1647 : 
; 1648 : 	VectorSet( vecSrc, origin[0], origin[1], origin[2] - lightDir[2] * 8.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	movss	DWORD PTR tv174[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0

; 1649 : 	light.r = light.g = light.b = light.a = 0;

	mov	DWORD PTR _light$[ebp+12], 0
	mov	eax, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR _light$[ebp+8], eax
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR _light$[ebp+4], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR _light$[ebp], edx

; 1650 : 
; 1651 : 	if(( mv->skycolor_r + mv->skycolor_g + mv->skycolor_b ) != 0 )

	mov	eax, DWORD PTR _mv$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	addss	xmm0, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _mv$[ebp]
	addss	xmm0, DWORD PTR [edx+116]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN16@R_StudioDy

; 1652 : 	{
; 1653 : 		msurface_t	*psurf = NULL;

	mov	DWORD PTR _psurf$12[ebp], 0

; 1654 : 		pmtrace_t		trace;
; 1655 : 
; 1656 : 		if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 1
	je	$LN12@R_StudioDy

; 1657 : 		{
; 1658 : 			vecEnd[0] = origin[0] - mv->skyvec_x * 65536.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm1

; 1659 : 			vecEnd[1] = origin[1] - mv->skyvec_y * 65536.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 1660 : 			vecEnd[2] = origin[2] - mv->skyvec_z * 65536.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 1661 : 		}

	jmp	$LN13@R_StudioDy
$LN12@R_StudioDy:

; 1662 : 		else
; 1663 : 		{
; 1664 : 			vecEnd[0] = origin[0] - mv->skyvec_x * 8192.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm1

; 1665 : 			vecEnd[1] = origin[1] - mv->skyvec_y * 8192.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 1666 : 			vecEnd[2] = origin[2] - mv->skyvec_z * 8192.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1
$LN13@R_StudioDy:

; 1667 : 		}
; 1668 : 
; 1669 : 		trace = CL_TraceLine( vecSrc, vecEnd, PM_WORLD_ONLY );

	push	8
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$11[ebp]
	rep movsd

; 1670 : 		if( trace.ent > 0 ) psurf = PM_TraceSurface( &clgame.pmove->physents[trace.ent], vecSrc, vecEnd );

	cmp	DWORD PTR _trace$11[ebp+48], 0
	jle	SHORT $LN14@R_StudioDy
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	imul	edx, DWORD PTR _trace$11[ebp+48], 224
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+592]
	push	ecx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psurf$12[ebp], eax
	jmp	SHORT $LN15@R_StudioDy
$LN14@R_StudioDy:

; 1671 :  		else psurf = PM_TraceSurface( clgame.pmove->physents, vecSrc, vecEnd );

	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	add	edx, 592				; 00000250H
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psurf$12[ebp], eax
$LN15@R_StudioDy:

; 1672 :  
; 1673 : 		if( FBitSet( ent->model->flags, STUDIO_FORCE_SKYLIGHT ) || ( psurf && FBitSet( psurf->flags, SURF_DRAWSKY )))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 1024				; 00000400H
	jne	SHORT $LN17@R_StudioDy
	cmp	DWORD PTR _psurf$12[ebp], 0
	je	$LN16@R_StudioDy
	mov	eax, DWORD PTR _psurf$12[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	$LN16@R_StudioDy
$LN17@R_StudioDy:

; 1674 : 		{
; 1675 : 			VectorSet( lightDir, mv->skyvec_x, mv->skyvec_y, mv->skyvec_z );

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+120]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+124]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+128]
	movss	DWORD PTR tv264[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv264[ebp]
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0

; 1676 : 
; 1677 : 			light.r = LightToTexGamma( bound( 0, mv->skycolor_r, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN38@R_StudioDy
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+108]
	jbe	SHORT $LN36@R_StudioDy
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	movss	DWORD PTR tv274[ebp], xmm0
	jmp	SHORT $LN37@R_StudioDy
$LN36@R_StudioDy:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv274[ebp], xmm0
$LN37@R_StudioDy:
	movss	xmm0, DWORD PTR tv274[ebp]
	movss	DWORD PTR tv275[ebp], xmm0
	jmp	SHORT $LN39@R_StudioDy
$LN38@R_StudioDy:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv275[ebp], xmm0
$LN39@R_StudioDy:
	cvttss2si eax, DWORD PTR tv275[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp], edx

; 1678 : 			light.g = LightToTexGamma( bound( 0, mv->skycolor_g, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+112]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN42@R_StudioDy
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+112]
	jbe	SHORT $LN40@R_StudioDy
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+112]
	movss	DWORD PTR tv288[ebp], xmm0
	jmp	SHORT $LN41@R_StudioDy
$LN40@R_StudioDy:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv288[ebp], xmm0
$LN41@R_StudioDy:
	movss	xmm0, DWORD PTR tv288[ebp]
	movss	DWORD PTR tv289[ebp], xmm0
	jmp	SHORT $LN43@R_StudioDy
$LN42@R_StudioDy:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv289[ebp], xmm0
$LN43@R_StudioDy:
	cvttss2si eax, DWORD PTR tv289[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp+4], edx

; 1679 : 			light.b = LightToTexGamma( bound( 0, mv->skycolor_b, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN46@R_StudioDy
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+116]
	jbe	SHORT $LN44@R_StudioDy
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR tv302[ebp], xmm0
	jmp	SHORT $LN45@R_StudioDy
$LN44@R_StudioDy:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv302[ebp], xmm0
$LN45@R_StudioDy:
	movss	xmm0, DWORD PTR tv302[ebp]
	movss	DWORD PTR tv303[ebp], xmm0
	jmp	SHORT $LN47@R_StudioDy
$LN46@R_StudioDy:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv303[ebp], xmm0
$LN47@R_StudioDy:
	cvttss2si eax, DWORD PTR tv303[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp+8], edx
$LN16@R_StudioDy:

; 1680 : 		}
; 1681 : 	}
; 1682 : 
; 1683 : 	if(( light.r + light.g + light.b ) < 16 ) // TESTTEST

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, DWORD PTR _light$[ebp+4]
	add	eax, DWORD PTR _light$[ebp+8]
	cmp	eax, 16					; 00000010H
	jae	$LN20@R_StudioDy

; 1684 : 	{
; 1685 : 		colorVec	gcolor;
; 1686 : 		float	grad[4];
; 1687 : 
; 1688 : 		VectorScale( lightDir, 2048.0f, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@45000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@45000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@45000000
	movss	DWORD PTR tv324[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv324[ebp]
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 1689 : 		VectorAdd( vecEnd, vecSrc, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	movss	DWORD PTR tv345[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv345[ebp]
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0

; 1690 : 
; 1691 : 		light = R_LightVec( vecSrc, vecEnd, g_studio.lightspot, g_studio.lightvec );

	push	OFFSET _g_studio+430172
	push	OFFSET _g_studio+430184
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _light$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _light$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _light$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _light$[ebp+12], edx

; 1692 : 
; 1693 : 		if( VectorIsNull( g_studio.lightvec ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+430172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@R_StudioDy
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_studio[eax+430172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@R_StudioDy
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[eax+430172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN19@R_StudioDy

; 1694 : 		{
; 1695 : 			vecSrc[0] -= 16.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 1696 : 			vecSrc[1] -= 16.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	subss	xmm0, DWORD PTR __real@41800000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0

; 1697 : 			vecEnd[0] -= 16.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 1698 : 			vecEnd[1] -= 16.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	subss	xmm0, DWORD PTR __real@41800000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 1699 : 
; 1700 : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 1701 : 			grad[0] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1216[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1216[ebp]
	mov	ecx, DWORD PTR tv1216[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1219[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1219[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _grad$9[ebp+eax], xmm0

; 1702 : 
; 1703 : 			vecSrc[0] += 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	addss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 1704 : 			vecEnd[0] += 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	addss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 1705 : 
; 1706 : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 1707 : 			grad[1] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1246[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1246[ebp]
	mov	ecx, DWORD PTR tv1246[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1249[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1249[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _grad$9[ebp+edx], xmm0

; 1708 : 
; 1709 : 			vecSrc[1] += 32.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	addss	xmm0, DWORD PTR __real@42000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0

; 1710 : 			vecEnd[1] += 32.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR __real@42000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 1711 : 
; 1712 : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 1713 : 			grad[2] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1276[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1276[ebp]
	mov	ecx, DWORD PTR tv1276[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1279[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1279[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _grad$9[ebp+edx], xmm0

; 1714 : 
; 1715 : 			vecSrc[0] -= 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 1716 : 			vecEnd[0] -= 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 1717 : 
; 1718 : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 1719 : 			grad[3] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1306[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1306[ebp]
	mov	ecx, DWORD PTR tv1306[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1309[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1309[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR _grad$9[ebp+eax], xmm0

; 1720 : 
; 1721 : 			lightDir[0] = grad[0] - grad[1] - grad[2] + grad[3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _grad$9[ebp+ecx]
	subss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	subss	xmm0, DWORD PTR _grad$9[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 1722 : 			lightDir[1] = grad[1] + grad[0] - grad[2] - grad[3];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _grad$9[ebp+eax]
	addss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	subss	xmm0, DWORD PTR _grad$9[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 3
	subss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0

; 1723 : 			VectorNormalize( lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$8[ebp]
	movss	xmm0, DWORD PTR _ilength$8[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@R_StudioDy
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$8[ebp]
	movss	DWORD PTR _ilength$8[ebp], xmm0
$LN21@R_StudioDy:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 1724 : 		}

	jmp	SHORT $LN20@R_StudioDy
$LN19@R_StudioDy:

; 1725 : 		else
; 1726 : 		{
; 1727 : 			VectorCopy( g_studio.lightvec, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _g_studio[ecx+430172]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _g_studio[edx+430172]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _g_studio[edx+430172]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
$LN20@R_StudioDy:

; 1728 : 		}
; 1729 : 	}
; 1730 : 
; 1731 : 	VectorSet( finalLight, light.r, light.g, light.b );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv1363[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1363[ebp]
	mov	eax, DWORD PTR tv1363[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1367[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1367[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv1373[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1373[ebp]
	mov	eax, DWORD PTR tv1373[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1377[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1377[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR tv1382[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1382[ebp]
	mov	edx, DWORD PTR tv1382[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1386[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1386[ebp]
	movss	DWORD PTR tv581[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv581[ebp]
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0

; 1732 : 	ent->cvFloorColor = light;

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3320				; 00000cf8H
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 1733 : 
; 1734 : 	total = Q_max( Q_max( light.r, light.g ), light.b );

	mov	eax, DWORD PTR _light$[ebp]
	cmp	eax, DWORD PTR _light$[ebp+4]
	jbe	SHORT $LN48@R_StudioDy
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv584[ebp], ecx
	jmp	SHORT $LN49@R_StudioDy
$LN48@R_StudioDy:
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv584[ebp], edx
$LN49@R_StudioDy:
	mov	eax, DWORD PTR tv584[ebp]
	cmp	eax, DWORD PTR _light$[ebp+8]
	jbe	SHORT $LN52@R_StudioDy
	mov	ecx, DWORD PTR _light$[ebp]
	cmp	ecx, DWORD PTR _light$[ebp+4]
	jbe	SHORT $LN50@R_StudioDy
	mov	edx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv587[ebp], edx
	jmp	SHORT $LN51@R_StudioDy
$LN50@R_StudioDy:
	mov	eax, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv587[ebp], eax
$LN51@R_StudioDy:
	mov	ecx, DWORD PTR tv587[ebp]
	mov	DWORD PTR tv588[ebp], ecx
	jmp	SHORT $LN53@R_StudioDy
$LN52@R_StudioDy:
	mov	edx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR tv588[ebp], edx
$LN53@R_StudioDy:
	mov	eax, DWORD PTR tv588[ebp]
	mov	DWORD PTR tv1415[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1415[ebp]
	mov	ecx, DWORD PTR tv1415[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1419[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1419[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 1735 : 	if( total == 0.0f ) total = 1.0f;

	movss	xmm0, DWORD PTR _total$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@R_StudioDy
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _total$[ebp], xmm0
$LN22@R_StudioDy:

; 1736 : 
; 1737 : 	// scale lightdir by light intentsity
; 1738 : 	VectorScale( lightDir, total, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _total$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _total$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _total$[ebp]
	movss	DWORD PTR tv605[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv605[ebp]
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 1739 : 
; 1740 : 	for( lnum = 0, dl = cl_dlights; lnum < MAX_DLIGHTS; lnum++, dl++ )

	mov	DWORD PTR _lnum$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@R_StudioDy
$LN2@R_StudioDy:
	mov	eax, DWORD PTR _lnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _lnum$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@R_StudioDy:
	cmp	DWORD PTR _lnum$[ebp], 32		; 00000020H
	jae	$LN3@R_StudioDy

; 1741 : 	{
; 1742 : 		if( dl->die < g_studio.time || !r_dynamic->value )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _g_studio
	comisd	xmm1, xmm0
	ja	SHORT $LN24@R_StudioDy
	mov	eax, DWORD PTR _r_dynamic
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_StudioDy
$LN24@R_StudioDy:

; 1743 : 			continue;

	jmp	SHORT $LN2@R_StudioDy
$LN23@R_StudioDy:

; 1744 : 
; 1745 : 		VectorSubtract( ent->origin, dl->origin, dist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv640[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv640[ebp]
	movss	DWORD PTR _dist$[ebp+eax], xmm0

; 1746 : 
; 1747 : 		radius = VectorLength( dist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dist$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm1, DWORD PTR _dist$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _dist$[ebp+eax]
	mulss	xmm1, DWORD PTR _dist$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _radius$[ebp]

; 1748 : 		add = (dl->radius - radius);

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _add$[ebp], xmm0

; 1749 : 
; 1750 : 		if( add > 0.0f )

	movss	xmm0, DWORD PTR _add$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN25@R_StudioDy

; 1751 : 		{
; 1752 : 			total += add;

	movss	xmm0, DWORD PTR _total$[ebp]
	addss	xmm0, DWORD PTR _add$[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 1753 : 
; 1754 : 			if( radius > 1.0f )

	movss	xmm0, DWORD PTR _radius$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN26@R_StudioDy

; 1755 : 				VectorScale( dist, ( add / radius ), dist );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dist$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv693[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv693[ebp]
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
	jmp	SHORT $LN27@R_StudioDy
$LN26@R_StudioDy:

; 1756 : 			else VectorScale( dist, add, dist );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dist$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dist$[ebp+eax]
	mulss	xmm0, DWORD PTR _add$[ebp]
	movss	DWORD PTR tv708[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv708[ebp]
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
$LN27@R_StudioDy:

; 1757 : 
; 1758 : 			VectorAdd( lightDir, dist, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, DWORD PTR _dist$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	addss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	addss	xmm0, DWORD PTR _dist$[ebp+ecx]
	movss	DWORD PTR tv729[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv729[ebp]
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0

; 1759 : 
; 1760 : 			finalLight[0] += LightToTexGamma( dl->color.r ) * ( add / 256.0f ) * 2.0f;

	mov	eax, 4
	imul	esi, eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	movzx	eax, al
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _finalLight$[ebp+edx], xmm0

; 1761 : 			finalLight[1] += LightToTexGamma( dl->color.g ) * ( add / 256.0f ) * 2.0f;

	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0

; 1762 : 			finalLight[2] += LightToTexGamma( dl->color.b ) * ( add / 256.0f ) * 2.0f;

	mov	esi, 4
	shl	esi, 1
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0
$LN25@R_StudioDy:

; 1763 : 		}
; 1764 : 	}

	jmp	$LN2@R_StudioDy
$LN3@R_StudioDy:

; 1765 : 
; 1766 : 	if( FBitSet( ent->model->flags, STUDIO_AMBIENT_LIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 256				; 00000100H
	je	SHORT $LN28@R_StudioDy

; 1767 : 		add = 0.6f;

	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR _add$[ebp], xmm0
	jmp	SHORT $LN29@R_StudioDy
$LN28@R_StudioDy:

; 1768 : 	else add = 0.9f;

	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR _add$[ebp], xmm0
$LN29@R_StudioDy:

; 1769 : 
; 1770 : 	VectorScale( lightDir, add, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _add$[ebp]
	movss	DWORD PTR tv790[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv790[ebp]
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 1771 : 
; 1772 : 	plight->shadelight = VectorLength( lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1773 : 	plight->ambientlight = total - plight->shadelight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR _total$[ebp]
	subss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx], ecx

; 1774 : 
; 1775 : 	total = Q_max( Q_max( finalLight[0], finalLight[1] ), finalLight[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	comiss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	jbe	SHORT $LN54@R_StudioDy
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	movss	DWORD PTR tv833[ebp], xmm0
	jmp	SHORT $LN55@R_StudioDy
$LN54@R_StudioDy:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	movss	DWORD PTR tv833[ebp], xmm0
$LN55@R_StudioDy:
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv833[ebp]
	comiss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	jbe	SHORT $LN58@R_StudioDy
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	comiss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	jbe	SHORT $LN56@R_StudioDy
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	movss	DWORD PTR tv851[ebp], xmm0
	jmp	SHORT $LN57@R_StudioDy
$LN56@R_StudioDy:
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	movss	DWORD PTR tv851[ebp], xmm0
$LN57@R_StudioDy:
	movss	xmm0, DWORD PTR tv851[ebp]
	movss	DWORD PTR tv855[ebp], xmm0
	jmp	SHORT $LN59@R_StudioDy
$LN58@R_StudioDy:
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	movss	DWORD PTR tv855[ebp], xmm0
$LN59@R_StudioDy:
	movss	xmm0, DWORD PTR tv855[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 1776 : 
; 1777 : 	if( total > 0.0f )

	movss	xmm0, DWORD PTR _total$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN30@R_StudioDy

; 1778 : 	{
; 1779 : 		plight->color[0] = finalLight[0] * ( 1.0f / total );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [ecx+eax+8], xmm0

; 1780 : 		plight->color[1] = finalLight[1] * ( 1.0f / total );

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 1781 : 		plight->color[2] = finalLight[2] * ( 1.0f / total );

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 1782 : 	}

	jmp	SHORT $LN31@R_StudioDy
$LN30@R_StudioDy:

; 1783 : 	else VectorSet( plight->color, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax+8], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx+8], xmm0
$LN31@R_StudioDy:

; 1784 : 
; 1785 : 	if( plight->ambientlight > 128 )

	mov	eax, DWORD PTR _plight$[ebp]
	cmp	DWORD PTR [eax], 128			; 00000080H
	jle	SHORT $LN32@R_StudioDy

; 1786 : 		plight->ambientlight = 128;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax], 128			; 00000080H
$LN32@R_StudioDy:

; 1787 : 
; 1788 : 	if( plight->ambientlight + plight->shadelight > 255 )

	mov	eax, DWORD PTR _plight$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _plight$[ebp]
	add	ecx, DWORD PTR [edx+4]
	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN33@R_StudioDy

; 1789 : 		plight->shadelight = 255 - plight->ambientlight;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN33@R_StudioDy:

; 1790 : 
; 1791 : 	VectorNormalize2( lightDir, plight->plightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$7[ebp]
	movss	xmm0, DWORD PTR _ilength$7[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN34@R_StudioDy
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$7[ebp]
	movss	DWORD PTR _ilength$7[ebp], xmm0
$LN34@R_StudioDy:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	DWORD PTR [ecx+eax], xmm0
$LN1@R_StudioDy:

; 1792 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioDynamicLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCheckBBox
_TEXT	SEGMENT
_R_StudioCheckBBox PROC					; COMDAT

; 1605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1606 : 	if( !RI.currententity || !RI.currentmodel )

	cmp	DWORD PTR _RI+28, 0
	je	SHORT $LN3@R_StudioCh
	cmp	DWORD PTR _RI+32, 0
	jne	SHORT $LN2@R_StudioCh
$LN3@R_StudioCh:

; 1607 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioCh
$LN2@R_StudioCh:

; 1608 : 
; 1609 : 	return R_StudioComputeBBox( NULL );

	push	0
	call	_R_StudioComputeBBox
	add	esp, 4
$LN1@R_StudioCh:

; 1610 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioCheckBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupModel
_TEXT	SEGMENT
_index$ = -4						; size = 4
_bodypart$ = 8						; size = 4
_ppbodypart$ = 12					; size = 4
_ppsubmodel$ = 16					; size = 4
_R_StudioSetupModel PROC				; COMDAT

; 1581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1582 : 	int	index;
; 1583 : 
; 1584 : 	if( bodypart > m_pStudioHeader->numbodyparts )

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _bodypart$[ebp]
	cmp	ecx, DWORD PTR [eax+204]
	jle	SHORT $LN2@R_StudioSe

; 1585 : 		bodypart = 0;

	mov	DWORD PTR _bodypart$[ebp], 0
$LN2@R_StudioSe:

; 1586 : 
; 1587 : 	m_pBodyPart = (mstudiobodyparts_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bodypartindex) + bodypart;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+208]
	imul	edx, DWORD PTR _bodypart$[ebp], 76
	add	ecx, edx
	mov	DWORD PTR _m_pBodyPart, ecx

; 1588 : 
; 1589 : 	index = RI.currententity->curstate.body / m_pBodyPart->base;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _m_pBodyPart
	mov	eax, DWORD PTR [eax+1032]
	cdq
	idiv	DWORD PTR [ecx+68]
	mov	DWORD PTR _index$[ebp], eax

; 1590 : 	index = index % m_pBodyPart->nummodels;

	mov	ecx, DWORD PTR _m_pBodyPart
	mov	eax, DWORD PTR _index$[ebp]
	cdq
	idiv	DWORD PTR [ecx+64]
	mov	DWORD PTR _index$[ebp], edx

; 1591 : 
; 1592 : 	m_pSubModel = (mstudiomodel_t *)((byte *)m_pStudioHeader + m_pBodyPart->modelindex) + index;

	mov	eax, DWORD PTR _m_pBodyPart
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+72]
	imul	edx, DWORD PTR _index$[ebp], 112
	add	ecx, edx
	mov	DWORD PTR _m_pSubModel, ecx

; 1593 : 
; 1594 : 	if( ppbodypart ) *ppbodypart = m_pBodyPart;

	cmp	DWORD PTR _ppbodypart$[ebp], 0
	je	SHORT $LN3@R_StudioSe
	mov	eax, DWORD PTR _ppbodypart$[ebp]
	mov	ecx, DWORD PTR _m_pBodyPart
	mov	DWORD PTR [eax], ecx
$LN3@R_StudioSe:

; 1595 : 	if( ppsubmodel ) *ppsubmodel = m_pSubModel;

	cmp	DWORD PTR _ppsubmodel$[ebp], 0
	je	SHORT $LN1@R_StudioSe
	mov	eax, DWORD PTR _ppsubmodel$[ebp]
	mov	ecx, DWORD PTR _m_pSubModel
	mov	DWORD PTR [eax], ecx
$LN1@R_StudioSe:

; 1596 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCalcAttachments
_TEXT	SEGMENT
tv178 = -132						; size = 4
tv150 = -132						; size = 4
tv70 = -132						; size = 4
_ilength$1 = -64					; size = 4
_i$ = -60						; size = 4
_localAng$ = -56					; size = 12
_localOrg$ = -44					; size = 12
_bonepos$ = -32						; size = 12
_forward$ = -20						; size = 12
_pAtt$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioCalcAttachments PROC				; COMDAT

; 1554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1555 : 	mstudioattachment_t	*pAtt;
; 1556 : 	vec3_t		forward, bonepos;
; 1557 : 	vec3_t		localOrg, localAng;
; 1558 : 	int		i;
; 1559 : 
; 1560 : 	// calculate attachment points
; 1561 : 	pAtt = (mstudioattachment_t *)((byte *)m_pStudioHeader + m_pStudioHeader->attachmentindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR _pAtt$[ebp], ecx

; 1562 : 
; 1563 : 	for( i = 0; i < Q_min( MAXSTUDIOATTACHMENTS, m_pStudioHeader->numattachments ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioCa
$LN2@R_StudioCa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioCa:
	mov	eax, DWORD PTR _m_pStudioHeader
	cmp	DWORD PTR [eax+212], 4
	jle	SHORT $LN6@R_StudioCa
	mov	DWORD PTR tv70[ebp], 4
	jmp	SHORT $LN7@R_StudioCa
$LN6@R_StudioCa:
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [ecx+212]
	mov	DWORD PTR tv70[ebp], edx
$LN7@R_StudioCa:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR tv70[ebp]
	jge	$LN3@R_StudioCa

; 1564 : 	{
; 1565 : 		Matrix3x4_VectorTransform( g_studio.lighttransform[pAtt[i].bone], pAtt[i].org, RI.currententity->attachment[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _RI+28
	lea	edx, DWORD PTR [ecx+eax+3248]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pAtt$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	push	edx
	imul	eax, DWORD PTR _i$[ebp], 88
	mov	ecx, DWORD PTR _pAtt$[ebp]
	imul	edx, DWORD PTR [ecx+eax+36], 48
	add	edx, OFFSET _g_studio+6224
	push	edx
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 1566 : 		VectorSubtract( RI.currententity->attachment[i], RI.currententity->origin, localOrg );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _RI+28
	lea	edx, DWORD PTR [ecx+eax+3248]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+3224]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _localOrg$[ebp+edx], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _RI+28
	lea	edx, DWORD PTR [ecx+eax+3248]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+3224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _localOrg$[ebp+edx], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _RI+28
	lea	edx, DWORD PTR [ecx+eax+3248]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _RI+28
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+3224]
	movss	DWORD PTR tv150[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv150[ebp]
	movss	DWORD PTR _localOrg$[ebp+edx], xmm0

; 1567 : 		Matrix3x4_OriginFromMatrix( g_studio.lighttransform[pAtt[i].bone], bonepos );

	lea	eax, DWORD PTR _bonepos$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 88
	mov	edx, DWORD PTR _pAtt$[ebp]
	imul	eax, DWORD PTR [edx+ecx+36], 48
	add	eax, OFFSET _g_studio+6224
	push	eax
	call	_Matrix3x4_OriginFromMatrix
	add	esp, 8

; 1568 : 		VectorSubtract( localOrg, bonepos, forward );	// make forward

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _localOrg$[ebp+ecx]
	subss	xmm0, DWORD PTR _bonepos$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _forward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _localOrg$[ebp+eax]
	subss	xmm0, DWORD PTR _bonepos$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _forward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _localOrg$[ebp+eax]
	subss	xmm0, DWORD PTR _bonepos$[ebp+ecx]
	movss	DWORD PTR tv178[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _forward$[ebp+edx], xmm0

; 1569 : 		VectorNormalizeFast( forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR _forward$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm1, DWORD PTR _forward$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _forward$[ebp+eax]
	mulss	xmm1, DWORD PTR _forward$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_rsqrt
	add	esp, 4
	fstp	DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _forward$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _forward$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _forward$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _forward$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _forward$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _forward$[ebp+ecx], xmm0

; 1570 : 		VectorAngles( forward, localAng );

	lea	eax, DWORD PTR _localAng$[ebp]
	push	eax
	lea	ecx, DWORD PTR _forward$[ebp]
	push	ecx
	call	_VectorAngles
	add	esp, 8

; 1571 : 	}

	jmp	$LN2@R_StudioCa
$LN3@R_StudioCa:

; 1572 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioCalcAttachments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupChrome
_TEXT	SEGMENT
tv302 = -124						; size = 4
tv224 = -124						; size = 4
tv81 = -124						; size = 4
_ilength$1 = -56					; size = 4
_ilength$2 = -52					; size = 4
_ilength$3 = -48					; size = 4
_tmp$4 = -44						; size = 12
_chromerightvec$5 = -32					; size = 12
_chromeupvec$6 = -20					; size = 12
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pchrome$ = 8						; size = 4
_bone$ = 12						; size = 4
_normal$ = 16						; size = 4
_R_StudioSetupChrome PROC				; COMDAT

; 1511 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1512 : 	float	n;
; 1513 : 
; 1514 : 	if( g_studio.chromeage[bone] != g_studio.framecount )

	mov	eax, DWORD PTR _bone$[ebp]
	mov	ecx, DWORD PTR _g_studio[eax*4+762508]
	cmp	ecx, DWORD PTR _g_studio+16
	je	$LN2@R_StudioSe

; 1515 : 	{
; 1516 : 		// calculate vectors from the viewer to the bone. This roughly adjusts for position
; 1517 : 		vec3_t	chromeupvec;	// g_studio.chrome t vector in world reference frame
; 1518 : 		vec3_t	chromerightvec;	// g_studio.chrome s vector in world reference frame
; 1519 : 		vec3_t	tmp;		// vector pointing at bone in world reference frame
; 1520 : 
; 1521 : 		VectorNegate( g_studio.chrome_origin, tmp );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+628352]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _tmp$4[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+628352]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _tmp$4[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[eax+628352]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv81[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv81[ebp]
	movss	DWORD PTR _tmp$4[ebp+ecx], xmm0

; 1522 : 		tmp[0] += g_studio.bonestransform[bone][0][3];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 48
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	lea	edx, DWORD PTR _g_studio[edx+eax+80]
	mov	eax, 4
	imul	eax, eax, 3
	movss	xmm0, DWORD PTR _tmp$4[ebp+ecx]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _tmp$4[ebp+edx], xmm0

; 1523 : 		tmp[1] += g_studio.bonestransform[bone][1][3];

	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _bone$[ebp], 48
	mov	edx, 16					; 00000010H
	shl	edx, 0
	lea	ecx, DWORD PTR _g_studio[ecx+edx+80]
	mov	edx, 4
	imul	edx, edx, 3
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _tmp$4[ebp+eax], xmm0

; 1524 : 		tmp[2] += g_studio.bonestransform[bone][2][3];

	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _bone$[ebp], 48
	mov	edx, 16					; 00000010H
	shl	edx, 1
	lea	ecx, DWORD PTR _g_studio[ecx+edx+80]
	mov	edx, 4
	imul	edx, edx, 3
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _tmp$4[ebp+eax], xmm0

; 1525 : 
; 1526 : 		VectorNormalize( tmp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm1, DWORD PTR _tmp$4[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@R_StudioSe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN3@R_StudioSe:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _tmp$4[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _tmp$4[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _tmp$4[ebp+ecx], xmm0

; 1527 : 		CrossProduct( tmp, RI.vright, chromeupvec );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _RI[ecx+236]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _tmp$4[ebp+edx]
	mulss	xmm1, DWORD PTR _RI[eax+236]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _chromeupvec$6[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _RI[edx+236]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[edx+236]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _chromeupvec$6[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+edx]
	mulss	xmm0, DWORD PTR _RI[eax+236]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[eax+236]
	subss	xmm0, xmm1
	movss	DWORD PTR tv224[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv224[ebp]
	movss	DWORD PTR _chromeupvec$6[ebp+ecx], xmm0

; 1528 : 		VectorNormalize( chromeupvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _chromeupvec$6[ebp+ecx]
	mulss	xmm0, DWORD PTR _chromeupvec$6[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _chromeupvec$6[ebp+ecx]
	mulss	xmm1, DWORD PTR _chromeupvec$6[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _chromeupvec$6[ebp+eax]
	mulss	xmm1, DWORD PTR _chromeupvec$6[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$2[ebp]
	movss	xmm0, DWORD PTR _ilength$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@R_StudioSe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$2[ebp]
	movss	DWORD PTR _ilength$2[ebp], xmm0
$LN4@R_StudioSe:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _chromeupvec$6[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _chromeupvec$6[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _chromeupvec$6[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _chromeupvec$6[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _chromeupvec$6[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _chromeupvec$6[ebp+ecx], xmm0

; 1529 : 		CrossProduct( tmp, chromeupvec, chromerightvec );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _chromeupvec$6[ebp+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _tmp$4[ebp+edx]
	mulss	xmm1, DWORD PTR _chromeupvec$6[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _chromerightvec$5[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+eax]
	mulss	xmm0, DWORD PTR _chromeupvec$6[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm1, DWORD PTR _chromeupvec$6[ebp+edx]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _chromerightvec$5[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _tmp$4[ebp+edx]
	mulss	xmm0, DWORD PTR _chromeupvec$6[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _tmp$4[ebp+ecx]
	mulss	xmm1, DWORD PTR _chromeupvec$6[ebp+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR tv302[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv302[ebp]
	movss	DWORD PTR _chromerightvec$5[ebp+ecx], xmm0

; 1530 : 		VectorNormalize( chromerightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _chromerightvec$5[ebp+ecx]
	mulss	xmm0, DWORD PTR _chromerightvec$5[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _chromerightvec$5[ebp+ecx]
	mulss	xmm1, DWORD PTR _chromerightvec$5[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _chromerightvec$5[ebp+eax]
	mulss	xmm1, DWORD PTR _chromerightvec$5[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_StudioSe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN5@R_StudioSe:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _chromerightvec$5[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _chromerightvec$5[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _chromerightvec$5[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _chromerightvec$5[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _chromerightvec$5[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _chromerightvec$5[ebp+ecx], xmm0

; 1531 : 
; 1532 : 		Matrix3x4_VectorIRotate( g_studio.bonestransform[bone], chromeupvec, g_studio.chromeup[bone] );

	imul	eax, DWORD PTR _bone$[ebp], 12
	add	eax, OFFSET _g_studio+760972
	push	eax
	lea	ecx, DWORD PTR _chromeupvec$6[ebp]
	push	ecx
	imul	edx, DWORD PTR _bone$[ebp], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorIRotate
	add	esp, 12					; 0000000cH

; 1533 : 		Matrix3x4_VectorIRotate( g_studio.bonestransform[bone], chromerightvec, g_studio.chromeright[bone] );

	imul	eax, DWORD PTR _bone$[ebp], 12
	add	eax, OFFSET _g_studio+759436
	push	eax
	lea	ecx, DWORD PTR _chromerightvec$5[ebp]
	push	ecx
	imul	edx, DWORD PTR _bone$[ebp], 48
	add	edx, OFFSET _g_studio+80
	push	edx
	call	_Matrix3x4_VectorIRotate
	add	esp, 12					; 0000000cH

; 1534 : 
; 1535 : 		g_studio.chromeage[bone] = g_studio.framecount;

	mov	eax, DWORD PTR _bone$[ebp]
	mov	ecx, DWORD PTR _g_studio+16
	mov	DWORD PTR _g_studio[eax*4+762508], ecx
$LN2@R_StudioSe:

; 1536 : 	}
; 1537 : 
; 1538 : 	// calc s coord
; 1539 : 	n = DotProduct( normal, g_studio.chromeright[bone] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR _g_studio[edx+eax+759436]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+759436]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+759436]
	addss	xmm0, xmm1
	movss	DWORD PTR _n$[ebp], xmm0

; 1540 : 	pchrome[0] = (n + 1.0f) * 32.0f;

	movss	xmm0, DWORD PTR _n$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchrome$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1541 : 
; 1542 : 	// calc t coord
; 1543 : 	n = DotProduct( normal, g_studio.chromeup[bone] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	mulss	xmm0, DWORD PTR _g_studio[edx+eax+760972]
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+760972]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _bone$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [esi+ecx]
	mulss	xmm1, DWORD PTR _g_studio[edx+eax+760972]
	addss	xmm0, xmm1
	movss	DWORD PTR _n$[ebp], xmm0

; 1544 : 	pchrome[1] = (n + 1.0f) * 32.0f;

	movss	xmm0, DWORD PTR _n$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@42000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pchrome$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 1545 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupChrome ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioGenerateNormals
_TEXT	SEGMENT
tv578 = -144						; size = 4
tv575 = -144						; size = 4
tv542 = -144						; size = 4
tv509 = -144						; size = 4
tv476 = -144						; size = 4
tv437 = -144						; size = 4
tv404 = -144						; size = 4
tv353 = -144						; size = 4
tv320 = -144						; size = 4
tv287 = -144						; size = 4
tv254 = -144						; size = 4
tv215 = -144						; size = 4
tv182 = -144						; size = 4
tv131 = -144						; size = 4
tv70 = -144						; size = 4
_ilength$1 = -76					; size = 4
_odd$2 = -72						; size = 4
_ptricmds$3 = -68					; size = 4
_j$ = -64						; size = 4
_i$ = -60						; size = 4
_pmesh$ = -56						; size = 4
_norm$ = -52						; size = 12
_e1$ = -40						; size = 12
_e0$ = -28						; size = 12
_v2$ = -16						; size = 4
_v1$ = -12						; size = 4
_v0$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_StudioGenerateNormals PROC				; COMDAT

; 1416 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1417 : 	int		v0, v1, v2;
; 1418 : 	vec3_t		e0, e1, norm;
; 1419 : 	mstudiomesh_t	*pmesh;
; 1420 : 	int		i, j;
; 1421 : 
; 1422 : 	Assert( m_pSubModel != NULL );

	cmp	DWORD PTR _m_pSubModel, 0
	je	SHORT $LN29@R_StudioGe
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN30@R_StudioGe
$LN29@R_StudioGe:
	mov	DWORD PTR tv70[ebp], 0
$LN30@R_StudioGe:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioGenerateNormals@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BE@LCGNDHPO@m_pSubModel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1423 : 
; 1424 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioGe
$LN2@R_StudioGe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioGe:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $LN3@R_StudioGe

; 1425 : 		VectorClear( g_studio.norms[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_studio[eax+ecx+233556], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _g_studio[ecx+eax+233556], xmm0
	jmp	SHORT $LN2@R_StudioGe
$LN3@R_StudioGe:

; 1426 : 
; 1427 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@R_StudioGe
$LN5@R_StudioGe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_StudioGe:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN6@R_StudioGe

; 1428 : 	{
; 1429 : 		short	*ptricmds;
; 1430 : 
; 1431 : 		pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + j;

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+76]
	imul	edx, DWORD PTR _j$[ebp], 20
	add	ecx, edx
	mov	DWORD PTR _pmesh$[ebp], ecx

; 1432 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$3[ebp], ecx
$LN8@R_StudioGe:

; 1433 : 
; 1434 : 		while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$3[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv131[ebp], edx
	mov	eax, DWORD PTR _ptricmds$3[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$3[ebp], eax
	cmp	DWORD PTR tv131[ebp], 0
	je	$LN9@R_StudioGe

; 1435 : 		{
; 1436 : 			if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	$LN19@R_StudioGe

; 1437 : 			{
; 1438 : 				i = -i;

	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax

; 1439 : 
; 1440 : 				if( i > 2 )

	cmp	DWORD PTR _i$[ebp], 2
	jle	$LN21@R_StudioGe

; 1441 : 				{
; 1442 : 					v0 = ptricmds[0]; ptricmds += 4;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v0$[ebp], eax
	mov	eax, DWORD PTR _ptricmds$3[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$3[ebp], eax

; 1443 : 					v1 = ptricmds[0]; ptricmds += 4;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v1$[ebp], eax
	mov	eax, DWORD PTR _ptricmds$3[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$3[ebp], eax

; 1444 : 
; 1445 : 					for( i -= 2; i > 0; i--, ptricmds += 4 )

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 2
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@R_StudioGe
$LN10@R_StudioGe:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$3[ebp], ecx
$LN12@R_StudioGe:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN11@R_StudioGe

; 1446 : 					{
; 1447 : 						v2 = ptricmds[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v2$[ebp], eax

; 1448 : 
; 1449 : 						VectorSubtract( g_studio.verts[v1], g_studio.verts[v0], e0 );

	imul	eax, DWORD PTR _v1$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _e0$[ebp+eax], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[eax+esi+36948]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _e0$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR _g_studio[edx+eax+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	movss	DWORD PTR tv182[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv182[ebp]
	movss	DWORD PTR _e0$[ebp+edx], xmm0

; 1450 : 						VectorSubtract( g_studio.verts[v2], g_studio.verts[v0], e1 );

	imul	eax, DWORD PTR _v2$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _e1$[ebp+eax], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[eax+esi+36948]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _e1$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR _g_studio[edx+eax+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	movss	DWORD PTR tv215[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv215[ebp]
	movss	DWORD PTR _e1$[ebp+edx], xmm0

; 1451 : 						CrossProduct( e1, e0, norm );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _e1$[ebp+eax]
	mulss	xmm0, DWORD PTR _e0$[ebp+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _e1$[ebp+edx]
	mulss	xmm1, DWORD PTR _e0$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _norm$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _e1$[ebp+eax]
	mulss	xmm0, DWORD PTR _e0$[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _e1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _e0$[ebp+edx]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _norm$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _e1$[ebp+edx]
	mulss	xmm0, DWORD PTR _e0$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _e1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _e0$[ebp+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR tv254[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv254[ebp]
	movss	DWORD PTR _norm$[ebp+ecx], xmm0

; 1452 : 
; 1453 : 						VectorAdd( g_studio.norms[v0], norm, g_studio.norms[v0] );

	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv287[ebp], xmm0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv287[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1454 : 						VectorAdd( g_studio.norms[v1], norm, g_studio.norms[v1] );

	imul	eax, DWORD PTR _v1$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv320[ebp], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv320[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1455 : 						VectorAdd( g_studio.norms[v2], norm, g_studio.norms[v2] );

	imul	eax, DWORD PTR _v2$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv353[ebp], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv353[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1456 : 
; 1457 : 						v1 = v2;

	mov	eax, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v1$[ebp], eax

; 1458 : 					}

	jmp	$LN10@R_StudioGe
$LN11@R_StudioGe:

; 1459 : 				}

	jmp	SHORT $LN22@R_StudioGe
$LN21@R_StudioGe:

; 1460 : 				else
; 1461 : 				{
; 1462 : 					ptricmds += i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _ptricmds$3[ebp], edx
$LN22@R_StudioGe:

; 1463 : 				}
; 1464 : 			}

	jmp	$LN24@R_StudioGe
$LN19@R_StudioGe:

; 1465 : 			else
; 1466 : 			{
; 1467 : 				if( i > 2 )

	cmp	DWORD PTR _i$[ebp], 2
	jle	$LN23@R_StudioGe

; 1468 : 				{
; 1469 : 					qboolean	odd = false;

	mov	DWORD PTR _odd$2[ebp], 0

; 1470 : 
; 1471 : 					v0 = ptricmds[0]; ptricmds += 4;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v0$[ebp], eax
	mov	eax, DWORD PTR _ptricmds$3[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$3[ebp], eax

; 1472 : 					v1 = ptricmds[0]; ptricmds += 4;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v1$[ebp], eax
	mov	eax, DWORD PTR _ptricmds$3[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$3[ebp], eax

; 1473 : 
; 1474 : 					for( i -= 2; i > 0; i--, ptricmds += 4 )

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 2
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN15@R_StudioGe
$LN13@R_StudioGe:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$3[ebp], ecx
$LN15@R_StudioGe:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN14@R_StudioGe

; 1475 : 					{
; 1476 : 						v2 = ptricmds[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$3[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	mov	DWORD PTR _v2$[ebp], eax

; 1477 : 
; 1478 : 						VectorSubtract( g_studio.verts[v1], g_studio.verts[v0], e0 );

	imul	eax, DWORD PTR _v1$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _e0$[ebp+eax], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[eax+esi+36948]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _e0$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR _g_studio[edx+eax+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	movss	DWORD PTR tv404[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv404[ebp]
	movss	DWORD PTR _e0$[ebp+edx], xmm0

; 1479 : 						VectorSubtract( g_studio.verts[v2], g_studio.verts[v0], e1 );

	imul	eax, DWORD PTR _v2$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _e1$[ebp+eax], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+36948]
	subss	xmm0, DWORD PTR _g_studio[eax+esi+36948]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _e1$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR _g_studio[edx+eax+36948]
	subss	xmm0, DWORD PTR _g_studio[ecx+esi+36948]
	movss	DWORD PTR tv437[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv437[ebp]
	movss	DWORD PTR _e1$[ebp+edx], xmm0

; 1480 : 						CrossProduct( e1, e0, norm );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _e1$[ebp+eax]
	mulss	xmm0, DWORD PTR _e0$[ebp+ecx]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR _e1$[ebp+edx]
	mulss	xmm1, DWORD PTR _e0$[ebp+eax]
	subss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _norm$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _e1$[ebp+eax]
	mulss	xmm0, DWORD PTR _e0$[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR _e1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _e0$[ebp+edx]
	subss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _norm$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _e1$[ebp+edx]
	mulss	xmm0, DWORD PTR _e0$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _e1$[ebp+ecx]
	mulss	xmm1, DWORD PTR _e0$[ebp+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR tv476[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv476[ebp]
	movss	DWORD PTR _norm$[ebp+ecx], xmm0

; 1481 : 
; 1482 : 						VectorAdd( g_studio.norms[v0], norm, g_studio.norms[v0] );

	imul	eax, DWORD PTR _v0$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v0$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv509[ebp], xmm0
	imul	ecx, DWORD PTR _v0$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv509[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1483 : 						VectorAdd( g_studio.norms[v1], norm, g_studio.norms[v1] );

	imul	eax, DWORD PTR _v1$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v1$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv542[ebp], xmm0
	imul	ecx, DWORD PTR _v1$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv542[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1484 : 						VectorAdd( g_studio.norms[v2], norm, g_studio.norms[v2] );

	imul	eax, DWORD PTR _v2$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[edx+eax+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+ecx]
	imul	edx, DWORD PTR _v2$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+233556], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+233556]
	addss	xmm0, DWORD PTR _norm$[ebp+eax]
	movss	DWORD PTR tv575[ebp], xmm0
	imul	ecx, DWORD PTR _v2$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv575[ebp]
	movss	DWORD PTR _g_studio[ecx+edx+233556], xmm0

; 1485 : 
; 1486 : 						if( odd ) v1 = v2;

	cmp	DWORD PTR _odd$2[ebp], 0
	je	SHORT $LN25@R_StudioGe
	mov	eax, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v1$[ebp], eax
	jmp	SHORT $LN26@R_StudioGe
$LN25@R_StudioGe:

; 1487 : 						else v0 = v2;

	mov	eax, DWORD PTR _v2$[ebp]
	mov	DWORD PTR _v0$[ebp], eax
$LN26@R_StudioGe:

; 1488 : 
; 1489 : 						odd = !odd;

	cmp	DWORD PTR _odd$2[ebp], 0
	jne	SHORT $LN31@R_StudioGe
	mov	DWORD PTR tv578[ebp], 1
	jmp	SHORT $LN32@R_StudioGe
$LN31@R_StudioGe:
	mov	DWORD PTR tv578[ebp], 0
$LN32@R_StudioGe:
	mov	eax, DWORD PTR tv578[ebp]
	mov	DWORD PTR _odd$2[ebp], eax

; 1490 : 					}

	jmp	$LN13@R_StudioGe
$LN14@R_StudioGe:

; 1491 : 				}

	jmp	SHORT $LN24@R_StudioGe
$LN23@R_StudioGe:

; 1492 : 				else
; 1493 : 				{
; 1494 : 					ptricmds += i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptricmds$3[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _ptricmds$3[ebp], edx
$LN24@R_StudioGe:

; 1495 : 				}
; 1496 : 			}
; 1497 : 		}

	jmp	$LN8@R_StudioGe
$LN9@R_StudioGe:

; 1498 : 	}

	jmp	$LN5@R_StudioGe
$LN6@R_StudioGe:

; 1499 : 
; 1500 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@R_StudioGe
$LN16@R_StudioGe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@R_StudioGe:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	$LN17@R_StudioGe

; 1501 : 		VectorNormalize( g_studio.norms[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	mulss	xmm0, DWORD PTR _g_studio[ecx+esi+233556]
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR _g_studio[edx+eax+233556]
	mulss	xmm1, DWORD PTR _g_studio[ecx+esi+233556]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR _g_studio[edx+eax+233556]
	mulss	xmm1, DWORD PTR _g_studio[ecx+esi+233556]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN27@R_StudioGe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN27@R_StudioGe:
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+edx+233556]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[edx+ecx+233556], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+233556]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[eax+edx+233556], xmm0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+233556]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 12
	movss	DWORD PTR _g_studio[eax+edx+233556], xmm0
	jmp	$LN16@R_StudioGe
$LN17@R_StudioGe:

; 1502 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioGenerateNormals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioBuildNormalTable
_TEXT	SEGMENT
tv241 = -92						; size = 8
tv235 = -92						; size = 8
tv229 = -92						; size = 8
tv94 = -88						; size = 4
tv70 = -88						; size = 4
_ptricmds$1 = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_pmesh$ = -8						; size = 4
_e$ = -4						; size = 4
_R_StudioBuildNormalTable PROC				; COMDAT

; 1365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1366 : 	cl_entity_t	*e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 1367 : 	mstudiomesh_t	*pmesh;
; 1368 : 	int		i, j;
; 1369 : 
; 1370 : 	Assert( m_pSubModel != NULL );

	cmp	DWORD PTR _m_pSubModel, 0
	je	SHORT $LN22@R_StudioBu
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN23@R_StudioBu
$LN22@R_StudioBu:
	mov	DWORD PTR tv70[ebp], 0
$LN23@R_StudioBu:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioBuildNormalTable@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BE@LCGNDHPO@m_pSubModel?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1371 : 
; 1372 : 	// reset chrome cache
; 1373 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioBu
$LN2@R_StudioBu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioBu:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN3@R_StudioBu

; 1374 : 		g_studio.chromeage[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _g_studio[eax*4+762508], 0
	jmp	SHORT $LN2@R_StudioBu
$LN3@R_StudioBu:

; 1375 : 
; 1376 : 	for( i = 0; i < m_pSubModel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_StudioBu
$LN5@R_StudioBu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_StudioBu:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $LN6@R_StudioBu

; 1377 : 		g_studio.normaltable[i] = -1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _g_studio[eax*4+763020], -1
	jmp	SHORT $LN5@R_StudioBu
$LN6@R_StudioBu:

; 1378 : 
; 1379 : 	for( j = 0; j < m_pSubModel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@R_StudioBu
$LN8@R_StudioBu:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@R_StudioBu:
	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$LN9@R_StudioBu

; 1380 : 	{
; 1381 : 		short	*ptricmds;
; 1382 : 
; 1383 : 		pmesh = (mstudiomesh_t *)((byte *)m_pStudioHeader + m_pSubModel->meshindex) + j;

	mov	eax, DWORD PTR _m_pSubModel
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+76]
	imul	edx, DWORD PTR _j$[ebp], 20
	add	ecx, edx
	mov	DWORD PTR _pmesh$[ebp], ecx

; 1384 : 		ptricmds = (short *)((byte *)m_pStudioHeader + pmesh->triindex);

	mov	eax, DWORD PTR _pmesh$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ptricmds$1[ebp], ecx
$LN11@R_StudioBu:

; 1385 : 
; 1386 : 		while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$1[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _ptricmds$1[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$1[ebp], eax
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN12@R_StudioBu

; 1387 : 		{
; 1388 : 			if( i < 0 ) i = -i;

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $LN16@R_StudioBu
	mov	eax, DWORD PTR _i$[ebp]
	neg	eax
	mov	DWORD PTR _i$[ebp], eax
$LN16@R_StudioBu:

; 1389 : 
; 1390 : 			for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $LN15@R_StudioBu
$LN13@R_StudioBu:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptricmds$1[ebp]
	add	ecx, 8
	mov	DWORD PTR _ptricmds$1[ebp], ecx
$LN15@R_StudioBu:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN14@R_StudioBu

; 1391 : 			{
; 1392 : 				if( g_studio.normaltable[ptricmds[0]] < 0 )

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptricmds$1[ebp]
	movsx	eax, WORD PTR [edx+ecx]
	cmp	DWORD PTR _g_studio[eax*4+763020], 0
	jge	SHORT $LN17@R_StudioBu

; 1393 : 					g_studio.normaltable[ptricmds[0]] = ptricmds[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ptricmds$1[ebp]
	movsx	edx, WORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _ptricmds$1[ebp]
	movsx	eax, WORD PTR [ecx+eax]
	mov	DWORD PTR _g_studio[edx*4+763020], eax
$LN17@R_StudioBu:

; 1394 : 			}

	jmp	SHORT $LN13@R_StudioBu
$LN14@R_StudioBu:

; 1395 : 		}

	jmp	$LN11@R_StudioBu
$LN12@R_StudioBu:

; 1396 : 	}

	jmp	$LN8@R_StudioBu
$LN9@R_StudioBu:

; 1397 : 
; 1398 : 	g_studio.chrome_origin[0] = cos( r_glowshellfreq.value * g_studio.time ) * 4000.0f;

	cvtss2sd xmm0, DWORD PTR _r_glowshellfreq+12
	mulsd	xmm0, QWORD PTR _g_studio
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv229[ebp]
	movsd	xmm0, QWORD PTR tv229[ebp]
	mulsd	xmm0, QWORD PTR __real@40af400000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _g_studio[ecx+628352], xmm0

; 1399 : 	g_studio.chrome_origin[1] = sin( r_glowshellfreq.value * g_studio.time ) * 4000.0f;

	cvtss2sd xmm0, DWORD PTR _r_glowshellfreq+12
	mulsd	xmm0, QWORD PTR _g_studio
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv235[ebp]
	movsd	xmm0, QWORD PTR tv235[ebp]
	mulsd	xmm0, QWORD PTR __real@40af400000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _g_studio[eax+628352], xmm0

; 1400 : 	g_studio.chrome_origin[2] = cos( r_glowshellfreq.value * g_studio.time * 0.33f ) * 4000.0f;

	cvtss2sd xmm0, DWORD PTR _r_glowshellfreq+12
	mulsd	xmm0, QWORD PTR _g_studio
	mulsd	xmm0, QWORD PTR __real@3fd51eb860000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv241[ebp]
	movsd	xmm0, QWORD PTR tv241[ebp]
	mulsd	xmm0, QWORD PTR __real@40af400000000000
	mov	eax, 4
	shl	eax, 1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _g_studio[eax+628352], xmm0

; 1401 : 
; 1402 : 	if( e->curstate.rendercolor.r || e->curstate.rendercolor.g || e->curstate.rendercolor.b )

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	test	ecx, ecx
	jne	SHORT $LN20@R_StudioBu
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+993]
	test	ecx, ecx
	jne	SHORT $LN20@R_StudioBu
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	test	ecx, ecx
	je	SHORT $LN18@R_StudioBu
$LN20@R_StudioBu:

; 1403 : 		TriColor4ub( e->curstate.rendercolor.r, e->curstate.rendercolor.g, e->curstate.rendercolor.b, 255 );

	push	255					; 000000ffH
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+993]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, BYTE PTR [ecx+992]
	push	edx
	call	_TriColor4ub
	add	esp, 16					; 00000010H
	jmp	SHORT $LN19@R_StudioBu
$LN18@R_StudioBu:

; 1404 : 	else TriColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	_TriColor4ub
	add	esp, 16					; 00000010H
$LN19@R_StudioBu:

; 1405 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioBuildNormalTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSaveBones
_TEXT	SEGMENT
_i$ = -8						; size = 4
_pbones$ = -4						; size = 4
_R_StudioSaveBones PROC					; COMDAT

; 1342 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1343 : 	mstudiobone_t	*pbones;
; 1344 : 	int		i;
; 1345 : 
; 1346 : 	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 1347 : 	g_studio.cached_numbones = m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	mov	DWORD PTR _g_studio+34896, ecx

; 1348 : 
; 1349 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioSa
$LN2@R_StudioSa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioSa:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN1@R_StudioSa

; 1350 : 	{
; 1351 : 		Matrix3x4_Copy( g_studio.cached_bonestransform[i], g_studio.bonestransform[i] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+18512
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1352 : 		Matrix3x4_Copy( g_studio.cached_lighttransform[i], g_studio.lighttransform[i] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+6224
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+24656
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1353 : 		Q_strncpy( g_studio.cached_bonenames[i], pbones[i].name, 32 );

	push	32					; 00000020H
	imul	eax, DWORD PTR _i$[ebp], 112
	add	eax, DWORD PTR _pbones$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	add	ecx, OFFSET _g_studio+30800
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1354 : 	}

	jmp	SHORT $LN2@R_StudioSa
$LN1@R_StudioSa:

; 1355 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSaveBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupBones
_TEXT	SEGMENT
_copy_bones$1 = -92					; size = 4
_s$2 = -88						; size = 4
_dadt$3 = -84						; size = 4
_s$4 = -80						; size = 4
_i$ = -76						; size = 4
_bonematrix$ = -72					; size = 48
_panim$ = -24						; size = 4
_pseqdesc$ = -20					; size = 4
_pbones$ = -16						; size = 4
_f$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_StudioSetupBones PROC				; COMDAT

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1186 : 	double		f;
; 1187 : 	mstudiobone_t	*pbones;
; 1188 : 	mstudioseqdesc_t	*pseqdesc;
; 1189 : 	mstudioanim_t	*panim;
; 1190 : 	matrix3x4		bonematrix;
; 1191 : 	static vec3_t	pos[MAXSTUDIOBONES];
; 1192 : 	static vec4_t	q[MAXSTUDIOBONES];
; 1193 : 	static vec3_t	pos2[MAXSTUDIOBONES];
; 1194 : 	static vec4_t	q2[MAXSTUDIOBONES];
; 1195 : 	static vec3_t	pos3[MAXSTUDIOBONES];
; 1196 : 	static vec4_t	q3[MAXSTUDIOBONES];
; 1197 : 	static vec3_t	pos4[MAXSTUDIOBONES];
; 1198 : 	static vec4_t	q4[MAXSTUDIOBONES];
; 1199 : 	int		i;
; 1200 : 
; 1201 : 	if( e->curstate.sequence >= m_pStudioHeader->numseq )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+956]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN8@R_StudioSe

; 1202 : 		e->curstate.sequence = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+956], 0
$LN8@R_StudioSe:

; 1203 : 
; 1204 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + e->curstate.sequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _e$[ebp]
	imul	eax, DWORD PTR [edx+956], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 1205 : 
; 1206 : 	f = R_StudioEstimateFrame( e, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_StudioEstimateFrame
	add	esp, 8
	fstp	QWORD PTR _f$[ebp]

; 1207 : 
; 1208 : 	panim = R_StudioGetAnim( m_pStudioHeader, RI.currentmodel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+32
	push	ecx
	mov	edx, DWORD PTR _m_pStudioHeader
	push	edx
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 1209 : 	R_StudioCalcRotations( e, pos, q, pseqdesc, panim, f );

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??R_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1210 : 
; 1211 : 	if( pseqdesc->numblends > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 1
	jle	$LN10@R_StudioSe

; 1212 : 	{
; 1213 : 		float	s;
; 1214 : 		float	dadt;
; 1215 : 
; 1216 : 		panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1217 : 		R_StudioCalcRotations( e, pos2, q2, pseqdesc, panim, f );

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos2@?1??R_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1218 : 
; 1219 : 		dadt = R_StudioEstimateInterpolant( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioEstimateInterpolant
	add	esp, 4
	fstp	DWORD PTR _dadt$3[ebp]

; 1220 : 		s = (e->curstate.blending[0] * dadt + e->latched.prevblending[0] * (1.0f - dadt)) / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1016]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _dadt$3[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+3216]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$3[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$4[ebp], xmm0

; 1221 : 
; 1222 : 		R_StudioSlerpBones( m_pStudioHeader->numbones, q, pos, q2, pos2, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 1223 : 
; 1224 : 		if( pseqdesc->numblends == 4 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 4
	jne	$LN10@R_StudioSe

; 1225 : 		{
; 1226 : 			panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1227 : 			R_StudioCalcRotations( e, pos3, q3, pseqdesc, panim, f );

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1228 : 
; 1229 : 			panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1230 : 			R_StudioCalcRotations( e, pos4, q4, pseqdesc, panim, f );

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos4@?1??R_StudioSetupBones@@9@9
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1231 : 
; 1232 : 			s = (e->curstate.blending[0] * dadt + e->latched.prevblending[0] * (1.0f - dadt)) / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+1016]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _dadt$3[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+3216]
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$3[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$4[ebp], xmm0

; 1233 : 			R_StudioSlerpBones( m_pStudioHeader->numbones, q3, pos3, q4, pos4, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 1234 : 
; 1235 : 			s = (e->curstate.blending[1] * dadt + e->latched.prevblending[1] * (1.0f - dadt)) / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1016]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _dadt$3[ebp]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+3216]
	cvtsi2ss xmm1, edx
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$3[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$4[ebp], xmm0

; 1236 : 			R_StudioSlerpBones( m_pStudioHeader->numbones, q, pos, q3, pos3, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$4[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H
$LN10@R_StudioSe:

; 1237 : 		}
; 1238 : 	}
; 1239 : 
; 1240 : 	if( g_studio.interpolate && e->latched.sequencetime && ( e->latched.sequencetime + 0.2f > g_studio.time ) && ( e->latched.prevsequence < m_pStudioHeader->numseq ))

	cmp	DWORD PTR _g_studio+20, 0
	je	$LN11@R_StudioSe
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+3172]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN11@R_StudioSe
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+3172]
	addss	xmm0, DWORD PTR __real@3e4ccccd
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _g_studio
	jbe	$LN11@R_StudioSe
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+3204]
	cmp	edx, DWORD PTR [ecx+164]
	jge	$LN11@R_StudioSe

; 1241 : 	{
; 1242 : 		// blend from last sequence
; 1243 : 		static vec3_t	pos1b[MAXSTUDIOBONES];
; 1244 : 		static vec4_t	q1b[MAXSTUDIOBONES];
; 1245 : 		float		s;
; 1246 : 
; 1247 : 		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + e->latched.prevsequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _e$[ebp]
	imul	eax, DWORD PTR [edx+3204], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 1248 : 		panim = R_StudioGetAnim( m_pStudioHeader, RI.currentmodel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+32
	push	ecx
	mov	edx, DWORD PTR _m_pStudioHeader
	push	edx
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 1249 : 
; 1250 : 		// clip prevframe
; 1251 : 		R_StudioCalcRotations( e, pos1b, q1b, pseqdesc, panim, e->latched.prevframe );

	mov	eax, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+3208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q1b@?4??R_StudioSetupBones@@9@9
	push	OFFSET ?pos1b@?4??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1252 : 
; 1253 : 		if( pseqdesc->numblends > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 1
	jle	$LN14@R_StudioSe

; 1254 : 		{
; 1255 : 			panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1256 : 			R_StudioCalcRotations( e, pos2, q2, pseqdesc, panim, e->latched.prevframe );

	mov	eax, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+3208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos2@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1257 : 
; 1258 : 			s = (e->latched.prevseqblending[0]) / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3176]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$2[ebp], xmm0

; 1259 : 			R_StudioSlerpBones( m_pStudioHeader->numbones, q1b, pos1b, q2, pos2, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos1b@?4??R_StudioSetupBones@@9@9
	push	OFFSET ?q1b@?4??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 1260 : 
; 1261 : 			if( pseqdesc->numblends == 4 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+120], 4
	jne	$LN14@R_StudioSe

; 1262 : 			{
; 1263 : 				panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1264 : 				R_StudioCalcRotations( e, pos3, q3, pseqdesc, panim, e->latched.prevframe );

	mov	eax, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+3208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1265 : 
; 1266 : 				panim += m_pStudioHeader->numbones;

	mov	eax, DWORD PTR _m_pStudioHeader
	imul	ecx, DWORD PTR [eax+140], 12
	add	ecx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panim$[ebp], ecx

; 1267 : 				R_StudioCalcRotations( e, pos4, q4, pseqdesc, panim, e->latched.prevframe );

	mov	eax, DWORD PTR _e$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+3208]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos4@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1268 : 
; 1269 : 				s = (e->latched.prevseqblending[0]) / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3176]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$2[ebp], xmm0

; 1270 : 				R_StudioSlerpBones( m_pStudioHeader->numbones, q3, pos3, q4, pos4, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q4@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 1271 : 
; 1272 : 				s = (e->latched.prevseqblending[1]) / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+3176]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _s$2[ebp], xmm0

; 1273 : 				R_StudioSlerpBones( m_pStudioHeader->numbones, q1b, pos1b, q3, pos3, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q3@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos1b@?4??R_StudioSetupBones@@9@9
	push	OFFSET ?q1b@?4??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H
$LN14@R_StudioSe:

; 1274 : 			}
; 1275 : 		}
; 1276 : 
; 1277 : 		s = 1.0f - ( g_studio.time - e->latched.sequencetime ) / 0.2f;

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3172]
	movsd	xmm1, QWORD PTR _g_studio
	subsd	xmm1, xmm0
	divsd	xmm1, QWORD PTR __real@3fc99999a0000000
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$2[ebp], xmm0

; 1278 : 		R_StudioSlerpBones( m_pStudioHeader->numbones, q, pos, q1b, pos1b, s );

	push	ecx
	movss	xmm0, DWORD PTR _s$2[ebp]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ?pos1b@?4??R_StudioSetupBones@@9@9
	push	OFFSET ?q1b@?4??R_StudioSetupBones@@9@9
	push	OFFSET ?pos@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?q@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	_R_StudioSlerpBones
	add	esp, 24					; 00000018H

; 1279 : 	}

	jmp	SHORT $LN12@R_StudioSe
$LN11@R_StudioSe:

; 1280 : 	else
; 1281 : 	{
; 1282 : 		// store prevframe otherwise
; 1283 : 		e->latched.prevframe = f;

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	movss	DWORD PTR [eax+3208], xmm0
$LN12@R_StudioSe:

; 1284 : 	}
; 1285 : 
; 1286 : 	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 1287 : 
; 1288 : 	// calc gait animation
; 1289 : 	if( m_pPlayerInfo && m_pPlayerInfo->gaitsequence != 0 )

	cmp	DWORD PTR _m_pPlayerInfo, 0
	je	$LN3@R_StudioSe
	mov	eax, DWORD PTR _m_pPlayerInfo
	cmp	DWORD PTR [eax+380], 0
	je	$LN3@R_StudioSe

; 1290 : 	{
; 1291 : 		qboolean	copy_bones = true;

	mov	DWORD PTR _copy_bones$1[ebp], 1

; 1292 : 
; 1293 : 		if( m_pPlayerInfo->gaitsequence >= m_pStudioHeader->numseq ) 

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+380]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN16@R_StudioSe

; 1294 : 			m_pPlayerInfo->gaitsequence = 0;

	mov	eax, DWORD PTR _m_pPlayerInfo
	mov	DWORD PTR [eax+380], 0
$LN16@R_StudioSe:

; 1295 : 
; 1296 : 		pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + m_pPlayerInfo->gaitsequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _m_pPlayerInfo
	imul	eax, DWORD PTR [edx+380], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 1297 : 
; 1298 : 		panim = R_StudioGetAnim( m_pStudioHeader, RI.currentmodel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+32
	push	ecx
	mov	edx, DWORD PTR _m_pStudioHeader
	push	edx
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 1299 : 		R_StudioCalcRotations( e, pos2, q2, pseqdesc, panim, m_pPlayerInfo->gaitframe );

	mov	eax, DWORD PTR _m_pPlayerInfo
	push	ecx
	movss	xmm0, DWORD PTR [eax+384]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _panim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	push	edx
	push	OFFSET ?q2@?1??R_StudioSetupBones@@9@9
	push	OFFSET ?pos2@?1??R_StudioSetupBones@@9@9
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1300 : 
; 1301 : 		for( i = 0; i < m_pStudioHeader->numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioSe
$LN2@R_StudioSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioSe:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN3@R_StudioSe

; 1302 : 		{
; 1303 : 			if( !Q_strcmp( pbones[i].name, "Bip01 Spine" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0M@ECGMMMKA@Bip01?5Spine@
	imul	eax, DWORD PTR _i$[ebp], 112
	add	eax, DWORD PTR _pbones$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@R_StudioSe

; 1304 : 				copy_bones = false;

	mov	DWORD PTR _copy_bones$1[ebp], 0
	jmp	SHORT $LN19@R_StudioSe
$LN17@R_StudioSe:

; 1305 : 			else if( !Q_strcmp( pbones[pbones[i].parent].name, "Bip01 Pelvis" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@OECCGFMA@Bip01?5Pelvis@
	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	imul	edx, DWORD PTR [ecx+eax+32], 112
	add	edx, DWORD PTR _pbones$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@R_StudioSe

; 1306 : 				copy_bones = true;

	mov	DWORD PTR _copy_bones$1[ebp], 1
$LN19@R_StudioSe:

; 1307 : 
; 1308 : 			if( !copy_bones ) continue;

	cmp	DWORD PTR _copy_bones$1[ebp], 0
	jne	SHORT $LN20@R_StudioSe
	jmp	SHORT $LN2@R_StudioSe
$LN20@R_StudioSe:

; 1309 : 
; 1310 : 			VectorCopy( pos2[i], pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	imul	esi, esi, 0
	mov	edx, DWORD PTR ?pos2@?1??R_StudioSetupBones@@9@9[eax+edx]
	mov	DWORD PTR ?pos@?1??R_StudioSetupBones@@9@9[ecx+esi], edx
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR ?pos2@?1??R_StudioSetupBones@@9@9[eax+ecx]
	mov	DWORD PTR ?pos@?1??R_StudioSetupBones@@9@9[edx+esi], eax
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR ?pos2@?1??R_StudioSetupBones@@9@9[ecx+edx]
	mov	DWORD PTR ?pos@?1??R_StudioSetupBones@@9@9[eax+esi], ecx

; 1311 : 			Vector4Copy( q2[i], q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	esi, 4
	imul	esi, esi, 0
	mov	edx, DWORD PTR ?q2@?1??R_StudioSetupBones@@9@9[eax+edx]
	mov	DWORD PTR ?q@?1??R_StudioSetupBones@@9@9[ecx+esi], edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR ?q2@?1??R_StudioSetupBones@@9@9[eax+ecx]
	mov	DWORD PTR ?q@?1??R_StudioSetupBones@@9@9[edx+esi], eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR ?q2@?1??R_StudioSetupBones@@9@9[ecx+edx]
	mov	DWORD PTR ?q@?1??R_StudioSetupBones@@9@9[eax+esi], ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, 4
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	esi, 4
	imul	esi, esi, 3
	mov	ecx, DWORD PTR ?q2@?1??R_StudioSetupBones@@9@9[edx+ecx]
	mov	DWORD PTR ?q@?1??R_StudioSetupBones@@9@9[eax+esi], ecx

; 1312 : 		}

	jmp	$LN2@R_StudioSe
$LN3@R_StudioSe:

; 1313 : 	}
; 1314 : 
; 1315 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_StudioSe
$LN5@R_StudioSe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_StudioSe:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN6@R_StudioSe

; 1316 : 	{
; 1317 : 		Matrix3x4_FromOriginQuat( bonematrix, q[i], pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET ?pos@?1??R_StudioSetupBones@@9@9
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET ?q@?1??R_StudioSetupBones@@9@9
	push	ecx
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	_Matrix3x4_FromOriginQuat
	add	esp, 12					; 0000000cH

; 1318 : 
; 1319 : 		if( pbones[i].parent == -1 ) 

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [ecx+eax+32], -1
	jne	SHORT $LN21@R_StudioSe

; 1320 : 		{
; 1321 : 			Matrix3x4_ConcatTransforms( g_studio.bonestransform[i], g_studio.rotationmatrix, bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	push	OFFSET _g_studio+32
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1322 : 			Matrix3x4_Copy( g_studio.lighttransform[i], g_studio.bonestransform[i] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1323 : 
; 1324 : 			// apply client-side effects to the transformation matrix
; 1325 : 			R_StudioFxTransform( e, g_studio.bonestransform[i] );

	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_StudioFxTransform
	add	esp, 8

; 1326 : 		} 

	jmp	SHORT $LN22@R_StudioSe
$LN21@R_StudioSe:

; 1327 : 		else
; 1328 : 		{
; 1329 : 			Matrix3x4_ConcatTransforms( g_studio.bonestransform[i], g_studio.bonestransform[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1330 : 			Matrix3x4_ConcatTransforms( g_studio.lighttransform[i], g_studio.lighttransform[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+6224
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
$LN22@R_StudioSe:

; 1331 : 		}
; 1332 : 	}

	jmp	$LN5@R_StudioSe
$LN6@R_StudioSe:

; 1333 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioMergeBones
_TEXT	SEGMENT
_f$ = -80						; size = 8
_bonematrix$ = -72					; size = 48
_panim$ = -24						; size = 4
_pseqdesc$ = -20					; size = 4
_pbones$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_m_pSubModel$ = 12					; size = 4
_R_StudioMergeBones PROC				; COMDAT

; 1125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1126 : 	int		i, j;
; 1127 : 	mstudiobone_t	*pbones;
; 1128 : 	mstudioseqdesc_t	*pseqdesc;
; 1129 : 	mstudioanim_t	*panim;
; 1130 : 	matrix3x4		bonematrix;
; 1131 : 	static vec4_t	q[MAXSTUDIOBONES];
; 1132 : 	static float	pos[MAXSTUDIOBONES][3];
; 1133 : 	double		f;
; 1134 : 
; 1135 : 	if( e->curstate.sequence >=  m_pStudioHeader->numseq )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+956]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN8@R_StudioMe

; 1136 : 		e->curstate.sequence = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+956], 0
$LN8@R_StudioMe:

; 1137 : 
; 1138 : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + e->curstate.sequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _e$[ebp]
	imul	eax, DWORD PTR [edx+956], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 1139 : 
; 1140 : 	f = R_StudioEstimateFrame( e, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_StudioEstimateFrame
	add	esp, 8
	fstp	QWORD PTR _f$[ebp]

; 1141 : 
; 1142 : 	panim = R_StudioGetAnim( m_pStudioHeader, m_pSubModel, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m_pStudioHeader
	push	edx
	call	_R_StudioGetAnim
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], eax

; 1143 : 	R_StudioCalcRotations( e, pos, q, pseqdesc, panim, f );

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	push	ecx
	push	OFFSET ?q@?1??R_StudioMergeBones@@9@9
	push	OFFSET ?pos@?1??R_StudioMergeBones@@9@9
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioCalcRotations
	add	esp, 24					; 00000018H

; 1144 : 	pbones = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbones$[ebp], ecx

; 1145 : 
; 1146 : 	for( i = 0; i < m_pStudioHeader->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioMe
$LN2@R_StudioMe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioMe:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN3@R_StudioMe

; 1147 : 	{
; 1148 : 		for( j = 0; j < g_studio.cached_numbones; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@R_StudioMe
$LN5@R_StudioMe:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_StudioMe:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _g_studio+34896
	jge	SHORT $LN6@R_StudioMe

; 1149 : 		{
; 1150 : 			if( !Q_stricmp( pbones[i].name, g_studio.cached_bonenames[j] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 5
	add	eax, OFFSET _g_studio+30800
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	add	ecx, DWORD PTR _pbones$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@R_StudioMe

; 1151 : 			{
; 1152 : 				Matrix3x4_Copy( g_studio.bonestransform[i], g_studio.cached_bonestransform[j] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _j$[ebp], 48
	add	eax, OFFSET _g_studio+18512
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1153 : 				Matrix3x4_Copy( g_studio.lighttransform[i], g_studio.cached_lighttransform[j] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _j$[ebp], 48
	add	eax, OFFSET _g_studio+24656
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1154 : 				break;

	jmp	SHORT $LN6@R_StudioMe
$LN9@R_StudioMe:

; 1155 : 			}
; 1156 : 		}

	jmp	SHORT $LN5@R_StudioMe
$LN6@R_StudioMe:

; 1157 : 
; 1158 : 		if( j >= g_studio.cached_numbones )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _g_studio+34896
	jl	$LN12@R_StudioMe

; 1159 : 		{
; 1160 : 			Matrix3x4_FromOriginQuat( bonematrix, q[i], pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, OFFSET ?pos@?1??R_StudioMergeBones@@9@9
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET ?q@?1??R_StudioMergeBones@@9@9
	push	ecx
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	_Matrix3x4_FromOriginQuat
	add	esp, 12					; 0000000cH

; 1161 : 			if( pbones[i].parent == -1 ) 

	imul	eax, DWORD PTR _i$[ebp], 112
	mov	ecx, DWORD PTR _pbones$[ebp]
	cmp	DWORD PTR [ecx+eax+32], -1
	jne	SHORT $LN11@R_StudioMe

; 1162 : 			{
; 1163 : 				Matrix3x4_ConcatTransforms( g_studio.bonestransform[i], g_studio.rotationmatrix, bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	push	OFFSET _g_studio+32
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1164 : 				Matrix3x4_Copy( g_studio.lighttransform[i], g_studio.bonestransform[i] );

	push	48					; 00000030H
	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1165 : 
; 1166 : 				// apply client-side effects to the transformation matrix
; 1167 : 				R_StudioFxTransform( e, g_studio.bonestransform[i] );

	imul	eax, DWORD PTR _i$[ebp], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_StudioFxTransform
	add	esp, 8

; 1168 : 			} 

	jmp	SHORT $LN12@R_StudioMe
$LN11@R_StudioMe:

; 1169 : 			else 
; 1170 : 			{
; 1171 : 				Matrix3x4_ConcatTransforms( g_studio.bonestransform[i], g_studio.bonestransform[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+80
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+80
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH

; 1172 : 				Matrix3x4_ConcatTransforms( g_studio.lighttransform[i], g_studio.lighttransform[pbones[i].parent], bonematrix );

	lea	eax, DWORD PTR _bonematrix$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 112
	mov	edx, DWORD PTR _pbones$[ebp]
	imul	eax, DWORD PTR [edx+ecx+32], 48
	add	eax, OFFSET _g_studio+6224
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 48
	add	ecx, OFFSET _g_studio+6224
	push	ecx
	call	_Matrix3x4_ConcatTransforms
	add	esp, 12					; 0000000cH
$LN12@R_StudioMe:

; 1173 : 			}
; 1174 : 		}
; 1175 : 	}

	jmp	$LN2@R_StudioMe
$LN3@R_StudioMe:

; 1176 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioMergeBones ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCalcRotations
_TEXT	SEGMENT
_pbone$ = -56						; size = 4
_dadt$ = -52						; size = 4
_s$ = -48						; size = 4
_adj$ = -44						; size = 32
_frame$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_pos$ = 12						; size = 4
_q$ = 16						; size = 4
_pseqdesc$ = 20						; size = 4
_panim$ = 24						; size = 4
_f$ = 28						; size = 4
_R_StudioCalcRotations PROC				; COMDAT

; 1078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1079 : 	int		i, frame;
; 1080 : 	float		adj[MAXSTUDIOCONTROLLERS];
; 1081 : 	float		s, dadt;
; 1082 : 	mstudiobone_t	*pbone;
; 1083 : 
; 1084 : 	// bah, fix this bug with changing sequences too fast
; 1085 : 	if( f > pseqdesc->numframes - 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	movss	xmm1, DWORD PTR _f$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@R_StudioCa

; 1086 : 	{
; 1087 : 		f = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _f$[ebp], xmm0

; 1088 : 	}

	jmp	SHORT $LN7@R_StudioCa
$LN5@R_StudioCa:

; 1089 : 	else if( f < -0.01f )

	movss	xmm0, DWORD PTR __real@bc23d70a
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN7@R_StudioCa

; 1090 : 	{
; 1091 : 		// BUG ( somewhere else ) but this code should validate this data.
; 1092 : 		// This could cause a crash if the frame # is negative, so we'll go ahead
; 1093 : 		// and clamp it here
; 1094 : 		f = -0.01f;

	movss	xmm0, DWORD PTR __real@bc23d70a
	movss	DWORD PTR _f$[ebp], xmm0
$LN7@R_StudioCa:

; 1095 : 	}
; 1096 : 
; 1097 : 	frame = (int)f;

	cvttss2si eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR _frame$[ebp], eax

; 1098 : 
; 1099 : 	dadt = R_StudioEstimateInterpolant( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioEstimateInterpolant
	add	esp, 4
	fstp	DWORD PTR _dadt$[ebp]

; 1100 : 	s = (f - frame);

	cvtsi2ss xmm0, DWORD PTR _frame$[ebp]
	movss	xmm1, DWORD PTR _f$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _s$[ebp], xmm1

; 1101 : 
; 1102 : 	// add in programtic controllers
; 1103 : 	pbone = (mstudiobone_t *)((byte *)m_pStudioHeader + m_pStudioHeader->boneindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbone$[ebp], ecx

; 1104 : 
; 1105 : 	R_StudioCalcBoneAdj( dadt, adj, e->curstate.controller, e->latched.prevcontroller, e->mouth.mouthopen );

	mov	eax, DWORD PTR _e$[ebp]
	movzx	ecx, BYTE PTR [eax+3160]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	add	edx, 3212				; 00000c8cH
	push	edx
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1012				; 000003f4H
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _dadt$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_StudioCalcBoneAdj
	add	esp, 20					; 00000014H

; 1106 : 
; 1107 : 	for( i = 0; i < m_pStudioHeader->numbones; i++, pbone++, panim++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioCa
$LN2@R_StudioCa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pbone$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR _pbone$[ebp], ecx
	mov	edx, DWORD PTR _panim$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], edx
$LN4@R_StudioCa:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN3@R_StudioCa

; 1108 : 	{
; 1109 : 		R_StudioCalcBoneQuaternion( frame, s, pbone, panim, adj, q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbone$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_R_StudioCalcBoneQuaternion
	add	esp, 24					; 00000018H

; 1110 : 		R_StudioCalcBonePosition( frame, s, pbone, panim, adj, pos[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbone$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	call	_R_StudioCalcBonePosition
	add	esp, 24					; 00000018H

; 1111 : 	}

	jmp	$LN2@R_StudioCa
$LN3@R_StudioCa:

; 1112 : 
; 1113 : 	if( pseqdesc->motiontype & STUDIO_X ) pos[pseqdesc->motionbone][0] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 1
	je	SHORT $LN8@R_StudioCa
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
$LN8@R_StudioCa:

; 1114 : 	if( pseqdesc->motiontype & STUDIO_Y ) pos[pseqdesc->motionbone][1] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 2
	je	SHORT $LN9@R_StudioCa
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
$LN9@R_StudioCa:

; 1115 : 	if( pseqdesc->motiontype & STUDIO_Z ) pos[pseqdesc->motionbone][2] = 0.0f;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	and	ecx, 4
	je	SHORT $LN10@R_StudioCa
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	imul	ecx, DWORD PTR [eax+72], 12
	add	ecx, DWORD PTR _pos$[ebp]
	mov	edx, 4
	shl	edx, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx], xmm0
$LN10@R_StudioCa:

; 1116 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioCalcRotations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCalcBoneAdj
_TEXT	SEGMENT
tv203 = -96						; size = 4
tv79 = -96						; size = 4
tv219 = -92						; size = 4
tv202 = -92						; size = 4
tv78 = -92						; size = 4
_b$1 = -24						; size = 4
_a$2 = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_value$ = -8						; size = 4
_pbonecontroller$ = -4					; size = 4
_dadt$ = 8						; size = 4
_adj$ = 12						; size = 4
_pcontroller1$ = 16					; size = 4
_pcontroller2$ = 20					; size = 4
_mouthopen$ = 24					; size = 1
_R_StudioCalcBoneAdj PROC				; COMDAT

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 823  : 	mstudiobonecontroller_t	*pbonecontroller;
; 824  : 	float			value = 0.0f;	

	xorps	xmm0, xmm0
	movss	DWORD PTR _value$[ebp], xmm0

; 825  : 	int			i, j;
; 826  : 
; 827  : 	pbonecontroller = (mstudiobonecontroller_t *)((byte *)m_pStudioHeader + m_pStudioHeader->bonecontrollerindex);

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR _pbonecontroller$[ebp], ecx

; 828  : 
; 829  : 	for( j = 0; j < m_pStudioHeader->numbonecontrollers; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@R_StudioCa
$LN2@R_StudioCa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@R_StudioCa:
	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	$LN3@R_StudioCa

; 830  : 	{
; 831  : 		i = pbonecontroller[j].index;

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _i$[ebp], edx

; 832  : 
; 833  : 		if( i == STUDIO_MOUTH )

	cmp	DWORD PTR _i$[ebp], 4
	jne	$LN7@R_StudioCa

; 834  : 		{
; 835  : 			// mouth hardcoded at controller 4
; 836  : 			value = (float)mouthopen / 64.0f;

	movzx	eax, BYTE PTR _mouthopen$[ebp]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _value$[ebp], xmm0

; 837  : 			value = bound( 0.0f, value, 1.0f );				

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN23@R_StudioCa
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _value$[ebp]
	jbe	SHORT $LN21@R_StudioCa
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR tv78[ebp], xmm0
	jmp	SHORT $LN22@R_StudioCa
$LN21@R_StudioCa:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv78[ebp], xmm0
$LN22@R_StudioCa:
	movss	xmm0, DWORD PTR tv78[ebp]
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN24@R_StudioCa
$LN23@R_StudioCa:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
$LN24@R_StudioCa:
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 838  : 			value = (1.0f - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _value$[ebp]
	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+8]
	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	movss	xmm1, DWORD PTR _value$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _value$[ebp], xmm0

; 839  : 		}

	jmp	$LN11@R_StudioCa
$LN7@R_StudioCa:

; 840  : 		else if( i < 4 )

	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN11@R_StudioCa

; 841  : 		{
; 842  : 			// check for 360% wrapping
; 843  : 			if( FBitSet( pbonecontroller[j].type, STUDIO_RLOOP ))

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 32768				; 00008000H
	je	$LN10@R_StudioCa

; 844  : 			{
; 845  : 				if( abs( pcontroller1[i] - pcontroller2[i] ) > 128 )

	mov	eax, DWORD PTR _pcontroller1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pcontroller2$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	push	ecx
	call	_abs
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jle	$LN12@R_StudioCa

; 846  : 				{
; 847  : 					int a = (pcontroller1[i] + 128) % 256;

	mov	eax, DWORD PTR _pcontroller1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, 128				; 00000080H
	and	ecx, -2147483393			; 800000ffH
	jns	SHORT $LN31@R_StudioCa
	dec	ecx
	or	ecx, -256				; ffffff00H
	inc	ecx
$LN31@R_StudioCa:
	mov	DWORD PTR _a$2[ebp], ecx

; 848  : 					int b = (pcontroller2[i] + 128) % 256;

	mov	eax, DWORD PTR _pcontroller2$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, 128				; 00000080H
	and	ecx, -2147483393			; 800000ffH
	jns	SHORT $LN32@R_StudioCa
	dec	ecx
	or	ecx, -256				; ffffff00H
	inc	ecx
$LN32@R_StudioCa:
	mov	DWORD PTR _b$1[ebp], ecx

; 849  : 					value = (( a * dadt ) + ( b * ( 1.0f - dadt )) - 128) * (360.0f / 256.0f) + pbonecontroller[j].start;

	cvtsi2ss xmm0, DWORD PTR _a$2[ebp]
	mulss	xmm0, DWORD PTR _dadt$[ebp]
	cvtsi2ss xmm1, DWORD PTR _b$1[ebp]
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@43000000
	mulss	xmm0, DWORD PTR __real@3fb40000
	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR _value$[ebp], xmm0

; 850  : 				}

	jmp	SHORT $LN13@R_StudioCa
$LN12@R_StudioCa:

; 851  : 				else 
; 852  : 				{
; 853  : 					value = ((pcontroller1[i] * dadt + (pcontroller2[i]) * (1.0f - dadt))) * (360.0f / 256.0f) + pbonecontroller[j].start;

	mov	eax, DWORD PTR _pcontroller1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _dadt$[ebp]
	mov	edx, DWORD PTR _pcontroller2$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2ss xmm1, eax
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3fb40000
	imul	ecx, DWORD PTR _j$[ebp], 24
	mov	edx, DWORD PTR _pbonecontroller$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+8]
	movss	DWORD PTR _value$[ebp], xmm0
$LN13@R_StudioCa:

; 854  : 				}
; 855  : 			}

	jmp	$LN11@R_StudioCa
$LN10@R_StudioCa:

; 856  : 			else 
; 857  : 			{
; 858  : 				value = (pcontroller1[i] * dadt + pcontroller2[i] * (1.0f - dadt)) / 255.0f;

	mov	eax, DWORD PTR _pcontroller1$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR _dadt$[ebp]
	mov	edx, DWORD PTR _pcontroller2$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2ss xmm1, eax
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _dadt$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _value$[ebp], xmm0

; 859  : 				value = bound( 0.0f, value, 1.0f );

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN27@R_StudioCa
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _value$[ebp]
	jbe	SHORT $LN25@R_StudioCa
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR tv202[ebp], xmm0
	jmp	SHORT $LN26@R_StudioCa
$LN25@R_StudioCa:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv202[ebp], xmm0
$LN26@R_StudioCa:
	movss	xmm0, DWORD PTR tv202[ebp]
	movss	DWORD PTR tv203[ebp], xmm0
	jmp	SHORT $LN28@R_StudioCa
$LN27@R_StudioCa:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv203[ebp], xmm0
$LN28@R_StudioCa:
	movss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 860  : 				value = (1.0f - value) * pbonecontroller[j].start + value * pbonecontroller[j].end;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _value$[ebp]
	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+8]
	imul	edx, DWORD PTR _j$[ebp], 24
	mov	eax, DWORD PTR _pbonecontroller$[ebp]
	movss	xmm1, DWORD PTR _value$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _value$[ebp], xmm0
$LN11@R_StudioCa:

; 861  : 			}
; 862  : 		}
; 863  : 
; 864  : 		switch( pbonecontroller[j].type & STUDIO_TYPES )

	imul	eax, DWORD PTR _j$[ebp], 24
	mov	ecx, DWORD PTR _pbonecontroller$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 32767				; 00007fffH
	mov	DWORD PTR tv219[ebp], edx
	mov	eax, DWORD PTR tv219[ebp]
	sub	eax, 1
	mov	DWORD PTR tv219[ebp], eax
	cmp	DWORD PTR tv219[ebp], 31		; 0000001fH
	ja	SHORT $LN5@R_StudioCa
	mov	ecx, DWORD PTR tv219[ebp]
	movzx	edx, BYTE PTR $LN29@R_StudioCa[ecx]
	jmp	DWORD PTR $LN30@R_StudioCa[edx*4]
$LN14@R_StudioCa:

; 865  : 		{
; 866  : 		case STUDIO_XR:
; 867  : 		case STUDIO_YR:
; 868  : 		case STUDIO_ZR:
; 869  : 			adj[j] = DEG2RAD( value );

	movss	xmm0, DWORD PTR _value$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 870  : 			break;

	jmp	SHORT $LN5@R_StudioCa
$LN17@R_StudioCa:

; 871  : 		case STUDIO_X:
; 872  : 		case STUDIO_Y:
; 873  : 		case STUDIO_Z:
; 874  : 			adj[j] = value;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
$LN5@R_StudioCa:

; 875  : 			break;
; 876  : 		}
; 877  : 	}

	jmp	$LN2@R_StudioCa
$LN3@R_StudioCa:

; 878  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@R_StudioCa:
	DD	$LN17@R_StudioCa
	DD	$LN14@R_StudioCa
	DD	$LN5@R_StudioCa
$LN29@R_StudioCa:
	DB	0
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_R_StudioCalcBoneAdj ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioFxTransform
_TEXT	SEGMENT
tv144 = -96						; size = 4
tv248 = -92						; size = 4
tv234 = -88						; size = 4
tv220 = -84						; size = 4
tv163 = -84						; size = 4
tv65 = -84						; size = 4
_scale$1 = -16						; size = 4
_axis$2 = -12						; size = 4
_offset$3 = -8						; size = 4
_axis$4 = -4						; size = 4
_ent$ = 8						; size = 4
_transform$ = 12					; size = 4
_R_StudioFxTransform PROC				; COMDAT

; 778  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 779  : 	switch( ent->curstate.renderfx )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+996]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 15			; 0000000fH
	je	SHORT $LN4@R_StudioFx
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	je	SHORT $LN4@R_StudioFx
	cmp	DWORD PTR tv65[ebp], 18			; 00000012H
	je	$LN11@R_StudioFx
	jmp	$LN2@R_StudioFx
$LN4@R_StudioFx:

; 780  : 	{
; 781  : 	case kRenderFxDistort:
; 782  : 	case kRenderFxHologram:
; 783  : 		if( !COM_RandomLong( 0, 49 ))

	push	49					; 00000031H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	$LN6@R_StudioFx

; 784  : 		{
; 785  : 			int	axis = COM_RandomLong( 0, 1 );

	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _axis$4[ebp], eax

; 786  : 
; 787  : 			if( axis == 1 ) axis = 2; // choose between x & z

	cmp	DWORD PTR _axis$4[ebp], 1
	jne	SHORT $LN8@R_StudioFx
	mov	DWORD PTR _axis$4[ebp], 2
$LN8@R_StudioFx:

; 788  : 			VectorScale( transform[axis], COM_RandomFloat( 1.0f, 1.484f ), transform[axis] );

	mov	esi, DWORD PTR _axis$4[ebp]
	shl	esi, 4
	add	esi, DWORD PTR _transform$[ebp]
	mov	eax, 4
	imul	edi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fbdf3b6
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv220[ebp]
	movss	xmm0, DWORD PTR tv220[ebp]
	mulss	xmm0, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR _axis$4[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _transform$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	esi, DWORD PTR _axis$4[ebp]
	shl	esi, 4
	add	esi, DWORD PTR _transform$[ebp]
	mov	edi, 4
	shl	edi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3fbdf3b6
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv234[ebp]
	movss	xmm0, DWORD PTR tv234[ebp]
	mulss	xmm0, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR _axis$4[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _transform$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	esi, DWORD PTR _axis$4[ebp]
	shl	esi, 4
	add	esi, DWORD PTR _transform$[ebp]
	mov	edi, 4
	shl	edi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@3fbdf3b6
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv248[ebp]
	movss	xmm0, DWORD PTR [esi+edi]
	mulss	xmm0, DWORD PTR tv248[ebp]
	movss	DWORD PTR tv144[ebp], xmm0
	mov	eax, DWORD PTR _axis$4[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _transform$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv144[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 789  : 		}

	jmp	$LN9@R_StudioFx
$LN6@R_StudioFx:

; 790  : 		else if( !COM_RandomLong( 0, 49 ))

	push	49					; 00000031H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@R_StudioFx

; 791  : 		{
; 792  : 			float	offset;
; 793  : 			int	axis = COM_RandomLong( 0, 1 );

	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _axis$2[ebp], eax

; 794  : 
; 795  : 			if( axis == 1 ) axis = 2; // choose between x & z

	cmp	DWORD PTR _axis$2[ebp], 1
	jne	SHORT $LN10@R_StudioFx
	mov	DWORD PTR _axis$2[ebp], 2
$LN10@R_StudioFx:

; 796  : 			offset = COM_RandomFloat( -10.0f, 10.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _offset$3[ebp]

; 797  : 			transform[COM_RandomLong( 0, 2 )][3] += offset;

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	shl	eax, 4
	add	eax, DWORD PTR _transform$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	add	eax, edx
	mov	DWORD PTR tv163[ebp], eax
	mov	eax, DWORD PTR tv163[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _offset$3[ebp]
	mov	ecx, DWORD PTR tv163[ebp]
	movss	DWORD PTR [ecx], xmm0
$LN9@R_StudioFx:

; 798  : 		}
; 799  : 		break;

	jmp	$LN2@R_StudioFx
$LN11@R_StudioFx:

; 800  : 	case kRenderFxExplode:
; 801  : 		{
; 802  : 			float	scale;
; 803  : 
; 804  : 			scale = 1.0f + ( g_studio.time - ent->curstate.animtime ) * 10.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	movsd	xmm1, QWORD PTR _g_studio
	subsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@4024000000000000
	addsd	xmm1, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _scale$1[ebp], xmm0

; 805  : 			if( scale > 2.0f ) scale = 2.0f; // don't blow up more than 200%

	movss	xmm0, DWORD PTR _scale$1[ebp]
	comiss	xmm0, DWORD PTR __real@40000000
	jbe	SHORT $LN12@R_StudioFx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _scale$1[ebp], xmm0
$LN12@R_StudioFx:

; 806  : 
; 807  : 			transform[0][1] *= scale;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _transform$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _scale$1[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _transform$[ebp]
	movss	DWORD PTR [edx+eax], xmm0

; 808  : 			transform[1][1] *= scale;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _transform$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _scale$1[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _transform$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 809  : 			transform[2][1] *= scale;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _transform$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _scale$1[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _transform$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN2@R_StudioFx:

; 810  : 		}
; 811  : 		break;
; 812  : 	}
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioFxTransform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioEstimateInterpolant
_TEXT	SEGMENT
_dadt$ = -4						; size = 4
_e$ = 8							; size = 4
_R_StudioEstimateInterpolant PROC			; COMDAT

; 654  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 655  : 	float	dadt = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dadt$[ebp], xmm0

; 656  : 
; 657  : 	if( g_studio.interpolate && ( e->curstate.animtime >= e->latched.prevanimtime + 0.01f ))

	cmp	DWORD PTR _g_studio+20, 0
	je	SHORT $LN3@R_StudioEs
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+3168]
	addss	xmm0, DWORD PTR __real@3c23d70a
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm1, DWORD PTR [ecx+1004]
	comiss	xmm1, xmm0
	jb	SHORT $LN3@R_StudioEs

; 658  : 	{
; 659  : 		dadt = ( g_studio.time - e->curstate.animtime ) / 0.1f;

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	movsd	xmm1, QWORD PTR _g_studio
	subsd	xmm1, xmm0
	divsd	xmm1, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _dadt$[ebp], xmm0

; 660  : 		if( dadt > 2.0f ) dadt = 2.0f;

	movss	xmm0, DWORD PTR _dadt$[ebp]
	comiss	xmm0, DWORD PTR __real@40000000
	jbe	SHORT $LN3@R_StudioEs
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _dadt$[ebp], xmm0
$LN3@R_StudioEs:

; 661  : 	}
; 662  : 
; 663  : 	return dadt;

	fld	DWORD PTR _dadt$[ebp]

; 664  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioEstimateInterpolant ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioEstimateFrame
_TEXT	SEGMENT
tv184 = -84						; size = 4
_f$ = -16						; size = 8
_dfdt$ = -8						; size = 8
_e$ = 8							; size = 4
_pseqdesc$ = 12						; size = 4
_R_StudioEstimateFrame PROC				; COMDAT

; 617  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 618  : 	double	dfdt, f;
; 619  : 
; 620  : 	if( g_studio.interpolate )

	cmp	DWORD PTR _g_studio+20, 0
	je	SHORT $LN2@R_StudioEs

; 621  : 	{
; 622  : 		if( g_studio.time < e->curstate.animtime ) dfdt = 0.0;

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	comisd	xmm0, QWORD PTR _g_studio
	jbe	SHORT $LN4@R_StudioEs
	xorps	xmm0, xmm0
	movsd	QWORD PTR _dfdt$[ebp], xmm0
	jmp	SHORT $LN5@R_StudioEs
$LN4@R_StudioEs:

; 623  : 		else dfdt = (g_studio.time - e->curstate.animtime) * e->curstate.framerate * pseqdesc->fps;

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	movsd	xmm1, QWORD PTR _g_studio
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+1008]
	mulsd	xmm1, xmm0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+32]
	mulsd	xmm1, xmm0
	movsd	QWORD PTR _dfdt$[ebp], xmm1
$LN5@R_StudioEs:

; 624  : 	}

	jmp	SHORT $LN3@R_StudioEs
$LN2@R_StudioEs:

; 625  : 	else dfdt = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _dfdt$[ebp], xmm0
$LN3@R_StudioEs:

; 626  : 
; 627  : 	if( pseqdesc->numframes <= 1 ) f = 0.0;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jg	SHORT $LN6@R_StudioEs
	xorps	xmm0, xmm0
	movsd	QWORD PTR _f$[ebp], xmm0
	jmp	SHORT $LN7@R_StudioEs
$LN6@R_StudioEs:

; 628  : 	else f = (e->curstate.frame * (pseqdesc->numframes - 1)) / 256.0;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _e$[ebp]
	mulss	xmm0, DWORD PTR [edx+960]
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@4070000000000000
	movsd	QWORD PTR _f$[ebp], xmm0
$LN7@R_StudioEs:

; 629  :  
; 630  : 	f += dfdt;

	movsd	xmm0, QWORD PTR _f$[ebp]
	addsd	xmm0, QWORD PTR _dfdt$[ebp]
	movsd	QWORD PTR _f$[ebp], xmm0

; 631  : 
; 632  : 	if( pseqdesc->flags & STUDIO_LOOPING ) 

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	je	SHORT $LN8@R_StudioEs

; 633  : 	{
; 634  : 		if( pseqdesc->numframes > 1 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jle	SHORT $LN10@R_StudioEs

; 635  : 			f -= (int)(f / (pseqdesc->numframes - 1)) *  (pseqdesc->numframes - 1);

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2sd xmm0, ecx
	movsd	xmm1, QWORD PTR _f$[ebp]
	divsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	imul	edx, ecx
	cvtsi2sd xmm0, edx
	movsd	xmm1, QWORD PTR _f$[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _f$[ebp], xmm1
$LN10@R_StudioEs:

; 636  : 		if( f < 0 ) f += (pseqdesc->numframes - 1);

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _f$[ebp]
	jbe	SHORT $LN11@R_StudioEs
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	sub	ecx, 1
	cvtsi2sd xmm0, ecx
	addsd	xmm0, QWORD PTR _f$[ebp]
	movsd	QWORD PTR _f$[ebp], xmm0
$LN11@R_StudioEs:

; 637  : 	}

	jmp	SHORT $LN13@R_StudioEs
$LN8@R_StudioEs:

; 638  : 	else 
; 639  : 	{
; 640  : 		if( f >= pseqdesc->numframes - 1.001 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+56]
	subsd	xmm0, QWORD PTR __real@3ff004189374bc6a
	movsd	xmm1, QWORD PTR _f$[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN12@R_StudioEs

; 641  : 			f = pseqdesc->numframes - 1.001;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+56]
	subsd	xmm0, QWORD PTR __real@3ff004189374bc6a
	movsd	QWORD PTR _f$[ebp], xmm0
$LN12@R_StudioEs:

; 642  : 		if( f < 0.0 )  f = 0.0;

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _f$[ebp]
	jbe	SHORT $LN13@R_StudioEs
	xorps	xmm0, xmm0
	movsd	QWORD PTR _f$[ebp], xmm0
$LN13@R_StudioEs:

; 643  : 	}
; 644  : 	return f;

	cvtsd2ss xmm0, QWORD PTR _f$[ebp]
	movss	DWORD PTR tv184[ebp], xmm0
	fld	DWORD PTR tv184[ebp]

; 645  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioEstimateFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetUpTransform
_TEXT	SEGMENT
_angles$ = -28						; size = 12
_origin$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_StudioSetUpTransform PROC				; COMDAT

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 583  : 	vec3_t	origin, angles;
; 584  : 
; 585  : 	VectorCopy( e->origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 586  : 	VectorCopy( e->angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3236]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3236]
	mov	DWORD PTR _angles$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+3236]
	mov	DWORD PTR _angles$[ebp+ecx], eax

; 587  : 
; 588  : 	// interpolate monsters position (moved into UpdateEntityFields by user request)
; 589  : 	if( e->curstate.movetype == MOVETYPE_STEP && !FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP )) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1000], 4
	jne	SHORT $LN2@R_StudioSe
	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	jne	SHORT $LN2@R_StudioSe

; 590  : 	{
; 591  : 		R_StudioLerpMovement( e, g_studio.time, origin, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _g_studio
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_StudioLerpMovement
	add	esp, 20					; 00000014H
$LN2@R_StudioSe:

; 592  : 	}
; 593  : 
; 594  : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN3@R_StudioSe

; 595  : 		angles[PITCH] = -angles[PITCH]; // stupid quake bug

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _angles$[ebp+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _angles$[ebp+eax], xmm0
$LN3@R_StudioSe:

; 596  : 
; 597  : 	// don't rotate clients, only aim
; 598  : 	if( e->player ) angles[PITCH] = 0.0f;

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@R_StudioSe
	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _angles$[ebp+ecx], xmm0
$LN4@R_StudioSe:

; 599  : 
; 600  : 	Matrix3x4_CreateFromEntity( g_studio.rotationmatrix, angles, origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _origin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	push	OFFSET _g_studio+32
	call	_Matrix3x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 601  : 
; 602  : 	if( tr.fFlipViewModel )

	cmp	DWORD PTR _tr+83216, 0
	je	$LN5@R_StudioSe

; 603  : 	{
; 604  : 		g_studio.rotationmatrix[0][1] = -g_studio.rotationmatrix[0][1];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _g_studio[ecx+edx+32]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _g_studio[ecx+edx+32], xmm0

; 605  : 		g_studio.rotationmatrix[1][1] = -g_studio.rotationmatrix[1][1];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+32]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 16					; 00000010H
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+32], xmm0

; 606  : 		g_studio.rotationmatrix[2][1] = -g_studio.rotationmatrix[2][1];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_studio[eax+ecx+32]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 16					; 00000010H
	shl	edx, 1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _g_studio[edx+eax+32], xmm0
$LN5@R_StudioSe:

; 607  : 	}
; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetUpTransform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioPlayerBlend
_TEXT	SEGMENT
_pseqdesc$ = 8						; size = 4
_pBlend$ = 12						; size = 4
_pPitch$ = 16						; size = 4
_R_StudioPlayerBlend PROC				; COMDAT

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 522  : 	// calc up/down pointing
; 523  : 	*pBlend = (*pPitch * 3.0f);

	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@40400000
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [edx], ecx

; 524  : 
; 525  : 	if( *pBlend < pseqdesc->blendstart[0] )

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+136]
	comiss	xmm1, xmm0
	jbe	SHORT $LN2@R_StudioPl

; 526  : 	{
; 527  : 		*pPitch -= pseqdesc->blendstart[0] / 3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+136]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _pPitch$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 528  : 		*pBlend = 0;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 0

; 529  : 	}

	jmp	$LN5@R_StudioPl
$LN2@R_StudioPl:

; 530  : 	else if( *pBlend > pseqdesc->blendend[0] )

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	comiss	xmm0, DWORD PTR [eax+edx+144]
	jbe	SHORT $LN4@R_StudioPl

; 531  : 	{
; 532  : 		*pPitch -= pseqdesc->blendend[0] / 3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+144]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, DWORD PTR _pPitch$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _pPitch$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 533  : 		*pBlend = 255;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 255			; 000000ffH

; 534  : 	}

	jmp	$LN5@R_StudioPl
$LN4@R_StudioPl:

; 535  : 	else
; 536  : 	{
; 537  : 		if( pseqdesc->blendend[0] - pseqdesc->blendstart[0] < 0.1f ) // catch qc error

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	esi, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+144]
	subss	xmm0, DWORD PTR [esi+eax+136]
	movss	xmm1, DWORD PTR __real@3dcccccd
	comiss	xmm1, xmm0
	jbe	SHORT $LN6@R_StudioPl

; 538  : 			*pBlend = 127;

	mov	eax, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [eax], 127			; 0000007fH
	jmp	SHORT $LN7@R_StudioPl
$LN6@R_StudioPl:

; 539  : 		else *pBlend = 255 * (*pBlend - pseqdesc->blendstart[0]) / (pseqdesc->blendend[0] - pseqdesc->blendstart[0]);

	mov	eax, DWORD PTR _pBlend$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	subss	xmm0, DWORD PTR [eax+edx+136]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	esi, DWORD PTR _pseqdesc$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+144]
	subss	xmm1, DWORD PTR [esi+ecx+136]
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _pBlend$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@R_StudioPl:

; 540  : 		*pPitch = 0.0f;

	mov	eax, DWORD PTR _pPitch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0
$LN5@R_StudioPl:

; 541  : 	}
; 542  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioPlayerBlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnStudioGetRotationMatrix
_TEXT	SEGMENT
_pfnStudioGetRotationMatrix PROC			; COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 511  : 	return (float ***)g_studio.rotationmatrix;

	mov	eax, OFFSET _g_studio+32

; 512  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStudioGetRotationMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnStudioGetAliasTransform
_TEXT	SEGMENT
_pfnStudioGetAliasTransform PROC			; COMDAT

; 499  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 500  : 	return NULL;

	xor	eax, eax

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStudioGetAliasTransform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnStudioGetLightTransform
_TEXT	SEGMENT
_pfnStudioGetLightTransform PROC			; COMDAT

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 489  : 	return (float ****)g_studio.lighttransform;

	mov	eax, OFFSET _g_studio+6224

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStudioGetLightTransform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnStudioGetBoneTransform
_TEXT	SEGMENT
_pfnStudioGetBoneTransform PROC				; COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 478  : 	return (float ****)g_studio.bonestransform;

	mov	eax, OFFSET _g_studio+80

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStudioGetBoneTransform ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetAliasScale
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_pfnGetAliasScale PROC					; COMDAT

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 466  : 	if( x ) *x = 1.0f;

	cmp	DWORD PTR _x$[ebp], 0
	je	SHORT $LN2@pfnGetAlia
	mov	eax, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0
$LN2@pfnGetAlia:

; 467  : 	if( y ) *y = 1.0f;

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN3@pfnGetAlia
	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax], xmm0
$LN3@pfnGetAlia:

; 468  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetAliasScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetModelCounters
_TEXT	SEGMENT
_s$ = 8							; size = 4
_a$ = 12						; size = 4
_pfnGetModelCounters PROC				; COMDAT

; 453  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 454  : 	*s = &g_studio.framecount;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR [eax], OFFSET _g_studio+16

; 455  : 	*a = &r_stats.c_studio_models_drawn;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax], OFFSET _r_stats+32

; 456  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetModelCounters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_GetChromeSprite
_TEXT	SEGMENT
_R_GetChromeSprite PROC					; COMDAT

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 443  : 	return cl_sprite_shell;

	mov	eax, DWORD PTR _cl_sprite_shell

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetChromeSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetViewInfo
_TEXT	SEGMENT
_origin$ = 8						; size = 4
_upv$ = 12						; size = 4
_rightv$ = 16						; size = 4
_forwardv$ = 20						; size = 4
_pfnGetViewInfo PROC					; COMDAT

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 429  : 	if( origin ) VectorCopy( RI.vieworg, origin );

	cmp	DWORD PTR _origin$[ebp], 0
	je	SHORT $LN2@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR _RI[eax+200]
	mov	DWORD PTR [edx+ecx], eax
$LN2@pfnGetView:

; 430  : 	if( forwardv ) VectorCopy( RI.vforward, forwardv );

	cmp	DWORD PTR _forwardv$[ebp], 0
	je	SHORT $LN3@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _forwardv$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _forwardv$[ebp]
	mov	edx, DWORD PTR _RI[edx+224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _forwardv$[ebp]
	mov	eax, DWORD PTR _RI[eax+224]
	mov	DWORD PTR [edx+ecx], eax
$LN3@pfnGetView:

; 431  : 	if( rightv ) VectorCopy( RI.vright, rightv );

	cmp	DWORD PTR _rightv$[ebp], 0
	je	SHORT $LN4@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rightv$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+236]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rightv$[ebp]
	mov	edx, DWORD PTR _RI[edx+236]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rightv$[ebp]
	mov	eax, DWORD PTR _RI[eax+236]
	mov	DWORD PTR [edx+ecx], eax
$LN4@pfnGetView:

; 432  : 	if( upv ) VectorCopy( RI.vup, upv );

	cmp	DWORD PTR _upv$[ebp], 0
	je	SHORT $LN5@pfnGetView
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _upv$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+248]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _upv$[ebp]
	mov	edx, DWORD PTR _RI[edx+248]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _upv$[ebp]
	mov	eax, DWORD PTR _RI[eax+248]
	mov	DWORD PTR [edx+ecx], eax
$LN5@pfnGetView:

; 433  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetViewInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetEngineTimes
_TEXT	SEGMENT
_framecount$ = 8					; size = 4
_current$ = 12						; size = 4
_old$ = 16						; size = 4
_pfnGetEngineTimes PROC					; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 416  : 	if( framecount ) *framecount = tr.realframecount;

	cmp	DWORD PTR _framecount$[ebp], 0
	je	SHORT $LN2@pfnGetEngi
	mov	eax, DWORD PTR _framecount$[ebp]
	mov	ecx, DWORD PTR _tr+83196
	mov	DWORD PTR [eax], ecx
$LN2@pfnGetEngi:

; 417  : 	if( current ) *current = cl.time;

	cmp	DWORD PTR _current$[ebp], 0
	je	SHORT $LN3@pfnGetEngi
	mov	eax, DWORD PTR _current$[ebp]
	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR [eax], xmm0
$LN3@pfnGetEngi:

; 418  : 	if( old ) *old = cl.oldtime;

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN4@pfnGetEngi
	mov	eax, DWORD PTR _old$[ebp]
	movsd	xmm0, QWORD PTR _cl+2167648
	movsd	QWORD PTR [eax], xmm0
$LN4@pfnGetEngi:

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetEngineTimes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetViewEntity
_TEXT	SEGMENT
_pfnGetViewEntity PROC					; COMDAT

; 404  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 405  : 	return &clgame.viewent;

	mov	eax, OFFSET _clgame+260432

; 406  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetViewEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioGetPlayerState
_TEXT	SEGMENT
_index$ = 8						; size = 4
_R_StudioGetPlayerState PROC				; COMDAT

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 388  : 	if( !RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN2@R_StudioGe

; 389  : 		return &RI.currententity->curstate;

	mov	eax, DWORD PTR _RI+28
	add	eax, 912				; 00000390H
	jmp	SHORT $LN1@R_StudioGe
$LN2@R_StudioGe:

; 390  : 
; 391  : 	if( index < 0 || index >= cl.maxclients )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN4@R_StudioGe
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jl	SHORT $LN3@R_StudioGe
$LN4@R_StudioGe:

; 392  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioGe
$LN3@R_StudioGe:

; 393  : 
; 394  : 	return &cl.frames[cl.parsecountmod].playerstate[index];

	imul	eax, DWORD PTR _cl+12, 24056
	imul	ecx, DWORD PTR _index$[ebp], 452
	lea	eax, DWORD PTR _cl[eax+ecx+2736]
$LN1@R_StudioGe:

; 395  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioGetPlayerState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnMod_ForName
_TEXT	SEGMENT
_model$ = 8						; size = 4
_crash$ = 12						; size = 4
_pfnMod_ForName PROC					; COMDAT

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 377  : 	return Mod_ForName( model, crash, false );

	push	0
	mov	eax, DWORD PTR _crash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	_Mod_ForName
	add	esp, 12					; 0000000cH

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMod_ForName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnGetCurrentEntity
_TEXT	SEGMENT
_pfnGetCurrentEntity PROC				; COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 350  : 	return RI.currententity;

	mov	eax, DWORD PTR _RI+28

; 351  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetCurrentEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioComputeSkinMatrix
_TEXT	SEGMENT
_boneMat1$1 = -64					; size = 4
_boneMat0$2 = -60					; size = 4
_boneMat2$3 = -56					; size = 4
_boneMat1$4 = -52					; size = 4
_boneMat0$5 = -48					; size = 4
_boneMat3$6 = -44					; size = 4
_boneMat2$7 = -40					; size = 4
_boneMat1$8 = -36					; size = 4
_boneMat0$9 = -32					; size = 4
_flTotal$ = -28						; size = 4
_numbones$ = -24					; size = 4
_i$ = -20						; size = 4
_flWeight3$ = -16					; size = 4
_flWeight2$ = -12					; size = 4
_flWeight1$ = -8					; size = 4
_flWeight0$ = -4					; size = 4
_boneweights$ = 8					; size = 4
_result$ = 12						; size = 4
_R_StudioComputeSkinMatrix PROC				; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi

; 251  : 	float	flWeight0, flWeight1, flWeight2, flWeight3;
; 252  : 	int	i, numbones = 0;

	mov	DWORD PTR _numbones$[ebp], 0

; 253  : 	float	flTotal;
; 254  : 
; 255  : 	for( i = 0; i < MAXSTUDIOBONEWEIGHTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioCo
$LN2@R_StudioCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioCo:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN3@R_StudioCo

; 256  : 	{
; 257  : 		if( boneweights->bone[i] != -1 )

	mov	eax, DWORD PTR _boneweights$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN5@R_StudioCo

; 258  : 			numbones++;

	mov	eax, DWORD PTR _numbones$[ebp]
	add	eax, 1
	mov	DWORD PTR _numbones$[ebp], eax
$LN5@R_StudioCo:

; 259  : 	}

	jmp	SHORT $LN2@R_StudioCo
$LN3@R_StudioCo:

; 260  : 
; 261  : 	if( numbones == 4 )

	cmp	DWORD PTR _numbones$[ebp], 4
	jne	$LN6@R_StudioCo

; 262  : 	{
; 263  : 		vec4_t *boneMat0 = (vec4_t *)g_studio.worldtransform[boneweights->bone[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+4]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat0$9[ebp], ecx

; 264  : 		vec4_t *boneMat1 = (vec4_t *)g_studio.worldtransform[boneweights->bone[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	imul	eax, edx, 48
	add	eax, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat1$8[ebp], eax

; 265  : 		vec4_t *boneMat2 = (vec4_t *)g_studio.worldtransform[boneweights->bone[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	imul	eax, edx, 48
	add	eax, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat2$7[ebp], eax

; 266  : 		vec4_t *boneMat3 = (vec4_t *)g_studio.worldtransform[boneweights->bone[3]];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _boneweights$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+4]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat3$6[ebp], ecx

; 267  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight0$[ebp], xmm0

; 268  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight1$[ebp], xmm0

; 269  : 		flWeight2 = boneweights->weight[2] / 255.0f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight2$[ebp], xmm0

; 270  : 		flWeight3 = boneweights->weight[3] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _boneweights$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight3$[ebp], xmm0

; 271  : 		flTotal = flWeight0 + flWeight1 + flWeight2 + flWeight3;

	movss	xmm0, DWORD PTR _flWeight0$[ebp]
	addss	xmm0, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, DWORD PTR _flWeight3$[ebp]
	movss	DWORD PTR _flTotal$[ebp], xmm0

; 272  : 
; 273  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _flTotal$[ebp]
	jbe	SHORT $LN8@R_StudioCo
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flTotal$[ebp]
	addss	xmm0, DWORD PTR _flWeight0$[ebp]
	movss	DWORD PTR _flWeight0$[ebp], xmm0
$LN8@R_StudioCo:

; 274  : 
; 275  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1 + boneMat2[0][0] * flWeight2 + boneMat3[0][0] * flWeight3;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$9[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat3$6[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR [ecx+eax]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0

; 276  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1 + boneMat2[0][1] * flWeight2 + boneMat3[0][1] * flWeight3;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$9[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$8[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat3$6[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 277  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1 + boneMat2[0][2] * flWeight2 + boneMat3[0][2] * flWeight3;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$9[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$8[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat3$6[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 278  : 		result[0][3] = boneMat0[0][3] * flWeight0 + boneMat1[0][3] * flWeight1 + boneMat2[0][3] * flWeight2 + boneMat3[0][3] * flWeight3;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$9[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat3$6[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm1, DWORD PTR [ecx+eax]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	DWORD PTR [edx+ecx], xmm0

; 279  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1 + boneMat2[1][0] * flWeight2 + boneMat3[1][0] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$8[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 280  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1 + boneMat2[1][1] * flWeight2 + boneMat3[1][1] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 281  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1 + boneMat2[1][2] * flWeight2 + boneMat3[1][2] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 282  : 		result[1][3] = boneMat0[1][3] * flWeight0 + boneMat1[1][3] * flWeight1 + boneMat2[1][3] * flWeight2 + boneMat3[1][3] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$8[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 283  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1 + boneMat2[2][0] * flWeight2 + boneMat3[2][0] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$8[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 284  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1 + boneMat2[2][1] * flWeight2 + boneMat3[2][1] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 285  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1 + boneMat2[2][2] * flWeight2 + boneMat3[2][2] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$8[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _boneMat2$7[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _result$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 286  : 		result[2][3] = boneMat0[2][3] * flWeight0 + boneMat1[2][3] * flWeight1 + boneMat2[2][3] * flWeight2 + boneMat3[2][3] * flWeight3;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$9[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$8[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat2$7[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat3$6[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight3$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 287  : 	}

	jmp	$LN13@R_StudioCo
$LN6@R_StudioCo:

; 288  : 	else if( numbones == 3 )

	cmp	DWORD PTR _numbones$[ebp], 3
	jne	$LN9@R_StudioCo

; 289  : 	{
; 290  : 		vec4_t *boneMat0 = (vec4_t *)g_studio.worldtransform[boneweights->bone[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+4]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat0$5[ebp], ecx

; 291  : 		vec4_t *boneMat1 = (vec4_t *)g_studio.worldtransform[boneweights->bone[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	imul	eax, edx, 48
	add	eax, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat1$4[ebp], eax

; 292  : 		vec4_t *boneMat2 = (vec4_t *)g_studio.worldtransform[boneweights->bone[2]];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	imul	eax, edx, 48
	add	eax, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat2$3[ebp], eax

; 293  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight0$[ebp], xmm0

; 294  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight1$[ebp], xmm0

; 295  : 		flWeight2 = boneweights->weight[2] / 255.0f;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight2$[ebp], xmm0

; 296  : 		flTotal = flWeight0 + flWeight1 + flWeight2;

	movss	xmm0, DWORD PTR _flWeight0$[ebp]
	addss	xmm0, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, DWORD PTR _flWeight2$[ebp]
	movss	DWORD PTR _flTotal$[ebp], xmm0

; 297  : 
; 298  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _flTotal$[ebp]
	jbe	SHORT $LN11@R_StudioCo
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flTotal$[ebp]
	addss	xmm0, DWORD PTR _flWeight0$[ebp]
	movss	DWORD PTR _flWeight0$[ebp], xmm0
$LN11@R_StudioCo:

; 299  : 
; 300  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1 + boneMat2[0][0] * flWeight2;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$5[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 301  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1 + boneMat2[0][1] * flWeight2;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$5[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$4[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 302  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1 + boneMat2[0][2] * flWeight2;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$5[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$4[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 303  : 		result[0][3] = boneMat0[0][3] * flWeight0 + boneMat1[0][3] * flWeight1 + boneMat2[0][3] * flWeight2;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$5[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR [ecx+eax], xmm0

; 304  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1 + boneMat2[1][0] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$4[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 305  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1 + boneMat2[1][1] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 306  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1 + boneMat2[1][2] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 307  : 		result[1][3] = boneMat0[1][3] * flWeight0 + boneMat1[1][3] * flWeight1 + boneMat2[1][3] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$4[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 308  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1 + boneMat2[2][0] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$4[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 309  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1 + boneMat2[2][1] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 310  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1 + boneMat2[2][2] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$4[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _boneMat2$3[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 311  : 		result[2][3] = boneMat0[2][3] * flWeight0 + boneMat1[2][3] * flWeight1 + boneMat2[2][3] * flWeight2;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$5[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$4[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat2$3[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight2$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 312  : 	}

	jmp	$LN13@R_StudioCo
$LN9@R_StudioCo:

; 313  : 	else if( numbones == 2 )

	cmp	DWORD PTR _numbones$[ebp], 2
	jne	$LN12@R_StudioCo

; 314  : 	{
; 315  : 		vec4_t *boneMat0 = (vec4_t *)g_studio.worldtransform[boneweights->bone[0]];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+4]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat0$2[ebp], ecx

; 316  : 		vec4_t *boneMat1 = (vec4_t *)g_studio.worldtransform[boneweights->bone[1]];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	imul	eax, edx, 48
	add	eax, OFFSET _g_studio+12368
	mov	DWORD PTR _boneMat1$1[ebp], eax

; 317  : 		flWeight0 = boneweights->weight[0] / 255.0f;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight0$[ebp], xmm0

; 318  : 		flWeight1 = boneweights->weight[1] / 255.0f;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _boneweights$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _flWeight1$[ebp], xmm0

; 319  : 		flTotal = flWeight0 + flWeight1;

	movss	xmm0, DWORD PTR _flWeight0$[ebp]
	addss	xmm0, DWORD PTR _flWeight1$[ebp]
	movss	DWORD PTR _flTotal$[ebp], xmm0

; 320  : 
; 321  : 		if( flTotal < 1.0f ) flWeight0 += 1.0f - flTotal;	// compensate rounding error

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _flTotal$[ebp]
	jbe	SHORT $LN14@R_StudioCo
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _flTotal$[ebp]
	addss	xmm0, DWORD PTR _flWeight0$[ebp]
	movss	DWORD PTR _flWeight0$[ebp], xmm0
$LN14@R_StudioCo:

; 322  : 
; 323  : 		result[0][0] = boneMat0[0][0] * flWeight0 + boneMat1[0][0] * flWeight1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$2[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 324  : 		result[0][1] = boneMat0[0][1] * flWeight0 + boneMat1[0][1] * flWeight1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$2[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 325  : 		result[0][2] = boneMat0[0][2] * flWeight0 + boneMat1[0][2] * flWeight1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$2[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat1$1[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 326  : 		result[0][3] = boneMat0[0][3] * flWeight0 + boneMat1[0][3] * flWeight1;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _boneMat0$2[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 327  : 		result[1][0] = boneMat0[1][0] * flWeight0 + boneMat1[1][0] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 328  : 		result[1][1] = boneMat0[1][1] * flWeight0 + boneMat1[1][1] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 329  : 		result[1][2] = boneMat0[1][2] * flWeight0 + boneMat1[1][2] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 330  : 		result[1][3] = boneMat0[1][3] * flWeight0 + boneMat1[1][3] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _boneMat1$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 331  : 		result[2][0] = boneMat0[2][0] * flWeight0 + boneMat1[2][0] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 332  : 		result[2][1] = boneMat0[2][1] * flWeight0 + boneMat1[2][1] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0

; 333  : 		result[2][2] = boneMat0[2][2] * flWeight0 + boneMat1[2][2] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	edx, 16					; 00000010H
	shl	edx, 1
	add	edx, DWORD PTR _boneMat1$1[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _result$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR [ecx+edx], xmm0

; 334  : 		result[2][3] = boneMat0[2][3] * flWeight0 + boneMat1[2][3] * flWeight1;

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat0$2[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _flWeight0$[ebp]
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _boneMat1$1[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	xmm1, DWORD PTR [eax+edx]
	mulss	xmm1, DWORD PTR _flWeight1$[ebp]
	addss	xmm0, xmm1
	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _result$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	movss	DWORD PTR [eax+edx], xmm0

; 335  : 	}

	jmp	SHORT $LN13@R_StudioCo
$LN12@R_StudioCo:

; 336  : 	else
; 337  : 	{
; 338  : 		Matrix3x4_Copy( result, g_studio.worldtransform[boneweights->bone[0]] );

	push	48					; 00000030H
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _boneweights$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+4]
	imul	ecx, eax, 48
	add	ecx, OFFSET _g_studio+12368
	push	ecx
	mov	edx, DWORD PTR _result$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN13@R_StudioCo:

; 339  : 	}
; 340  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioComputeSkinMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioComputeBBox
_TEXT	SEGMENT
tv196 = -156						; size = 4
tv187 = -156						; size = 4
tv178 = -156						; size = 4
_i$ = -88						; size = 4
_pseqdesc$ = -84					; size = 4
_e$ = -80						; size = 4
_p2$ = -76						; size = 12
_p1$ = -64						; size = 12
_maxs$ = -52						; size = 12
_mins$ = -40						; size = 12
_studio_maxs$ = -28					; size = 12
_studio_mins$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_bbox$ = 8						; size = 4
_R_StudioComputeBBox PROC				; COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 200  : 	vec3_t		studio_mins, studio_maxs;
; 201  : 	vec3_t		mins, maxs, p1, p2;
; 202  : 	cl_entity_t	*e = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _e$[ebp], eax

; 203  : 	mstudioseqdesc_t	*pseqdesc;
; 204  : 	int		i;
; 205  : 
; 206  : 	if( !m_pStudioHeader )

	cmp	DWORD PTR _m_pStudioHeader, 0
	jne	SHORT $LN5@R_StudioCo

; 207  : 		return false;

	xor	eax, eax
	jmp	$LN1@R_StudioCo
$LN5@R_StudioCo:

; 208  : 
; 209  : 	// check if we have valid mins\maxs
; 210  : 	if( !VectorCompare( vec3_origin, RI.currentmodel->mins ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+32
	movss	xmm0, DWORD PTR _vec3_origin[ecx]
	ucomiss	xmm0, DWORD PTR [edx+eax+84]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@R_StudioCo
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _RI+32
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+84]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@R_StudioCo
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+32
	movss	xmm0, DWORD PTR _vec3_origin[eax]
	ucomiss	xmm0, DWORD PTR [edx+ecx+84]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@R_StudioCo
$LN8@R_StudioCo:

; 211  : 	{
; 212  : 		// clipping bounding box
; 213  : 		VectorCopy( RI.currentmodel->mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [edx+ecx+84]
	mov	DWORD PTR _mins$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+32
	mov	edx, DWORD PTR [ecx+edx+84]
	mov	DWORD PTR _mins$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+32
	mov	eax, DWORD PTR [edx+eax+84]
	mov	DWORD PTR _mins$[ebp+ecx], eax

; 214  : 		VectorCopy( RI.currentmodel->maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _RI+32
	mov	ecx, DWORD PTR [edx+ecx+96]
	mov	DWORD PTR _maxs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _RI+32
	mov	edx, DWORD PTR [ecx+edx+96]
	mov	DWORD PTR _maxs$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _RI+32
	mov	eax, DWORD PTR [edx+eax+96]
	mov	DWORD PTR _maxs$[ebp+ecx], eax

; 215  : 	}

	jmp	SHORT $LN7@R_StudioCo
$LN6@R_StudioCo:

; 216  : 	else
; 217  : 	{
; 218  : 		ClearBounds( mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8
$LN7@R_StudioCo:

; 219  : 	}
; 220  : 
; 221  : 	// check sequence range
; 222  : 	if( e->curstate.sequence < 0 || e->curstate.sequence >= m_pStudioHeader->numseq )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+956], 0
	jl	SHORT $LN10@R_StudioCo
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader
	mov	edx, DWORD PTR [eax+956]
	cmp	edx, DWORD PTR [ecx+164]
	jl	SHORT $LN9@R_StudioCo
$LN10@R_StudioCo:

; 223  : 		e->curstate.sequence = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+956], 0
$LN9@R_StudioCo:

; 224  : 
; 225  : 	pseqdesc = (mstudioseqdesc_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqindex) + e->curstate.sequence;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	ecx, DWORD PTR _m_pStudioHeader
	add	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _e$[ebp]
	imul	eax, DWORD PTR [edx+956], 176
	add	ecx, eax
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 226  : 
; 227  : 	// add sequence box to the model box
; 228  : 	AddPointToBounds( pseqdesc->bbmin, mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 229  : 	AddPointToBounds( pseqdesc->bbmax, mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 230  : 	ClearBounds( studio_mins, studio_maxs );

	lea	eax, DWORD PTR _studio_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _studio_mins$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8

; 231  : 
; 232  : 	// compute a full bounding box
; 233  : 	for( i = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioCo
$LN2@R_StudioCo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioCo:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@R_StudioCo

; 234  : 	{
; 235  :   		p1[0] = ( i & 1 ) ? mins[0] : maxs[0];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	je	SHORT $LN14@R_StudioCo
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+edx]
	movss	DWORD PTR tv178[ebp], xmm0
	jmp	SHORT $LN15@R_StudioCo
$LN14@R_StudioCo:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+ecx]
	movss	DWORD PTR tv178[ebp], xmm0
$LN15@R_StudioCo:
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR tv178[ebp]
	movss	DWORD PTR _p1$[ebp+eax], xmm0

; 236  :   		p1[1] = ( i & 2 ) ? mins[1] : maxs[1];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 2
	je	SHORT $LN16@R_StudioCo
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv187[ebp], xmm0
	jmp	SHORT $LN17@R_StudioCo
$LN16@R_StudioCo:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _maxs$[ebp+edx]
	movss	DWORD PTR tv187[ebp], xmm0
$LN17@R_StudioCo:
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR tv187[ebp]
	movss	DWORD PTR _p1$[ebp+eax], xmm0

; 237  :   		p1[2] = ( i & 4 ) ? mins[2] : maxs[2];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 4
	je	SHORT $LN18@R_StudioCo
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv196[ebp], xmm0
	jmp	SHORT $LN19@R_StudioCo
$LN18@R_StudioCo:
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _maxs$[ebp+edx]
	movss	DWORD PTR tv196[ebp], xmm0
$LN19@R_StudioCo:
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv196[ebp]
	movss	DWORD PTR _p1$[ebp+eax], xmm0

; 238  : 
; 239  : 		Matrix3x4_VectorTransform( g_studio.rotationmatrix, p1, p2 );

	lea	eax, DWORD PTR _p2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	push	OFFSET _g_studio+32
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 240  : 		AddPointToBounds( p2, studio_mins, studio_maxs );

	lea	eax, DWORD PTR _studio_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _studio_mins$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p2$[ebp]
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 241  : 		if( bbox ) VectorCopy( p2, bbox[i] );

	cmp	DWORD PTR _bbox$[ebp], 0
	je	SHORT $LN11@R_StudioCo
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _bbox$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _p2$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _bbox$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p2$[ebp+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _bbox$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _p2$[ebp+eax]
	mov	DWORD PTR [ecx+edx], eax
$LN11@R_StudioCo:

; 242  : 	}

	jmp	$LN2@R_StudioCo
$LN3@R_StudioCo:

; 243  : 
; 244  : 	if( !bbox && R_CullModel( e, studio_mins, studio_maxs ))

	cmp	DWORD PTR _bbox$[ebp], 0
	jne	SHORT $LN12@R_StudioCo
	lea	eax, DWORD PTR _studio_maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _studio_mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_CullModel
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN12@R_StudioCo

; 245  : 		return false; // model culled

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioCo
$LN12@R_StudioCo:

; 246  : 	return true; // visible

	mov	eax, 1
$LN1@R_StudioCo:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioComputeBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_AllowFlipViewModel
_TEXT	SEGMENT
_e$ = 8							; size = 4
_R_AllowFlipViewModel PROC				; COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 182  : 	if( cl_righthand && cl_righthand->value > 0 )

	cmp	DWORD PTR _cl_righthand, 0
	je	SHORT $LN3@R_AllowFli
	mov	eax, DWORD PTR _cl_righthand
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@R_AllowFli

; 183  : 	{
; 184  : 		if( e == &clgame.viewent )

	cmp	DWORD PTR _e$[ebp], OFFSET _clgame+260432
	jne	SHORT $LN3@R_AllowFli

; 185  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_AllowFli
$LN3@R_AllowFli:

; 186  : 	}
; 187  : 
; 188  : 	return false;

	xor	eax, eax
$LN1@R_AllowFli:

; 189  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AllowFlipViewModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetupTimings
_TEXT	SEGMENT
_R_StudioSetupTimings PROC				; COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 159  : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_StudioSe

; 160  : 	{
; 161  : 		// synchronize with server time
; 162  : 		g_studio.time = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _g_studio, xmm0

; 163  : 		g_studio.frametime = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	movsd	QWORD PTR _g_studio+8, xmm0

; 164  : 	}

	jmp	SHORT $LN3@R_StudioSe
$LN2@R_StudioSe:

; 165  : 	else
; 166  : 	{
; 167  : 		// menu stuff
; 168  : 		g_studio.time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _g_studio, xmm0

; 169  : 		g_studio.frametime = host.frametime;

	movsd	xmm0, QWORD PTR _host+1448
	movsd	QWORD PTR _g_studio+8, xmm0
$LN3@R_StudioSe:

; 170  : 	}
; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetupTimings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_DrawViewModel
_TEXT	SEGMENT
tv130 = -3836						; size = 4
_pweaponmodel$1 = -3384					; size = 4
_saveent$2 = -3380					; size = 3336
_dir$3 = -44						; size = 12
_lighting$4 = -32					; size = 24
_view$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_DrawViewModel PROC					; COMDAT

; 3674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3836				; 00000efcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3675 : 	cl_entity_t	*view = &clgame.viewent;

	mov	DWORD PTR _view$[ebp], OFFSET _clgame+260432

; 3676 : 
; 3677 : 	R_GatherPlayerLight();

	call	_R_GatherPlayerLight

; 3678 : 
; 3679 : 	if( r_drawviewmodel->value == 0 )

	mov	eax, DWORD PTR _r_drawviewmodel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@R_DrawView

; 3680 : 		return;

	jmp	$LN16@R_DrawView
$LN4@R_DrawView:

; 3681 : 
; 3682 : 	if( CL_IsThirdPerson( ))

	call	_CL_IsThirdPerson
	test	eax, eax
	je	SHORT $LN5@R_DrawView

; 3683 : 		return;

	jmp	$LN16@R_DrawView
$LN5@R_DrawView:

; 3684 : 
; 3685 : 	// ignore in thirdperson, camera view or client is died
; 3686 : 	if( !RP_NORMALPASS() || cl.local.health <= 0 || cl.viewentity != ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN7@R_DrawView
	cmp	DWORD PTR _cl+2212656, 0
	jle	SHORT $LN7@R_DrawView
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	je	SHORT $LN6@R_DrawView
$LN7@R_DrawView:

; 3687 : 		return;

	jmp	$LN16@R_DrawView
$LN6@R_DrawView:

; 3688 : 
; 3689 : 	tr.blend = CL_FxBlend( view ) / 255.0f;

	mov	eax, DWORD PTR _view$[ebp]
	push	eax
	call	_CL_FxBlend
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _tr+87592, xmm0

; 3690 : 	if( !R_ModelOpaque( view->curstate.rendermode ) && tr.blend <= 0.0f )

	mov	eax, DWORD PTR _view$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN8@R_DrawView
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _tr+87592
	jb	SHORT $LN8@R_DrawView

; 3691 : 		return; // invisible ?

	jmp	$LN16@R_DrawView
$LN8@R_DrawView:

; 3692 : 
; 3693 : 	RI.currententity = view;

	mov	eax, DWORD PTR _view$[ebp]
	mov	DWORD PTR _RI+28, eax

; 3694 : 
; 3695 : 	if( !RI.currententity->model )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN9@R_DrawView

; 3696 : 		return;

	jmp	$LN16@R_DrawView
$LN9@R_DrawView:

; 3697 : 
; 3698 : 	// adjust the depth range to prevent view model from poking into walls
; 3699 : 	pglDepthRange( gldepthmin, gldepthmin + 0.3f * ( gldepthmax - gldepthmin ));

	movss	xmm0, DWORD PTR _gldepthmax
	subss	xmm0, DWORD PTR _gldepthmin
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR _gldepthmin
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 3700 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 3701 : 
; 3702 : 	// backface culling for left-handed weapons
; 3703 : 	if( R_AllowFlipViewModel( RI.currententity ) || g_iBackFaceCull )

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_AllowFlipViewModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@R_DrawView
	cmp	DWORD PTR _g_iBackFaceCull, 0
	je	SHORT $LN10@R_DrawView
$LN11@R_DrawView:

; 3704 : 	{
; 3705 : 		tr.fFlipViewModel = true;

	mov	DWORD PTR _tr+83216, 1

; 3706 : 		pglFrontFace( GL_CW );

	push	2304					; 00000900H
	call	DWORD PTR _pglFrontFace
$LN10@R_DrawView:

; 3707 : 	}
; 3708 : 
; 3709 : 	switch( RI.currententity->model->type )

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv130[ebp], edx
	cmp	DWORD PTR tv130[ebp], 2
	je	SHORT $LN12@R_DrawView
	cmp	DWORD PTR tv130[ebp], 3
	je	SHORT $LN13@R_DrawView
	jmp	SHORT $LN2@R_DrawView
$LN12@R_DrawView:

; 3710 : 	{
; 3711 : 	case mod_alias:
; 3712 : 		R_DrawAliasModel( RI.currententity );

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_DrawAliasModel
	add	esp, 4

; 3713 : 		break;

	jmp	SHORT $LN2@R_DrawView
$LN13@R_DrawView:

; 3714 : 	case mod_studio:
; 3715 : 		R_StudioSetupTimings();

	call	_R_StudioSetupTimings

; 3716 : 		R_StudioDrawModelInternal( RI.currententity, STUDIO_RENDER );

	push	1
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioDrawModelInternal
	add	esp, 8
$LN2@R_DrawView:

; 3717 : 		break;
; 3718 : 	}
; 3719 : 
; 3720 : 	// restore depth range
; 3721 : 	pglDepthRange( gldepthmin, gldepthmax );

	cvtss2sd xmm0, DWORD PTR _gldepthmax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 3722 : 
; 3723 : 	// backface culling for left-handed weapons
; 3724 : 	if( R_AllowFlipViewModel( RI.currententity ) || g_iBackFaceCull )

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_AllowFlipViewModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@R_DrawView
	cmp	DWORD PTR _g_iBackFaceCull, 0
	je	SHORT $LN14@R_DrawView
$LN15@R_DrawView:

; 3725 : 	{
; 3726 : 		tr.fFlipViewModel = false;

	mov	DWORD PTR _tr+83216, 0

; 3727 : 		pglFrontFace( GL_CCW );

	push	2305					; 00000901H
	call	DWORD PTR _pglFrontFace
$LN14@R_DrawView:

; 3728 : 	}
; 3729 : 
; 3730 : 	// Render arm model only if detected
; 3731 : 	if (RI.currententity->curstate.armmodel)

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1200], 0
	je	$LN16@R_DrawView

; 3732 : 	{
; 3733 : 		RI.currententity->curstate.body = RI.currententity->curstate.armmodelbody;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+1044]
	mov	DWORD PTR [eax+1032], edx

; 3734 : 		RI.currententity->curstate.skin = RI.currententity->curstate.armmodelskin;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+1056]
	mov	DWORD PTR [eax+1048], edx

; 3735 : 
; 3736 : 		alight_t lighting;
; 3737 : 		vec3_t dir;
; 3738 : 		lighting.plightvec = dir;

	lea	eax, DWORD PTR _dir$3[ebp]
	mov	DWORD PTR _lighting$4[ebp+20], eax

; 3739 : 		R_StudioDynamicLight(RI.currententity, &lighting);

	lea	eax, DWORD PTR _lighting$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioDynamicLight
	add	esp, 8

; 3740 : 
; 3741 : 		R_StudioEntityLight(&lighting);

	lea	eax, DWORD PTR _lighting$4[ebp]
	push	eax
	call	_R_StudioEntityLight
	add	esp, 4

; 3742 : 
; 3743 : 		R_StudioSetUpTransform(RI.currententity);

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetUpTransform
	add	esp, 4

; 3744 : 		R_StudioSetupBones(RI.currententity);

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioSetupBones
	add	esp, 4

; 3745 : 		R_StudioSaveBones();

	call	_R_StudioSaveBones

; 3746 : 
; 3747 : 		// hack the depth range to prevent view model from poking into walls
; 3748 : 		pglDepthRange(gldepthmin, gldepthmin + 0.3f * (gldepthmax - gldepthmin));

	movss	xmm0, DWORD PTR _gldepthmax
	subss	xmm0, DWORD PTR _gldepthmin
	mulss	xmm0, DWORD PTR __real@3e99999a
	addss	xmm0, DWORD PTR _gldepthmin
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 3749 : 
; 3750 : 		cl_entity_t	saveent = *RI.currententity;

	mov	ecx, 834				; 00000342H
	mov	esi, DWORD PTR _RI+28
	lea	edi, DWORD PTR _saveent$2[ebp]
	rep movsd

; 3751 : 		model_t* pweaponmodel = CL_ModelHandle(RI.currententity->curstate.armmodel);

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+1200]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pweaponmodel$1[ebp], eax

; 3752 : 
; 3753 : 		if (!pweaponmodel)

	cmp	DWORD PTR _pweaponmodel$1[ebp], 0
	jne	SHORT $LN17@R_DrawView

; 3754 : 			return;

	jmp	$LN16@R_DrawView
$LN17@R_DrawView:

; 3755 : 
; 3756 : 		m_pStudioHeader = (studiohdr_t*)Mod_StudioExtradata(pweaponmodel);

	mov	eax, DWORD PTR _pweaponmodel$1[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _m_pStudioHeader, eax

; 3757 : 		R_StudioMergeBones(RI.currententity, pweaponmodel);

	mov	eax, DWORD PTR _pweaponmodel$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _RI+28
	push	ecx
	call	_R_StudioMergeBones
	add	esp, 8

; 3758 : 
; 3759 : 		// backface culling for left-handed weapons
; 3760 : 		if (R_AllowFlipViewModel(RI.currententity) || g_iBackFaceCull)

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_AllowFlipViewModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@R_DrawView
	cmp	DWORD PTR _g_iBackFaceCull, 0
	je	SHORT $LN18@R_DrawView
$LN19@R_DrawView:

; 3761 : 		{
; 3762 : 			tr.fFlipViewModel = true;

	mov	DWORD PTR _tr+83216, 1

; 3763 : 			pglFrontFace(GL_CW);

	push	2304					; 00000900H
	call	DWORD PTR _pglFrontFace
$LN18@R_DrawView:

; 3764 : 		}
; 3765 : 
; 3766 : 		R_StudioSetupLighting(&lighting);

	lea	eax, DWORD PTR _lighting$4[ebp]
	push	eax
	call	_R_StudioSetupLighting
	add	esp, 4

; 3767 : 		R_StudioRenderModel();

	call	_R_StudioRenderModel

; 3768 : 		R_StudioCalcAttachments();

	call	_R_StudioCalcAttachments

; 3769 : 
; 3770 : 		// restore depth range
; 3771 : 		pglDepthRange(gldepthmin, gldepthmax);

	cvtss2sd xmm0, DWORD PTR _gldepthmax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _gldepthmin
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglDepthRange

; 3772 : 
; 3773 : 		// backface culling for left-handed weapons
; 3774 : 		if (R_AllowFlipViewModel(RI.currententity) || g_iBackFaceCull)

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_AllowFlipViewModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@R_DrawView
	cmp	DWORD PTR _g_iBackFaceCull, 0
	je	SHORT $LN20@R_DrawView
$LN21@R_DrawView:

; 3775 : 		{
; 3776 : 			tr.fFlipViewModel = false;

	mov	DWORD PTR _tr+83216, 0

; 3777 : 			pglFrontFace(GL_CCW);

	push	2305					; 00000901H
	call	DWORD PTR _pglFrontFace
$LN20@R_DrawView:

; 3778 : 		}
; 3779 : 
; 3780 : 		*RI.currententity = saveent;

	mov	ecx, 834				; 00000342H
	lea	esi, DWORD PTR _saveent$2[ebp]
	mov	edi, DWORD PTR _RI+28
	rep movsd
$LN16@R_DrawView:

; 3781 : 	}
; 3782 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawViewModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_RunViewmodelEvents
_TEXT	SEGMENT
_i$ = -4						; size = 4
_R_RunViewmodelEvents PROC				; COMDAT

; 3625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3626 : 	int	i;
; 3627 : 
; 3628 : 	if( r_drawviewmodel->value == 0 )

	mov	eax, DWORD PTR _r_drawviewmodel
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_RunViewm

; 3629 : 		return;

	jmp	$LN1@R_RunViewm
$LN5@R_RunViewm:

; 3630 : 
; 3631 : 	if( CL_IsThirdPerson( ))

	call	_CL_IsThirdPerson
	test	eax, eax
	je	SHORT $LN6@R_RunViewm

; 3632 : 		return;

	jmp	$LN1@R_RunViewm
$LN6@R_RunViewm:

; 3633 : 
; 3634 : 	// ignore in thirdperson, camera view or client is died
; 3635 : 	if( !RP_NORMALPASS() || cl.local.health <= 0 || cl.viewentity != ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN8@R_RunViewm
	cmp	DWORD PTR _cl+2212656, 0
	jle	SHORT $LN8@R_RunViewm
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _cl+2212780, eax
	je	SHORT $LN7@R_RunViewm
$LN8@R_RunViewm:

; 3636 : 		return;

	jmp	$LN1@R_RunViewm
$LN7@R_RunViewm:

; 3637 : 
; 3638 : 	RI.currententity = &clgame.viewent;

	mov	DWORD PTR _RI+28, OFFSET _clgame+260432

; 3639 : 
; 3640 : 	if( !RI.currententity->model || RI.currententity->model->type != mod_studio )

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN10@R_RunViewm
	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN9@R_RunViewm
$LN10@R_RunViewm:

; 3641 : 		return;

	jmp	$LN1@R_RunViewm
$LN9@R_RunViewm:

; 3642 : 
; 3643 : 	R_StudioSetupTimings();

	call	_R_StudioSetupTimings

; 3644 : 
; 3645 : 	for( i = 0; i < 4; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_RunViewm
$LN2@R_RunViewm:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_RunViewm:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$LN3@R_RunViewm

; 3646 : 		VectorCopy( cl.simorg, RI.currententity->attachment[i] );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _RI+28
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _cl[ecx+2212976]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _RI+28
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cl[edx+2212976]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _RI+28
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _cl[eax+2212976]
	mov	DWORD PTR [ecx+edx], eax
	jmp	$LN2@R_RunViewm
$LN3@R_RunViewm:

; 3647 : 	RI.currentmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _RI+32, ecx

; 3648 : 
; 3649 : 	R_StudioDrawModelInternal( RI.currententity, STUDIO_EVENTS );

	push	2
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioDrawModelInternal
	add	esp, 8
$LN1@R_RunViewm:

; 3650 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RunViewmodelEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_GatherPlayerLight
_TEXT	SEGMENT
$T1 = -104						; size = 16
_c$ = -24						; size = 16
_view$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_R_GatherPlayerLight PROC				; COMDAT

; 3658 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3659 : 	cl_entity_t	*view = &clgame.viewent;

	mov	DWORD PTR _view$[ebp], OFFSET _clgame+260432

; 3660 : 	colorVec		c;
; 3661 : 
; 3662 : 	tr.ignore_lightgamma = true;

	mov	DWORD PTR _tr+83204, 1

; 3663 : 	c = R_LightPoint( view->origin );

	mov	eax, DWORD PTR _view$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_R_LightPoint
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _c$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _c$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _c$[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _c$[ebp+12], eax

; 3664 : 	tr.ignore_lightgamma = false;

	mov	DWORD PTR _tr+83204, 0

; 3665 : 	cl.local.light_level = (c.r + c.g + c.b) / 3;

	mov	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _c$[ebp+4]
	add	eax, DWORD PTR _c$[ebp+8]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR _cl+2212732, eax

; 3666 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GatherPlayerLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _pfnPlayerInfo
_TEXT	SEGMENT
_index$ = 8						; size = 4
_pfnPlayerInfo PROC					; COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 361  : 	if( !RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	jne	SHORT $LN2@pfnPlayerI

; 362  : 		return &gameui.playerinfo;

	mov	eax, OFFSET _gameui+3408
	jmp	SHORT $LN1@pfnPlayerI
$LN2@pfnPlayerI:

; 363  : 
; 364  : 	if( index < 0 || index > cl.maxclients )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN4@pfnPlayerI
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jle	SHORT $LN3@pfnPlayerI
$LN4@pfnPlayerI:

; 365  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnPlayerI
$LN3@pfnPlayerI:

; 366  : 	return &cl.players[index];

	imul	eax, DWORD PTR _index$[ebp], 584
	add	eax, OFFSET _cl+2184940
$LN1@pfnPlayerI:

; 367  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlayerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_DrawStudioModel
_TEXT	SEGMENT
_parent$1 = -4						; size = 4
_e$ = 8							; size = 4
_R_DrawStudioModel PROC					; COMDAT

; 3589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3590 : 	if( FBitSet( RI.params, RP_ENVVIEW ))

	mov	eax, DWORD PTR _RI
	and	eax, 2
	je	SHORT $LN2@R_DrawStud

; 3591 : 		return;

	jmp	$LN4@R_DrawStud
$LN2@R_DrawStud:

; 3592 : 
; 3593 : 	R_StudioSetupTimings();

	call	_R_StudioSetupTimings

; 3594 : 
; 3595 : 	if( e->player )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@R_DrawStud

; 3596 : 	{
; 3597 : 		R_StudioDrawModelInternal( e, STUDIO_RENDER|STUDIO_EVENTS );

	push	3
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioDrawModelInternal
	add	esp, 8

; 3598 : 	}

	jmp	$LN4@R_DrawStud
$LN3@R_DrawStud:

; 3599 : 	else
; 3600 : 	{
; 3601 : 		if( e->curstate.movetype == MOVETYPE_FOLLOW && e->curstate.aiment > 0 )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1000], 12		; 0000000cH
	jne	$LN6@R_DrawStud
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1100], 0
	jle	$LN6@R_DrawStud

; 3602 : 		{
; 3603 : 			cl_entity_t *parent = CL_GetEntityByIndex( e->curstate.aiment );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+1100]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _parent$1[ebp], eax

; 3604 : 
; 3605 : 			if( parent && parent->model && parent->model->type == mod_studio )

	cmp	DWORD PTR _parent$1[ebp], 0
	je	$LN6@R_DrawStud
	mov	eax, DWORD PTR _parent$1[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	$LN6@R_DrawStud
	mov	eax, DWORD PTR _parent$1[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN6@R_DrawStud

; 3606 : 			{
; 3607 : 				RI.currententity = parent;

	mov	eax, DWORD PTR _parent$1[ebp]
	mov	DWORD PTR _RI+28, eax

; 3608 : 				R_StudioDrawModelInternal( RI.currententity, 0 );

	push	0
	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_R_StudioDrawModelInternal
	add	esp, 8

; 3609 : 				VectorCopy( parent->curstate.origin, e->curstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+928], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+928], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+928], eax

; 3610 : 				VectorCopy( parent->origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _parent$1[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+3224], eax

; 3611 : 				RI.currententity = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _RI+28, eax
$LN6@R_DrawStud:

; 3612 : 			}
; 3613 : 		}
; 3614 : 
; 3615 : 		R_StudioDrawModelInternal( e, STUDIO_RENDER|STUDIO_EVENTS );

	push	3
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_StudioDrawModelInternal
	add	esp, 8
$LN4@R_DrawStud:

; 3616 : 	}
; 3617 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStudioModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_GetEntityRenderMode
_TEXT	SEGMENT
_phdr$ = -28						; size = 4
_model$ = -24						; size = 4
_oldent$ = -20						; size = 4
_ptexture$ = -16					; size = 4
_trans$ = -12						; size = 4
_opaque$ = -8						; size = 4
_i$ = -4						; size = 4
_ent$ = 8						; size = 4
_R_GetEntityRenderMode PROC				; COMDAT

; 2722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2723 : 	int		i, opaque, trans;
; 2724 : 	mstudiotexture_t	*ptexture;
; 2725 : 	cl_entity_t	*oldent;
; 2726 : 	model_t		*model;
; 2727 : 	studiohdr_t	*phdr;
; 2728 : 
; 2729 : 	oldent = RI.currententity;

	mov	eax, DWORD PTR _RI+28
	mov	DWORD PTR _oldent$[ebp], eax

; 2730 : 	RI.currententity = ent;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR _RI+28, eax

; 2731 : 
; 2732 : 	if( ent->player ) // check it for real playermodel

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@R_GetEntit

; 2733 : 		model = R_StudioSetupPlayerModel( ent->curstate.number - 1 );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	sub	ecx, 1
	push	ecx
	call	_R_StudioSetupPlayerModel
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax
	jmp	SHORT $LN6@R_GetEntit
$LN5@R_GetEntit:

; 2734 : 	else model = ent->model;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _model$[ebp], ecx
$LN6@R_GetEntit:

; 2735 : 
; 2736 : 	RI.currententity = oldent;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	DWORD PTR _RI+28, eax

; 2737 : 
; 2738 : 	if(( phdr = Mod_StudioExtradata( model )) == NULL )

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _phdr$[ebp], eax
	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $LN7@R_GetEntit

; 2739 : 	{
; 2740 : 		if( R_ModelOpaque( ent->curstate.rendermode ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN8@R_GetEntit

; 2741 : 		{
; 2742 : 			// forcing to choose right sorting type
; 2743 : 			if(( model && model->type == mod_brush ) && FBitSet( model->flags, MODEL_TRANSPARENT ))

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN8@R_GetEntit
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $LN8@R_GetEntit
	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 8
	je	SHORT $LN8@R_GetEntit

; 2744 : 				return kRenderTransAlpha;

	mov	eax, 4
	jmp	$LN1@R_GetEntit
$LN8@R_GetEntit:

; 2745 : 		}
; 2746 : 		return ent->curstate.rendermode;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+984]
	jmp	$LN1@R_GetEntit
$LN7@R_GetEntit:

; 2747 : 	}
; 2748 : 	ptexture = (mstudiotexture_t *)((byte *)phdr + phdr->textureindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx

; 2749 : 
; 2750 : 	for( opaque = trans = i = 0; i < phdr->numtextures; i++, ptexture++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _trans$[ebp], eax
	mov	ecx, DWORD PTR _trans$[ebp]
	mov	DWORD PTR _opaque$[ebp], ecx
	jmp	SHORT $LN4@R_GetEntit
$LN2@R_GetEntit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ptexture$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _ptexture$[ebp], ecx
$LN4@R_GetEntit:
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jge	SHORT $LN3@R_GetEntit

; 2751 : 	{
; 2752 : 		// ignore chrome & additive it's just a specular-like effect
; 2753 : 		if( FBitSet( ptexture->flags, STUDIO_NF_ADDITIVE ) && !FBitSet( ptexture->flags, STUDIO_NF_CHROME ))

	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 32					; 00000020H
	je	SHORT $LN10@R_GetEntit
	mov	eax, DWORD PTR _ptexture$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 2
	jne	SHORT $LN10@R_GetEntit

; 2754 : 			trans++;

	mov	eax, DWORD PTR _trans$[ebp]
	add	eax, 1
	mov	DWORD PTR _trans$[ebp], eax
	jmp	SHORT $LN11@R_GetEntit
$LN10@R_GetEntit:

; 2755 : 		else opaque++;

	mov	eax, DWORD PTR _opaque$[ebp]
	add	eax, 1
	mov	DWORD PTR _opaque$[ebp], eax
$LN11@R_GetEntit:

; 2756 : 	}

	jmp	SHORT $LN2@R_GetEntit
$LN3@R_GetEntit:

; 2757 : 
; 2758 : 	// if model is more additive than opaque
; 2759 : 	if( trans > opaque )

	mov	eax, DWORD PTR _trans$[ebp]
	cmp	eax, DWORD PTR _opaque$[ebp]
	jle	SHORT $LN12@R_GetEntit

; 2760 : 		return kRenderTransAdd;

	mov	eax, 5
	jmp	SHORT $LN1@R_GetEntit
$LN12@R_GetEntit:

; 2761 : 	return ent->curstate.rendermode;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [eax+984]
$LN1@R_GetEntit:

; 2762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetEntityRenderMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _CL_GetStudioEstimatedFrame
_TEXT	SEGMENT
tv83 = -84						; size = 4
tv82 = -80						; size = 4
_sequence$ = -12					; size = 4
_pseqdesc$ = -8						; size = 4
_pstudiohdr$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_GetStudioEstimatedFrame PROC			; COMDAT

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 674  : 	studiohdr_t	*pstudiohdr;
; 675  : 	mstudioseqdesc_t	*pseqdesc;
; 676  : 	int		sequence;
; 677  : 
; 678  : 	if( ent->model != NULL && ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	$LN3@CL_GetStud
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN3@CL_GetStud

; 679  : 	{
; 680  : 		pstudiohdr = (studiohdr_t *)Mod_StudioExtradata( ent->model );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudiohdr$[ebp], eax

; 681  : 
; 682  : 		if( pstudiohdr )

	cmp	DWORD PTR _pstudiohdr$[ebp], 0
	je	SHORT $LN3@CL_GetStud

; 683  : 		{
; 684  : 			sequence = bound( 0, ent->curstate.sequence, pstudiohdr->numseq - 1 );

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+956], 0
	jl	SHORT $LN7@CL_GetStud
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	sub	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+956], edx
	jge	SHORT $LN5@CL_GetStud
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN6@CL_GetStud
$LN5@CL_GetStud:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	sub	ecx, 1
	mov	DWORD PTR tv82[ebp], ecx
$LN6@CL_GetStud:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN8@CL_GetStud
$LN7@CL_GetStud:
	mov	DWORD PTR tv83[ebp], 0
$LN8@CL_GetStud:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _sequence$[ebp], eax

; 685  : 			pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + sequence;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _sequence$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 686  : 			return R_StudioEstimateFrame( ent, pseqdesc );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_R_StudioEstimateFrame
	add	esp, 8
	jmp	SHORT $LN1@CL_GetStud
$LN3@CL_GetStud:

; 687  : 		}
; 688  : 	}
; 689  : 
; 690  : 	return 0;

	fldz
$LN1@CL_GetStud:

; 691  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetStudioEstimatedFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioGetTexture
_TEXT	SEGMENT
_thdr$ = -12						; size = 4
_phdr$ = -8						; size = 4
_ptexture$ = -4						; size = 4
_e$ = 8							; size = 4
_R_StudioGetTexture PROC				; COMDAT

; 2068 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2069 : 	mstudiotexture_t	*ptexture;
; 2070 : 	studiohdr_t	*phdr, *thdr;
; 2071 : 
; 2072 : 	if(( phdr = Mod_StudioExtradata( e->model )) == NULL )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _phdr$[ebp], eax
	cmp	DWORD PTR _phdr$[ebp], 0
	jne	SHORT $LN2@R_StudioGe

; 2073 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@R_StudioGe
$LN2@R_StudioGe:

; 2074 : 
; 2075 : 	thdr = m_pStudioHeader;

	mov	eax, DWORD PTR _m_pStudioHeader
	mov	DWORD PTR _thdr$[ebp], eax

; 2076 : 	if( !thdr ) return NULL;	

	cmp	DWORD PTR _thdr$[ebp], 0
	jne	SHORT $LN3@R_StudioGe
	xor	eax, eax
	jmp	SHORT $LN1@R_StudioGe
$LN3@R_StudioGe:

; 2077 : 
; 2078 : 	if( m_fDoRemap ) ptexture = CL_GetRemapInfoForEntity( e )->ptexture;

	cmp	DWORD PTR _m_fDoRemap, 0
	je	SHORT $LN4@R_StudioGe
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_CL_GetRemapInfoForEntity
	add	esp, 4
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _ptexture$[ebp], ecx
	jmp	SHORT $LN5@R_StudioGe
$LN4@R_StudioGe:

; 2079 : 	else ptexture = (mstudiotexture_t *)((byte *)thdr + thdr->textureindex);

	mov	eax, DWORD PTR _thdr$[ebp]
	mov	ecx, DWORD PTR _thdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx
$LN5@R_StudioGe:

; 2080 : 
; 2081 : 	return ptexture;

	mov	eax, DWORD PTR _ptexture$[ebp]
$LN1@R_StudioGe:

; 2082 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioGetTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _CL_GetSequenceDuration
_TEXT	SEGMENT
tv80 = -80						; size = 4
tv147 = -76						; size = 4
tv79 = -76						; size = 4
_pseqdesc$ = -8						; size = 4
_pstudiohdr$ = -4					; size = 4
_ent$ = 8						; size = 4
_sequence$ = 12						; size = 4
_CL_GetSequenceDuration PROC				; COMDAT

; 700  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 701  : 	studiohdr_t	*pstudiohdr;
; 702  : 	mstudioseqdesc_t	*pseqdesc;
; 703  : 
; 704  : 	if( ent->model != NULL && ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	$LN4@CL_GetSequ
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN4@CL_GetSequ

; 705  : 	{
; 706  : 		pstudiohdr = (studiohdr_t *)Mod_StudioExtradata( ent->model );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	call	_Mod_StudioExtradata
	add	esp, 4
	mov	DWORD PTR _pstudiohdr$[ebp], eax

; 707  : 
; 708  : 		if( pstudiohdr )

	cmp	DWORD PTR _pstudiohdr$[ebp], 0
	je	$LN4@CL_GetSequ

; 709  : 		{
; 710  : 			sequence = bound( 0, sequence, pstudiohdr->numseq - 1 );

	cmp	DWORD PTR _sequence$[ebp], 0
	jl	SHORT $LN8@CL_GetSequ
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	sub	ecx, 1
	cmp	DWORD PTR _sequence$[ebp], ecx
	jge	SHORT $LN6@CL_GetSequ
	mov	edx, DWORD PTR _sequence$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN7@CL_GetSequ
$LN6@CL_GetSequ:
	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	sub	ecx, 1
	mov	DWORD PTR tv79[ebp], ecx
$LN7@CL_GetSequ:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN9@CL_GetSequ
$LN8@CL_GetSequ:
	mov	DWORD PTR tv80[ebp], 0
$LN9@CL_GetSequ:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR _sequence$[ebp], eax

; 711  : 			pseqdesc = (mstudioseqdesc_t *)((byte *)pstudiohdr + pstudiohdr->seqindex) + sequence;

	mov	eax, DWORD PTR _pstudiohdr$[ebp]
	mov	ecx, DWORD PTR _pstudiohdr$[ebp]
	add	ecx, DWORD PTR [eax+168]
	imul	edx, DWORD PTR _sequence$[ebp], 176
	add	ecx, edx
	mov	DWORD PTR _pseqdesc$[ebp], ecx

; 712  : 
; 713  : 			if( pseqdesc->numframes > 1 && pseqdesc->fps > 0 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jle	SHORT $LN4@CL_GetSequ
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@CL_GetSequ

; 714  : 				return (float)pseqdesc->numframes / (float)pseqdesc->fps;

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+56]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	divss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR tv147[ebp], xmm0
	fld	DWORD PTR tv147[ebp]
	jmp	SHORT $LN1@CL_GetSequ
$LN4@CL_GetSequ:

; 715  : 		}
; 716  : 	}
; 717  : 
; 718  : 	return 0.1f;

	fld	DWORD PTR __real@3dcccccd
$LN1@CL_GetSequ:

; 719  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetSequenceDuration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioLerpMovement
_TEXT	SEGMENT
tv159 = -124						; size = 4
_q2$1 = -56						; size = 16
_q1$2 = -40						; size = 16
_q$3 = -24						; size = 16
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_time$ = 12						; size = 8
_origin$ = 20						; size = 4
_angles$ = 24						; size = 4
_R_StudioLerpMovement PROC				; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 552  : 	float	f = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _f$[ebp], xmm0

; 553  : 
; 554  : 	// don't do it if the goalstarttime hasn't updated in a while.
; 555  : 	// NOTE: Because we need to interpolate multiplayer characters, the interpolation time limit
; 556  : 	// was increased to 1.0 s., which is 2x the max lag we are accounting for.
; 557  : 	if( g_studio.interpolate && ( time < e->curstate.animtime + 1.0f ) && ( e->curstate.animtime != e->latched.prevanimtime ))

	cmp	DWORD PTR _g_studio+20, 0
	je	SHORT $LN2@R_StudioLe
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	addss	xmm0, DWORD PTR __real@3f800000
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _time$[ebp]
	jbe	SHORT $LN2@R_StudioLe
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	ucomiss	xmm0, DWORD PTR [ecx+3168]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@R_StudioLe

; 558  : 		f = ( time - e->curstate.animtime ) / ( e->curstate.animtime - e->latched.prevanimtime );

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	movsd	xmm1, QWORD PTR _time$[ebp]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+1004]
	subss	xmm0, DWORD PTR [edx+3168]
	cvtss2sd xmm0, xmm0
	divsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _f$[ebp], xmm0
$LN2@R_StudioLe:

; 559  : 
; 560  : 	// Con_Printf( "%4.2f %.2f %.2f\n", f, e->curstate.animtime, g_studio.time );
; 561  : 	VectorLerp( e->latched.prevorigin, f, e->curstate.origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+edx+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+3180]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+928]
	subss	xmm0, DWORD PTR [edi+eax+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+3180]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+ecx+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+3180]
	addss	xmm1, xmm0
	movss	DWORD PTR tv159[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 562  : 
; 563  : 	if( !VectorCompareEpsilon( e->curstate.angles, e->latched.prevangles, ON_EPSILON ))

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3192				; 00000c78H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_VectorCompareEpsilon
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@R_StudioLe

; 564  : 	{
; 565  : 		vec4_t	q, q1, q2;
; 566  : 
; 567  : 		AngleQuaternion( e->curstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 568  : 		AngleQuaternion( e->latched.prevangles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 3192				; 00000c78H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 569  : 		QuaternionSlerp( q2, q1, f, q );

	lea	eax, DWORD PTR _q$3[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$1[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 570  : 		QuaternionAngle( q, angles );

	mov	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$3[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 571  : 	}

	jmp	SHORT $LN4@R_StudioLe
$LN3@R_StudioLe:

; 572  : 	else VectorCopy( e->curstate.angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx], eax
$LN4@R_StudioLe:

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioLerpMovement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioInit
_TEXT	SEGMENT
_R_StudioInit PROC					; COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 135  : 	cl_himodels = Cvar_Get( "cl_himodels", "1", FCVAR_ARCHIVE, "draw high-resolution player models in multiplayer" );

	push	OFFSET ??_C@_0DC@IAMPGLIE@draw?5high?9resolution?5player?5mod@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0M@NHHOJIBJ@cl_himodels@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cl_himodels, eax

; 136  : 	r_studio_sort_textures = Cvar_Get( "r_studio_sort_textures", "0", FCVAR_ARCHIVE, "change draw order for additive meshes" );

	push	OFFSET ??_C@_0CG@OFCMNBJG@change?5draw?5order?5for?5additive?5@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BH@GPOHDMMN@r_studio_sort_textures@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_studio_sort_textures, eax

; 137  : 	r_drawviewmodel = Cvar_Get( "r_drawviewmodel", "1", 0, "draw firstperson weapon model" );

	push	OFFSET ??_C@_0BO@JEINLOM@draw?5firstperson?5weapon?5model@
	push	0
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BA@JMOPJIOD@r_drawviewmodel@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_drawviewmodel, eax

; 138  : 
; 139  : 	Matrix3x4_LoadIdentity( g_studio.rotationmatrix );

	push	48					; 00000030H
	push	OFFSET _matrix3x4_identity
	push	OFFSET _g_studio+32
	call	_memcpy
	add	esp, 12					; 0000000cH

; 140  : 	Cvar_RegisterVariable( &r_glowshellfreq );

	push	OFFSET _r_glowshellfreq
	call	_Cvar_RegisterVariable
	add	esp, 4

; 141  : 
; 142  : 	// g-cont. cvar disabled by Valve
; 143  : //	Cvar_RegisterVariable( &r_shadows );
; 144  : 
; 145  : 	g_studio.interpolate = true;

	mov	DWORD PTR _g_studio+20, 1

; 146  : 	g_studio.framecount = 0;

	mov	DWORD PTR _g_studio+16, 0

; 147  : 	m_fDoRemap = false;

	mov	DWORD PTR _m_fDoRemap, 0

; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSetRemapColors
_TEXT	SEGMENT
_newTop$ = 8						; size = 4
_newBottom$ = 12					; size = 4
_R_StudioSetRemapColors PROC				; COMDAT

; 2651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2652 : 	CL_AllocRemapInfo( newTop, newBottom );

	mov	eax, DWORD PTR _newBottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newTop$[ebp]
	push	ecx
	call	_CL_AllocRemapInfo
	add	esp, 8

; 2653 : 
; 2654 : 	if( CL_GetRemapInfoForEntity( RI.currententity ))

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_CL_GetRemapInfoForEntity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@R_StudioSe

; 2655 : 	{
; 2656 : 		CL_UpdateRemapInfo( newTop, newBottom );

	mov	eax, DWORD PTR _newBottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newTop$[ebp]
	push	ecx
	call	_CL_UpdateRemapInfo
	add	esp, 8

; 2657 : 		m_fDoRemap = true;

	mov	DWORD PTR _m_fDoRemap, 1
$LN1@R_StudioSe:

; 2658 : 	}
; 2659 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSetRemapColors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _CL_InitStudioAPI
_TEXT	SEGMENT
_CL_InitStudioAPI PROC					; COMDAT

; 3989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3990 : 	pStudioDraw = &gStudioDraw;

	mov	DWORD PTR _pStudioDraw, OFFSET _gStudioDraw

; 3991 : 
; 3992 : 	// Xash will be used internal StudioModelRenderer
; 3993 : 	if( !clgame.dllFuncs.pfnGetStudioModelInterface )

	cmp	DWORD PTR _clgame+160, 0
	jne	SHORT $LN2@CL_InitStu

; 3994 : 		return;

	jmp	SHORT $LN1@CL_InitStu
$LN2@CL_InitStu:

; 3995 : 
; 3996 : 	if( clgame.dllFuncs.pfnGetStudioModelInterface( STUDIO_INTERFACE_VERSION, &pStudioDraw, &gStudioAPI ))

	push	OFFSET _gStudioAPI
	push	OFFSET _pStudioDraw
	push	1
	call	DWORD PTR _clgame+160
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@CL_InitStu

; 3997 : 		return;

	jmp	SHORT $LN1@CL_InitStu
$LN3@CL_InitStu:

; 3998 : 
; 3999 : 	// NOTE: we always return true even if game interface was not correct
; 4000 : 	// because we need Draw our StudioModels
; 4001 : 	// just restore pointer to builtin function
; 4002 : 	pStudioDraw = &gStudioDraw;

	mov	DWORD PTR _pStudioDraw, OFFSET _gStudioDraw
$LN1@CL_InitStu:

; 4003 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitStudioAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _Mod_StudioUnloadTextures
_TEXT	SEGMENT
_i$ = -12						; size = 4
_ptexture$ = -8						; size = 4
_phdr$ = -4						; size = 4
_data$ = 8						; size = 4
_Mod_StudioUnloadTextures PROC				; COMDAT

; 3905 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3906 : 	studiohdr_t	*phdr = (studiohdr_t *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _phdr$[ebp], eax

; 3907 : 	mstudiotexture_t	*ptexture;
; 3908 : 	int		i;
; 3909 : 
; 3910 : 	if( !phdr || host.type == HOST_DEDICATED )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $LN6@Mod_Studio
	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@Mod_Studio
$LN6@Mod_Studio:

; 3911 : 		return;

	jmp	SHORT $LN1@Mod_Studio
$LN5@Mod_Studio:

; 3912 : 
; 3913 : 	ptexture = (mstudiotexture_t *)(((byte *)phdr) + phdr->textureindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx

; 3914 : 
; 3915 : 	// release all textures
; 3916 : 	for( i = 0; i < phdr->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jge	SHORT $LN1@Mod_Studio

; 3917 : 	{
; 3918 : 		if( ptexture[i].index == tr.defaultTexture )

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+eax+76]
	cmp	edx, DWORD PTR _tr
	jne	SHORT $LN7@Mod_Studio

; 3919 : 			continue;

	jmp	SHORT $LN2@Mod_Studio
$LN7@Mod_Studio:

; 3920 : 		GL_FreeTexture( ptexture[i].index );

	imul	eax, DWORD PTR _i$[ebp], 80
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+eax+76]
	push	edx
	call	_GL_FreeTexture
	add	esp, 4

; 3921 : 	}

	jmp	SHORT $LN2@Mod_Studio
$LN1@Mod_Studio:

; 3922 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioUnloadTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _Mod_StudioLoadTextures
_TEXT	SEGMENT
_i$ = -12						; size = 4
_ptexture$ = -8						; size = 4
_phdr$ = -4						; size = 4
_mod$ = 8						; size = 4
_data$ = 12						; size = 4
_Mod_StudioLoadTextures PROC				; COMDAT

; 3883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3884 : 	studiohdr_t	*phdr = (studiohdr_t *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _phdr$[ebp], eax

; 3885 : 	mstudiotexture_t	*ptexture;
; 3886 : 	int		i;
; 3887 : 
; 3888 : 	if( !phdr || host.type == HOST_DEDICATED )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $LN6@Mod_Studio
	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN5@Mod_Studio
$LN6@Mod_Studio:

; 3889 : 		return;

	jmp	SHORT $LN1@Mod_Studio
$LN5@Mod_Studio:

; 3890 : 
; 3891 : 	ptexture = (mstudiotexture_t *)(((byte *)phdr) + phdr->textureindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _ptexture$[ebp], ecx

; 3892 : 	if( phdr->textureindex > 0 && phdr->numtextures <= MAXSTUDIOSKINS )

	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jle	SHORT $LN1@Mod_Studio
	mov	eax, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [eax+180], 256		; 00000100H
	jg	SHORT $LN1@Mod_Studio

; 3893 : 	{
; 3894 : 		for( i = 0; i < phdr->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Studio
$LN2@Mod_Studio:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Studio:
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+180]
	jge	SHORT $LN1@Mod_Studio

; 3895 : 			R_StudioLoadTexture( mod, phdr, &ptexture[i] );

	imul	eax, DWORD PTR _i$[ebp], 80
	add	eax, DWORD PTR _ptexture$[ebp]
	push	eax
	mov	ecx, DWORD PTR _phdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	push	edx
	call	_R_StudioLoadTexture
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Mod_Studio
$LN1@Mod_Studio:

; 3896 : 	}
; 3897 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_StudioLoadTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioGetAnim
_TEXT	SEGMENT
_modelpath$1 = -788					; size = 256
_modelname$2 = -532					; size = 256
_filepath$3 = -276					; size = 256
_buf$ = -20						; size = 4
_filesize$ = -16					; size = 4
_paSequences$ = -12					; size = 4
_pseqgroup$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_m_pStudioHeader$ = 8					; size = 4
_m_pSubModel$ = 12					; size = 4
_pseqdesc$ = 16						; size = 4
_R_StudioGetAnim PROC					; COMDAT

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 916				; 00000394H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 729  : 	mstudioseqgroup_t	*pseqgroup;
; 730  : 	cache_user_t	*paSequences;
; 731  : 	size_t		filesize;
; 732  :           byte		*buf;
; 733  : 
; 734  : 	pseqgroup = (mstudioseqgroup_t *)((byte *)m_pStudioHeader + m_pStudioHeader->seqgroupindex) + pseqdesc->seqgroup;

	mov	eax, DWORD PTR _m_pStudioHeader$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader$[ebp]
	add	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	imul	eax, DWORD PTR [edx+156], 104
	add	ecx, eax
	mov	DWORD PTR _pseqgroup$[ebp], ecx

; 735  : 	if( pseqdesc->seqgroup == 0 )

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jne	SHORT $LN2@R_StudioGe

; 736  : 		return ((byte *)m_pStudioHeader + pseqgroup->data + pseqdesc->animindex);

	mov	eax, DWORD PTR _pseqgroup$[ebp]
	mov	ecx, DWORD PTR _m_pStudioHeader$[ebp]
	add	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	ecx, DWORD PTR [edx+124]
	mov	eax, ecx
	jmp	$LN1@R_StudioGe
$LN2@R_StudioGe:

; 737  : 
; 738  : 	paSequences = (cache_user_t *)m_pSubModel->submodels;

	mov	eax, DWORD PTR _m_pSubModel$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _paSequences$[ebp], ecx

; 739  : 
; 740  : 	if( paSequences == NULL )

	cmp	DWORD PTR _paSequences$[ebp], 0
	jne	SHORT $LN3@R_StudioGe

; 741  : 	{
; 742  : 		paSequences = (cache_user_t *)Mem_Calloc( com_studiocache, MAXSTUDIOGROUPS * sizeof( cache_user_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioGetAnim@@9@9
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	64					; 00000040H
	mov	ecx, DWORD PTR _com_studiocache
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _paSequences$[ebp], eax

; 743  : 		m_pSubModel->submodels = (void *)paSequences;

	mov	eax, DWORD PTR _m_pSubModel$[ebp]
	mov	ecx, DWORD PTR _paSequences$[ebp]
	mov	DWORD PTR [eax+124], ecx
$LN3@R_StudioGe:

; 744  : 	}
; 745  : 
; 746  : 	// check for already loaded
; 747  : 	if( !Mod_CacheCheck(( cache_user_t *)&( paSequences[pseqdesc->seqgroup] )))

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _paSequences$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_Mod_CacheCheck
	add	esp, 4
	test	eax, eax
	jne	$LN4@R_StudioGe

; 748  : 	{
; 749  : 		string	filepath, modelname, modelpath;
; 750  : 
; 751  : 		COM_FileBase( m_pSubModel->name, modelname );

	lea	eax, DWORD PTR _modelname$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 752  : 		COM_ExtractFilePath( m_pSubModel->name, modelpath );

	lea	eax, DWORD PTR _modelpath$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSubModel$[ebp]
	push	ecx
	call	_COM_ExtractFilePath
	add	esp, 8

; 753  : 
; 754  : 		// NOTE: here we build real sub-animation filename because stupid user may rename model without recompile
; 755  : 		Q_snprintf( filepath, sizeof( filepath ), "%s/%s%i%i.mdl", modelpath, modelname, pseqdesc->seqgroup / 10, pseqdesc->seqgroup % 10 );

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [eax+156]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	edx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	push	eax
	lea	edx, DWORD PTR _modelname$2[ebp]
	push	edx
	lea	eax, DWORD PTR _modelpath$1[ebp]
	push	eax
	push	OFFSET ??_C@_0O@GEDKBEHJ@?$CFs?1?$CFs?$CFi?$CFi?4mdl@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _filepath$3[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 756  : 
; 757  : 		buf = FS_LoadFile( filepath, &filesize, false );

	push	0
	lea	eax, DWORD PTR _filesize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filepath$3[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax

; 758  : 		if( !buf || !filesize ) Host_Error( "StudioGetAnim: can't load %s\n", filepath );

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN6@R_StudioGe
	cmp	DWORD PTR _filesize$[ebp], 0
	jne	SHORT $LN5@R_StudioGe
$LN6@R_StudioGe:
	lea	eax, DWORD PTR _filepath$3[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HKBJCNDJ@StudioGetAnim?3?5can?8t?5load?5?$CFs?6@
	call	_Host_Error
	add	esp, 8
$LN5@R_StudioGe:

; 759  : 		if( IDSEQGRPHEADER != *(uint *)buf ) Host_Error( "StudioGetAnim: %s is corrupted\n", filepath );

	mov	eax, DWORD PTR _buf$[ebp]
	cmp	DWORD PTR [eax], 1364411465		; 51534449H
	je	SHORT $LN7@R_StudioGe
	lea	eax, DWORD PTR _filepath$3[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@PFOMPIEP@StudioGetAnim?3?5?$CFs?5is?5corrupted?6@
	call	_Host_Error
	add	esp, 8
$LN7@R_StudioGe:

; 760  : 
; 761  : 		Con_Printf( "loading: %s\n", filepath );

	lea	eax, DWORD PTR _filepath$3[ebp]
	push	eax
	push	OFFSET ??_C@_0N@FDHGFJAO@loading?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 762  : 			
; 763  : 		paSequences[pseqdesc->seqgroup].data = Mem_Calloc( com_studiocache, filesize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioGetAnim@@9@9
	add	eax, 35					; 00000023H
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _com_studiocache
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _paSequences$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 764  : 		memcpy( paSequences[pseqdesc->seqgroup].data, buf, filesize );

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _paSequences$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 765  : 		Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_StudioGetAnim@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DG@ONCFFIAJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN4@R_StudioGe:

; 766  : 	}
; 767  : 
; 768  : 	return ((byte *)paSequences[pseqdesc->seqgroup].data + pseqdesc->animindex);

	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _paSequences$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [ecx+124]
$LN1@R_StudioGe:

; 769  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioGetAnim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCalcBonePosition
_TEXT	SEGMENT
tv306 = -108						; size = 4
_panimvalue$1 = -40					; size = 4
_k$ = -36						; size = 4
_j$ = -32						; size = 4
_origin2$ = -28						; size = 12
_origin1$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_s$ = 12						; size = 4
_pbone$ = 16						; size = 4
_panim$ = 20						; size = 4
_adj$ = 24						; size = 4
_pos$ = 28						; size = 4
_R_StudioCalcBonePosition PROC				; COMDAT

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 976  : 	vec3_t	origin1;
; 977  : 	vec3_t	origin2;
; 978  : 	int	j, k;
; 979  : 
; 980  : 	for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@R_StudioCa
$LN2@R_StudioCa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@R_StudioCa:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN3@R_StudioCa

; 981  : 	{
; 982  : 		if( !panim || panim->offset[j] == 0 )

	cmp	DWORD PTR _panim$[ebp], 0
	je	SHORT $LN9@R_StudioCa
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jne	SHORT $LN7@R_StudioCa
$LN9@R_StudioCa:

; 983  : 		{
; 984  : 			origin2[j] = origin1[j] = pbone->value[j]; // default;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+64]
	mov	DWORD PTR _origin1$[ebp+eax*4], ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _origin1$[ebp+eax*4]
	mov	DWORD PTR _origin2$[ebp+edx*4], ecx

; 985  : 		}

	jmp	$LN8@R_StudioCa
$LN7@R_StudioCa:

; 986  : 		else
; 987  : 		{
; 988  : 			mstudioanimvalue_t	*panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	add	edx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panimvalue$1[ebp], edx

; 989  : 
; 990  : 			k = frame;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 991  : 
; 992  : 			// debug
; 993  : 			if( panimvalue->num.total < panimvalue->num.valid )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN10@R_StudioCa

; 994  : 				k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN10@R_StudioCa:

; 995  : 
; 996  : 			// find span of values that includes the frame we want
; 997  : 			while( panimvalue->num.total <= k )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, DWORD PTR _k$[ebp]
	jg	SHORT $LN6@R_StudioCa

; 998  : 			{
; 999  : 				k -= panimvalue->num.total;

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _k$[ebp], edx

; 1000 : 				panimvalue += panimvalue->num.valid + 1;

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+2]
	mov	DWORD PTR _panimvalue$1[ebp], eax

; 1001 : 
; 1002 :   				// debug
; 1003 : 				if( panimvalue->num.total < panimvalue->num.valid )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN11@R_StudioCa

; 1004 : 					k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN11@R_StudioCa:

; 1005 : 			}

	jmp	SHORT $LN10@R_StudioCa
$LN6@R_StudioCa:

; 1006 : 
; 1007 : 			// bah, missing blend!
; 1008 : 			if( panimvalue->num.valid > k )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _k$[ebp]
	jle	$LN12@R_StudioCa

; 1009 : 			{
; 1010 : 				origin1[j] = panimvalue[k+1].value;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _panimvalue$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+2]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin1$[ebp+eax*4], xmm0

; 1011 : 
; 1012 : 				if( panimvalue->num.valid > k + 1 )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN14@R_StudioCa

; 1013 : 				{
; 1014 : 					origin2[j] = panimvalue[k+2].value;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _panimvalue$1[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin2$[ebp+eax*4], xmm0

; 1015 : 				}

	jmp	SHORT $LN17@R_StudioCa
$LN14@R_StudioCa:

; 1016 : 				else
; 1017 : 				{
; 1018 : 					if( panimvalue->num.total > k + 1 )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN16@R_StudioCa

; 1019 : 						origin2[j] = origin1[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _origin1$[ebp+ecx*4]
	mov	DWORD PTR _origin2$[ebp+eax*4], edx
	jmp	SHORT $LN17@R_StudioCa
$LN16@R_StudioCa:

; 1020 : 					else origin2[j] = panimvalue[panimvalue->num.valid+2].value;

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin2$[ebp+ecx*4], xmm0
$LN17@R_StudioCa:

; 1021 : 				}
; 1022 : 			}

	jmp	SHORT $LN19@R_StudioCa
$LN12@R_StudioCa:

; 1023 : 			else
; 1024 : 			{
; 1025 : 				origin1[j] = panimvalue[panimvalue->num.valid].value;

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin1$[ebp+ecx*4], xmm0

; 1026 : 				if( panimvalue->num.total > k + 1 )

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN18@R_StudioCa

; 1027 : 					origin2[j] = origin1[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _origin1$[ebp+ecx*4]
	mov	DWORD PTR _origin2$[ebp+eax*4], edx
	jmp	SHORT $LN19@R_StudioCa
$LN18@R_StudioCa:

; 1028 : 				else origin2[j] = panimvalue[panimvalue->num.valid+2].value;

	mov	eax, DWORD PTR _panimvalue$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$1[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin2$[ebp+ecx*4], xmm0
$LN19@R_StudioCa:

; 1029 : 			}
; 1030 : 
; 1031 : 			origin1[j] = pbone->value[j] + origin1[j] * pbone->scale[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	movss	xmm0, DWORD PTR _origin1$[ebp+eax*4]
	mulss	xmm0, DWORD PTR [edx+ecx*4+88]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4+64]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin1$[ebp+edx*4], xmm0

; 1032 : 			origin2[j] = pbone->value[j] + origin2[j] * pbone->scale[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	movss	xmm0, DWORD PTR _origin2$[ebp+eax*4]
	mulss	xmm0, DWORD PTR [edx+ecx*4+88]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4+64]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin2$[ebp+edx*4], xmm0
$LN8@R_StudioCa:

; 1033 : 		}
; 1034 : 
; 1035 : 		if( pbone->bonecontroller[j] != -1 && adj != NULL )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	cmp	DWORD PTR [ecx+eax*4+40], -1
	je	SHORT $LN20@R_StudioCa
	cmp	DWORD PTR _adj$[ebp], 0
	je	SHORT $LN20@R_StudioCa

; 1036 : 		{
; 1037 : 			origin1[j] += adj[pbone->bonecontroller[j]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _origin1$[ebp+eax*4]
	addss	xmm0, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin1$[ebp+edx*4], xmm0

; 1038 : 			origin2[j] += adj[pbone->bonecontroller[j]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+40]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _origin2$[ebp+eax*4]
	addss	xmm0, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _origin2$[ebp+edx*4], xmm0
$LN20@R_StudioCa:

; 1039 : 		}
; 1040 : 	}

	jmp	$LN2@R_StudioCa
$LN3@R_StudioCa:

; 1041 : 
; 1042 : 	if( !VectorCompare( origin1, origin2 ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _origin1$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR _origin2$[ebp+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_StudioCa
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _origin1$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _origin2$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_StudioCa
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _origin1$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _origin2$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN21@R_StudioCa
$LN23@R_StudioCa:

; 1043 : 	{
; 1044 : 		VectorLerp( origin1, s, origin2, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR _origin2$[ebp+eax]
	subss	xmm0, DWORD PTR _origin1$[ebp+edx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR _origin1$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _origin2$[ebp+ecx]
	subss	xmm0, DWORD PTR _origin1$[ebp+edx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR _origin1$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _origin2$[ebp+eax]
	subss	xmm0, DWORD PTR _origin1$[ebp+ecx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	movss	xmm1, DWORD PTR _origin1$[ebp+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv306[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR tv306[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 1045 : 	}

	jmp	SHORT $LN22@R_StudioCa
$LN21@R_StudioCa:

; 1046 : 	else
; 1047 : 	{
; 1048 : 		VectorCopy( origin1, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _origin1$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _origin1$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR _origin1$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
$LN22@R_StudioCa:

; 1049 : 	}
; 1050 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioCalcBonePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioCalcBoneQuaternion
_TEXT	SEGMENT
_q2$1 = -72						; size = 16
_q1$2 = -56						; size = 16
_panimvalue$3 = -40					; size = 4
_k$ = -36						; size = 4
_j$ = -32						; size = 4
_angles2$ = -28						; size = 12
_angles1$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_frame$ = 8						; size = 4
_s$ = 12						; size = 4
_pbone$ = 16						; size = 4
_panim$ = 20						; size = 4
_adj$ = 24						; size = 4
_q$ = 28						; size = 4
_R_StudioCalcBoneQuaternion PROC			; COMDAT

; 887  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 888  : 	vec3_t	angles1;
; 889  : 	vec3_t	angles2;
; 890  : 	int	j, k;
; 891  : 
; 892  : 	for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@R_StudioCa
$LN2@R_StudioCa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@R_StudioCa:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN3@R_StudioCa

; 893  : 	{
; 894  : 		if( !panim || panim->offset[j+3] == 0 )

	cmp	DWORD PTR _panim$[ebp], 0
	je	SHORT $LN9@R_StudioCa
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+6]
	test	edx, edx
	jne	SHORT $LN7@R_StudioCa
$LN9@R_StudioCa:

; 895  : 		{
; 896  : 			angles2[j] = angles1[j] = pbone->value[j+3]; // default;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+76]
	mov	DWORD PTR _angles1$[ebp+eax*4], ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _angles1$[ebp+eax*4]
	mov	DWORD PTR _angles2$[ebp+edx*4], ecx

; 897  : 		}

	jmp	$LN8@R_StudioCa
$LN7@R_StudioCa:

; 898  : 		else
; 899  : 		{
; 900  : 			mstudioanimvalue_t *panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j+3]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+6]
	add	edx, DWORD PTR _panim$[ebp]
	mov	DWORD PTR _panimvalue$3[ebp], edx

; 901  : 
; 902  : 			k = frame;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 903  : 			
; 904  : 			// debug
; 905  : 			if( panimvalue->num.total < panimvalue->num.valid )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN10@R_StudioCa

; 906  : 				k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN10@R_StudioCa:

; 907  : 
; 908  : 			// find span of values that includes the frame we want			
; 909  : 			while( panimvalue->num.total <= k )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, DWORD PTR _k$[ebp]
	jg	SHORT $LN6@R_StudioCa

; 910  : 			{
; 911  : 				k -= panimvalue->num.total;

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _k$[ebp], edx

; 912  : 				panimvalue += panimvalue->num.valid + 1;

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+2]
	mov	DWORD PTR _panimvalue$3[ebp], eax

; 913  : 
; 914  : 				// debug
; 915  : 				if( panimvalue->num.total < panimvalue->num.valid )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN11@R_StudioCa

; 916  : 					k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN11@R_StudioCa:

; 917  : 			}

	jmp	SHORT $LN10@R_StudioCa
$LN6@R_StudioCa:

; 918  : 
; 919  : 			// bah, missing blend!
; 920  : 			if( panimvalue->num.valid > k )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _k$[ebp]
	jle	$LN12@R_StudioCa

; 921  : 			{
; 922  : 				angles1[j] = panimvalue[k+1].value;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _panimvalue$3[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+2]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles1$[ebp+eax*4], xmm0

; 923  : 
; 924  : 				if( panimvalue->num.valid > k + 1 )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN14@R_StudioCa

; 925  : 				{
; 926  : 					angles2[j] = panimvalue[k+2].value;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _panimvalue$3[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles2$[ebp+eax*4], xmm0

; 927  : 				}

	jmp	SHORT $LN17@R_StudioCa
$LN14@R_StudioCa:

; 928  : 				else
; 929  : 				{
; 930  : 					if( panimvalue->num.total > k + 1 )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN16@R_StudioCa

; 931  : 						angles2[j] = angles1[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _angles1$[ebp+ecx*4]
	mov	DWORD PTR _angles2$[ebp+eax*4], edx
	jmp	SHORT $LN17@R_StudioCa
$LN16@R_StudioCa:

; 932  : 					else angles2[j] = panimvalue[panimvalue->num.valid+2].value;

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles2$[ebp+ecx*4], xmm0
$LN17@R_StudioCa:

; 933  : 				}
; 934  : 			}

	jmp	SHORT $LN19@R_StudioCa
$LN12@R_StudioCa:

; 935  : 			else
; 936  : 			{
; 937  : 				angles1[j] = panimvalue[panimvalue->num.valid].value;

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles1$[ebp+ecx*4], xmm0

; 938  : 				if( panimvalue->num.total > k + 1 )

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN18@R_StudioCa

; 939  : 					angles2[j] = angles1[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _angles1$[ebp+ecx*4]
	mov	DWORD PTR _angles2$[ebp+eax*4], edx
	jmp	SHORT $LN19@R_StudioCa
$LN18@R_StudioCa:

; 940  : 				else angles2[j] = panimvalue[panimvalue->num.valid+2].value;

	mov	eax, DWORD PTR _panimvalue$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _panimvalue$3[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles2$[ebp+ecx*4], xmm0
$LN19@R_StudioCa:

; 941  : 			}
; 942  : 
; 943  : 			angles1[j] = pbone->value[j+3] + angles1[j] * pbone->scale[j+3];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	movss	xmm0, DWORD PTR _angles1$[ebp+eax*4]
	mulss	xmm0, DWORD PTR [edx+ecx*4+100]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4+76]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles1$[ebp+edx*4], xmm0

; 944  : 			angles2[j] = pbone->value[j+3] + angles2[j] * pbone->scale[j+3];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pbone$[ebp]
	movss	xmm0, DWORD PTR _angles2$[ebp+eax*4]
	mulss	xmm0, DWORD PTR [edx+ecx*4+100]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4+76]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles2$[ebp+edx*4], xmm0
$LN8@R_StudioCa:

; 945  : 		}
; 946  : 
; 947  : 		if( pbone->bonecontroller[j+3] != -1 && adj != NULL )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	cmp	DWORD PTR [ecx+eax*4+52], -1
	je	SHORT $LN20@R_StudioCa
	cmp	DWORD PTR _adj$[ebp], 0
	je	SHORT $LN20@R_StudioCa

; 948  : 		{
; 949  : 			angles1[j] += adj[pbone->bonecontroller[j+3]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+52]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _angles1$[ebp+eax*4]
	addss	xmm0, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles1$[ebp+edx*4], xmm0

; 950  : 			angles2[j] += adj[pbone->bonecontroller[j+3]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+52]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _adj$[ebp]
	movss	xmm0, DWORD PTR _angles2$[ebp+eax*4]
	addss	xmm0, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _angles2$[ebp+edx*4], xmm0
$LN20@R_StudioCa:

; 951  : 		}
; 952  : 	}

	jmp	$LN2@R_StudioCa
$LN3@R_StudioCa:

; 953  : 
; 954  : 	if( !VectorCompare( angles1, angles2 ))

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _angles1$[ebp+ecx]
	ucomiss	xmm0, DWORD PTR _angles2$[ebp+eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_StudioCa
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _angles1$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _angles2$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@R_StudioCa
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _angles1$[ebp+eax]
	ucomiss	xmm0, DWORD PTR _angles2$[ebp+ecx]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@R_StudioCa
$LN23@R_StudioCa:

; 955  : 	{
; 956  : 		vec4_t	q1, q2;
; 957  : 
; 958  : 		AngleQuaternion( angles1, q1, true );

	push	1
	lea	eax, DWORD PTR _q1$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles1$[ebp]
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 959  : 		AngleQuaternion( angles2, q2, true );

	push	1
	lea	eax, DWORD PTR _q2$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles2$[ebp]
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 960  : 		QuaternionSlerp( q1, q2, s, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q2$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _q1$2[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 961  : 	}

	jmp	SHORT $LN22@R_StudioCa
$LN21@R_StudioCa:

; 962  : 	else
; 963  : 	{
; 964  : 		AngleQuaternion( angles1, q, true );

	push	1
	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _angles1$[ebp]
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH
$LN22@R_StudioCa:

; 965  : 	}
; 966  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioCalcBoneQuaternion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_studio.c
;	COMDAT _R_StudioSlerpBones
_TEXT	SEGMENT
tv67 = -76						; size = 4
tv171 = -72						; size = 4
tv66 = -72						; size = 4
_i$ = -4						; size = 4
_numbones$ = 8						; size = 4
_q1$ = 12						; size = 4
_pos1$ = 16						; size = 4
_q2$ = 20						; size = 4
_pos2$ = 24						; size = 4
_s$ = 28						; size = 4
_R_StudioSlerpBones PROC				; COMDAT

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1060 : 	int	i;
; 1061 : 
; 1062 : 	s = bound( 0.0f, s, 1.0f );

	movss	xmm0, DWORD PTR _s$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN8@R_StudioSl
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _s$[ebp]
	jbe	SHORT $LN6@R_StudioSl
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN7@R_StudioSl
$LN6@R_StudioSl:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv66[ebp], xmm0
$LN7@R_StudioSl:
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN9@R_StudioSl
$LN8@R_StudioSl:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv67[ebp], xmm0
$LN9@R_StudioSl:
	movss	xmm0, DWORD PTR tv67[ebp]
	movss	DWORD PTR _s$[ebp], xmm0

; 1063 : 
; 1064 : 	for( i = 0; i < numbones; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_StudioSl
$LN2@R_StudioSl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_StudioSl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numbones$[ebp]
	jge	$LN3@R_StudioSl

; 1065 : 	{
; 1066 : 		QuaternionSlerp( q1[i], q2[i], s, q1[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _q1$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 1067 : 		VectorLerp( pos1[i], s, pos2[i], pos1[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _pos1$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pos2$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	imul	edi, DWORD PTR _i$[ebp], 12
	add	edi, DWORD PTR _pos1$[ebp]
	mov	ebx, 4
	imul	ebx, ebx, 0
	movss	xmm0, DWORD PTR [ecx+esi]
	subss	xmm0, DWORD PTR [edi+ebx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR [eax+edx]
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _pos1$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _pos1$[ebp]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pos2$[ebp]
	mov	esi, 4
	shl	esi, 0
	imul	edi, DWORD PTR _i$[ebp], 12
	add	edi, DWORD PTR _pos1$[ebp]
	mov	ebx, 4
	shl	ebx, 0
	movss	xmm0, DWORD PTR [ecx+esi]
	subss	xmm0, DWORD PTR [edi+ebx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	imul	edx, DWORD PTR _i$[ebp], 12
	add	edx, DWORD PTR _pos1$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pos1$[ebp]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _pos2$[ebp]
	mov	esi, 4
	shl	esi, 1
	imul	edi, DWORD PTR _i$[ebp], 12
	add	edi, DWORD PTR _pos1$[ebp]
	mov	ebx, 4
	shl	ebx, 1
	movss	xmm0, DWORD PTR [eax+esi]
	subss	xmm0, DWORD PTR [edi+ebx]
	mulss	xmm0, DWORD PTR _s$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv171[ebp], xmm1
	imul	ecx, DWORD PTR _i$[ebp], 12
	add	ecx, DWORD PTR _pos1$[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv171[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 1068 : 	}

	jmp	$LN2@R_StudioSl
$LN3@R_StudioSl:

; 1069 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_StudioSlerpBones ENDP
_TEXT	ENDS
END
