; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\titles.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_gMessageParms:BYTE:02cH
_DATA	ENDS
PUBLIC	_CL_TextMessageParse
PUBLIC	??_C@_08OAGMDKAF@position@			; `string'
PUBLIC	??_C@_06HOPIODND@effect@			; `string'
PUBLIC	??_C@_06HPHNOPOF@fxtime@			; `string'
PUBLIC	??_C@_06KEONFOCA@color2@			; `string'
PUBLIC	??_C@_05PEENBMOG@color@				; `string'
PUBLIC	??_C@_06JFGPOFJL@fadein@			; `string'
PUBLIC	??_C@_07BJADIKJG@fadeout@			; `string'
PUBLIC	??_C@_08DKAMCIDA@holdtime@			; `string'
PUBLIC	??_C@_0BO@NGGONDHB@?$FO1Error?3?$FO7?5unknown?5token?3?5?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_TextMessageParse@@9@9	; `CL_TextMessageParse'::`1'::__LINE__Var
PUBLIC	??_C@_0CM@CCGGGCGL@TextMessage?3?5unexpected?5?8?$HN?8?5fou@ ; `string'
PUBLIC	??_C@_0CD@NAPNCFAI@TextMessage?3?5error?5while?5parsin@ ; `string'
PUBLIC	??_C@_0CM@LPLKGJHI@TextMessage?3?5unexpected?5?8?$HL?8?5fou@ ; `string'
PUBLIC	??_C@_0DJ@FILFCBEI@?$FO3Warning?3?$FO7?5Too?5many?5messages?5@ ; `string'
PUBLIC	??_C@_0CG@GEMEMPMN@TextMessage?3?5parsed?5?$CFd?5text?5mes@ ; `string'
PUBLIC	??_C@_0DD@KNNOPLEO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0DH@FFPJPLBB@?$FO1Error?3?$FO7?5TextMessage?3?5overflo@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_COM_MemFgets:PROC
EXTRN	_COM_TrimSpace:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0DH@FFPJPLBB@?$FO1Error?3?$FO7?5TextMessage?3?5overflo@
CONST	SEGMENT
??_C@_0DH@FFPJPLBB@?$FO1Error?3?$FO7?5TextMessage?3?5overflo@ DB '^1Error'
	DB	':^7 TextMessage: overflow text message buffer!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KNNOPLEO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@KNNOPLEO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\titles.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GEMEMPMN@TextMessage?3?5parsed?5?$CFd?5text?5mes@
CONST	SEGMENT
??_C@_0CG@GEMEMPMN@TextMessage?3?5parsed?5?$CFd?5text?5mes@ DB 'TextMessa'
	DB	'ge: parsed %d text messages', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FILFCBEI@?$FO3Warning?3?$FO7?5Too?5many?5messages?5@
CONST	SEGMENT
??_C@_0DJ@FILFCBEI@?$FO3Warning?3?$FO7?5Too?5many?5messages?5@ DB '^3Warn'
	DB	'ing:^7 Too many messages in titles.txt, max is %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LPLKGJHI@TextMessage?3?5unexpected?5?8?$HL?8?5fou@
CONST	SEGMENT
??_C@_0CM@LPLKGJHI@TextMessage?3?5unexpected?5?8?$HL?8?5fou@ DB 'TextMess'
	DB	'age: unexpected ''{'' found, line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NAPNCFAI@TextMessage?3?5error?5while?5parsin@
CONST	SEGMENT
??_C@_0CD@NAPNCFAI@TextMessage?3?5error?5while?5parsin@ DB 'TextMessage: '
	DB	'error while parsing!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CCGGGCGL@TextMessage?3?5unexpected?5?8?$HN?8?5fou@
CONST	SEGMENT
??_C@_0CM@CCGGGCGL@TextMessage?3?5unexpected?5?8?$HN?8?5fou@ DB 'TextMess'
	DB	'age: unexpected ''}'' found, line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_TextMessageParse@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_TextMessageParse@@9@9 DD 0d4H	; `CL_TextMessageParse'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@NGGONDHB@?$FO1Error?3?$FO7?5unknown?5token?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BO@NGGONDHB@?$FO1Error?3?$FO7?5unknown?5token?3?5?$CFs?6@ DB '^1Er'
	DB	'ror:^7 unknown token: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DKAMCIDA@holdtime@
CONST	SEGMENT
??_C@_08DKAMCIDA@holdtime@ DB 'holdtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJADIKJG@fadeout@
CONST	SEGMENT
??_C@_07BJADIKJG@fadeout@ DB 'fadeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JFGPOFJL@fadein@
CONST	SEGMENT
??_C@_06JFGPOFJL@fadein@ DB 'fadein', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PEENBMOG@color@
CONST	SEGMENT
??_C@_05PEENBMOG@color@ DB 'color', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEONFOCA@color2@
CONST	SEGMENT
??_C@_06KEONFOCA@color2@ DB 'color2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPHNOPOF@fxtime@
CONST	SEGMENT
??_C@_06HPHNOPOF@fxtime@ DB 'fxtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOPIODND@effect@
CONST	SEGMENT
??_C@_06HOPIODND@effect@ DB 'effect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OAGMDKAF@position@
CONST	SEGMENT
??_C@_08OAGMDKAF@position@ DB 'position', 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02daH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0541H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _ParseDirective
_TEXT	SEGMENT
_tempFloat$1 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_pText$ = 8						; size = 4
_ParseDirective PROC					; COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 137  : 	if( pText && pText[0] == '$' )

	cmp	DWORD PTR _pText$[ebp], 0
	je	$LN2@ParseDirec
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 36					; 00000024H
	jne	$LN2@ParseDirec

; 138  : 	{
; 139  : 		float	tempFloat[8];
; 140  : 
; 141  : 		if( IsToken( pText, "position" ))

	push	OFFSET ??_C@_08OAGMDKAF@position@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@ParseDirec

; 142  : 		{
; 143  : 			if( ParseFloats( pText, tempFloat, 2 ))

	push	2
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@ParseDirec

; 144  : 			{
; 145  : 				gMessageParms.x = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+12, xmm0

; 146  : 				gMessageParms.y = tempFloat[1];

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+eax]
	movss	DWORD PTR _gMessageParms+16, xmm0
$LN5@ParseDirec:

; 147  : 			}
; 148  : 		}

	jmp	$LN25@ParseDirec
$LN3@ParseDirec:

; 149  : 		else if( IsToken( pText, "effect" ))

	push	OFFSET ??_C@_06HOPIODND@effect@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ParseDirec

; 150  : 		{
; 151  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@ParseDirec

; 152  : 			{
; 153  : 				gMessageParms.effect = (int)tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	cvttss2si edx, DWORD PTR _tempFloat$1[ebp+ecx]
	mov	DWORD PTR _gMessageParms, edx
$LN8@ParseDirec:

; 154  : 			}
; 155  : 		}

	jmp	$LN25@ParseDirec
$LN6@ParseDirec:

; 156  : 		else if( IsToken( pText, "fxtime" ))

	push	OFFSET ??_C@_06HPHNOPOF@fxtime@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@ParseDirec

; 157  : 		{
; 158  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@ParseDirec

; 159  : 			{
; 160  : 				gMessageParms.fxtime = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+32, xmm0
$LN11@ParseDirec:

; 161  : 			}
; 162  : 		}

	jmp	$LN25@ParseDirec
$LN9@ParseDirec:

; 163  : 		else if( IsToken( pText, "color2" ))

	push	OFFSET ??_C@_06KEONFOCA@color2@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN12@ParseDirec

; 164  : 		{
; 165  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@ParseDirec

; 166  : 			{
; 167  : 				gMessageParms.r2 = (int)tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	cvttss2si edx, DWORD PTR _tempFloat$1[ebp+ecx]
	mov	BYTE PTR _gMessageParms+8, dl

; 168  : 				gMessageParms.g2 = (int)tempFloat[1];

	mov	eax, 4
	shl	eax, 0
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+9, cl

; 169  : 				gMessageParms.b2 = (int)tempFloat[2];

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+10, cl
$LN14@ParseDirec:

; 170  : 			}
; 171  : 		}

	jmp	$LN25@ParseDirec
$LN12@ParseDirec:

; 172  : 		else if( IsToken( pText, "color" ))

	push	OFFSET ??_C@_05PEENBMOG@color@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@ParseDirec

; 173  : 		{
; 174  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN17@ParseDirec

; 175  : 			{
; 176  : 				gMessageParms.r1 = (int)tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	cvttss2si edx, DWORD PTR _tempFloat$1[ebp+ecx]
	mov	BYTE PTR _gMessageParms+4, dl

; 177  : 				gMessageParms.g1 = (int)tempFloat[1];

	mov	eax, 4
	shl	eax, 0
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+5, cl

; 178  : 				gMessageParms.b1 = (int)tempFloat[2];

	mov	eax, 4
	shl	eax, 1
	cvttss2si ecx, DWORD PTR _tempFloat$1[ebp+eax]
	mov	BYTE PTR _gMessageParms+6, cl
$LN17@ParseDirec:

; 179  : 			}
; 180  : 		}

	jmp	$LN25@ParseDirec
$LN15@ParseDirec:

; 181  : 		else if( IsToken( pText, "fadein" ))

	push	OFFSET ??_C@_06JFGPOFJL@fadein@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@ParseDirec

; 182  : 		{
; 183  : 			if( ParseFloats( pText, tempFloat, 1 ))

	push	1
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@ParseDirec

; 184  : 			{
; 185  : 				gMessageParms.fadein = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+20, xmm0
$LN20@ParseDirec:

; 186  : 			}
; 187  : 		}

	jmp	$LN25@ParseDirec
$LN18@ParseDirec:

; 188  : 		else if( IsToken( pText, "fadeout" ))

	push	OFFSET ??_C@_07BJADIKJG@fadeout@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@ParseDirec

; 189  : 		{
; 190  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN23@ParseDirec

; 191  : 			{
; 192  : 				gMessageParms.fadeout = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+24, xmm0
$LN23@ParseDirec:

; 193  : 			}
; 194  : 		}

	jmp	SHORT $LN25@ParseDirec
$LN21@ParseDirec:

; 195  : 		else if( IsToken( pText, "holdtime" ))

	push	OFFSET ??_C@_08DKAMCIDA@holdtime@
	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_IsToken
	add	esp, 8
	test	eax, eax
	je	SHORT $LN24@ParseDirec

; 196  : 		{
; 197  : 			if( ParseFloats( pText, tempFloat, 3 ))

	push	3
	lea	eax, DWORD PTR _tempFloat$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pText$[ebp]
	push	ecx
	call	_ParseFloats
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@ParseDirec

; 198  : 			{
; 199  : 				gMessageParms.holdtime = tempFloat[0];

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _tempFloat$1[ebp+ecx]
	movss	DWORD PTR _gMessageParms+28, xmm0
$LN26@ParseDirec:

; 200  : 			}
; 201  : 		}

	jmp	SHORT $LN25@ParseDirec
$LN24@ParseDirec:

; 202  : 		else
; 203  : 		{
; 204  : 			Con_DPrintf( S_ERROR "unknown token: %s\n", pText );

	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@NGGONDHB@?$FO1Error?3?$FO7?5unknown?5token?3?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8
$LN25@ParseDirec:

; 205  : 		}
; 206  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ParseDirec
$LN2@ParseDirec:

; 207  : 	}
; 208  : 	return 0;

	xor	eax, eax
$LN1@ParseDirec:

; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseDirective ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _IsToken
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_pTokenName$ = 12					; size = 4
_IsToken PROC						; COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 126  : 	if( !pText || !pTokenName )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN3@IsToken
	cmp	DWORD PTR _pTokenName$[ebp], 0
	jne	SHORT $LN2@IsToken
$LN3@IsToken:

; 127  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsToken
$LN2@IsToken:

; 128  : 
; 129  : 	if( !Q_strnicmp( pText+1, pTokenName, Q_strlen( pTokenName )))

	mov	eax, DWORD PTR _pTokenName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pTokenName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pText$[ebp]
	add	edx, 1
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@IsToken

; 130  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsToken
$LN4@IsToken:

; 131  : 
; 132  : 	return 0;

	xor	eax, eax
$LN1@IsToken:

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _ParseFloats
_TEXT	SEGMENT
_index$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pText$ = 8						; size = 4
_pFloat$ = 12						; size = 4
_count$ = 16						; size = 4
_ParseFloats PROC					; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 100  : 	const char *pTemp = pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _pTemp$[ebp], eax

; 101  : 	int index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN2@ParseFloat:

; 102  : 
; 103  : 	while( pTemp && count > 0 )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN3@ParseFloat
	cmp	DWORD PTR _count$[ebp], 0
	jle	SHORT $LN3@ParseFloat

; 104  : 	{
; 105  : 		// skip current token / float
; 106  : 		pTemp = SkipText( pTemp );

	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_SkipText
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 107  : 		// skip any whitespace in between
; 108  : 		pTemp = SkipSpace( pTemp );

	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_SkipSpace
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 109  : 
; 110  : 		if( pTemp )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN4@ParseFloat

; 111  : 		{
; 112  : 			// parse a float
; 113  : 			pFloat[index] = Q_atof( pTemp );

	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _pFloat$[ebp]
	fstp	DWORD PTR [edx+ecx*4]

; 114  : 			count--;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 115  : 			index++;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@ParseFloat:

; 116  : 		}
; 117  : 	}

	jmp	SHORT $LN2@ParseFloat
$LN3@ParseFloat:

; 118  : 
; 119  : 	if( count == 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN5@ParseFloat

; 120  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ParseFloat
$LN5@ParseFloat:

; 121  : 	return 0;

	xor	eax, eax
$LN1@ParseFloat:

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseFloats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _SkipText
_TEXT	SEGMENT
_pos$1 = -4						; size = 4
_pText$ = 8						; size = 4
_SkipText PROC						; COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 88   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN4@SkipText

; 89   : 	{
; 90   : 		int pos = 0;

	mov	DWORD PTR _pos$1[ebp], 0
$LN2@SkipText:

; 91   : 		while( pText[pos] && !IsWhiteSpace( pText[pos] ))

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@SkipText
	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SkipText

; 92   : 			pos++;

	mov	eax, DWORD PTR _pos$1[ebp]
	add	eax, 1
	mov	DWORD PTR _pos$1[ebp], eax
	jmp	SHORT $LN2@SkipText
$LN3@SkipText:

; 93   : 		return pText + pos;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	jmp	SHORT $LN1@SkipText
$LN4@SkipText:

; 94   : 	}
; 95   : 	return NULL;

	xor	eax, eax
$LN1@SkipText:

; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SkipText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _SkipSpace
_TEXT	SEGMENT
_pos$1 = -4						; size = 4
_pText$ = 8						; size = 4
_SkipSpace PROC						; COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 76   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN4@SkipSpace

; 77   : 	{
; 78   : 		int pos = 0;

	mov	DWORD PTR _pos$1[ebp], 0
$LN2@SkipSpace:

; 79   : 		while( pText[pos] && IsWhiteSpace( pText[pos] ))

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@SkipSpace
	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SkipSpace

; 80   : 			pos++;

	mov	eax, DWORD PTR _pos$1[ebp]
	add	eax, 1
	mov	DWORD PTR _pos$1[ebp], eax
	jmp	SHORT $LN2@SkipSpace
$LN3@SkipSpace:

; 81   : 		return pText + pos;

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _pos$1[ebp]
	jmp	SHORT $LN1@SkipSpace
$LN4@SkipSpace:

; 82   : 	}
; 83   : 	return NULL;

	xor	eax, eax
$LN1@SkipSpace:

; 84   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _IsWhiteSpace
_TEXT	SEGMENT
_space$ = 8						; size = 1
_IsWhiteSpace PROC					; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 69   : 	if( space == ' ' || space == '\t' || space == '\r' || space == '\n' )

	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 9
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@IsWhiteSpa
$LN3@IsWhiteSpa:

; 70   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsWhiteSpa
$LN2@IsWhiteSpa:

; 71   : 	return 0;

	xor	eax, eax
$LN1@IsWhiteSpa:

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsWhiteSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _IsEndOfText
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_IsEndOfText PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 59   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsEndOfTex

; 60   : 	{
; 61   : 		if( pText[0] == '}' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN2@IsEndOfTex

; 62   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsEndOfTex
$LN2@IsEndOfTex:

; 63   : 	}
; 64   : 	return 0;

	xor	eax, eax
$LN1@IsEndOfTex:

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsEndOfText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _IsStartOfText
_TEXT	SEGMENT
_pText$ = 8						; size = 4
_IsStartOfText PROC					; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 48   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsStartOfT

; 49   : 	{
; 50   : 		if( pText[0] == '{' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN2@IsStartOfT

; 51   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsStartOfT
$LN2@IsStartOfT:

; 52   : 	}
; 53   : 	return 0;

	xor	eax, eax
$LN1@IsStartOfT:

; 54   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsStartOfText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _IsComment
_TEXT	SEGMENT
_length$1 = -4						; size = 4
_pText$ = 8						; size = 4
_IsComment PROC						; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 29   : 	if( pText )

	cmp	DWORD PTR _pText$[ebp], 0
	je	SHORT $LN2@IsComment

; 30   : 	{
; 31   : 		int length = Q_strlen( pText );

	mov	eax, DWORD PTR _pText$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _length$1[ebp], eax

; 32   : 
; 33   : 		if( length >= 2 && pText[0] == '/' && pText[1] == '/' )

	cmp	DWORD PTR _length$1[ebp], 2
	jl	SHORT $LN3@IsComment
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pText$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN3@IsComment
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pText$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN3@IsComment

; 34   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsComment
$LN3@IsComment:

; 35   : 		
; 36   : 		// no text?
; 37   : 		if( length > 0 )

	cmp	DWORD PTR _length$1[ebp], 0
	jle	SHORT $LN2@IsComment

; 38   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@IsComment
$LN2@IsComment:

; 39   : 	}
; 40   : 
; 41   : 	// no text is a comment too
; 42   : 	return 1;

	mov	eax, 1
$LN1@IsComment:

; 43   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsComment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\titles.c
;	COMDAT _CL_TextMessageParse
_TEXT	SEGMENT
tv73 = -124992						; size = 4
_length$1 = -124476					; size = 4
_lastNamePos$ = -124472					; size = 4
_messageCount$ = -124468				; size = 4
_nameOffset$ = -124464					; size = 4
_messageSize$ = -124460					; size = 4
_textHeapSize$ = -124456				; size = 4
_nameHeapSize$ = -124452				; size = 4
_i$ = -124448						; size = 4
_textMessages$ = -124444				; size = 90112
_lastLinePos$ = -34332					; size = 4
_filePos$ = -34328					; size = 4
_lineNumber$ = -34324					; size = 4
_mode$ = -34320						; size = 4
_nameHeap$ = -34316					; size = 32768
_pNameHeap$ = -1548					; size = 4
_pCurrentText$ = -1544					; size = 4
_currentName$ = -1540					; size = 512
_trim$ = -1028						; size = 512
_buf$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_pMemFile$ = 8						; size = 4
_fileSize$ = 12						; size = 4
_CL_TextMessageParse PROC				; COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 124992				; 0001e840H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 213  : 	char			buf[512], trim[512], currentName[512];
; 214  : 	char			*pCurrentText = NULL, *pNameHeap;

	mov	DWORD PTR _pCurrentText$[ebp], 0

; 215  : 	char			nameHeap[32768]; // g-cont. i will scale up heap to handle all TFC messages
; 216  : 	int			mode = MSGFILE_NAME; // searching for a message name	

	mov	DWORD PTR _mode$[ebp], 0

; 217  : 	int			lineNumber, filePos, lastLinePos;
; 218  : 	client_textmessage_t	textMessages[MAX_MESSAGES];
; 219  : 	int			i, nameHeapSize, textHeapSize, messageSize, nameOffset;
; 220  : 	int			messageCount, lastNamePos;
; 221  : 
; 222  : 	lastNamePos = 0;

	mov	DWORD PTR _lastNamePos$[ebp], 0

; 223  : 	lineNumber = 0;

	mov	DWORD PTR _lineNumber$[ebp], 0

; 224  : 	filePos = 0;

	mov	DWORD PTR _filePos$[ebp], 0

; 225  : 	lastLinePos = 0;

	mov	DWORD PTR _lastLinePos$[ebp], 0

; 226  : 	messageCount = 0;

	mov	DWORD PTR _messageCount$[ebp], 0
$LN2@CL_TextMes:

; 227  : 
; 228  : 	while( COM_MemFgets( pMemFile, fileSize, &filePos, buf, 512 ) != NULL )

	push	512					; 00000200H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filePos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMemFile$[ebp]
	push	eax
	call	_COM_MemFgets
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN3@CL_TextMes

; 229  : 	{
; 230  : 		COM_TrimSpace( buf, trim );

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_COM_TrimSpace
	add	esp, 8

; 231  : 
; 232  : 		switch( mode )

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN12@CL_TextMes
	cmp	DWORD PTR tv73[ebp], 1
	je	$LN17@CL_TextMes
	jmp	$LN4@CL_TextMes
$LN12@CL_TextMes:

; 233  : 		{
; 234  : 		case MSGFILE_NAME:
; 235  : 			// skip comment lines
; 236  : 			if( IsComment( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsComment
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@CL_TextMes

; 237  : 				break;

	jmp	$LN4@CL_TextMes
$LN13@CL_TextMes:

; 238  : 
; 239  : 			// Is this a directive "$command"?, if so parse it and break
; 240  : 			if( ParseDirective( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_ParseDirective
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@CL_TextMes

; 241  : 				break;

	jmp	$LN4@CL_TextMes
$LN14@CL_TextMes:

; 242  : 
; 243  : 			if( IsStartOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsStartOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@CL_TextMes

; 244  : 			{
; 245  : 				mode = MSGFILE_TEXT;

	mov	DWORD PTR _mode$[ebp], 1

; 246  : 				pCurrentText = (char*)(pMemFile + filePos);

	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, DWORD PTR _filePos$[ebp]
	mov	DWORD PTR _pCurrentText$[ebp], eax

; 247  : 				break;

	jmp	$LN4@CL_TextMes
$LN15@CL_TextMes:

; 248  : 			}
; 249  : 
; 250  : 			if( IsEndOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsEndOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@CL_TextMes

; 251  : 			{
; 252  : 				Con_Reportf( "TextMessage: unexpected '}' found, line %d\n", lineNumber );

	mov	eax, DWORD PTR _lineNumber$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@CCGGGCGL@TextMessage?3?5unexpected?5?8?$HN?8?5fou@
	call	_Con_Reportf
	add	esp, 8

; 253  : 				return;

	jmp	$LN1@CL_TextMes
$LN16@CL_TextMes:

; 254  : 			}
; 255  : 			Q_strcpy( currentName, trim );

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	lea	ecx, DWORD PTR _currentName$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 256  : 			break;

	jmp	$LN4@CL_TextMes
$LN17@CL_TextMes:

; 257  : 		case MSGFILE_TEXT:
; 258  : 			if( IsEndOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsEndOfText
	add	esp, 4
	test	eax, eax
	je	$LN18@CL_TextMes

; 259  : 			{
; 260  : 				int length = Q_strlen( currentName );

	lea	eax, DWORD PTR _currentName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _length$1[ebp], eax

; 261  : 
; 262  : 				// save name on name heap
; 263  : 				if( lastNamePos + length > 32768 )

	mov	eax, DWORD PTR _lastNamePos$[ebp]
	add	eax, DWORD PTR _length$1[ebp]
	cmp	eax, 32768				; 00008000H
	jle	SHORT $LN19@CL_TextMes

; 264  : 				{
; 265  : 					Con_Reportf( "TextMessage: error while parsing!\n" );

	push	OFFSET ??_C@_0CD@NAPNCFAI@TextMessage?3?5error?5while?5parsin@
	call	_Con_Reportf
	add	esp, 4

; 266  : 					return;

	jmp	$LN1@CL_TextMes
$LN19@CL_TextMes:

; 267  : 				}
; 268  : 
; 269  : 				Q_strcpy( nameHeap + lastNamePos, currentName );

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _currentName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastNamePos$[ebp]
	lea	edx, DWORD PTR _nameHeap$[ebp+ecx]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 270  : 
; 271  : 				// terminate text in-place in the memory file
; 272  : 				// (it's temporary memory that will be deleted)
; 273  : 				pMemFile[lastLinePos-1] = 0;

	mov	eax, DWORD PTR _pMemFile$[ebp]
	add	eax, DWORD PTR _lastLinePos$[ebp]
	mov	BYTE PTR [eax-1], 0

; 274  : 
; 275  : 				// Save name/text on heap
; 276  : 				textMessages[messageCount] = gMessageParms;

	imul	eax, DWORD PTR _messageCount$[ebp], 44
	lea	edi, DWORD PTR _textMessages$[ebp+eax]
	mov	ecx, 11					; 0000000bH
	mov	esi, OFFSET _gMessageParms
	rep movsd

; 277  : 				textMessages[messageCount].pName = nameHeap + lastNamePos;

	mov	eax, DWORD PTR _lastNamePos$[ebp]
	lea	ecx, DWORD PTR _nameHeap$[ebp+eax]
	imul	edx, DWORD PTR _messageCount$[ebp], 44
	mov	DWORD PTR _textMessages$[ebp+edx+36], ecx

; 278  : 				lastNamePos += Q_strlen( currentName ) + 1;

	lea	eax, DWORD PTR _currentName$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lastNamePos$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _lastNamePos$[ebp], edx

; 279  : 				textMessages[messageCount].pMessage = pCurrentText;

	imul	eax, DWORD PTR _messageCount$[ebp], 44
	mov	ecx, DWORD PTR _pCurrentText$[ebp]
	mov	DWORD PTR _textMessages$[ebp+eax+40], ecx

; 280  : 				messageCount++;

	mov	eax, DWORD PTR _messageCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _messageCount$[ebp], eax

; 281  : 
; 282  : 				// reset parser to search for names
; 283  : 				mode = MSGFILE_NAME;

	mov	DWORD PTR _mode$[ebp], 0

; 284  : 				break;

	jmp	SHORT $LN4@CL_TextMes
$LN18@CL_TextMes:

; 285  : 			}
; 286  : 			if( IsStartOfText( trim ))

	lea	eax, DWORD PTR _trim$[ebp]
	push	eax
	call	_IsStartOfText
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_TextMes

; 287  : 			{
; 288  : 				Con_Reportf( "TextMessage: unexpected '{' found, line %d\n", lineNumber );

	mov	eax, DWORD PTR _lineNumber$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@LPLKGJHI@TextMessage?3?5unexpected?5?8?$HL?8?5fou@
	call	_Con_Reportf
	add	esp, 8

; 289  : 				return;

	jmp	$LN1@CL_TextMes
$LN4@CL_TextMes:

; 290  : 			}
; 291  : 			break;
; 292  : 		}
; 293  : 
; 294  : 		lineNumber++;

	mov	eax, DWORD PTR _lineNumber$[ebp]
	add	eax, 1
	mov	DWORD PTR _lineNumber$[ebp], eax

; 295  : 		lastLinePos = filePos;

	mov	eax, DWORD PTR _filePos$[ebp]
	mov	DWORD PTR _lastLinePos$[ebp], eax

; 296  : 
; 297  : 		if( messageCount >= MAX_MESSAGES )

	cmp	DWORD PTR _messageCount$[ebp], 2048	; 00000800H
	jl	SHORT $LN21@CL_TextMes

; 298  : 		{
; 299  : 			Con_Printf( S_WARN "Too many messages in titles.txt, max is %d\n", MAX_MESSAGES );

	push	2048					; 00000800H
	push	OFFSET ??_C@_0DJ@FILFCBEI@?$FO3Warning?3?$FO7?5Too?5many?5messages?5@
	call	_Con_Printf
	add	esp, 8

; 300  : 			break;

	jmp	SHORT $LN3@CL_TextMes
$LN21@CL_TextMes:

; 301  : 		}
; 302  : 	}

	jmp	$LN2@CL_TextMes
$LN3@CL_TextMes:

; 303  : 
; 304  : 	Con_Reportf( "TextMessage: parsed %d text messages\n", messageCount );

	mov	eax, DWORD PTR _messageCount$[ebp]
	push	eax
	push	OFFSET ??_C@_0CG@GEMEMPMN@TextMessage?3?5parsed?5?$CFd?5text?5mes@
	call	_Con_Reportf
	add	esp, 8

; 305  : 	nameHeapSize = lastNamePos;

	mov	eax, DWORD PTR _lastNamePos$[ebp]
	mov	DWORD PTR _nameHeapSize$[ebp], eax

; 306  : 	textHeapSize = 0;

	mov	DWORD PTR _textHeapSize$[ebp], 0

; 307  : 
; 308  : 	for( i = 0; i < messageCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@CL_TextMes
$LN6@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _messageCount$[ebp]
	jge	SHORT $LN7@CL_TextMes

; 309  : 		textHeapSize += Q_strlen( textMessages[i].pMessage ) + 1;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _textMessages$[ebp+eax+40]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _textHeapSize$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _textHeapSize$[ebp], eax
	jmp	SHORT $LN6@CL_TextMes
$LN7@CL_TextMes:

; 310  : 	messageSize = ( messageCount * sizeof( client_textmessage_t ));

	imul	eax, DWORD PTR _messageCount$[ebp], 44
	mov	DWORD PTR _messageSize$[ebp], eax

; 311  : 
; 312  : 	if(( textHeapSize + nameHeapSize + messageSize ) <= 0 )

	mov	eax, DWORD PTR _textHeapSize$[ebp]
	add	eax, DWORD PTR _nameHeapSize$[ebp]
	add	eax, DWORD PTR _messageSize$[ebp]
	test	eax, eax
	jg	SHORT $LN22@CL_TextMes

; 313  : 	{
; 314  : 		clgame.titles = NULL;

	mov	DWORD PTR _clgame+255288, 0

; 315  : 		clgame.numTitles = 0;

	mov	DWORD PTR _clgame+255292, 0

; 316  : 		return;

	jmp	$LN1@CL_TextMes
$LN22@CL_TextMes:

; 317  : 	}
; 318  : 
; 319  : 	// must malloc because we need to be able to clear it after initialization
; 320  : 	clgame.titles = (client_textmessage_t *)Mem_Calloc( cls.mempool, textHeapSize + nameHeapSize + messageSize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_TextMessageParse@@9@9
	add	eax, 108				; 0000006cH
	push	eax
	push	OFFSET ??_C@_0DD@KNNOPLEO@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _textHeapSize$[ebp]
	add	ecx, DWORD PTR _nameHeapSize$[ebp]
	add	ecx, DWORD PTR _messageSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _clgame+255288, eax

; 321  : 	
; 322  : 	// copy table over
; 323  : 	memcpy( clgame.titles, textMessages, messageSize );

	mov	eax, DWORD PTR _messageSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _textMessages$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+255288
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 324  : 	
; 325  : 	// copy Name heap
; 326  : 	pNameHeap = ((char *)clgame.titles) + messageSize;

	mov	eax, DWORD PTR _clgame+255288
	add	eax, DWORD PTR _messageSize$[ebp]
	mov	DWORD PTR _pNameHeap$[ebp], eax

; 327  : 	memcpy( pNameHeap, nameHeap, nameHeapSize );

	mov	eax, DWORD PTR _nameHeapSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nameHeap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pNameHeap$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 328  : 	nameOffset = pNameHeap - clgame.titles[0].pName;

	mov	eax, 44					; 0000002cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _clgame+255288
	mov	eax, DWORD PTR _pNameHeap$[ebp]
	sub	eax, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _nameOffset$[ebp], eax

; 329  : 
; 330  : 	// copy text & fixup pointers
; 331  : 	pCurrentText = pNameHeap + nameHeapSize;

	mov	eax, DWORD PTR _pNameHeap$[ebp]
	add	eax, DWORD PTR _nameHeapSize$[ebp]
	mov	DWORD PTR _pCurrentText$[ebp], eax

; 332  : 
; 333  : 	for( i = 0; i < messageCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@CL_TextMes
$LN9@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@CL_TextMes:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _messageCount$[ebp]
	jge	$LN10@CL_TextMes

; 334  : 	{
; 335  : 		clgame.titles[i].pName += nameOffset;			// adjust name pointer (parallel buffer)

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+255288
	mov	edx, DWORD PTR [ecx+eax+36]
	add	edx, DWORD PTR _nameOffset$[ebp]
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+255288
	mov	DWORD PTR [ecx+eax+36], edx

; 336  : 		Q_strcpy( pCurrentText, clgame.titles[i].pMessage );	// copy text over

	push	99999					; 0001869fH
	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+255288
	mov	edx, DWORD PTR [ecx+eax+40]
	push	edx
	mov	eax, DWORD PTR _pCurrentText$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 337  : 		clgame.titles[i].pMessage = pCurrentText;

	imul	eax, DWORD PTR _i$[ebp], 44
	mov	ecx, DWORD PTR _clgame+255288
	mov	edx, DWORD PTR _pCurrentText$[ebp]
	mov	DWORD PTR [ecx+eax+40], edx

; 338  : 		pCurrentText += Q_strlen( pCurrentText ) + 1;

	mov	eax, DWORD PTR _pCurrentText$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pCurrentText$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pCurrentText$[ebp], edx

; 339  : 	}

	jmp	$LN9@CL_TextMes
$LN10@CL_TextMes:

; 340  : 
; 341  : 	if(( pCurrentText - (char *)clgame.titles ) != ( textHeapSize + nameHeapSize + messageSize ))

	mov	eax, DWORD PTR _pCurrentText$[ebp]
	sub	eax, DWORD PTR _clgame+255288
	mov	ecx, DWORD PTR _textHeapSize$[ebp]
	add	ecx, DWORD PTR _nameHeapSize$[ebp]
	add	ecx, DWORD PTR _messageSize$[ebp]
	cmp	eax, ecx
	je	SHORT $LN23@CL_TextMes

; 342  : 		Con_DPrintf( S_ERROR "TextMessage: overflow text message buffer!\n" );

	push	OFFSET ??_C@_0DH@FFPJPLBB@?$FO1Error?3?$FO7?5TextMessage?3?5overflo@
	call	_Con_DPrintf
	add	esp, 4
$LN23@CL_TextMes:

; 343  : 
; 344  : 	clgame.numTitles = messageCount;

	mov	eax, DWORD PTR _messageCount$[ebp]
	mov	DWORD PTR _clgame+255292, eax
$LN1@CL_TextMes:

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TextMessageParse ENDP
_TEXT	ENDS
END
