; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sv_client.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_clc_strings
PUBLIC	??_C@_07GFCHLEIN@clc_bad@			; `string'
PUBLIC	??_C@_07LMBPBGK@clc_nop@			; `string'
PUBLIC	??_C@_08PGMLNADH@clc_move@			; `string'
PUBLIC	??_C@_0O@MPLAIAKG@clc_stringcmd@		; `string'
PUBLIC	??_C@_09ILFCADOM@clc_delta@			; `string'
PUBLIC	??_C@_0BB@DGILCFHG@clc_resourcelist@		; `string'
PUBLIC	??_C@_0M@GINOJNK@clc_unused6@			; `string'
PUBLIC	??_C@_0BE@LHECKONJ@clc_fileconsistency@		; `string'
PUBLIC	??_C@_0O@GLEDMLFP@clc_voicedata@		; `string'
PUBLIC	??_C@_0O@GCINHBLN@clc_cvarvalue@		; `string'
PUBLIC	??_C@_0P@FIMCBGDB@clc_cvarvalue2@		; `string'
PUBLIC	_ucmds
PUBLIC	??_C@_03CLCAEGCJ@new@				; `string'
PUBLIC	??_C@_03DKFAMNOH@god@				; `string'
PUBLIC	??_C@_04BJJEOANI@kill@				; `string'
PUBLIC	??_C@_05EAFKHBAM@begin@				; `string'
PUBLIC	??_C@_05BDADGJGG@spawn@				; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_06IHODGGMJ@noclip@			; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_07BANLMPIG@setinfo@			; `string'
PUBLIC	??_C@_07LEPICBOJ@sendres@			; `string'
PUBLIC	??_C@_08HPLPOCJL@notarget@			; `string'
PUBLIC	??_C@_04NIDJFNBE@info@				; `string'
PUBLIC	??_C@_06GLEHBAJE@dlfile@			; `string'
PUBLIC	??_C@_0L@KKPFIJOL@disconnect@			; `string'
PUBLIC	??_C@_08PPJNGBMG@userinfo@			; `string'
EXTRN	_SV_ServerLog_f:PROC
;	COMDAT ??_C@_08PPJNGBMG@userinfo@
CONST	SEGMENT
??_C@_08PPJNGBMG@userinfo@ DB 'userinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKPFIJOL@disconnect@
CONST	SEGMENT
??_C@_0L@KKPFIJOL@disconnect@ DB 'disconnect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLEHBAJE@dlfile@
CONST	SEGMENT
??_C@_06GLEHBAJE@dlfile@ DB 'dlfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIDJFNBE@info@
CONST	SEGMENT
??_C@_04NIDJFNBE@info@ DB 'info', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HPLPOCJL@notarget@
CONST	SEGMENT
??_C@_08HPLPOCJL@notarget@ DB 'notarget', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEPICBOJ@sendres@
CONST	SEGMENT
??_C@_07LEPICBOJ@sendres@ DB 'sendres', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BANLMPIG@setinfo@
CONST	SEGMENT
??_C@_07BANLMPIG@setinfo@ DB 'setinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IHODGGMJ@noclip@
CONST	SEGMENT
??_C@_06IHODGGMJ@noclip@ DB 'noclip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BDADGJGG@spawn@
CONST	SEGMENT
??_C@_05BDADGJGG@spawn@ DB 'spawn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAFKHBAM@begin@
CONST	SEGMENT
??_C@_05EAFKHBAM@begin@ DB 'begin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJJEOANI@kill@
CONST	SEGMENT
??_C@_04BJJEOANI@kill@ DB 'kill', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DKFAMNOH@god@
CONST	SEGMENT
??_C@_03DKFAMNOH@god@ DB 'god', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLCAEGCJ@new@
CONST	SEGMENT
??_C@_03CLCAEGCJ@new@ DB 'new', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIMCBGDB@clc_cvarvalue2@
CONST	SEGMENT
??_C@_0P@FIMCBGDB@clc_cvarvalue2@ DB 'clc_cvarvalue2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCINHBLN@clc_cvarvalue@
CONST	SEGMENT
??_C@_0O@GCINHBLN@clc_cvarvalue@ DB 'clc_cvarvalue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLEDMLFP@clc_voicedata@
CONST	SEGMENT
??_C@_0O@GLEDMLFP@clc_voicedata@ DB 'clc_voicedata', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHECKONJ@clc_fileconsistency@
CONST	SEGMENT
??_C@_0BE@LHECKONJ@clc_fileconsistency@ DB 'clc_fileconsistency', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GINOJNK@clc_unused6@
CONST	SEGMENT
??_C@_0M@GINOJNK@clc_unused6@ DB 'clc_unused6', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGILCFHG@clc_resourcelist@
CONST	SEGMENT
??_C@_0BB@DGILCFHG@clc_resourcelist@ DB 'clc_resourcelist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILFCADOM@clc_delta@
CONST	SEGMENT
??_C@_09ILFCADOM@clc_delta@ DB 'clc_delta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MPLAIAKG@clc_stringcmd@
CONST	SEGMENT
??_C@_0O@MPLAIAKG@clc_stringcmd@ DB 'clc_stringcmd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PGMLNADH@clc_move@
CONST	SEGMENT
??_C@_08PGMLNADH@clc_move@ DB 'clc_move', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMBPBGK@clc_nop@
CONST	SEGMENT
??_C@_07LMBPBGK@clc_nop@ DB 'clc_nop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFCHLEIN@clc_bad@
CONST	SEGMENT
??_C@_07GFCHLEIN@clc_bad@ DB 'clc_bad', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_clc_strings DD	FLAT:??_C@_07GFCHLEIN@clc_bad@
	DD	FLAT:??_C@_07LMBPBGK@clc_nop@
	DD	FLAT:??_C@_08PGMLNADH@clc_move@
	DD	FLAT:??_C@_0O@MPLAIAKG@clc_stringcmd@
	DD	FLAT:??_C@_09ILFCADOM@clc_delta@
	DD	FLAT:??_C@_0BB@DGILCFHG@clc_resourcelist@
	DD	FLAT:??_C@_0M@GINOJNK@clc_unused6@
	DD	FLAT:??_C@_0BE@LHECKONJ@clc_fileconsistency@
	DD	FLAT:??_C@_0O@GLEDMLFP@clc_voicedata@
	DD	FLAT:??_C@_0O@GCINHBLN@clc_cvarvalue@
	DD	FLAT:??_C@_0P@FIMCBGDB@clc_cvarvalue2@
	ORG $+4
_ucmds	DD	FLAT:??_C@_03CLCAEGCJ@new@
	DD	FLAT:_SV_New_f
	DD	FLAT:??_C@_03DKFAMNOH@god@
	DD	FLAT:_SV_Godmode_f
	DD	FLAT:??_C@_04BJJEOANI@kill@
	DD	FLAT:_SV_Kill_f
	DD	FLAT:??_C@_05EAFKHBAM@begin@
	DD	FLAT:_SV_Begin_f
	DD	FLAT:??_C@_05BDADGJGG@spawn@
	DD	FLAT:_SV_Spawn_f
	DD	FLAT:??_C@_05PDJBBECF@pause@
	DD	FLAT:_SV_Pause_f
	DD	FLAT:??_C@_06IHODGGMJ@noclip@
	DD	FLAT:_SV_Noclip_f
	DD	FLAT:??_C@_03MGHMBJCF@log@
	DD	FLAT:_SV_ServerLog_f
	DD	FLAT:??_C@_07BANLMPIG@setinfo@
	DD	FLAT:_SV_SetInfo_f
	DD	FLAT:??_C@_07LEPICBOJ@sendres@
	DD	FLAT:_SV_SendRes_f
	DD	FLAT:??_C@_08HPLPOCJL@notarget@
	DD	FLAT:_SV_Notarget_f
	DD	FLAT:??_C@_04NIDJFNBE@info@
	DD	FLAT:_SV_ShowServerinfo_f
	DD	FLAT:??_C@_06GLEHBAJE@dlfile@
	DD	FLAT:_SV_DownloadFile_f
	DD	FLAT:??_C@_0L@KKPFIJOL@disconnect@
	DD	FLAT:_SV_Disconnect_f
	DD	FLAT:??_C@_08PPJNGBMG@userinfo@
	DD	FLAT:_SV_UpdateUserinfo_f
	DD	00H
	DD	00H
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetRealBytesWritten
PUBLIC	_MSG_GetNumBitsWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_MSG_GetData
PUBLIC	_SV_DropClient
PUBLIC	_SV_UserinfoChanged
PUBLIC	_SV_RemoteCommand
PUBLIC	_SV_RefreshUserinfo
PUBLIC	_SV_GetChallenge
PUBLIC	_SV_TogglePause
PUBLIC	_SV_ShouldUpdatePing
PUBLIC	_SV_GetClientIDString
PUBLIC	_SV_FullClientUpdate
PUBLIC	_SV_FullUpdateMovevars
PUBLIC	_SV_GetPlayerStats
PUBLIC	_SV_SendServerdata
PUBLIC	_SV_ExecuteClientMessage
PUBLIC	_SV_ConnectionlessPacket
PUBLIC	_SV_FakeConnect
PUBLIC	_SV_ExecuteClientCommand
PUBLIC	_SV_BuildReconnect
PUBLIC	_SV_IsPlayerIndex
PUBLIC	_SV_CalcPing
PUBLIC	_SV_EndRedirect
PUBLIC	_SV_GetFragmentSize
PUBLIC	_SV_RejectConnection
PUBLIC	_SV_FailDownload
PUBLIC	_SV_CheckChallenge
PUBLIC	_SV_CheckIPRestrictions
PUBLIC	_SV_FindEmptySlot
PUBLIC	_SV_ConnectClient
PUBLIC	_SV_BeginRedirect
PUBLIC	_SV_FlushRedirect
PUBLIC	_SV_TestBandWidth
PUBLIC	_SV_Ack
PUBLIC	_SV_Info
PUBLIC	_SV_BuildNetAnswer
PUBLIC	_SV_Ping
PUBLIC	_Rcon_Validate
PUBLIC	_SV_EstablishTimeBase
PUBLIC	_SV_CalcClientTime
PUBLIC	_SV_PutClientInServer
PUBLIC	_SV_UpdateClientView
PUBLIC	_SV_WriteDeltaDescriptionToClient
PUBLIC	_SV_TSourceEngineQuery
PUBLIC	_SV_ParseResourceList
PUBLIC	_SV_ParseCvarValue
PUBLIC	_SV_ParseCvarValue2
PUBLIC	??_C@_0N@KABAGPMO@challenge?5?$CFi@		; `string'
PUBLIC	??_C@_08IGNJNAKN@cl_dlmax@			; `string'
PUBLIC	??_C@_0CD@KFMFNEGJ@?$CFs?5connection?5refused?4?5Reason?3?5@ ; `string'
PUBLIC	??_C@_0CP@DPENDPLB@print?6?$FO1Server?5was?5reject?5the?5c@ ; `string'
PUBLIC	??_C@_0M@MNJNCGPD@disconnect?6@			; `string'
PUBLIC	??_C@_0BP@NAEOINNF@no?5challenge?5for?5your?5address?6@ ; `string'
PUBLIC	??_C@_0BA@OEEOOGPP@server?5is?5full?6@		; `string'
PUBLIC	?__LINE__Var@?0??SV_ConnectClient@@9@9		; `SV_ConnectClient'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@PBPHMGIF@insufficient?5connection?5info?6@ ; `string'
PUBLIC	??_C@_0CI@EIIIDCNK@unsupported?5protocol?5?$CI?$CFi?5should@ ; `string'
PUBLIC	??_C@_0CF@MHPLKMCG@invalid?5protinfo?5in?5connect?5com@ ; `string'
PUBLIC	??_C@_05IPCIHGO@qport@				; `string'
PUBLIC	??_C@_04BCJJGJPP@uuid@				; `string'
PUBLIC	??_C@_0CL@MJLLLANH@invalid?5authentication?5certific@ ; `string'
PUBLIC	??_C@_0DH@MCNPJPOI@LAN?5servers?5are?5restricted?5to?5l@ ; `string'
PUBLIC	??_C@_0CF@NCGDNHHH@invalid?5userinfo?5in?5connect?5com@ ; `string'
PUBLIC	??_C@_08NLHBPEGP@password@			; `string'
PUBLIC	??_C@_0BC@HLBFGPEN@invalid?5password?6@		; `string'
PUBLIC	??_C@_0BI@OIEFBMDN@?$FO2Note?3?$FO7?5?$CFs?3reconnect?6@ ; `string'
PUBLIC	??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_08COCEEGAP@Datagram@			; `string'
PUBLIC	??_C@_0P@IOGHOCLL@client_connect@		; `string'
PUBLIC	??_C@_0CI@JJFACAMK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_FakeConnect@@9@9		; `SV_FakeConnect'::`1'::__LINE__Var
PUBLIC	??_C@_03OHHOIALK@Bot@				; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_06FKIDPGKK@gordon@			; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_08OLGKFJAO@topcolor@			; `string'
PUBLIC	??_C@_0M@IIFIMDEK@bottomcolor@			; `string'
PUBLIC	??_C@_0CL@GOELOEAP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_DropClient@@9@9		; `SV_DropClient'::`1'::__LINE__Var
PUBLIC	??_C@_08HCILNBCA@print?6?$CFs@			; `string'
PUBLIC	??_C@_0DG@MHGFLFH@?$FO1Error?3?$FO7?5SV_FlushRedirect?3?5?$CFs@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_06JIGMCFA@ID_BOT@				; `string'
PUBLIC	??_C@_0M@BBHCLPEK@ID_LOOPBACK@			; `string'
PUBLIC	??_C@_06FDOKGCLC@ID_LAN@			; `string'
PUBLIC	??_C@_05GCODEKLL@ID_?$CFs@			; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_07IPHJHJLD@gfx?4wad@			; `string'
PUBLIC	??_C@_0BA@KODPIFE@BandWidthPacket@		; `string'
PUBLIC	??_C@_0L@BEEDAEFO@testpacket@			; `string'
PUBLIC	??_C@_08BCPMNFMF@ping?5?$CFs?6@			; `string'
PUBLIC	??_C@_0BD@OIMKEPNL@?$CFs?3?5wrong?5version?6@	; `string'
PUBLIC	??_C@_04OODOLJMA@host@				; `string'
PUBLIC	??_C@_03HBNNNHNM@map@				; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi@				; `string'
PUBLIC	??_C@_02JPDDFAPL@dm@				; `string'
PUBLIC	??_C@_04KADBPNCB@team@				; `string'
PUBLIC	??_C@_04OILOBHMB@coop@				; `string'
PUBLIC	??_C@_05HGECBMF@numcl@				; `string'
PUBLIC	??_C@_05HDFHMFIE@maxcl@				; `string'
PUBLIC	??_C@_07GGMBKBFD@gamedir@			; `string'
PUBLIC	??_C@_07BOBGOODP@info?6?$CFs@			; `string'
PUBLIC	??_C@_08FCFPNNHF@protocol@			; `string'
PUBLIC	??_C@_08EJOEDJLI@neterror@			; `string'
PUBLIC	??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0N@JDEEPBCI@?$CFc?2?$CFs?2?$CFi?2?$CFf?2@	; `string'
PUBLIC	??_C@_08EHKIGBEA@hostname@			; `string'
PUBLIC	??_C@_07LKPDDKMO@current@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max@				; `string'
PUBLIC	??_C@_09MLGAJAED@undefined@			; `string'
PUBLIC	??_C@_03JBLJHHJA@ack@				; `string'
PUBLIC	??_C@_0BC@EHLDDKCE@Rcon?5from?5?$CFs?3?6?$CFs?6@ ; `string'
PUBLIC	??_C@_0BG@CBNMMMKJ@Rcon?3?5?$CC?$CFs?$CC?5from?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BP@EMFADBPO@?$FO1Error?3?$FO7?5Bad?5rcon_password?4?6@ ; `string'
PUBLIC	??_C@_05BEKPGMFA@Spawn@				; `string'
PUBLIC	??_C@_05HFINLBCI@save?1@			; `string'
PUBLIC	??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@		; `string'
PUBLIC	??_C@_04MLPCGCCJ@hltv@				; `string'
PUBLIC	??_C@_0N@BKPKGGIB@cd?5loop?5?$CF3d?6@		; `string'
PUBLIC	??_C@_08CAOOLPGL@invasion@			; `string'
PUBLIC	??_C@_05FPMBMOMC@test?6@			; `string'
PUBLIC	??_C@_0BK@LNONJGHE@spawn?5player?3?5overflowed?6@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0L@FBPMLECH@reconnect?6@			; `string'
PUBLIC	??_C@_0CI@HHNJMAIM@?6?$FO3BUILD?5?$CFd?5SERVER?5?$CI?$CFi?5CRC?$CJ?6Ser@ ; `string'
PUBLIC	??_C@_03ILBCOJBH@New@				; `string'
PUBLIC	??_C@_0BN@JEAEPECE@Connection?5rejected?5by?5game?6@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BF@FKGNFJNH@fullserverinfo?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BE@MCELCJJK@Pause?5not?5allowed?4?6@	; `string'
PUBLIC	??_C@_0BL@GFHKHDIC@Spectators?5can?5not?5pause?4?6@ ; `string'
PUBLIC	??_C@_0BI@JKOKILDM@?$FO2?$CFs?$FO7?5paused?5the?5game?6@ ; `string'
PUBLIC	??_C@_0BK@JIAPMADH@?$FO2?$CFs?$FO7?5unpaused?5the?5game?6@ ; `string'
PUBLIC	??_C@_07PMJAFAE@console@			; `string'
PUBLIC	??_C@_07LFIJDALL@unnamed@			; `string'
PUBLIC	??_C@_07IBEGINLN@?$CFs?5?$CI?$CFu?$CJ@		; `string'
PUBLIC	??_C@_04HCCHHEEF@rate@				; `string'
PUBLIC	??_C@_09EFLGBOKH@cl_nopred@			; `string'
PUBLIC	??_C@_05OMKMDA@cl_lc@				; `string'
PUBLIC	??_C@_05COECHLGF@cl_lw@				; `string'
PUBLIC	??_C@_0O@GLEIJHMA@cl_updaterate@		; `string'
PUBLIC	??_C@_09NFOPKLIK@sv_cheats@			; `string'
PUBLIC	??_C@_0L@MDMNIPJN@noclip?5ON?6@			; `string'
PUBLIC	??_C@_0M@MIKGJGLH@noclip?5OFF?6@		; `string'
PUBLIC	??_C@_0N@POKEKLLJ@godmode?5OFF?6@		; `string'
PUBLIC	??_C@_0M@MCLKHHDH@godmode?5ON?6@		; `string'
PUBLIC	??_C@_0O@FBINJHBB@notarget?5OFF?6@		; `string'
PUBLIC	??_C@_0N@OBJNJDJO@notarget?5ON?6@		; `string'
PUBLIC	?__LINE__Var@?0??SV_Kill_f@@9@9			; `SV_Kill_f'::`1'::__LINE__Var
PUBLIC	??_C@_0BP@DGBAKJMC@Can?8t?5suicide?5?9?5already?5dead?$CB?6@ ; `string'
PUBLIC	??_C@_0O@IMIDHLA@SendResources@			; `string'
PUBLIC	?__LINE__Var@?0??SV_DownloadFile_f@@9@9		; `SV_DownloadFile_f'::`1'::__LINE__Var
PUBLIC	??_C@_03JBGBEIGK@mdl@				; `string'
PUBLIC	??_C@_04HJKAGJBM@?$CBMD5@			; `string'
PUBLIC	??_C@_0L@DHBFCELB@custom?4hpk@			; `string'
PUBLIC	??_C@_0BD@EBKLBEDB@Server?5is?5paused?4?6@	; `string'
PUBLIC	??_C@_0CE@PCAOCCIJ@?8?$CFs?8?5is?5not?5valid?5from?5the?5cons@ ; `string'
PUBLIC	??_C@_0M@PKKNFAD@ucmd?9?$DO?$CFs?$CI?$CJ?6@	; `string'
PUBLIC	??_C@_0L@BAECHHDI@fullupdate@			; `string'
PUBLIC	??_C@_0BD@JHHJPGKC@TSourceEngineQuery@		; `string'
PUBLIC	??_C@_07CINOGAJB@fareast@			; `string'
PUBLIC	??_C@_03GKODMEGH@hl?4@				; `string'
PUBLIC	??_C@_0CC@BEHBECBG@SV_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@ ; `string'
PUBLIC	??_C@_04OONEELOO@ping@				; `string'
PUBLIC	??_C@_09PAHKGFGO@bandwidth@			; `string'
PUBLIC	??_C@_0N@FADCLAAC@getchallenge@			; `string'
PUBLIC	??_C@_07KAIBNCHO@connect@			; `string'
PUBLIC	??_C@_04CLKJCJJE@rcon@				; `string'
PUBLIC	??_C@_07PHGFOLHM@netinfo@			; `string'
PUBLIC	??_C@_01LKDEMHDF@s@				; `string'
PUBLIC	??_C@_07CDBHODM@TSource@			; `string'
PUBLIC	??_C@_01KBJDNOO@i@				; `string'
PUBLIC	??_C@_05JPBCIDCN@?$PP?$PP?$PP?$PPj@		; `string'
PUBLIC	??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@ ; `string'
PUBLIC	??_C@_0EA@NCHKBPHB@?$FO1Error?3?$FO7?5SV_ParseClientMove?3?5@ ; `string'
PUBLIC	??_C@_0ED@KEKJHFIF@?$FO1Error?3?$FO7?5SV_UserMove?3?5failed?5@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_ParseResourceList@@9@9	; `SV_ParseResourceList'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@FELOKCJM@Verifying?5and?5uploading?5resourc@ ; `string'
PUBLIC	??_C@_0BO@LCICNDAF@Custom?5resources?5total?5?$CF?42fK?6@ ; `string'
PUBLIC	??_C@_0BC@PBEPLNEK@?5?5Models?3?5?5?$CF?42fK?6@	; `string'
PUBLIC	??_C@_0BC@CNJCGBDI@?5?5Sounds?3?5?5?$CF?42fK?6@	; `string'
PUBLIC	??_C@_0BC@OOEPAONE@?5?5Decals?3?5?5?$CF?42fK?6@	; `string'
PUBLIC	??_C@_0BC@HCHFBGEM@?5?5Skins?5?3?5?5?$CF?42fK?6@ ; `string'
PUBLIC	??_C@_0BE@MEAONMDF@?5?5Generic?5?3?5?5?$CF?42fK?6@ ; `string'
PUBLIC	??_C@_0BE@DAFJBGEG@?5?5Events?5?5?3?5?5?$CF?42fK?6@ ; `string'
PUBLIC	??_C@_0BI@FLKKINBM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?6@ ; `string'
PUBLIC	??_C@_0BK@CNKJOPDO@resources?5to?5request?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CI@NDPJCJPA@Cvar?5query?5response?3?5name?3?$CFs?0?5v@ ; `string'
PUBLIC	??_C@_0EA@FCCJIFAN@Cvar?5query?5response?3?5name?3?$CFs?0?5r@ ; `string'
PUBLIC	?__LINE__Var@?0??SV_ExecuteClientMessage@@9@9	; `SV_ExecuteClientMessage'::`1'::__LINE__Var
PUBLIC	??_C@_0CF@LBJHNMOG@?$FO1Error?3?$FO7?5incoming?5overflow?5fo@ ; `string'
PUBLIC	??_C@_0BI@CCJPDDNB@?$FO1Error?3?$FO7?5?$CFs?3?5clc_bad?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f000000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fc99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@4090000000000000
PUBLIC	__real@40c3878000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@447a0000
PUBLIC	__real@44800000
PUBLIC	__real@461c3c00
PUBLIC	__real@47c35000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c0f869f000000000
PUBLIC	__real@c61c3c00
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_TokenizeString:PROC
EXTRN	_Cmd_ExecuteString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_NET_IsReservedAdr:PROC
EXTRN	_NET_CompareClassBAdr:PROC
EXTRN	_NET_CompareAdr:PROC
EXTRN	_NET_CompareBaseAdr:PROC
EXTRN	_NET_SendPacket:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_FileLength:PROC
EXTRN	_Q_buildnum:PROC
EXTRN	_Host_Error:PROC
EXTRN	_COM_HexConvert:PROC
EXTRN	_COM_IsSafeFileToDownload:PROC
EXTRN	_COM_TrimSpace:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CRC32_BlockSequence:PROC
EXTRN	_CRC32_ProcessBuffer:PROC
EXTRN	_MD5Init:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5_Print:PROC
EXTRN	_COM_ClearCustomizationList:PROC
EXTRN	_COM_SizeofResourceList:PROC
EXTRN	_HPAK_GetDataPointer:PROC
EXTRN	_HPAK_ResourceForHash:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_Log_Printf:PROC
EXTRN	_SV_BroadcastPrintf:PROC
EXTRN	_UI_CreditsActive:PROC
EXTRN	_SV_Serverinfo:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Info_RemovePrefixedKeys:PROC
EXTRN	_Info_SetValueForKey:PROC
EXTRN	_Info_IsValid:PROC
EXTRN	_Info_Print:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_fabs:PROC
EXTRN	_Mod_StudioTexName:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_SeekToBit:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteOneBit:PROC
EXTRN	_MSG_WriteUBitLong:PROC
EXTRN	_MSG_WriteBits:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteChar:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteFloat:PROC
EXTRN	_MSG_WriteVec3Angles:PROC
EXTRN	_MSG_WriteBytes:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_Netchan_Setup:PROC
EXTRN	_Netchan_CreateFileFragmentsFromBuffer:PROC
EXTRN	_Netchan_CreateFragments:PROC
EXTRN	_Netchan_CreateFileFragments:PROC
EXTRN	_Netchan_TransmitBits:PROC
EXTRN	_Netchan_OutOfBand:PROC
EXTRN	_Netchan_OutOfBandPrint:PROC
EXTRN	_Netchan_IsLocal:PROC
EXTRN	_Netchan_FragSend:PROC
EXTRN	_Netchan_Clear:PROC
EXTRN	_SV_AddToMaster:PROC
EXTRN	_SV_ModelHandle:PROC
EXTRN	_SV_ClientPrintf:PROC
EXTRN	_SV_RunCmd:PROC
EXTRN	_SV_AddToResourceList:PROC
EXTRN	_SV_ParseConsistencyResponse:PROC
EXTRN	_SV_EstimateNeededResources:PROC
EXTRN	_SV_ClearResourceList:PROC
EXTRN	_SV_BatchUploadRequest:PROC
EXTRN	_SV_SendResources:PROC
EXTRN	_SV_ClearResourceLists:PROC
EXTRN	_SV_InitEdict:PROC
EXTRN	_SV_CheckEdict:PROC
EXTRN	_SV_MakeString:PROC
EXTRN	_SV_GetString:PROC
EXTRN	_SV_SendUserReg:PROC
EXTRN	_SV_RestartAmbientSounds:PROC
EXTRN	_SV_RestartDecals:PROC
EXTRN	_SV_RestartStaticEnts:PROC
EXTRN	_SV_EdictNum:PROC
EXTRN	_SV_PlayerIsFrozen:PROC
EXTRN	_Delta_NumTables:PROC
EXTRN	_Delta_FindStructByIndex:PROC
EXTRN	_Delta_WriteTableField:PROC
EXTRN	_MSG_ReadDeltaUsercmd:PROC
EXTRN	_MSG_WriteDeltaMovevars:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_net_local:BYTE
EXTRN	_sv_lan:BYTE
EXTRN	_net_drop:DWORD
EXTRN	_SV_UPDATE_BACKUP:DWORD
EXTRN	_svs:BYTE
EXTRN	_sv:BYTE
EXTRN	_svgame:BYTE
EXTRN	_sv_unlagsamples:BYTE
EXTRN	_rcon_password:BYTE
EXTRN	_sv_send_resources:BYTE
EXTRN	_sv_send_logos:BYTE
EXTRN	_sv_allow_upload:BYTE
EXTRN	_sv_allow_download:BYTE
EXTRN	_sv_password:BYTE
EXTRN	_sv_uploadmax:BYTE
EXTRN	_hostname:BYTE
EXTRN	_sv_pausable:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?result@?1??SV_GetClientIDString@@9@9 DB 040H DUP (?)	; `SV_GetClientIDString'::`2'::result
?outputbuf@?1??SV_RemoteCommand@@9@9 DB 0800H DUP (?)	; `SV_RemoteCommand'::`2'::outputbuf
?last_ping@?1??SV_GetPlayerStats@@9@9 DD 020H DUP (?)	; `SV_GetPlayerStats'::`2'::last_ping
?last_loss@?1??SV_GetPlayerStats@@9@9 DD 020H DUP (?)	; `SV_GetPlayerStats'::`2'::last_loss
?msg_buf@?1??SV_PutClientInServer@@9@9 DB 040400H DUP (?) ; `SV_PutClientInServer'::`2'::msg_buf
_BSS	ENDS
;	COMDAT __real@c61c3c00
CONST	SEGMENT
__real@c61c3c00 DD 0c61c3c00r			; -9999
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@40c3878000000000
CONST	SEGMENT
__real@40c3878000000000 DQ 040c3878000000000r	; 9999
CONST	ENDS
;	COMDAT __real@4090000000000000
CONST	SEGMENT
__real@4090000000000000 DQ 04090000000000000r	; 1024
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc99999a0000000
CONST	SEGMENT
__real@3fc99999a0000000 DQ 03fc99999a0000000r	; 0.2
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BI@CCJPDDNB@?$FO1Error?3?$FO7?5?$CFs?3?5clc_bad?6@
CONST	SEGMENT
??_C@_0BI@CCJPDDNB@?$FO1Error?3?$FO7?5?$CFs?3?5clc_bad?6@ DB '^1Error:^7 '
	DB	'%s: clc_bad', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LBJHNMOG@?$FO1Error?3?$FO7?5incoming?5overflow?5fo@
CONST	SEGMENT
??_C@_0CF@LBJHNMOG@?$FO1Error?3?$FO7?5incoming?5overflow?5fo@ DB '^1Error'
	DB	':^7 incoming overflow for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ExecuteClientMessage@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ExecuteClientMessage@@9@9 DD 0948H	; `SV_ExecuteClientMessage'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EA@FCCJIFAN@Cvar?5query?5response?3?5name?3?$CFs?0?5r@
CONST	SEGMENT
??_C@_0EA@FCCJIFAN@Cvar?5query?5response?3?5name?3?$CFs?0?5r@ DB 'Cvar qu'
	DB	'ery response: name:%s, request ID %d, cvar:%s, value:%s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NDPJCJPA@Cvar?5query?5response?3?5name?3?$CFs?0?5v@
CONST	SEGMENT
??_C@_0CI@NDPJCJPA@Cvar?5query?5response?3?5name?3?$CFs?0?5v@ DB 'Cvar qu'
	DB	'ery response: name:%s, value:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CNKJOPDO@resources?5to?5request?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@CNKJOPDO@resources?5to?5request?3?5?$CFs?6@ DB 'resources to re'
	DB	'quest: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLKKINBM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?6@
CONST	SEGMENT
??_C@_0BI@FLKKINBM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?6@ DB '--'
	DB	'--------------------', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAFJBGEG@?5?5Events?5?5?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BE@DAFJBGEG@?5?5Events?5?5?3?5?5?$CF?42fK?6@ DB '  Events  :  %.2f'
	DB	'K', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MEAONMDF@?5?5Generic?5?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BE@MEAONMDF@?5?5Generic?5?3?5?5?$CF?42fK?6@ DB '  Generic :  %.2fK'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HCHFBGEM@?5?5Skins?5?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BC@HCHFBGEM@?5?5Skins?5?3?5?5?$CF?42fK?6@ DB '  Skins :  %.2fK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OOEPAONE@?5?5Decals?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BC@OOEPAONE@?5?5Decals?3?5?5?$CF?42fK?6@ DB '  Decals:  %.2fK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNJCGBDI@?5?5Sounds?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BC@CNJCGBDI@?5?5Sounds?3?5?5?$CF?42fK?6@ DB '  Sounds:  %.2fK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PBEPLNEK@?5?5Models?3?5?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BC@PBEPLNEK@?5?5Models?3?5?5?$CF?42fK?6@ DB '  Models:  %.2fK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LCICNDAF@Custom?5resources?5total?5?$CF?42fK?6@
CONST	SEGMENT
??_C@_0BO@LCICNDAF@Custom?5resources?5total?5?$CF?42fK?6@ DB 'Custom reso'
	DB	'urces total %.2fK', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FELOKCJM@Verifying?5and?5uploading?5resourc@
CONST	SEGMENT
??_C@_0CG@FELOKCJM@Verifying?5and?5uploading?5resourc@ DB 'Verifying and '
	DB	'uploading resources...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ParseResourceList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ParseResourceList@@9@9 DD 08cbH	; `SV_ParseResourceList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0ED@KEKJHFIF@?$FO1Error?3?$FO7?5SV_UserMove?3?5failed?5@
CONST	SEGMENT
??_C@_0ED@KEKJHFIF@?$FO1Error?3?$FO7?5SV_UserMove?3?5failed?5@ DB '^1Erro'
	DB	'r:^7 SV_UserMove: failed command checksum for %s (%d != %d)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NCHKBPHB@?$FO1Error?3?$FO7?5SV_ParseClientMove?3?5@
CONST	SEGMENT
??_C@_0EA@NCHKBPHB@?$FO1Error?3?$FO7?5SV_ParseClientMove?3?5@ DB '^1Error'
	DB	':^7 SV_ParseClientMove: %s sending too many commands %i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@
CONST	SEGMENT
??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@ DB '^1Error'
	DB	':^7 bad connectionless packet from %s:', 0aH, '%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPBCIDCN@?$PP?$PP?$PP?$PPj@
CONST	SEGMENT
??_C@_05JPBCIDCN@?$PP?$PP?$PP?$PPj@ DB 0ffH, 0ffH, 0ffH, 0ffH, 'j', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i@
CONST	SEGMENT
??_C@_01KBJDNOO@i@ DB 'i', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CDBHODM@TSource@
CONST	SEGMENT
??_C@_07CDBHODM@TSource@ DB 'TSource', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s@
CONST	SEGMENT
??_C@_01LKDEMHDF@s@ DB 's', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHGFOLHM@netinfo@
CONST	SEGMENT
??_C@_07PHGFOLHM@netinfo@ DB 'netinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLKJCJJE@rcon@
CONST	SEGMENT
??_C@_04CLKJCJJE@rcon@ DB 'rcon', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KAIBNCHO@connect@
CONST	SEGMENT
??_C@_07KAIBNCHO@connect@ DB 'connect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FADCLAAC@getchallenge@
CONST	SEGMENT
??_C@_0N@FADCLAAC@getchallenge@ DB 'getchallenge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PAHKGFGO@bandwidth@
CONST	SEGMENT
??_C@_09PAHKGFGO@bandwidth@ DB 'bandwidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OONEELOO@ping@
CONST	SEGMENT
??_C@_04OONEELOO@ping@ DB 'ping', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BEHBECBG@SV_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@BEHBECBG@SV_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@ DB 'SV_Con'
	DB	'nectionlessPacket: %s : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GKODMEGH@hl?4@
CONST	SEGMENT
??_C@_03GKODMEGH@hl?4@ DB 'hl.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CINOGAJB@fareast@
CONST	SEGMENT
??_C@_07CINOGAJB@fareast@ DB 'fareast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JHHJPGKC@TSourceEngineQuery@
CONST	SEGMENT
??_C@_0BD@JHHJPGKC@TSourceEngineQuery@ DB 'TSourceEngineQuery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BAECHHDI@fullupdate@
CONST	SEGMENT
??_C@_0L@BAECHHDI@fullupdate@ DB 'fullupdate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKKNFAD@ucmd?9?$DO?$CFs?$CI?$CJ?6@
CONST	SEGMENT
??_C@_0M@PKKNFAD@ucmd?9?$DO?$CFs?$CI?$CJ?6@ DB 'ucmd->%s()', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PCAOCCIJ@?8?$CFs?8?5is?5not?5valid?5from?5the?5cons@
CONST	SEGMENT
??_C@_0CE@PCAOCCIJ@?8?$CFs?8?5is?5not?5valid?5from?5the?5cons@ DB '''%s'''
	DB	' is not valid from the console', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EBKLBEDB@Server?5is?5paused?4?6@
CONST	SEGMENT
??_C@_0BD@EBKLBEDB@Server?5is?5paused?4?6@ DB 'Server is paused.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHBFCELB@custom?4hpk@
CONST	SEGMENT
??_C@_0L@DHBFCELB@custom?4hpk@ DB 'custom.hpk', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJKAGJBM@?$CBMD5@
CONST	SEGMENT
??_C@_04HJKAGJBM@?$CBMD5@ DB '!MD5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBGBEIGK@mdl@
CONST	SEGMENT
??_C@_03JBGBEIGK@mdl@ DB 'mdl', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_DownloadFile_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_DownloadFile_f@@9@9 DD 071dH	; `SV_DownloadFile_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@IMIDHLA@SendResources@
CONST	SEGMENT
??_C@_0O@IMIDHLA@SendResources@ DB 'SendResources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DGBAKJMC@Can?8t?5suicide?5?9?5already?5dead?$CB?6@
CONST	SEGMENT
??_C@_0BP@DGBAKJMC@Can?8t?5suicide?5?9?5already?5dead?$CB?6@ DB 'Can''t s'
	DB	'uicide - already dead!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_Kill_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_Kill_f@@9@9 DD 06edH		; `SV_Kill_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@OBJNJDJO@notarget?5ON?6@
CONST	SEGMENT
??_C@_0N@OBJNJDJO@notarget?5ON?6@ DB 'notarget ON', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FBINJHBB@notarget?5OFF?6@
CONST	SEGMENT
??_C@_0O@FBINJHBB@notarget?5OFF?6@ DB 'notarget OFF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCLKHHDH@godmode?5ON?6@
CONST	SEGMENT
??_C@_0M@MCLKHHDH@godmode?5ON?6@ DB 'godmode ON', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POKEKLLJ@godmode?5OFF?6@
CONST	SEGMENT
??_C@_0N@POKEKLLJ@godmode?5OFF?6@ DB 'godmode OFF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MIKGJGLH@noclip?5OFF?6@
CONST	SEGMENT
??_C@_0M@MIKGJGLH@noclip?5OFF?6@ DB 'noclip OFF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDMNIPJN@noclip?5ON?6@
CONST	SEGMENT
??_C@_0L@MDMNIPJN@noclip?5ON?6@ DB 'noclip ON', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFOPKLIK@sv_cheats@
CONST	SEGMENT
??_C@_09NFOPKLIK@sv_cheats@ DB 'sv_cheats', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLEIJHMA@cl_updaterate@
CONST	SEGMENT
??_C@_0O@GLEIJHMA@cl_updaterate@ DB 'cl_updaterate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05COECHLGF@cl_lw@
CONST	SEGMENT
??_C@_05COECHLGF@cl_lw@ DB 'cl_lw', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMKMDA@cl_lc@
CONST	SEGMENT
??_C@_05OMKMDA@cl_lc@ DB 'cl_lc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFLGBOKH@cl_nopred@
CONST	SEGMENT
??_C@_09EFLGBOKH@cl_nopred@ DB 'cl_nopred', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCCHHEEF@rate@
CONST	SEGMENT
??_C@_04HCCHHEEF@rate@ DB 'rate', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBEGINLN@?$CFs?5?$CI?$CFu?$CJ@
CONST	SEGMENT
??_C@_07IBEGINLN@?$CFs?5?$CI?$CFu?$CJ@ DB '%s (%u)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFIJDALL@unnamed@
CONST	SEGMENT
??_C@_07LFIJDALL@unnamed@ DB 'unnamed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PMJAFAE@console@
CONST	SEGMENT
??_C@_07PMJAFAE@console@ DB 'console', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JIAPMADH@?$FO2?$CFs?$FO7?5unpaused?5the?5game?6@
CONST	SEGMENT
??_C@_0BK@JIAPMADH@?$FO2?$CFs?$FO7?5unpaused?5the?5game?6@ DB '^2%s^7 unp'
	DB	'aused the game', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JKOKILDM@?$FO2?$CFs?$FO7?5paused?5the?5game?6@
CONST	SEGMENT
??_C@_0BI@JKOKILDM@?$FO2?$CFs?$FO7?5paused?5the?5game?6@ DB '^2%s^7 pause'
	DB	'd the game', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GFHKHDIC@Spectators?5can?5not?5pause?4?6@
CONST	SEGMENT
??_C@_0BL@GFHKHDIC@Spectators?5can?5not?5pause?4?6@ DB 'Spectators can no'
	DB	't pause.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MCELCJJK@Pause?5not?5allowed?4?6@
CONST	SEGMENT
??_C@_0BE@MCELCJJK@Pause?5not?5allowed?4?6@ DB 'Pause not allowed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKGNFJNH@fullserverinfo?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BF@FKGNFJNH@fullserverinfo?5?$CC?$CFs?$CC?6@ DB 'fullserverinfo "%'
	DB	's"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JEAEPECE@Connection?5rejected?5by?5game?6@
CONST	SEGMENT
??_C@_0BN@JEAEPECE@Connection?5rejected?5by?5game?6@ DB 'Connection rejec'
	DB	'ted by game', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ILBCOJBH@New@
CONST	SEGMENT
??_C@_03ILBCOJBH@New@ DB 'New', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HHNJMAIM@?6?$FO3BUILD?5?$CFd?5SERVER?5?$CI?$CFi?5CRC?$CJ?6Ser@
CONST	SEGMENT
??_C@_0CI@HHNJMAIM@?6?$FO3BUILD?5?$CFd?5SERVER?5?$CI?$CFi?5CRC?$CJ?6Ser@ DB 0aH
	DB	'^3BUILD %d SERVER (%i CRC)', 0aH, 'Server #%i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBPMLECH@reconnect?6@
CONST	SEGMENT
??_C@_0L@FBPMLECH@reconnect?6@ DB 'reconnect', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNONJGHE@spawn?5player?3?5overflowed?6@
CONST	SEGMENT
??_C@_0BK@LNONJGHE@spawn?5player?3?5overflowed?6@ DB 'spawn player: overf'
	DB	'lowed', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPMBMOMC@test?6@
CONST	SEGMENT
??_C@_05FPMBMOMC@test?6@ DB 'test', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CAOOLPGL@invasion@
CONST	SEGMENT
??_C@_08CAOOLPGL@invasion@ DB 'invasion', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BKPKGGIB@cd?5loop?5?$CF3d?6@
CONST	SEGMENT
??_C@_0N@BKPKGGIB@cd?5loop?5?$CF3d?6@ DB 'cd loop %3d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLPCGCCJ@hltv@
CONST	SEGMENT
??_C@_04MLPCGCCJ@hltv@ DB 'hltv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
CONST	SEGMENT
??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@ DB '%s%s.HL2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFINLBCI@save?1@
CONST	SEGMENT
??_C@_05HFINLBCI@save?1@ DB 'save/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BEKPGMFA@Spawn@
CONST	SEGMENT
??_C@_05BEKPGMFA@Spawn@ DB 'Spawn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EMFADBPO@?$FO1Error?3?$FO7?5Bad?5rcon_password?4?6@
CONST	SEGMENT
??_C@_0BP@EMFADBPO@?$FO1Error?3?$FO7?5Bad?5rcon_password?4?6@ DB '^1Error'
	DB	':^7 Bad rcon_password.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CBNMMMKJ@Rcon?3?5?$CC?$CFs?$CC?5from?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BG@CBNMMMKJ@Rcon?3?5?$CC?$CFs?$CC?5from?5?$CC?$CFs?$CC?6@ DB 'Rcon'
	DB	': "%s" from "%s"', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EHLDDKCE@Rcon?5from?5?$CFs?3?6?$CFs?6@
CONST	SEGMENT
??_C@_0BC@EHLDDKCE@Rcon?5from?5?$CFs?3?6?$CFs?6@ DB 'Rcon from %s:', 0aH, '%'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBLJHHJA@ack@
CONST	SEGMENT
??_C@_03JBLJHHJA@ack@ DB 'ack', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLGAJAED@undefined@
CONST	SEGMENT
??_C@_09MLGAJAED@undefined@ DB 'undefined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max@
CONST	SEGMENT
??_C@_03LJAEFNNE@max@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKPDDKMO@current@
CONST	SEGMENT
??_C@_07LKPDDKMO@current@ DB 'current', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHKIGBEA@hostname@
CONST	SEGMENT
??_C@_08EHKIGBEA@hostname@ DB 'hostname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDEEPBCI@?$CFc?2?$CFs?2?$CFi?2?$CFf?2@
CONST	SEGMENT
??_C@_0N@JDEEPBCI@?$CFc?2?$CFs?2?$CFi?2?$CFf?2@ DB '%c\%s\%i\%f\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@ DB 'netinfo %i %i %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08EJOEDJLI@neterror@
CONST	SEGMENT
??_C@_08EJOEDJLI@neterror@ DB 'neterror', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCFPNNHF@protocol@
CONST	SEGMENT
??_C@_08FCFPNNHF@protocol@ DB 'protocol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BOBGOODP@info?6?$CFs@
CONST	SEGMENT
??_C@_07BOBGOODP@info?6?$CFs@ DB 'info', 0aH, '%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGMBKBFD@gamedir@
CONST	SEGMENT
??_C@_07GGMBKBFD@gamedir@ DB 'gamedir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDFHMFIE@maxcl@
CONST	SEGMENT
??_C@_05HDFHMFIE@maxcl@ DB 'maxcl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGECBMF@numcl@
CONST	SEGMENT
??_C@_05HGECBMF@numcl@ DB 'numcl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OILOBHMB@coop@
CONST	SEGMENT
??_C@_04OILOBHMB@coop@ DB 'coop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KADBPNCB@team@
CONST	SEGMENT
??_C@_04KADBPNCB@team@ DB 'team', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JPDDFAPL@dm@
CONST	SEGMENT
??_C@_02JPDDFAPL@dm@ DB 'dm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBNNNHNM@map@
CONST	SEGMENT
??_C@_03HBNNNHNM@map@ DB 'map', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OODOLJMA@host@
CONST	SEGMENT
??_C@_04OODOLJMA@host@ DB 'host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OIMKEPNL@?$CFs?3?5wrong?5version?6@
CONST	SEGMENT
??_C@_0BD@OIMKEPNL@?$CFs?3?5wrong?5version?6@ DB '%s: wrong version', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCPMNFMF@ping?5?$CFs?6@
CONST	SEGMENT
??_C@_08BCPMNFMF@ping?5?$CFs?6@ DB 'ping %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEEDAEFO@testpacket@
CONST	SEGMENT
??_C@_0L@BEEDAEFO@testpacket@ DB 'testpacket', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KODPIFE@BandWidthPacket@
CONST	SEGMENT
??_C@_0BA@KODPIFE@BandWidthPacket@ DB 'BandWidthPacket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPHJHJLD@gfx?4wad@
CONST	SEGMENT
??_C@_07IPHJHJLD@gfx?4wad@ DB 'gfx.wad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCODEKLL@ID_?$CFs@
CONST	SEGMENT
??_C@_05GCODEKLL@ID_?$CFs@ DB 'ID_%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDOKGCLC@ID_LAN@
CONST	SEGMENT
??_C@_06FDOKGCLC@ID_LAN@ DB 'ID_LAN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBHCLPEK@ID_LOOPBACK@
CONST	SEGMENT
??_C@_0M@BBHCLPEK@ID_LOOPBACK@ DB 'ID_LOOPBACK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIGMCFA@ID_BOT@
CONST	SEGMENT
??_C@_06JIGMCFA@ID_BOT@ DB 'ID_BOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MHGFLFH@?$FO1Error?3?$FO7?5SV_FlushRedirect?3?5?$CFs@
CONST	SEGMENT
??_C@_0DG@MHGFLFH@?$FO1Error?3?$FO7?5SV_FlushRedirect?3?5?$CFs@ DB '^1Err'
	DB	'or:^7 SV_FlushRedirect: %s: invalid destination', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HCILNBCA@print?6?$CFs@
CONST	SEGMENT
??_C@_08HCILNBCA@print?6?$CFs@ DB 'print', 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_DropClient@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_DropClient@@9@9 DD 01e0H		; `SV_DropClient'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CL@GOELOEAP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@
CONST	SEGMENT
??_C@_0CL@GOELOEAP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@ DB '"'
	DB	'%s<%i><%i><>" connected, address "local"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIFIMDEK@bottomcolor@
CONST	SEGMENT
??_C@_0M@IIFIMDEK@bottomcolor@ DB 'bottomcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLGKFJAO@topcolor@
CONST	SEGMENT
??_C@_08OLGKFJAO@topcolor@ DB 'topcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FKIDPGKK@gordon@
CONST	SEGMENT
??_C@_06FKIDPGKK@gordon@ DB 'gordon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OHHOIALK@Bot@
CONST	SEGMENT
??_C@_03OHHOIALK@Bot@ DB 'Bot', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_FakeConnect@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_FakeConnect@@9@9 DD 0199H		; `SV_FakeConnect'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CI@JJFACAMK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@
CONST	SEGMENT
??_C@_0CI@JJFACAMK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@ DB '"'
	DB	'%s<%i><%i><>" connected, address "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOGHOCLL@client_connect@
CONST	SEGMENT
??_C@_0P@IOGHOCLL@client_connect@ DB 'client_connect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08COCEEGAP@Datagram@
CONST	SEGMENT
??_C@_08COCEEGAP@Datagram@ DB 'Datagram', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\server\sv_client.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OIEFBMDN@?$FO2Note?3?$FO7?5?$CFs?3reconnect?6@
CONST	SEGMENT
??_C@_0BI@OIEFBMDN@?$FO2Note?3?$FO7?5?$CFs?3reconnect?6@ DB '^2Note:^7 %s'
	DB	':reconnect', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HLBFGPEN@invalid?5password?6@
CONST	SEGMENT
??_C@_0BC@HLBFGPEN@invalid?5password?6@ DB 'invalid password', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLHBPEGP@password@
CONST	SEGMENT
??_C@_08NLHBPEGP@password@ DB 'password', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NCGDNHHH@invalid?5userinfo?5in?5connect?5com@
CONST	SEGMENT
??_C@_0CF@NCGDNHHH@invalid?5userinfo?5in?5connect?5com@ DB 'invalid useri'
	DB	'nfo in connect command', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MCNPJPOI@LAN?5servers?5are?5restricted?5to?5l@
CONST	SEGMENT
??_C@_0DH@MCNPJPOI@LAN?5servers?5are?5restricted?5to?5l@ DB 'LAN servers '
	DB	'are restricted to local clients (class C)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MJLLLANH@invalid?5authentication?5certific@
CONST	SEGMENT
??_C@_0CL@MJLLLANH@invalid?5authentication?5certific@ DB 'invalid authent'
	DB	'ication certificate length', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCJJGJPP@uuid@
CONST	SEGMENT
??_C@_04BCJJGJPP@uuid@ DB 'uuid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPCIHGO@qport@
CONST	SEGMENT
??_C@_05IPCIHGO@qport@ DB 'qport', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MHPLKMCG@invalid?5protinfo?5in?5connect?5com@
CONST	SEGMENT
??_C@_0CF@MHPLKMCG@invalid?5protinfo?5in?5connect?5com@ DB 'invalid proti'
	DB	'nfo in connect command', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIIIDCNK@unsupported?5protocol?5?$CI?$CFi?5should@
CONST	SEGMENT
??_C@_0CI@EIIIDCNK@unsupported?5protocol?5?$CI?$CFi?5should@ DB 'unsuppor'
	DB	'ted protocol (%i should be %i)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PBPHMGIF@insufficient?5connection?5info?6@
CONST	SEGMENT
??_C@_0BO@PBPHMGIF@insufficient?5connection?5info?6@ DB 'insufficient con'
	DB	'nection info', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SV_ConnectClient@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??SV_ConnectClient@@9@9 DD 0e9H		; `SV_ConnectClient'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@OEEOOGPP@server?5is?5full?6@
CONST	SEGMENT
??_C@_0BA@OEEOOGPP@server?5is?5full?6@ DB 'server is full', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NAEOINNF@no?5challenge?5for?5your?5address?6@
CONST	SEGMENT
??_C@_0BP@NAEOINNF@no?5challenge?5for?5your?5address?6@ DB 'no challenge '
	DB	'for your address', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNJNCGPD@disconnect?6@
CONST	SEGMENT
??_C@_0M@MNJNCGPD@disconnect?6@ DB 'disconnect', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DPENDPLB@print?6?$FO1Server?5was?5reject?5the?5c@
CONST	SEGMENT
??_C@_0CP@DPENDPLB@print?6?$FO1Server?5was?5reject?5the?5c@ DB 'print', 0aH
	DB	'^1Server was reject the connection:^7 %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KFMFNEGJ@?$CFs?5connection?5refused?4?5Reason?3?5@
CONST	SEGMENT
??_C@_0CD@KFMFNEGJ@?$CFs?5connection?5refused?4?5Reason?3?5@ DB '%s conne'
	DB	'ction refused. Reason: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGNJNAKN@cl_dlmax@
CONST	SEGMENT
??_C@_08IGNJNAKN@cl_dlmax@ DB 'cl_dlmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KABAGPMO@challenge?5?$CFi@
CONST	SEGMENT
??_C@_0N@KABAGPMO@challenge?5?$CFi@ DB 'challenge %i', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_g_userid DD	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0cbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03fcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	05c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03dfH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02a1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	014H
	DB	0c0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0281H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	04e1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0619H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0284H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	024cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0945H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0479H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	034bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	047H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0142H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01aaH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05f3H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ParseCvarValue2
_TEXT	SEGMENT
_requestID$ = -520					; size = 4
_value$ = -516						; size = 256
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseCvarValue2 PROC				; COMDAT

; 2356 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 648				; 00000288H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2357 : 	string	name, value;
; 2358 : 	int	requestID = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _requestID$[ebp], eax

; 2359 : 
; 2360 : 	Q_strcpy( name, MSG_ReadString( msg ));

	push	99999					; 0001869fH
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2361 : 	Q_strcpy( value, MSG_ReadString( msg ));

	push	99999					; 0001869fH
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2362 : 
; 2363 : 	if( svgame.dllFuncs2.pfnCvarValue2 != NULL )

	cmp	DWORD PTR _svgame+19488, 0
	je	SHORT $LN2@SV_ParseCv

; 2364 : 		svgame.dllFuncs2.pfnCvarValue2( cl->edict, requestID, name, value );

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _requestID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19488
	add	esp, 16					; 00000010H
$LN2@SV_ParseCv:

; 2365 : 	Con_Reportf( "Cvar query response: name:%s, request ID %d, cvar:%s, value:%s\n", cl->name, requestID, name, value );

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _requestID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0EA@FCCJIFAN@Cvar?5query?5response?3?5name?3?$CFs?0?5r@
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 2366 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseCvarValue2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ParseCvarValue
_TEXT	SEGMENT
_value$ = -4						; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseCvarValue PROC					; COMDAT

; 2340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2341 : 	const char *value = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _value$[ebp], eax

; 2342 : 
; 2343 : 	if( svgame.dllFuncs2.pfnCvarValue != NULL )

	cmp	DWORD PTR _svgame+19484, 0
	je	SHORT $LN2@SV_ParseCv

; 2344 : 		svgame.dllFuncs2.pfnCvarValue( cl->edict, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	push	edx
	call	DWORD PTR _svgame+19484
	add	esp, 8
$LN2@SV_ParseCv:

; 2345 : 	Con_Reportf( "Cvar query response: name:%s, value:%s\n", cl->name, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_0CI@NDPJCJPA@Cvar?5query?5response?3?5name?3?$CFs?0?5v@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2346 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseCvarValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ParseResourceList
_TEXT	SEGMENT
_ri$ = -52						; size = 32
_total$ = -20						; size = 4
_i$ = -16						; size = 4
_resource$ = -12					; size = 4
_totalsize$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseResourceList PROC				; COMDAT

; 2251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2252 : 	int		totalsize;
; 2253 : 	resource_t	*resource;
; 2254 : 	int		i, total;
; 2255 : 	resourceinfo_t	ri;
; 2256 : 
; 2257 : 	total = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _total$[ebp], eax

; 2258 : 
; 2259 : 	SV_ClearResourceList( &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264720				; 00040a10H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2260 : 	SV_ClearResourceList( &cl->resourcesonhand );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264584				; 00040988H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2261 : 
; 2262 : 	for( i = 0; i < total; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_ParseRe
$LN2@SV_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ParseRe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total$[ebp]
	jge	$LN3@SV_ParseRe

; 2263 : 	{
; 2264 : 		resource = Z_Calloc( sizeof( resource_t ) );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ParseResourceList@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _resource$[ebp], eax

; 2265 : 		Q_strncpy( resource->szFileName, MSG_ReadString( msg ), sizeof( resource->szFileName ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2266 : 		resource->type = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 2267 : 		resource->nIndex = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 2268 : 		resource->nDownloadSize = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 2269 : 		resource->ucFlags = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _resource$[ebp]
	mov	BYTE PTR [ecx+76], al

; 2270 : 		resource->pNext = NULL;

	mov	eax, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [eax+128], 0

; 2271 : 		resource->pPrev = NULL;

	mov	eax, DWORD PTR _resource$[ebp]
	mov	DWORD PTR [eax+132], 0

; 2272 : 		ClearBits( resource->ucFlags, RES_WASMISSING );

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _resource$[ebp]
	mov	BYTE PTR [edx+76], cl

; 2273 : 
; 2274 : 		if( FBitSet( resource->ucFlags, RES_CUSTOM ))

	mov	eax, DWORD PTR _resource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	and	ecx, 4
	je	SHORT $LN5@SV_ParseRe

; 2275 : 			MSG_ReadBytes( msg, resource->rgucMD5_hash, 16 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _resource$[ebp]
	add	eax, 77					; 0000004dH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH
$LN5@SV_ParseRe:

; 2276 : 
; 2277 : 		if( resource->type > t_world || resource->nDownloadSize > 1024 * 1024 * 1024 )

	mov	eax, DWORD PTR _resource$[ebp]
	cmp	DWORD PTR [eax+64], 6
	jg	SHORT $LN7@SV_ParseRe
	mov	eax, DWORD PTR _resource$[ebp]
	cmp	DWORD PTR [eax+72], 1073741824		; 40000000H
	jle	SHORT $LN6@SV_ParseRe
$LN7@SV_ParseRe:

; 2278 : 		{
; 2279 : 			SV_ClearResourceList( &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264720				; 00040a10H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2280 : 			SV_ClearResourceList( &cl->resourcesonhand );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264584				; 00040988H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2281 : 			return;

	jmp	$LN1@SV_ParseRe
$LN6@SV_ParseRe:

; 2282 : 		}
; 2283 : 		SV_AddToResourceList( resource, &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264720				; 00040a10H
	push	eax
	mov	ecx, DWORD PTR _resource$[ebp]
	push	ecx
	call	_SV_AddToResourceList
	add	esp, 8

; 2284 : 	}

	jmp	$LN2@SV_ParseRe
$LN3@SV_ParseRe:

; 2285 : 
; 2286 : 	totalsize = COM_SizeofResourceList( &cl->resourcesneeded, &ri );

	lea	eax, DWORD PTR _ri$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 264720				; 00040a10H
	push	ecx
	call	_COM_SizeofResourceList
	add	esp, 8
	mov	DWORD PTR _totalsize$[ebp], eax

; 2287 : 
; 2288 : 	if( totalsize != 0 && sv_allow_upload.value )

	cmp	DWORD PTR _totalsize$[ebp], 0
	je	$LN8@SV_ParseRe
	movss	xmm0, DWORD PTR _sv_allow_upload+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@SV_ParseRe

; 2289 : 	{
; 2290 : 		Con_DPrintf( "Verifying and uploading resources...\n" );

	push	OFFSET ??_C@_0CG@FELOKCJM@Verifying?5and?5uploading?5resourc@
	call	_Con_DPrintf
	add	esp, 4

; 2291 : 
; 2292 : 		if( totalsize != 0 )

	cmp	DWORD PTR _totalsize$[ebp], 0
	je	$LN9@SV_ParseRe

; 2293 : 		{
; 2294 : 			Con_DPrintf( "Custom resources total %.2fK\n", totalsize / 1024.0 );

	cvtsi2sd xmm0, DWORD PTR _totalsize$[ebp]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BO@LCICNDAF@Custom?5resources?5total?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 2295 : 
; 2296 : 			if ( ri.info[t_model].size != 0 )

	mov	eax, 4
	shl	eax, 1
	cmp	DWORD PTR _ri$[ebp+eax], 0
	je	SHORT $LN10@SV_ParseRe

; 2297 : 				Con_DPrintf( "  Models:  %.2fK\n", ri.info[t_model].size / 1024.0 );

	mov	eax, 4
	shl	eax, 1
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BC@PBEPLNEK@?5?5Models?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN10@SV_ParseRe:

; 2298 : 
; 2299 : 			if ( ri.info[t_sound].size != 0 )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN11@SV_ParseRe

; 2300 : 				Con_DPrintf( "  Sounds:  %.2fK\n", ri.info[t_sound].size / 1024.0 );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+ecx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BC@CNJCGBDI@?5?5Sounds?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN11@SV_ParseRe:

; 2301 : 
; 2302 : 			if ( ri.info[t_decal].size != 0 )

	mov	eax, 4
	imul	ecx, eax, 3
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN12@SV_ParseRe

; 2303 : 				Con_DPrintf( "  Decals:  %.2fK\n", ri.info[t_decal].size / 1024.0 );

	mov	eax, 4
	imul	ecx, eax, 3
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+ecx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BC@OOEPAONE@?5?5Decals?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN12@SV_ParseRe:

; 2304 : 
; 2305 : 			if ( ri.info[t_skin].size != 0 )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _ri$[ebp+eax], 0
	je	SHORT $LN13@SV_ParseRe

; 2306 : 				Con_DPrintf( "  Skins :  %.2fK\n", ri.info[t_skin].size / 1024.0 );

	mov	eax, 4
	shl	eax, 0
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BC@HCHFBGEM@?5?5Skins?5?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN13@SV_ParseRe:

; 2307 : 
; 2308 : 			if ( ri.info[t_generic].size != 0 )

	mov	eax, 4
	shl	eax, 2
	cmp	DWORD PTR _ri$[ebp+eax], 0
	je	SHORT $LN14@SV_ParseRe

; 2309 : 				Con_DPrintf( "  Generic :  %.2fK\n", ri.info[t_generic].size / 1024.0 );

	mov	eax, 4
	shl	eax, 2
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+eax]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@MEAONMDF@?5?5Generic?5?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN14@SV_ParseRe:

; 2310 : 
; 2311 : 			if ( ri.info[t_eventscript].size != 0 )

	mov	eax, 4
	imul	ecx, eax, 5
	cmp	DWORD PTR _ri$[ebp+ecx], 0
	je	SHORT $LN15@SV_ParseRe

; 2312 : 				Con_DPrintf( "  Events  :  %.2fK\n", ri.info[t_eventscript].size / 1024.0 );

	mov	eax, 4
	imul	ecx, eax, 5
	cvtsi2sd xmm0, DWORD PTR _ri$[ebp+ecx]
	divsd	xmm0, QWORD PTR __real@4090000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@DAFJBGEG@?5?5Events?5?5?3?5?5?$CF?42fK?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN15@SV_ParseRe:

; 2313 : 
; 2314 : 			Con_DPrintf( "----------------------\n" );

	push	OFFSET ??_C@_0BI@FLKKINBM@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?6@
	call	_Con_DPrintf
	add	esp, 4
$LN9@SV_ParseRe:

; 2315 : 		}
; 2316 : 
; 2317 : 		totalsize = SV_EstimateNeededResources( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_EstimateNeededResources
	add	esp, 4
	mov	DWORD PTR _totalsize$[ebp], eax

; 2318 : 
; 2319 : 		if( totalsize > sv_uploadmax.value * 1024 * 1024 )

	cvtsi2ss xmm0, DWORD PTR _totalsize$[ebp]
	movss	xmm1, DWORD PTR _sv_uploadmax+12
	mulss	xmm1, DWORD PTR __real@44800000
	mulss	xmm1, DWORD PTR __real@44800000
	comiss	xmm0, xmm1
	jbe	SHORT $LN16@SV_ParseRe

; 2320 : 		{
; 2321 : 			SV_ClearResourceList( &cl->resourcesneeded );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264720				; 00040a10H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2322 : 			SV_ClearResourceList( &cl->resourcesonhand );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264584				; 00040988H
	push	eax
	call	_SV_ClearResourceList
	add	esp, 4

; 2323 : 			return;

	jmp	SHORT $LN1@SV_ParseRe
$LN16@SV_ParseRe:

; 2324 : 		}
; 2325 : 		Con_DPrintf( "resources to request: %s\n", Q_memprint( totalsize ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _totalsize$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BK@CNKJOPDO@resources?5to?5request?3?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8
$LN8@SV_ParseRe:

; 2326 : 	}
; 2327 : 
; 2328 : 	cl->upstate = us_processing;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+4], 1

; 2329 : 	SV_BatchUploadRequest( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_BatchUploadRequest
	add	esp, 4
$LN1@SV_ParseRe:

; 2330 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseResourceList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ParseClientMove
_TEXT	SEGMENT
tv294 = -4216						; size = 4
_model$ = -3700						; size = 4
_player$ = -3696					; size = 4
_packet_loss$ = -3692					; size = 4
_cmds$ = -3688						; size = 3584
_from$ = -104						; size = 4
_to$ = -100						; size = 4
_nullcmd$ = -96						; size = 56
_numcmds$ = -40						; size = 4
_totalcmds$ = -36					; size = 4
_numbackup$ = -32					; size = 4
_i$ = -28						; size = 4
_checksum2$ = -24					; size = 4
_checksum1$ = -20					; size = 4
_size$ = -16						; size = 4
_key$ = -12						; size = 4
_frame$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ParseClientMove PROC				; COMDAT

; 2119 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4216				; 00001078H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2120 : 	client_frame_t	*frame;
; 2121 : 	int		key, size, checksum1, checksum2;
; 2122 : 	int		i, numbackup, totalcmds, numcmds;
; 2123 : 	usercmd_t		nullcmd, *to, *from;
; 2124 : 	usercmd_t		cmds[CMD_BACKUP];
; 2125 : 	float		packet_loss;
; 2126 : 	edict_t		*player;
; 2127 : 	model_t		*model;
; 2128 : 
; 2129 : 	player = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _player$[ebp], ecx

; 2130 : 
; 2131 : 	frame = &cl->frames[cl->netchan.incoming_acknowledged & SV_UPDATE_MASK];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	and	eax, DWORD PTR [ecx+628]
	imul	edx, eax, 9296
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+281884]
	mov	DWORD PTR _frame$[ebp], edx

; 2132 : 	memset( &nullcmd, 0, sizeof( usercmd_t ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _nullcmd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2133 : 	memset( cmds, 0, sizeof( cmds ));

	push	3584					; 00000e00H
	push	0
	lea	eax, DWORD PTR _cmds$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2134 : 
; 2135 : 	key = MSG_GetRealBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	mov	DWORD PTR _key$[ebp], eax

; 2136 : 	checksum1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _checksum1$[ebp], eax

; 2137 : 	packet_loss = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _packet_loss$[ebp], xmm0

; 2138 : 
; 2139 : 	numbackup = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _numbackup$[ebp], eax

; 2140 : 	numcmds = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _numcmds$[ebp], eax

; 2141 : 
; 2142 : 	totalcmds = numcmds + numbackup;

	mov	eax, DWORD PTR _numcmds$[ebp]
	add	eax, DWORD PTR _numbackup$[ebp]
	mov	DWORD PTR _totalcmds$[ebp], eax

; 2143 : 	net_drop -= (numcmds - 1);

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _net_drop
	sub	ecx, eax
	mov	DWORD PTR _net_drop, ecx

; 2144 : 
; 2145 : 	if( totalcmds < 0 || totalcmds >= CMD_MASK )

	cmp	DWORD PTR _totalcmds$[ebp], 0
	jl	SHORT $LN16@SV_ParseCl
	cmp	DWORD PTR _totalcmds$[ebp], 63		; 0000003fH
	jl	SHORT $LN15@SV_ParseCl
$LN16@SV_ParseCl:

; 2146 : 	{
; 2147 : 		Con_Reportf( S_ERROR "SV_ParseClientMove: %s sending too many commands %i\n", cl->name, totalcmds );

	mov	eax, DWORD PTR _totalcmds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_0EA@NCHKBPHB@?$FO1Error?3?$FO7?5SV_ParseClientMove?3?5@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2148 : 		SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 2149 : 		return;

	jmp	$LN27@SV_ParseCl
$LN15@SV_ParseCl:

; 2150 : 	}
; 2151 : 
; 2152 : 	from = &nullcmd;	// first cmd are starting from null-compressed usercmd_t

	lea	eax, DWORD PTR _nullcmd$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 2153 : 
; 2154 : 	for( i = totalcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _totalcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN4@SV_ParseCl
$LN2@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_ParseCl:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN3@SV_ParseCl

; 2155 : 	{
; 2156 : 		to = &cmds[i];

	imul	eax, DWORD PTR _i$[ebp], 56
	lea	ecx, DWORD PTR _cmds$[ebp+eax]
	mov	DWORD PTR _to$[ebp], ecx

; 2157 : 		MSG_ReadDeltaUsercmd( msg, from, to );

	mov	eax, DWORD PTR _to$[ebp]
	push	eax
	mov	ecx, DWORD PTR _from$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadDeltaUsercmd
	add	esp, 12					; 0000000cH

; 2158 : 		from = to; // get new baseline

	mov	eax, DWORD PTR _to$[ebp]
	mov	DWORD PTR _from$[ebp], eax

; 2159 : 	}

	jmp	SHORT $LN2@SV_ParseCl
$LN3@SV_ParseCl:

; 2160 : 
; 2161 : 	if( cl->state != cs_spawned )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN17@SV_ParseCl

; 2162 : 		return;

	jmp	$LN27@SV_ParseCl
$LN17@SV_ParseCl:

; 2163 : 
; 2164 : 	// if the checksum fails, ignore the rest of the packet
; 2165 : 	size = MSG_GetRealBytesRead( msg ) - key - 1;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetRealBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _key$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 2166 : 	checksum2 = CRC32_BlockSequence( msg->pData + key + 1, size, cl->netchan.incoming_sequence );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _key$[ebp]
	lea	eax, DWORD PTR [ecx+edx+1]
	push	eax
	call	_CRC32_BlockSequence
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	mov	DWORD PTR _checksum2$[ebp], ecx

; 2167 : 
; 2168 : 	if( checksum2 != checksum1 )

	mov	eax, DWORD PTR _checksum2$[ebp]
	cmp	eax, DWORD PTR _checksum1$[ebp]
	je	SHORT $LN18@SV_ParseCl

; 2169 : 	{
; 2170 : 		Con_Reportf( S_ERROR "SV_UserMove: failed command checksum for %s (%d != %d)\n", cl->name, checksum2, checksum1 );

	mov	eax, DWORD PTR _checksum1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _checksum2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 8
	push	edx
	push	OFFSET ??_C@_0ED@KEKJHFIF@?$FO1Error?3?$FO7?5SV_UserMove?3?5failed?5@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 2171 : 		return;

	jmp	$LN27@SV_ParseCl
$LN18@SV_ParseCl:

; 2172 : 	}
; 2173 : 
; 2174 : 	cl->packet_loss = packet_loss;

	cvttss2si eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+264936], eax

; 2175 : 
; 2176 : 	// freeze player for some reasons if loadgame was executed
; 2177 : 	if( GameState->loadGame )

	cmp	DWORD PTR _host+156, 0
	je	SHORT $LN19@SV_ParseCl

; 2178 : 		return;

	jmp	$LN27@SV_ParseCl
$LN19@SV_ParseCl:

; 2179 : 
; 2180 : 	// check for pause or frozen
; 2181 : 	if( sv.paused || !CL_IsInGame() || SV_PlayerIsFrozen( player ))

	cmp	DWORD PTR _sv+2595656, 0
	jne	SHORT $LN22@SV_ParseCl
	call	_CL_IsInGame
	test	eax, eax
	je	SHORT $LN22@SV_ParseCl
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_PlayerIsFrozen
	add	esp, 4
	test	eax, eax
	je	$LN20@SV_ParseCl
$LN22@SV_ParseCl:

; 2182 : 	{
; 2183 : 		for( i = 0; i < numcmds; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_ParseCl
$LN5@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numcmds$[ebp]
	jge	$LN6@SV_ParseCl

; 2184 : 		{
; 2185 : 			cmds[i].msec = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	mov	BYTE PTR _cmds$[ebp+eax+2], 0

; 2186 : 			cmds[i].forwardmove = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+eax+16], xmm0

; 2187 : 			cmds[i].sidemove = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+eax+20], xmm0

; 2188 : 			cmds[i].upmove = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	xorps	xmm0, xmm0
	movss	DWORD PTR _cmds$[ebp+eax+24], xmm0

; 2189 : 			cmds[i].buttons = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	mov	DWORD PTR _cmds$[ebp+eax+32], 0

; 2190 : 
; 2191 : 			if( SV_PlayerIsFrozen( player ))

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	_SV_PlayerIsFrozen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@SV_ParseCl

; 2192 : 				cmds[i].impulse = 0;

	imul	eax, DWORD PTR _i$[ebp], 56
	mov	BYTE PTR _cmds$[ebp+eax+36], 0
$LN23@SV_ParseCl:

; 2193 : 
; 2194 : 			VectorCopy( cmds[i].viewangles, player->v.v_angle );

	imul	eax, DWORD PTR _i$[ebp], 56
	lea	ecx, DWORD PTR _cmds$[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR [esi+edx+244], eax
	imul	ecx, DWORD PTR _i$[ebp], 56
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [edx+eax+4]
	mov	DWORD PTR [esi+ecx+244], edx
	imul	eax, DWORD PTR _i$[ebp], 56
	lea	ecx, DWORD PTR _cmds$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR [esi+eax+244], ecx

; 2195 : 		}

	jmp	$LN5@SV_ParseCl
$LN6@SV_ParseCl:

; 2196 : 		net_drop = 0;

	mov	DWORD PTR _net_drop, 0

; 2197 : 	}

	jmp	$LN24@SV_ParseCl
$LN20@SV_ParseCl:

; 2198 : 	else
; 2199 : 	{
; 2200 : 		if( !player->v.fixangle )

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+288], 0
	jne	$LN24@SV_ParseCl

; 2201 : 			VectorCopy( cmds[0].viewangles, player->v.v_angle );

	mov	eax, 56					; 00000038H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _cmds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR [esi+eax+244], ecx
	mov	edx, 56					; 00000038H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _cmds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR [esi+eax+244], ecx
	mov	edx, 56					; 00000038H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _cmds$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR [esi+eax+244], ecx
$LN24@SV_ParseCl:

; 2202 : 	}
; 2203 : 
; 2204 : 	SV_EstablishTimeBase( cl, cmds, net_drop, numbackup, numcmds );

	mov	eax, DWORD PTR _numcmds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numbackup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _net_drop
	push	edx
	lea	eax, DWORD PTR _cmds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_EstablishTimeBase
	add	esp, 20					; 00000014H

; 2205 : 
; 2206 : 	if( net_drop < 24 )

	cmp	DWORD PTR _net_drop, 24			; 00000018H
	jge	SHORT $LN11@SV_ParseCl
$LN8@SV_ParseCl:

; 2207 : 	{
; 2208 : 		while( net_drop > numbackup )

	mov	eax, DWORD PTR _net_drop
	cmp	eax, DWORD PTR _numbackup$[ebp]
	jle	SHORT $LN9@SV_ParseCl

; 2209 : 		{
; 2210 : 			SV_RunCmd( cl, &cl->lastcmd, 0 );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264856				; 00040a98H
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2211 : 			net_drop--;

	mov	eax, DWORD PTR _net_drop
	sub	eax, 1
	mov	DWORD PTR _net_drop, eax

; 2212 : 		}

	jmp	SHORT $LN8@SV_ParseCl
$LN9@SV_ParseCl:

; 2213 : 
; 2214 : 		while( net_drop > 0 )

	cmp	DWORD PTR _net_drop, 0
	jle	SHORT $LN11@SV_ParseCl

; 2215 : 		{
; 2216 : 			i = numcmds + net_drop - 1;

	mov	eax, DWORD PTR _net_drop
	mov	ecx, DWORD PTR _numcmds$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _i$[ebp], edx

; 2217 : 			SV_RunCmd( cl, &cmds[i], cl->netchan.incoming_sequence - i );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	sub	ecx, DWORD PTR _i$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 56
	lea	eax, DWORD PTR _cmds$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2218 : 			net_drop--;

	mov	eax, DWORD PTR _net_drop
	sub	eax, 1
	mov	DWORD PTR _net_drop, eax

; 2219 : 		}

	jmp	SHORT $LN9@SV_ParseCl
$LN11@SV_ParseCl:

; 2220 : 	}
; 2221 : 
; 2222 : 	for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN14@SV_ParseCl
$LN12@SV_ParseCl:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@SV_ParseCl:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN13@SV_ParseCl

; 2223 : 	{
; 2224 : 		SV_RunCmd( cl, &cmds[i], cl->netchan.incoming_sequence - i );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	sub	ecx, DWORD PTR _i$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 56
	lea	eax, DWORD PTR _cmds$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_RunCmd
	add	esp, 12					; 0000000cH

; 2225 : 	}

	jmp	SHORT $LN12@SV_ParseCl
$LN13@SV_ParseCl:

; 2226 : 
; 2227 : 	cl->lastcmd = cmds[0];

	mov	eax, 56					; 00000038H
	imul	ecx, eax, 0
	lea	esi, DWORD PTR _cmds$[ebp+ecx]
	mov	edi, DWORD PTR _cl$[ebp]
	add	edi, 264856				; 00040a98H
	mov	ecx, 14					; 0000000eH
	rep movsd

; 2228 : 
; 2229 : 	// adjust latency time by 1/2 last client frame since
; 2230 : 	// the message probably arrived 1/2 through client's frame loop
; 2231 : 	frame->ping_time -= ( cl->lastcmd.msec * 0.5f ) / 1000.0f;

	mov	eax, DWORD PTR _cl$[ebp]
	movzx	ecx, BYTE PTR [eax+264858]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR __real@447a0000
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm1, DWORD PTR [edx+8]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [eax+8], xmm1

; 2232 : 	frame->ping_time = Q_max( 0.0f, frame->ping_time );

	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN29@SV_ParseCl
	xorps	xmm0, xmm0
	movss	DWORD PTR tv294[ebp], xmm0
	jmp	SHORT $LN30@SV_ParseCl
$LN29@SV_ParseCl:
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR tv294[ebp], xmm0
$LN30@SV_ParseCl:
	mov	edx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 2233 : 	model = SV_ModelHandle( player->v.modelindex );

	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	push	ecx
	call	_SV_ModelHandle
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 2234 : 
; 2235 : 	if( model && model->type == mod_studio )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $LN27@SV_ParseCl
	mov	eax, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN27@SV_ParseCl

; 2236 : 	{
; 2237 : 		// g-cont. yes we using svgame.globals->time instead of sv.time
; 2238 : 		if( player->v.animtime > svgame.globals->time + sv.frametime )

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _player$[ebp]
	movss	xmm1, DWORD PTR [ecx+476]
	comiss	xmm1, xmm0
	jbe	SHORT $LN27@SV_ParseCl

; 2239 : 			player->v.animtime = svgame.globals->time + sv.frametime;

	mov	eax, DWORD PTR _svgame+19268
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR _sv+32
	mov	ecx, DWORD PTR _player$[ebp]
	movss	DWORD PTR [ecx+476], xmm0
$LN27@SV_ParseCl:

; 2240 : 	}
; 2241 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ParseClientMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_TSourceEngineQuery
_TEXT	SEGMENT
tv146 = -1256						; size = 4
_buf$ = -1060						; size = 20
_index$ = -1040						; size = 4
_bots$ = -1036						; size = 4
_count$ = -1032						; size = 4
_answer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_TSourceEngineQuery PROC				; COMDAT

; 2003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1256				; 000004e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2004 : 	// A2S_INFO
; 2005 : 	char	answer[1024] = "";

	mov	al, BYTE PTR ??_C@_00CNPNBAHC@@
	mov	BYTE PTR _answer$[ebp], al
	push	1023					; 000003ffH
	push	0
	lea	eax, DWORD PTR _answer$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2006 : 	int	count = 0, bots = 0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _bots$[ebp], 0

; 2007 : 	int	index;
; 2008 : 	sizebuf_t	buf;
; 2009 : 
; 2010 : 	if( svs.clients )

	cmp	DWORD PTR _svs+33344, 0
	je	SHORT $LN3@SV_TSource

; 2011 : 	{
; 2012 : 		for( index = 0; index < svs.maxclients; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@SV_TSource
$LN2@SV_TSource:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@SV_TSource:
	mov	eax, DWORD PTR _index$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_TSource

; 2013 : 		{
; 2014 : 			if( svs.clients[index].state >= cs_connected )

	imul	eax, DWORD PTR _index$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 2
	jl	SHORT $LN8@SV_TSource

; 2015 : 			{
; 2016 : 				if( FBitSet( svs.clients[index].flags, FCL_FAKECLIENT ))

	imul	eax, DWORD PTR _index$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	mov	edx, DWORD PTR [ecx+eax+40]
	and	edx, 128				; 00000080H
	je	SHORT $LN7@SV_TSource

; 2017 : 					bots++;

	mov	eax, DWORD PTR _bots$[ebp]
	add	eax, 1
	mov	DWORD PTR _bots$[ebp], eax
	jmp	SHORT $LN8@SV_TSource
$LN7@SV_TSource:

; 2018 : 				else count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN8@SV_TSource:

; 2019 : 			}
; 2020 : 		}

	jmp	SHORT $LN2@SV_TSource
$LN3@SV_TSource:

; 2021 : 	}
; 2022 : 
; 2023 : 	MSG_Init( &buf, "TSourceEngineQuery", answer, sizeof( answer ));

	push	-1
	push	1024					; 00000400H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@JHHJPGKC@TSourceEngineQuery@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2024 : 
; 2025 : 	MSG_WriteByte( &buf, 'm' );

	push	109					; 0000006dH
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2026 : 	MSG_WriteString( &buf, NET_AdrToString( net_local ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 2027 : 	MSG_WriteString( &buf, hostname.string );

	mov	eax, DWORD PTR _hostname+4
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2028 : 	MSG_WriteString( &buf, sv.name );

	push	OFFSET _sv+56
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 2029 : 	MSG_WriteString( &buf, GI->gamefolder );

	mov	eax, DWORD PTR _SI+768
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2030 : 	MSG_WriteString( &buf, GI->title );

	mov	eax, DWORD PTR _SI+768
	add	eax, 384				; 00000180H
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2031 : 	MSG_WriteByte( &buf, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2032 : 	MSG_WriteByte( &buf, svs.maxclients );

	mov	eax, DWORD PTR _svs+16
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2033 : 	MSG_WriteByte( &buf, PROTOCOL_VERSION );

	push	49					; 00000031H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2034 : 	MSG_WriteByte( &buf, host.type == HOST_DEDICATED ? 'D' : 'L' );

	cmp	DWORD PTR _host+164, 1
	jne	SHORT $LN16@SV_TSource
	mov	DWORD PTR tv146[ebp], 68		; 00000044H
	jmp	SHORT $LN17@SV_TSource
$LN16@SV_TSource:
	mov	DWORD PTR tv146[ebp], 76		; 0000004cH
$LN17@SV_TSource:
	mov	eax, DWORD PTR tv146[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2035 : 	MSG_WriteByte( &buf, 'W' );

	push	87					; 00000057H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2036 : 
; 2037 : 	if( Q_stricmp( GI->gamedir, "fareast" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07CINOGAJB@fareast@
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN9@SV_TSource

; 2038 : 	{
; 2039 : 		MSG_WriteByte( &buf, 1 ); // mod

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2040 : 		MSG_WriteString( &buf, GI->game_url );

	mov	eax, DWORD PTR _SI+768
	add	eax, 644				; 00000284H
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2041 : 		MSG_WriteString( &buf, GI->update_url );

	mov	eax, DWORD PTR _SI+768
	add	eax, 900				; 00000384H
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 2042 : 		MSG_WriteByte( &buf, 0 );

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 2043 : 		MSG_WriteLong( &buf, (long)GI->version );

	mov	eax, DWORD PTR _SI+768
	cvttss2si ecx, DWORD PTR [eax+448]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 2044 : 		MSG_WriteLong( &buf, GI->size );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1284]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 2045 : 
; 2046 : 		if( GI->gamemode == 2 )

	mov	eax, DWORD PTR _SI+768
	cmp	DWORD PTR [eax+1288], 2
	jne	SHORT $LN11@SV_TSource

; 2047 : 			MSG_WriteByte( &buf, 1 ); // multiplayer_only

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
	jmp	SHORT $LN12@SV_TSource
$LN11@SV_TSource:

; 2048 : 		else MSG_WriteByte( &buf, 0 );

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN12@SV_TSource:

; 2049 : 
; 2050 : 		if( Q_strstr( GI->game_dll, "hl." ))

	push	OFFSET ??_C@_03GKODMEGH@hl?4@
	mov	eax, DWORD PTR _SI+768
	add	eax, 516				; 00000204H
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@SV_TSource

; 2051 : 			MSG_WriteByte( &buf, 0 ); // Half-Life DLL

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
	jmp	SHORT $LN14@SV_TSource
$LN13@SV_TSource:

; 2052 : 		else MSG_WriteByte( &buf, 1 ); // Own DLL

	push	1
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN14@SV_TSource:

; 2053 : 	}

	jmp	SHORT $LN10@SV_TSource
$LN9@SV_TSource:

; 2054 : 	else MSG_WriteByte( &buf, 0 ); // Half-Life

	push	0
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8
$LN10@SV_TSource:

; 2055 : 
; 2056 : 	MSG_WriteByte( &buf, GI->secure ); // unsecure

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1292]
	push	ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 2057 : 	MSG_WriteByte( &buf, bots );

	mov	eax, DWORD PTR _bots$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 2058 : 
; 2059 : 	NET_SendPacket( NS_SERVER, MSG_GetNumBytesWritten( &buf ), MSG_GetData( &buf ), from );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H

; 2060 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TSourceEngineQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Begin_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Begin_f PROC					; COMDAT

; 1927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1928 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_Begin_f

; 1929 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_Begin_f
$LN2@SV_Begin_f:

; 1930 : 
; 1931 : 	// now client is spawned
; 1932 : 	cl->state = cs_spawned;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 3

; 1933 : 	return true;

	mov	eax, 1
$LN1@SV_Begin_f:

; 1934 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Begin_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Spawn_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Spawn_f PROC					; COMDAT

; 1898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1899 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_Spawn_f

; 1900 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_Spawn_f
$LN2@SV_Spawn_f:

; 1901 : 
; 1902 : 	// handle the case of a level changing while a client was connecting
; 1903 : 	if( Q_atoi( Cmd_Argv( 1 )) != svs.spawncount )

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, DWORD PTR _svs+33340
	je	SHORT $LN3@SV_Spawn_f

; 1904 : 	{
; 1905 : 		SV_New_f( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_New_f
	add	esp, 4

; 1906 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Spawn_f
$LN3@SV_Spawn_f:

; 1907 : 	}
; 1908 : 
; 1909 : 	SV_PutClientInServer( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_PutClientInServer
	add	esp, 4

; 1910 : 
; 1911 : 	// if we are paused, tell the clients
; 1912 : 	if( sv.paused )

	cmp	DWORD PTR _sv+2595656, 0
	je	SHORT $LN4@SV_Spawn_f

; 1913 : 	{
; 1914 : 		MSG_BeginServerCmd( &sv.reliable_datagram, svc_setpause );

	push	0
	push	1
	push	24					; 00000018H
	push	OFFSET _sv+2431724
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1915 : 		MSG_WriteByte( &sv.reliable_datagram, sv.paused );

	mov	eax, DWORD PTR _sv+2595656
	push	eax
	push	OFFSET _sv+2431724
	call	_MSG_WriteByte
	add	esp, 8

; 1916 : 		SV_ClientPrintf( cl, "Server is paused.\n" );

	push	OFFSET ??_C@_0BD@EBKLBEDB@Server?5is?5paused?4?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8
$LN4@SV_Spawn_f:

; 1917 : 	}
; 1918 : 	return true;

	mov	eax, 1
$LN1@SV_Spawn_f:

; 1919 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Spawn_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_DownloadFile_f
_TEXT	SEGMENT
_size$1 = -184						; size = 4
_pbuf$2 = -180						; size = 4
_md5$3 = -176						; size = 32
_custResource$4 = -144					; size = 136
_name$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_DownloadFile_f PROC					; COMDAT

; 1821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1822 : 	char	*name;
; 1823 : 
; 1824 : 	if( Cmd_Argc() < 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jae	SHORT $LN2@SV_Downloa

; 1825 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN2@SV_Downloa:

; 1826 : 
; 1827 : 	name = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1828 : 
; 1829 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@SV_Downloa

; 1830 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN3@SV_Downloa:

; 1831 : 
; 1832 : 	if( !COM_IsSafeFileToDownload( name ) || !sv_allow_download.value )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_IsSafeFileToDownload
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@SV_Downloa
	movss	xmm0, DWORD PTR _sv_allow_download+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_Downloa
$LN5@SV_Downloa:

; 1833 : 	{
; 1834 : 		SV_FailDownload( cl, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FailDownload
	add	esp, 8

; 1835 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN4@SV_Downloa:

; 1836 : 	}
; 1837 : 
; 1838 : 	// g-cont. now we supports hot precache
; 1839 : 	if( name[0] != '!' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 33					; 00000021H
	je	$LN6@SV_Downloa

; 1840 : 	{
; 1841 : 		if( sv_send_resources.value )

	movss	xmm0, DWORD PTR _sv_send_resources+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN10@SV_Downloa

; 1842 : 		{
; 1843 : 			// also check the model textures
; 1844 : 			if( !Q_stricmp( COM_FileExtension( name ), "mdl" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03JBGBEIGK@mdl@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@SV_Downloa

; 1845 : 			{
; 1846 : 				if( FS_FileExists( Mod_StudioTexName( name ), false ) > 0 )

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN9@SV_Downloa

; 1847 : 					Netchan_CreateFileFragments( &cl->netchan, Mod_StudioTexName( name ));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_StudioTexName
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFileFragments
	add	esp, 8
$LN9@SV_Downloa:

; 1848 : 			}
; 1849 : 
; 1850 : 			if( Netchan_CreateFileFragments( &cl->netchan, name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFileFragments
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@SV_Downloa

; 1851 : 			{
; 1852 : 				Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1853 : 				return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN10@SV_Downloa:

; 1854 : 			}
; 1855 : 		}
; 1856 : 
; 1857 : 		SV_FailDownload( cl, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FailDownload
	add	esp, 8

; 1858 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Downloa
$LN6@SV_Downloa:

; 1859 : 	}
; 1860 : 
; 1861 : 	if( Q_strlen( name ) == 36 && !Q_strnicmp( name, "!MD5", 4 ) && sv_send_logos.value )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 36					; 00000024H
	jne	$LN11@SV_Downloa
	push	4
	push	OFFSET ??_C@_04HJKAGJBM@?$CBMD5@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@SV_Downloa
	movss	xmm0, DWORD PTR _sv_send_logos+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN11@SV_Downloa

; 1862 : 	{
; 1863 : 		resource_t	custResource;
; 1864 : 		byte		md5[32];
; 1865 : 		byte		*pbuf;
; 1866 : 		int		size;
; 1867 : 
; 1868 : 		memset( &custResource, 0, sizeof( custResource ) );

	push	136					; 00000088H
	push	0
	lea	eax, DWORD PTR _custResource$4[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1869 : 		COM_HexConvert( name + 4, 32, md5 );

	lea	eax, DWORD PTR _md5$3[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _name$[ebp]
	add	ecx, 4
	push	ecx
	call	_COM_HexConvert
	add	esp, 12					; 0000000cH

; 1870 : 
; 1871 : 		if( HPAK_ResourceForHash( CUSTOM_RES_PATH, md5, &custResource ))

	lea	eax, DWORD PTR _custResource$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _md5$3[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_ResourceForHash
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN15@SV_Downloa

; 1872 : 		{
; 1873 : 			if( HPAK_GetDataPointer( CUSTOM_RES_PATH, &custResource, &pbuf, &size ))

	lea	eax, DWORD PTR _size$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _custResource$4[ebp]
	push	edx
	push	OFFSET ??_C@_0L@DHBFCELB@custom?4hpk@
	call	_HPAK_GetDataPointer
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN15@SV_Downloa

; 1874 : 			{
; 1875 : 				if( size )

	cmp	DWORD PTR _size$1[ebp], 0
	je	SHORT $LN15@SV_Downloa

; 1876 : 				{
; 1877 : 					Netchan_CreateFileFragmentsFromBuffer( &cl->netchan, name, pbuf, size );

	mov	eax, DWORD PTR _size$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_CreateFileFragmentsFromBuffer
	add	esp, 16					; 00000010H

; 1878 : 					Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1879 : 					Mem_Free( pbuf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_DownloadFile_f@@9@9
	add	eax, 58					; 0000003aH
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _pbuf$2[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN15@SV_Downloa:

; 1880 : 				}
; 1881 : 			}
; 1882 : 		}
; 1883 : 	}

	jmp	SHORT $LN12@SV_Downloa
$LN11@SV_Downloa:

; 1884 : 	else
; 1885 : 	{
; 1886 : 		SV_FailDownload( cl, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FailDownload
	add	esp, 8
$LN12@SV_Downloa:

; 1887 : 	}
; 1888 : 
; 1889 : 	return true;

	mov	eax, 1
$LN1@SV_Downloa:

; 1890 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DownloadFile_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_SendRes_f
_TEXT	SEGMENT
_msg$ = -131096						; size = 20
_buffer$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_SendRes_f PROC					; COMDAT

; 1794 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131608				; 00020218H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1795 : 	byte	buffer[MAX_INIT_MSG];
; 1796 : 	sizebuf_t	msg;
; 1797 : 
; 1798 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN2@SV_SendRes

; 1799 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_SendRes
$LN2@SV_SendRes:

; 1800 : 
; 1801 : 	MSG_Init( &msg, "SendResources", buffer, sizeof( buffer ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@IMIDHLA@SendResources@
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1802 : 
; 1803 : 	if( svs.maxclients > 1 && FBitSet( cl->flags, FCL_SEND_RESOURCES ))

	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN3@SV_SendRes
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 512				; 00000200H
	je	SHORT $LN3@SV_SendRes

; 1804 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_SendRes
$LN3@SV_SendRes:

; 1805 : 
; 1806 : 	SetBits( cl->flags, FCL_SEND_RESOURCES );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 1807 : 	SV_SendResources( cl, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_SendResources
	add	esp, 8

; 1808 : 
; 1809 : 	Netchan_CreateFragments( &cl->netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1810 : 	Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1811 : 
; 1812 : 	return true;

	mov	eax, 1
$LN1@SV_SendRes:

; 1813 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendRes_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Kill_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Kill_f PROC						; COMDAT

; 1773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1774 : 	if( !SV_IsValidEdict( cl->edict ))

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_Kill_f@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	push	edx
	call	_SV_CheckEdict
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_Kill_f

; 1775 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Kill_f
$LN2@SV_Kill_f:

; 1776 : 
; 1777 : 	if( cl->edict->v.health <= 0.0f )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+520]
	jb	SHORT $LN3@SV_Kill_f

; 1778 : 	{
; 1779 : 		SV_ClientPrintf( cl, "Can't suicide - already dead!\n");

	push	OFFSET ??_C@_0BP@DGBAKJMC@Can?8t?5suicide?5?9?5already?5dead?$CB?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1780 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Kill_f
$LN3@SV_Kill_f:

; 1781 : 	}
; 1782 : 
; 1783 : 	svgame.dllFuncs.pfnClientKill( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19340
	add	esp, 4

; 1784 : 
; 1785 : 	return true;

	mov	eax, 1
$LN1@SV_Kill_f:

; 1786 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Kill_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Notarget_f
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Notarget_f PROC					; COMDAT

; 1752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1753 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1754 : 
; 1755 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET ??_C@_09NFOPKLIK@sv_cheats@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Notarge
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Notarge
$LN3@SV_Notarge:

; 1756 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Notarge
$LN2@SV_Notarge:

; 1757 : 
; 1758 : 	pEntity->v.flags = pEntity->v.flags ^ FL_NOTARGET;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	xor	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1759 : 
; 1760 : 	if( !FBitSet( pEntity->v.flags, FL_NOTARGET ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN4@SV_Notarge

; 1761 : 		SV_ClientPrintf( cl, "notarget OFF\n" );

	push	OFFSET ??_C@_0O@FBINJHBB@notarget?5OFF?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8
	jmp	SHORT $LN5@SV_Notarge
$LN4@SV_Notarge:

; 1762 : 	else SV_ClientPrintf( cl, "notarget ON\n" );

	push	OFFSET ??_C@_0N@OBJNJDJO@notarget?5ON?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8
$LN5@SV_Notarge:

; 1763 : 
; 1764 : 	return true;

	mov	eax, 1
$LN1@SV_Notarge:

; 1765 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Notarget_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Godmode_f
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Godmode_f PROC					; COMDAT

; 1728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1729 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1730 : 
; 1731 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET ??_C@_09NFOPKLIK@sv_cheats@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Godmode
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Godmode
$LN3@SV_Godmode:

; 1732 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Godmode
$LN2@SV_Godmode:

; 1733 : 
; 1734 : 	pEntity->v.flags = pEntity->v.flags ^ FL_GODMODE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	xor	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+656], ecx

; 1735 : 	if( pEntity->v.takedamage == DAMAGE_AIM )

	mov	eax, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [eax+600]
	ucomiss	xmm0, DWORD PTR __real@40000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SV_Godmode

; 1736 : 		pEntity->v.takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _pEntity$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+600], xmm0
	jmp	SHORT $LN5@SV_Godmode
$LN4@SV_Godmode:

; 1737 : 	else pEntity->v.takedamage = DAMAGE_AIM;

	mov	eax, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+600], xmm0
$LN5@SV_Godmode:

; 1738 : 
; 1739 : 	if( !FBitSet( pEntity->v.flags, FL_GODMODE ))

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN6@SV_Godmode

; 1740 : 		SV_ClientPrintf( cl, "godmode OFF\n" );

	push	OFFSET ??_C@_0N@POKEKLLJ@godmode?5OFF?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8
	jmp	SHORT $LN7@SV_Godmode
$LN6@SV_Godmode:

; 1741 : 	else SV_ClientPrintf( cl, "godmode ON\n" );

	push	OFFSET ??_C@_0M@MCLKHHDH@godmode?5ON?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8
$LN7@SV_Godmode:

; 1742 : 
; 1743 : 	return true;

	mov	eax, 1
$LN1@SV_Godmode:

; 1744 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Godmode_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Noclip_f
_TEXT	SEGMENT
_pEntity$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_Noclip_f PROC					; COMDAT

; 1702 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1703 : 	edict_t	*pEntity = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 1704 : 
; 1705 : 	if( !Cvar_VariableInteger( "sv_cheats" ) || sv.background )

	push	OFFSET ??_C@_09NFOPKLIK@sv_cheats@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_Noclip_
	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_Noclip_
$LN3@SV_Noclip_:

; 1706 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Noclip_
$LN2@SV_Noclip_:

; 1707 : 
; 1708 : 	if( pEntity->v.movetype != MOVETYPE_NOCLIP )

	mov	eax, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [eax+396], 8
	je	SHORT $LN4@SV_Noclip_

; 1709 : 	{
; 1710 : 		SV_ClientPrintf( cl, "noclip ON\n" );

	push	OFFSET ??_C@_0L@MDMNIPJN@noclip?5ON?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1711 : 		pEntity->v.movetype = MOVETYPE_NOCLIP;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+396], 8

; 1712 : 	}

	jmp	SHORT $LN5@SV_Noclip_
$LN4@SV_Noclip_:

; 1713 : 	else
; 1714 : 	{
; 1715 : 		SV_ClientPrintf( cl, "noclip OFF\n" );

	push	OFFSET ??_C@_0M@MIKGJGLH@noclip?5OFF?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1716 : 		pEntity->v.movetype =  MOVETYPE_WALK;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+396], 3
$LN5@SV_Noclip_:

; 1717 : 	}
; 1718 : 
; 1719 : 	return true;

	mov	eax, 1
$LN1@SV_Noclip_:

; 1720 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Noclip_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_SetInfo_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_SetInfo_f PROC					; COMDAT

; 1688 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1689 : 	Info_SetValueForKey( cl->userinfo, Cmd_Argv( 1 ), Cmd_Argv( 2 ), MAX_INFO_STRING );

	push	256					; 00000100H
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1690 : 
; 1691 : 	if( cl->state >= cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@SV_SetInfo

; 1692 : 		SetBits( cl->flags, FCL_RESEND_USERINFO ); // needs for update client info

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN2@SV_SetInfo:

; 1693 : 	return true;

	mov	eax, 1

; 1694 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SetInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_UpdateUserinfo_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_UpdateUserinfo_f PROC				; COMDAT

; 1674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1675 : 	Q_strncpy( cl->userinfo, Cmd_Argv( 1 ), sizeof( cl->userinfo ));

	push	256					; 00000100H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1676 : 
; 1677 : 	if( cl->state >= cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN2@SV_UpdateU

; 1678 : 		SetBits( cl->flags, FCL_RESEND_USERINFO ); // needs for update client info

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN2@SV_UpdateU:

; 1679 : 	return true;

	mov	eax, 1

; 1680 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateUserinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Pause_f
_TEXT	SEGMENT
_message$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_Pause_f PROC					; COMDAT

; 1531 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1532 : 	string	message;
; 1533 : 
; 1534 : 	if( UI_CreditsActive( ))

	call	_UI_CreditsActive
	test	eax, eax
	je	SHORT $LN2@SV_Pause_f

; 1535 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Pause_f
$LN2@SV_Pause_f:

; 1536 : 
; 1537 : 	if( !sv_pausable->value )

	mov	eax, DWORD PTR _sv_pausable
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SV_Pause_f

; 1538 : 	{
; 1539 : 		SV_ClientPrintf( cl, "Pause not allowed.\n" );

	push	OFFSET ??_C@_0BE@MCELCJJK@Pause?5not?5allowed?4?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1540 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_Pause_f
$LN3@SV_Pause_f:

; 1541 : 	}
; 1542 : 
; 1543 : 	if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN4@SV_Pause_f

; 1544 : 	{
; 1545 : 		SV_ClientPrintf( cl, "Spectators can not pause.\n" );

	push	OFFSET ??_C@_0BL@GFHKHDIC@Spectators?5can?5not?5pause?4?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ClientPrintf
	add	esp, 8

; 1546 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_Pause_f
$LN4@SV_Pause_f:

; 1547 : 	}
; 1548 : 
; 1549 : 	if( !sv.paused ) Q_snprintf( message, MAX_STRING, "^2%s^7 paused the game\n", cl->name );

	cmp	DWORD PTR _sv+2595656, 0
	jne	SHORT $LN5@SV_Pause_f
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0BI@JKOKILDM@?$FO2?$CFs?$FO7?5paused?5the?5game?6@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@SV_Pause_f
$LN5@SV_Pause_f:

; 1550 : 	else Q_snprintf( message, MAX_STRING, "^2%s^7 unpaused the game\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0BK@JIAPMADH@?$FO2?$CFs?$FO7?5unpaused?5the?5game?6@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN6@SV_Pause_f:

; 1551 : 
; 1552 : 	SV_TogglePause( message );

	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_SV_TogglePause
	add	esp, 4

; 1553 : 
; 1554 : 	return true;

	mov	eax, 1
$LN1@SV_Pause_f:

; 1555 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Pause_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ShowServerinfo_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_ShowServerinfo_f PROC				; COMDAT

; 1520 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1521 : 	Info_Print( svs.serverinfo );

	push	OFFSET _svs+60
	call	_Info_Print
	add	esp, 4

; 1522 : 	return true;

	mov	eax, 1

; 1523 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ShowServerinfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Disconnect_f
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_Disconnect_f PROC					; COMDAT

; 1507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1508 : 	SV_DropClient( cl, false );	

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 1509 : 	return true;

	mov	eax, 1

; 1510 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Disconnect_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_New_f
_TEXT	SEGMENT
_i$ = -131392						; size = 4
_msg$ = -131388						; size = 20
_cur$ = -131368						; size = 4
_szName$ = -131364					; size = 32
_szAddress$ = -131332					; size = 128
_szRejectReason$ = -131204				; size = 128
_msg_buf$ = -131076					; size = 131072
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_New_f PROC						; COMDAT

; 1444 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131904				; 00020340H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1445 : 	byte		msg_buf[MAX_INIT_MSG];
; 1446 : 	char		szRejectReason[128];
; 1447 : 	char		szAddress[128];
; 1448 : 	char		szName[32];
; 1449 : 	sv_client_t	*cur;
; 1450 : 	sizebuf_t		msg;
; 1451 : 	int		i;
; 1452 : 
; 1453 : 	MSG_Init( &msg, "New", msg_buf, sizeof( msg_buf ));

	push	-1
	push	131072					; 00020000H
	lea	eax, DWORD PTR _msg_buf$[ebp]
	push	eax
	push	OFFSET ??_C@_03ILBCOJBH@New@
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1454 : 
; 1455 : 	if( cl->state != cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $LN5@SV_New_f

; 1456 : 		return false;

	xor	eax, eax
	jmp	$LN1@SV_New_f
$LN5@SV_New_f:

; 1457 : 
; 1458 : 	// send the serverdata
; 1459 : 	SV_SendServerdata( &msg, cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_SendServerdata
	add	esp, 8

; 1460 : 
; 1461 : 	// if the client was connected, tell the game .dll to disconnect him/her.
; 1462 : 	if(( cl->state == cs_spawned ) && cl->edict )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN6@SV_New_f
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264948], 0
	je	SHORT $LN6@SV_New_f

; 1463 : 		svgame.dllFuncs.pfnClientDisconnect( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19336
	add	esp, 4
$LN6@SV_New_f:

; 1464 : 
; 1465 : 	Q_snprintf( szName, sizeof( szName ), "%s", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1466 : 	Q_snprintf( szAddress, sizeof( szAddress ), "%s", NET_AdrToString( cl->netchan.remote_address ));

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	128					; 00000080H
	lea	ecx, DWORD PTR _szAddress$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1467 : 	Q_snprintf( szRejectReason, sizeof( szRejectReason ), "Connection rejected by game\n");

	push	OFFSET ??_C@_0BN@JEAEPECE@Connection?5rejected?5by?5game?6@
	push	128					; 00000080H
	lea	eax, DWORD PTR _szRejectReason$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 12					; 0000000cH

; 1468 : 
; 1469 : 	// Allow the game dll to reject this client.
; 1470 : 	if( !svgame.dllFuncs.pfnClientConnect( cl->edict, szName, szAddress, szRejectReason ))

	lea	eax, DWORD PTR _szRejectReason$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szAddress$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19332
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN7@SV_New_f

; 1471 : 	{
; 1472 : 		// reject the connection and drop the client.
; 1473 : 		SV_RejectConnection( cl->netchan.remote_address, "%s\n", szRejectReason );

	lea	eax, DWORD PTR _szRejectReason$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	call	_SV_RejectConnection
	add	esp, 28					; 0000001cH

; 1474 : 		SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 1475 : 		return true;

	mov	eax, 1
	jmp	$LN1@SV_New_f
$LN7@SV_New_f:

; 1476 : 	}
; 1477 : 
; 1478 : 	// server info string
; 1479 : 	MSG_BeginServerCmd( &msg, svc_stufftext );

	push	0
	push	1
	push	9
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1480 : 	MSG_WriteString( &msg, va( "fullserverinfo \"%s\"\n", SV_Serverinfo( )));

	call	_SV_Serverinfo
	push	eax
	push	OFFSET ??_C@_0BF@FKGNFJNH@fullserverinfo?5?$CC?$CFs?$CC?6@
	call	_va
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1481 : 
; 1482 : 	// collect the info about all the players and send to me
; 1483 : 	for( i = 0, cur = svs.clients; i < svs.maxclients; i++, cur++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@SV_New_f
$LN2@SV_New_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@SV_New_f:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_New_f

; 1484 : 	{
; 1485 : 		if( !cur->edict || cur->state != cs_spawned )

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+264948], 0
	je	SHORT $LN9@SV_New_f
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN8@SV_New_f
$LN9@SV_New_f:

; 1486 : 			continue;	// not in game yet

	jmp	SHORT $LN2@SV_New_f
$LN8@SV_New_f:

; 1487 : 		SV_FullClientUpdate( cur, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_SV_FullClientUpdate
	add	esp, 8

; 1488 : 	}

	jmp	SHORT $LN2@SV_New_f
$LN3@SV_New_f:

; 1489 : 
; 1490 : 	// g-cont. why this is there?
; 1491 : 	memset( &cl->lastcmd, 0, sizeof( cl->lastcmd ));

	push	56					; 00000038H
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264856				; 00040a98H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1492 : 
; 1493 : 	Netchan_CreateFragments( &cl->netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1494 : 	Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4

; 1495 : 
; 1496 : 	return true;

	mov	eax, 1
$LN1@SV_New_f:

; 1497 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_New_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_WriteDeltaDescriptionToClient
_TEXT	SEGMENT
_dt$1 = -12						; size = 4
_fieldIndex$ = -8					; size = 4
_tableIndex$ = -4					; size = 4
_msg$ = 8						; size = 4
_SV_WriteDeltaDescriptionToClient PROC			; COMDAT

; 1350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1351 : 	int	tableIndex;
; 1352 : 	int	fieldIndex;
; 1353 : 
; 1354 : 	for( tableIndex = 0; tableIndex < Delta_NumTables(); tableIndex++ )

	mov	DWORD PTR _tableIndex$[ebp], 0
	jmp	SHORT $LN4@SV_WriteDe
$LN2@SV_WriteDe:
	mov	eax, DWORD PTR _tableIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _tableIndex$[ebp], eax
$LN4@SV_WriteDe:
	call	_Delta_NumTables
	cmp	DWORD PTR _tableIndex$[ebp], eax
	jge	SHORT $LN1@SV_WriteDe

; 1355 : 	{
; 1356 : 		delta_info_t	*dt = Delta_FindStructByIndex( tableIndex );

	mov	eax, DWORD PTR _tableIndex$[ebp]
	push	eax
	call	_Delta_FindStructByIndex
	add	esp, 4
	mov	DWORD PTR _dt$1[ebp], eax

; 1357 : 
; 1358 : 		for( fieldIndex = 0; fieldIndex < dt->numFields; fieldIndex++ )

	mov	DWORD PTR _fieldIndex$[ebp], 0
	jmp	SHORT $LN7@SV_WriteDe
$LN5@SV_WriteDe:
	mov	eax, DWORD PTR _fieldIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _fieldIndex$[ebp], eax
$LN7@SV_WriteDe:
	mov	eax, DWORD PTR _dt$1[ebp]
	mov	ecx, DWORD PTR _fieldIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN6@SV_WriteDe

; 1359 : 			Delta_WriteTableField( msg, tableIndex, &dt->pFields[fieldIndex] );

	mov	eax, DWORD PTR _fieldIndex$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _dt$1[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	mov	edx, DWORD PTR _tableIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_Delta_WriteTableField
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@SV_WriteDe
$LN6@SV_WriteDe:

; 1360 : 	}

	jmp	SHORT $LN2@SV_WriteDe
$LN1@SV_WriteDe:

; 1361 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_WriteDeltaDescriptionToClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_UpdateClientView
_TEXT	SEGMENT
_viewEnt$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_UpdateClientView PROC				; COMDAT

; 1299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1300 : 	int	viewEnt;
; 1301 : 
; 1302 : 	if( cl->pViewEntity )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264952], 0
	je	SHORT $LN2@SV_UpdateC

; 1303 : 		viewEnt = NUM_FOR_EDICT( cl->pViewEntity );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264952]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
	jmp	SHORT $LN3@SV_UpdateC
$LN2@SV_UpdateC:

; 1304 : 	else viewEnt = NUM_FOR_EDICT( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264948]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$[ebp], eax
$LN3@SV_UpdateC:

; 1305 : 
; 1306 : 	MSG_BeginServerCmd( &cl->netchan.message, svc_setview );

	push	0
	push	1
	push	5
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1307 : 	MSG_WriteWord( &cl->netchan.message, viewEnt );

	mov	eax, DWORD PTR _viewEnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1308 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UpdateClientView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_PutClientInServer
_TEXT	SEGMENT
_viewEnt$1 = -1688					; size = 4
_i$2 = -1684						; size = 4
_name$3 = -1680						; size = 256
_levelData$4 = -1424					; size = 1396
_msg$ = -28						; size = 20
_ent$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_PutClientInServer PROC				; COMDAT

; 1165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1944				; 00000798H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1166 : 	static byte    	msg_buf[0x20200 * 2];	// MAX_INIT_MSG + some space
; 1167 : 	edict_t		*ent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _ent$[ebp], ecx

; 1168 : 	sizebuf_t		msg;
; 1169 : 
; 1170 : 	MSG_Init( &msg, "Spawn", msg_buf, sizeof( msg_buf ));

	push	-1
	push	263168					; 00040400H
	push	OFFSET ?msg_buf@?1??SV_PutClientInServer@@9@9
	push	OFFSET ??_C@_05BEKPGMFA@Spawn@
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 1171 : 
; 1172 : 	if( sv.loadgame )

	cmp	DWORD PTR _sv+8, 0
	je	$LN5@SV_PutClie

; 1173 : 	{
; 1174 : 		// NOTE: we needs to setup angles on restore here
; 1175 : 		if( ent->v.fixangle == 1 )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+288], 1
	jne	SHORT $LN7@SV_PutClie

; 1176 : 		{
; 1177 : 			MSG_BeginServerCmd( &msg, svc_setangle );

	push	0
	push	1
	push	10					; 0000000aH
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1178 : 			MSG_WriteVec3Angles( &msg, ent->v.angles );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteVec3Angles
	add	esp, 8

; 1179 : 			ent->v.fixangle = 0;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+288], 0
$LN7@SV_PutClie:

; 1180 : 		}
; 1181 : 
; 1182 : 		if( svgame.dllFuncs.pfnParmsChangeLevel )

	cmp	DWORD PTR _svgame+19380, 0
	je	$LN8@SV_PutClie

; 1183 : 		{
; 1184 : 			SAVERESTOREDATA	levelData;
; 1185 : 			string		name;
; 1186 : 			int		i;
; 1187 : 
; 1188 : 			memset( &levelData, 0, sizeof( levelData ));

	push	1396					; 00000574H
	push	0
	lea	eax, DWORD PTR _levelData$4[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1189 : 			svgame.globals->pSaveData = &levelData;

	mov	eax, DWORD PTR _svgame+19268
	lea	ecx, DWORD PTR _levelData$4[ebp]
	mov	DWORD PTR [eax+160], ecx

; 1190 : 			svgame.dllFuncs.pfnParmsChangeLevel();

	call	DWORD PTR _svgame+19380

; 1191 : 
; 1192 : 			MSG_BeginServerCmd( &msg, svc_restore );

	push	0
	push	1
	push	33					; 00000021H
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1193 : 			Q_snprintf( name, sizeof( name ), "%s%s.HL2", DEFAULT_SAVE_DIRECTORY, sv.name );

	push	OFFSET _sv+56
	push	OFFSET ??_C@_05HFINLBCI@save?1@
	push	OFFSET ??_C@_08FHNNBCPI@?$CFs?$CFs?4HL2@
	push	256					; 00000100H
	lea	eax, DWORD PTR _name$3[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1194 : 			COM_FixSlashes( name );

	lea	eax, DWORD PTR _name$3[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 1195 : 			MSG_WriteString( &msg, name );

	lea	eax, DWORD PTR _name$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1196 : 			MSG_WriteByte( &msg, levelData.connectionCount );

	mov	eax, DWORD PTR _levelData$4[ebp+36]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 1197 : 
; 1198 : 			for( i = 0; i < levelData.connectionCount; i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@SV_PutClie
$LN2@SV_PutClie:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@SV_PutClie:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _levelData$4[ebp+36]
	jge	SHORT $LN3@SV_PutClie

; 1199 : 				MSG_WriteString( &msg, levelData.levelList[i].mapName );

	imul	eax, DWORD PTR _i$2[ebp], 80
	lea	ecx, DWORD PTR _levelData$4[ebp+eax+44]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8
	jmp	SHORT $LN2@SV_PutClie
$LN3@SV_PutClie:

; 1200 : 
; 1201 : 			svgame.globals->pSaveData = NULL;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+160], 0
$LN8@SV_PutClie:

; 1202 : 		}
; 1203 : 
; 1204 : 		// reset weaponanim
; 1205 : 		MSG_BeginServerCmd( &msg, svc_weaponanim );

	push	0
	push	1
	push	35					; 00000023H
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1206 : 		MSG_WriteLong(&msg, (long)(ent->v.savedvanim));

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+436]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 1207 : 		MSG_WriteFloat(&msg, (float)(ent->v.savedvframerate));

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+440]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteFloat
	add	esp, 8

; 1208 : 		MSG_WriteByte(&msg, (byte)(ent->v.savedvframe));

	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+444]
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 1209 : 
; 1210 : 		sv.loadgame = false;

	mov	DWORD PTR _sv+8, 0

; 1211 : 		sv.paused = false;

	mov	DWORD PTR _sv+2595656, 0

; 1212 : 	}

	jmp	$LN6@SV_PutClie
$LN5@SV_PutClie:

; 1213 : 	else
; 1214 : 	{	
; 1215 : 		if( Q_atoi( Info_ValueForKey( cl->userinfo, "hltv" )))

	push	OFFSET ??_C@_04MLPCGCCJ@hltv@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@SV_PutClie

; 1216 : 			SetBits( cl->flags, FCL_HLTV_PROXY );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN9@SV_PutClie:

; 1217 : 
; 1218 : 		// need to realloc private data for client
; 1219 : 		SV_InitEdict( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SV_InitEdict
	add	esp, 4

; 1220 : 
; 1221 : 		if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN10@SV_PutClie

; 1222 : 			SetBits( ent->v.flags, FL_PROXY );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 1048576				; 00100000H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
	jmp	SHORT $LN11@SV_PutClie
$LN10@SV_PutClie:

; 1223 : 		else ent->v.flags = 0;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+656], 0
$LN11@SV_PutClie:

; 1224 : 
; 1225 : 		ent->v.netname = MAKE_STRING( cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+688], eax

; 1226 : 		ent->v.colormap = NUM_FOR_EDICT( ent );	// ???

	mov	eax, DWORD PTR _ent$[ebp]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+660], eax

; 1227 : 
; 1228 : 		// fisrt entering
; 1229 : 		svgame.globals->time = sv.time;

	cvtsd2ss xmm0, QWORD PTR _sv+16
	mov	eax, DWORD PTR _svgame+19268
	movss	DWORD PTR [eax], xmm0

; 1230 : 		svgame.dllFuncs.pfnClientPutInServer( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	DWORD PTR _svgame+19344
	add	esp, 4

; 1231 : 
; 1232 : 		if( sv.background )	// don't attack player in background mode

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN12@SV_PutClie

; 1233 : 			SetBits( ent->v.flags, FL_GODMODE|FL_NOTARGET );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	or	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+656], ecx
$LN12@SV_PutClie:

; 1234 : 
; 1235 : 		cl->pViewEntity = NULL; // reset pViewEntity

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264952], 0
$LN6@SV_PutClie:

; 1236 : 	}
; 1237 : 
; 1238 : 	if( svgame.globals->cdAudioTrack )

	mov	eax, DWORD PTR _svgame+19268
	cmp	DWORD PTR [eax+140], 0
	je	SHORT $LN13@SV_PutClie

; 1239 : 	{
; 1240 : 		MSG_BeginServerCmd( &msg, svc_stufftext );

	push	0
	push	1
	push	9
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1241 : 		MSG_WriteString( &msg, va( "cd loop %3d\n", svgame.globals->cdAudioTrack ));

	mov	eax, DWORD PTR _svgame+19268
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	push	OFFSET ??_C@_0N@BKPKGGIB@cd?5loop?5?$CF3d?6@
	call	_va
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 1242 : 		svgame.globals->cdAudioTrack = 0;

	mov	eax, DWORD PTR _svgame+19268
	mov	DWORD PTR [eax+140], 0
$LN13@SV_PutClie:

; 1243 : 	}
; 1244 : 
; 1245 : #ifdef HACKS_RELATED_HLMODS
; 1246 : 	// enable dev-mode to prevent crash cheat-protecting from Invasion mod
; 1247 : 	if( FBitSet( ent->v.flags, FL_GODMODE|FL_NOTARGET ) && !Q_stricmp( GI->gamefolder, "invasion" ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	and	ecx, 192				; 000000c0H
	je	SHORT $LN14@SV_PutClie
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08CAOOLPGL@invasion@
	mov	eax, DWORD PTR _SI+768
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_PutClie

; 1248 : 		SV_ExecuteClientCommand( cl, "test\n" );

	push	OFFSET ??_C@_05FPMBMOMC@test?6@
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_ExecuteClientCommand
	add	esp, 8
$LN14@SV_PutClie:

; 1249 : #endif
; 1250 : 	// refresh the userinfo and movevars
; 1251 : 	// NOTE: because movevars can be changed during the connection process
; 1252 : 	SetBits( cl->flags, FCL_RESEND_USERINFO|FCL_RESEND_MOVEVARS );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 3
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 1253 : 
; 1254 : 	// reset client times
; 1255 : 	cl->connecttime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264912], xmm0

; 1256 : 	cl->ignorecmdtime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264928], xmm0

; 1257 : 	cl->cmdtime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264920], xmm0

; 1258 : 
; 1259 : 	if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	$LN19@SV_PutClie

; 1260 : 	{
; 1261 : 		int	viewEnt;
; 1262 : 
; 1263 : 		// NOTE: it's will be fragmented automatically in right ordering
; 1264 : 		MSG_WriteBits( &msg, MSG_GetData( &sv.signon ), MSG_GetNumBitsWritten( &sv.signon ));

	push	OFFSET _sv+2456340
	call	_MSG_GetNumBitsWritten
	add	esp, 4
	push	eax
	push	OFFSET _sv+2456340
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteBits
	add	esp, 12					; 0000000cH

; 1265 : 
; 1266 : 		if( cl->pViewEntity )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264952], 0
	je	SHORT $LN16@SV_PutClie

; 1267 : 			viewEnt = NUM_FOR_EDICT( cl->pViewEntity );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264952]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$1[ebp], eax
	jmp	SHORT $LN17@SV_PutClie
$LN16@SV_PutClie:

; 1268 : 		else viewEnt = NUM_FOR_EDICT( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264948]
	sub	eax, DWORD PTR _svgame+7928
	cdq
	mov	ecx, 900				; 00000384H
	idiv	ecx
	mov	DWORD PTR _viewEnt$1[ebp], eax
$LN17@SV_PutClie:

; 1269 : 
; 1270 : 		MSG_BeginServerCmd( &msg, svc_setview );

	push	0
	push	1
	push	5
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1271 : 		MSG_WriteWord( &msg, viewEnt );

	mov	eax, DWORD PTR _viewEnt$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteWord
	add	esp, 8

; 1272 : 
; 1273 : 		MSG_BeginServerCmd( &msg, svc_signonnum );

	push	0
	push	1
	push	25					; 00000019H
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1274 : 		MSG_WriteByte( &msg, 1 );

	push	1
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteByte
	add	esp, 8

; 1275 : 
; 1276 : 		if( MSG_CheckOverflow( &msg ))

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@SV_PutClie

; 1277 : 		{
; 1278 : 			if( svs.maxclients == 1 )

	cmp	DWORD PTR _svs+16, 1
	jne	SHORT $LN20@SV_PutClie

; 1279 : 				Host_Error( "spawn player: overflowed\n" );

	push	OFFSET ??_C@_0BK@LNONJGHE@spawn?5player?3?5overflowed?6@
	call	_Host_Error
	add	esp, 4
	jmp	SHORT $LN21@SV_PutClie
$LN20@SV_PutClie:

; 1280 : 			else SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8
$LN21@SV_PutClie:

; 1281 : 		}

	jmp	SHORT $LN19@SV_PutClie
$LN18@SV_PutClie:

; 1282 : 		else
; 1283 : 		{
; 1284 : 			// send initialization data
; 1285 : 			Netchan_CreateFragments( &cl->netchan, &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	call	_Netchan_CreateFragments
	add	esp, 8

; 1286 : 			Netchan_FragSend( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_FragSend
	add	esp, 4
$LN19@SV_PutClie:

; 1287 : 		}
; 1288 : 	}
; 1289 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_PutClientInServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_CalcClientTime
_TEXT	SEGMENT
tv192 = -104						; size = 8
tv91 = -100						; size = 4
tv70 = -100						; size = 4
tv67 = -100						; size = 4
_frame$1 = -32						; size = 4
_frame$2 = -28						; size = 4
_backtrack$ = -24					; size = 4
_count$ = -20						; size = 4
_i$ = -16						; size = 4
_ping$ = -12						; size = 4
_maxping$ = -8						; size = 4
_minping$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_CalcClientTime PROC					; COMDAT

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 967  : 	float	minping, maxping;
; 968  : 	float	ping = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _ping$[ebp], xmm0

; 969  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 970  : 	int	backtrack;
; 971  : 
; 972  : 	backtrack = (int)sv_unlagsamples.value;

	cvttss2si eax, DWORD PTR _sv_unlagsamples+12
	mov	DWORD PTR _backtrack$[ebp], eax

; 973  : 	if( backtrack < 1 ) backtrack = 1;

	cmp	DWORD PTR _backtrack$[ebp], 1
	jge	SHORT $LN8@SV_CalcCli
	mov	DWORD PTR _backtrack$[ebp], 1
$LN8@SV_CalcCli:

; 974  : 
; 975  : 	if( backtrack >= (SV_UPDATE_BACKUP <= 16 ? SV_UPDATE_BACKUP : 16 ))

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 16		; 00000010H
	jg	SHORT $LN19@SV_CalcCli
	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN20@SV_CalcCli
$LN19@SV_CalcCli:
	mov	DWORD PTR tv67[ebp], 16			; 00000010H
$LN20@SV_CalcCli:
	mov	ecx, DWORD PTR _backtrack$[ebp]
	cmp	ecx, DWORD PTR tv67[ebp]
	jl	SHORT $LN9@SV_CalcCli

; 976  : 		backtrack = ( SV_UPDATE_BACKUP <= 16 ? SV_UPDATE_BACKUP : 16 );

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 16		; 00000010H
	jg	SHORT $LN21@SV_CalcCli
	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN22@SV_CalcCli
$LN21@SV_CalcCli:
	mov	DWORD PTR tv70[ebp], 16			; 00000010H
$LN22@SV_CalcCli:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _backtrack$[ebp], ecx
$LN9@SV_CalcCli:

; 977  : 
; 978  : 	if( backtrack <= 0 )

	cmp	DWORD PTR _backtrack$[ebp], 0
	jg	SHORT $LN10@SV_CalcCli

; 979  : 		return 0.0f;

	fldz
	jmp	$LN1@SV_CalcCli
$LN10@SV_CalcCli:

; 980  : 
; 981  : 	for( i = 0; i < backtrack; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CalcCli
$LN2@SV_CalcCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CalcCli:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _backtrack$[ebp]
	jge	SHORT $LN3@SV_CalcCli

; 982  : 	{
; 983  : 		client_frame_t	*frame = &cl->frames[SV_UPDATE_MASK & (cl->netchan.incoming_acknowledged - i)];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	sub	edx, DWORD PTR _i$[ebp]
	and	eax, edx
	imul	eax, eax, 9296
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281884]
	mov	DWORD PTR _frame$2[ebp], eax

; 984  : 		if( frame->ping_time <= 0.0f )

	mov	eax, DWORD PTR _frame$2[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+8]
	jb	SHORT $LN11@SV_CalcCli

; 985  : 			continue;

	jmp	SHORT $LN2@SV_CalcCli
$LN11@SV_CalcCli:

; 986  : 
; 987  : 		ping += frame->ping_time;

	mov	eax, DWORD PTR _frame$2[ebp]
	movss	xmm0, DWORD PTR _ping$[ebp]
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _ping$[ebp], xmm0

; 988  : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 989  : 	}

	jmp	SHORT $LN2@SV_CalcCli
$LN3@SV_CalcCli:

; 990  : 
; 991  : 	if( !count ) return 0.0f;

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN12@SV_CalcCli
	fldz
	jmp	$LN1@SV_CalcCli
$LN12@SV_CalcCli:

; 992  : 
; 993  : 	minping =  9999.0f;

	movss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR _minping$[ebp], xmm0

; 994  : 	maxping = -9999.0f;

	movss	xmm0, DWORD PTR __real@c61c3c00
	movss	DWORD PTR _maxping$[ebp], xmm0

; 995  : 	ping /= count;

	cvtsi2ss xmm0, DWORD PTR _count$[ebp]
	movss	xmm1, DWORD PTR _ping$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _ping$[ebp], xmm1

; 996  : 	
; 997  : 	for( i = 0; i < ( SV_UPDATE_BACKUP <= 4 ? SV_UPDATE_BACKUP : 4 ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_CalcCli
$LN5@SV_CalcCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_CalcCli:
	cmp	DWORD PTR _SV_UPDATE_BACKUP, 4
	jg	SHORT $LN23@SV_CalcCli
	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN24@SV_CalcCli
$LN23@SV_CalcCli:
	mov	DWORD PTR tv91[ebp], 4
$LN24@SV_CalcCli:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR tv91[ebp]
	jge	SHORT $LN6@SV_CalcCli

; 998  : 	{
; 999  : 		client_frame_t	*frame = &cl->frames[SV_UPDATE_MASK & (cl->netchan.incoming_acknowledged - i)];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	sub	edx, DWORD PTR _i$[ebp]
	and	eax, edx
	imul	eax, eax, 9296
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+281884]
	mov	DWORD PTR _frame$1[ebp], eax

; 1000 : 		if( frame->ping_time <= 0.0f )

	mov	eax, DWORD PTR _frame$1[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+8]
	jb	SHORT $LN13@SV_CalcCli

; 1001 : 			continue;

	jmp	SHORT $LN5@SV_CalcCli
$LN13@SV_CalcCli:

; 1002 : 
; 1003 : 		if( frame->ping_time < minping )

	mov	eax, DWORD PTR _frame$1[ebp]
	movss	xmm0, DWORD PTR _minping$[ebp]
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN14@SV_CalcCli

; 1004 : 			minping = frame->ping_time;

	mov	eax, DWORD PTR _frame$1[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _minping$[ebp], xmm0
$LN14@SV_CalcCli:

; 1005 : 
; 1006 : 		if( frame->ping_time > maxping )

	mov	eax, DWORD PTR _frame$1[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR _maxping$[ebp]
	jbe	SHORT $LN15@SV_CalcCli

; 1007 : 			maxping = frame->ping_time;

	mov	eax, DWORD PTR _frame$1[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _maxping$[ebp], xmm0
$LN15@SV_CalcCli:

; 1008 : 	}

	jmp	$LN5@SV_CalcCli
$LN6@SV_CalcCli:

; 1009 : 
; 1010 : 	if( maxping < minping || fabs( maxping - minping ) <= 0.2f )

	movss	xmm0, DWORD PTR _minping$[ebp]
	comiss	xmm0, DWORD PTR _maxping$[ebp]
	ja	SHORT $LN17@SV_CalcCli
	movss	xmm0, DWORD PTR _maxping$[ebp]
	subss	xmm0, DWORD PTR _minping$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv192[ebp]
	movsd	xmm0, QWORD PTR __real@3fc99999a0000000
	comisd	xmm0, QWORD PTR tv192[ebp]
	jb	SHORT $LN16@SV_CalcCli
$LN17@SV_CalcCli:

; 1011 : 		return ping;

	fld	DWORD PTR _ping$[ebp]
	jmp	SHORT $LN1@SV_CalcCli
$LN16@SV_CalcCli:

; 1012 : 
; 1013 : 	return 0.0f;

	fldz
$LN1@SV_CalcCli:

; 1014 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CalcClientTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_EstablishTimeBase
_TEXT	SEGMENT
_cmdnum$ = -16						; size = 4
_i$ = -12						; size = 4
_runcmd_time$ = -8					; size = 8
_cl$ = 8						; size = 4
_cmds$ = 12						; size = 4
_dropped$ = 16						; size = 4
_numbackup$ = 20					; size = 4
_numcmds$ = 24						; size = 4
_SV_EstablishTimeBase PROC				; COMDAT

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 933  : 	double	runcmd_time = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 934  : 	int	i, cmdnum = dropped;

	mov	eax, DWORD PTR _dropped$[ebp]
	mov	DWORD PTR _cmdnum$[ebp], eax

; 935  : 
; 936  : 	if( dropped < 24 )

	cmp	DWORD PTR _dropped$[ebp], 24		; 00000018H
	jge	SHORT $LN5@SV_Establi
$LN2@SV_Establi:

; 937  : 	{
; 938  : 		while( dropped > numbackup )

	mov	eax, DWORD PTR _dropped$[ebp]
	cmp	eax, DWORD PTR _numbackup$[ebp]
	jle	SHORT $LN3@SV_Establi

; 939  : 		{
; 940  : 			runcmd_time = (double)cl->lastcmd.msec / 1000.0;

	mov	eax, DWORD PTR _cl$[ebp]
	movzx	ecx, BYTE PTR [eax+264858]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 941  : 			dropped--;

	mov	eax, DWORD PTR _dropped$[ebp]
	sub	eax, 1
	mov	DWORD PTR _dropped$[ebp], eax

; 942  : 		}

	jmp	SHORT $LN2@SV_Establi
$LN3@SV_Establi:

; 943  : 
; 944  : 		while( dropped > 0 )

	cmp	DWORD PTR _dropped$[ebp], 0
	jle	SHORT $LN5@SV_Establi

; 945  : 		{
; 946  : 			cmdnum = dropped + numcmds - 1;

	mov	eax, DWORD PTR _numcmds$[ebp]
	mov	ecx, DWORD PTR _dropped$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _cmdnum$[ebp], edx

; 947  : 			runcmd_time += (double)cmds[cmdnum].msec / 1000.0;

	imul	eax, DWORD PTR _cmdnum$[ebp], 56
	mov	ecx, DWORD PTR _cmds$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+2]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0

; 948  : 			dropped--;

	mov	eax, DWORD PTR _dropped$[ebp]
	sub	eax, 1
	mov	DWORD PTR _dropped$[ebp], eax

; 949  : 		}		

	jmp	SHORT $LN3@SV_Establi
$LN5@SV_Establi:

; 950  : 	}
; 951  : 
; 952  : 	for( i = numcmds - 1; i >= 0; i-- )

	mov	eax, DWORD PTR _numcmds$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN8@SV_Establi
$LN6@SV_Establi:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@SV_Establi:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN7@SV_Establi

; 953  : 		runcmd_time += cmds[i].msec / 1000.0;

	imul	eax, DWORD PTR _i$[ebp], 56
	mov	ecx, DWORD PTR _cmds$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+2]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	movsd	QWORD PTR _runcmd_time$[ebp], xmm0
	jmp	SHORT $LN6@SV_Establi
$LN7@SV_Establi:

; 954  : 
; 955  : 	cl->timebase = sv.time + sv.frametime - runcmd_time;

	cvtss2sd xmm0, DWORD PTR _sv+32
	addsd	xmm0, QWORD PTR _sv+16
	subsd	xmm0, QWORD PTR _runcmd_time$[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264368], xmm0

; 956  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EstablishTimeBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _Rcon_Validate
_TEXT	SEGMENT
_Rcon_Validate PROC					; COMDAT

; 838  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 839  : 	if( !Q_strlen( rcon_password.string ))

	mov	eax, DWORD PTR _rcon_password+4
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@Rcon_Valid

; 840  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Rcon_Valid
$LN2@Rcon_Valid:

; 841  : 	if( Q_strcmp( Cmd_Argv( 1 ), rcon_password.string ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _rcon_password+4
	push	eax
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@Rcon_Valid

; 842  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Rcon_Valid
$LN3@Rcon_Valid:

; 843  : 	return true;

	mov	eax, 1
$LN1@Rcon_Valid:

; 844  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Rcon_Validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Ping
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_Ping PROC						; COMDAT

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 829  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "ack" );

	push	OFFSET ??_C@_03JBLJHHJA@ack@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 830  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Ping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_BuildNetAnswer
_TEXT	SEGMENT
$T1 = -944						; size = 4
$T2 = -940						; size = 4
$T3 = -936						; size = 4
$T4 = -932						; size = 4
_time$5 = -800						; size = 4
_ed$6 = -796						; size = 4
_count$ = -792						; size = 4
_i$ = -788						; size = 4
_type$ = -784						; size = 4
_context$ = -780					; size = 4
_version$ = -776					; size = 4
_answer$ = -772						; size = 512
_string$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_BuildNetAnswer PROC					; COMDAT

; 737  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 944				; 000003b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 738  : 	char	string[MAX_INFO_STRING], answer[512];
; 739  : 	int	version, context, type;
; 740  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 741  : 
; 742  : 	// ignore in single player
; 743  : 	if( svs.maxclients == 1 || !svs.initialized )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN9@SV_BuildNe
	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN8@SV_BuildNe
$LN9@SV_BuildNe:

; 744  : 		return;

	jmp	$LN19@SV_BuildNe
$LN8@SV_BuildNe:

; 745  : 
; 746  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 747  : 	context = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _context$[ebp], eax

; 748  : 	type = Q_atoi( Cmd_Argv( 3 ));

	push	3
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 749  : 
; 750  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	$LN10@SV_BuildNe

; 751  : 	{
; 752  : 		// handle the unsupported protocol
; 753  : 		string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN22@SV_BuildNe
	jmp	SHORT $LN23@SV_BuildNe
$LN22@SV_BuildNe:
	call	___report_rangecheckfailure
$LN23@SV_BuildNe:
	mov	edx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 754  : 		Info_SetValueForKey( string, "neterror", "protocol", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_08FCFPNNHF@protocol@
	push	OFFSET ??_C@_08EJOEDJLI@neterror@
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 755  : 
; 756  : 		// send error unsupported protocol
; 757  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 758  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 759  : 		return;

	jmp	$LN19@SV_BuildNe
$LN10@SV_BuildNe:

; 760  : 	}
; 761  : 
; 762  : 	if( type == NETAPI_REQUEST_PING )

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN11@SV_BuildNe

; 763  : 	{
; 764  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, "" );

	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _context$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 765  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 766  : 	}

	jmp	$LN19@SV_BuildNe
$LN11@SV_BuildNe:

; 767  : 	else if( type == NETAPI_REQUEST_RULES )

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN13@SV_BuildNe

; 768  : 	{
; 769  : 		// send serverinfo
; 770  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, svs.serverinfo );

	push	OFFSET _svs+60
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _context$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	edx, DWORD PTR _answer$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 771  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 772  : 	}

	jmp	$LN19@SV_BuildNe
$LN13@SV_BuildNe:

; 773  : 	else if( type == NETAPI_REQUEST_PLAYERS )

	cmp	DWORD PTR _type$[ebp], 3
	jne	$LN15@SV_BuildNe

; 774  : 	{
; 775  : 		string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 256			; 00000100H
	jae	SHORT $LN24@SV_BuildNe
	jmp	SHORT $LN25@SV_BuildNe
$LN24@SV_BuildNe:
	call	___report_rangecheckfailure
$LN25@SV_BuildNe:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 776  : 
; 777  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_BuildNe
$LN2@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_BuildNe

; 778  : 		{
; 779  : 			if( svs.clients[i].state >= cs_connected )

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 2
	jl	$LN17@SV_BuildNe

; 780  : 			{
; 781  : 				edict_t *ed = svs.clients[i].edict;

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	mov	edx, DWORD PTR [ecx+eax+264948]
	mov	DWORD PTR _ed$6[ebp], edx

; 782  : 				float time = host.realtime - svs.clients[i].connection_started;

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [ecx+eax+264376]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _time$5[ebp], xmm0

; 783  : 				Q_strncat( string, va( "%c\\%s\\%i\\%f\\", count, svs.clients[i].name, (int)ed->v.frags, time ), sizeof( string )); 

	push	256					; 00000100H
	cvtss2sd xmm0, DWORD PTR _time$5[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ed$6[ebp]
	cvttss2si ecx, DWORD PTR [eax+592]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 289832
	mov	eax, DWORD PTR _svs+33344
	lea	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@JDEEPBCI@?$CFc?2?$CFs?2?$CFi?2?$CFf?2@
	call	_va
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 784  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN17@SV_BuildNe:

; 785  : 			}
; 786  : 		}

	jmp	$LN2@SV_BuildNe
$LN3@SV_BuildNe:

; 787  : 
; 788  : 		// send playernames
; 789  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 790  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 791  : 	}

	jmp	$LN19@SV_BuildNe
$LN15@SV_BuildNe:

; 792  : 	else if( type == NETAPI_REQUEST_DETAILS )

	cmp	DWORD PTR _type$[ebp], 4
	jne	$LN18@SV_BuildNe

; 793  : 	{
; 794  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@SV_BuildNe
$LN5@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_BuildNe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_BuildNe

; 795  : 			if( svs.clients[i].state >= cs_connected )

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 2
	jl	SHORT $LN20@SV_BuildNe

; 796  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN20@SV_BuildNe:
	jmp	SHORT $LN5@SV_BuildNe
$LN6@SV_BuildNe:

; 797  : 
; 798  : 		string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN26@SV_BuildNe
	jmp	SHORT $LN27@SV_BuildNe
$LN26@SV_BuildNe:
	call	___report_rangecheckfailure
$LN27@SV_BuildNe:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 799  : 		Info_SetValueForKey( string, "hostname", hostname.string, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _hostname+4
	push	eax
	push	OFFSET ??_C@_08EHKIGBEA@hostname@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 800  : 		Info_SetValueForKey( string, "gamedir", GI->gamefolder, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 801  : 		Info_SetValueForKey( string, "current", va( "%i", count ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_07LKPDDKMO@current@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 802  : 		Info_SetValueForKey( string, "max", va( "%i", svs.maxclients ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svs+16
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_03LJAEFNNE@max@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 803  : 		Info_SetValueForKey( string, "map", sv.name, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	push	OFFSET ??_C@_03HBNNNHNM@map@
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 804  : 
; 805  : 		// send serverinfo
; 806  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 807  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 808  : 	}

	jmp	$LN19@SV_BuildNe
$LN18@SV_BuildNe:

; 809  : 	else
; 810  : 	{
; 811  : 		string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN28@SV_BuildNe
	jmp	SHORT $LN29@SV_BuildNe
$LN28@SV_BuildNe:
	call	___report_rangecheckfailure
$LN29@SV_BuildNe:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 812  : 		Info_SetValueForKey( string, "neterror", "undefined", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_09MLGAJAED@undefined@
	push	OFFSET ??_C@_08EJOEDJLI@neterror@
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 813  : 
; 814  : 		// send error undefined request type
; 815  : 		Q_snprintf( answer, sizeof( answer ), "netinfo %i %i %s\n", context, type, string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _context$[ebp]
	push	edx
	push	OFFSET ??_C@_0BC@DJBMEGA@netinfo?5?$CFi?5?$CFi?5?$CFs?6@
	push	512					; 00000200H
	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 816  : 		Netchan_OutOfBandPrint( NS_SERVER, from, answer );

	lea	eax, DWORD PTR _answer$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH
$LN19@SV_BuildNe:

; 817  : 	}
; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BuildNetAnswer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Info
_TEXT	SEGMENT
$T1 = -340						; size = 4
_version$ = -272					; size = 4
_count$ = -268						; size = 4
_i$ = -264						; size = 4
_string$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_Info PROC						; COMDAT

; 694  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 695  : 	char	string[MAX_INFO_STRING];
; 696  : 	int	i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 697  : 	int	version;
; 698  : 
; 699  : 	// ignore in single player
; 700  : 	if( svs.maxclients == 1 || !svs.initialized )

	cmp	DWORD PTR _svs+16, 1
	je	SHORT $LN6@SV_Info
	cmp	DWORD PTR _svs, 0
	jne	SHORT $LN5@SV_Info
$LN6@SV_Info:

; 701  : 		return;

	jmp	$LN1@SV_Info
$LN5@SV_Info:

; 702  : 
; 703  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 704  : 	string[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN11@SV_Info
	jmp	SHORT $LN12@SV_Info
$LN11@SV_Info:
	call	___report_rangecheckfailure
$LN12@SV_Info:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _string$[ebp+edx], 0

; 705  : 
; 706  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN7@SV_Info

; 707  : 	{
; 708  : 		Q_snprintf( string, sizeof( string ), "%s: wrong version\n", hostname.string );

	mov	eax, DWORD PTR _hostname+4
	push	eax
	push	OFFSET ??_C@_0BD@OIMKEPNL@?$CFs?3?5wrong?5version?6@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 709  : 	}

	jmp	$LN8@SV_Info
$LN7@SV_Info:

; 710  : 	else
; 711  : 	{
; 712  : 		for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_Info
$LN2@SV_Info:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_Info:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_Info

; 713  : 			if( svs.clients[i].state >= cs_connected )

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 2
	jl	SHORT $LN9@SV_Info

; 714  : 				count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN9@SV_Info:
	jmp	SHORT $LN2@SV_Info
$LN3@SV_Info:

; 715  : 
; 716  : 		Info_SetValueForKey( string, "host", hostname.string, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _hostname+4
	push	eax
	push	OFFSET ??_C@_04OODOLJMA@host@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 717  : 		Info_SetValueForKey( string, "map", sv.name, MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET _sv+56
	push	OFFSET ??_C@_03HBNNNHNM@map@
	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 718  : 		Info_SetValueForKey( string, "dm", va( "%i", (int)svgame.globals->deathmatch ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svgame+19268
	cvttss2si ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_02JPDDFAPL@dm@
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 719  : 		Info_SetValueForKey( string, "team", va( "%i", (int)svgame.globals->teamplay ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svgame+19268
	cvttss2si ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_04KADBPNCB@team@
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 720  : 		Info_SetValueForKey( string, "coop", va( "%i", (int)svgame.globals->coop ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svgame+19268
	cvttss2si ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_04OILOBHMB@coop@
	lea	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 721  : 		Info_SetValueForKey( string, "numcl", va( "%i", count ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_05HGECBMF@numcl@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 722  : 		Info_SetValueForKey( string, "maxcl", va( "%i", svs.maxclients ), MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _svs+16
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_05HDFHMFIE@maxcl@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 723  : 		Info_SetValueForKey( string, "gamedir", GI->gamefolder, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H
$LN8@SV_Info:

; 724  : 	}
; 725  : 
; 726  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "info\n%s", string );

	lea	eax, DWORD PTR _string$[ebp]
	push	eax
	push	OFFSET ??_C@_07BOBGOODP@info?6?$CFs@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H
$LN1@SV_Info:

; 727  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_Ack
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_Ack	PROC						; COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 682  : 	Con_Printf( "ping %s\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_08BCPMNFMF@ping?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 683  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_Ack	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_TestBandWidth
_TEXT	SEGMENT
_send$ = -64048						; size = 20
_test$ = -64028						; size = 4
_crcpos$ = -64024					; size = 4
_filepos$ = -64020					; size = 4
_crcValue$ = -64016					; size = 4
_send_buf$ = -64012					; size = 64000
_packetsize$ = -12					; size = 4
_version$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_TestBandWidth PROC					; COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 64560				; 0000fc30H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 630  : 	int	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 631  : 	int	packetsize = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _packetsize$[ebp], eax

; 632  : 	byte	send_buf[FRAGMENT_MAX_SIZE];
; 633  : 	dword	crcValue = 0;

	mov	DWORD PTR _crcValue$[ebp], 0

; 634  : 	byte	*filepos;
; 635  : 	int	crcpos;
; 636  : 	file_t	*test;
; 637  : 	sizebuf_t	send;
; 638  : 
; 639  : 	// don't waste time of protocol mismatched
; 640  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN2@SV_TestBan

; 641  : 	{
; 642  : 		SV_RejectConnection( from, "unsupported protocol (%i should be %i)\n", version, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@EIIIDCNK@unsupported?5protocol?5?$CI?$CFi?5should@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_RejectConnection
	add	esp, 32					; 00000020H

; 643  : 		return;

	jmp	$LN1@SV_TestBan
$LN2@SV_TestBan:

; 644  : 	}
; 645  : 
; 646  : 	test = FS_Open( "gfx.wad", "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	push	OFFSET ??_C@_07IPHJHJLD@gfx?4wad@
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _test$[ebp], eax

; 647  : 
; 648  : 	if( FS_FileLength( test ) < sizeof( send_buf ))

	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_FS_FileLength
	add	esp, 4
	cmp	eax, 64000				; 0000fa00H
	jae	SHORT $LN3@SV_TestBan

; 649  : 	{
; 650  : 		// skip the test and just get challenge
; 651  : 		SV_GetChallenge( from );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_GetChallenge
	add	esp, 20					; 00000014H

; 652  : 		return;

	jmp	$LN1@SV_TestBan
$LN3@SV_TestBan:

; 653  : 	}
; 654  : 
; 655  : 	// write the packet header
; 656  : 	MSG_Init( &send, "BandWidthPacket", send_buf, sizeof( send_buf ));

	push	-1
	push	64000					; 0000fa00H
	lea	eax, DWORD PTR _send_buf$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@KODPIFE@BandWidthPacket@
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 657  : 	MSG_WriteLong( &send, -1 );	// -1 sequence means out of band

	push	-1
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 658  : 	MSG_WriteString( &send, "testpacket" );

	push	OFFSET ??_C@_0L@BEEDAEFO@testpacket@
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 659  : 	crcpos = MSG_GetNumBytesWritten( &send );

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _crcpos$[ebp], eax

; 660  : 	MSG_WriteLong( &send, 0 ); // reserve space for crc

	push	0
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 661  : 	filepos = send.pData + MSG_GetNumBytesWritten( &send );

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	add	eax, DWORD PTR _send$[ebp+8]
	mov	DWORD PTR _filepos$[ebp], eax

; 662  : 	packetsize = packetsize - MSG_GetNumBytesWritten( &send ); // adjust the packet size

	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	ecx, DWORD PTR _packetsize$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _packetsize$[ebp], ecx

; 663  : 	FS_Read( test, filepos, packetsize );

	mov	eax, DWORD PTR _packetsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filepos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _test$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 664  : 	FS_Close( test );

	mov	eax, DWORD PTR _test$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 665  : 
; 666  : 	CRC32_ProcessBuffer( &crcValue, filepos, packetsize );	// calc CRC

	mov	eax, DWORD PTR _packetsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filepos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _crcValue$[ebp]
	push	edx
	call	_CRC32_ProcessBuffer
	add	esp, 12					; 0000000cH

; 667  : 	MSG_SeekToBit( &send, packetsize << 3, SEEK_CUR );

	push	1
	mov	eax, DWORD PTR _packetsize$[ebp]
	shl	eax, 3
	push	eax
	lea	ecx, DWORD PTR _send$[ebp]
	push	ecx
	call	_MSG_SeekToBit
	add	esp, 12					; 0000000cH

; 668  : 	*(uint *)&send.pData[crcpos] = crcValue;

	mov	eax, DWORD PTR _send$[ebp+8]
	add	eax, DWORD PTR _crcpos$[ebp]
	mov	ecx, DWORD PTR _crcValue$[ebp]
	mov	DWORD PTR [eax], ecx

; 669  : 
; 670  : 	// send the datagram
; 671  : 	NET_SendPacket( NS_SERVER, MSG_GetNumBytesWritten( &send ), MSG_GetData( &send ), from );

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR _send$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _send$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	push	eax
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
$LN1@SV_TestBan:

; 672  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TestBandWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FlushRedirect
_TEXT	SEGMENT
tv68 = -68						; size = 4
_adr$ = 8						; size = 20
_dest$ = 28						; size = 4
_buf$ = 32						; size = 4
_SV_FlushRedirect PROC					; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 559  : 	if( sv.current_client && FBitSet( sv.current_client->flags, FCL_FAKECLIENT ))

	cmp	DWORD PTR _sv+40, 0
	je	SHORT $LN4@SV_FlushRe
	mov	eax, DWORD PTR _sv+40
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN4@SV_FlushRe

; 560  : 		return;

	jmp	$LN1@SV_FlushRe
$LN4@SV_FlushRe:

; 561  : 
; 562  : 	switch( dest )

	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 0
	je	$LN8@SV_FlushRe
	cmp	DWORD PTR tv68[ebp], 1
	je	SHORT $LN6@SV_FlushRe
	cmp	DWORD PTR tv68[ebp], 2
	je	SHORT $LN5@SV_FlushRe
	jmp	$LN1@SV_FlushRe
$LN5@SV_FlushRe:

; 563  : 	{
; 564  : 	case RD_PACKET:
; 565  : 		Netchan_OutOfBandPrint( NS_SERVER, adr, "print\n%s", buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	OFFSET ??_C@_08HCILNBCA@print?6?$CFs@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 566  : 		break;

	jmp	SHORT $LN1@SV_FlushRe
$LN6@SV_FlushRe:

; 567  : 	case RD_CLIENT:
; 568  : 		if( !sv.current_client ) return; // client not set

	cmp	DWORD PTR _sv+40, 0
	jne	SHORT $LN7@SV_FlushRe
	jmp	SHORT $LN1@SV_FlushRe
$LN7@SV_FlushRe:

; 569  : 		MSG_BeginServerCmd( &sv.current_client->netchan.message, svc_print );

	push	0
	push	1
	push	8
	mov	eax, DWORD PTR _sv+40
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 570  : 		MSG_WriteString( &sv.current_client->netchan.message, buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sv+40
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 571  : 		break;

	jmp	SHORT $LN1@SV_FlushRe
$LN8@SV_FlushRe:

; 572  : 	case RD_NONE:
; 573  : 		Con_Printf( S_ERROR "SV_FlushRedirect: %s: invalid destination\n", NET_AdrToString( adr ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DG@MHGFLFH@?$FO1Error?3?$FO7?5SV_FlushRedirect?3?5?$CFs@
	call	_Con_Printf
	add	esp, 8
$LN1@SV_FlushRe:

; 574  : 		break;
; 575  : 	}
; 576  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FlushRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_BeginRedirect
_TEXT	SEGMENT
_adr$ = 8						; size = 20
_target$ = 28						; size = 4
_buffer$ = 32						; size = 4
_buffersize$ = 36					; size = 4
_flush$ = 40						; size = 4
_SV_BeginRedirect PROC					; COMDAT

; 545  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 546  : 	if( !target || !buffer || !buffersize || !flush )

	cmp	DWORD PTR _target$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _buffersize$[ebp], 0
	je	SHORT $LN3@SV_BeginRe
	cmp	DWORD PTR _flush$[ebp], 0
	jne	SHORT $LN2@SV_BeginRe
$LN3@SV_BeginRe:

; 547  : 		return;

	jmp	SHORT $LN1@SV_BeginRe
$LN2@SV_BeginRe:

; 548  : 
; 549  : 	host.rd.target = target;

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR _host+884, eax

; 550  : 	host.rd.buffer = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _host+888, eax

; 551  : 	host.rd.buffersize = buffersize;

	mov	eax, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR _host+892, eax

; 552  : 	host.rd.flush = flush;

	mov	eax, DWORD PTR _flush$[ebp]
	mov	DWORD PTR _host+916, eax

; 553  : 	host.rd.address = adr;

	mov	eax, DWORD PTR _adr$[ebp]
	mov	DWORD PTR _host+896, eax
	mov	ecx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR _host+900, ecx
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR _host+904, edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR _host+908, eax
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR _host+912, ecx

; 554  : 	host.rd.buffer[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host+888
	mov	BYTE PTR [edx+ecx], 0
$LN1@SV_BeginRe:

; 555  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BeginRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ConnectClient
_TEXT	SEGMENT
_s$ = -556						; size = 4
_challenge$ = -552					; size = 4
_count$ = -548						; size = 4
_i$ = -544						; size = 4
_version$ = -540					; size = 4
_qport$ = -536						; size = 4
_nClientSlot$ = -532					; size = 4
_reconnect$ = -528					; size = 4
_newcl$ = -524						; size = 4
_cl$ = -520						; size = 4
_protinfo$ = -516					; size = 256
_userinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_SV_ConnectClient PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 234  : 	char		userinfo[MAX_INFO_STRING];
; 235  : 	char		protinfo[MAX_INFO_STRING];
; 236  : 	sv_client_t	*cl, *newcl = NULL;

	mov	DWORD PTR _newcl$[ebp], 0

; 237  : 	qboolean		reconnect = false;

	mov	DWORD PTR _reconnect$[ebp], 0

; 238  : 	int		nClientSlot = 0;

	mov	DWORD PTR _nClientSlot$[ebp], 0

; 239  : 	int		qport, version;
; 240  : 	int		i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 241  : 	int		challenge;
; 242  : 	char		*s;
; 243  : 
; 244  : 	if( Cmd_Argc() < 5 )

	call	_Cmd_Argc
	cmp	eax, 5
	jae	SHORT $LN8@SV_Connect

; 245  : 	{
; 246  : 		SV_RejectConnection( from, "insufficient connection info\n" );

	push	OFFSET ??_C@_0BO@PBPHMGIF@insufficient?5connection?5info?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 247  : 		return;

	jmp	$LN26@SV_Connect
$LN8@SV_Connect:

; 248  : 	}
; 249  : 
; 250  : 	version = Q_atoi( Cmd_Argv( 1 ));

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _version$[ebp], eax

; 251  : 
; 252  : 	if( version != PROTOCOL_VERSION )

	cmp	DWORD PTR _version$[ebp], 49		; 00000031H
	je	SHORT $LN9@SV_Connect

; 253  : 	{
; 254  : 		SV_RejectConnection( from, "unsupported protocol (%i should be %i)\n", version, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _version$[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@EIIIDCNK@unsupported?5protocol?5?$CI?$CFi?5should@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_RejectConnection
	add	esp, 32					; 00000020H

; 255  : 		return;

	jmp	$LN26@SV_Connect
$LN9@SV_Connect:

; 256  : 	}
; 257  : 
; 258  : 	challenge = Q_atoi( Cmd_Argv( 2 )); // get challenge

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _challenge$[ebp], eax

; 259  : 
; 260  : 	// see if the challenge is valid (local clients don't need to challenge)
; 261  : 	if( !SV_CheckChallenge( from, challenge ))

	mov	eax, DWORD PTR _challenge$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_CheckChallenge
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN10@SV_Connect

; 262  : 		return;

	jmp	$LN26@SV_Connect
$LN10@SV_Connect:

; 263  : 
; 264  : 	s = Cmd_Argv( 3 );	// protocol info

	push	3
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 265  : 
; 266  : 	if( !Info_IsValid( s ))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_IsValid
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SV_Connect

; 267  : 	{
; 268  : 		SV_RejectConnection( from, "invalid protinfo in connect command\n" );

	push	OFFSET ??_C@_0CF@MHPLKMCG@invalid?5protinfo?5in?5connect?5com@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 269  : 		return;

	jmp	$LN26@SV_Connect
$LN11@SV_Connect:

; 270  : 	}
; 271  : 
; 272  : 	Q_strncpy( protinfo, s, sizeof( protinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _protinfo$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 273  : 
; 274  : 	// extract qport from protocol info
; 275  : 	qport = Q_atoi( Info_ValueForKey( protinfo, "qport" ));

	push	OFFSET ??_C@_05IPCIHGO@qport@
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _qport$[ebp], eax

; 276  : 
; 277  : 	s = Info_ValueForKey( protinfo, "uuid" );

	push	OFFSET ??_C@_04BCJJGJPP@uuid@
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _s$[ebp], eax

; 278  : 	if( Q_strlen( s ) != 32 )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	je	SHORT $LN12@SV_Connect

; 279  : 	{
; 280  : 		SV_RejectConnection( from, "invalid authentication certificate length\n" );

	push	OFFSET ??_C@_0CL@MJLLLANH@invalid?5authentication?5certific@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 281  : 		return;

	jmp	$LN26@SV_Connect
$LN12@SV_Connect:

; 282  : 	}
; 283  : 
; 284  : 	// LAN servers restrict to class b IP addresses
; 285  : 	if( !SV_CheckIPRestrictions( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_CheckIPRestrictions
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN13@SV_Connect

; 286  : 	{
; 287  : 		SV_RejectConnection( from, "LAN servers are restricted to local clients (class C)\n" );

	push	OFFSET ??_C@_0DH@MCNPJPOI@LAN?5servers?5are?5restricted?5to?5l@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 288  : 		return;

	jmp	$LN26@SV_Connect
$LN13@SV_Connect:

; 289  : 	}
; 290  : 
; 291  : 	s = Cmd_Argv( 4 );	// user info

	push	4
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 292  : 
; 293  : 	if( Q_strlen( s ) > MAX_INFO_STRING || !Info_IsValid( s ))

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jg	SHORT $LN15@SV_Connect
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Info_IsValid
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@SV_Connect
$LN15@SV_Connect:

; 294  : 	{
; 295  : 		SV_RejectConnection( from, "invalid userinfo in connect command\n" );

	push	OFFSET ??_C@_0CF@NCGDNHHH@invalid?5userinfo?5in?5connect?5com@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 296  : 		return;

	jmp	$LN26@SV_Connect
$LN14@SV_Connect:

; 297  : 	}
; 298  : 
; 299  : 	Q_strncpy( userinfo, s, sizeof( userinfo ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _userinfo$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 300  : 
; 301  : 	// check connection password (don't verify local client)
; 302  : 	if( !NET_IsLocalAddress( from ) && sv_password.string[0] && Q_stricmp( sv_password.string, Info_ValueForKey( userinfo, "password" )))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN16@SV_Connect
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sv_password+4
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN16@SV_Connect
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08NLHBPEGP@password@
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _sv_password+4
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@SV_Connect

; 303  : 	{
; 304  : 		SV_RejectConnection( from, "invalid password\n" );

	push	OFFSET ??_C@_0BC@HLBFGPEN@invalid?5password?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 305  : 		return;

	jmp	$LN26@SV_Connect
$LN16@SV_Connect:

; 306  : 	}
; 307  : 
; 308  : 	// if there is already a slot for this ip, reuse it
; 309  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Connect
$LN2@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	$LN3@SV_Connect

; 310  : 	{
; 311  : 		if( cl->state == cs_free || cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN18@SV_Connect
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN17@SV_Connect
$LN18@SV_Connect:

; 312  : 			continue;

	jmp	SHORT $LN2@SV_Connect
$LN17@SV_Connect:

; 313  : 
; 314  : 		if( NET_CompareBaseAdr( from, cl->netchan.remote_address ) && ( cl->netchan.qport == qport || from.port == cl->netchan.remote_address.port ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_CompareBaseAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN19@SV_Connect
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	cmp	ecx, DWORD PTR _qport$[ebp]
	je	SHORT $LN20@SV_Connect
	movzx	eax, WORD PTR _from$[ebp+18]
	mov	ecx, DWORD PTR _cl$[ebp]
	movzx	edx, WORD PTR [ecx+582]
	cmp	eax, edx
	jne	SHORT $LN19@SV_Connect
$LN20@SV_Connect:

; 315  : 		{
; 316  : 			reconnect = true;

	mov	DWORD PTR _reconnect$[ebp], 1

; 317  : 			newcl = cl;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR _newcl$[ebp], eax

; 318  : 			break;

	jmp	SHORT $LN3@SV_Connect
$LN19@SV_Connect:

; 319  : 		}
; 320  : 	}

	jmp	$LN2@SV_Connect
$LN3@SV_Connect:

; 321  : 
; 322  : 	// A reconnecting client will re-use the slot found above when checking for reconnection.
; 323  : 	// the slot will be wiped clean.
; 324  : 	if( !reconnect )

	cmp	DWORD PTR _reconnect$[ebp], 0
	jne	SHORT $LN21@SV_Connect

; 325  : 	{
; 326  : 		// connect the client if there are empty slots.
; 327  : 		if( !SV_FindEmptySlot( from, &nClientSlot, &newcl ))

	lea	eax, DWORD PTR _newcl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nClientSlot$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_SV_FindEmptySlot
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN23@SV_Connect

; 328  : 			return;

	jmp	$LN26@SV_Connect
$LN23@SV_Connect:

; 329  : 	}

	jmp	SHORT $LN22@SV_Connect
$LN21@SV_Connect:

; 330  : 	else
; 331  : 	{
; 332  : 		Con_Reportf( S_NOTE "%s:reconnect\n", NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BI@OIEFBMDN@?$FO2Note?3?$FO7?5?$CFs?3reconnect?6@
	call	_Con_Reportf
	add	esp, 8
$LN22@SV_Connect:

; 333  : 	}
; 334  : 
; 335  : 	// find a client slot
; 336  : 	ASSERT( newcl != NULL );

	cmp	DWORD PTR _newcl$[ebp], 0
	jne	SHORT $LN24@SV_Connect
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ConnectClient@@9@9
	add	eax, 103				; 00000067H
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN24@SV_Connect:

; 337  : 
; 338  : 	// build a new connection
; 339  : 	// accept the new client
; 340  : 	sv.current_client = newcl;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR _sv+40, eax

; 341  : 	newcl->edict = EDICT_NUM( (newcl - svs.clients) + 1 );

	mov	eax, DWORD PTR _newcl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	edx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [edx+264948], eax

; 342  : 	newcl->challenge = challenge; // save challenge for checksumming

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	ecx, DWORD PTR _challenge$[ebp]
	mov	DWORD PTR [eax+289824], ecx

; 343  : 	newcl->frames = (client_frame_t *)Z_Calloc( sizeof( client_frame_t ) * SV_UPDATE_BACKUP );

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ConnectClient@@9@9
	add	eax, 110				; 0000006eH
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _SV_UPDATE_BACKUP, 9296
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [ecx+281884], eax

; 344  : 	newcl->userid = g_userid++;	// create unique userid

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	ecx, DWORD PTR _g_userid
	mov	DWORD PTR [eax+289828], ecx
	mov	edx, DWORD PTR _g_userid
	add	edx, 1
	mov	DWORD PTR _g_userid, edx

; 345  : 	newcl->state = cs_connected;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax], 2

; 346  : 
; 347  : 	// reset viewentities (from previous level)
; 348  : 	memset( newcl->viewentity, 0, sizeof( newcl->viewentity ));

	push	512					; 00000200H
	push	0
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 264956				; 00040afcH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 349  : 	newcl->num_viewents = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+265468], 0

; 350  : 	newcl->listeners = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+265476], 0

; 351  : 
; 352  : 	// initailize netchan
; 353  : 	Netchan_Setup( NS_SERVER, &newcl->netchan, from, qport, newcl, SV_GetFragmentSize );

	push	OFFSET _SV_GetFragmentSize
	mov	eax, DWORD PTR _newcl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _qport$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 560				; 00000230H
	push	ecx
	push	1
	call	_Netchan_Setup
	add	esp, 40					; 00000028H

; 354  : 	MSG_Init( &newcl->datagram, "Datagram", newcl->datagram_buf, sizeof( newcl->datagram_buf )); // datagram buf

	push	-1
	push	16384					; 00004000H
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 265500				; 00040d1cH
	push	eax
	push	OFFSET ??_C@_08COCEEGAP@Datagram@
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 265480				; 00040d08H
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 355  : 
; 356  : 	// send the connect packet to the client
; 357  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "client_connect" );

	push	OFFSET ??_C@_0P@IOGHOCLL@client_connect@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 358  : 
; 359  : 	newcl->upstate = us_inactive;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+4], 0

; 360  : 	newcl->connection_started = host.realtime;

	mov	eax, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+264376], xmm0

; 361  : 	newcl->cl_updaterate = 0.05;	// 20 fps as default

	mov	eax, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR __real@3fa999999999999a
	movsd	QWORD PTR [eax+264360], xmm0

; 362  : 	newcl->delta_sequence = -1;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264332], -1

; 363  : 	newcl->flags = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+40], 0

; 364  : 
; 365  : 	Q_strncpy( newcl->hashedcdkey, Info_ValueForKey( protinfo, "uuid" ), 32 );

	push	32					; 00000020H
	push	OFFSET ??_C@_04BCJJGJPP@uuid@
	lea	eax, DWORD PTR _protinfo$[ebp]
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 264384				; 000408c0H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 366  : 	newcl->hashedcdkey[32] = '\0';

	mov	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _newcl$[ebp]
	mov	BYTE PTR [ecx+eax+264384], 0

; 367  : 
; 368  : 	// reset any remaining events
; 369  : 	memset( &newcl->events, 0, sizeof( newcl->events ));

	push	7936					; 00001f00H
	push	0
	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 281888				; 00044d20H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 370  : 
; 371  : 	// parse some info from the info strings (this can override cl_updaterate)
; 372  : 	Q_strncpy( newcl->userinfo, userinfo, sizeof( newcl->userinfo ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 373  : 	SV_UserinfoChanged( newcl );

	mov	eax, DWORD PTR _newcl$[ebp]
	push	eax
	call	_SV_UserinfoChanged
	add	esp, 4

; 374  : 	SV_ClearResourceLists( newcl );

	mov	eax, DWORD PTR _newcl$[ebp]
	push	eax
	call	_SV_ClearResourceLists
	add	esp, 4

; 375  : #if 0
; 376  : 	memset( &newcl->resourcesneeded, 0, sizeof( resource_t ));
; 377  : 	memset( &newcl->resourcesonhand, 0, sizeof( resource_t ));
; 378  : 	newcl->resourcesneeded.pNext = newcl->resourcesneeded.pPrev = &newcl->resourcesneeded;
; 379  : 	newcl->resourcesonhand.pNext = newcl->resourcesonhand.pPrev = &newcl->resourcesonhand;
; 380  : #endif
; 381  : 	newcl->next_messagetime = host.realtime + newcl->cl_updaterate;

	mov	eax, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR [eax+264360]
	mov	ecx, DWORD PTR _newcl$[ebp]
	movsd	QWORD PTR [ecx+264336], xmm0

; 382  : 	newcl->next_sendinfotime = 0.0;

	mov	eax, DWORD PTR _newcl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264352], xmm0

; 383  : 	newcl->ignored_ents = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264944], 0

; 384  : 	newcl->chokecount = 0;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264328], 0

; 385  : 
; 386  : 	// reset stats
; 387  : 	newcl->next_checkpingtime = -1.0;

	mov	eax, DWORD PTR _newcl$[ebp]
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR [eax+264344], xmm0

; 388  : 	newcl->packet_loss = 0.0f;

	mov	eax, DWORD PTR _newcl$[ebp]
	mov	DWORD PTR [eax+264936], 0

; 389  : 
; 390  : 	// if this was the first client on the server, or the last client
; 391  : 	// the server can hold, send a heartbeat to the master.
; 392  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_Connect
$LN5@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN7@SV_Connect:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_Connect

; 393  : 		if( cl->state >= cs_connected ) count++;

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN25@SV_Connect
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN25@SV_Connect:
	jmp	SHORT $LN5@SV_Connect
$LN6@SV_Connect:

; 394  : 
; 395  : 	Log_Printf( "\"%s<%i><%i><>\" connected, address \"%s\"\n", newcl->name, newcl->userid, i, NET_AdrToString( newcl->netchan.remote_address ));

	mov	eax, DWORD PTR _newcl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newcl$[ebp]
	mov	eax, DWORD PTR [edx+289828]
	push	eax
	mov	ecx, DWORD PTR _newcl$[ebp]
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_0CI@JJFACAMK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@
	call	_Log_Printf
	add	esp, 20					; 00000014H

; 396  : 
; 397  : 	if( count == 1 || count == svs.maxclients )

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $LN27@SV_Connect
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN26@SV_Connect
$LN27@SV_Connect:

; 398  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN26@SV_Connect:

; 399  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ConnectClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FindEmptySlot
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_from$ = 8						; size = 20
_pslot$ = 28						; size = 4
_ppClient$ = 32						; size = 4
_SV_FindEmptySlot PROC					; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 208  : 	sv_client_t	*cl;
; 209  : 	int		i;
; 210  : 
; 211  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_FindEmp
$LN2@SV_FindEmp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_FindEmp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_FindEmp

; 212  : 	{
; 213  : 		if( cl->state == cs_free )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@SV_FindEmp

; 214  : 		{
; 215  : 			*ppClient = cl;

	mov	eax, DWORD PTR _ppClient$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], ecx

; 216  : 			*pslot = i;

	mov	eax, DWORD PTR _pslot$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx

; 217  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@SV_FindEmp
$LN5@SV_FindEmp:

; 218  : 		}
; 219  : 	}

	jmp	SHORT $LN2@SV_FindEmp
$LN3@SV_FindEmp:

; 220  : 
; 221  : 	SV_RejectConnection( from, "server is full\n" );

	push	OFFSET ??_C@_0BA@OEEOOGPP@server?5is?5full?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 222  : 	return 0;

	xor	eax, eax
$LN1@SV_FindEmp:

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FindEmptySlot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_CheckIPRestrictions
_TEXT	SEGMENT
_from$ = 8						; size = 20
_SV_CheckIPRestrictions PROC				; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 190  : 	if( sv_lan.value )

	movss	xmm0, DWORD PTR _sv_lan+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@SV_CheckIP

; 191  : 	{
; 192  : 		if( !NET_CompareClassBAdr( from, net_local ) && !NET_IsReservedAdr( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_local
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_local+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_local+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_local+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_local+16
	mov	DWORD PTR [eax+16], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	call	_NET_CompareClassBAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	jne	SHORT $LN3@SV_CheckIP
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsReservedAdr
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN3@SV_CheckIP

; 193  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckIP
$LN3@SV_CheckIP:

; 194  : 	}
; 195  : 	return 1;

	mov	eax, 1
$LN1@SV_CheckIP:

; 196  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckIPRestrictions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_CheckChallenge
_TEXT	SEGMENT
_i$ = -4						; size = 4
_from$ = 8						; size = 20
_challenge$ = 28					; size = 4
_SV_CheckChallenge PROC					; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 150  : 	int	i;
; 151  : 
; 152  : 	// see if the challenge is valid
; 153  : 	// don't care if it is a local address.
; 154  : 	if( NET_IsLocalAddress( from ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN5@SV_CheckCh

; 155  : 		return 1;

	mov	eax, 1
	jmp	$LN1@SV_CheckCh
$LN5@SV_CheckCh:

; 156  : 
; 157  : 	for( i = 0; i < MAX_CHALLENGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CheckCh
$LN2@SV_CheckCh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CheckCh:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@SV_CheckCh

; 158  : 	{
; 159  : 		if( NET_CompareAdr( from, svs.challenges[i].adr ))

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN6@SV_CheckCh

; 160  : 		{
; 161  : 			if( challenge == svs.challenges[i].challenge )

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _challenge$[ebp]
	cmp	ecx, DWORD PTR _svs[eax+33408]
	jne	SHORT $LN6@SV_CheckCh

; 162  : 				break; // valid challenge

	jmp	SHORT $LN3@SV_CheckCh
$LN6@SV_CheckCh:

; 163  : #if 0
; 164  : 			// g-cont. this breaks multiple connections from single machine
; 165  : 			SV_RejectConnection( from, "bad challenge %i\n", challenge );
; 166  : 			return 0;
; 167  : #endif
; 168  : 		}
; 169  : 	}

	jmp	SHORT $LN2@SV_CheckCh
$LN3@SV_CheckCh:

; 170  : 
; 171  : 	if( i == MAX_CHALLENGES )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN8@SV_CheckCh

; 172  : 	{
; 173  : 		SV_RejectConnection( from, "no challenge for your address\n" );

	push	OFFSET ??_C@_0BP@NAEOINNF@no?5challenge?5for?5your?5address?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_RejectConnection
	add	esp, 24					; 00000018H

; 174  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SV_CheckCh
$LN8@SV_CheckCh:

; 175  : 	}
; 176  : 	svs.challenges[i].connected = true;

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	DWORD PTR _svs[eax+33412], 1

; 177  : 
; 178  : 	return 1;

	mov	eax, 1
$LN1@SV_CheckCh:

; 179  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CheckChallenge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FailDownload
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_filename$ = 12						; size = 4
_SV_FailDownload PROC					; COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 134  : 	if( !COM_CheckString( filename ))

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@SV_FailDow

; 135  : 		return;

	jmp	SHORT $LN1@SV_FailDow
$LN2@SV_FailDow:

; 136  : 
; 137  : 	MSG_BeginServerCmd( &cl->netchan.message, svc_filetxferfailed );

	push	0
	push	1
	push	49					; 00000031H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 138  : 	MSG_WriteString( &cl->netchan.message, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
$LN1@SV_FailDow:

; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FailDownload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_RejectConnection
_TEXT	SEGMENT
_argptr$ = -1032					; size = 4
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_fmt$ = 28						; size = 4
_SV_RejectConnection PROC				; COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 112  : 	char	text[1024];
; 113  : 	va_list	argptr;
; 114  : 
; 115  : 	va_start( argptr, fmt );

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 116  : 	Q_vsnprintf( text, sizeof( text ), fmt, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 117  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 118  : 
; 119  : 	Con_Reportf( "%s connection refused. Reason: %s\n", NET_AdrToString( from ), text );

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CD@KFMFNEGJ@?$CFs?5connection?5refused?4?5Reason?3?5@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 120  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "print\n^1Server was reject the connection:^7 %s", text );

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@DPENDPLB@print?6?$FO1Server?5was?5reject?5the?5c@
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 121  : 	Netchan_OutOfBandPrint( NS_SERVER, from, "disconnect\n" );

	push	OFFSET ??_C@_0M@MNJNCGPD@disconnect?6@
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 28					; 0000001cH

; 122  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RejectConnection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_GetFragmentSize
_TEXT	SEGMENT
tv77 = -76						; size = 4
tv76 = -72						; size = 4
_cl_frag_size$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_GetFragmentSize PROC				; COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 92   : 	int	cl_frag_size;
; 93   : 
; 94   : 	if( Netchan_IsLocal( &cl->netchan ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_IsLocal
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SV_GetFrag

; 95   : 		return FRAGMENT_LOCAL_SIZE;

	mov	eax, 64000				; 0000fa00H
	jmp	SHORT $LN1@SV_GetFrag
$LN2@SV_GetFrag:

; 96   : 
; 97   : 	cl_frag_size = Q_atoi( Info_ValueForKey( cl->userinfo, "cl_dlmax" ));

	push	OFFSET ??_C@_08IGNJNAKN@cl_dlmax@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _cl_frag_size$[ebp], eax

; 98   : 	cl_frag_size = bound( FRAGMENT_MIN_SIZE, cl_frag_size, FRAGMENT_MAX_SIZE );

	cmp	DWORD PTR _cl_frag_size$[ebp], 1200	; 000004b0H
	jl	SHORT $LN6@SV_GetFrag
	cmp	DWORD PTR _cl_frag_size$[ebp], 64000	; 0000fa00H
	jge	SHORT $LN4@SV_GetFrag
	mov	eax, DWORD PTR _cl_frag_size$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@SV_GetFrag
$LN4@SV_GetFrag:
	mov	DWORD PTR tv76[ebp], 64000		; 0000fa00H
$LN5@SV_GetFrag:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN7@SV_GetFrag
$LN6@SV_GetFrag:
	mov	DWORD PTR tv77[ebp], 1200		; 000004b0H
$LN7@SV_GetFrag:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _cl_frag_size$[ebp], edx

; 99   : 
; 100  : 	return cl_frag_size;

	mov	eax, DWORD PTR _cl_frag_size$[ebp]
$LN1@SV_GetFrag:

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetFragmentSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_EndRedirect
_TEXT	SEGMENT
_SV_EndRedirect PROC					; COMDAT

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 580  : 	if( host.rd.flush )

	cmp	DWORD PTR _host+916, 0
	je	SHORT $LN2@SV_EndRedi

; 581  : 		host.rd.flush( host.rd.address, host.rd.target, host.rd.buffer );

	mov	eax, DWORD PTR _host+888
	push	eax
	mov	ecx, DWORD PTR _host+884
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _host+896
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _host+900
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _host+904
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _host+908
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _host+912
	mov	DWORD PTR [edx+16], eax
	call	DWORD PTR _host+916
	add	esp, 28					; 0000001cH
$LN2@SV_EndRedi:

; 582  : 
; 583  : 	host.rd.target = 0;

	mov	DWORD PTR _host+884, 0

; 584  : 	host.rd.buffer = NULL;

	mov	DWORD PTR _host+888, 0

; 585  : 	host.rd.buffersize = 0;

	mov	DWORD PTR _host+892, 0

; 586  : 	host.rd.flush = NULL;

	mov	DWORD PTR _host+916, 0

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_EndRedirect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_CalcPing
_TEXT	SEGMENT
_frame$ = -24						; size = 4
_back$ = -20						; size = 4
_idx$ = -16						; size = 4
_count$ = -12						; size = 4
_i$ = -8						; size = 4
_ping$ = -4						; size = 4
_cl$ = 8						; size = 4
_SV_CalcPing PROC					; COMDAT

; 888  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 889  : 	float		ping = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _ping$[ebp], xmm0

; 890  : 	int		i, count;
; 891  : 	int		idx, back;
; 892  : 	client_frame_t	*frame;
; 893  : 
; 894  : 	// bots don't have a real ping
; 895  : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ) || !cl->frames )

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN6@SV_CalcPin
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281884], 0
	jne	SHORT $LN5@SV_CalcPin
$LN6@SV_CalcPin:

; 896  : 		return 5;

	mov	eax, 5
	jmp	$LN1@SV_CalcPin
$LN5@SV_CalcPin:

; 897  : 
; 898  : 	if( SV_UPDATE_BACKUP <= 31 )

	cmp	DWORD PTR _SV_UPDATE_BACKUP, 31		; 0000001fH
	jg	SHORT $LN7@SV_CalcPin

; 899  : 	{
; 900  : 		back = SV_UPDATE_BACKUP / 2;

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _back$[ebp], eax

; 901  : 		if( back <= 0 ) return 0;

	cmp	DWORD PTR _back$[ebp], 0
	jg	SHORT $LN9@SV_CalcPin
	xor	eax, eax
	jmp	$LN1@SV_CalcPin
$LN9@SV_CalcPin:

; 902  : 	}

	jmp	SHORT $LN8@SV_CalcPin
$LN7@SV_CalcPin:

; 903  : 	else back = 16;

	mov	DWORD PTR _back$[ebp], 16		; 00000010H
$LN8@SV_CalcPin:

; 904  : 
; 905  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 906  : 
; 907  : 	for( i = 0; i < back; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_CalcPin
$LN2@SV_CalcPin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_CalcPin:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _back$[ebp]
	jge	SHORT $LN3@SV_CalcPin

; 908  : 	{
; 909  : 		idx = cl->netchan.incoming_acknowledged + ~i;

	mov	eax, DWORD PTR _i$[ebp]
	not	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	eax, DWORD PTR [ecx+628]
	mov	DWORD PTR _idx$[ebp], eax

; 910  : 		frame = &cl->frames[idx & SV_UPDATE_MASK];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _idx$[ebp]
	imul	ecx, eax, 9296
	mov	edx, DWORD PTR _cl$[ebp]
	add	ecx, DWORD PTR [edx+281884]
	mov	DWORD PTR _frame$[ebp], ecx

; 911  : 
; 912  : 		if( frame->ping_time > 0.0f )

	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@SV_CalcPin

; 913  : 		{
; 914  : 			ping += frame->ping_time;

	mov	eax, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR _ping$[ebp]
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR _ping$[ebp], xmm0

; 915  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN10@SV_CalcPin:

; 916  : 		}
; 917  : 	}

	jmp	SHORT $LN2@SV_CalcPin
$LN3@SV_CalcPin:

; 918  : 
; 919  : 	if( count > 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jle	SHORT $LN11@SV_CalcPin

; 920  : 		return (( ping / count ) * 1000.0f );

	cvtsi2ss xmm0, DWORD PTR _count$[ebp]
	movss	xmm1, DWORD PTR _ping$[ebp]
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@447a0000
	cvttss2si eax, xmm1
	jmp	SHORT $LN1@SV_CalcPin
$LN11@SV_CalcPin:

; 921  : 	return 0;

	xor	eax, eax
$LN1@SV_CalcPin:

; 922  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_CalcPing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_IsPlayerIndex
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_SV_IsPlayerIndex PROC					; COMDAT

; 1122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1123 : 	if( idx > 0 && idx <= svs.maxclients )

	cmp	DWORD PTR _idx$[ebp], 0
	jle	SHORT $LN2@SV_IsPlaye
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jg	SHORT $LN2@SV_IsPlaye

; 1124 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_IsPlaye
$LN2@SV_IsPlaye:

; 1125 : 	return false;

	xor	eax, eax
$LN1@SV_IsPlaye:

; 1126 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_IsPlayerIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_BuildReconnect
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_SV_BuildReconnect PROC					; COMDAT

; 1337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1338 : 	MSG_BeginServerCmd( msg, svc_stufftext );

	push	0
	push	1
	push	9
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1339 : 	MSG_WriteString( msg, "reconnect\n" );

	push	OFFSET ??_C@_0L@FBPMLECH@reconnect?6@
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1340 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_BuildReconnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ExecuteClientCommand
_TEXT	SEGMENT
_u$ = -4						; size = 4
_cl$ = 8						; size = 4
_s$ = 12						; size = 4
_SV_ExecuteClientCommand PROC				; COMDAT

; 1962 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1963 : 	ucmd_t	*u;
; 1964 : 
; 1965 : 	Cmd_TokenizeString( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 1966 : 
; 1967 : 	for( u = ucmds; u->name; u++ )

	mov	DWORD PTR _u$[ebp], OFFSET _ucmds
	jmp	SHORT $LN4@SV_Execute
$LN2@SV_Execute:
	mov	eax, DWORD PTR _u$[ebp]
	add	eax, 8
	mov	DWORD PTR _u$[ebp], eax
$LN4@SV_Execute:
	mov	eax, DWORD PTR _u$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@SV_Execute

; 1968 : 	{
; 1969 : 		if( !Q_strcmp( Cmd_Argv( 0 ), u->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@SV_Execute

; 1970 : 		{
; 1971 : 			if( !u->func( cl ))

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SV_Execute

; 1972 : 				Con_Printf( "'%s' is not valid from the console\n", u->name );

	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CE@PCAOCCIJ@?8?$CFs?8?5is?5not?5valid?5from?5the?5cons@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN7@SV_Execute
$LN6@SV_Execute:

; 1973 : 			else Con_Reportf( "ucmd->%s()\n", u->name );

	mov	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0M@PKKNFAD@ucmd?9?$DO?$CFs?$CI?$CJ?6@
	call	_Con_Reportf
	add	esp, 8
$LN7@SV_Execute:

; 1974 : 			break;

	jmp	SHORT $LN3@SV_Execute
$LN5@SV_Execute:

; 1975 : 		}
; 1976 : 	}

	jmp	SHORT $LN2@SV_Execute
$LN3@SV_Execute:

; 1977 : 
; 1978 : 	if( !u->name && sv.state == ss_active )

	mov	eax, DWORD PTR _u$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@SV_Execute
	cmp	DWORD PTR _sv, 2
	jne	SHORT $LN1@SV_Execute

; 1979 : 	{
; 1980 : 		// custom client commands
; 1981 : 		svgame.dllFuncs.pfnClientCommand( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19348
	add	esp, 4

; 1982 : 
; 1983 : 		if( !Q_strcmp( Cmd_Argv( 0 ), "fullupdate" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@BAECHHDI@fullupdate@
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@SV_Execute

; 1984 : 		{
; 1985 : 			// resend the ambient sounds for demo recording
; 1986 : 			SV_RestartAmbientSounds();

	call	_SV_RestartAmbientSounds

; 1987 : 			// resend all the decals for demo recording
; 1988 : 			SV_RestartDecals();

	call	_SV_RestartDecals

; 1989 : 			// resend all the static ents for demo recording
; 1990 : 			SV_RestartStaticEnts();

	call	_SV_RestartStaticEnts

; 1991 : 			// resend the viewentity
; 1992 : 			SV_UpdateClientView( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UpdateClientView
	add	esp, 4
$LN1@SV_Execute:

; 1993 : 		}
; 1994 : 	}
; 1995 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ExecuteClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FakeConnect
_TEXT	SEGMENT
$T1 = -340						; size = 4
_cl$ = -272						; size = 4
_count$ = -268						; size = 4
_i$ = -264						; size = 4
_userinfo$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_netname$ = 8						; size = 4
_SV_FakeConnect PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 410  : 	char		userinfo[MAX_INFO_STRING];
; 411  : 	int		i, count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 412  : 	sv_client_t	*cl;
; 413  : 
; 414  : 	if( !COM_CheckString( netname ))

	mov	eax, DWORD PTR _netname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@SV_FakeCon

; 415  : 		netname = "Bot";

	mov	DWORD PTR _netname$[ebp], OFFSET ??_C@_03OHHOIALK@Bot@
$LN8@SV_FakeCon:

; 416  : 
; 417  : 	// find a client slot
; 418  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_FakeCon
$LN2@SV_FakeCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_FakeCon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_FakeCon

; 419  : 	{
; 420  : 		if( cl->state == cs_free )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@SV_FakeCon

; 421  : 			break;

	jmp	SHORT $LN3@SV_FakeCon
$LN9@SV_FakeCon:

; 422  : 	}

	jmp	SHORT $LN2@SV_FakeCon
$LN3@SV_FakeCon:

; 423  : 
; 424  : 	if( i == svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN10@SV_FakeCon

; 425  : 		return NULL; // server is full

	xor	eax, eax
	jmp	$LN1@SV_FakeCon
$LN10@SV_FakeCon:

; 426  : 
; 427  : 	userinfo[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN16@SV_FakeCon
	jmp	SHORT $LN17@SV_FakeCon
$LN16@SV_FakeCon:
	call	___report_rangecheckfailure
$LN17@SV_FakeCon:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _userinfo$[ebp+edx], 0

; 428  : 
; 429  : 	// setup fake client params
; 430  : 	Info_SetValueForKey( userinfo, "name", netname, MAX_INFO_STRING );

	push	256					; 00000100H
	mov	eax, DWORD PTR _netname$[ebp]
	push	eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	lea	ecx, DWORD PTR _userinfo$[ebp]
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 431  : 	Info_SetValueForKey( userinfo, "model", "gordon", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_06FKIDPGKK@gordon@
	push	OFFSET ??_C@_05NCCFOPHA@model@
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 432  : 	Info_SetValueForKey( userinfo, "topcolor", "1", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_08OLGKFJAO@topcolor@
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 433  : 	Info_SetValueForKey( userinfo, "bottomcolor", "1", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0M@IIFIMDEK@bottomcolor@
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 434  : 
; 435  : 	// build a new connection
; 436  : 	// accept the new client
; 437  : 	sv.current_client = cl;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR _sv+40, eax

; 438  : 
; 439  : 	if( cl->frames ) Mem_Free( cl->frames );	// fakeclients doesn't have frames

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281884], 0
	je	SHORT $LN11@SV_FakeCon
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_FakeConnect@@9@9
	add	eax, 30					; 0000001eH
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+281884]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN11@SV_FakeCon:

; 440  : 	memset( cl, 0, sizeof( sv_client_t ));

	push	289832					; 00046c28H
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 441  : 
; 442  : 	cl->edict = EDICT_NUM( (cl - svs.clients) + 1 );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	add	eax, 1
	push	eax
	call	_SV_EdictNum
	add	esp, 4
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+264948], eax

; 443  : 	cl->userid = g_userid++;		// create unique userid

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR _g_userid
	mov	DWORD PTR [eax+289828], ecx
	mov	edx, DWORD PTR _g_userid
	add	edx, 1
	mov	DWORD PTR _g_userid, edx

; 444  : 	SetBits( cl->flags, FCL_FAKECLIENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 445  : 
; 446  : 	// parse some info from the info strings
; 447  : 	Q_strncpy( cl->userinfo, userinfo, sizeof( cl->userinfo ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _userinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 448  : 	SV_UserinfoChanged( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UserinfoChanged
	add	esp, 4

; 449  : 	SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 450  : 	cl->next_sendinfotime = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264352], xmm0

; 451  : 
; 452  : 	// if this was the first client on the server, or the last client
; 453  : 	// the server can hold, send a heartbeat to the master.
; 454  : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN7@SV_FakeCon
$LN5@SV_FakeCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN7@SV_FakeCon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN6@SV_FakeCon

; 455  : 		if( cl->state >= cs_connected ) count++;

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN12@SV_FakeCon
	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN12@SV_FakeCon:
	jmp	SHORT $LN5@SV_FakeCon
$LN6@SV_FakeCon:

; 456  : 	cl = sv.current_client;

	mov	eax, DWORD PTR _sv+40
	mov	DWORD PTR _cl$[ebp], eax

; 457  : 
; 458  : 	Log_Printf( "\"%s<%i><%i><>\" connected, address \"local\"\n", cl->name, cl->userid, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+289828]
	push	edx
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0CL@GOELOEAP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFi?$DO?$DM?$DO?$CC?5connected?0?5addre@
	call	_Log_Printf
	add	esp, 16					; 00000010H

; 459  : 
; 460  : 	SetBits( cl->edict->v.flags, FL_CLIENT|FL_FAKECLIENT );	// mark it as fakeclient

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	edx, DWORD PTR [ecx+656]
	or	edx, 8200				; 00002008H
	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR [ecx+656], edx

; 461  : 	cl->connection_started = host.realtime;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax+264376], xmm0

; 462  : 	cl->state = cs_spawned;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 3

; 463  : 
; 464  : 	if( count == 1 || count == svs.maxclients )

	cmp	DWORD PTR _count$[ebp], 1
	je	SHORT $LN14@SV_FakeCon
	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN13@SV_FakeCon
$LN14@SV_FakeCon:

; 465  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN13@SV_FakeCon:

; 466  : 	
; 467  : 	return cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	eax, DWORD PTR [eax+264948]
$LN1@SV_FakeCon:

; 468  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FakeConnect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ConnectionlessPacket
_TEXT	SEGMENT
_len$ = -1040						; size = 4
_buf$ = -1036						; size = 1024
_pcmd$ = -12						; size = 4
_args$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_SV_ConnectionlessPacket PROC				; COMDAT

; 2073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1232				; 000004d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2074 : 	char	*args;
; 2075 : 	char	*pcmd, buf[MAX_SYSPATH];
; 2076 : 	int	len = sizeof( buf );

	mov	DWORD PTR _len$[ebp], 1024		; 00000400H

; 2077 : 
; 2078 : 	MSG_Clear( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_Clear
	add	esp, 4

; 2079 : 	MSG_ReadLong( msg );// skip the -1 marker

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4

; 2080 : 
; 2081 : 	args = MSG_ReadStringLine( msg );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _args$[ebp], eax

; 2082 : 	Cmd_TokenizeString( args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 2083 : 
; 2084 : 	pcmd = Cmd_Argv( 0 );

	push	0
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _pcmd$[ebp], eax

; 2085 : 	Con_Reportf( "SV_ConnectionlessPacket: %s : %s\n", NET_AdrToString( from ), pcmd );

	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0CC@BEHBECBG@SV_ConnectionlessPacket?3?5?$CFs?5?3?5?$CF@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 2086 : 
; 2087 : 	if( !Q_strcmp( pcmd, "ping" )) SV_Ping( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04OONEELOO@ping@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_Ping
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN2@SV_Connect:

; 2088 : 	else if( !Q_strcmp( pcmd, "ack" )) SV_Ack( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03JBLJHHJA@ack@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_Ack
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN4@SV_Connect:

; 2089 : 	else if( !Q_strcmp( pcmd, "info" )) SV_Info( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04NIDJFNBE@info@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_Info
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN6@SV_Connect:

; 2090 : 	else if( !Q_strcmp( pcmd, "bandwidth" )) SV_TestBandWidth( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09PAHKGFGO@bandwidth@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_TestBandWidth
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN8@SV_Connect:

; 2091 : 	else if( !Q_strcmp( pcmd, "getchallenge" )) SV_GetChallenge( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@FADCLAAC@getchallenge@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_GetChallenge
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN10@SV_Connect:

; 2092 : 	else if( !Q_strcmp( pcmd, "connect" )) SV_ConnectClient( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07KAIBNCHO@connect@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_ConnectClient
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN12@SV_Connect:

; 2093 : 	else if( !Q_strcmp( pcmd, "rcon" )) SV_RemoteCommand( from, msg );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04CLKJCJJE@rcon@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_Connect
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_RemoteCommand
	add	esp, 24					; 00000018H
	jmp	$LN1@SV_Connect
$LN14@SV_Connect:

; 2094 : 	else if( !Q_strcmp( pcmd, "netinfo" )) SV_BuildNetAnswer( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07PHGFOLHM@netinfo@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_BuildNetAnswer
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN16@SV_Connect:

; 2095 : 	else if( !Q_strcmp( pcmd, "s" )) SV_AddToMaster( from, msg );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01LKDEMHDF@s@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@SV_Connect
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_SV_AddToMaster
	add	esp, 24					; 00000018H
	jmp	$LN1@SV_Connect
$LN18@SV_Connect:

; 2096 : 	else if( !Q_strcmp( pcmd, "T" "Source" )) SV_TSourceEngineQuery( from );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07CDBHODM@TSource@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_TSourceEngineQuery
	add	esp, 20					; 00000014H
	jmp	$LN1@SV_Connect
$LN20@SV_Connect:

; 2097 : 	else if( !Q_strcmp( pcmd, "i" )) NET_SendPacket( NS_SERVER, 5, "\xFF\xFF\xFF\xFFj", from ); // A2A_PING

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01KBJDNOO@i@
	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@SV_Connect
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	push	OFFSET ??_C@_05JPBCIDCN@?$PP?$PP?$PP?$PPj@
	push	5
	push	1
	call	_NET_SendPacket
	add	esp, 32					; 00000020H
	jmp	$LN1@SV_Connect
$LN22@SV_Connect:

; 2098 : 	else if( svgame.dllFuncs.pfnConnectionlessPacket( &from, args, buf, &len ))

	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	DWORD PTR _svgame+19452
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN24@SV_Connect

; 2099 : 	{
; 2100 : 		// user out of band message (must be handled in CL_ConnectionlessPacket)
; 2101 : 		if( len > 0 ) Netchan_OutOfBand( NS_SERVER, from, len, buf );

	cmp	DWORD PTR _len$[ebp], 0
	jle	SHORT $LN26@SV_Connect
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _from$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	push	1
	call	_Netchan_OutOfBand
	add	esp, 32					; 00000020H
$LN26@SV_Connect:

; 2102 : 	}

	jmp	SHORT $LN1@SV_Connect
$LN24@SV_Connect:

; 2103 : 	else Con_DPrintf( S_ERROR "bad connectionless packet from %s:\n%s\n", NET_AdrToString( from ), args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DC@KKDBOFAL@?$FO1Error?3?$FO7?5bad?5connectionless?5p@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN1@SV_Connect:

; 2104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ConnectionlessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ExecuteClientMessage
_TEXT	SEGMENT
tv145 = -80						; size = 4
_c$ = -12						; size = 4
_frame$ = -8						; size = 4
_move_issued$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_ExecuteClientMessage PROC				; COMDAT

; 2376 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2377 : 	qboolean		move_issued = false;

	mov	DWORD PTR _move_issued$[ebp], 0

; 2378 : 	client_frame_t	*frame;
; 2379 : 	int		c;
; 2380 : 
; 2381 : 	ASSERT( cl->frames != NULL );

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281884], 0
	jne	SHORT $LN6@SV_Execute
	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_ExecuteClientMessage@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN6@SV_Execute:

; 2382 : 
; 2383 : 	// calc ping time
; 2384 : 	frame = &cl->frames[cl->netchan.incoming_acknowledged & SV_UPDATE_MASK];

	mov	eax, DWORD PTR _SV_UPDATE_BACKUP
	sub	eax, 1
	mov	ecx, DWORD PTR _cl$[ebp]
	and	eax, DWORD PTR [ecx+628]
	imul	edx, eax, 9296
	mov	eax, DWORD PTR _cl$[ebp]
	add	edx, DWORD PTR [eax+281884]
	mov	DWORD PTR _frame$[ebp], edx

; 2385 : 
; 2386 : 	// ping time doesn't factor in message interval, either
; 2387 : 	frame->ping_time = host.realtime - frame->senttime - cl->cl_updaterate;

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR _cl$[ebp]
	subsd	xmm0, QWORD PTR [ecx+264360]
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 2388 : 
; 2389 : 	// on first frame ( no senttime ) don't skew ping
; 2390 : 	if( frame->senttime == 0.0f ) frame->ping_time = 0.0f;

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@SV_Execute
	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN7@SV_Execute:

; 2391 : 
; 2392 : 	// don't skew ping based on signon stuff either
; 2393 : 	if(( host.realtime - cl->connection_started ) < 2.0f && ( frame->ping_time > 0.0 ))

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR [eax+264376]
	movsd	xmm1, QWORD PTR __real@4000000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN8@SV_Execute
	mov	eax, DWORD PTR _frame$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+8]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN8@SV_Execute

; 2394 : 		frame->ping_time = 0.0f;

	mov	eax, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN8@SV_Execute:

; 2395 : 
; 2396 : 	cl->latency = SV_CalcClientTime( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_CalcClientTime
	add	esp, 4
	mov	ecx, DWORD PTR _cl$[ebp]
	fstp	DWORD PTR [ecx+264940]

; 2397 : 	cl->delta_sequence = -1; // no delta unless requested

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264332], -1
$LN2@SV_Execute:

; 2398 : 				
; 2399 : 	// read optional clientCommand strings
; 2400 : 	while( cl->state != cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	je	$LN3@SV_Execute

; 2401 : 	{
; 2402 : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@SV_Execute

; 2403 : 		{
; 2404 : 			Con_DPrintf( S_ERROR "incoming overflow for %s\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0CF@LBJHNMOG@?$FO1Error?3?$FO7?5incoming?5overflow?5fo@
	call	_Con_DPrintf
	add	esp, 8

; 2405 : 			SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 2406 : 			return;

	jmp	$LN3@SV_Execute
$LN9@SV_Execute:

; 2407 : 		}
; 2408 : 
; 2409 : 		// end of message
; 2410 : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@SV_Execute

; 2411 : 			break;

	jmp	$LN3@SV_Execute
$LN10@SV_Execute:

; 2412 : 
; 2413 : 		c = MSG_ReadClientCmd( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax

; 2414 : 
; 2415 : 		switch( c )

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv145[ebp], eax
	mov	ecx, DWORD PTR tv145[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv145[ebp], ecx
	cmp	DWORD PTR tv145[ebp], 9
	ja	$LN21@SV_Execute
	mov	edx, DWORD PTR tv145[ebp]
	jmp	DWORD PTR $LN23@SV_Execute[edx*4]
$LN11@SV_Execute:

; 2416 : 		{
; 2417 : 		case clc_nop:
; 2418 : 			break;

	jmp	$LN4@SV_Execute
$LN12@SV_Execute:

; 2419 : 		case clc_delta:
; 2420 : 			cl->delta_sequence = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [ecx+264332], eax

; 2421 : 			break;

	jmp	$LN4@SV_Execute
$LN13@SV_Execute:

; 2422 : 		case clc_move:
; 2423 : 			if( move_issued ) return; // someone is trying to cheat...

	cmp	DWORD PTR _move_issued$[ebp], 0
	je	SHORT $LN14@SV_Execute
	jmp	$LN3@SV_Execute
$LN14@SV_Execute:

; 2424 : 			move_issued = true;

	mov	DWORD PTR _move_issued$[ebp], 1

; 2425 : 			SV_ParseClientMove( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseClientMove
	add	esp, 8

; 2426 : 			break;

	jmp	$LN4@SV_Execute
$LN15@SV_Execute:

; 2427 : 		case clc_stringcmd:	
; 2428 : 			SV_ExecuteClientCommand( cl, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ExecuteClientCommand
	add	esp, 8

; 2429 : 			if( cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN16@SV_Execute

; 2430 : 				return; // disconnect command

	jmp	SHORT $LN3@SV_Execute
$LN16@SV_Execute:

; 2431 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN17@SV_Execute:

; 2432 : 		case clc_resourcelist:
; 2433 : 			SV_ParseResourceList( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseResourceList
	add	esp, 8

; 2434 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN18@SV_Execute:

; 2435 : 		case clc_fileconsistency:
; 2436 : 			SV_ParseConsistencyResponse( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseConsistencyResponse
	add	esp, 8

; 2437 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN19@SV_Execute:

; 2438 : 		case clc_requestcvarvalue:
; 2439 : 			SV_ParseCvarValue( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseCvarValue
	add	esp, 8

; 2440 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN20@SV_Execute:

; 2441 : 		case clc_requestcvarvalue2:
; 2442 : 			SV_ParseCvarValue2( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_ParseCvarValue2
	add	esp, 8

; 2443 : 			break;

	jmp	SHORT $LN4@SV_Execute
$LN21@SV_Execute:

; 2444 : 		default:
; 2445 : 			Con_DPrintf( S_ERROR "%s: clc_bad\n", cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0BI@CCJPDDNB@?$FO1Error?3?$FO7?5?$CFs?3?5clc_bad?6@
	call	_Con_DPrintf
	add	esp, 8

; 2446 : 			SV_DropClient( cl, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_DropClient
	add	esp, 8

; 2447 : 			return;

	jmp	SHORT $LN3@SV_Execute
$LN4@SV_Execute:

; 2448 : 		}
; 2449 : 	}

	jmp	$LN2@SV_Execute
$LN3@SV_Execute:

; 2450 :  }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN23@SV_Execute:
	DD	$LN11@SV_Execute
	DD	$LN13@SV_Execute
	DD	$LN15@SV_Execute
	DD	$LN12@SV_Execute
	DD	$LN17@SV_Execute
	DD	$LN21@SV_Execute
	DD	$LN18@SV_Execute
	DD	$LN21@SV_Execute
	DD	$LN19@SV_Execute
	DD	$LN20@SV_Execute
_SV_ExecuteClientMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_SendServerdata
_TEXT	SEGMENT
_i$ = -264						; size = 4
_message$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_cl$ = 12						; size = 4
_SV_SendServerdata PROC					; COMDAT

; 1372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1373 : 	string	message;
; 1374 : 	int	i;
; 1375 : 
; 1376 : 	// Only send this message to developer console, or multiplayer clients.
; 1377 : 	if(( host_developer.value ) || ( svs.maxclients > 1 ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@SV_SendSer
	cmp	DWORD PTR _svs+16, 1
	jle	SHORT $LN11@SV_SendSer
$LN12@SV_SendSer:

; 1378 : 	{
; 1379 : 		MSG_BeginServerCmd( msg, svc_print );

	push	0
	push	1
	push	8
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1380 : 		Q_snprintf( message, sizeof( message ), "\n^3BUILD %d SERVER (%i CRC)\nServer #%i\n", Q_buildnum(), sv.progsCRC, svs.spawncount );

	mov	eax, DWORD PTR _svs+33340
	push	eax
	mov	ecx, DWORD PTR _sv+52
	push	ecx
	call	_Q_buildnum
	push	eax
	push	OFFSET ??_C@_0CI@HHNJMAIM@?6?$FO3BUILD?5?$CFd?5SERVER?5?$CI?$CFi?5CRC?$CJ?6Ser@
	push	256					; 00000100H
	lea	edx, DWORD PTR _message$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 1381 : 		MSG_WriteString( msg, message );

	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8
$LN11@SV_SendSer:

; 1382 : 	}
; 1383 : 
; 1384 : 	// send the serverdata
; 1385 : 	MSG_BeginServerCmd( msg, svc_serverdata );

	push	0
	push	1
	push	11					; 0000000bH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1386 : 	MSG_WriteLong( msg, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteLong
	add	esp, 8

; 1387 : 	MSG_WriteLong( msg, svs.spawncount );

	mov	eax, DWORD PTR _svs+33340
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1388 : 	MSG_WriteLong( msg, sv.worldmapCRC );

	mov	eax, DWORD PTR _sv+48
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1389 : 	MSG_WriteByte( msg, cl - svs.clients );

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteByte
	add	esp, 8

; 1390 : 	MSG_WriteByte( msg, svs.maxclients );

	mov	eax, DWORD PTR _svs+16
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 1391 : 	MSG_WriteWord( msg, GI->max_edicts );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1656]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteWord
	add	esp, 8

; 1392 : 	MSG_WriteWord( msg, MAX_MODELS );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteWord
	add	esp, 8

; 1393 : 	MSG_WriteString( msg, sv.name );

	push	OFFSET _sv+56
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteString
	add	esp, 8

; 1394 : 	MSG_WriteString( msg, STRING( svgame.edicts->v.message )); // Map Message

	mov	eax, DWORD PTR _svgame+7928
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_SV_GetString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteString
	add	esp, 8

; 1395 : 	MSG_WriteOneBit( msg, sv.background ); // tell client about background map

	mov	eax, DWORD PTR _sv+4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteOneBit
	add	esp, 8

; 1396 : 	MSG_WriteString( msg, GI->gamefolder );

	mov	eax, DWORD PTR _SI+768
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1397 : 	MSG_WriteLong( msg, host.features );

	mov	eax, DWORD PTR _host+34752
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteLong
	add	esp, 8

; 1398 : 
; 1399 : 	// send the player hulls
; 1400 : 	for( i = 0; i < MAX_MAP_HULLS * 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_SendSer
$LN2@SV_SendSer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 12			; 0000000cH
	jge	SHORT $LN3@SV_SendSer

; 1401 : 	{
; 1402 : 		MSG_WriteChar( msg, host.player_mins[i/3][i%3] );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	cvttss2si edx, DWORD PTR _host[ecx+edx*4+34236]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8

; 1403 : 		MSG_WriteChar( msg, host.player_maxs[i/3][i%3] );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	esi, 3
	idiv	esi
	cvttss2si edx, DWORD PTR _host[ecx+edx*4+34284]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteChar
	add	esp, 8

; 1404 : 	}

	jmp	$LN2@SV_SendSer
$LN3@SV_SendSer:

; 1405 : 
; 1406 : 	// send delta-encoding
; 1407 : 	SV_WriteDeltaDescriptionToClient( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_SV_WriteDeltaDescriptionToClient
	add	esp, 4

; 1408 : 
; 1409 : 	// now client know delta and can reading encoded messages
; 1410 : 	SV_FullUpdateMovevars( cl, msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	push	ecx
	call	_SV_FullUpdateMovevars
	add	esp, 8

; 1411 : 
; 1412 : 	// send the user messages registration
; 1413 : 	for( i = 1; i < MAX_USER_MESSAGES && svgame.msg[i].name[0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@SV_SendSer
$LN5@SV_SendSer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 197			; 000000c5H
	jge	SHORT $LN6@SV_SendSer
	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _svgame[eax+edx+4]
	test	eax, eax
	je	SHORT $LN6@SV_SendSer

; 1414 : 		SV_SendUserReg( msg, &svgame.msg[i] );

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svgame+4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_SV_SendUserReg
	add	esp, 8
	jmp	SHORT $LN5@SV_SendSer
$LN6@SV_SendSer:

; 1415 : 
; 1416 : 	for( i = 0; i < MAX_LIGHTSTYLES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SV_SendSer
$LN8@SV_SendSer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SV_SendSer:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN9@SV_SendSer

; 1417 : 	{
; 1418 : 		if( !sv.lightstyles[i].pattern[0] )

	imul	eax, DWORD PTR _i$[ebp], 1296
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sv[eax+edx+726216]
	test	eax, eax
	jne	SHORT $LN13@SV_SendSer

; 1419 : 			continue;	// unused style

	jmp	SHORT $LN8@SV_SendSer
$LN13@SV_SendSer:

; 1420 : 
; 1421 : 		MSG_BeginServerCmd( msg, svc_lightstyle );

	push	0
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1422 : 		MSG_WriteByte( msg, i ); // stylenum

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteByte
	add	esp, 8

; 1423 : 		MSG_WriteString( msg, sv.lightstyles[i].pattern );

	imul	eax, DWORD PTR _i$[ebp], 1296
	add	eax, OFFSET _sv+726216
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1424 : 		MSG_WriteFloat( msg, sv.lightstyles[i].time );

	imul	eax, DWORD PTR _i$[ebp], 1296
	push	ecx
	movss	xmm0, DWORD PTR _sv[eax+727508]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteFloat
	add	esp, 8

; 1425 : 	}

	jmp	$LN8@SV_SendSer
$LN9@SV_SendSer:

; 1426 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_SendServerdata ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_GetPlayerStats
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_ping$ = 12						; size = 4
_packet_loss$ = 16					; size = 4
_SV_GetPlayerStats PROC					; COMDAT

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1139 : 	static int	last_ping[MAX_CLIENTS];
; 1140 : 	static int	last_loss[MAX_CLIENTS];
; 1141 : 	int		i;
; 1142 : 
; 1143 : 	i = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], eax

; 1144 : 
; 1145 : 	if( host.realtime >= cl->next_checkpingtime )

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	comisd	xmm0, QWORD PTR [eax+264344]
	jb	SHORT $LN2@SV_GetPlay

; 1146 : 	{
; 1147 : 		cl->next_checkpingtime = host.realtime + 2.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264344], xmm0

; 1148 : 		last_ping[i] = SV_CalcPing( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_CalcPing
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR ?last_ping@?1??SV_GetPlayerStats@@9@9[ecx*4], eax

; 1149 : 		last_loss[i] = cl->packet_loss;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264936]
	mov	DWORD PTR ?last_loss@?1??SV_GetPlayerStats@@9@9[eax*4], edx
$LN2@SV_GetPlay:

; 1150 : 	}
; 1151 : 
; 1152 : 	if( ping ) *ping = last_ping[i];

	cmp	DWORD PTR _ping$[ebp], 0
	je	SHORT $LN3@SV_GetPlay
	mov	eax, DWORD PTR _ping$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?last_ping@?1??SV_GetPlayerStats@@9@9[ecx*4]
	mov	DWORD PTR [eax], edx
$LN3@SV_GetPlay:

; 1153 : 	if( packet_loss ) *packet_loss = last_loss[i];

	cmp	DWORD PTR _packet_loss$[ebp], 0
	je	SHORT $LN4@SV_GetPlay
	mov	eax, DWORD PTR _packet_loss$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?last_loss@?1??SV_GetPlayerStats@@9@9[ecx*4]
	mov	DWORD PTR [eax], edx
$LN4@SV_GetPlay:

; 1154 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetPlayerStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FullUpdateMovevars
_TEXT	SEGMENT
_nullmovevars$ = -164					; size = 160
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_FullUpdateMovevars PROC				; COMDAT

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1086 : 	movevars_t	nullmovevars;
; 1087 : 
; 1088 : 	memset( &nullmovevars, 0, sizeof( nullmovevars ));

	push	160					; 000000a0H
	push	0
	lea	eax, DWORD PTR _nullmovevars$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1089 : 	MSG_WriteDeltaMovevars( msg, &nullmovevars, &svgame.movevars );

	push	OFFSET _svgame+7936
	lea	eax, DWORD PTR _nullmovevars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteDeltaMovevars
	add	esp, 12					; 0000000cH

; 1090 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FullUpdateMovevars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_FullClientUpdate
_TEXT	SEGMENT
_i$ = -368						; size = 4
_ctx$ = -364						; size = 88
_digest$ = -276						; size = 16
_info$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_msg$ = 12						; size = 4
_SV_FullClientUpdate PROC				; COMDAT

; 1024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 432				; 000001b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1025 : 	char		info[MAX_INFO_STRING];
; 1026 : 	char		digest[16];
; 1027 : 	MD5Context_t	ctx;
; 1028 : 	int		i;	
; 1029 : 
; 1030 : 	// process userinfo before updating
; 1031 : 	SV_UserinfoChanged( cl );

	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_UserinfoChanged
	add	esp, 4

; 1032 : 
; 1033 : 	i = cl - svs.clients;

	mov	eax, DWORD PTR _cl$[ebp]
	sub	eax, DWORD PTR _svs+33344
	cdq
	mov	ecx, 289832				; 00046c28H
	idiv	ecx
	mov	DWORD PTR _i$[ebp], eax

; 1034 : 
; 1035 : 	MSG_BeginServerCmd( msg, svc_updateuserinfo );

	push	0
	push	1
	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1036 : 	MSG_WriteUBitLong( msg, i, MAX_CLIENT_BITS );

	push	5
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteUBitLong
	add	esp, 12					; 0000000cH

; 1037 : 	MSG_WriteLong( msg, cl->userid );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+289828]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_WriteLong
	add	esp, 8

; 1038 : 
; 1039 : 	if( cl->name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+8]
	test	eax, eax
	je	$LN2@SV_FullCli

; 1040 : 	{
; 1041 : 		MSG_WriteOneBit( msg, 1 );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8

; 1042 : 
; 1043 : 		Q_strncpy( info, cl->userinfo, sizeof( info ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1044 : 
; 1045 : 		// remove server passwords, etc.
; 1046 : 		Info_RemovePrefixedKeys( info, '_' );

	push	95					; 0000005fH
	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Info_RemovePrefixedKeys
	add	esp, 8

; 1047 : 		MSG_WriteString( msg, info );

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteString
	add	esp, 8

; 1048 : 
; 1049 : 		MD5Init( &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	call	_MD5Init
	add	esp, 4

; 1050 : 		MD5Update( &ctx, cl->hashedcdkey, sizeof( cl->hashedcdkey ));

	push	34					; 00000022H
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264384				; 000408c0H
	push	eax
	lea	ecx, DWORD PTR _ctx$[ebp]
	push	ecx
	call	_MD5Update
	add	esp, 12					; 0000000cH

; 1051 : 		MD5Final( digest, &ctx );

	lea	eax, DWORD PTR _ctx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _digest$[ebp]
	push	ecx
	call	_MD5Final
	add	esp, 8

; 1052 : 
; 1053 : 		MSG_WriteBytes( msg, digest, sizeof( digest ));

	push	16					; 00000010H
	lea	eax, DWORD PTR _digest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_WriteBytes
	add	esp, 12					; 0000000cH

; 1054 : 	}

	jmp	SHORT $LN1@SV_FullCli
$LN2@SV_FullCli:

; 1055 : 	else MSG_WriteOneBit( msg, 0 );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_FullCli:

; 1056 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_FullClientUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_GetClientIDString
_TEXT	SEGMENT
_cl$ = 8						; size = 4
_SV_GetClientIDString PROC				; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 598  : 	static char	result[MAX_QPATH];
; 599  : 
; 600  : 	if( !cl ) return "";

	cmp	DWORD PTR _cl$[ebp], 0
	jne	SHORT $LN2@SV_GetClie
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	$LN1@SV_GetClie
$LN2@SV_GetClie:

; 601  : 
; 602  : 	if( FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	je	SHORT $LN3@SV_GetClie

; 603  : 	{
; 604  : 		Q_strncpy( result, "ID_BOT", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET ??_C@_06JIGMCFA@ID_BOT@
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 605  : 	}

	jmp	$LN8@SV_GetClie
$LN3@SV_GetClie:

; 606  : 	else if( NET_IsLocalAddress( cl->netchan.remote_address ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN5@SV_GetClie

; 607  : 	{
; 608  : 		Q_strncpy( result, "ID_LOOPBACK", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET ??_C@_0M@BBHCLPEK@ID_LOOPBACK@
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 609  : 	}

	jmp	SHORT $LN8@SV_GetClie
$LN5@SV_GetClie:

; 610  : 	else if( sv_lan.value )

	movss	xmm0, DWORD PTR _sv_lan+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@SV_GetClie

; 611  : 	{
; 612  : 		Q_strncpy( result, "ID_LAN", sizeof( result ));

	push	64					; 00000040H
	push	OFFSET ??_C@_06FDOKGCLC@ID_LAN@
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 613  : 	}

	jmp	SHORT $LN8@SV_GetClie
$LN7@SV_GetClie:

; 614  : 	else
; 615  : 	{
; 616  : 		Q_snprintf( result, sizeof( result ), "ID_%s", MD5_Print( cl->hashedcdkey ));

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264384				; 000408c0H
	push	eax
	call	_MD5_Print
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_05GCODEKLL@ID_?$CFs@
	push	64					; 00000040H
	push	OFFSET ?result@?1??SV_GetClientIDString@@9@9
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN8@SV_GetClie:

; 617  : 	}
; 618  : 
; 619  : 	return result;

	mov	eax, OFFSET ?result@?1??SV_GetClientIDString@@9@9
$LN1@SV_GetClie:

; 620  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetClientIDString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_ShouldUpdatePing
_TEXT	SEGMENT
tv74 = -68						; size = 4
_cl$ = 8						; size = 4
_SV_ShouldUpdatePing PROC				; COMDAT

; 1101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1102 : 	if( FBitSet( cl->flags, FCL_HLTV_PROXY ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 256				; 00000100H
	je	SHORT $LN2@SV_ShouldU

; 1103 : 	{
; 1104 : 		if( host.realtime < cl->next_checkpingtime )

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR [eax+264344]
	comisd	xmm0, QWORD PTR _host+1440
	jbe	SHORT $LN3@SV_ShouldU

; 1105 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@SV_ShouldU
$LN3@SV_ShouldU:

; 1106 : 
; 1107 : 		cl->next_checkpingtime = host.realtime + 2.0;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264344], xmm0

; 1108 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@SV_ShouldU
$LN2@SV_ShouldU:

; 1109 : 	}
; 1110 : 
; 1111 : 	// they are viewing the scoreboard.  Send them pings.
; 1112 : 	return FBitSet( cl->lastcmd.buttons, IN_SCORE ) ? true : false;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264888]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN5@SV_ShouldU
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN6@SV_ShouldU
$LN5@SV_ShouldU:
	mov	DWORD PTR tv74[ebp], 0
$LN6@SV_ShouldU:
	mov	eax, DWORD PTR tv74[ebp]
$LN1@SV_ShouldU:

; 1113 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_ShouldUpdatePing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_TogglePause
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_SV_TogglePause PROC					; COMDAT

; 1316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1317 : 	if( sv.background ) return;

	cmp	DWORD PTR _sv+4, 0
	je	SHORT $LN2@SV_ToggleP
	jmp	SHORT $LN1@SV_ToggleP
$LN2@SV_ToggleP:

; 1318 : 
; 1319 : 	sv.paused ^= 1;

	mov	eax, DWORD PTR _sv+2595656
	xor	eax, 1
	mov	DWORD PTR _sv+2595656, eax

; 1320 : 
; 1321 : 	if( COM_CheckString( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SV_ToggleP

; 1322 : 		SV_BroadcastPrintf( NULL, "%s", msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	call	_SV_BroadcastPrintf
	add	esp, 12					; 0000000cH
$LN3@SV_ToggleP:

; 1323 : 
; 1324 : 	// send notification to all clients
; 1325 : 	MSG_BeginServerCmd( &sv.reliable_datagram, svc_setpause );

	push	0
	push	1
	push	24					; 00000018H
	push	OFFSET _sv+2431724
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1326 : 	MSG_WriteOneBit( &sv.reliable_datagram, sv.paused );

	mov	eax, DWORD PTR _sv+2595656
	push	eax
	push	OFFSET _sv+2431724
	call	_MSG_WriteOneBit
	add	esp, 8
$LN1@SV_ToggleP:

; 1327 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_TogglePause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_GetChallenge
_TEXT	SEGMENT
_oldestTime$ = -16					; size = 8
_oldest$ = -8						; size = 4
_i$ = -4						; size = 4
_from$ = 8						; size = 20
_SV_GetChallenge PROC					; COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 58   : 	int	i, oldest = 0;

	mov	DWORD PTR _oldest$[ebp], 0

; 59   : 	double	oldestTime;
; 60   : 
; 61   : 	oldestTime = 0x7fffffff;

	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	movsd	QWORD PTR _oldestTime$[ebp], xmm0

; 62   : 
; 63   : 	// see if we already have a challenge for this ip
; 64   : 	for( i = 0; i < MAX_CHALLENGES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_GetChal
$LN2@SV_GetChal:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_GetChal:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@SV_GetChal

; 65   : 	{
; 66   : 		if( !svs.challenges[i].connected && NET_CompareAdr( from, svs.challenges[i].adr ))

	imul	eax, DWORD PTR _i$[ebp], 40
	cmp	DWORD PTR _svs[eax+33412], 0
	jne	SHORT $LN5@SV_GetChal
	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_CompareAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN5@SV_GetChal

; 67   : 			break;

	jmp	SHORT $LN3@SV_GetChal
$LN5@SV_GetChal:

; 68   : 
; 69   : 		if( svs.challenges[i].time < oldestTime )

	imul	eax, DWORD PTR _i$[ebp], 40
	movsd	xmm0, QWORD PTR _oldestTime$[ebp]
	comisd	xmm0, QWORD PTR _svs[eax+33400]
	jbe	SHORT $LN6@SV_GetChal

; 70   : 		{
; 71   : 			oldestTime = svs.challenges[i].time;

	imul	eax, DWORD PTR _i$[ebp], 40
	movsd	xmm0, QWORD PTR _svs[eax+33400]
	movsd	QWORD PTR _oldestTime$[ebp], xmm0

; 72   : 			oldest = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _oldest$[ebp], eax
$LN6@SV_GetChal:

; 73   : 		}
; 74   : 	}

	jmp	$LN2@SV_GetChal
$LN3@SV_GetChal:

; 75   : 
; 76   : 	if( i == MAX_CHALLENGES )

	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jne	SHORT $LN7@SV_GetChal

; 77   : 	{
; 78   : 		// this is the first time this client has asked for a challenge
; 79   : 		svs.challenges[oldest].challenge = (COM_RandomLong( 0, 0xFFFF ) << 16) | COM_RandomLong( 0, 0xFFFF );

	push	65535					; 0000ffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	esi, eax
	shl	esi, 16					; 00000010H
	push	65535					; 0000ffffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	or	esi, eax
	imul	eax, DWORD PTR _oldest$[ebp], 40
	mov	DWORD PTR _svs[eax+33408], esi

; 80   : 		svs.challenges[oldest].adr = from;

	imul	eax, DWORD PTR _oldest$[ebp], 40
	add	eax, OFFSET _svs+33376
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx

; 81   : 		svs.challenges[oldest].time = host.realtime;

	imul	eax, DWORD PTR _oldest$[ebp], 40
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _svs[eax+33400], xmm0

; 82   : 		svs.challenges[oldest].connected = false;

	imul	eax, DWORD PTR _oldest$[ebp], 40
	mov	DWORD PTR _svs[eax+33412], 0

; 83   : 		i = oldest;

	mov	eax, DWORD PTR _oldest$[ebp]
	mov	DWORD PTR _i$[ebp], eax
$LN7@SV_GetChal:

; 84   : 	}
; 85   : 
; 86   : 	// send it back
; 87   : 	Netchan_OutOfBandPrint( NS_SERVER, svs.challenges[i].adr, "challenge %i", svs.challenges[i].challenge );

	imul	eax, DWORD PTR _i$[ebp], 40
	mov	ecx, DWORD PTR _svs[eax+33408]
	push	ecx
	push	OFFSET ??_C@_0N@KABAGPMO@challenge?5?$CFi@
	imul	edx, DWORD PTR _i$[ebp], 40
	add	edx, OFFSET _svs+33376
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	push	1
	call	_Netchan_OutOfBandPrint
	add	esp, 32					; 00000020H

; 88   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_GetChallenge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_RefreshUserinfo
_TEXT	SEGMENT
_i$ = -8						; size = 4
_cl$ = -4						; size = 4
_SV_RefreshUserinfo PROC				; COMDAT

; 1065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1066 : 	sv_client_t	*cl;
; 1067 : 	int		i;
; 1068 : 
; 1069 : 	for( i = 0, cl = svs.clients; i < svs.maxclients; i++, cl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _cl$[ebp], eax
	jmp	SHORT $LN4@SV_Refresh
$LN2@SV_Refresh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _cl$[ebp], ecx
$LN4@SV_Refresh:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN1@SV_Refresh

; 1070 : 	{
; 1071 : 		if( cl->state >= cs_connected )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $LN5@SV_Refresh

; 1072 : 			SetBits( cl->flags, FCL_RESEND_USERINFO );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 1
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN5@SV_Refresh:

; 1073 : 	}

	jmp	SHORT $LN2@SV_Refresh
$LN1@SV_Refresh:

; 1074 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RefreshUserinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_RemoteCommand
_TEXT	SEGMENT
$T1 = -1228						; size = 4
_i$ = -1032						; size = 4
_remaining$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_from$ = 8						; size = 20
_msg$ = 28						; size = 4
_SV_RemoteCommand PROC					; COMDAT

; 856  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1228				; 000004ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 857  : 	static char	outputbuf[2048];
; 858  : 	char		remaining[1024];
; 859  : 	int		i;
; 860  : 
; 861  : 	Con_Printf( "Rcon from %s:\n%s\n", NET_AdrToString( from ), MSG_GetData( msg ) + 4 );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetData
	add	esp, 4
	add	eax, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0BC@EHLDDKCE@Rcon?5from?5?$CFs?3?6?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 862  : 	Log_Printf( "Rcon: \"%s\" from \"%s\"\n", MSG_GetData( msg ) + 4, NET_AdrToString( from ));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_GetData
	add	esp, 4
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0BG@CBNMMMKJ@Rcon?3?5?$CC?$CFs?$CC?5from?5?$CC?$CFs?$CC?6@
	call	_Log_Printf
	add	esp, 12					; 0000000cH

; 863  : 	SV_BeginRedirect( from, RD_PACKET, outputbuf, sizeof( outputbuf ) - 16, SV_FlushRedirect );

	push	OFFSET _SV_FlushRedirect
	push	2032					; 000007f0H
	push	OFFSET ?outputbuf@?1??SV_RemoteCommand@@9@9
	push	2
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _from$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _from$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _from$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _from$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _from$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_SV_BeginRedirect
	add	esp, 36					; 00000024H

; 864  : 
; 865  : 	if( Rcon_Validate( ))

	call	_Rcon_Validate
	test	eax, eax
	je	$LN5@SV_RemoteC

; 866  : 	{
; 867  : 		remaining[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1024		; 00000400H
	jae	SHORT $LN8@SV_RemoteC
	jmp	SHORT $LN9@SV_RemoteC
$LN8@SV_RemoteC:
	call	___report_rangecheckfailure
$LN9@SV_RemoteC:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _remaining$[ebp+edx], 0

; 868  : 		for( i = 2; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@SV_RemoteC
$LN2@SV_RemoteC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_RemoteC:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@SV_RemoteC

; 869  : 		{
; 870  : 			Q_strcat( remaining, Cmd_Argv( i ));

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _remaining$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 871  : 			Q_strcat( remaining, " " );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _remaining$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 872  : 		}

	jmp	SHORT $LN2@SV_RemoteC
$LN3@SV_RemoteC:

; 873  : 		Cmd_ExecuteString( remaining );

	lea	eax, DWORD PTR _remaining$[ebp]
	push	eax
	call	_Cmd_ExecuteString
	add	esp, 4

; 874  : 	}

	jmp	SHORT $LN6@SV_RemoteC
$LN5@SV_RemoteC:

; 875  : 	else Con_Printf( S_ERROR "Bad rcon_password.\n" );

	push	OFFSET ??_C@_0BP@EMFADBPO@?$FO1Error?3?$FO7?5Bad?5rcon_password?4?6@
	call	_Con_Printf
	add	esp, 4
$LN6@SV_RemoteC:

; 876  : 
; 877  : 	SV_EndRedirect();

	call	_SV_EndRedirect
$LN7@SV_RemoteC:

; 878  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_RemoteCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_UserinfoChanged
_TEXT	SEGMENT
tv276 = -676						; size = 4
tv215 = -676						; size = 4
tv275 = -672						; size = 4
tv214 = -672						; size = 4
tv172 = -672						; size = 4
_i$1 = -540						; size = 4
_val$ = -536						; size = 4
_current$ = -532					; size = 4
_name2$ = -528						; size = 256
_name1$ = -272						; size = 256
_ent$ = -16						; size = 4
_dupc$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_cl$ = 8						; size = 4
_SV_UserinfoChanged PROC				; COMDAT

; 1566 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 676				; 000002a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1567 : 	int		i, dupc = 1;

	mov	DWORD PTR _dupc$[ebp], 1

; 1568 : 	edict_t		*ent = cl->edict;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	mov	DWORD PTR _ent$[ebp], ecx

; 1569 : 	string		name1, name2;	
; 1570 : 	sv_client_t	*current;
; 1571 : 	char		*val;
; 1572 : 
; 1573 : 	if( !COM_CheckString( cl->userinfo ))

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@SV_Userinf

; 1574 : 		return;

	jmp	$LN1@SV_Userinf
$LN7@SV_Userinf:

; 1575 : 
; 1576 : 	val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1577 : 	Q_strncpy( name2, val, sizeof( name2 ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1578 : 	COM_TrimSpace( name2, name1 );

	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name2$[ebp]
	push	ecx
	call	_COM_TrimSpace
	add	esp, 8

; 1579 : 
; 1580 : 	if( !Q_stricmp( name1, "console" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07PMJAFAE@console@
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@SV_Userinf

; 1581 : 	{
; 1582 : 		Info_SetValueForKey( cl->userinfo, "name", "unnamed", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_07LFIJDALL@unnamed@
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1583 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1584 : 	}

	jmp	SHORT $LN10@SV_Userinf
$LN8@SV_Userinf:

; 1585 : 	else if( Q_strcmp( name1, val ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name1$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@SV_Userinf

; 1586 : 	{
; 1587 : 		Info_SetValueForKey( cl->userinfo, "name", name1, MAX_INFO_STRING );

	push	256					; 00000100H
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1588 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax
$LN10@SV_Userinf:

; 1589 : 	}
; 1590 : 
; 1591 : 	if( !Q_strlen( name1 ))

	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SV_Userinf

; 1592 : 	{
; 1593 : 		Info_SetValueForKey( cl->userinfo, "name", "unnamed", MAX_INFO_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_07LFIJDALL@unnamed@
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1594 : 		val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1595 : 		Q_strncpy( name2, "unnamed", sizeof( name2 ));

	push	256					; 00000100H
	push	OFFSET ??_C@_07LFIJDALL@unnamed@
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1596 : 		Q_strncpy( name1, "unnamed", sizeof( name1 ));

	push	256					; 00000100H
	push	OFFSET ??_C@_07LFIJDALL@unnamed@
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN11@SV_Userinf:

; 1597 : 	}
; 1598 : 
; 1599 : 	// check to see if another user by the same name exists
; 1600 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@SV_Userinf

; 1601 : 	{
; 1602 : 		for( i = 0, current = svs.clients; i < svs.maxclients; i++, current++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _svs+33344
	mov	DWORD PTR _current$[ebp], eax
	jmp	SHORT $LN6@SV_Userinf
$LN4@SV_Userinf:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 289832				; 00046c28H
	mov	DWORD PTR _current$[ebp], ecx
$LN6@SV_Userinf:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN5@SV_Userinf

; 1603 : 		{
; 1604 : 			if( current == cl || current->state != cs_spawned )

	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR _cl$[ebp]
	je	SHORT $LN13@SV_Userinf
	mov	eax, DWORD PTR _current$[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN12@SV_Userinf
$LN13@SV_Userinf:

; 1605 : 				continue;

	jmp	SHORT $LN4@SV_Userinf
$LN12@SV_Userinf:

; 1606 : 
; 1607 : 			if( !Q_stricmp( current->name, val ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 8
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@SV_Userinf

; 1608 : 				break;

	jmp	SHORT $LN5@SV_Userinf
$LN14@SV_Userinf:

; 1609 : 		}

	jmp	SHORT $LN4@SV_Userinf
$LN5@SV_Userinf:

; 1610 : 
; 1611 : 		if( i != svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	je	$LN15@SV_Userinf

; 1612 : 		{
; 1613 : 			// dup name
; 1614 : 			Q_snprintf( name2, sizeof( name2 ), "%s (%u)", name1, dupc++ );

	mov	eax, DWORD PTR _dupc$[ebp]
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR tv172[ebp]
	push	ecx
	lea	edx, DWORD PTR _name1$[ebp]
	push	edx
	push	OFFSET ??_C@_07IBEGINLN@?$CFs?5?$CI?$CFu?$CJ@
	push	256					; 00000100H
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _dupc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _dupc$[ebp], ecx

; 1615 : 			Info_SetValueForKey( cl->userinfo, "name", name2, MAX_INFO_STRING );

	push	256					; 00000100H
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	call	_Info_SetValueForKey
	add	esp, 16					; 00000010H

; 1616 : 			val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1617 : 			Q_strncpy( cl->name, name2, sizeof( cl->name ));

	push	32					; 00000020H
	lea	eax, DWORD PTR _name2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1618 : 		}

	jmp	SHORT $LN16@SV_Userinf
$LN15@SV_Userinf:

; 1619 : 		else
; 1620 : 		{
; 1621 : 			if( dupc == 1 ) // unchanged

	cmp	DWORD PTR _dupc$[ebp], 1
	jne	SHORT $LN17@SV_Userinf

; 1622 : 				Q_strncpy( cl->name, name1, sizeof( cl->name ));

	push	32					; 00000020H
	lea	eax, DWORD PTR _name1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN17@SV_Userinf:

; 1623 : 			break;

	jmp	SHORT $LN3@SV_Userinf
$LN16@SV_Userinf:

; 1624 : 		}
; 1625 : 	}

	jmp	$LN11@SV_Userinf
$LN3@SV_Userinf:

; 1626 : 
; 1627 : 	// rate command
; 1628 : 	val = Info_ValueForKey( cl->userinfo, "rate" );

	push	OFFSET ??_C@_04HCCHHEEF@rate@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1629 : 	if( Q_strlen( val ))

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	$LN18@SV_Userinf

; 1630 : 		cl->netchan.rate = bound( MIN_RATE, Q_atoi( val ), MAX_RATE );

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	comiss	xmm0, DWORD PTR __real@447a0000
	jb	SHORT $LN32@SV_Userinf
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR __real@47c35000
	comiss	xmm1, xmm0
	jbe	SHORT $LN30@SV_Userinf
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR tv214[ebp], xmm0
	jmp	SHORT $LN31@SV_Userinf
$LN30@SV_Userinf:
	movss	xmm0, DWORD PTR __real@47c35000
	movss	DWORD PTR tv214[ebp], xmm0
$LN31@SV_Userinf:
	movss	xmm0, DWORD PTR tv214[ebp]
	movss	DWORD PTR tv215[ebp], xmm0
	jmp	SHORT $LN33@SV_Userinf
$LN32@SV_Userinf:
	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR tv215[ebp], xmm0
$LN33@SV_Userinf:
	cvtss2sd xmm0, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+608], xmm0
	jmp	SHORT $LN19@SV_Userinf
$LN18@SV_Userinf:

; 1631 : 	else cl->netchan.rate = DEFAULT_RATE;

	mov	eax, DWORD PTR _cl$[ebp]
	movsd	xmm0, QWORD PTR __real@40c3878000000000
	movsd	QWORD PTR [eax+608], xmm0
$LN19@SV_Userinf:

; 1632 : 
; 1633 : 	// movement prediction	
; 1634 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_nopred" )))

	push	OFFSET ??_C@_09EFLGBOKH@cl_nopred@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@SV_Userinf

; 1635 : 		ClearBits( cl->flags, FCL_PREDICT_MOVEMENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN21@SV_Userinf
$LN20@SV_Userinf:

; 1636 : 	else SetBits( cl->flags, FCL_PREDICT_MOVEMENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN21@SV_Userinf:

; 1637 : 
; 1638 : 	// lag compensation
; 1639 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_lc" )))

	push	OFFSET ??_C@_05OMKMDA@cl_lc@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@SV_Userinf

; 1640 : 		SetBits( cl->flags, FCL_LAG_COMPENSATION );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN23@SV_Userinf
$LN22@SV_Userinf:

; 1641 : 	else ClearBits( cl->flags, FCL_LAG_COMPENSATION );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN23@SV_Userinf:

; 1642 : 
; 1643 : 	// weapon perdiction
; 1644 : 	if( Q_atoi( Info_ValueForKey( cl->userinfo, "cl_lw" )))

	push	OFFSET ??_C@_05COECHLGF@cl_lw@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@SV_Userinf

; 1645 : 		SetBits( cl->flags, FCL_LOCAL_WEAPONS );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
	jmp	SHORT $LN25@SV_Userinf
$LN24@SV_Userinf:

; 1646 : 	else ClearBits( cl->flags, FCL_LOCAL_WEAPONS );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx
$LN25@SV_Userinf:

; 1647 : 
; 1648 : 	val = Info_ValueForKey( cl->userinfo, "cl_updaterate" );

	push	OFFSET ??_C@_0O@GLEIJHMA@cl_updaterate@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1649 : 
; 1650 : 	if( Q_strlen( val ))

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	$LN28@SV_Userinf

; 1651 : 	{
; 1652 : 		if( Q_atoi( val ) != 0 )

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	test	eax, eax
	je	$LN27@SV_Userinf

; 1653 : 		{
; 1654 : 			int i = bound( 10, Q_atoi( val ), 300 );

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN36@SV_Userinf
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 300				; 0000012cH
	jge	SHORT $LN34@SV_Userinf
	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN35@SV_Userinf
$LN34@SV_Userinf:
	mov	DWORD PTR tv275[ebp], 300		; 0000012cH
$LN35@SV_Userinf:
	mov	eax, DWORD PTR tv275[ebp]
	mov	DWORD PTR tv276[ebp], eax
	jmp	SHORT $LN37@SV_Userinf
$LN36@SV_Userinf:
	mov	DWORD PTR tv276[ebp], 10		; 0000000aH
$LN37@SV_Userinf:
	mov	ecx, DWORD PTR tv276[ebp]
	mov	DWORD PTR _i$1[ebp], ecx

; 1655 : 			cl->cl_updaterate = 1.0 / i;

	cvtsi2sd xmm0, DWORD PTR _i$1[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	mov	eax, DWORD PTR _cl$[ebp]
	movsd	QWORD PTR [eax+264360], xmm1

; 1656 : 		}

	jmp	SHORT $LN28@SV_Userinf
$LN27@SV_Userinf:

; 1657 : 		else cl->cl_updaterate = 0.0;

	mov	eax, DWORD PTR _cl$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+264360], xmm0
$LN28@SV_Userinf:

; 1658 : 	}
; 1659 : 
; 1660 : 	// call prog code to allow overrides
; 1661 : 	svgame.dllFuncs.pfnClientUserInfoChanged( cl->edict, cl->userinfo );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+264948]
	push	edx
	call	DWORD PTR _svgame+19352
	add	esp, 8

; 1662 : 
; 1663 : 	val = Info_ValueForKey( cl->userinfo, "name" );

	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	mov	DWORD PTR _val$[ebp], eax

; 1664 : 	Q_strncpy( cl->name, val, sizeof( cl->name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cl$[ebp]
	add	ecx, 8
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1665 : 	ent->v.netname = MAKE_STRING( cl->name );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 8
	push	eax
	call	_SV_MakeString
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+688], eax
$LN1@SV_Userinf:

; 1666 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_UserinfoChanged ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\server\sv_client.c
;	COMDAT _SV_DropClient
_TEXT	SEGMENT
_i$ = -4						; size = 4
_cl$ = 8						; size = 4
_crash$ = 12						; size = 4
_SV_DropClient PROC					; COMDAT

; 480  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 481  : 	int	i;
; 482  : 	
; 483  : 	if( cl->state == cs_zombie )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@SV_DropCli

; 484  : 		return;	// already dropped

	jmp	$LN12@SV_DropCli
$LN5@SV_DropCli:

; 485  : 
; 486  : 	if( !crash )

	cmp	DWORD PTR _crash$[ebp], 0
	jne	SHORT $LN6@SV_DropCli

; 487  : 	{
; 488  : 		// add the disconnect
; 489  : 		if( !FBitSet( cl->flags, FCL_FAKECLIENT ))

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN7@SV_DropCli

; 490  : 			MSG_BeginServerCmd( &cl->netchan.message, svc_disconnect );

	push	0
	push	1
	push	2
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 660				; 00000294H
	push	eax
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H
$LN7@SV_DropCli:

; 491  : 
; 492  : 		if( cl->edict && cl->state == cs_spawned )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+264948], 0
	je	SHORT $LN8@SV_DropCli
	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN8@SV_DropCli

; 493  : 			svgame.dllFuncs.pfnClientDisconnect( cl->edict );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+264948]
	push	ecx
	call	DWORD PTR _svgame+19336
	add	esp, 4
$LN8@SV_DropCli:

; 494  : 		Netchan_TransmitBits( &cl->netchan, 0, NULL );

	push	0
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_TransmitBits
	add	esp, 12					; 0000000cH
$LN6@SV_DropCli:

; 495  : 	}
; 496  : 
; 497  : 	ClearBits( cl->flags, FCL_FAKECLIENT );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 498  : 	ClearBits( cl->flags, FCL_HLTV_PROXY );

	mov	eax, DWORD PTR _cl$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 499  : 	cl->state = cs_zombie; // become free in a few seconds

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax], 1

; 500  : 	cl->name[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl$[ebp]
	mov	BYTE PTR [edx+ecx+8], 0

; 501  : 
; 502  : 	if( cl->frames )

	mov	eax, DWORD PTR _cl$[ebp]
	cmp	DWORD PTR [eax+281884], 0
	je	SHORT $LN9@SV_DropCli

; 503  : 		Mem_Free( cl->frames ); // release delta

	mov	eax, DWORD PTR ?__LINE__Var@?0??SV_DropClient@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DG@FDKFJKBP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cl$[ebp]
	mov	edx, DWORD PTR [ecx+281884]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@SV_DropCli:

; 504  : 	cl->frames = NULL;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+281884], 0

; 505  : 
; 506  : 	if( NET_CompareBaseAdr( cl->netchan.remote_address, host.rd.address ))

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _host+896
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _host+900
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _host+904
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _host+908
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _host+912
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _cl$[ebp]
	add	edx, 564				; 00000234H
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	call	_NET_CompareBaseAdr
	add	esp, 40					; 00000028H
	test	eax, eax
	je	SHORT $LN10@SV_DropCli

; 507  : 		SV_EndRedirect();

	call	_SV_EndRedirect
$LN10@SV_DropCli:

; 508  : 
; 509  : 	// throw away any residual garbage in the channel.
; 510  : 	Netchan_Clear( &cl->netchan );

	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	call	_Netchan_Clear
	add	esp, 4

; 511  : 
; 512  : 	// clean client data on disconnect
; 513  : 	memset( cl->userinfo, 0, MAX_INFO_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 514  : 	memset( cl->physinfo, 0, MAX_INFO_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 515  : 	COM_ClearCustomizationList( &cl->customdata, false );

	push	0
	mov	eax, DWORD PTR _cl$[ebp]
	add	eax, 264420				; 000408e4H
	push	eax
	call	_COM_ClearCustomizationList
	add	esp, 8

; 516  : 
; 517  : 	// don't send to other clients
; 518  : 	cl->edict = NULL;

	mov	eax, DWORD PTR _cl$[ebp]
	mov	DWORD PTR [eax+264948], 0

; 519  : 
; 520  : 	// send notification to all other clients
; 521  : 	SV_FullClientUpdate( cl, &sv.reliable_datagram );

	push	OFFSET _sv+2431724
	mov	eax, DWORD PTR _cl$[ebp]
	push	eax
	call	_SV_FullClientUpdate
	add	esp, 8

; 522  : 
; 523  : 	// if this was the last client on the server, send a heartbeat
; 524  : 	// to the master so it is known the server is empty
; 525  : 	// send a heartbeat now so the master will get up to date info
; 526  : 	// if there is already a slot for this ip, reuse it
; 527  : 	for( i = 0; i < svs.maxclients; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SV_DropCli
$LN2@SV_DropCli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SV_DropCli:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jge	SHORT $LN3@SV_DropCli

; 528  : 	{
; 529  : 		if( svs.clients[i].state >= cs_connected )

	imul	eax, DWORD PTR _i$[ebp], 289832
	mov	ecx, DWORD PTR _svs+33344
	cmp	DWORD PTR [ecx+eax], 2
	jl	SHORT $LN11@SV_DropCli

; 530  : 			break;

	jmp	SHORT $LN3@SV_DropCli
$LN11@SV_DropCli:

; 531  : 	}

	jmp	SHORT $LN2@SV_DropCli
$LN3@SV_DropCli:

; 532  : 
; 533  : 	if( i == svs.maxclients )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _svs+16
	jne	SHORT $LN12@SV_DropCli

; 534  : 		svs.last_heartbeat = MAX_HEARTBEAT;

	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR _svs+33368, xmm0
$LN12@SV_DropCli:

; 535  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SV_DropClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 109  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsWritten PROC				; COMDAT

; 104  : _inline int MSG_GetNumBitsWritten( sizebuf_t *sb ) { return sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetRealBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetRealBytesWritten PROC				; COMDAT

; 103  : _inline int MSG_GetRealBytesWritten( sizebuf_t *sb ) { return sb->iCurBit >> 3; }	// unpadded

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetRealBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
