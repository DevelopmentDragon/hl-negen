; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\s_mix.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_paintbuffer:QWORD:0401H
COMM	_roombuffer:QWORD:0404H
COMM	_temppaintbuffer:QWORD:0404H
COMM	_g_curpaintbuffer:DWORD
COMM	_paintbuffers:BYTE:0144H
COMM	_streambuffer:QWORD:0401H
COMM	_facingbuffer:QWORD:0404H
COMM	_snd_scaletable:DWORD:08008H
_DATA	ENDS
PUBLIC	_S_InitScaletable
PUBLIC	_S_MixDataToDevice
PUBLIC	_MIX_ClearAllPaintBuffers
PUBLIC	_MIX_InitAllPaintbuffers
PUBLIC	_MIX_FreeAllPaintbuffers
PUBLIC	_MIX_PaintChannels
PUBLIC	_S_TransferPaintBuffer
PUBLIC	_MIX_ActivatePaintbuffer
PUBLIC	_MIX_SetCurrentPaintbuffer
PUBLIC	_MIX_GetCurrentPaintbufferIndex
PUBLIC	_MIX_GetCurrentPaintbufferPtr
PUBLIC	_MIX_DeactivateAllPaintbuffers
PUBLIC	_MIX_ResetPaintbufferFilterCounters
PUBLIC	_MIX_GetPFrontFromIPaint
PUBLIC	_MIX_GetPPaintFromIPaint
PUBLIC	_S_PaintMonoFrom8
PUBLIC	_S_PaintStereoFrom8
PUBLIC	_S_PaintMonoFrom16
PUBLIC	_S_PaintStereoFrom16
PUBLIC	_S_Mix8MonoTimeCompress
PUBLIC	_S_Mix8Mono
PUBLIC	_S_Mix8Stereo
PUBLIC	_S_Mix16Mono
PUBLIC	_S_Mix16Stereo
PUBLIC	_S_MixChannel
PUBLIC	_S_ShouldContinueMixing
PUBLIC	_MIX_MixChannelsToPaintbuffer
PUBLIC	_S_GetNextpFilter
PUBLIC	_S_Interpolate2xCubic
PUBLIC	_S_Interpolate2xLinear
PUBLIC	_S_MixBufferUpsample2x
PUBLIC	_MIX_MixPaintbuffers
PUBLIC	_MIX_CompressPaintbuffer
PUBLIC	_S_MixUpsample
PUBLIC	_MIX_MixStreamBuffer
PUBLIC	_MIX_MixRawSamplesBuffer
PUBLIC	_MIX_UpsampleAllPaintbuffers
PUBLIC	?__LINE__Var@?0??MIX_ActivatePaintbuffer@@9@9	; `MIX_ActivatePaintbuffer'::`1'::__LINE__Var
PUBLIC	??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@ ; `string'
PUBLIC	?__LINE__Var@?0??MIX_SetCurrentPaintbuffer@@9@9	; `MIX_SetCurrentPaintbuffer'::`1'::__LINE__Var
PUBLIC	??_C@_0BJ@FIAEAKMH@g_curpaintbuffer?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	?__LINE__Var@?0??MIX_GetCurrentPaintbufferPtr@@9@9 ; `MIX_GetCurrentPaintbufferPtr'::`1'::__LINE__Var
PUBLIC	??_C@_0BH@MHGFDKMI@ipaint?5?$DM?5CPAINTBUFFERS@	; `string'
PUBLIC	?__LINE__Var@?0??MIX_GetPFrontFromIPaint@@9@9	; `MIX_GetPFrontFromIPaint'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??MIX_GetPPaintFromIPaint@@9@9	; `MIX_GetPPaintFromIPaint'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??S_MixChannel@@9@9		; `S_MixChannel'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@FPLEBBAM@pSource?5?$CB?$DN?5NULL@	; `string'
PUBLIC	?__LINE__Var@?0??S_MixDataToDevice@@9@9		; `S_MixDataToDevice'::`1'::__LINE__Var
PUBLIC	??_C@_0EH@KMLPFBNP@floor?$CI?5sampleFrac?5?$CL?5rate?5?$CK?5?$CI?5ou@ ; `string'
PUBLIC	?__LINE__Var@?0??MIX_MixChannelsToPaintbuffer@@9@9 ; `MIX_MixChannelsToPaintbuffer'::`1'::__LINE__Var
PUBLIC	??_C@_0BO@IKNMDPG@outputRate?5?$DM?$DN?5SOUND_DMA_SPEED@ ; `string'
PUBLIC	??_C@_0EJ@FJHFLJPJ@?$CB?$CI?$CI?5endtime?5?9?5paintedtime?5?$CJ?5?$CG?50@ ; `string'
PUBLIC	?__LINE__Var@?0??S_Interpolate2xCubic@@9@9	; `S_Interpolate2xCubic'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@NHAOPJMJ@upCount?5?$DM?$DN?5PAINTBUFFER_SIZE@ ; `string'
PUBLIC	??_C@_0EG@FDMFCNOI@outpos?5?$DM?$DN?5?$CI?5sizeof?$CI?5temppaintbu@ ; `string'
PUBLIC	??_C@_0N@CJCNACGM@cfltmem?5?$DO?$DN?53@		; `string'
PUBLIC	?__LINE__Var@?0??S_Interpolate2xLinear@@9@9	; `S_Interpolate2xLinear'::`1'::__LINE__Var
PUBLIC	??_C@_0N@BLBLGAOO@cfltmem?5?$DO?$DN?51@		; `string'
PUBLIC	?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9	; `MIX_MixPaintbuffers'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@HAIEOKBA@count?5?$DM?$DN?5PAINTBUFFER_SIZE@ ; `string'
PUBLIC	??_C@_0BG@JJKNADJI@ibuf1?5?$DM?5CPAINTBUFFERS@	; `string'
PUBLIC	??_C@_0BG@HDCLNOPK@ibuf2?5?$DM?5CPAINTBUFFERS@	; `string'
PUBLIC	??_C@_0BG@JMHJGIBL@ibuf3?5?$DM?5CPAINTBUFFERS@	; `string'
PUBLIC	?__LINE__Var@?0??S_MixUpsample@@9@9		; `S_MixUpsample'::`1'::__LINE__Var
PUBLIC	??_C@_0BI@CJPIEBEF@ifilter?5?$DM?5CPAINTFILTERS@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@41b0000000000000
PUBLIC	__real@43800000
PUBLIC	__real@4d800000
EXTRN	_memset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	__imp__ceil:PROC
EXTRN	__imp__floor:PROC
EXTRN	_S_LoadSound:PROC
EXTRN	_S_GetMasterVolume:PROC
EXTRN	_S_GetMusicVolume:PROC
EXTRN	_S_FreeChannel:PROC
EXTRN	_CheckNewDspPresets:PROC
EXTRN	_DSP_Process:PROC
EXTRN	_DSP_GetGain:PROC
EXTRN	_S_FindRawChannel:PROC
EXTRN	_SND_MoveMouth8:PROC
EXTRN	_SND_MoveMouth16:PROC
EXTRN	_S_GetOutputData:PROC
EXTRN	_VOX_ModifyPitch:PROC
EXTRN	_VOX_MixDataToDevice:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_channels:BYTE
EXTRN	_raw_channels:ZWORD
EXTRN	_total_channels:DWORD
EXTRN	_paintedtime:DWORD
EXTRN	_s_listener:BYTE
EXTRN	_idsp_room:DWORD
EXTRN	_dma:BYTE
EXTRN	_s_lerping:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@4d800000
CONST	SEGMENT
__real@4d800000 DD 04d800000r			; 2.68435e+08
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@41b0000000000000
CONST	SEGMENT
__real@41b0000000000000 DQ 041b0000000000000r	; 2.68435e+08
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BI@CJPIEBEF@ifilter?5?$DM?5CPAINTFILTERS@
CONST	SEGMENT
??_C@_0BI@CJPIEBEF@ifilter?5?$DM?5CPAINTFILTERS@ DB 'ifilter < CPAINTFILT'
	DB	'ERS', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_MixUpsample@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_MixUpsample@@9@9 DD 0378H		; `S_MixUpsample'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@JMHJGIBL@ibuf3?5?$DM?5CPAINTBUFFERS@
CONST	SEGMENT
??_C@_0BG@JMHJGIBL@ibuf3?5?$DM?5CPAINTBUFFERS@ DB 'ibuf3 < CPAINTBUFFERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDCLNOPK@ibuf2?5?$DM?5CPAINTBUFFERS@
CONST	SEGMENT
??_C@_0BG@HDCLNOPK@ibuf2?5?$DM?5CPAINTBUFFERS@ DB 'ibuf2 < CPAINTBUFFERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JJKNADJI@ibuf1?5?$DM?5CPAINTBUFFERS@
CONST	SEGMENT
??_C@_0BG@JJKNADJI@ibuf1?5?$DM?5CPAINTBUFFERS@ DB 'ibuf1 < CPAINTBUFFERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HAIEOKBA@count?5?$DM?$DN?5PAINTBUFFER_SIZE@
CONST	SEGMENT
??_C@_0BK@HAIEOKBA@count?5?$DM?$DN?5PAINTBUFFER_SIZE@ DB 'count <= PAINTB'
	DB	'UFFER_SIZE', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9 DD 0347H	; `MIX_MixPaintbuffers'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@BLBLGAOO@cfltmem?5?$DO?$DN?51@
CONST	SEGMENT
??_C@_0N@BLBLGAOO@cfltmem?5?$DO?$DN?51@ DB 'cfltmem >= 1', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_Interpolate2xLinear@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_Interpolate2xLinear@@9@9 DD 02f3H	; `S_Interpolate2xLinear'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@CJCNACGM@cfltmem?5?$DO?$DN?53@
CONST	SEGMENT
??_C@_0N@CJCNACGM@cfltmem?5?$DO?$DN?53@ DB 'cfltmem >= 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FDMFCNOI@outpos?5?$DM?$DN?5?$CI?5sizeof?$CI?5temppaintbu@
CONST	SEGMENT
??_C@_0EG@FDMFCNOI@outpos?5?$DM?$DN?5?$CI?5sizeof?$CI?5temppaintbu@ DB 'o'
	DB	'utpos <= ( sizeof( temppaintbuffer ) / sizeof( temppaintbuffe'
	DB	'r[0] ))', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHAOPJMJ@upCount?5?$DM?$DN?5PAINTBUFFER_SIZE@
CONST	SEGMENT
??_C@_0BM@NHAOPJMJ@upCount?5?$DM?$DN?5PAINTBUFFER_SIZE@ DB 'upCount <= PA'
	DB	'INTBUFFER_SIZE', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_Interpolate2xCubic@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_Interpolate2xCubic@@9@9 DD 0296H	; `S_Interpolate2xCubic'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EJ@FJHFLJPJ@?$CB?$CI?$CI?5endtime?5?9?5paintedtime?5?$CJ?5?$CG?50@
CONST	SEGMENT
??_C@_0EJ@FJHFLJPJ@?$CB?$CI?$CI?5endtime?5?9?5paintedtime?5?$CJ?5?$CG?50@ DB '!'
	DB	'(( endtime - paintedtime ) & 0x3 ) || ( outputRate == SOUND_D'
	DB	'MA_SPEED )', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IKNMDPG@outputRate?5?$DM?$DN?5SOUND_DMA_SPEED@
CONST	SEGMENT
??_C@_0BO@IKNMDPG@outputRate?5?$DM?$DN?5SOUND_DMA_SPEED@ DB 'outputRate <'
	DB	'= SOUND_DMA_SPEED', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_MixChannelsToPaintbuffer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_MixChannelsToPaintbuffer@@9@9 DD 0216H ; `MIX_MixChannelsToPaintbuffer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EH@KMLPFBNP@floor?$CI?5sampleFrac?5?$CL?5rate?5?$CK?5?$CI?5ou@
CONST	SEGMENT
??_C@_0EH@KMLPFBNP@floor?$CI?5sampleFrac?5?$CL?5rate?5?$CK?5?$CI?5ou@ DB 'f'
	DB	'loor( sampleFrac + rate * ( outSampleCount - 1 )) <= availabl'
	DB	'eSamples', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_MixDataToDevice@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_MixDataToDevice@@9@9 DD 01a7H	; `S_MixDataToDevice'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@FPLEBBAM@pSource?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BA@FPLEBBAM@pSource?5?$CB?$DN?5NULL@ DB 'pSource != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_MixChannel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_MixChannel@@9@9 DD 018cH		; `S_MixChannel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_GetPPaintFromIPaint@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_GetPPaintFromIPaint@@9@9 DD 0baH	; `MIX_GetPPaintFromIPaint'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_GetPFrontFromIPaint@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_GetPFrontFromIPaint@@9@9 DD 0b4H	; `MIX_GetPFrontFromIPaint'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@MHGFDKMI@ipaint?5?$DM?5CPAINTBUFFERS@
CONST	SEGMENT
??_C@_0BH@MHGFDKMI@ipaint?5?$DM?5CPAINTBUFFERS@ DB 'ipaint < CPAINTBUFFER'
	DB	'S', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_GetCurrentPaintbufferPtr@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_GetCurrentPaintbufferPtr@@9@9 DD 093H ; `MIX_GetCurrentPaintbufferPtr'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BJ@FIAEAKMH@g_curpaintbuffer?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BJ@FIAEAKMH@g_curpaintbuffer?5?$CB?$DN?5NULL@ DB 'g_curpaintbuffer'
	DB	' != NULL', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_SetCurrentPaintbuffer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_SetCurrentPaintbuffer@@9@9 DD 080H	; `MIX_SetCurrentPaintbuffer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@
CONST	SEGMENT
??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@ DB 'ipaintbuffer < '
	DB	'CPAINTBUFFERS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\s_mix.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??MIX_ActivatePaintbuffer@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??MIX_ActivatePaintbuffer@@9@9 DD 073H	; `MIX_ActivatePaintbuffer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	072H
	DB	085H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	037H
	DB	065H
	DB	078H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_UpsampleAllPaintbuffers
_TEXT	SEGMENT
_end$ = 8						; size = 4
_count$ = 12						; size = 4
_MIX_UpsampleAllPaintbuffers PROC			; COMDAT

; 969  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 970  : 	// process stream buffer
; 971  : 	MIX_MixStreamBuffer( end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_MIX_MixStreamBuffer
	add	esp, 4

; 972  : 
; 973  : 	// 11khz sounds are mixed into 3 buffers based on distance from listener, and facing direction
; 974  : 	// These buffers are facing, facingaway, room
; 975  : 	// These 3 mixed buffers are then each upsampled to 22khz.
; 976  : 
; 977  : 	// 22khz sounds are mixed into the 3 buffers based on distance from listener, and facing direction
; 978  : 	// These 3 mixed buffers are then each upsampled to 44khz.
; 979  : 
; 980  : 	// 44khz sounds are mixed into the 3 buffers based on distance from listener, and facing direction
; 981  : 
; 982  : 	MIX_DeactivateAllPaintbuffers();

	call	_MIX_DeactivateAllPaintbuffers

; 983  : 
; 984  : 	// set paintbuffer upsample filter indices to 0
; 985  : 	MIX_ResetPaintbufferFilterCounters();

	call	_MIX_ResetPaintbufferFilterCounters

; 986  : 
; 987  : 	// only mix to roombuffer if dsp fx are on KDB: perf
; 988  : 	MIX_ActivatePaintbuffer( IROOMBUFFER );	// operates on MIX_MixChannelsToPaintbuffer

	push	1
	call	_MIX_ActivatePaintbuffer
	add	esp, 4

; 989  : 
; 990  : 	// mix 11khz sounds: 
; 991  : 	MIX_MixChannelsToPaintbuffer( end, SOUND_11k, SOUND_11k );

	push	11025					; 00002b11H
	push	11025					; 00002b11H
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_MIX_MixChannelsToPaintbuffer
	add	esp, 12					; 0000000cH

; 992  : 
; 993  : 	// upsample all 11khz buffers by 2x
; 994  : 	// only upsample roombuffer if dsp fx are on KDB: perf
; 995  : 	MIX_SetCurrentPaintbuffer( IROOMBUFFER ); // operates on MixUpSample

	push	1
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 996  : 	S_MixUpsample( count / (SOUND_DMA_SPEED / SOUND_11k), FILTERTYPE_LINEAR ); 

	push	1
	mov	eax, DWORD PTR _count$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	eax
	call	_S_MixUpsample
	add	esp, 8

; 997  : 
; 998  : 	// mix 22khz sounds: 
; 999  : 	MIX_MixChannelsToPaintbuffer( end, SOUND_22k, SOUND_22k );

	push	22050					; 00005622H
	push	22050					; 00005622H
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_MIX_MixChannelsToPaintbuffer
	add	esp, 12					; 0000000cH

; 1000 : 	
; 1001 : 	// upsample all 22khz buffers by 2x
; 1002 : 	// only upsample roombuffer if dsp fx are on KDB: perf
; 1003 : 	MIX_SetCurrentPaintbuffer( IROOMBUFFER );

	push	1
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 1004 : 	S_MixUpsample( count / ( SOUND_DMA_SPEED / SOUND_22k ), FILTERTYPE_LINEAR );

	push	1
	mov	eax, DWORD PTR _count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	call	_S_MixUpsample
	add	esp, 8

; 1005 : 
; 1006 : 	// mix all 44khz sounds to all active paintbuffers
; 1007 : 	MIX_MixChannelsToPaintbuffer( end, SOUND_44k, SOUND_DMA_SPEED );

	push	44100					; 0000ac44H
	push	44100					; 0000ac44H
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_MIX_MixChannelsToPaintbuffer
	add	esp, 12					; 0000000cH

; 1008 : 
; 1009 : 	// mix raw samples from the video streams
; 1010 : 	MIX_SetCurrentPaintbuffer( IROOMBUFFER );

	push	1
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 1011 : 	MIX_MixRawSamplesBuffer( end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_MIX_MixRawSamplesBuffer
	add	esp, 4

; 1012 : 
; 1013 : 	MIX_DeactivateAllPaintbuffers();

	call	_MIX_DeactivateAllPaintbuffers

; 1014 : 	MIX_SetCurrentPaintbuffer( IPAINTBUFFER );

	push	0
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 1015 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_UpsampleAllPaintbuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_MixRawSamplesBuffer
_TEXT	SEGMENT
tv83 = -88						; size = 4
_ch$1 = -20						; size = 4
_stop$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_pbuf$ = -4						; size = 4
_end$ = 8						; size = 4
_MIX_MixRawSamplesBuffer PROC				; COMDAT

; 932  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 933  : 	portable_samplepair_t	*pbuf;
; 934  : 	uint			i, j, stop;
; 935  : 
; 936  : 	pbuf = MIX_GetCurrentPaintbufferPtr()->pbuf;

	call	_MIX_GetCurrentPaintbufferPtr
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pbuf$[ebp], eax

; 937  : 
; 938  : 	if( s_listener.paused ) return;

	cmp	DWORD PTR _s_listener+80, 0
	je	SHORT $LN8@MIX_MixRaw
	jmp	$LN1@MIX_MixRaw
$LN8@MIX_MixRaw:

; 939  : 
; 940  : 	// paint in the raw channels
; 941  : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_MixRaw
$LN2@MIX_MixRaw:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_MixRaw:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jae	$LN1@MIX_MixRaw

; 942  : 	{
; 943  : 		// copy from the streaming sound source
; 944  : 		rawchan_t	*ch = raw_channels[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$1[ebp], ecx

; 945  : 
; 946  : 		// background track should be mixing into another buffer
; 947  : 		if( !ch || ch->entnum == S_RAW_SOUND_BACKGROUNDTRACK )

	cmp	DWORD PTR _ch$1[ebp], 0
	je	SHORT $LN10@MIX_MixRaw
	mov	eax, DWORD PTR _ch$1[ebp]
	cmp	DWORD PTR [eax], -2			; fffffffeH
	jne	SHORT $LN9@MIX_MixRaw
$LN10@MIX_MixRaw:

; 948  : 			continue;

	jmp	SHORT $LN2@MIX_MixRaw
$LN9@MIX_MixRaw:

; 949  : 
; 950  : 		// not audible
; 951  : 		if( !ch->leftvol && !ch->rightvol )

	mov	eax, DWORD PTR _ch$1[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@MIX_MixRaw
	mov	eax, DWORD PTR _ch$1[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN11@MIX_MixRaw

; 952  : 			continue;

	jmp	SHORT $LN2@MIX_MixRaw
$LN11@MIX_MixRaw:

; 953  : 
; 954  : 		stop = (end < ch->s_rawend) ? end : ch->s_rawend;

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR _end$[ebp], ecx
	jae	SHORT $LN13@MIX_MixRaw
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@MIX_MixRaw
$LN13@MIX_MixRaw:
	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@MIX_MixRaw:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _stop$[ebp], edx

; 955  : 
; 956  : 		for( j = paintedtime; j < stop; j++ )

	mov	eax, DWORD PTR _paintedtime
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@MIX_MixRaw
$LN5@MIX_MixRaw:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@MIX_MixRaw:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _stop$[ebp]
	jae	SHORT $LN6@MIX_MixRaw

; 957  : 		{
; 958  : 			pbuf[j-paintedtime].left += ( ch->rawsamples[j & ( ch->max_samples - 1 )].left * ch->leftvol ) >> 8;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	ecx, DWORD PTR _ch$1[ebp]
	mov	edx, DWORD PTR [ecx+72]
	sub	edx, 1
	and	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _ch$1[ebp]
	mov	esi, DWORD PTR _ch$1[ebp]
	mov	edx, DWORD PTR [ecx+edx*8+76]
	imul	edx, DWORD PTR [esi+8]
	sar	edx, 8
	mov	ecx, DWORD PTR _pbuf$[ebp]
	add	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 959  : 			pbuf[j-paintedtime].right += ( ch->rawsamples[j & ( ch->max_samples - 1 )].right * ch->rightvol ) >> 8;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	ecx, DWORD PTR _ch$1[ebp]
	mov	edx, DWORD PTR [ecx+72]
	sub	edx, 1
	and	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _ch$1[ebp]
	mov	esi, DWORD PTR _ch$1[ebp]
	mov	edx, DWORD PTR [ecx+edx*8+80]
	imul	edx, DWORD PTR [esi+12]
	sar	edx, 8
	mov	ecx, DWORD PTR _pbuf$[ebp]
	add	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 960  : 		}

	jmp	$LN5@MIX_MixRaw
$LN6@MIX_MixRaw:

; 961  : 	}

	jmp	$LN2@MIX_MixRaw
$LN1@MIX_MixRaw:

; 962  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_MixRawSamplesBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_MixStreamBuffer
_TEXT	SEGMENT
tv84 = -84						; size = 4
_stop$1 = -16						; size = 4
_i$2 = -12						; size = 4
_ch$ = -8						; size = 4
_pbuf$ = -4						; size = 4
_end$ = 8						; size = 4
_MIX_MixStreamBuffer PROC				; COMDAT

; 901  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 902  : 	portable_samplepair_t	*pbuf;
; 903  : 	rawchan_t			*ch;
; 904  : 
; 905  : 	pbuf = MIX_GetPFrontFromIPaint( ISTREAMBUFFER );

	push	2
	call	_MIX_GetPFrontFromIPaint
	add	esp, 4
	mov	DWORD PTR _pbuf$[ebp], eax

; 906  : 	ch = S_FindRawChannel( S_RAW_SOUND_BACKGROUNDTRACK, false );

	push	0
	push	-2					; fffffffeH
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax

; 907  : 
; 908  : 	// clear the paint buffer
; 909  : 	if( s_listener.paused || !ch || ch->s_rawend < paintedtime )

	cmp	DWORD PTR _s_listener+80, 0
	jne	SHORT $LN10@MIX_MixStr
	cmp	DWORD PTR _ch$[ebp], 0
	je	SHORT $LN10@MIX_MixStr
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	jae	SHORT $LN8@MIX_MixStr
$LN10@MIX_MixStr:

; 910  : 	{
; 911  : 		memset( pbuf, 0, (end - paintedtime) * sizeof( portable_samplepair_t ));

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _paintedtime
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 912  : 	}

	jmp	$LN1@MIX_MixStr
$LN8@MIX_MixStr:

; 913  : 	else
; 914  : 	{	
; 915  : 		int	i, stop;
; 916  : 
; 917  : 		// copy from the streaming sound source
; 918  : 		stop = (end < ch->s_rawend) ? end : ch->s_rawend;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	DWORD PTR _end$[ebp], ecx
	jae	SHORT $LN12@MIX_MixStr
	mov	edx, DWORD PTR _end$[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN13@MIX_MixStr
$LN12@MIX_MixStr:
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv84[ebp], ecx
$LN13@MIX_MixStr:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _stop$1[ebp], edx

; 919  : 
; 920  : 		for( i = paintedtime; i < stop; i++ )

	mov	eax, DWORD PTR _paintedtime
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN4@MIX_MixStr
$LN2@MIX_MixStr:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@MIX_MixStr:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _stop$1[ebp]
	jge	SHORT $LN3@MIX_MixStr

; 921  : 		{
; 922  : 			pbuf[i-paintedtime].left = ( ch->rawsamples[i & ( ch->max_samples - 1 )].left * ch->leftvol ) >> 8;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	sub	ecx, 1
	and	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8+76]
	imul	ecx, DWORD PTR [eax+8]
	sar	ecx, 8
	mov	edx, DWORD PTR _i$2[ebp]
	sub	edx, DWORD PTR _paintedtime
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 923  : 			pbuf[i-paintedtime].right = ( ch->rawsamples[i & ( ch->max_samples - 1 )].right * ch->rightvol ) >> 8;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	sub	ecx, 1
	and	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*8+80]
	imul	ecx, DWORD PTR [eax+12]
	sar	ecx, 8
	mov	edx, DWORD PTR _i$2[ebp]
	sub	edx, DWORD PTR _paintedtime
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 924  : 		}			

	jmp	SHORT $LN2@MIX_MixStr
$LN3@MIX_MixStr:

; 925  : 
; 926  : 		for( ; i < end; i++ )

	jmp	SHORT $LN7@MIX_MixStr
$LN5@MIX_MixStr:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@MIX_MixStr:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jge	SHORT $LN1@MIX_MixStr

; 927  : 			pbuf[i-paintedtime].left = pbuf[i-paintedtime].right = 0;

	mov	eax, DWORD PTR _i$2[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], 0
	mov	edx, DWORD PTR _i$2[ebp]
	sub	edx, DWORD PTR _paintedtime
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+edx*8], 0
	jmp	SHORT $LN5@MIX_MixStr
$LN1@MIX_MixStr:

; 928  : 	}
; 929  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_MixStreamBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_MixUpsample
_TEXT	SEGMENT
tv72 = -76						; size = 4
_ifilter$ = -8						; size = 4
_ppaint$ = -4						; size = 4
_sampleCount$ = 8					; size = 4
_filtertype$ = 12					; size = 4
_S_MixUpsample PROC					; COMDAT

; 888  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 889  : 	paintbuffer_t	*ppaint = MIX_GetCurrentPaintbufferPtr();

	call	_MIX_GetCurrentPaintbufferPtr
	mov	DWORD PTR _ppaint$[ebp], eax

; 890  : 	int		ifilter = ppaint->ifilter;

	mov	eax, DWORD PTR _ppaint$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ifilter$[ebp], ecx

; 891  : 
; 892  : 	Assert( ifilter < CPAINTFILTERS );

	cmp	DWORD PTR _ifilter$[ebp], 4
	jge	SHORT $LN3@S_MixUpsam
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@S_MixUpsam
$LN3@S_MixUpsam:
	mov	DWORD PTR tv72[ebp], 0
$LN4@S_MixUpsam:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_MixUpsample@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@CJPIEBEF@ifilter?5?$DM?5CPAINTFILTERS@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 893  : 
; 894  : 	S_MixBufferUpsample2x( sampleCount, ppaint->pbuf, &(ppaint->fltmem[ifilter][0]), CPAINTFILTERMEM, filtertype );

	mov	eax, DWORD PTR _filtertype$[ebp]
	push	eax
	push	3
	imul	ecx, DWORD PTR _ifilter$[ebp], 24
	mov	edx, DWORD PTR _ppaint$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	ecx, 8
	imul	edx, ecx, 0
	add	eax, edx
	push	eax
	mov	eax, DWORD PTR _ppaint$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _sampleCount$[ebp]
	push	edx
	call	_S_MixBufferUpsample2x
	add	esp, 20					; 00000014H

; 895  : 
; 896  : 	// make sure on next upsample pass for this paintbuffer, new filter memory is used
; 897  : 	ppaint->ifilter++;

	mov	eax, DWORD PTR _ppaint$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _ppaint$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 898  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_MixUpsample ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_CompressPaintbuffer
_TEXT	SEGMENT
tv84 = -84						; size = 4
tv76 = -84						; size = 4
tv85 = -80						; size = 4
tv77 = -80						; size = 4
_i$ = -12						; size = 4
_ppaint$ = -8						; size = 4
_pbuf$ = -4						; size = 4
_ipaint$ = 8						; size = 4
_count$ = 12						; size = 4
_MIX_CompressPaintbuffer PROC				; COMDAT

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 873  : 	portable_samplepair_t	*pbuf;
; 874  : 	paintbuffer_t		*ppaint;
; 875  : 	int			i;
; 876  : 
; 877  : 	ppaint = MIX_GetPPaintFromIPaint( ipaint );

	mov	eax, DWORD PTR _ipaint$[ebp]
	push	eax
	call	_MIX_GetPPaintFromIPaint
	add	esp, 4
	mov	DWORD PTR _ppaint$[ebp], eax

; 878  : 	pbuf = ppaint->pbuf;

	mov	eax, DWORD PTR _ppaint$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pbuf$[ebp], ecx

; 879  : 	
; 880  : 	for( i = 0; i < count; i++, pbuf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_Compre
$LN2@MIX_Compre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	add	ecx, 8
	mov	DWORD PTR _pbuf$[ebp], ecx
$LN4@MIX_Compre:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN1@MIX_Compre

; 881  : 	{
; 882  : 		pbuf->left = CLIP( pbuf->left );

	mov	eax, DWORD PTR _pbuf$[ebp]
	cmp	DWORD PTR [eax], 32760			; 00007ff8H
	jle	SHORT $LN8@MIX_Compre
	mov	DWORD PTR tv77[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN9@MIX_Compre
$LN8@MIX_Compre:
	mov	ecx, DWORD PTR _pbuf$[ebp]
	cmp	DWORD PTR [ecx], -32760			; ffff8008H
	jge	SHORT $LN6@MIX_Compre
	mov	DWORD PTR tv76[ebp], -32760		; ffff8008H
	jmp	SHORT $LN7@MIX_Compre
$LN6@MIX_Compre:
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv76[ebp], eax
$LN7@MIX_Compre:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv77[ebp], ecx
$LN9@MIX_Compre:
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR [edx], eax

; 883  : 		pbuf->right = CLIP( pbuf->right );

	mov	eax, DWORD PTR _pbuf$[ebp]
	cmp	DWORD PTR [eax+4], 32760		; 00007ff8H
	jle	SHORT $LN12@MIX_Compre
	mov	DWORD PTR tv85[ebp], 32760		; 00007ff8H
	jmp	SHORT $LN13@MIX_Compre
$LN12@MIX_Compre:
	mov	ecx, DWORD PTR _pbuf$[ebp]
	cmp	DWORD PTR [ecx+4], -32760		; ffff8008H
	jge	SHORT $LN10@MIX_Compre
	mov	DWORD PTR tv84[ebp], -32760		; ffff8008H
	jmp	SHORT $LN11@MIX_Compre
$LN10@MIX_Compre:
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv84[ebp], eax
$LN11@MIX_Compre:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv85[ebp], ecx
$LN13@MIX_Compre:
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR [edx+4], eax

; 884  : 	}

	jmp	$LN2@MIX_Compre
$LN1@MIX_Compre:

; 885  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_CompressPaintbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_MixPaintbuffers
_TEXT	SEGMENT
tv128 = -88						; size = 4
tv88 = -88						; size = 4
tv80 = -88						; size = 4
tv72 = -88						; size = 4
_gain$ = -20						; size = 4
_i$ = -16						; size = 4
_pbuf3$ = -12						; size = 4
_pbuf2$ = -8						; size = 4
_pbuf1$ = -4						; size = 4
_ibuf1$ = 8						; size = 4
_ibuf2$ = 12						; size = 4
_ibuf3$ = 16						; size = 4
_count$ = 20						; size = 4
_fgain$ = 24						; size = 4
_MIX_MixPaintbuffers PROC				; COMDAT

; 839  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 840  : 	portable_samplepair_t	*pbuf1, *pbuf2, *pbuf3;
; 841  : 	int			i, gain;
; 842  : 
; 843  : 	gain = 256 * fgain;

	movss	xmm0, DWORD PTR __real@43800000
	mulss	xmm0, DWORD PTR _fgain$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _gain$[ebp], eax

; 844  : 	
; 845  : 	Assert( count <= PAINTBUFFER_SIZE );

	cmp	DWORD PTR _count$[ebp], 1024		; 00000400H
	jg	SHORT $LN6@MIX_MixPai
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@MIX_MixPai
$LN6@MIX_MixPai:
	mov	DWORD PTR tv72[ebp], 0
$LN7@MIX_MixPai:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BK@HAIEOKBA@count?5?$DM?$DN?5PAINTBUFFER_SIZE@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 846  : 	Assert( ibuf1 < CPAINTBUFFERS );

	cmp	DWORD PTR _ibuf1$[ebp], 3
	jge	SHORT $LN8@MIX_MixPai
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN9@MIX_MixPai
$LN8@MIX_MixPai:
	mov	DWORD PTR tv80[ebp], 0
$LN9@MIX_MixPai:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BG@JJKNADJI@ibuf1?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv80[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 847  : 	Assert( ibuf2 < CPAINTBUFFERS );

	cmp	DWORD PTR _ibuf2$[ebp], 3
	jge	SHORT $LN10@MIX_MixPai
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN11@MIX_MixPai
$LN10@MIX_MixPai:
	mov	DWORD PTR tv88[ebp], 0
$LN11@MIX_MixPai:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BG@HDCLNOPK@ibuf2?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv88[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 848  : 	Assert( ibuf3 < CPAINTBUFFERS );

	cmp	DWORD PTR _ibuf3$[ebp], 3
	jge	SHORT $LN12@MIX_MixPai
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN13@MIX_MixPai
$LN12@MIX_MixPai:
	mov	DWORD PTR tv128[ebp], 0
$LN13@MIX_MixPai:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_MixPaintbuffers@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BG@JMHJGIBL@ibuf3?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv128[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 849  : 
; 850  : 	pbuf1 = paintbuffers[ibuf1].pbuf;

	imul	eax, DWORD PTR _ibuf1$[ebp], 108
	mov	ecx, DWORD PTR _paintbuffers[eax+4]
	mov	DWORD PTR _pbuf1$[ebp], ecx

; 851  : 	pbuf2 = paintbuffers[ibuf2].pbuf;

	imul	eax, DWORD PTR _ibuf2$[ebp], 108
	mov	ecx, DWORD PTR _paintbuffers[eax+4]
	mov	DWORD PTR _pbuf2$[ebp], ecx

; 852  : 	pbuf3 = paintbuffers[ibuf3].pbuf;

	imul	eax, DWORD PTR _ibuf3$[ebp], 108
	mov	ecx, DWORD PTR _paintbuffers[eax+4]
	mov	DWORD PTR _pbuf3$[ebp], ecx

; 853  : 	
; 854  : 	// destination buffer stereo - average n chans down to stereo 
; 855  : 
; 856  : 	// destination 2ch:
; 857  : 	// pb1 2ch + pb2 2ch		-> pb3 2ch
; 858  : 	// pb1 2ch + pb2 (4ch->2ch)		-> pb3 2ch
; 859  : 	// pb1 (4ch->2ch) + pb2 (4ch->2ch)	-> pb3 2ch
; 860  : 
; 861  : 	// mix front channels
; 862  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_MixPai
$LN2@MIX_MixPai:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_MixPai:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	SHORT $LN3@MIX_MixPai

; 863  : 	{
; 864  : 		pbuf3[i].left = pbuf1[i].left;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pbuf1$[ebp]
	mov	edx, DWORD PTR [esi+edx*8]
	mov	DWORD PTR [ecx+eax*8], edx

; 865  : 		pbuf3[i].right = pbuf1[i].right;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pbuf1$[ebp]
	mov	edx, DWORD PTR [esi+edx*8+4]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 866  : 		pbuf3[i].left += (pbuf2[i].left * gain) >> 8;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf2$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	imul	edx, DWORD PTR _gain$[ebp]
	sar	edx, 8
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	add	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 867  : 		pbuf3[i].right += (pbuf2[i].right * gain) >> 8;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf2$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	imul	edx, DWORD PTR _gain$[ebp]
	sar	edx, 8
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	add	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf3$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 868  : 	}

	jmp	SHORT $LN2@MIX_MixPai
$LN3@MIX_MixPai:

; 869  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_MixPaintbuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_MixBufferUpsample2x
_TEXT	SEGMENT
tv83 = -80						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_upCount$ = -4						; size = 4
_count$ = 8						; size = 4
_pbuffer$ = 12						; size = 4
_pfiltermem$ = 16					; size = 4
_cfltmem$ = 20						; size = 4
_filtertype$ = 24					; size = 4
_S_MixBufferUpsample2x PROC				; COMDAT

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 785  : 	int	upCount = count<<1;

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 1
	mov	DWORD PTR _upCount$[ebp], eax

; 786  : 	int	i, j;	
; 787  : 
; 788  : 	// reverse through buffer, duplicating contents for 'count' samples
; 789  : 	for( i = upCount - 1, j = count - 1; j >= 0; i-=2, j-- )

	mov	eax, DWORD PTR _upCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN4@S_MixBuffe
$LN2@S_MixBuffe:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 2
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN4@S_MixBuffe:
	cmp	DWORD PTR _j$[ebp], 0
	jl	SHORT $LN3@S_MixBuffe

; 790  : 	{	
; 791  : 		pbuffer[i] = pbuffer[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	DWORD PTR [esi+ecx*8+4], eax

; 792  : 		pbuffer[i-1] = pbuffer[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [esi+ecx*8-8], edx
	mov	DWORD PTR [esi+ecx*8-4], eax

; 793  : 	}

	jmp	SHORT $LN2@S_MixBuffe
$LN3@S_MixBuffe:

; 794  : 
; 795  : 	if( !s_lerping->value ) return;

	mov	eax, DWORD PTR _s_lerping
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@S_MixBuffe
	jmp	SHORT $LN5@S_MixBuffe
$LN7@S_MixBuffe:

; 796  : 	
; 797  : 	// pass forward through buffer, interpolate all even slots
; 798  : 	switch( filtertype )

	mov	eax, DWORD PTR _filtertype$[ebp]
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 1
	je	SHORT $LN8@S_MixBuffe
	cmp	DWORD PTR tv83[ebp], 2
	je	SHORT $LN9@S_MixBuffe
	jmp	SHORT $LN10@S_MixBuffe
$LN8@S_MixBuffe:

; 799  : 	{
; 800  : 	case FILTERTYPE_LINEAR:
; 801  : 		S_Interpolate2xLinear( pbuffer, pfiltermem, cfltmem, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfltmem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfiltermem$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuffer$[ebp]
	push	eax
	call	_S_Interpolate2xLinear
	add	esp, 16					; 00000010H

; 802  : 		break;

	jmp	SHORT $LN5@S_MixBuffe
$LN9@S_MixBuffe:

; 803  : 	case FILTERTYPE_CUBIC:
; 804  : 		S_Interpolate2xCubic( pbuffer, pfiltermem, cfltmem, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfltmem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfiltermem$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuffer$[ebp]
	push	eax
	call	_S_Interpolate2xCubic
	add	esp, 16					; 00000010H
$LN10@S_MixBuffe:
$LN5@S_MixBuffe:

; 805  : 		break;
; 806  : 	default:	// no filter
; 807  : 		break;
; 808  : 	}
; 809  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_MixBufferUpsample2x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Interpolate2xLinear
_TEXT	SEGMENT
tv79 = -76						; size = 4
tv71 = -76						; size = 4
_upCount$ = -8						; size = 4
_i$ = -4						; size = 4
_pbuffer$ = 8						; size = 4
_pfiltermem$ = 12					; size = 4
_cfltmem$ = 16						; size = 4
_count$ = 20						; size = 4
_S_Interpolate2xLinear PROC				; COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 756  : 	int	i, upCount = count<<1;

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 1
	mov	DWORD PTR _upCount$[ebp], eax

; 757  : 
; 758  : 	Assert( upCount <= PAINTBUFFER_SIZE );

	cmp	DWORD PTR _upCount$[ebp], 1024		; 00000400H
	jg	SHORT $LN6@S_Interpol
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN7@S_Interpol
$LN6@S_Interpol:
	mov	DWORD PTR tv71[ebp], 0
$LN7@S_Interpol:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Interpolate2xLinear@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BM@NHAOPJMJ@upCount?5?$DM?$DN?5PAINTBUFFER_SIZE@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 759  : 	Assert( cfltmem >= 1 );

	cmp	DWORD PTR _cfltmem$[ebp], 1
	jl	SHORT $LN8@S_Interpol
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN9@S_Interpol
$LN8@S_Interpol:
	mov	DWORD PTR tv79[ebp], 0
$LN9@S_Interpol:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Interpolate2xLinear@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@BLBLGAOO@cfltmem?5?$DO?$DN?51@
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 760  : 
; 761  : 	// use interpolation value from previous mix
; 762  : 	pbuffer[0].left = (pfiltermem->left + pbuffer[0].left) >> 1;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pfiltermem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _pbuffer$[ebp]
	add	eax, DWORD PTR [edx+ecx]
	sar	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 763  : 	pbuffer[0].right = (pfiltermem->right + pbuffer[0].right) >> 1;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pfiltermem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _pbuffer$[ebp]
	add	eax, DWORD PTR [edx+ecx+4]
	sar	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [ecx+edx+4], eax

; 764  : 
; 765  : 	for( i = 2; i < upCount; i += 2 )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@S_Interpol
$LN2@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _upCount$[ebp]
	jge	SHORT $LN3@S_Interpol

; 766  : 	{
; 767  : 		// use linear interpolation for upsampling
; 768  : 		pbuffer[i].left = (pbuffer[i].left + pbuffer[i-1].left) >> 1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	add	edx, DWORD PTR [ecx+eax*8-8]
	sar	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 769  : 		pbuffer[i].right = (pbuffer[i].right + pbuffer[i-1].right) >> 1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	add	edx, DWORD PTR [ecx+eax*8-4]
	sar	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 770  : 	}

	jmp	SHORT $LN2@S_Interpol
$LN3@S_Interpol:

; 771  : 
; 772  : 	// save last value to be played out in buffer
; 773  : 	*pfiltermem = pbuffer[upCount - 1]; 

	mov	eax, DWORD PTR _upCount$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8-8]
	mov	eax, DWORD PTR [ecx+eax*8-4]
	mov	ecx, DWORD PTR _pfiltermem$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 774  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Interpolate2xLinear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Interpolate2xCubic
_TEXT	SEGMENT
tv197 = -124						; size = 4
tv189 = -124						; size = 4
tv71 = -124						; size = 4
_outpos$ = -56						; size = 4
_psamp3$ = -52						; size = 4
_psamp2$ = -48						; size = 4
_psamp1$ = -44						; size = 4
_psamp0$ = -40						; size = 4
_x2$ = -36						; size = 4
_x1$ = -32						; size = 4
_x0$ = -28						; size = 4
_xm1$ = -24						; size = 4
_c$ = -20						; size = 4
_b$ = -16						; size = 4
_a$ = -12						; size = 4
_upCount$ = -8						; size = 4
_i$ = -4						; size = 4
_pbuffer$ = 8						; size = 4
_pfiltermem$ = 12					; size = 4
_cfltmem$ = 16						; size = 4
_count$ = 20						; size = 4
_S_Interpolate2xCubic PROC				; COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi

; 663  : 
; 664  : // implement cubic interpolation on 2x upsampled buffer.   Effectively delays buffer contents by 2 samples.
; 665  : // pbuffer: contains samples at 0, 2, 4, 6...
; 666  : // temppaintbuffer is temp buffer, same size as paintbuffer, used to store processed values
; 667  : // count: number of samples to process in buffer ie: how many samples at 0, 2, 4, 6...
; 668  : 
; 669  : // finpos is the fractional, inpos the integer part.
; 670  : //		finpos = 0.5 for upsampling by 2x
; 671  : //		inpos is the position of the sample
; 672  : 
; 673  : //		xm1 = x [inpos - 1];
; 674  : //		x0 = x [inpos + 0];
; 675  : //		x1 = x [inpos + 1];
; 676  : //		x2 = x [inpos + 2];
; 677  : //		a = (3 * (x0-x1) - xm1 + x2) / 2;
; 678  : //		b = 2*x1 + xm1 - (5*x0 + x2) / 2;
; 679  : //		c = (x1 - xm1) / 2;
; 680  : //		y [outpos] = (((a * finpos) + b) * finpos + c) * finpos + x0;
; 681  : 
; 682  : 	int i, upCount = count << 1;

	mov	eax, DWORD PTR _count$[ebp]
	shl	eax, 1
	mov	DWORD PTR _upCount$[ebp], eax

; 683  : 	int a, b, c;
; 684  : 	int xm1, x0, x1, x2;
; 685  : 	portable_samplepair_t *psamp0;
; 686  : 	portable_samplepair_t *psamp1;
; 687  : 	portable_samplepair_t *psamp2;
; 688  : 	portable_samplepair_t *psamp3;
; 689  : 	int outpos = 0;

	mov	DWORD PTR _outpos$[ebp], 0

; 690  : 
; 691  : 	Assert( upCount <= PAINTBUFFER_SIZE );

	cmp	DWORD PTR _upCount$[ebp], 1024		; 00000400H
	jg	SHORT $LN9@S_Interpol
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN10@S_Interpol
$LN9@S_Interpol:
	mov	DWORD PTR tv71[ebp], 0
$LN10@S_Interpol:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Interpolate2xCubic@@9@9
	add	eax, 29					; 0000001dH
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BM@NHAOPJMJ@upCount?5?$DM?$DN?5PAINTBUFFER_SIZE@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 692  : 
; 693  : 	// pfiltermem holds 6 samples from previous buffer pass
; 694  : 	// process 'count' samples
; 695  : 	for( i = 0; i < count; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Interpol
$LN2@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@S_Interpol

; 696  : 	{
; 697  : 		// get source sample pointer
; 698  : 		psamp0 = S_GetNextpFilter( i-1, pbuffer, pfiltermem );

	mov	eax, DWORD PTR _pfiltermem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	push	edx
	call	_S_GetNextpFilter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psamp0$[ebp], eax

; 699  : 		psamp1 = S_GetNextpFilter( i+0, pbuffer, pfiltermem );

	mov	eax, DWORD PTR _pfiltermem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	_S_GetNextpFilter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psamp1$[ebp], eax

; 700  : 		psamp2 = S_GetNextpFilter( i+1, pbuffer, pfiltermem );

	mov	eax, DWORD PTR _pfiltermem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	call	_S_GetNextpFilter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psamp2$[ebp], eax

; 701  : 		psamp3 = S_GetNextpFilter( i+2, pbuffer, pfiltermem );

	mov	eax, DWORD PTR _pfiltermem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 2
	push	edx
	call	_S_GetNextpFilter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psamp3$[ebp], eax

; 702  : 
; 703  : 		// write out original sample to interpolation buffer
; 704  : 		temppaintbuffer[outpos++] = *psamp1;

	mov	eax, DWORD PTR _psamp1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _outpos$[ebp]
	mov	DWORD PTR _temppaintbuffer[eax*8], ecx
	mov	DWORD PTR _temppaintbuffer[eax*8+4], edx
	mov	ecx, DWORD PTR _outpos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outpos$[ebp], ecx

; 705  : 
; 706  : 		// get all left samples for interpolation window
; 707  : 		xm1 = psamp0->left;

	mov	eax, DWORD PTR _psamp0$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _xm1$[ebp], ecx

; 708  : 		x0 = psamp1->left;

	mov	eax, DWORD PTR _psamp1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x0$[ebp], ecx

; 709  : 		x1 = psamp2->left;

	mov	eax, DWORD PTR _psamp2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x1$[ebp], ecx

; 710  : 		x2 = psamp3->left;

	mov	eax, DWORD PTR _psamp3$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x2$[ebp], ecx

; 711  : 		
; 712  : 		// interpolate
; 713  : 		a = (3 * (x0-x1) - xm1 + x2) / 2;

	mov	eax, DWORD PTR _x0$[ebp]
	sub	eax, DWORD PTR _x1$[ebp]
	imul	eax, eax, 3
	sub	eax, DWORD PTR _xm1$[ebp]
	add	eax, DWORD PTR _x2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _a$[ebp], eax

; 714  : 		b = 2*x1 + xm1 - (5*x0 + x2) / 2;

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _xm1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*2]
	imul	eax, DWORD PTR _x0$[ebp], 5
	add	eax, DWORD PTR _x2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _b$[ebp], ecx

; 715  : 		c = (x1 - xm1) / 2;

	mov	eax, DWORD PTR _x1$[ebp]
	sub	eax, DWORD PTR _xm1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _c$[ebp], eax

; 716  : 		
; 717  : 		// write out interpolated sample
; 718  : 		temppaintbuffer[outpos].left = a/8 + b/4 + c/2 + x0;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 3
	mov	eax, DWORD PTR _b$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	ecx, eax
	mov	eax, DWORD PTR _c$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, DWORD PTR _x0$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _outpos$[ebp]
	mov	DWORD PTR _temppaintbuffer[edx*8], eax

; 719  : 		
; 720  : 		// get all right samples for window
; 721  : 		xm1 = psamp0->right;

	mov	eax, DWORD PTR _psamp0$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _xm1$[ebp], ecx

; 722  : 		x0 = psamp1->right;

	mov	eax, DWORD PTR _psamp1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _x0$[ebp], ecx

; 723  : 		x1 = psamp2->right;

	mov	eax, DWORD PTR _psamp2$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _x1$[ebp], ecx

; 724  : 		x2 = psamp3->right;

	mov	eax, DWORD PTR _psamp3$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _x2$[ebp], ecx

; 725  : 		
; 726  : 		// interpolate
; 727  : 		a = (3 * (x0-x1) - xm1 + x2) / 2;

	mov	eax, DWORD PTR _x0$[ebp]
	sub	eax, DWORD PTR _x1$[ebp]
	imul	eax, eax, 3
	sub	eax, DWORD PTR _xm1$[ebp]
	add	eax, DWORD PTR _x2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _a$[ebp], eax

; 728  : 		b = 2*x1 + xm1 - (5*x0 + x2) / 2;

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _xm1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*2]
	imul	eax, DWORD PTR _x0$[ebp], 5
	add	eax, DWORD PTR _x2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _b$[ebp], ecx

; 729  : 		c = (x1 - xm1) / 2;

	mov	eax, DWORD PTR _x1$[ebp]
	sub	eax, DWORD PTR _xm1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _c$[ebp], eax

; 730  : 		
; 731  : 		// write out interpolated sample, increment output counter
; 732  : 		temppaintbuffer[outpos++].right = a/8 + b/4 + c/2 + x0;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	mov	ecx, eax
	sar	ecx, 3
	mov	eax, DWORD PTR _b$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	ecx, eax
	mov	eax, DWORD PTR _c$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, DWORD PTR _x0$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _outpos$[ebp]
	mov	DWORD PTR _temppaintbuffer[edx*8+4], eax
	mov	eax, DWORD PTR _outpos$[ebp]
	add	eax, 1
	mov	DWORD PTR _outpos$[ebp], eax

; 733  : 		
; 734  : 		Assert( outpos <= ( sizeof( temppaintbuffer ) / sizeof( temppaintbuffer[0] )));

	cmp	DWORD PTR _outpos$[ebp], 1025		; 00000401H
	ja	SHORT $LN11@S_Interpol
	mov	DWORD PTR tv189[ebp], 1
	jmp	SHORT $LN12@S_Interpol
$LN11@S_Interpol:
	mov	DWORD PTR tv189[ebp], 0
$LN12@S_Interpol:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Interpolate2xCubic@@9@9
	add	eax, 72					; 00000048H
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0EG@FDMFCNOI@outpos?5?$DM?$DN?5?$CI?5sizeof?$CI?5temppaintbu@
	mov	ecx, DWORD PTR tv189[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 735  : 	}

	jmp	$LN2@S_Interpol
$LN3@S_Interpol:

; 736  : 	
; 737  : 	Assert( cfltmem >= 3 );

	cmp	DWORD PTR _cfltmem$[ebp], 3
	jl	SHORT $LN13@S_Interpol
	mov	DWORD PTR tv197[ebp], 1
	jmp	SHORT $LN14@S_Interpol
$LN13@S_Interpol:
	mov	DWORD PTR tv197[ebp], 0
$LN14@S_Interpol:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Interpolate2xCubic@@9@9
	add	eax, 75					; 0000004bH
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@CJCNACGM@cfltmem?5?$DO?$DN?53@
	mov	ecx, DWORD PTR tv197[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 738  : 
; 739  : 	// save last 3 samples from paintbuffer
; 740  : 	pfiltermem[0] = pbuffer[upCount - 5];

	mov	eax, DWORD PTR _upCount$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8-40]
	mov	eax, DWORD PTR [ecx+eax*8-36]
	mov	ecx, 8
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pfiltermem$[ebp]
	mov	DWORD PTR [esi+ecx], edx
	mov	DWORD PTR [esi+ecx+4], eax

; 741  : 	pfiltermem[1] = pbuffer[upCount - 3];

	mov	eax, DWORD PTR _upCount$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8-24]
	mov	eax, DWORD PTR [ecx+eax*8-20]
	mov	ecx, 8
	shl	ecx, 0
	mov	esi, DWORD PTR _pfiltermem$[ebp]
	mov	DWORD PTR [esi+ecx], edx
	mov	DWORD PTR [esi+ecx+4], eax

; 742  : 	pfiltermem[2] = pbuffer[upCount - 1];

	mov	eax, DWORD PTR _upCount$[ebp]
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8-8]
	mov	eax, DWORD PTR [ecx+eax*8-4]
	mov	ecx, 8
	shl	ecx, 1
	mov	esi, DWORD PTR _pfiltermem$[ebp]
	mov	DWORD PTR [esi+ecx], edx
	mov	DWORD PTR [esi+ecx+4], eax

; 743  : 
; 744  : 	// copy temppaintbuffer back into paintbuffer
; 745  : 	for( i = 0; i < upCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@S_Interpol
$LN5@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@S_Interpol:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _upCount$[ebp]
	jge	SHORT $LN1@S_Interpol

; 746  : 		pbuffer[i] = temppaintbuffer[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _temppaintbuffer[eax*8]
	mov	edx, DWORD PTR _temppaintbuffer[eax*8+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pbuffer$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	jmp	SHORT $LN5@S_Interpol
$LN1@S_Interpol:

; 747  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Interpolate2xCubic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_GetNextpFilter
_TEXT	SEGMENT
_i$ = 8							; size = 4
_pbuffer$ = 12						; size = 4
_pfiltermem$ = 16					; size = 4
_S_GetNextpFilter PROC					; COMDAT

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 645  : 	// The delay buffer is assumed to precede the paintbuffer by 6 duplicated samples
; 646  : 	if( i == -1 ) return (&(pfiltermem[0]));

	cmp	DWORD PTR _i$[ebp], -1
	jne	SHORT $LN2@S_GetNextp
	mov	eax, 8
	imul	eax, eax, 0
	add	eax, DWORD PTR _pfiltermem$[ebp]
	jmp	SHORT $LN1@S_GetNextp
$LN2@S_GetNextp:

; 647  : 	if( i == 0 ) return (&(pfiltermem[1]));

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN3@S_GetNextp
	mov	eax, 8
	shl	eax, 0
	add	eax, DWORD PTR _pfiltermem$[ebp]
	jmp	SHORT $LN1@S_GetNextp
$LN3@S_GetNextp:

; 648  : 	if( i == 1 ) return (&(pfiltermem[2]));

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN4@S_GetNextp
	mov	eax, 8
	shl	eax, 1
	add	eax, DWORD PTR _pfiltermem$[ebp]
	jmp	SHORT $LN1@S_GetNextp
$LN4@S_GetNextp:

; 649  : 
; 650  : 	// return from paintbuffer, where samples are doubled.  
; 651  : 	// even samples are to be replaced with interpolated value.
; 652  : 	return (&(pbuffer[(i-2) * 2 + 1]));

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax-4]
	mov	edx, DWORD PTR _pbuffer$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+8]
$LN1@S_GetNextp:

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetNextpFilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_MixChannelsToPaintbuffer
_TEXT	SEGMENT
tv157 = -88						; size = 4
tv144 = -88						; size = 4
tv81 = -88						; size = 4
tv70 = -88						; size = 4
_bZeroVolume$ = -20					; size = 4
_sampleCount$ = -16					; size = 4
_i$ = -12						; size = 4
_pSource$ = -8						; size = 4
_ch$ = -4						; size = 4
_endtime$ = 8						; size = 4
_rate$ = 12						; size = 4
_outputRate$ = 16					; size = 4
_MIX_MixChannelsToPaintbuffer PROC			; COMDAT

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 535  : 	channel_t *ch;
; 536  : 	wavdata_t	*pSource;
; 537  : 	int	i, sampleCount;
; 538  : 	qboolean	bZeroVolume;
; 539  : 
; 540  : 	// mix each channel into paintbuffer
; 541  : 	ch = channels;

	mov	DWORD PTR _ch$[ebp], OFFSET _channels

; 542  : 	
; 543  : 	// validate parameters
; 544  : 	Assert( outputRate <= SOUND_DMA_SPEED );

	cmp	DWORD PTR _outputRate$[ebp], 44100	; 0000ac44H
	jg	SHORT $LN39@MIX_MixCha
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN40@MIX_MixCha
$LN39@MIX_MixCha:
	mov	DWORD PTR tv70[ebp], 0
$LN40@MIX_MixCha:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_MixChannelsToPaintbuffer@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BO@IKNMDPG@outputRate?5?$DM?$DN?5SOUND_DMA_SPEED@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 545  : 
; 546  : 	// make sure we're not discarding data
; 547  : 	Assert( !(( endtime - paintedtime ) & 0x3 ) || ( outputRate == SOUND_DMA_SPEED ));

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _paintedtime
	and	eax, 3
	je	SHORT $LN41@MIX_MixCha
	cmp	DWORD PTR _outputRate$[ebp], 44100	; 0000ac44H
	je	SHORT $LN41@MIX_MixCha
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN42@MIX_MixCha
$LN41@MIX_MixCha:
	mov	DWORD PTR tv81[ebp], 1
$LN42@MIX_MixCha:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??MIX_MixChannelsToPaintbuffer@@9@9
	add	ecx, 13					; 0000000dH
	push	ecx
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0EJ@FJHFLJPJ@?$CB?$CI?$CI?5endtime?5?9?5paintedtime?5?$CJ?5?$CG?50@
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 548  : 											  
; 549  : 	// 44k: try to mix this many samples at outputRate
; 550  : 	sampleCount = ( endtime - paintedtime ) / ( SOUND_DMA_SPEED / outputRate );

	mov	ecx, DWORD PTR _endtime$[ebp]
	sub	ecx, DWORD PTR _paintedtime
	mov	eax, 44100				; 0000ac44H
	cdq
	idiv	DWORD PTR _outputRate$[ebp]
	mov	esi, eax
	mov	eax, ecx
	cdq
	idiv	esi
	mov	DWORD PTR _sampleCount$[ebp], eax

; 551  : 	
; 552  : 	if( sampleCount <= 0 ) return;

	cmp	DWORD PTR _sampleCount$[ebp], 0
	jg	SHORT $LN7@MIX_MixCha
	jmp	$LN3@MIX_MixCha
$LN7@MIX_MixCha:

; 553  : 
; 554  : 	for( i = 0; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_MixCha
$LN2@MIX_MixCha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN4@MIX_MixCha:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	$LN3@MIX_MixCha

; 555  : 	{
; 556  : 		if( !ch->sfx ) continue;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN8@MIX_MixCha
	jmp	SHORT $LN2@MIX_MixCha
$LN8@MIX_MixCha:

; 557  : 
; 558  : 		// NOTE: background map is allow both type sounds: menu and game
; 559  : 		if( !cl.background )

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN9@MIX_MixCha

; 560  : 		{
; 561  : 			if( cls.key_dest == key_console && ch->localsound )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN11@MIX_MixCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $LN11@MIX_MixCha

; 562  : 			{
; 563  : 				// play, playvol
; 564  : 			}

	jmp	SHORT $LN16@MIX_MixCha
$LN11@MIX_MixCha:

; 565  : 			else if(( s_listener.inmenu || s_listener.paused ) && !ch->localsound )

	cmp	DWORD PTR _s_listener+76, 0
	jne	SHORT $LN15@MIX_MixCha
	cmp	DWORD PTR _s_listener+80, 0
	je	SHORT $LN13@MIX_MixCha
$LN15@MIX_MixCha:
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN13@MIX_MixCha

; 566  : 			{
; 567  : 				// play only local sounds, keep pause for other
; 568  : 				continue;

	jmp	SHORT $LN2@MIX_MixCha

; 569  : 			}

	jmp	SHORT $LN16@MIX_MixCha
$LN13@MIX_MixCha:

; 570  : 			else if( !s_listener.inmenu && !s_listener.active && !ch->staticsound )

	cmp	DWORD PTR _s_listener+76, 0
	jne	SHORT $LN16@MIX_MixCha
	cmp	DWORD PTR _s_listener+72, 0
	jne	SHORT $LN16@MIX_MixCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN16@MIX_MixCha

; 571  : 			{
; 572  : 				// play only ambient sounds, keep pause for other
; 573  : 				continue;

	jmp	$LN2@MIX_MixCha
$LN16@MIX_MixCha:

; 574  : 			}
; 575  : 		}

	jmp	SHORT $LN17@MIX_MixCha
$LN9@MIX_MixCha:

; 576  : 		else if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN17@MIX_MixCha

; 577  : 			continue;	// silent mode in console

	jmp	$LN2@MIX_MixCha
$LN17@MIX_MixCha:

; 578  : 
; 579  : 		pSource = S_LoadSound( ch->sfx );

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 580  : 
; 581  : 		// Don't mix sound data for sounds with zero volume. If it's a non-looping sound, 
; 582  : 		// just remove the sound when its volume goes to zero.
; 583  : 		bZeroVolume = !ch->leftvol && !ch->rightvol;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN43@MIX_MixCha
	mov	ecx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN43@MIX_MixCha
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN44@MIX_MixCha
$LN43@MIX_MixCha:
	mov	DWORD PTR tv144[ebp], 0
$LN44@MIX_MixCha:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _bZeroVolume$[ebp], edx

; 584  :  
; 585  : 		if( !bZeroVolume )

	cmp	DWORD PTR _bZeroVolume$[ebp], 0
	jne	SHORT $LN19@MIX_MixCha

; 586  : 		{
; 587  : 			// this values matched with GoldSrc
; 588  : 			if( ch->leftvol < 8 && ch->rightvol < 8 )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 8
	jge	SHORT $LN19@MIX_MixCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+24], 8
	jge	SHORT $LN19@MIX_MixCha

; 589  : 				bZeroVolume = true;

	mov	DWORD PTR _bZeroVolume$[ebp], 1
$LN19@MIX_MixCha:

; 590  : 		}
; 591  : 
; 592  : 		if( !pSource || ( bZeroVolume && pSource->loopStart == -1 ))

	cmp	DWORD PTR _pSource$[ebp], 0
	je	SHORT $LN22@MIX_MixCha
	cmp	DWORD PTR _bZeroVolume$[ebp], 0
	je	SHORT $LN20@MIX_MixCha
	mov	eax, DWORD PTR _pSource$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $LN20@MIX_MixCha
$LN22@MIX_MixCha:

; 593  : 		{
; 594  : 			if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN23@MIX_MixCha

; 595  : 			{
; 596  : 				S_FreeChannel( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 597  : 				continue;

	jmp	$LN2@MIX_MixCha
$LN23@MIX_MixCha:

; 598  : 			}
; 599  : 		}

	jmp	SHORT $LN24@MIX_MixCha
$LN20@MIX_MixCha:

; 600  : 		else if( bZeroVolume )

	cmp	DWORD PTR _bZeroVolume$[ebp], 0
	je	SHORT $LN24@MIX_MixCha

; 601  : 		{
; 602  : 			continue;

	jmp	$LN2@MIX_MixCha
$LN24@MIX_MixCha:

; 603  : 		}
; 604  : 
; 605  : 		// multipass mixing - only mix samples of specified sample rate
; 606  : 		switch( rate )

	mov	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	cmp	DWORD PTR tv157[ebp], 11025		; 00002b11H
	je	SHORT $LN25@MIX_MixCha
	cmp	DWORD PTR tv157[ebp], 22050		; 00005622H
	je	SHORT $LN25@MIX_MixCha
	cmp	DWORD PTR tv157[ebp], 44100		; 0000ac44H
	je	SHORT $LN25@MIX_MixCha
	jmp	SHORT $LN29@MIX_MixCha
$LN25@MIX_MixCha:

; 607  : 		{
; 608  : 		case SOUND_11k:
; 609  : 		case SOUND_22k:
; 610  : 		case SOUND_44k:
; 611  : 			if( rate != pSource->rate )

	mov	eax, DWORD PTR _pSource$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _rate$[ebp], ecx
	je	SHORT $LN28@MIX_MixCha

; 612  : 				continue;

	jmp	$LN2@MIX_MixCha
$LN28@MIX_MixCha:
$LN29@MIX_MixCha:

; 613  : 			break;
; 614  : 		default:	break;
; 615  : 		}
; 616  : 
; 617  : 		// get playback pitch
; 618  : 		if( ch->isSentence )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN30@MIX_MixCha

; 619  : 			ch->pitch = VOX_ModifyPitch( ch, ch->basePitch * 0.01f );

	mov	eax, DWORD PTR _ch$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_VOX_ModifyPitch
	add	esp, 8
	mov	edx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [edx+64]
	jmp	SHORT $LN31@MIX_MixCha
$LN30@MIX_MixCha:

; 620  : 		else ch->pitch = ch->basePitch * 0.01f;

	mov	eax, DWORD PTR _ch$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+60]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+64], xmm0
$LN31@MIX_MixCha:

; 621  : 
; 622  : 		if( CL_GetEntityByIndex( ch->entnum ) && ( ch->entchannel == CHAN_VOICE ))

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN34@MIX_MixCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+32], 2
	jne	SHORT $LN34@MIX_MixCha

; 623  : 		{
; 624  : 			if( pSource->width == 1 )

	mov	eax, DWORD PTR _pSource$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 1
	jne	SHORT $LN33@MIX_MixCha

; 625  : 				SND_MoveMouth8( ch, pSource, sampleCount );

	mov	eax, DWORD PTR _sampleCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_MoveMouth8
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN34@MIX_MixCha
$LN33@MIX_MixCha:

; 626  : 			else SND_MoveMouth16( ch, pSource, sampleCount );

	mov	eax, DWORD PTR _sampleCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_MoveMouth16
	add	esp, 12					; 0000000cH
$LN34@MIX_MixCha:

; 627  : 		}
; 628  : 
; 629  : 		// mix channel to all active paintbuffers.
; 630  : 		// NOTE: must be called once per channel only - consecutive calls retrieve additional data.
; 631  : 		if( ch->isSentence )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN35@MIX_MixCha

; 632  : 			VOX_MixDataToDevice( ch, sampleCount, outputRate, 0 );

	push	0
	mov	eax, DWORD PTR _outputRate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sampleCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_VOX_MixDataToDevice
	add	esp, 16					; 00000010H
	jmp	SHORT $LN36@MIX_MixCha
$LN35@MIX_MixCha:

; 633  : 		else S_MixDataToDevice( ch, sampleCount, outputRate, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _outputRate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sampleCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_S_MixDataToDevice
	add	esp, 20					; 00000014H
$LN36@MIX_MixCha:

; 634  : 
; 635  : 		if( !S_ShouldContinueMixing( ch ))

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_ShouldContinueMixing
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN37@MIX_MixCha

; 636  : 		{
; 637  : 			S_FreeChannel( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4
$LN37@MIX_MixCha:

; 638  : 		}
; 639  : 	}

	jmp	$LN2@MIX_MixCha
$LN3@MIX_MixCha:

; 640  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_MixChannelsToPaintbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_ShouldContinueMixing
_TEXT	SEGMENT
tv70 = -68						; size = 4
_ch$ = 8						; size = 4
_S_ShouldContinueMixing PROC				; COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 514  : 	if( ch->isSentence )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN2@S_ShouldCo

; 515  : 	{
; 516  : 		if( ch->currentWord )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN3@S_ShouldCo

; 517  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@S_ShouldCo
$LN3@S_ShouldCo:

; 518  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@S_ShouldCo
$LN2@S_ShouldCo:

; 519  : 	}
; 520  : 
; 521  : 	return !ch->pMixer.finished;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jne	SHORT $LN5@S_ShouldCo
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN6@S_ShouldCo
$LN5@S_ShouldCo:
	mov	DWORD PTR tv70[ebp], 0
$LN6@S_ShouldCo:
	mov	eax, DWORD PTR tv70[ebp]
$LN1@S_ShouldCo:

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_ShouldContinueMixing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_MixChannel
_TEXT	SEGMENT
tv92 = -92						; size = 4
tv83 = -92						; size = 4
tv91 = -88						; size = 4
tv82 = -88						; size = 4
tv73 = -88						; size = 4
_pbuf$ = -20						; size = 4
_pSource$ = -16						; size = 4
_ppaint$ = -12						; size = 4
_pvol$ = -8						; size = 8
_pChannel$ = 8						; size = 4
_pData$ = 12						; size = 4
_outputOffset$ = 16					; size = 4
_inputOffset$ = 20					; size = 4
_fracRate$ = 24						; size = 4
_outCount$ = 28						; size = 4
_timecompress$ = 32					; size = 4
_S_MixChannel PROC					; COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 397  : 	int			pvol[CCHANVOLUMES];
; 398  : 	paintbuffer_t		*ppaint = MIX_GetCurrentPaintbufferPtr();

	call	_MIX_GetCurrentPaintbufferPtr
	mov	DWORD PTR _ppaint$[ebp], eax

; 399  : 	wavdata_t			*pSource = pChannel->sfx->cache;

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$[ebp], edx

; 400  : 	portable_samplepair_t	*pbuf;
; 401  : 
; 402  : 	Assert( pSource != NULL );

	cmp	DWORD PTR _pSource$[ebp], 0
	je	SHORT $LN9@S_MixChann
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN10@S_MixChann
$LN9@S_MixChann:
	mov	DWORD PTR tv73[ebp], 0
$LN10@S_MixChann:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_MixChannel@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BA@FPLEBBAM@pSource?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv73[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 403  : 
; 404  : 	pvol[0] = bound( 0, pChannel->leftvol, 255 );

	mov	eax, DWORD PTR _pChannel$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jl	SHORT $LN13@S_MixChann
	mov	ecx, DWORD PTR _pChannel$[ebp]
	cmp	DWORD PTR [ecx+20], 255			; 000000ffH
	jge	SHORT $LN11@S_MixChann
	mov	edx, DWORD PTR _pChannel$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN12@S_MixChann
$LN11@S_MixChann:
	mov	DWORD PTR tv82[ebp], 255		; 000000ffH
$LN12@S_MixChann:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN14@S_MixChann
$LN13@S_MixChann:
	mov	DWORD PTR tv83[ebp], 0
$LN14@S_MixChann:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _pvol$[ebp+eax], ecx

; 405  : 	pvol[1] = bound( 0, pChannel->rightvol, 255 );

	mov	eax, DWORD PTR _pChannel$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jl	SHORT $LN17@S_MixChann
	mov	ecx, DWORD PTR _pChannel$[ebp]
	cmp	DWORD PTR [ecx+24], 255			; 000000ffH
	jge	SHORT $LN15@S_MixChann
	mov	edx, DWORD PTR _pChannel$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN16@S_MixChann
$LN15@S_MixChann:
	mov	DWORD PTR tv91[ebp], 255		; 000000ffH
$LN16@S_MixChann:
	mov	ecx, DWORD PTR tv91[ebp]
	mov	DWORD PTR tv92[ebp], ecx
	jmp	SHORT $LN18@S_MixChann
$LN17@S_MixChann:
	mov	DWORD PTR tv92[ebp], 0
$LN18@S_MixChann:
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR _pvol$[ebp+edx], eax

; 406  : 	pbuf = ppaint->pbuf + outputOffset;

	mov	eax, DWORD PTR _ppaint$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _outputOffset$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _pbuf$[ebp], eax

; 407  : 
; 408  : 	if( pSource->channels == 1 )

	mov	eax, DWORD PTR _pSource$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 1
	jne	SHORT $LN2@S_MixChann

; 409  : 	{
; 410  : 		if( pSource->width == 1 )

	mov	eax, DWORD PTR _pSource$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 1
	jne	SHORT $LN4@S_MixChann

; 411  : 			S_Mix8Mono( pbuf, pvol, (char *)pData, inputOffset, fracRate, outCount, timecompress );

	mov	eax, DWORD PTR _timecompress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fracRate$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvol$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_Mix8Mono
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN5@S_MixChann
$LN4@S_MixChann:

; 412  : 		else S_Mix16Mono( pbuf, pvol, (short *)pData, inputOffset, fracRate, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fracRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_S_Mix16Mono
	add	esp, 24					; 00000018H
$LN5@S_MixChann:

; 413  : 	}

	jmp	SHORT $LN1@S_MixChann
$LN2@S_MixChann:

; 414  : 	else
; 415  : 	{
; 416  : 		if( pSource->width == 1 )

	mov	eax, DWORD PTR _pSource$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 1
	jne	SHORT $LN6@S_MixChann

; 417  : 			S_Mix8Stereo( pbuf, pvol, (char *)pData, inputOffset, fracRate, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fracRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_S_Mix8Stereo
	add	esp, 24					; 00000018H
	jmp	SHORT $LN1@S_MixChann
$LN6@S_MixChann:

; 418  : 		else S_Mix16Stereo( pbuf, pvol, (short *)pData, inputOffset, fracRate, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fracRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvol$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	_S_Mix16Stereo
	add	esp, 24					; 00000018H
$LN1@S_MixChann:

; 419  : 	}
; 420  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_MixChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Mix16Stereo
_TEXT	SEGMENT
_sampleFrac$ = -12					; size = 4
_sampleIndex$ = -8					; size = 4
_i$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_inputOffset$ = 20					; size = 4
_rateScale$ = 24					; size = 4
_outCount$ = 28						; size = 4
_S_Mix16Stereo PROC					; COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 375  : 	int	i, sampleIndex = 0;

	mov	DWORD PTR _sampleIndex$[ebp], 0

; 376  : 	uint	sampleFrac = inputOffset;

	mov	eax, DWORD PTR _inputOffset$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 377  : 
; 378  : 	// Not using pitch shift?
; 379  : 	if( rateScale == FIX( 1 ))

	cmp	DWORD PTR _rateScale$[ebp], 268435456	; 10000000H
	jne	SHORT $LN5@S_Mix16Ste

; 380  : 	{
; 381  : 		S_PaintStereoFrom16( pbuf, volume, pData, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_PaintStereoFrom16
	add	esp, 16					; 00000010H

; 382  : 		return;

	jmp	$LN1@S_Mix16Ste
$LN5@S_Mix16Ste:

; 383  : 	}
; 384  : 
; 385  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Mix16Ste
$LN2@S_Mix16Ste:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Mix16Ste:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	$LN1@S_Mix16Ste

; 386  : 	{
; 387  : 		pbuf[i].left += (volume[0] * (int)( pData[sampleIndex+0] ))>>8;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sampleIndex$[ebp]
	mov	eax, DWORD PTR _pData$[ebp]
	movsx	edx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _volume$[ebp]
	imul	edx, DWORD PTR [eax+ecx]
	sar	edx, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	add	edx, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 388  : 		pbuf[i].right += (volume[1] * (int)( pData[sampleIndex+1] ))>>8;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _sampleIndex$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [edx+ecx*2+2]
	mov	edx, DWORD PTR _volume$[ebp]
	imul	ecx, DWORD PTR [edx+eax]
	sar	ecx, 8
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbuf$[ebp]
	add	ecx, DWORD PTR [edx+eax*8+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx

; 389  : 		sampleFrac += rateScale;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	add	eax, DWORD PTR _rateScale$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 390  : 		sampleIndex += FIX_INTPART(sampleFrac)<<1;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	sar	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _sampleIndex$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _sampleIndex$[ebp], edx

; 391  : 		sampleFrac = FIX_FRACPART(sampleFrac);

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 392  : 	}

	jmp	$LN2@S_Mix16Ste
$LN1@S_Mix16Ste:

; 393  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Mix16Stereo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Mix16Mono
_TEXT	SEGMENT
_sampleFrac$ = -12					; size = 4
_sampleIndex$ = -8					; size = 4
_i$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_inputOffset$ = 20					; size = 4
_rateScale$ = 24					; size = 4
_outCount$ = 28						; size = 4
_S_Mix16Mono PROC					; COMDAT

; 352  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 353  : 	int	i, sampleIndex = 0;

	mov	DWORD PTR _sampleIndex$[ebp], 0

; 354  : 	uint	sampleFrac = inputOffset;

	mov	eax, DWORD PTR _inputOffset$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 355  : 
; 356  : 	// Not using pitch shift?
; 357  : 	if( rateScale == FIX( 1 ))

	cmp	DWORD PTR _rateScale$[ebp], 268435456	; 10000000H
	jne	SHORT $LN5@S_Mix16Mon

; 358  : 	{
; 359  : 		S_PaintMonoFrom16( pbuf, volume, pData, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_PaintMonoFrom16
	add	esp, 16					; 00000010H

; 360  : 		return;

	jmp	$LN1@S_Mix16Mon
$LN5@S_Mix16Mon:

; 361  : 	}
; 362  : 
; 363  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Mix16Mon
$LN2@S_Mix16Mon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Mix16Mon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	$LN1@S_Mix16Mon

; 364  : 	{
; 365  : 		pbuf[i].left += (volume[0] * (int)( pData[sampleIndex] ))>>8;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sampleIndex$[ebp]
	mov	eax, DWORD PTR _pData$[ebp]
	movsx	edx, WORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _volume$[ebp]
	imul	edx, DWORD PTR [eax+ecx]
	sar	edx, 8
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	add	edx, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 366  : 		pbuf[i].right += (volume[1] * (int)( pData[sampleIndex] ))>>8;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _sampleIndex$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	movsx	ecx, WORD PTR [edx+ecx*2]
	mov	edx, DWORD PTR _volume$[ebp]
	imul	ecx, DWORD PTR [edx+eax]
	sar	ecx, 8
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbuf$[ebp]
	add	ecx, DWORD PTR [edx+eax*8+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx

; 367  : 		sampleFrac += rateScale;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	add	eax, DWORD PTR _rateScale$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 368  : 		sampleIndex += FIX_INTPART( sampleFrac );

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	sar	eax, 28					; 0000001cH
	add	eax, DWORD PTR _sampleIndex$[ebp]
	mov	DWORD PTR _sampleIndex$[ebp], eax

; 369  : 		sampleFrac = FIX_FRACPART( sampleFrac );

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 370  : 	}

	jmp	$LN2@S_Mix16Mon
$LN1@S_Mix16Mon:

; 371  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Mix16Mono ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Mix8Stereo
_TEXT	SEGMENT
_rscale$ = -20						; size = 4
_lscale$ = -16						; size = 4
_sampleFrac$ = -12					; size = 4
_sampleIndex$ = -8					; size = 4
_i$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_inputOffset$ = 20					; size = 4
_rateScale$ = 24					; size = 4
_outCount$ = 28						; size = 4
_S_Mix8Stereo PROC					; COMDAT

; 326  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 327  : 	int	i, sampleIndex = 0;

	mov	DWORD PTR _sampleIndex$[ebp], 0

; 328  : 	uint	sampleFrac = inputOffset;

	mov	eax, DWORD PTR _inputOffset$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 329  : 	int	*lscale, *rscale;
; 330  : 
; 331  : 	// Not using pitch shift?
; 332  : 	if( rateScale == FIX( 1 ))

	cmp	DWORD PTR _rateScale$[ebp], 268435456	; 10000000H
	jne	SHORT $LN5@S_Mix8Ster

; 333  : 	{
; 334  : 		S_PaintStereoFrom8( pbuf, volume, pData, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_PaintStereoFrom8
	add	esp, 16					; 00000010H

; 335  : 		return;

	jmp	$LN1@S_Mix8Ster
$LN5@S_Mix8Ster:

; 336  : 	}
; 337  : 
; 338  : 	lscale = snd_scaletable[volume[0] >> SND_SCALE_SHIFT];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sar	eax, 1
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET _snd_scaletable
	mov	DWORD PTR _lscale$[ebp], eax

; 339  : 	rscale = snd_scaletable[volume[1] >> SND_SCALE_SHIFT];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sar	edx, 1
	shl	edx, 10					; 0000000aH
	add	edx, OFFSET _snd_scaletable
	mov	DWORD PTR _rscale$[ebp], edx

; 340  : 
; 341  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Mix8Ster
$LN2@S_Mix8Ster:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Mix8Ster:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	SHORT $LN1@S_Mix8Ster

; 342  : 	{
; 343  : 		pbuf[i].left += lscale[pData[sampleIndex+0]];

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _sampleIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR _lscale$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 344  : 		pbuf[i].right += rscale[pData[sampleIndex+1]];

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _sampleIndex$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR _rscale$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 345  : 		sampleFrac += rateScale;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	add	eax, DWORD PTR _rateScale$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 346  : 		sampleIndex += FIX_INTPART( sampleFrac )<<1;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	sar	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _sampleIndex$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _sampleIndex$[ebp], edx

; 347  : 		sampleFrac = FIX_FRACPART( sampleFrac );

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 348  : 	}

	jmp	SHORT $LN2@S_Mix8Ster
$LN1@S_Mix8Ster:

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Mix8Stereo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Mix8Mono
_TEXT	SEGMENT
_rscale$ = -20						; size = 4
_lscale$ = -16						; size = 4
_sampleFrac$ = -12					; size = 4
_sampleIndex$ = -8					; size = 4
_i$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_inputOffset$ = 20					; size = 4
_rateScale$ = 24					; size = 4
_outCount$ = 28						; size = 4
_timecompress$ = 32					; size = 4
_S_Mix8Mono PROC					; COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 295  : 	int	i, sampleIndex = 0;

	mov	DWORD PTR _sampleIndex$[ebp], 0

; 296  : 	uint	sampleFrac = inputOffset;

	mov	eax, DWORD PTR _inputOffset$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 297  : 	int	*lscale, *rscale;
; 298  : 
; 299  : 	if( timecompress != 0 )

	cmp	DWORD PTR _timecompress$[ebp], 0
	je	SHORT $LN5@S_Mix8Mono

; 300  : 	{
; 301  : 		S_Mix8MonoTimeCompress( pbuf, volume, pData, inputOffset, rateScale, outCount, timecompress );

	mov	eax, DWORD PTR _timecompress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rateScale$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_Mix8MonoTimeCompress
	add	esp, 28					; 0000001cH
$LN5@S_Mix8Mono:

; 302  : //		return;
; 303  : 	}
; 304  : 
; 305  : 	// Not using pitch shift?
; 306  : 	if( rateScale == FIX( 1 ))

	cmp	DWORD PTR _rateScale$[ebp], 268435456	; 10000000H
	jne	SHORT $LN6@S_Mix8Mono

; 307  : 	{
; 308  : 		S_PaintMonoFrom8( pbuf, volume, pData, outCount );

	mov	eax, DWORD PTR _outCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_S_PaintMonoFrom8
	add	esp, 16					; 00000010H

; 309  : 		return;

	jmp	$LN1@S_Mix8Mono
$LN6@S_Mix8Mono:

; 310  : 	}
; 311  : 
; 312  : 	lscale = snd_scaletable[volume[0] >> SND_SCALE_SHIFT];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sar	eax, 1
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET _snd_scaletable
	mov	DWORD PTR _lscale$[ebp], eax

; 313  : 	rscale = snd_scaletable[volume[1] >> SND_SCALE_SHIFT];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sar	edx, 1
	shl	edx, 10					; 0000000aH
	add	edx, OFFSET _snd_scaletable
	mov	DWORD PTR _rscale$[ebp], edx

; 314  : 
; 315  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Mix8Mono
$LN2@S_Mix8Mono:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Mix8Mono:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	SHORT $LN1@S_Mix8Mono

; 316  : 	{
; 317  : 		pbuf[i].left += lscale[pData[sampleIndex]];

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _sampleIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR _lscale$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8], edx

; 318  : 		pbuf[i].right += rscale[pData[sampleIndex]];

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _sampleIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR _rscale$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 319  : 		sampleFrac += rateScale;

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	add	eax, DWORD PTR _rateScale$[ebp]
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 320  : 		sampleIndex += FIX_INTPART( sampleFrac );

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	sar	eax, 28					; 0000001cH
	add	eax, DWORD PTR _sampleIndex$[ebp]
	mov	DWORD PTR _sampleIndex$[ebp], eax

; 321  : 		sampleFrac = FIX_FRACPART( sampleFrac );

	mov	eax, DWORD PTR _sampleFrac$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR _sampleFrac$[ebp], eax

; 322  : 	}

	jmp	SHORT $LN2@S_Mix8Mono
$LN1@S_Mix8Mono:

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Mix8Mono ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_Mix8MonoTimeCompress
_TEXT	SEGMENT
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_inputOffset$ = 20					; size = 4
_rateScale$ = 24					; size = 4
_outCount$ = 28						; size = 4
_timecompress$ = 32					; size = 4
_S_Mix8MonoTimeCompress PROC				; COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 291  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Mix8MonoTimeCompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_PaintStereoFrom16
_TEXT	SEGMENT
_i$ = -16						; size = 4
_right$ = -12						; size = 4
_left$ = -8						; size = 4
_data$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_outCount$ = 20						; size = 4
_S_PaintStereoFrom16 PROC				; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 270  : 	uint	*data;
; 271  : 	int	left, right;
; 272  : 	int	i;
; 273  : 
; 274  : 	data = (uint *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 275  : 		
; 276  : 	for( i = 0; i < outCount; i++, data++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_PaintSte
$LN2@S_PaintSte:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 4
	mov	DWORD PTR _data$[ebp], ecx
$LN4@S_PaintSte:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	$LN1@S_PaintSte

; 277  : 	{
; 278  : 		left = (signed short)((*data & 0x0000FFFF));

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65535				; 0000ffffH
	movsx	edx, cx
	mov	DWORD PTR _left$[ebp], edx

; 279  : 		right = (signed short)((*data & 0xFFFF0000) >> 16);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -65536				; ffff0000H
	shr	ecx, 16					; 00000010H
	movsx	edx, cx
	mov	DWORD PTR _right$[ebp], edx

; 280  : 
; 281  : 		left =  (left * volume[0]) >> 8;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR _left$[ebp]
	imul	eax, DWORD PTR [edx+ecx]
	sar	eax, 8
	mov	DWORD PTR _left$[ebp], eax

; 282  : 		right = (right * volume[1]) >> 8;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR _right$[ebp]
	imul	edx, DWORD PTR [ecx+eax]
	sar	edx, 8
	mov	DWORD PTR _right$[ebp], edx

; 283  : 
; 284  : 		pbuf[i].left += left;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	add	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 285  : 		pbuf[i].right += right;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	add	edx, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 286  : 	}

	jmp	$LN2@S_PaintSte
$LN1@S_PaintSte:

; 287  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PaintStereoFrom16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_PaintMonoFrom16
_TEXT	SEGMENT
_data$ = -16						; size = 4
_i$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_outCount$ = 20						; size = 4
_S_PaintMonoFrom16 PROC					; COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 255  : 	int	left, right;
; 256  : 	int	i, data;
; 257  : 
; 258  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_PaintMon
$LN2@S_PaintMon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_PaintMon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	SHORT $LN1@S_PaintMon

; 259  : 	{
; 260  : 		data = pData[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _data$[ebp], edx

; 261  : 		left = ( data * volume[0]) >> 8;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	imul	eax, DWORD PTR [edx+ecx]
	sar	eax, 8
	mov	DWORD PTR _left$[ebp], eax

; 262  : 		right = (data * volume[1]) >> 8;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR _data$[ebp]
	imul	edx, DWORD PTR [ecx+eax]
	sar	edx, 8
	mov	DWORD PTR _right$[ebp], edx

; 263  : 		pbuf[i].left += left;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	add	edx, DWORD PTR _left$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 264  : 		pbuf[i].right += right;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	add	edx, DWORD PTR _right$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 265  : 	}

	jmp	SHORT $LN2@S_PaintMon
$LN1@S_PaintMon:

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PaintMonoFrom16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_PaintStereoFrom8
_TEXT	SEGMENT
_i$ = -24						; size = 4
_data$ = -20						; size = 4
_right$ = -16						; size = 4
_left$ = -12						; size = 4
_rscale$ = -8						; size = 4
_lscale$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_outCount$ = 20						; size = 4
_S_PaintStereoFrom8 PROC				; COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 235  : 	int	*lscale, *rscale;
; 236  : 	uint	left, right;
; 237  : 	word	*data;
; 238  : 	int	i;
; 239  : 
; 240  : 	lscale = snd_scaletable[volume[0] >> SND_SCALE_SHIFT];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sar	eax, 1
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET _snd_scaletable
	mov	DWORD PTR _lscale$[ebp], eax

; 241  : 	rscale = snd_scaletable[volume[1] >> SND_SCALE_SHIFT];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sar	edx, 1
	shl	edx, 10					; 0000000aH
	add	edx, OFFSET _snd_scaletable
	mov	DWORD PTR _rscale$[ebp], edx

; 242  : 	data = (word *)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 243  : 
; 244  : 	for( i = 0; i < outCount; i++, data++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_PaintSte
$LN2@S_PaintSte:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 2
	mov	DWORD PTR _data$[ebp], ecx
$LN4@S_PaintSte:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	SHORT $LN1@S_PaintSte

; 245  : 	{
; 246  : 		left = (byte)((*data & 0x00FF));

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax]
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	mov	DWORD PTR _left$[ebp], edx

; 247  : 		right = (byte)((*data & 0xFF00) >> 8);

	mov	eax, DWORD PTR _data$[ebp]
	movzx	ecx, WORD PTR [eax]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	movzx	edx, cl
	mov	DWORD PTR _right$[ebp], edx

; 248  : 		pbuf[i].left += lscale[left];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _lscale$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 249  : 		pbuf[i].right += rscale[right];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _rscale$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 250  : 	}

	jmp	SHORT $LN2@S_PaintSte
$LN1@S_PaintSte:

; 251  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PaintStereoFrom8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_PaintMonoFrom8
_TEXT	SEGMENT
_data$ = -16						; size = 4
_i$ = -12						; size = 4
_rscale$ = -8						; size = 4
_lscale$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_volume$ = 12						; size = 4
_pData$ = 16						; size = 4
_outCount$ = 20						; size = 4
_S_PaintMonoFrom8 PROC					; COMDAT

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 219  : 	int	*lscale, *rscale;
; 220  : 	int 	i, data;
; 221  : 		
; 222  : 	lscale = snd_scaletable[volume[0] >> SND_SCALE_SHIFT];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _volume$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sar	eax, 1
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET _snd_scaletable
	mov	DWORD PTR _lscale$[ebp], eax

; 223  : 	rscale = snd_scaletable[volume[1] >> SND_SCALE_SHIFT];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _volume$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sar	edx, 1
	shl	edx, 10					; 0000000aH
	add	edx, OFFSET _snd_scaletable
	mov	DWORD PTR _rscale$[ebp], edx

; 224  : 
; 225  : 	for( i = 0; i < outCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_PaintMon
$LN2@S_PaintMon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_PaintMon:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outCount$[ebp]
	jge	SHORT $LN1@S_PaintMon

; 226  : 	{
; 227  : 		data = pData[i];

	mov	eax, DWORD PTR _pData$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _data$[ebp], ecx

; 228  : 		pbuf[i].left += lscale[data];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _lscale$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 229  : 		pbuf[i].right += rscale[data];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _rscale$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 230  : 	}

	jmp	SHORT $LN2@S_PaintMon
$LN1@S_PaintMon:

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PaintMonoFrom8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_GetPPaintFromIPaint
_TEXT	SEGMENT
tv70 = -68						; size = 4
_ipaint$ = 8						; size = 4
_MIX_GetPPaintFromIPaint PROC				; COMDAT

; 186  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 187  : 	Assert( ipaint < CPAINTBUFFERS );

	cmp	DWORD PTR _ipaint$[ebp], 3
	jge	SHORT $LN3@MIX_GetPPa
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@MIX_GetPPa
$LN3@MIX_GetPPa:
	mov	DWORD PTR tv70[ebp], 0
$LN4@MIX_GetPPa:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_GetPPaintFromIPaint@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BH@MHGFDKMI@ipaint?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 188  : 	return &paintbuffers[ipaint];

	imul	eax, DWORD PTR _ipaint$[ebp], 108
	add	eax, OFFSET _paintbuffers

; 189  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_GetPPaintFromIPaint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_GetPFrontFromIPaint
_TEXT	SEGMENT
tv70 = -68						; size = 4
_ipaintbuffer$ = 8					; size = 4
_MIX_GetPFrontFromIPaint PROC				; COMDAT

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 181  : 	Assert( ipaintbuffer < CPAINTBUFFERS );

	cmp	DWORD PTR _ipaintbuffer$[ebp], 3
	jge	SHORT $LN3@MIX_GetPFr
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@MIX_GetPFr
$LN3@MIX_GetPFr:
	mov	DWORD PTR tv70[ebp], 0
$LN4@MIX_GetPFr:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_GetPFrontFromIPaint@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 182  : 	return paintbuffers[ipaintbuffer].pbuf;

	imul	eax, DWORD PTR _ipaintbuffer$[ebp], 108
	mov	eax, DWORD PTR _paintbuffers[eax+4]

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_GetPFrontFromIPaint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_ResetPaintbufferFilterCounters
_TEXT	SEGMENT
_i$ = -4						; size = 4
_MIX_ResetPaintbufferFilterCounters PROC		; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 166  : 	int	i;
; 167  : 
; 168  : 	for( i = 0; i < CPAINTBUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_ResetP
$LN2@MIX_ResetP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_ResetP:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN1@MIX_ResetP

; 169  : 		paintbuffers[i].ifilter = FILTERTYPE_NONE;

	imul	eax, DWORD PTR _i$[ebp], 108
	mov	DWORD PTR _paintbuffers[eax+8], 0
	jmp	SHORT $LN2@MIX_ResetP
$LN1@MIX_ResetP:

; 170  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_ResetPaintbufferFilterCounters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_DeactivateAllPaintbuffers
_TEXT	SEGMENT
_i$ = -4						; size = 4
_MIX_DeactivateAllPaintbuffers PROC			; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 157  : 	int	i;
; 158  : 
; 159  : 	for( i = 0; i < CPAINTBUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_Deacti
$LN2@MIX_Deacti:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_Deacti:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN1@MIX_Deacti

; 160  : 		paintbuffers[i].factive = false;

	imul	eax, DWORD PTR _i$[ebp], 108
	mov	DWORD PTR _paintbuffers[eax], 0
	jmp	SHORT $LN2@MIX_Deacti
$LN1@MIX_Deacti:

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_DeactivateAllPaintbuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_GetCurrentPaintbufferPtr
_TEXT	SEGMENT
tv71 = -72						; size = 4
_ipaint$ = -4						; size = 4
_MIX_GetCurrentPaintbufferPtr PROC			; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 148  : 	int	ipaint = MIX_GetCurrentPaintbufferIndex();

	call	_MIX_GetCurrentPaintbufferIndex
	mov	DWORD PTR _ipaint$[ebp], eax

; 149  : 	
; 150  : 	Assert( ipaint < CPAINTBUFFERS );

	cmp	DWORD PTR _ipaint$[ebp], 3
	jge	SHORT $LN3@MIX_GetCur
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@MIX_GetCur
$LN3@MIX_GetCur:
	mov	DWORD PTR tv71[ebp], 0
$LN4@MIX_GetCur:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_GetCurrentPaintbufferPtr@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BH@MHGFDKMI@ipaint?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 151  : 	return &paintbuffers[ipaint];

	imul	eax, DWORD PTR _ipaint$[ebp], 108
	add	eax, OFFSET _paintbuffers

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_GetCurrentPaintbufferPtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_GetCurrentPaintbufferIndex
_TEXT	SEGMENT
_i$ = -4						; size = 4
_MIX_GetCurrentPaintbufferIndex PROC			; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 136  : 	int	i;
; 137  : 
; 138  : 	for( i = 0; i < CPAINTBUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_GetCur
$LN2@MIX_GetCur:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_GetCur:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@MIX_GetCur

; 139  : 	{
; 140  : 		if( g_curpaintbuffer == paintbuffers[i].pbuf )

	imul	eax, DWORD PTR _i$[ebp], 108
	mov	ecx, DWORD PTR _g_curpaintbuffer
	cmp	ecx, DWORD PTR _paintbuffers[eax+4]
	jne	SHORT $LN5@MIX_GetCur

; 141  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@MIX_GetCur
$LN5@MIX_GetCur:

; 142  : 	}

	jmp	SHORT $LN2@MIX_GetCur
$LN3@MIX_GetCur:

; 143  : 	return 0;

	xor	eax, eax
$LN1@MIX_GetCur:

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_GetCurrentPaintbufferIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_SetCurrentPaintbuffer
_TEXT	SEGMENT
tv81 = -68						; size = 4
tv70 = -68						; size = 4
_ipaintbuffer$ = 8					; size = 4
_MIX_SetCurrentPaintbuffer PROC				; COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 129  : 	Assert( ipaintbuffer < CPAINTBUFFERS );

	cmp	DWORD PTR _ipaintbuffer$[ebp], 3
	jge	SHORT $LN3@MIX_SetCur
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@MIX_SetCur
$LN3@MIX_SetCur:
	mov	DWORD PTR tv70[ebp], 0
$LN4@MIX_SetCur:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_SetCurrentPaintbuffer@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 130  : 	g_curpaintbuffer = paintbuffers[ipaintbuffer].pbuf;

	imul	eax, DWORD PTR _ipaintbuffer$[ebp], 108
	mov	ecx, DWORD PTR _paintbuffers[eax+4]
	mov	DWORD PTR _g_curpaintbuffer, ecx

; 131  : 	Assert( g_curpaintbuffer != NULL );

	cmp	DWORD PTR _g_curpaintbuffer, 0
	je	SHORT $LN5@MIX_SetCur
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN6@MIX_SetCur
$LN5@MIX_SetCur:
	mov	DWORD PTR tv81[ebp], 0
$LN6@MIX_SetCur:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_SetCurrentPaintbuffer@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BJ@FIAEAKMH@g_curpaintbuffer?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv81[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_SetCurrentPaintbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_ActivatePaintbuffer
_TEXT	SEGMENT
tv70 = -68						; size = 4
_ipaintbuffer$ = 8					; size = 4
_MIX_ActivatePaintbuffer PROC				; COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 116  : 	Assert( ipaintbuffer < CPAINTBUFFERS );

	cmp	DWORD PTR _ipaintbuffer$[ebp], 3
	jge	SHORT $LN3@MIX_Activa
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@MIX_Activa
$LN3@MIX_Activa:
	mov	DWORD PTR tv70[ebp], 0
$LN4@MIX_Activa:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??MIX_ActivatePaintbuffer@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BN@BEOLPJFF@ipaintbuffer?5?$DM?5CPAINTBUFFERS@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 117  : 	paintbuffers[ipaintbuffer].factive = true;

	imul	eax, DWORD PTR _ipaintbuffer$[ebp], 108
	mov	DWORD PTR _paintbuffers[eax], 1

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_ActivatePaintbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_TransferPaintBuffer
_TEXT	SEGMENT
_pbuf$ = -36						; size = 4
_snd_out$ = -32						; size = 4
_sampleMask$ = -28					; size = 4
_val$ = -24						; size = 4
_i$ = -20						; size = 4
_lpaintedtime$ = -16					; size = 4
_lpos$ = -12						; size = 4
_snd_linear_count$ = -8					; size = 4
_snd_p$ = -4						; size = 4
_endtime$ = 8						; size = 4
_S_TransferPaintBuffer PROC				; COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 63   : 	int	*snd_p, snd_linear_count;
; 64   : 	int	lpos, lpaintedtime;
; 65   : 	int	i, val, sampleMask;
; 66   : 	short	*snd_out;
; 67   : 	dword	*pbuf;
; 68   : 
; 69   : 	pbuf = (dword *)dma.buffer;

	mov	eax, DWORD PTR _dma+8
	mov	DWORD PTR _pbuf$[ebp], eax

; 70   : 	snd_p = (int *)PAINTBUFFER;

	mov	eax, DWORD PTR _g_curpaintbuffer
	mov	DWORD PTR _snd_p$[ebp], eax

; 71   : 	lpaintedtime = paintedtime;

	mov	eax, DWORD PTR _paintedtime
	mov	DWORD PTR _lpaintedtime$[ebp], eax

; 72   : 	sampleMask = ((dma.samples >> 1) - 1);

	mov	eax, DWORD PTR _dma
	sar	eax, 1
	sub	eax, 1
	mov	DWORD PTR _sampleMask$[ebp], eax
$LN2@S_Transfer:

; 73   : 
; 74   : 	while( lpaintedtime < endtime )

	mov	eax, DWORD PTR _lpaintedtime$[ebp]
	cmp	eax, DWORD PTR _endtime$[ebp]
	jge	$LN1@S_Transfer

; 75   : 	{
; 76   : 		// handle recirculating buffer issues
; 77   : 		lpos = lpaintedtime & sampleMask;

	mov	eax, DWORD PTR _lpaintedtime$[ebp]
	and	eax, DWORD PTR _sampleMask$[ebp]
	mov	DWORD PTR _lpos$[ebp], eax

; 78   : 
; 79   : 		snd_out = (short *)pbuf + (lpos << 1);

	mov	eax, DWORD PTR _lpos$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _snd_out$[ebp], edx

; 80   : 
; 81   : 		snd_linear_count = (dma.samples>>1) - lpos;

	mov	eax, DWORD PTR _dma
	sar	eax, 1
	sub	eax, DWORD PTR _lpos$[ebp]
	mov	DWORD PTR _snd_linear_count$[ebp], eax

; 82   : 		if( lpaintedtime + snd_linear_count > endtime )

	mov	eax, DWORD PTR _lpaintedtime$[ebp]
	add	eax, DWORD PTR _snd_linear_count$[ebp]
	cmp	eax, DWORD PTR _endtime$[ebp]
	jle	SHORT $LN7@S_Transfer

; 83   : 			snd_linear_count = endtime - lpaintedtime;

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _lpaintedtime$[ebp]
	mov	DWORD PTR _snd_linear_count$[ebp], eax
$LN7@S_Transfer:

; 84   : 
; 85   : 		snd_linear_count <<= 1;

	mov	eax, DWORD PTR _snd_linear_count$[ebp]
	shl	eax, 1
	mov	DWORD PTR _snd_linear_count$[ebp], eax

; 86   : 
; 87   : 		// write a linear blast of samples
; 88   : 		for( i = 0; i < snd_linear_count; i += 2 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@S_Transfer
$LN4@S_Transfer:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax
$LN6@S_Transfer:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _snd_linear_count$[ebp]
	jge	$LN5@S_Transfer

; 89   : 		{
; 90   : 			val = (snd_p[i+0] * 256) >> 8;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _snd_p$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	shl	edx, 8
	sar	edx, 8
	mov	DWORD PTR _val$[ebp], edx

; 91   : 
; 92   : 			if( val > 0x7fff ) snd_out[i+0] = 0x7fff;

	cmp	DWORD PTR _val$[ebp], 32767		; 00007fffH
	jle	SHORT $LN8@S_Transfer
	mov	eax, 32767				; 00007fffH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _snd_out$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	jmp	SHORT $LN9@S_Transfer
$LN8@S_Transfer:

; 93   : 			else if( val < (short)0x8000 )

	cmp	DWORD PTR _val$[ebp], -32768		; ffff8000H
	jge	SHORT $LN10@S_Transfer

; 94   : 				snd_out[i+0] = (short)0x8000;

	mov	eax, -32768				; ffff8000H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _snd_out$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	jmp	SHORT $LN9@S_Transfer
$LN10@S_Transfer:

; 95   : 			else snd_out[i+0] = val;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _snd_out$[ebp]
	mov	dx, WORD PTR _val$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
$LN9@S_Transfer:

; 96   : 
; 97   : 			val = (snd_p[i+1] * 256) >> 8;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _snd_p$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	shl	edx, 8
	sar	edx, 8
	mov	DWORD PTR _val$[ebp], edx

; 98   : 			if( val > 0x7fff ) snd_out[i+1] = 0x7fff;

	cmp	DWORD PTR _val$[ebp], 32767		; 00007fffH
	jle	SHORT $LN12@S_Transfer
	mov	eax, 32767				; 00007fffH
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _snd_out$[ebp]
	mov	WORD PTR [edx+ecx*2+2], ax
	jmp	SHORT $LN13@S_Transfer
$LN12@S_Transfer:

; 99   : 			else if( val < (short)0x8000 )

	cmp	DWORD PTR _val$[ebp], -32768		; ffff8000H
	jge	SHORT $LN14@S_Transfer

; 100  : 				snd_out[i+1] = (short)0x8000;

	mov	eax, -32768				; ffff8000H
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _snd_out$[ebp]
	mov	WORD PTR [edx+ecx*2+2], ax
	jmp	SHORT $LN13@S_Transfer
$LN14@S_Transfer:

; 101  : 			else snd_out[i+1] = val;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _snd_out$[ebp]
	mov	dx, WORD PTR _val$[ebp]
	mov	WORD PTR [ecx+eax*2+2], dx
$LN13@S_Transfer:

; 102  : 		}

	jmp	$LN4@S_Transfer
$LN5@S_Transfer:

; 103  : 
; 104  : 		snd_p += snd_linear_count;

	mov	eax, DWORD PTR _snd_linear_count$[ebp]
	mov	ecx, DWORD PTR _snd_p$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _snd_p$[ebp], edx

; 105  : 		lpaintedtime += (snd_linear_count >> 1);

	mov	eax, DWORD PTR _snd_linear_count$[ebp]
	sar	eax, 1
	add	eax, DWORD PTR _lpaintedtime$[ebp]
	mov	DWORD PTR _lpaintedtime$[ebp], eax

; 106  : 	}

	jmp	$LN2@S_Transfer
$LN1@S_Transfer:

; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_TransferPaintBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_PaintChannels
_TEXT	SEGMENT
_dsp_room_gain$ = -12					; size = 4
_count$ = -8						; size = 4
_end$ = -4						; size = 4
_endtime$ = 8						; size = 4
_MIX_PaintChannels PROC					; COMDAT

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1019 : 	int	end, count;
; 1020 : 	float	dsp_room_gain;
; 1021 : 
; 1022 : 	CheckNewDspPresets();

	call	_CheckNewDspPresets

; 1023 : 
; 1024 : 	// get dsp preset gain values, update gain crossfaders,
; 1025 : 	// used when mixing dsp processed buffers into paintbuffer
; 1026 : 	dsp_room_gain = DSP_GetGain( idsp_room );	// update crossfader - gain only used in MIX_ScaleChannelVolume

	mov	eax, DWORD PTR _idsp_room
	push	eax
	call	_DSP_GetGain
	add	esp, 4
	fstp	DWORD PTR _dsp_room_gain$[ebp]
$LN2@MIX_PaintC:

; 1027 : 
; 1028 : 	while( paintedtime < endtime )

	mov	eax, DWORD PTR _paintedtime
	cmp	eax, DWORD PTR _endtime$[ebp]
	jge	$LN3@MIX_PaintC

; 1029 : 	{
; 1030 : 		// if paintbuffer is smaller than DMA buffer
; 1031 : 		end = endtime;

	mov	eax, DWORD PTR _endtime$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 1032 : 		if( endtime - paintedtime > PAINTBUFFER_SIZE )

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _paintedtime
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN4@MIX_PaintC

; 1033 : 			end = paintedtime + PAINTBUFFER_SIZE;

	mov	eax, DWORD PTR _paintedtime
	add	eax, 1024				; 00000400H
	mov	DWORD PTR _end$[ebp], eax
$LN4@MIX_PaintC:

; 1034 : 
; 1035 : 		// number of 44khz samples to mix into paintbuffer, up to paintbuffer size
; 1036 : 		count = end - paintedtime;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _paintedtime
	mov	DWORD PTR _count$[ebp], eax

; 1037 : 
; 1038 : 		// clear the all mix buffers
; 1039 : 		MIX_ClearAllPaintBuffers( count, false );

	push	0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	call	_MIX_ClearAllPaintBuffers
	add	esp, 8

; 1040 : 
; 1041 : 		MIX_UpsampleAllPaintbuffers( end, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	call	_MIX_UpsampleAllPaintbuffers
	add	esp, 8

; 1042 : 
; 1043 : 		// process all sounds with DSP
; 1044 : 		DSP_Process( idsp_room, MIX_GetPFrontFromIPaint( IROOMBUFFER ), count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	1
	call	_MIX_GetPFrontFromIPaint
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _idsp_room
	push	ecx
	call	_DSP_Process
	add	esp, 12					; 0000000cH

; 1045 : 
; 1046 : 		// add music or soundtrack from movie (no dsp)
; 1047 : 		MIX_MixPaintbuffers( IPAINTBUFFER, IROOMBUFFER, IPAINTBUFFER, count, S_GetMasterVolume() );

	call	_S_GetMasterVolume
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	0
	push	1
	push	0
	call	_MIX_MixPaintbuffers
	add	esp, 20					; 00000014H

; 1048 : 
; 1049 : 		// add music or soundtrack from movie (no dsp)
; 1050 : 		MIX_MixPaintbuffers( IPAINTBUFFER, ISTREAMBUFFER, IPAINTBUFFER, count, S_GetMusicVolume() );	

	call	_S_GetMusicVolume
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	0
	push	2
	push	0
	call	_MIX_MixPaintbuffers
	add	esp, 20					; 00000014H

; 1051 : 
; 1052 : 		// clip all values > 16 bit down to 16 bit
; 1053 : 		MIX_CompressPaintbuffer( IPAINTBUFFER, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	0
	call	_MIX_CompressPaintbuffer
	add	esp, 8

; 1054 : 
; 1055 : 		// transfer IPAINTBUFFER paintbuffer out to DMA buffer
; 1056 : 		MIX_SetCurrentPaintbuffer( IPAINTBUFFER );

	push	0
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 1057 : 
; 1058 : 		// transfer out according to DMA format
; 1059 : 		S_TransferPaintBuffer( end );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	call	_S_TransferPaintBuffer
	add	esp, 4

; 1060 : 		paintedtime = end;

	mov	eax, DWORD PTR _end$[ebp]
	mov	DWORD PTR _paintedtime, eax

; 1061 : 	}

	jmp	$LN2@MIX_PaintC
$LN3@MIX_PaintC:

; 1062 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_PaintChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_FreeAllPaintbuffers
_TEXT	SEGMENT
_MIX_FreeAllPaintbuffers PROC				; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 193  : 	// clear paintbuffer structs
; 194  : 	memset( paintbuffers, 0, CPAINTBUFFERS * sizeof( paintbuffer_t ));

	push	324					; 00000144H
	push	0
	push	OFFSET _paintbuffers
	call	_memset
	add	esp, 12					; 0000000cH

; 195  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_FreeAllPaintbuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_InitAllPaintbuffers
_TEXT	SEGMENT
_MIX_InitAllPaintbuffers PROC				; COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 200  : 	// clear paintbuffer structs
; 201  : 	memset( paintbuffers, 0, CPAINTBUFFERS * sizeof( paintbuffer_t ));

	push	324					; 00000144H
	push	0
	push	OFFSET _paintbuffers
	call	_memset
	add	esp, 12					; 0000000cH

; 202  : 
; 203  : 	paintbuffers[IPAINTBUFFER].pbuf = paintbuffer;

	mov	eax, 108				; 0000006cH
	imul	ecx, eax, 0
	mov	DWORD PTR _paintbuffers[ecx+4], OFFSET _paintbuffer

; 204  : 	paintbuffers[IROOMBUFFER].pbuf = roombuffer;

	mov	eax, 108				; 0000006cH
	shl	eax, 0
	mov	DWORD PTR _paintbuffers[eax+4], OFFSET _roombuffer

; 205  : 	paintbuffers[ISTREAMBUFFER].pbuf = streambuffer;

	mov	eax, 108				; 0000006cH
	shl	eax, 1
	mov	DWORD PTR _paintbuffers[eax+4], OFFSET _streambuffer

; 206  : 		
; 207  : 	MIX_SetCurrentPaintbuffer( IPAINTBUFFER );

	push	0
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 208  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_InitAllPaintbuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _MIX_ClearAllPaintBuffers
_TEXT	SEGMENT
tv65 = -76						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_SampleCount$ = 8					; size = 4
_clearFilters$ = 12					; size = 4
_MIX_ClearAllPaintBuffers PROC				; COMDAT

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 814  : 	int	count = min( SampleCount, PAINTBUFFER_SIZE );

	cmp	DWORD PTR _SampleCount$[ebp], 1024	; 00000400H
	jge	SHORT $LN9@MIX_ClearA
	mov	eax, DWORD PTR _SampleCount$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN10@MIX_ClearA
$LN9@MIX_ClearA:
	mov	DWORD PTR tv65[ebp], 1024		; 00000400H
$LN10@MIX_ClearA:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 815  : 	int	i;
; 816  : 
; 817  : 	// zero out all paintbuffer data (ignore sampleCount)
; 818  : 	for( i = 0; i < CPAINTBUFFERS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@MIX_ClearA
$LN2@MIX_ClearA:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@MIX_ClearA:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@MIX_ClearA

; 819  : 	{
; 820  : 		if( paintbuffers[i].pbuf != NULL )

	imul	eax, DWORD PTR _i$[ebp], 108
	cmp	DWORD PTR _paintbuffers[eax+4], 0
	je	SHORT $LN5@MIX_ClearA

; 821  : 			memset( paintbuffers[i].pbuf, 0, (count+1) * sizeof( portable_samplepair_t ));

	mov	eax, DWORD PTR _count$[ebp]
	lea	ecx, DWORD PTR [eax*8+8]
	push	ecx
	push	0
	imul	edx, DWORD PTR _i$[ebp], 108
	mov	eax, DWORD PTR _paintbuffers[edx+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN5@MIX_ClearA:

; 822  : 
; 823  : 		if( clearFilters )

	cmp	DWORD PTR _clearFilters$[ebp], 0
	je	SHORT $LN6@MIX_ClearA

; 824  : 		{
; 825  : 			memset( paintbuffers[i].fltmem, 0, sizeof( paintbuffers[i].fltmem ));

	push	96					; 00000060H
	push	0
	imul	eax, DWORD PTR _i$[ebp], 108
	add	eax, OFFSET _paintbuffers+12
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@MIX_ClearA:

; 826  : 		}
; 827  : 	}

	jmp	SHORT $LN2@MIX_ClearA
$LN3@MIX_ClearA:

; 828  : 
; 829  : 	if( clearFilters )

	cmp	DWORD PTR _clearFilters$[ebp], 0
	je	SHORT $LN1@MIX_ClearA

; 830  : 	{
; 831  : 		MIX_ResetPaintbufferFilterCounters();

	call	_MIX_ResetPaintbufferFilterCounters
$LN1@MIX_ClearA:

; 832  : 	}
; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MIX_ClearAllPaintBuffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_MixDataToDevice
_TEXT	SEGMENT
tv260 = -152						; size = 8
tv314 = -144						; size = 8
tv182 = -140						; size = 4
tv291 = -136						; size = 8
tv273 = -136						; size = 8
tv253 = -136						; size = 8
_inputSampleCount$1 = -64				; size = 4
_end$2 = -60						; size = 8
_j$3 = -52						; size = 4
_i$4 = -48						; size = 4
_sampleFrac$5 = -44					; size = 8
_pData$6 = -36						; size = 4
_use_loop$7 = -32					; size = 4
_pSource$8 = -28					; size = 4
_outSampleCount$9 = -24					; size = 4
_availableSamples$10 = -20				; size = 4
_samplesRequired$11 = -16				; size = 4
_rate$ = -12						; size = 4
_inputRate$ = -8					; size = 4
_startingOffset$ = -4					; size = 4
_pChannel$ = 8						; size = 4
_sampleCount$ = 12					; size = 4
_outRate$ = 16						; size = 4
_outOffset$ = 20					; size = 4
_timeCompress$ = 24					; size = 4
_S_MixDataToDevice PROC					; COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi

; 424  : 	// save this to compute total output
; 425  : 	int	startingOffset = outOffset;

	mov	eax, DWORD PTR _outOffset$[ebp]
	mov	DWORD PTR _startingOffset$[ebp], eax

; 426  : 	float	inputRate = ( pChannel->pitch * pChannel->sfx->cache->rate );

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	movzx	eax, WORD PTR [edx]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _pChannel$[ebp]
	mulss	xmm0, DWORD PTR [ecx+64]
	movss	DWORD PTR _inputRate$[ebp], xmm0

; 427  : 	float	rate = inputRate / outRate;

	cvtsi2ss xmm0, DWORD PTR _outRate$[ebp]
	movss	xmm1, DWORD PTR _inputRate$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _rate$[ebp], xmm1

; 428  : 		
; 429  : 	// shouldn't be playing this if finished, but return if we are
; 430  : 	if( pChannel->pMixer.finished )

	mov	eax, DWORD PTR _pChannel$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN7@S_MixDataT

; 431  : 		return 0;

	xor	eax, eax
	jmp	$LN1@S_MixDataT
$LN7@S_MixDataT:

; 432  : 
; 433  : 	// If we are terminating this wave prematurely, then make sure we detect the limit
; 434  : 	if( pChannel->pMixer.forcedEndSample )

	mov	eax, DWORD PTR _pChannel$[ebp]
	movsd	xmm0, QWORD PTR [eax+96]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@S_MixDataT

; 435  : 	{
; 436  : 		// how many total input samples will we need?
; 437  : 		int	samplesRequired = (int)(sampleCount * rate);

	cvtsi2ss xmm0, DWORD PTR _sampleCount$[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _samplesRequired$11[ebp], eax

; 438  : 
; 439  : 		// will this hit the end?
; 440  : 		if( pChannel->pMixer.sample + samplesRequired >= pChannel->pMixer.forcedEndSample )

	cvtsi2sd xmm0, DWORD PTR _samplesRequired$11[ebp]
	mov	eax, DWORD PTR _pChannel$[ebp]
	addsd	xmm0, QWORD PTR [eax+80]
	mov	ecx, DWORD PTR _pChannel$[ebp]
	comisd	xmm0, QWORD PTR [ecx+96]
	jb	SHORT $LN9@S_MixDataT

; 441  : 		{
; 442  : 			// yes, mark finished and truncate the sample request
; 443  : 			pChannel->pMixer.finished = true;

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	DWORD PTR [eax+104], 1

; 444  : 			sampleCount = (int)((pChannel->pMixer.forcedEndSample - pChannel->pMixer.sample) / rate );

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	ecx, DWORD PTR _pChannel$[ebp]
	movsd	xmm0, QWORD PTR [eax+96]
	subsd	xmm0, QWORD PTR [ecx+80]
	cvtss2sd xmm1, DWORD PTR _rate$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	DWORD PTR _sampleCount$[ebp], edx
$LN9@S_MixDataT:

; 445  : 		}
; 446  : 	}
; 447  : 
; 448  : 	while( sampleCount > 0 )

	cmp	DWORD PTR _sampleCount$[ebp], 0
	jle	$LN3@S_MixDataT

; 449  : 	{
; 450  : 		int	availableSamples, outSampleCount;
; 451  : 		wavdata_t	*pSource = pChannel->sfx->cache;

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$8[ebp], edx

; 452  : 		qboolean	use_loop = pChannel->use_loop;

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _use_loop$7[ebp], ecx

; 453  : 		char	*pData = NULL;

	mov	DWORD PTR _pData$6[ebp], 0

; 454  : 		double	sampleFrac;
; 455  : 		int	i, j;
; 456  : 
; 457  : 		// compute number of input samples required
; 458  : 		double	end = pChannel->pMixer.sample + rate * sampleCount;

	cvtsi2ss xmm0, DWORD PTR _sampleCount$[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _pChannel$[ebp]
	addsd	xmm0, QWORD PTR [eax+80]
	movsd	QWORD PTR _end$2[ebp], xmm0

; 459  : 		int	inputSampleCount = (int)(ceil( end ) - floor( pChannel->pMixer.sample ));

	sub	esp, 8
	movsd	xmm0, QWORD PTR _end$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	fstp	QWORD PTR tv253[ebp]
	movsd	xmm0, QWORD PTR tv253[ebp]
	mov	eax, DWORD PTR _pChannel$[ebp]
	sub	esp, 8
	movsd	xmm1, QWORD PTR [eax+80]
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv314[ebp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv260[ebp]
	movsd	xmm0, QWORD PTR tv314[ebp]
	subsd	xmm0, QWORD PTR tv260[ebp]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _inputSampleCount$1[ebp], ecx

; 460  : 
; 461  : 		availableSamples = S_GetOutputData( pSource, &pData, pChannel->pMixer.sample, inputSampleCount, use_loop );

	mov	eax, DWORD PTR _use_loop$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputSampleCount$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChannel$[ebp]
	cvttsd2si eax, QWORD PTR [edx+80]
	push	eax
	lea	ecx, DWORD PTR _pData$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSource$8[ebp]
	push	edx
	call	_S_GetOutputData
	add	esp, 20					; 00000014H
	mov	DWORD PTR _availableSamples$10[ebp], eax

; 462  : 
; 463  : 		// none available, bail out
; 464  : 		if( !availableSamples ) break;

	cmp	DWORD PTR _availableSamples$10[ebp], 0
	jne	SHORT $LN10@S_MixDataT
	jmp	$LN3@S_MixDataT
$LN10@S_MixDataT:

; 465  : 
; 466  : 		sampleFrac = pChannel->pMixer.sample - floor( pChannel->pMixer.sample );

	mov	eax, DWORD PTR _pChannel$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+80]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv273[ebp]
	mov	ecx, DWORD PTR _pChannel$[ebp]
	movsd	xmm0, QWORD PTR [ecx+80]
	subsd	xmm0, QWORD PTR tv273[ebp]
	movsd	QWORD PTR _sampleFrac$5[ebp], xmm0

; 467  : 
; 468  : 		if( availableSamples < inputSampleCount )

	mov	eax, DWORD PTR _availableSamples$10[ebp]
	cmp	eax, DWORD PTR _inputSampleCount$1[ebp]
	jge	SHORT $LN11@S_MixDataT

; 469  : 		{
; 470  : 			// how many samples are there given the number of input samples and the rate.
; 471  : 			outSampleCount = (int)ceil(( availableSamples - sampleFrac ) / rate );

	cvtsi2sd xmm0, DWORD PTR _availableSamples$10[ebp]
	subsd	xmm0, QWORD PTR _sampleFrac$5[ebp]
	cvtss2sd xmm1, DWORD PTR _rate$[ebp]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _outSampleCount$9[ebp], eax

; 472  : 		}

	jmp	SHORT $LN12@S_MixDataT
$LN11@S_MixDataT:

; 473  : 		else
; 474  : 		{
; 475  : 			outSampleCount = sampleCount;

	mov	eax, DWORD PTR _sampleCount$[ebp]
	mov	DWORD PTR _outSampleCount$9[ebp], eax
$LN12@S_MixDataT:

; 476  : 		}
; 477  : 
; 478  : 		// Verify that we won't get a buffer overrun.
; 479  : 		Assert( floor( sampleFrac + rate * ( outSampleCount - 1 )) <= availableSamples );

	mov	eax, DWORD PTR _outSampleCount$9[ebp]
	sub	eax, 1
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _sampleFrac$5[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR tv291[ebp]
	cvtsi2sd xmm0, DWORD PTR _availableSamples$10[ebp]
	comisd	xmm0, QWORD PTR tv291[ebp]
	jb	SHORT $LN16@S_MixDataT
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN17@S_MixDataT
$LN16@S_MixDataT:
	mov	DWORD PTR tv182[ebp], 0
$LN17@S_MixDataT:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??S_MixDataToDevice@@9@9
	add	ecx, 56					; 00000038H
	push	ecx
	push	OFFSET ??_C@_0DC@IIJBIJGB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0EH@KMLPFBNP@floor?$CI?5sampleFrac?5?$CL?5rate?5?$CK?5?$CI?5ou@
	mov	edx, DWORD PTR tv182[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 480  : 
; 481  : 		// save current paintbuffer
; 482  : 		j = MIX_GetCurrentPaintbufferIndex();

	call	_MIX_GetCurrentPaintbufferIndex
	mov	DWORD PTR _j$3[ebp], eax

; 483  : 
; 484  : 		for( i = 0; i < CPAINTBUFFERS; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN6@S_MixDataT
$LN4@S_MixDataT:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN6@S_MixDataT:
	cmp	DWORD PTR _i$4[ebp], 3
	jge	SHORT $LN5@S_MixDataT

; 485  : 		{
; 486  : 			if( !paintbuffers[i].factive )

	imul	eax, DWORD PTR _i$4[ebp], 108
	cmp	DWORD PTR _paintbuffers[eax], 0
	jne	SHORT $LN13@S_MixDataT

; 487  : 				continue;

	jmp	SHORT $LN4@S_MixDataT
$LN13@S_MixDataT:

; 488  : 
; 489  : 			// mix chan into all active paintbuffers
; 490  : 			MIX_SetCurrentPaintbuffer( i );

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 491  : 
; 492  : 			S_MixChannel( pChannel, pData, outOffset, FIX_FLOAT( sampleFrac ), FIX_FLOAT( rate ), outSampleCount, timeCompress );

	mov	eax, DWORD PTR _timeCompress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outSampleCount$9[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _rate$[ebp]
	mulss	xmm0, DWORD PTR __real@4d800000
	cvttss2si edx, xmm0
	push	edx
	movsd	xmm0, QWORD PTR _sampleFrac$5[ebp]
	mulsd	xmm0, QWORD PTR __real@41b0000000000000
	cvttsd2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _outOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pData$6[ebp]
	push	edx
	mov	eax, DWORD PTR _pChannel$[ebp]
	push	eax
	call	_S_MixChannel
	add	esp, 28					; 0000001cH

; 493  : 		}

	jmp	SHORT $LN4@S_MixDataT
$LN5@S_MixDataT:

; 494  : 
; 495  : 		MIX_SetCurrentPaintbuffer( j );

	mov	eax, DWORD PTR _j$3[ebp]
	push	eax
	call	_MIX_SetCurrentPaintbuffer
	add	esp, 4

; 496  : 
; 497  : 		pChannel->pMixer.sample += outSampleCount * rate;

	cvtsi2ss xmm0, DWORD PTR _outSampleCount$9[ebp]
	mulss	xmm0, DWORD PTR _rate$[ebp]
	cvtss2sd xmm0, xmm0
	mov	eax, DWORD PTR _pChannel$[ebp]
	addsd	xmm0, QWORD PTR [eax+80]
	mov	ecx, DWORD PTR _pChannel$[ebp]
	movsd	QWORD PTR [ecx+80], xmm0

; 498  : 		outOffset += outSampleCount;

	mov	eax, DWORD PTR _outOffset$[ebp]
	add	eax, DWORD PTR _outSampleCount$9[ebp]
	mov	DWORD PTR _outOffset$[ebp], eax

; 499  : 		sampleCount -= outSampleCount;

	mov	eax, DWORD PTR _sampleCount$[ebp]
	sub	eax, DWORD PTR _outSampleCount$9[ebp]
	mov	DWORD PTR _sampleCount$[ebp], eax

; 500  : 	}

	jmp	$LN9@S_MixDataT
$LN3@S_MixDataT:

; 501  : 
; 502  : 	// Did we run out of samples? if so, mark finished
; 503  : 	if( sampleCount > 0 )

	cmp	DWORD PTR _sampleCount$[ebp], 0
	jle	SHORT $LN14@S_MixDataT

; 504  : 	{
; 505  : 		pChannel->pMixer.finished = true;

	mov	eax, DWORD PTR _pChannel$[ebp]
	mov	DWORD PTR [eax+104], 1
$LN14@S_MixDataT:

; 506  : 	}
; 507  : 
; 508  : 	// total number of samples mixed !!! at the output clock rate !!!
; 509  : 	return outOffset - startingOffset;

	mov	eax, DWORD PTR _outOffset$[ebp]
	sub	eax, DWORD PTR _startingOffset$[ebp]
$LN1@S_MixDataT:

; 510  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_MixDataToDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_mix.c
;	COMDAT _S_InitScaletable
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_S_InitScaletable PROC					; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 46   : 	int	i, j;
; 47   : 
; 48   : 	for( i = 0; i < SND_SCALE_LEVELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_InitScal
$LN2@S_InitScal:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_InitScal:
	cmp	DWORD PTR _i$[ebp], 128			; 00000080H
	jge	SHORT $LN1@S_InitScal

; 49   : 	{
; 50   : 		for( j = 0; j < 256; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@S_InitScal
$LN5@S_InitScal:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@S_InitScal:
	cmp	DWORD PTR _j$[ebp], 256			; 00000100H
	jge	SHORT $LN6@S_InitScal

; 51   : 			snd_scaletable[i][j] = ((signed char)j) * i * (1<<SND_SCALE_SHIFT);

	movsx	eax, BYTE PTR _j$[ebp]
	imul	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _snd_scaletable[ecx+edx*4], eax
	jmp	SHORT $LN5@S_InitScal
$LN6@S_InitScal:

; 52   : 	}

	jmp	SHORT $LN2@S_InitScal
$LN1@S_InitScal:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_InitScaletable ENDP
_TEXT	ENDS
END
