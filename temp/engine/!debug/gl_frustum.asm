; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_frustum.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_GL_FrustumInitProj
PUBLIC	_GL_FrustumInitOrtho
PUBLIC	_GL_FrustumInitBox
PUBLIC	_GL_FrustumInitProjFromMatrix
PUBLIC	_GL_FrustumSetPlane
PUBLIC	_GL_FrustumNormalizePlane
PUBLIC	_GL_FrustumComputeBounds
PUBLIC	_GL_FrustumComputeCorners
PUBLIC	_GL_FrustumDrawDebug
PUBLIC	_GL_FrustumCullBox
PUBLIC	_GL_FrustumCullSphere
PUBLIC	_GL_FrustumEnablePlane
PUBLIC	_GL_FrustumDisablePlane
PUBLIC	?__LINE__Var@?0??GL_FrustumEnablePlane@@9@9	; `GL_FrustumEnablePlane'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_FrustumDisablePlane@@9@9	; `GL_FrustumDisablePlane'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_FrustumSetPlane@@9@9	; `GL_FrustumSetPlane'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_FrustumNormalizePlane@@9@9	; `GL_FrustumNormalizePlane'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_sqrt:PROC
EXTRN	_SignbitsForPlane:PROC
EXTRN	_PlaneTypeForNormal:PROC
EXTRN	_SinCos:PROC
EXTRN	_PlanesGetIntersectionPoint:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_RI:BYTE
EXTRN	_r_nocull:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_FrustumNormalizePlane@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_FrustumNormalizePlane@@9@9 DD 030H	; `GL_FrustumNormalizePlane'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_FrustumSetPlane@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_FrustumSetPlane@@9@9 DD 024H	; `GL_FrustumSetPlane'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_FrustumDisablePlane@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_FrustumDisablePlane@@9@9 DD 01eH	; `GL_FrustumDisablePlane'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@
CONST	SEGMENT
??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@ DB 's'
	DB	'ide >= 0 && side < FRUSTUM_PLANES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_frustum.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_FrustumEnablePlane@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_FrustumEnablePlane@@9@9 DD 015H	; `GL_FrustumEnablePlane'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	018fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	06cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0127H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03a0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0826H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumDisablePlane
_TEXT	SEGMENT
tv71 = -68						; size = 4
_out$ = 8						; size = 4
_side$ = 12						; size = 4
_GL_FrustumDisablePlane PROC				; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 31   : 	Assert( side >= 0 && side < FRUSTUM_PLANES );

	cmp	DWORD PTR _side$[ebp], 0
	jl	SHORT $LN3@GL_Frustum
	cmp	DWORD PTR _side$[ebp], 6
	jge	SHORT $LN3@GL_Frustum
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@GL_Frustum
$LN3@GL_Frustum:
	mov	DWORD PTR tv71[ebp], 0
$LN4@GL_Frustum:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_FrustumDisablePlane@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 32   : 	ClearBits( out->clipFlags, BIT( side ));

	mov	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _out$[ebp]
	and	eax, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+120], eax

; 33   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumDisablePlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumEnablePlane
_TEXT	SEGMENT
tv71 = -68						; size = 4
_out$ = 8						; size = 4
_side$ = 12						; size = 4
_GL_FrustumEnablePlane PROC				; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 22   : 	Assert( side >= 0 && side < FRUSTUM_PLANES );

	cmp	DWORD PTR _side$[ebp], 0
	jl	SHORT $LN5@GL_Frustum
	cmp	DWORD PTR _side$[ebp], 6
	jge	SHORT $LN5@GL_Frustum
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@GL_Frustum
$LN5@GL_Frustum:
	mov	DWORD PTR tv71[ebp], 0
$LN6@GL_Frustum:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_FrustumEnablePlane@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 23   : 
; 24   : 	// make sure what plane is ready
; 25   : 	if( !VectorIsNull( out->planes[side].normal ))

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@GL_Frustum
	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@GL_Frustum
	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@GL_Frustum
$LN3@GL_Frustum:

; 26   : 		SetBits( out->clipFlags, BIT( side ));

	mov	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _out$[ebp]
	or	eax, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+120], eax
$LN2@GL_Frustum:

; 27   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumEnablePlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumCullSphere
_TEXT	SEGMENT
_p$1 = -16						; size = 4
_bit$ = -12						; size = 4
_i$ = -8						; size = 4
_iClipFlags$ = -4					; size = 4
_out$ = 8						; size = 4
_center$ = 12						; size = 4
_radius$ = 16						; size = 4
_userClipFlags$ = 20					; size = 4
_GL_FrustumCullSphere PROC				; COMDAT

; 332  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 333  : 	int	iClipFlags;
; 334  : 	int	i, bit;
; 335  : 
; 336  : 	if( r_nocull->value )

	mov	eax, DWORD PTR _r_nocull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@GL_Frustum

; 337  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_Frustum
$LN5@GL_Frustum:

; 338  : 
; 339  : 	if( userClipFlags != 0 )

	cmp	DWORD PTR _userClipFlags$[ebp], 0
	je	SHORT $LN6@GL_Frustum

; 340  : 		iClipFlags = userClipFlags;

	mov	eax, DWORD PTR _userClipFlags$[ebp]
	mov	DWORD PTR _iClipFlags$[ebp], eax
	jmp	SHORT $LN7@GL_Frustum
$LN6@GL_Frustum:

; 341  : 	else iClipFlags = out->clipFlags;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _iClipFlags$[ebp], ecx
$LN7@GL_Frustum:

; 342  : 
; 343  : 	for( i = FRUSTUM_PLANES, bit = 1; i > 0; i--, bit <<= 1 )

	mov	DWORD PTR _i$[ebp], 6
	mov	DWORD PTR _bit$[ebp], 1
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _bit$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _bit$[ebp], ecx
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN3@GL_Frustum

; 344  : 	{
; 345  : 		const mplane_t *p = &out->planes[FRUSTUM_PLANES - i];

	mov	eax, 6
	sub	eax, DWORD PTR _i$[ebp]
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p$1[ebp], ecx

; 346  : 
; 347  : 		if( !FBitSet( iClipFlags, bit ))

	mov	eax, DWORD PTR _iClipFlags$[ebp]
	and	eax, DWORD PTR _bit$[ebp]
	jne	SHORT $LN8@GL_Frustum

; 348  : 			continue;

	jmp	SHORT $LN2@GL_Frustum
$LN8@GL_Frustum:

; 349  : 
; 350  : 		if( DotProduct( center, p->normal ) - p->dist <= -radius )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _center$[ebp]
	mov	esi, DWORD PTR _p$1[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _center$[ebp]
	mov	esi, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _center$[ebp]
	mov	esi, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	xmm1, DWORD PTR _radius$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm1, xmm0
	jb	SHORT $LN9@GL_Frustum

; 351  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@GL_Frustum
$LN9@GL_Frustum:

; 352  : 	}

	jmp	$LN2@GL_Frustum
$LN3@GL_Frustum:

; 353  : 
; 354  : 	return false;

	xor	eax, eax
$LN1@GL_Frustum:

; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumCullSphere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumCullBox
_TEXT	SEGMENT
tv79 = -84						; size = 4
_p$1 = -16						; size = 4
_bit$ = -12						; size = 4
_i$ = -8						; size = 4
_iClipFlags$ = -4					; size = 4
_out$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_userClipFlags$ = 20					; size = 4
_GL_FrustumCullBox PROC					; COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 272  : 	int	iClipFlags;
; 273  : 	int	i, bit;
; 274  : 
; 275  : 	if( r_nocull->value )

	mov	eax, DWORD PTR _r_nocull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@GL_Frustum

; 276  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_Frustum
$LN7@GL_Frustum:

; 277  : 
; 278  : 	if( userClipFlags != 0 )

	cmp	DWORD PTR _userClipFlags$[ebp], 0
	je	SHORT $LN8@GL_Frustum

; 279  : 		iClipFlags = userClipFlags;

	mov	eax, DWORD PTR _userClipFlags$[ebp]
	mov	DWORD PTR _iClipFlags$[ebp], eax
	jmp	SHORT $LN9@GL_Frustum
$LN8@GL_Frustum:

; 280  : 	else iClipFlags = out->clipFlags;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _iClipFlags$[ebp], ecx
$LN9@GL_Frustum:

; 281  : 
; 282  : 	for( i = FRUSTUM_PLANES, bit = 1; i > 0; i--, bit <<= 1 )

	mov	DWORD PTR _i$[ebp], 6
	mov	DWORD PTR _bit$[ebp], 1
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _bit$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _bit$[ebp], ecx
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN3@GL_Frustum

; 283  : 	{
; 284  : 		const mplane_t	*p = &out->planes[FRUSTUM_PLANES - i];

	mov	eax, 6
	sub	eax, DWORD PTR _i$[ebp]
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _p$1[ebp], ecx

; 285  : 
; 286  : 		if( !FBitSet( iClipFlags, bit ))

	mov	eax, DWORD PTR _iClipFlags$[ebp]
	and	eax, DWORD PTR _bit$[ebp]
	jne	SHORT $LN10@GL_Frustum

; 287  : 			continue;

	jmp	SHORT $LN2@GL_Frustum
$LN10@GL_Frustum:

; 288  : 
; 289  : 		switch( p->signbits )

	mov	eax, DWORD PTR _p$1[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 7
	ja	$LN27@GL_Frustum
	mov	edx, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN29@GL_Frustum[edx*4]
$LN11@GL_Frustum:

; 290  : 		{
; 291  : 		case 0:
; 292  : 			if( p->normal[0] * maxs[0] + p->normal[1] * maxs[1] + p->normal[2] * maxs[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@GL_Frustum

; 293  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN12@GL_Frustum:

; 294  : 			break;

	jmp	$LN5@GL_Frustum
$LN13@GL_Frustum:

; 295  : 		case 1:
; 296  : 			if( p->normal[0] * mins[0] + p->normal[1] * maxs[1] + p->normal[2] * maxs[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@GL_Frustum

; 297  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN14@GL_Frustum:

; 298  : 			break;

	jmp	$LN5@GL_Frustum
$LN15@GL_Frustum:

; 299  : 		case 2:
; 300  : 			if( p->normal[0] * maxs[0] + p->normal[1] * mins[1] + p->normal[2] * maxs[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@GL_Frustum

; 301  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN16@GL_Frustum:

; 302  : 			break;

	jmp	$LN5@GL_Frustum
$LN17@GL_Frustum:

; 303  : 		case 3:
; 304  : 			if( p->normal[0] * mins[0] + p->normal[1] * mins[1] + p->normal[2] * maxs[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@GL_Frustum

; 305  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN18@GL_Frustum:

; 306  : 			break;

	jmp	$LN5@GL_Frustum
$LN19@GL_Frustum:

; 307  : 		case 4:
; 308  : 			if( p->normal[0] * maxs[0] + p->normal[1] * maxs[1] + p->normal[2] * mins[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@GL_Frustum

; 309  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN20@GL_Frustum:

; 310  : 			break;

	jmp	$LN5@GL_Frustum
$LN21@GL_Frustum:

; 311  : 		case 5:
; 312  : 			if( p->normal[0] * mins[0] + p->normal[1] * maxs[1] + p->normal[2] * mins[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN22@GL_Frustum

; 313  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN22@GL_Frustum:

; 314  : 			break;

	jmp	$LN5@GL_Frustum
$LN23@GL_Frustum:

; 315  : 		case 6:
; 316  : 			if( p->normal[0] * maxs[0] + p->normal[1] * mins[1] + p->normal[2] * mins[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _maxs$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN24@GL_Frustum

; 317  : 				return true;

	mov	eax, 1
	jmp	$LN1@GL_Frustum
$LN24@GL_Frustum:

; 318  : 			break;

	jmp	$LN5@GL_Frustum
$LN25@GL_Frustum:

; 319  : 		case 7:
; 320  : 			if( p->normal[0] * mins[0] + p->normal[1] * mins[1] + p->normal[2] * mins[2] < p->dist )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$1[ebp]
	mov	esi, DWORD PTR _mins$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _p$1[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	comiss	xmm1, xmm0
	jbe	SHORT $LN26@GL_Frustum

; 321  : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@GL_Frustum
$LN26@GL_Frustum:

; 322  : 			break;

	jmp	SHORT $LN5@GL_Frustum
$LN27@GL_Frustum:

; 323  : 		default:
; 324  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@GL_Frustum
$LN5@GL_Frustum:

; 325  : 		}
; 326  : 	}

	jmp	$LN2@GL_Frustum
$LN3@GL_Frustum:

; 327  : 
; 328  : 	return false;

	xor	eax, eax
$LN1@GL_Frustum:

; 329  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@GL_Frustum:
	DD	$LN11@GL_Frustum
	DD	$LN13@GL_Frustum
	DD	$LN15@GL_Frustum
	DD	$LN17@GL_Frustum
	DD	$LN19@GL_Frustum
	DD	$LN21@GL_Frustum
	DD	$LN23@GL_Frustum
	DD	$LN25@GL_Frustum
_GL_FrustumCullBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumDrawDebug
_TEXT	SEGMENT
_i$ = -104						; size = 4
_bbox$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_GL_FrustumDrawDebug PROC				; COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 239  : 	vec3_t	bbox[8];
; 240  : 	int	i;
; 241  : 
; 242  : 	GL_FrustumComputeCorners( out, bbox );

	lea	eax, DWORD PTR _bbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumComputeCorners
	add	esp, 8

; 243  : 
; 244  : 	// g-cont. frustum must be yellow :-)
; 245  : 	pglColor4f( 1.0f, 1.0f, 0.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 246  : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 247  : 	pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 248  : 
; 249  : 	for( i = 0; i < 2; i += 1 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 2
	jge	$LN3@GL_Frustum

; 250  : 	{
; 251  : 		pglVertex3fv( bbox[i+0] );

	imul	eax, DWORD PTR _i$[ebp], 12
	lea	ecx, DWORD PTR _bbox$[ebp+eax]
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 252  : 		pglVertex3fv( bbox[i+2] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 253  : 		pglVertex3fv( bbox[i+4] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 4
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 254  : 		pglVertex3fv( bbox[i+6] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 6
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 255  : 		pglVertex3fv( bbox[i+0] );

	imul	eax, DWORD PTR _i$[ebp], 12
	lea	ecx, DWORD PTR _bbox$[ebp+eax]
	push	ecx
	call	DWORD PTR _pglVertex3fv

; 256  : 		pglVertex3fv( bbox[i+4] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 4
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 257  : 		pglVertex3fv( bbox[i+2] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 258  : 		pglVertex3fv( bbox[i+6] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 6
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 259  : 		pglVertex3fv( bbox[i*2+0] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 1
	imul	ecx, eax, 12
	lea	edx, DWORD PTR _bbox$[ebp+ecx]
	push	edx
	call	DWORD PTR _pglVertex3fv

; 260  : 		pglVertex3fv( bbox[i*2+1] );

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	imul	edx, ecx, 12
	lea	eax, DWORD PTR _bbox$[ebp+edx]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 261  : 		pglVertex3fv( bbox[i*2+4] );

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+4]
	imul	edx, ecx, 12
	lea	eax, DWORD PTR _bbox$[ebp+edx]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 262  : 		pglVertex3fv( bbox[i*2+5] );

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+eax+5]
	imul	edx, ecx, 12
	lea	eax, DWORD PTR _bbox$[ebp+edx]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 263  : 	}

	jmp	$LN2@GL_Frustum
$LN3@GL_Frustum:

; 264  : 
; 265  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 266  : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 267  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumDrawDebug ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumComputeCorners
_TEXT	SEGMENT
_out$ = 8						; size = 4
_corners$ = 12						; size = 4
_GL_FrustumComputeCorners PROC				; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 201  : 	memset( corners, 0, sizeof( corners ));

	push	4
	push	0
	mov	eax, DWORD PTR _corners$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 202  : 
; 203  : 	PlanesGetIntersectionPoint( &out->planes[FRUSTUM_LEFT], &out->planes[FRUSTUM_TOP], &out->planes[FRUSTUM_FAR], corners[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _corners$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 2
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 204  : 	PlanesGetIntersectionPoint( &out->planes[FRUSTUM_RIGHT], &out->planes[FRUSTUM_TOP], &out->planes[FRUSTUM_FAR], corners[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	add	eax, DWORD PTR _corners$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 3
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 205  : 	PlanesGetIntersectionPoint( &out->planes[FRUSTUM_LEFT], &out->planes[FRUSTUM_BOTTOM], &out->planes[FRUSTUM_FAR], corners[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	add	eax, DWORD PTR _corners$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 1
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 206  : 	PlanesGetIntersectionPoint( &out->planes[FRUSTUM_RIGHT], &out->planes[FRUSTUM_BOTTOM], &out->planes[FRUSTUM_FAR], corners[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _corners$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 2
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	shl	eax, 1
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 207  : 
; 208  : 	if( FBitSet( out->clipFlags, BIT( FRUSTUM_NEAR )))

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	and	ecx, 32					; 00000020H
	je	$LN2@GL_Frustum

; 209  : 	{
; 210  : 		PlanesGetIntersectionPoint( &out->planes[FRUSTUM_LEFT], &out->planes[FRUSTUM_TOP], &out->planes[FRUSTUM_NEAR], corners[4] );

	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 5
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 211  : 		PlanesGetIntersectionPoint( &out->planes[FRUSTUM_RIGHT], &out->planes[FRUSTUM_TOP], &out->planes[FRUSTUM_NEAR], corners[5] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 5
	add	ecx, DWORD PTR _corners$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 3
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	shl	eax, 0
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 212  : 		PlanesGetIntersectionPoint( &out->planes[FRUSTUM_LEFT], &out->planes[FRUSTUM_BOTTOM], &out->planes[FRUSTUM_NEAR], corners[6] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 6
	add	ecx, DWORD PTR _corners$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 1
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 213  : 		PlanesGetIntersectionPoint( &out->planes[FRUSTUM_RIGHT], &out->planes[FRUSTUM_BOTTOM], &out->planes[FRUSTUM_NEAR], corners[7] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 7
	add	ecx, DWORD PTR _corners$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	shl	ecx, 1
	add	ecx, DWORD PTR _out$[ebp]
	push	ecx
	mov	edx, 20					; 00000014H
	shl	edx, 0
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 214  : 	}

	jmp	$LN3@GL_Frustum
$LN2@GL_Frustum:

; 215  : 	else
; 216  : 	{
; 217  : 		PlanesGetIntersectionPoint( &out->planes[FRUSTUM_LEFT], &out->planes[FRUSTUM_RIGHT], &out->planes[FRUSTUM_TOP], corners[4] );

	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 3
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	mov	eax, 20					; 00000014H
	shl	eax, 0
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_PlanesGetIntersectionPoint
	add	esp, 16					; 00000010H

; 218  : 		VectorCopy( corners[4], corners[5] );

	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 5
	add	ecx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, edx, 5
	add	edx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 2
	add	ecx, DWORD PTR _corners$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 5
	add	eax, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 219  : 		VectorCopy( corners[4], corners[6] );

	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 6
	add	ecx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, edx, 6
	add	edx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 2
	add	ecx, DWORD PTR _corners$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 6
	add	eax, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 220  : 		VectorCopy( corners[4], corners[7] );

	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 12					; 0000000cH
	imul	ecx, ecx, 7
	add	ecx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, 12					; 0000000cH
	shl	eax, 2
	add	eax, DWORD PTR _corners$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 12					; 0000000cH
	imul	edx, edx, 7
	add	edx, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+esi], eax
	mov	ecx, 12					; 0000000cH
	shl	ecx, 2
	add	ecx, DWORD PTR _corners$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 7
	add	eax, DWORD PTR _corners$[ebp]
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx
$LN3@GL_Frustum:

; 221  : 	}
; 222  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumComputeCorners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumComputeBounds
_TEXT	SEGMENT
_i$ = -104						; size = 4
_corners$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
_GL_FrustumComputeBounds PROC				; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 226  : 	vec3_t	corners[8];
; 227  : 	int	i;
; 228  : 
; 229  : 	GL_FrustumComputeCorners( out, corners );

	lea	eax, DWORD PTR _corners$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumComputeCorners
	add	esp, 8

; 230  : 
; 231  : 	ClearBounds( mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_ClearBounds
	add	esp, 8

; 232  : 
; 233  : 	for( i = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN1@GL_Frustum

; 234  : 		AddPointToBounds( corners[i], mins, maxs );

	mov	eax, DWORD PTR _maxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	eax, DWORD PTR _corners$[ebp+edx]
	push	eax
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@GL_Frustum
$LN1@GL_Frustum:

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumComputeBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumNormalizePlane
_TEXT	SEGMENT
tv71 = -76						; size = 4
_ilength$1 = -8						; size = 4
_length$ = -4						; size = 4
_out$ = 8						; size = 4
_side$ = 12						; size = 4
_GL_FrustumNormalizePlane PROC				; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 49   : 	float	length;
; 50   : 
; 51   : 	Assert( side >= 0 && side < FRUSTUM_PLANES );

	cmp	DWORD PTR _side$[ebp], 0
	jl	SHORT $LN4@GL_Frustum
	cmp	DWORD PTR _side$[ebp], 6
	jge	SHORT $LN4@GL_Frustum
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@GL_Frustum
$LN4@GL_Frustum:
	mov	DWORD PTR tv71[ebp], 0
$LN5@GL_Frustum:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_FrustumNormalizePlane@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 52   : 
; 53   : 	// normalize
; 54   : 	length = VectorLength( out->planes[side].normal );

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _side$[ebp], 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [ecx+esi]
	imul	edx, DWORD PTR _side$[ebp], 20
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _side$[ebp], 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	imul	edx, DWORD PTR _side$[ebp], 20
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _side$[ebp], 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [ecx+esi]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _length$[ebp]

; 55   : 
; 56   : 	if( length )

	movss	xmm0, DWORD PTR _length$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@GL_Frustum

; 57   : 	{
; 58   : 		float ilength = (1.0f / length);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _length$[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0

; 59   : 		out->planes[side].normal[0] *= ilength;

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _side$[ebp], 20
	add	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 60   : 		out->planes[side].normal[1] *= ilength;

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 61   : 		out->planes[side].normal[2] *= ilength;

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 62   : 		out->planes[side].dist *= ilength;

	imul	eax, DWORD PTR _side$[ebp], 20
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+12]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	imul	edx, DWORD PTR _side$[ebp], 20
	mov	eax, DWORD PTR _out$[ebp]
	movss	DWORD PTR [eax+edx+12], xmm0
$LN2@GL_Frustum:

; 63   : 	}
; 64   : 
; 65   : 	out->planes[side].type = PlaneTypeForNormal( out->planes[side].normal );

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_PlaneTypeForNormal
	add	esp, 4
	imul	ecx, DWORD PTR _side$[ebp], 20
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx+16], al

; 66   : 	out->planes[side].signbits = SignbitsForPlane( out->planes[side].normal );

	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_SignbitsForPlane
	add	esp, 4
	imul	ecx, DWORD PTR _side$[ebp], 20
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx+17], al

; 67   : 
; 68   : 	SetBits( out->clipFlags, BIT( side ));

	mov	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _out$[ebp]
	or	eax, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+120], eax

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumNormalizePlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumSetPlane
_TEXT	SEGMENT
tv71 = -68						; size = 4
_out$ = 8						; size = 4
_side$ = 12						; size = 4
_vecNormal$ = 16					; size = 4
_flDist$ = 20						; size = 4
_GL_FrustumSetPlane PROC				; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 37   : 	Assert( side >= 0 && side < FRUSTUM_PLANES );

	cmp	DWORD PTR _side$[ebp], 0
	jl	SHORT $LN3@GL_Frustum
	cmp	DWORD PTR _side$[ebp], 6
	jge	SHORT $LN3@GL_Frustum
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@GL_Frustum
$LN3@GL_Frustum:
	mov	DWORD PTR tv71[ebp], 0
$LN4@GL_Frustum:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_FrustumSetPlane@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@EDPOEDNI@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CD@PNDILOJH@side?5?$DO?$DN?50?5?$CG?$CG?5side?5?$DM?5FRUSTUM_PLA@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 38   : 
; 39   : 	out->planes[side].type = PlaneTypeForNormal( vecNormal );

	mov	eax, DWORD PTR _vecNormal$[ebp]
	push	eax
	call	_PlaneTypeForNormal
	add	esp, 4
	imul	ecx, DWORD PTR _side$[ebp], 20
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx+16], al

; 40   : 	out->planes[side].signbits = SignbitsForPlane( vecNormal );

	mov	eax, DWORD PTR _vecNormal$[ebp]
	push	eax
	call	_SignbitsForPlane
	add	esp, 4
	imul	ecx, DWORD PTR _side$[ebp], 20
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx+17], al

; 41   : 	VectorCopy( vecNormal, out->planes[side].normal );

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _side$[ebp], 20
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _vecNormal$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _side$[ebp], 20
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _vecNormal$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _side$[ebp], 20
	add	ecx, DWORD PTR _out$[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _vecNormal$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [ecx+edx], eax

; 42   : 	out->planes[side].dist = flDist;

	imul	eax, DWORD PTR _side$[ebp], 20
	mov	ecx, DWORD PTR _out$[ebp]
	movss	xmm0, DWORD PTR _flDist$[ebp]
	movss	DWORD PTR [ecx+eax+12], xmm0

; 43   : 
; 44   : 	SetBits( out->clipFlags, BIT( side ));

	mov	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _out$[ebp]
	or	eax, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [edx+120], eax

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumSetPlane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumInitProjFromMatrix
_TEXT	SEGMENT
_i$ = -4						; size = 4
_out$ = 8						; size = 4
_projection$ = 12					; size = 4
_GL_FrustumInitProjFromMatrix PROC			; COMDAT

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 155  : 	int	i;
; 156  : 
; 157  : 	// left
; 158  : 	out->planes[FRUSTUM_LEFT].normal[0] =	projection[0][3] + projection[0][0];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _out$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 159  : 	out->planes[FRUSTUM_LEFT].normal[1] =	projection[1][3] + projection[1][0];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 160  : 	out->planes[FRUSTUM_LEFT].normal[2] =	projection[2][3] + projection[2][0];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 161  : 	out->planes[FRUSTUM_LEFT].dist =	-(projection[3][3] + projection[3][0]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx+12], xmm0

; 162  : 
; 163  : 	// right
; 164  : 	out->planes[FRUSTUM_RIGHT].normal[0] =	projection[0][3] - projection[0][0];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	shl	eax, 0
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 165  : 	out->planes[FRUSTUM_RIGHT].normal[1] =	projection[1][3] - projection[1][0];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 0
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 166  : 	out->planes[FRUSTUM_RIGHT].normal[2] =	projection[2][3] - projection[2][0];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 0
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 167  : 	out->planes[FRUSTUM_RIGHT].dist =	-(projection[3][3] - projection[3][0]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax+12], xmm0

; 168  : 
; 169  : 	// bottom
; 170  : 	out->planes[FRUSTUM_BOTTOM].normal[0] =	projection[0][3] + projection[0][1];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	shl	eax, 1
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 171  : 	out->planes[FRUSTUM_BOTTOM].normal[1] =	projection[1][3] + projection[1][1];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 1
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 172  : 	out->planes[FRUSTUM_BOTTOM].normal[2] =	projection[2][3] + projection[2][1];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 1
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 173  : 	out->planes[FRUSTUM_BOTTOM].dist =	-(projection[3][3] + projection[3][1]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax+12], xmm0

; 174  : 
; 175  : 	// top
; 176  : 	out->planes[FRUSTUM_TOP].normal[0] =	projection[0][3] - projection[0][1];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _out$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 177  : 	out->planes[FRUSTUM_TOP].normal[1] =	projection[1][3] - projection[1][1];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 3
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 178  : 	out->planes[FRUSTUM_TOP].normal[2] =	projection[2][3] - projection[2][1];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 3
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 179  : 	out->planes[FRUSTUM_TOP].dist =	-(projection[3][3] - projection[3][1]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx+12], xmm0

; 180  : 
; 181  : 	// near
; 182  : 	out->planes[FRUSTUM_NEAR].normal[0] =	projection[0][3] + projection[0][2];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 5
	add	ecx, DWORD PTR _out$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0

; 183  : 	out->planes[FRUSTUM_NEAR].normal[1] =	projection[1][3] + projection[1][2];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0

; 184  : 	out->planes[FRUSTUM_NEAR].normal[2] =	projection[2][3] + projection[2][2];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	imul	eax, edx, 5
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR [eax+ecx], xmm0

; 185  : 	out->planes[FRUSTUM_NEAR].dist =	-(projection[3][3] + projection[3][2]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [edx+ecx+12], xmm0

; 186  : 
; 187  : 	// far
; 188  : 	out->planes[FRUSTUM_FAR].normal[0] =	projection[0][3] - projection[0][2];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 0
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 20					; 00000014H
	shl	eax, 2
	add	eax, DWORD PTR _out$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 189  : 	out->planes[FRUSTUM_FAR].normal[1] =	projection[1][3] - projection[1][2];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 2
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0

; 190  : 	out->planes[FRUSTUM_FAR].normal[2] =	projection[2][3] - projection[2][2];

	mov	eax, 16					; 00000010H
	shl	eax, 1
	add	eax, DWORD PTR _projection$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 20					; 00000014H
	shl	edx, 2
	add	edx, DWORD PTR _out$[ebp]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR [edx+eax], xmm0

; 191  : 	out->planes[FRUSTUM_FAR].dist =	-(projection[3][3] - projection[3][2]);

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _projection$[ebp]
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, 16					; 00000010H
	imul	edx, edx, 3
	add	edx, DWORD PTR _projection$[ebp]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [ecx+eax]
	subss	xmm0, DWORD PTR [edx+esi]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 20					; 00000014H
	shl	eax, 2
	mov	ecx, DWORD PTR _out$[ebp]
	movss	DWORD PTR [ecx+eax+12], xmm0

; 192  : 
; 193  : 	for( i = 0; i < FRUSTUM_PLANES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $LN3@GL_Frustum

; 194  : 	{
; 195  : 		GL_FrustumNormalizePlane( out, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumNormalizePlane
	add	esp, 8

; 196  : 	}

	jmp	SHORT $LN2@GL_Frustum
$LN3@GL_Frustum:

; 197  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumInitProjFromMatrix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumInitBox
_TEXT	SEGMENT
tv79 = -88						; size = 4
_i$ = -20						; size = 4
_normal$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_org$ = 12						; size = 4
_radius$ = 16						; size = 4
_GL_FrustumInitBox PROC					; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 141  : 	vec3_t	normal;
; 142  : 	int	i;
; 143  : 
; 144  : 	for( i = 0; i < FRUSTUM_PLANES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Frustum
$LN2@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Frustum:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@GL_Frustum

; 145  : 	{
; 146  : 		// setup normal for each direction
; 147  : 		VectorClear( normal );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _normal$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _normal$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _normal$[ebp+eax], xmm0

; 148  : 		normal[((i >> 1) + 1) % 3] = (i & 1) ? 1.0f : -1.0f;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	je	SHORT $LN6@GL_Frustum
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN7@GL_Frustum
$LN6@GL_Frustum:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv79[ebp], xmm0
$LN7@GL_Frustum:
	mov	eax, DWORD PTR _i$[ebp]
	sar	eax, 1
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR _normal$[ebp+edx*4], xmm0

; 149  : 		GL_FrustumSetPlane( out, i, normal, DotProduct( org, normal ) - radius );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 150  : 	}

	jmp	$LN2@GL_Frustum
$LN3@GL_Frustum:

; 151  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumInitBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumInitOrtho
_TEXT	SEGMENT
tv216 = -112						; size = 4
tv172 = -112						; size = 4
tv128 = -112						; size = 4
_orgOffset$ = -44					; size = 4
_iup$ = -40						; size = 12
_iright$ = -28						; size = 12
_iforward$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_xLeft$ = 12						; size = 4
_xRight$ = 16						; size = 4
_yTop$ = 20						; size = 4
_yBottom$ = 24						; size = 4
_flZNear$ = 28						; size = 4
_flZFar$ = 32						; size = 4
_GL_FrustumInitOrtho PROC				; COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 114  : 	vec3_t	iforward, iright, iup;
; 115  : 
; 116  : 	// setup the near and far planes
; 117  : 	float orgOffset = DotProduct( RI.cullorigin, RI.cull_vforward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _RI[edx+272]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _RI[ecx+272]
	addss	xmm0, xmm1
	movss	DWORD PTR _orgOffset$[ebp], xmm0

; 118  : 	VectorNegate( RI.cull_vforward, iforward );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _iforward$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _iforward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv128[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv128[ebp]
	movss	DWORD PTR _iforward$[ebp+ecx], xmm0

; 119  : 
; 120  : 	// because quake ortho is inverted and far and near should be swaped
; 121  : 	GL_FrustumSetPlane( out, FRUSTUM_FAR, iforward, -flZNear - orgOffset );

	movss	xmm0, DWORD PTR _flZNear$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _iforward$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 122  : 	GL_FrustumSetPlane( out, FRUSTUM_NEAR, RI.cull_vforward, flZFar + orgOffset );

	movss	xmm0, DWORD PTR _flZFar$[ebp]
	addss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+272
	push	5
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 123  : 
; 124  : 	// setup left and right planes
; 125  : 	orgOffset = DotProduct( RI.cullorigin, RI.cull_vright );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _RI[eax+284]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _RI[edx+284]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _RI[ecx+284]
	addss	xmm0, xmm1
	movss	DWORD PTR _orgOffset$[ebp], xmm0

; 126  : 	VectorNegate( RI.cull_vright, iright );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+284]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _iright$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+284]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _iright$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+284]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv172[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _iright$[ebp+ecx], xmm0

; 127  : 
; 128  : 	GL_FrustumSetPlane( out, FRUSTUM_LEFT, RI.cull_vright, xLeft + orgOffset );

	movss	xmm0, DWORD PTR _xLeft$[ebp]
	addss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+284
	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 129  : 	GL_FrustumSetPlane( out, FRUSTUM_RIGHT, iright, -xRight - orgOffset );

	movss	xmm0, DWORD PTR _xRight$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _iright$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 130  : 
; 131  : 	// setup top and buttom planes
; 132  : 	orgOffset = DotProduct( RI.cullorigin, RI.cull_vup );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _RI[eax+296]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _RI[edx+296]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _RI[ecx+296]
	addss	xmm0, xmm1
	movss	DWORD PTR _orgOffset$[ebp], xmm0

; 133  : 	VectorNegate( RI.cull_vup, iup );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+296]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _iup$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+296]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _iup$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+296]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv216[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv216[ebp]
	movss	DWORD PTR _iup$[ebp+ecx], xmm0

; 134  : 
; 135  : 	GL_FrustumSetPlane( out, FRUSTUM_TOP, RI.cull_vup, yTop + orgOffset );

	movss	xmm0, DWORD PTR _yTop$[ebp]
	addss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+296
	push	3
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 136  : 	GL_FrustumSetPlane( out, FRUSTUM_BOTTOM, iup, -yBottom - orgOffset );

	movss	xmm0, DWORD PTR _yBottom$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, DWORD PTR _orgOffset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _iup$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 137  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumInitOrtho ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_frustum.c
;	COMDAT _GL_FrustumInitProj
_TEXT	SEGMENT
tv401 = -128						; size = 4
tv354 = -128						; size = 4
tv308 = -128						; size = 4
tv259 = -128						; size = 4
tv226 = -128						; size = 4
tv183 = -128						; size = 4
tv134 = -128						; size = 4
_iforward$ = -60					; size = 12
_normal$ = -48						; size = 12
_nearpoint$ = -36					; size = 12
_farpoint$ = -24					; size = 12
_xc$ = -12						; size = 4
_xs$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_flZNear$ = 12						; size = 4
_flZFar$ = 16						; size = 4
_flFovX$ = 20						; size = 4
_flFovY$ = 24						; size = 4
_GL_FrustumInitProj PROC				; COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 73   : 	float	xs, xc;
; 74   : 	vec3_t	farpoint, nearpoint;
; 75   : 	vec3_t	normal, iforward;	
; 76   : 
; 77   : 	// horizontal fov used for left and right planes
; 78   : 	SinCos( DEG2RAD( flFovX ) * 0.5f, &xs, &xc );

	lea	eax, DWORD PTR _xc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xs$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _flFovX$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 79   : 
; 80   : 	// setup left plane
; 81   : 	VectorMAM( xs, RI.cull_vforward, -xc, RI.cull_vright, normal ); 

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm1, DWORD PTR _RI[eax+284]
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 0
	mulss	xmm1, DWORD PTR _RI[ecx+284]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm1, DWORD PTR _RI[ecx+284]
	addss	xmm0, xmm1
	movss	DWORD PTR tv134[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 82   : 	GL_FrustumSetPlane( out, FRUSTUM_LEFT, normal, DotProduct( RI.cullorigin, normal ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 83   : 
; 84   : 	// setup right plane
; 85   : 	VectorMAM( xs, RI.cull_vforward, xc, RI.cull_vright, normal ); 

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[eax+284]
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[ecx+284]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[ecx+284]
	addss	xmm0, xmm1
	movss	DWORD PTR tv183[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv183[ebp]
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 86   : 	GL_FrustumSetPlane( out, FRUSTUM_RIGHT, normal, DotProduct( RI.cullorigin, normal ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 87   : 
; 88   : 	// vertical fov used for top and bottom planes
; 89   : 	SinCos( DEG2RAD( flFovY ) * 0.5f, &xs, &xc );

	lea	eax, DWORD PTR _xc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xs$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR _flFovY$[ebp]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 90   : 	VectorNegate( RI.cull_vforward, iforward );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _RI[ecx+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _iforward$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _RI[ecx+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _iforward$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _RI[eax+272]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv226[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv226[ebp]
	movss	DWORD PTR _iforward$[ebp+ecx], xmm0

; 91   : 
; 92   : 	// setup bottom plane
; 93   : 	VectorMAM( xs, RI.cull_vforward, -xc, RI.cull_vup, normal ); 

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm1, DWORD PTR _RI[eax+296]
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 0
	mulss	xmm1, DWORD PTR _RI[ecx+296]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	movss	xmm1, DWORD PTR _xc$[ebp]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm1, DWORD PTR _RI[ecx+296]
	addss	xmm0, xmm1
	movss	DWORD PTR tv259[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv259[ebp]
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 94   : 	GL_FrustumSetPlane( out, FRUSTUM_BOTTOM, normal, DotProduct( RI.cullorigin, normal ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 95   : 
; 96   : 	// setup top plane
; 97   : 	VectorMAM( xs, RI.cull_vforward, xc, RI.cull_vup, normal ); 

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[eax+296]
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[ecx+296]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _xs$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _xc$[ebp]
	mulss	xmm1, DWORD PTR _RI[ecx+296]
	addss	xmm0, xmm1
	movss	DWORD PTR tv308[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv308[ebp]
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 98   : 	GL_FrustumSetPlane( out, FRUSTUM_TOP, normal, DotProduct( RI.cullorigin, normal ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+260]
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+260]
	mulss	xmm1, DWORD PTR _normal$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 99   : 
; 100  : 	// setup far plane
; 101  : 	VectorMA( RI.cullorigin, flZFar, RI.cull_vforward, farpoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _flZFar$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	addss	xmm0, DWORD PTR _RI[ecx+260]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _farpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _flZFar$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	addss	xmm0, DWORD PTR _RI[eax+260]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _farpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _flZFar$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	movss	xmm1, DWORD PTR _RI[eax+260]
	addss	xmm1, xmm0
	movss	DWORD PTR tv354[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv354[ebp]
	movss	DWORD PTR _farpoint$[ebp+edx], xmm0

; 102  : 	GL_FrustumSetPlane( out, FRUSTUM_FAR, iforward, DotProduct( iforward, farpoint ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _iforward$[ebp+ecx]
	mulss	xmm0, DWORD PTR _farpoint$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _iforward$[ebp+ecx]
	mulss	xmm1, DWORD PTR _farpoint$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _iforward$[ebp+eax]
	mulss	xmm1, DWORD PTR _farpoint$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _iforward$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H

; 103  : 
; 104  : 	// no need to setup backplane for general view. It's only used for portals and mirrors
; 105  : 	if (flZNear == 0.0f) return;

	movss	xmm0, DWORD PTR _flZNear$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@GL_Frustum
	jmp	$LN1@GL_Frustum
$LN2@GL_Frustum:

; 106  : 
; 107  : 	// setup near plane
; 108  : 	VectorMA( RI.cullorigin, flZNear, RI.cull_vforward, nearpoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _flZNear$[ebp]
	mulss	xmm0, DWORD PTR _RI[eax+272]
	addss	xmm0, DWORD PTR _RI[ecx+260]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _nearpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _flZNear$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	addss	xmm0, DWORD PTR _RI[eax+260]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _nearpoint$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _flZNear$[ebp]
	mulss	xmm0, DWORD PTR _RI[ecx+272]
	movss	xmm1, DWORD PTR _RI[eax+260]
	addss	xmm1, xmm0
	movss	DWORD PTR tv401[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv401[ebp]
	movss	DWORD PTR _nearpoint$[ebp+edx], xmm0

; 109  : 	GL_FrustumSetPlane( out, FRUSTUM_NEAR, RI.cull_vforward, DotProduct( RI.cull_vforward, nearpoint ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _RI[ecx+272]
	mulss	xmm0, DWORD PTR _nearpoint$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _RI[ecx+272]
	mulss	xmm1, DWORD PTR _nearpoint$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _RI[eax+272]
	mulss	xmm1, DWORD PTR _nearpoint$[ebp+ecx]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _RI+272
	push	5
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_GL_FrustumSetPlane
	add	esp, 16					; 00000010H
$LN1@GL_Frustum:

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FrustumInitProj ENDP
_TEXT	ENDS
END
