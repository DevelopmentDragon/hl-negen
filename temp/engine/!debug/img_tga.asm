; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_tga.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Image_LoadTGA
PUBLIC	_Image_SaveTGA
PUBLIC	?__LINE__Var@?0??Image_LoadTGA@@9@9		; `Image_LoadTGA'::`1'::__LINE__Var
PUBLIC	??_C@_0EN@JMEOKIGN@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0FE@BEDLBNNH@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0FB@FKABHNIJ@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0FM@BGJMCCIM@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0FF@KDCDDBNI@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0EO@CAAPEJGE@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ ; `string'
PUBLIC	??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??Image_SaveTGA@@9@9		; `Image_SaveTGA'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@NFNNHOFJ@Generated?5by?5Xash?5ImageLib?$AA@ ; `string'
PUBLIC	__real@3f800000
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_WriteFile:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Image_ValidSize:PROC
EXTRN	_Image_CheckFlag:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_image:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0BM@NFNNHOFJ@Generated?5by?5Xash?5ImageLib?$AA@
CONST	SEGMENT
??_C@_0BM@NFNNHOFJ@Generated?5by?5Xash?5ImageLib?$AA@ DB 'Generated by Xa'
	DB	'sh ImageLib', 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_SaveTGA@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_SaveTGA@@9@9 DD 0e1H		; `Image_SaveTGA'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_tga.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@CAAPEJGE@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0EO@CAAPEJGE@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) Only 8 bit images supported for'
	DB	' type 3 and 11', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@KDCDDBNI@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0FF@KDCDDBNI@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) Only 32 or 24 bit images suppor'
	DB	'ted for type 2 and 10', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@BGJMCCIM@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0FM@BGJMCCIM@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) only 24 and 32 bit colormaps ar'
	DB	'e supported for type 1 and 9', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@FKABHNIJ@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0FB@FKABHNIJ@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) colormap_index is not supported'
	DB	' for type 1 and 9', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@BEDLBNNH@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0FE@BEDLBNNH@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) Only 8 bit colormaps are suppor'
	DB	'ted for type 1 and 9', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@JMEOKIGN@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
CONST	SEGMENT
??_C@_0EN@JMEOKIGN@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@ DB '^'
	DB	'1Error:^7 Image_LoadTGA: (%s) Only 8 bit images supported for'
	DB	' type 1 and 9', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_LoadTGA@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_LoadTGA@@9@9 DD 019H		; `Image_LoadTGA'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	09faH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_tga.c
;	COMDAT _Image_SaveTGA
_TEXT	SEGMENT
tv199 = -100						; size = 4
tv191 = -100						; size = 4
tv178 = -100						; size = 4
tv171 = -100						; size = 4
_comment$ = -32						; size = 4
_out$ = -28						; size = 4
_buffer$ = -24						; size = 4
_in$ = -20						; size = 4
_bufend$ = -16						; size = 4
_pixel_size$ = -12					; size = 4
_outsize$ = -8						; size = 4
_y$ = -4						; size = 4
_name$ = 8						; size = 4
_pix$ = 12						; size = 4
_Image_SaveTGA PROC					; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 226  : 	int		y, outsize, pixel_size;
; 227  : 	const byte	*bufend, *in;
; 228  : 	byte		*buffer, *out;
; 229  : 	const char	*comment = "Generated by Xash ImageLib\0";

	mov	DWORD PTR _comment$[ebp], OFFSET ??_C@_0BM@NFNNHOFJ@Generated?5by?5Xash?5ImageLib?$AA@

; 230  : 
; 231  : 	if( FS_FileExists( name, false ) && !Image_CheckFlag( IL_ALLOW_OVERWRITE ))

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@Image_Save
	push	4
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@Image_Save

; 232  : 		return false; // already existed

	xor	eax, eax
	jmp	$LN1@Image_Save
$LN18@Image_Save:

; 233  : 
; 234  : 	if( pix->flags & IMAGE_HAS_ALPHA )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN19@Image_Save

; 235  : 		outsize = pix->width * pix->height * 4 + 18 + Q_strlen( comment );

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _pix$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	imul	esi, edx
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	lea	ecx, DWORD PTR [eax+esi*4+18]
	mov	DWORD PTR _outsize$[ebp], ecx
	jmp	SHORT $LN20@Image_Save
$LN19@Image_Save:

; 236  : 	else outsize = pix->width * pix->height * 3 + 18 + Q_strlen( comment );

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pix$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	imul	esi, ecx, 3
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	lea	edx, DWORD PTR [esi+eax+18]
	mov	DWORD PTR _outsize$[ebp], edx
$LN20@Image_Save:

; 237  : 
; 238  : 	buffer = (byte *)Mem_Calloc( host.imagepool, outsize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveTGA@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _outsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buffer$[ebp], eax

; 239  : 
; 240  : 	// prepare header
; 241  : 	buffer[0] = Q_strlen( comment ); // tga comment length

	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 242  : 	buffer[2] = 2; // uncompressed type

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [ecx+eax], 2

; 243  : 	buffer[12] = (pix->width >> 0) & 0xFF;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 12
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 244  : 	buffer[13] = (pix->width >> 8) & 0xFF;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	sar	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 13
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 245  : 	buffer[14] = (pix->height >> 0) & 0xFF;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 14
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 246  : 	buffer[15] = (pix->height >> 8) & 0xFF;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	sar	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	edx, 1
	imul	eax, edx, 15
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 247  : 	buffer[16] = ( pix->flags & IMAGE_HAS_ALPHA ) ? 32 : 24;

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN33@Image_Save
	mov	DWORD PTR tv171[ebp], 32		; 00000020H
	jmp	SHORT $LN34@Image_Save
$LN33@Image_Save:
	mov	DWORD PTR tv171[ebp], 24		; 00000018H
$LN34@Image_Save:
	mov	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	cl, BYTE PTR tv171[ebp]
	mov	BYTE PTR [eax+edx], cl

; 248  : 	buffer[17] = ( pix->flags & IMAGE_HAS_ALPHA ) ? 8 : 0; // 8 bits of alpha

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN35@Image_Save
	mov	DWORD PTR tv178[ebp], 8
	jmp	SHORT $LN36@Image_Save
$LN35@Image_Save:
	mov	DWORD PTR tv178[ebp], 0
$LN36@Image_Save:
	mov	edx, 1
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	dl, BYTE PTR tv178[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 249  : 	Q_strncpy( buffer + 18, comment, Q_strlen( comment )); 

	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, 18					; 00000012H
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 250  : 	out = buffer + 18 + Q_strlen( comment );

	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+eax+18]
	mov	DWORD PTR _out$[ebp], edx

; 251  : 
; 252  : 	// get image description
; 253  : 	switch( pix->type )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv191[ebp], ecx
	mov	edx, DWORD PTR tv191[ebp]
	sub	edx, 3
	mov	DWORD PTR tv191[ebp], edx
	cmp	DWORD PTR tv191[ebp], 3
	ja	SHORT $LN25@Image_Save
	mov	eax, DWORD PTR tv191[ebp]
	jmp	DWORD PTR $LN37@Image_Save[eax*4]
$LN22@Image_Save:

; 254  : 	{
; 255  : 	case PF_RGB_24:
; 256  : 	case PF_BGR_24: pixel_size = 3; break;

	mov	DWORD PTR _pixel_size$[ebp], 3
	jmp	SHORT $LN2@Image_Save
$LN24@Image_Save:

; 257  : 	case PF_RGBA_32:
; 258  : 	case PF_BGRA_32: pixel_size = 4; break;	

	mov	DWORD PTR _pixel_size$[ebp], 4
	jmp	SHORT $LN2@Image_Save
$LN25@Image_Save:

; 259  : 	default:
; 260  : 		Mem_Free( buffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveTGA@@9@9
	add	eax, 35					; 00000023H
	push	eax
	push	OFFSET ??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 261  : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Save
$LN2@Image_Save:

; 262  : 	}
; 263  : 
; 264  : 	switch( pix->type )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv199[ebp], ecx
	mov	edx, DWORD PTR tv199[ebp]
	sub	edx, 3
	mov	DWORD PTR tv199[ebp], edx
	cmp	DWORD PTR tv199[ebp], 3
	ja	$LN4@Image_Save
	mov	eax, DWORD PTR tv199[ebp]
	jmp	DWORD PTR $LN38@Image_Save[eax*4]
$LN27@Image_Save:

; 265  : 	{
; 266  : 	case PF_RGB_24:
; 267  : 	case PF_RGBA_32:
; 268  : 		// swap rgba to bgra and flip upside down
; 269  : 		for( y = pix->height - 1; y >= 0; y-- )

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	sub	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
	jmp	SHORT $LN8@Image_Save
$LN6@Image_Save:
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN8@Image_Save:
	cmp	DWORD PTR _y$[ebp], 0
	jl	$LN7@Image_Save

; 270  : 		{
; 271  : 			in = pix->buffer + y * pix->width * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _y$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pix$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _in$[ebp], ecx

; 272  : 			bufend = in + pix->width * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	add	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _bufend$[ebp], ecx

; 273  : 			for( ; in < bufend; in += pixel_size )

	jmp	SHORT $LN11@Image_Save
$LN9@Image_Save:
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _pixel_size$[ebp]
	mov	DWORD PTR _in$[ebp], eax
$LN11@Image_Save:
	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _bufend$[ebp]
	jae	SHORT $LN10@Image_Save

; 274  : 			{
; 275  : 				*out++ = in[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 276  : 				*out++ = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 277  : 				*out++ = in[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 278  : 				if( pix->flags & IMAGE_HAS_ALPHA )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN28@Image_Save

; 279  : 					*out++ = in[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN28@Image_Save:

; 280  : 			}

	jmp	$LN9@Image_Save
$LN10@Image_Save:

; 281  : 		}

	jmp	$LN6@Image_Save
$LN7@Image_Save:

; 282  : 		break;

	jmp	$LN4@Image_Save
$LN30@Image_Save:

; 283  : 	case PF_BGR_24:
; 284  : 	case PF_BGRA_32:
; 285  : 		// flip upside down
; 286  : 		for( y = pix->height - 1; y >= 0; y-- )

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	sub	ecx, 1
	mov	DWORD PTR _y$[ebp], ecx
	jmp	SHORT $LN14@Image_Save
$LN12@Image_Save:
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN14@Image_Save:
	cmp	DWORD PTR _y$[ebp], 0
	jl	$LN4@Image_Save

; 287  : 		{
; 288  : 			in = pix->buffer + y * pix->width * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _y$[ebp]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	mov	edx, DWORD PTR _pix$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR _in$[ebp], ecx

; 289  : 			bufend = in + pix->width * pixel_size;

	mov	eax, DWORD PTR _pix$[ebp]
	movzx	ecx, WORD PTR [eax]
	imul	ecx, DWORD PTR _pixel_size$[ebp]
	add	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _bufend$[ebp], ecx

; 290  : 			for( ; in < bufend; in += pixel_size )

	jmp	SHORT $LN17@Image_Save
$LN15@Image_Save:
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _pixel_size$[ebp]
	mov	DWORD PTR _in$[ebp], eax
$LN17@Image_Save:
	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _bufend$[ebp]
	jae	SHORT $LN16@Image_Save

; 291  : 			{
; 292  : 				*out++ = in[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 293  : 				*out++ = in[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 294  : 				*out++ = in[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 295  : 				if( pix->flags & IMAGE_HAS_ALPHA )

	mov	eax, DWORD PTR _pix$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN31@Image_Save

; 296  : 					*out++ = in[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx
$LN31@Image_Save:

; 297  : 			}

	jmp	$LN15@Image_Save
$LN16@Image_Save:

; 298  : 		}

	jmp	$LN12@Image_Save
$LN4@Image_Save:

; 299  : 		break;
; 300  : 	}	
; 301  : 	FS_WriteFile( name, buffer, outsize );

	mov	eax, DWORD PTR _outsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_WriteFile
	add	esp, 12					; 0000000cH

; 302  : 
; 303  : 	Mem_Free( buffer );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_SaveTGA@@9@9
	add	eax, 78					; 0000004eH
	push	eax
	push	OFFSET ??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 304  : 	return true;

	mov	eax, 1
$LN1@Image_Save:

; 305  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN37@Image_Save:
	DD	$LN24@Image_Save
	DD	$LN24@Image_Save
	DD	$LN22@Image_Save
	DD	$LN22@Image_Save
$LN38@Image_Save:
	DD	$LN27@Image_Save
	DD	$LN30@Image_Save
	DD	$LN27@Image_Save
	DD	$LN30@Image_Save
_Image_SaveTGA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_tga.c
;	COMDAT _Image_LoadTGA
_TEXT	SEGMENT
tv300 = -1308						; size = 4
tv298 = -1308						; size = 4
tv294 = -1308						; size = 4
tv283 = -1308						; size = 4
_targa_header$ = -1112					; size = 18
_compressed$ = -1092					; size = 4
_reflectivity$ = -1088					; size = 12
_pixelcount$ = -1076					; size = 4
_readpixelcount$ = -1072				; size = 4
_alpha$ = -1068						; size = 1
_blue$ = -1067						; size = 1
_green$ = -1066						; size = 1
_red$ = -1065						; size = 1
_palette$ = -1064					; size = 1024
_targa_rgba$ = -40					; size = 4
_pixbuf$ = -36						; size = 4
_buf_p$ = -32						; size = 4
_col$ = -28						; size = 4
_row$ = -24						; size = 4
_row_inc$ = -20						; size = 4
_rows$ = -16						; size = 4
_columns$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Image_LoadTGA PROC					; COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1308				; 0000051cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 26   : 	int	i, columns, rows, row_inc, row, col;
; 27   : 	byte	*buf_p, *pixbuf, *targa_rgba;
; 28   : 	byte	palette[256][4], red = 0, green = 0, blue = 0, alpha = 0;

	mov	BYTE PTR _red$[ebp], 0
	mov	BYTE PTR _green$[ebp], 0
	mov	BYTE PTR _blue$[ebp], 0
	mov	BYTE PTR _alpha$[ebp], 0

; 29   : 	int	readpixelcount, pixelcount;
; 30   : 	int	reflectivity[3] = { 0, 0, 0 };

	mov	DWORD PTR _reflectivity$[ebp], 0
	mov	DWORD PTR _reflectivity$[ebp+4], 0
	mov	DWORD PTR _reflectivity$[ebp+8], 0

; 31   : 	qboolean	compressed;
; 32   : 	tga_t	targa_header;
; 33   : 
; 34   : 	if( filesize < sizeof( tga_t ))

	cmp	DWORD PTR _filesize$[ebp], 18		; 00000012H
	jae	SHORT $LN15@Image_Load

; 35   : 		return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN15@Image_Load:

; 36   : 
; 37   : 	buf_p = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _buf_p$[ebp], eax

; 38   : 	targa_header.id_length = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 39   : 	targa_header.colormap_type = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp+1], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 40   : 	targa_header.image_type = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp+2], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 41   : 
; 42   : 	targa_header.colormap_index = buf_p[0] + buf_p[1] * 256;		buf_p += 2;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	add	eax, ecx
	mov	WORD PTR _targa_header$[ebp+3], ax
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 43   : 	targa_header.colormap_length = buf_p[0] + buf_p[1] * 256;		buf_p += 2;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	shl	ecx, 8
	add	eax, ecx
	mov	WORD PTR _targa_header$[ebp+5], ax
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 44   : 	targa_header.colormap_size = *buf_p;				buf_p += 1;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp+7], cl
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_p$[ebp], eax

; 45   : 	targa_header.x_origin = *(short *)buf_p;			buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _targa_header$[ebp+8], cx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 46   : 	targa_header.y_origin = *(short *)buf_p;			buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _targa_header$[ebp+10], cx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 47   : 	targa_header.width = image.width = *(short *)buf_p;		buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _image+8, cx
	mov	dx, WORD PTR _image+8
	mov	WORD PTR _targa_header$[ebp+12], dx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 48   : 	targa_header.height = image.height = *(short *)buf_p;		buf_p += 2;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _image+10, cx
	mov	dx, WORD PTR _image+10
	mov	WORD PTR _targa_header$[ebp+14], dx
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_p$[ebp], eax

; 49   : 	targa_header.pixel_size = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp+16], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 50   : 	targa_header.attributes = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _targa_header$[ebp+17], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 51   : 	if( targa_header.id_length != 0 ) buf_p += targa_header.id_length;	// skip TARGA image comment

	movzx	eax, BYTE PTR _targa_header$[ebp]
	test	eax, eax
	je	SHORT $LN16@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp]
	add	eax, DWORD PTR _buf_p$[ebp]
	mov	DWORD PTR _buf_p$[ebp], eax
$LN16@Image_Load:

; 52   : 
; 53   : 	// check for tga file
; 54   : 	if( !Image_ValidSize( name )) return false;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Image_ValidSize
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN17@Image_Load
	xor	eax, eax
	jmp	$LN1@Image_Load
$LN17@Image_Load:

; 55   : 
; 56   : 	image.type = PF_RGBA_32; // always exctracted to 32-bit buffer

	mov	DWORD PTR _image+20, 3

; 57   : 
; 58   : 	if( targa_header.image_type == 1 || targa_header.image_type == 9 )

	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 1
	je	SHORT $LN20@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 9
	jne	$LN18@Image_Load
$LN20@Image_Load:

; 59   : 	{
; 60   : 		// uncompressed colormapped image
; 61   : 		if( targa_header.pixel_size != 8 )

	movzx	eax, BYTE PTR _targa_header$[ebp+16]
	cmp	eax, 8
	je	SHORT $LN21@Image_Load

; 62   : 		{
; 63   : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) Only 8 bit images supported for type 1 and 9\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EN@JMEOKIGN@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 64   : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN21@Image_Load:

; 65   : 		}
; 66   : 		if( targa_header.colormap_length != 256 )

	movzx	eax, WORD PTR _targa_header$[ebp+5]
	cmp	eax, 256				; 00000100H
	je	SHORT $LN22@Image_Load

; 67   : 		{
; 68   : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) Only 8 bit colormaps are supported for type 1 and 9\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0FE@BEDLBNNH@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 69   : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN22@Image_Load:

; 70   : 		}
; 71   : 		if( targa_header.colormap_index )

	movzx	eax, WORD PTR _targa_header$[ebp+3]
	test	eax, eax
	je	SHORT $LN23@Image_Load

; 72   : 		{
; 73   : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) colormap_index is not supported for type 1 and 9\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0FB@FKABHNIJ@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 74   : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN23@Image_Load:

; 75   : 		}
; 76   : 		if( targa_header.colormap_size == 24 )

	movzx	eax, BYTE PTR _targa_header$[ebp+7]
	cmp	eax, 24					; 00000018H
	jne	$LN24@Image_Load

; 77   : 		{
; 78   : 			for( i = 0; i < targa_header.colormap_length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Load
$LN2@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Load:
	movzx	eax, WORD PTR _targa_header$[ebp+5]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@Image_Load

; 79   : 			{
; 80   : 				palette[i][2] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 81   : 				palette[i][1] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 82   : 				palette[i][0] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_p$[ebp], eax

; 83   : 				palette[i][3] = 255;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR [ecx+eax], 255			; 000000ffH

; 84   : 			}

	jmp	$LN2@Image_Load
$LN3@Image_Load:

; 85   : 		}

	jmp	$LN27@Image_Load
$LN24@Image_Load:

; 86   : 		else if( targa_header.colormap_size == 32 )

	movzx	eax, BYTE PTR _targa_header$[ebp+7]
	cmp	eax, 32					; 00000020H
	jne	$LN26@Image_Load

; 87   : 		{
; 88   : 			for( i = 0; i < targa_header.colormap_length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Load
$LN5@Image_Load:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Load:
	movzx	eax, WORD PTR _targa_header$[ebp+5]
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN6@Image_Load

; 89   : 			{
; 90   : 				palette[i][2] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 91   : 				palette[i][1] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 92   : 				palette[i][0] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _buf_p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_p$[ebp], eax

; 93   : 				palette[i][3] = *buf_p++;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _buf_p$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	eax, DWORD PTR _buf_p$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_p$[ebp], eax

; 94   : 			}

	jmp	$LN5@Image_Load
$LN6@Image_Load:

; 95   : 		}

	jmp	SHORT $LN27@Image_Load
$LN26@Image_Load:

; 96   : 		else
; 97   : 		{
; 98   : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) only 24 and 32 bit colormaps are supported for type 1 and 9\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0FM@BGJMCCIM@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 99   : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN27@Image_Load:

; 100  : 		}
; 101  : 	}

	jmp	$LN34@Image_Load
$LN18@Image_Load:

; 102  : 	else if( targa_header.image_type == 2 || targa_header.image_type == 10 )

	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 2
	je	SHORT $LN30@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN28@Image_Load
$LN30@Image_Load:

; 103  : 	{
; 104  : 		// uncompressed or RLE compressed RGB
; 105  : 		if( targa_header.pixel_size != 32 && targa_header.pixel_size != 24 )

	movzx	eax, BYTE PTR _targa_header$[ebp+16]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN31@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp+16]
	cmp	eax, 24					; 00000018H
	je	SHORT $LN31@Image_Load

; 106  : 		{
; 107  : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) Only 32 or 24 bit images supported for type 2 and 10\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0FF@KDCDDBNI@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 108  : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN31@Image_Load:

; 109  : 		}
; 110  : 	}

	jmp	SHORT $LN34@Image_Load
$LN28@Image_Load:

; 111  : 	else if( targa_header.image_type == 3 || targa_header.image_type == 11 )

	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 3
	je	SHORT $LN33@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN34@Image_Load
$LN33@Image_Load:

; 112  : 	{
; 113  : 		// uncompressed greyscale
; 114  : 		if( targa_header.pixel_size != 8 )

	movzx	eax, BYTE PTR _targa_header$[ebp+16]
	cmp	eax, 8
	je	SHORT $LN34@Image_Load

; 115  : 		{
; 116  : 			Con_DPrintf( S_ERROR "Image_LoadTGA: (%s) Only 8 bit images supported for type 3 and 11\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EO@CAAPEJGE@?$FO1Error?3?$FO7?5Image_LoadTGA?3?5?$CI?$CFs?$CJ?5@
	call	_Con_DPrintf
	add	esp, 8

; 117  : 			return false;

	xor	eax, eax
	jmp	$LN1@Image_Load
$LN34@Image_Load:

; 118  : 		}
; 119  : 	}
; 120  : 
; 121  : 	columns = targa_header.width;

	movzx	eax, WORD PTR _targa_header$[ebp+12]
	mov	DWORD PTR _columns$[ebp], eax

; 122  : 	rows = targa_header.height;

	movzx	eax, WORD PTR _targa_header$[ebp+14]
	mov	DWORD PTR _rows$[ebp], eax

; 123  : 
; 124  : 	image.size = image.width * image.height * 4;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _image+28, eax

; 125  : 	targa_rgba = image.rgba = Mem_Malloc( host.imagepool, image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_LoadTGA@@9@9
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET ??_C@_0DN@OFFCNMJJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _host+34744
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _image+40, eax
	mov	eax, DWORD PTR _image+40
	mov	DWORD PTR _targa_rgba$[ebp], eax

; 126  : 
; 127  : 	// if bit 5 of attributes isn't set, the image has been stored from bottom to top
; 128  : 	if( !Image_CheckFlag( IL_DONTFLIP_TGA ) && targa_header.attributes & 0x20 )

	push	8
	call	_Image_CheckFlag
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN35@Image_Load
	movzx	eax, BYTE PTR _targa_header$[ebp+17]
	and	eax, 32					; 00000020H
	je	SHORT $LN35@Image_Load

; 129  : 	{
; 130  : 		pixbuf = targa_rgba;

	mov	eax, DWORD PTR _targa_rgba$[ebp]
	mov	DWORD PTR _pixbuf$[ebp], eax

; 131  : 		row_inc = 0;

	mov	DWORD PTR _row_inc$[ebp], 0

; 132  : 	}

	jmp	SHORT $LN36@Image_Load
$LN35@Image_Load:

; 133  : 	else
; 134  : 	{
; 135  : 		pixbuf = targa_rgba + ( rows - 1 ) * columns * 4;

	mov	eax, DWORD PTR _rows$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _columns$[ebp]
	mov	ecx, DWORD PTR _targa_rgba$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pixbuf$[ebp], edx

; 136  : 		row_inc = -columns * 4 * 2;

	mov	eax, DWORD PTR _columns$[ebp]
	neg	eax
	shl	eax, 2
	shl	eax, 1
	mov	DWORD PTR _row_inc$[ebp], eax
$LN36@Image_Load:

; 137  : 	}
; 138  : 
; 139  : 	compressed = ( targa_header.image_type == 9 || targa_header.image_type == 10 || targa_header.image_type == 11 );

	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	cmp	eax, 9
	je	SHORT $LN53@Image_Load
	movzx	ecx, BYTE PTR _targa_header$[ebp+2]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN53@Image_Load
	movzx	edx, BYTE PTR _targa_header$[ebp+2]
	cmp	edx, 11					; 0000000bH
	je	SHORT $LN53@Image_Load
	mov	DWORD PTR tv283[ebp], 0
	jmp	SHORT $LN54@Image_Load
$LN53@Image_Load:
	mov	DWORD PTR tv283[ebp], 1
$LN54@Image_Load:
	mov	eax, DWORD PTR tv283[ebp]
	mov	DWORD PTR _compressed$[ebp], eax

; 140  : 	for( row = col = 0; row < rows; )

	mov	DWORD PTR _col$[ebp], 0
	mov	eax, DWORD PTR _col$[ebp]
	mov	DWORD PTR _row$[ebp], eax
$LN8@Image_Load:
	mov	eax, DWORD PTR _row$[ebp]
	cmp	eax, DWORD PTR _rows$[ebp]
	jge	$LN9@Image_Load

; 141  : 	{
; 142  : 		pixelcount = 0x10000;

	mov	DWORD PTR _pixelcount$[ebp], 65536	; 00010000H

; 143  : 		readpixelcount = 0x10000;

	mov	DWORD PTR _readpixelcount$[ebp], 65536	; 00010000H

; 144  : 
; 145  : 		if( compressed )

	cmp	DWORD PTR _compressed$[ebp], 0
	je	SHORT $LN37@Image_Load

; 146  : 		{
; 147  : 			pixelcount = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _pixelcount$[ebp], ecx
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 148  : 			if( pixelcount & 0x80 )  // run-length packet

	mov	eax, DWORD PTR _pixelcount$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN38@Image_Load

; 149  : 				readpixelcount = 1;

	mov	DWORD PTR _readpixelcount$[ebp], 1
$LN38@Image_Load:

; 150  : 			pixelcount = 1 + ( pixelcount & 0x7f );

	mov	eax, DWORD PTR _pixelcount$[ebp]
	and	eax, 127				; 0000007fH
	add	eax, 1
	mov	DWORD PTR _pixelcount$[ebp], eax
$LN37@Image_Load:

; 151  : 		}
; 152  : 
; 153  : 		while( pixelcount-- && ( row < rows ) )

	mov	eax, DWORD PTR _pixelcount$[ebp]
	mov	DWORD PTR tv294[ebp], eax
	mov	ecx, DWORD PTR _pixelcount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pixelcount$[ebp], ecx
	cmp	DWORD PTR tv294[ebp], 0
	je	$LN12@Image_Load
	mov	eax, DWORD PTR _row$[ebp]
	cmp	eax, DWORD PTR _rows$[ebp]
	jge	$LN12@Image_Load

; 154  : 		{
; 155  : 			if( readpixelcount-- > 0 )

	mov	eax, DWORD PTR _readpixelcount$[ebp]
	mov	DWORD PTR tv298[ebp], eax
	mov	ecx, DWORD PTR _readpixelcount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _readpixelcount$[ebp], ecx
	cmp	DWORD PTR tv298[ebp], 0
	jle	$LN13@Image_Load

; 156  : 			{
; 157  : 				switch( targa_header.image_type )

	movzx	eax, BYTE PTR _targa_header$[ebp+2]
	mov	DWORD PTR tv300[ebp], eax
	mov	ecx, DWORD PTR tv300[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv300[ebp], ecx
	cmp	DWORD PTR tv300[ebp], 10		; 0000000aH
	ja	$LN13@Image_Load
	mov	edx, DWORD PTR tv300[ebp]
	jmp	DWORD PTR $LN55@Image_Load[edx*4]
$LN40@Image_Load:

; 158  : 				{
; 159  : 				case 1:
; 160  : 				case 9:
; 161  : 					// colormapped image
; 162  : 					blue = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _blue$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 163  : 					red = palette[blue][0];

	movzx	eax, BYTE PTR _blue$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _red$[ebp], cl

; 164  : 					green = palette[blue][1];

	movzx	eax, BYTE PTR _blue$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _green$[ebp], al

; 165  : 					alpha = palette[blue][3];

	movzx	eax, BYTE PTR _blue$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	imul	eax, edx, 3
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _alpha$[ebp], cl

; 166  : 					blue = palette[blue][2];

	movzx	eax, BYTE PTR _blue$[ebp]
	lea	ecx, DWORD PTR _palette$[ebp+eax*4]
	mov	edx, 1
	shl	edx, 1
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _blue$[ebp], al

; 167  : 					if( alpha != 255 ) image.flags |= IMAGE_HAS_ALPHA;

	movzx	eax, BYTE PTR _alpha$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN42@Image_Load
	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
$LN42@Image_Load:

; 168  : 					break;

	jmp	$LN13@Image_Load
$LN43@Image_Load:

; 169  : 				case 2:
; 170  : 				case 10:
; 171  : 					// 24 or 32 bit image
; 172  : 					blue = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _blue$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 173  : 					green = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _green$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 174  : 					red = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _red$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 175  : 					alpha = 255;

	mov	BYTE PTR _alpha$[ebp], 255		; 000000ffH

; 176  : 					if( targa_header.pixel_size == 32 )

	movzx	eax, BYTE PTR _targa_header$[ebp+16]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN46@Image_Load

; 177  : 					{
; 178  : 						alpha = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _alpha$[ebp], cl
	mov	edx, DWORD PTR _buf_p$[ebp]
	add	edx, 1
	mov	DWORD PTR _buf_p$[ebp], edx

; 179  : 						if( alpha != 255 )

	movzx	eax, BYTE PTR _alpha$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN46@Image_Load

; 180  : 							image.flags |= IMAGE_HAS_ALPHA;

	mov	eax, DWORD PTR _image+24
	or	eax, 2
	mov	DWORD PTR _image+24, eax
$LN46@Image_Load:

; 181  : 					}
; 182  : 					break;

	jmp	SHORT $LN13@Image_Load
$LN47@Image_Load:

; 183  : 				case 3:
; 184  : 				case 11:
; 185  : 					// greyscale image
; 186  : 					blue = green = red = *buf_p++;

	mov	eax, DWORD PTR _buf_p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _red$[ebp], cl
	mov	dl, BYTE PTR _red$[ebp]
	mov	BYTE PTR _green$[ebp], dl
	mov	al, BYTE PTR _green$[ebp]
	mov	BYTE PTR _blue$[ebp], al
	mov	ecx, DWORD PTR _buf_p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _buf_p$[ebp], ecx

; 187  : 					alpha = 255;

	mov	BYTE PTR _alpha$[ebp], 255		; 000000ffH
$LN13@Image_Load:

; 188  : 					break;
; 189  : 				}
; 190  : 			}
; 191  : 
; 192  : 			if( red != green || green != blue )

	movzx	eax, BYTE PTR _red$[ebp]
	movzx	ecx, BYTE PTR _green$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN50@Image_Load
	movzx	eax, BYTE PTR _green$[ebp]
	movzx	ecx, BYTE PTR _blue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN49@Image_Load
$LN50@Image_Load:

; 193  : 				image.flags |= IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _image+24
	or	eax, 4
	mov	DWORD PTR _image+24, eax
$LN49@Image_Load:

; 194  : 
; 195  : 			reflectivity[0] += red;

	mov	eax, 4
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _red$[ebp]
	add	edx, DWORD PTR _reflectivity$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _reflectivity$[ebp+ecx], edx

; 196  : 			reflectivity[1] += green;

	mov	eax, 4
	shl	eax, 0
	movzx	ecx, BYTE PTR _green$[ebp]
	add	ecx, DWORD PTR _reflectivity$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _reflectivity$[ebp+edx], ecx

; 197  : 			reflectivity[2] += blue;

	mov	eax, 4
	shl	eax, 1
	movzx	ecx, BYTE PTR _blue$[ebp]
	add	ecx, DWORD PTR _reflectivity$[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _reflectivity$[ebp+edx], ecx

; 198  : 
; 199  : 			*pixbuf++ = red;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _red$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 200  : 			*pixbuf++ = green;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _green$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 201  : 			*pixbuf++ = blue;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _blue$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 202  : 			*pixbuf++ = alpha;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	mov	cl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pixbuf$[ebp]
	add	edx, 1
	mov	DWORD PTR _pixbuf$[ebp], edx

; 203  : 			if( ++col == columns )

	mov	eax, DWORD PTR _col$[ebp]
	add	eax, 1
	mov	DWORD PTR _col$[ebp], eax
	mov	ecx, DWORD PTR _col$[ebp]
	cmp	ecx, DWORD PTR _columns$[ebp]
	jne	SHORT $LN51@Image_Load

; 204  : 			{
; 205  : 				// run spans across rows
; 206  : 				row++;

	mov	eax, DWORD PTR _row$[ebp]
	add	eax, 1
	mov	DWORD PTR _row$[ebp], eax

; 207  : 				col = 0;

	mov	DWORD PTR _col$[ebp], 0

; 208  : 				pixbuf += row_inc;

	mov	eax, DWORD PTR _pixbuf$[ebp]
	add	eax, DWORD PTR _row_inc$[ebp]
	mov	DWORD PTR _pixbuf$[ebp], eax
$LN51@Image_Load:

; 209  : 			}
; 210  : 		}

	jmp	$LN37@Image_Load
$LN12@Image_Load:

; 211  : 	}

	jmp	$LN8@Image_Load
$LN9@Image_Load:

; 212  : 
; 213  : 	VectorDivide( reflectivity, ( image.width * image.height ), image.fogParams );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cvtsi2ss xmm1, edx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	ecx, 1
	imul	edx, ecx, 0
	cvttss2si eax, xmm0
	mov	BYTE PTR _image[edx+76], al
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+ecx]
	movzx	edx, WORD PTR _image+8
	movzx	eax, WORD PTR _image+10
	imul	edx, eax
	cvtsi2ss xmm1, edx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	ecx, 1
	shl	ecx, 0
	cvttss2si edx, xmm0
	mov	BYTE PTR _image[ecx+76], dl
	mov	eax, 4
	shl	eax, 1
	cvtsi2ss xmm0, DWORD PTR _reflectivity$[ebp+eax]
	movzx	ecx, WORD PTR _image+8
	movzx	edx, WORD PTR _image+10
	imul	ecx, edx
	cvtsi2ss xmm1, ecx
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm1
	mulss	xmm0, xmm2
	mov	eax, 1
	shl	eax, 1
	cvttss2si ecx, xmm0
	mov	BYTE PTR _image[eax+76], cl

; 214  : 	image.depth = 1;

	mov	eax, 1
	mov	WORD PTR _image+12, ax

; 215  : 
; 216  : 	return true;

	mov	eax, 1
$LN1@Image_Load:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@Image_Load:
	DD	$LN40@Image_Load
	DD	$LN43@Image_Load
	DD	$LN47@Image_Load
	DD	$LN13@Image_Load
	DD	$LN13@Image_Load
	DD	$LN13@Image_Load
	DD	$LN13@Image_Load
	DD	$LN13@Image_Load
	DD	$LN40@Image_Load
	DD	$LN43@Image_Load
	DD	$LN47@Image_Load
_Image_LoadTGA ENDP
_TEXT	ENDS
END
