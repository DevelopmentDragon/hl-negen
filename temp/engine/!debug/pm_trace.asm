; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\pm_trace.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_pm_hullmins DD	0c1800000r			; -16
	DD	0c1800000r			; -16
	DD	0c2100000r			; -36
	DD	0c1800000r			; -16
	DD	0c1800000r			; -16
	DD	0c1900000r			; -18
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0c2000000r			; -32
	DD	0c2000000r			; -32
	DD	0c2000000r			; -32
_pm_hullmaxs DD	041800000r			; 16
	DD	041800000r			; 16
	DD	042100000r			; 36
	DD	041800000r			; 16
	DD	041800000r			; 16
	DD	041900000r			; 18
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042000000r			; 32
	DD	042000000r			; 32
	DD	042000000r			; 32
CONST	ENDS
PUBLIC	_Pmove_Init
PUBLIC	_PM_InitBoxHull
PUBLIC	_PM_HullForBsp
PUBLIC	_PM_RecursiveHullCheck
PUBLIC	_PM_PlayerTraceExt
PUBLIC	_PM_TestPlayerPosition
PUBLIC	_PM_HullPointContents
PUBLIC	_PM_ConvertTrace
PUBLIC	_PM_HullForBox
PUBLIC	_PM_HullForStudio
PUBLIC	?__LINE__Var@?0??PM_HullForBsp@@9@9		; `PM_HullForBsp'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0L@BKPNJPAO@pe?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0BC@HNKHKKMI@pe?9?$DOmodel?5?$CB?$DN?5NULL@ ; `string'
PUBLIC	??_C@_0N@MOOOOKHB@hull?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0CL@GOJPIGLN@PM_RecursiveHullCheck?3?5bad?5node@ ; `string'
PUBLIC	??_C@_0CH@OBLIICFO@?$FO3Warning?3?$FO7?5trace?5backed?5up?5pa@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3d000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_Host_IsLocalClient:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_SV_ClipPMoveToEntity:PROC
EXTRN	_CL_ClipPMoveToEntity:PROC
EXTRN	_Matrix4x4_VectorITransform:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Matrix4x4_TransformPositivePlane:PROC
EXTRN	_Mod_HullForStudio:PROC
EXTRN	_Mod_HitgroupForStudioHull:PROC
EXTRN	_World_TransformAABB:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_pm_boxplanes DB 078H DUP (?)
_pm_boxclipnodes DQ 06H DUP (?)
_pm_boxhull DB	028H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d000000
CONST	SEGMENT
__real@3d000000 DD 03d000000r			; 0.03125
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CH@OBLIICFO@?$FO3Warning?3?$FO7?5trace?5backed?5up?5pa@
CONST	SEGMENT
??_C@_0CH@OBLIICFO@?$FO3Warning?3?$FO7?5trace?5backed?5up?5pa@ DB '^3Warn'
	DB	'ing:^7 trace backed up past 0.0', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GOJPIGLN@PM_RecursiveHullCheck?3?5bad?5node@
CONST	SEGMENT
??_C@_0CL@GOJPIGLN@PM_RecursiveHullCheck?3?5bad?5node@ DB 'PM_RecursiveHu'
	DB	'llCheck: bad node number %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOOOKHB@hull?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@MOOOOKHB@hull?5?$CB?$DN?5NULL@ DB 'hull != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HNKHKKMI@pe?9?$DOmodel?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BC@HNKHKKMI@pe?9?$DOmodel?5?$CB?$DN?5NULL@ DB 'pe->model != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BKPNJPAO@pe?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@BKPNJPAO@pe?5?$CB?$DN?5NULL@ DB 'pe != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\pm_trace.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??PM_HullForBsp@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??PM_HullForBsp@@9@9 DD 094H		; `PM_HullForBsp'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01cbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0ae7H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	012ebH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	079eH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_HullForStudio
_TEXT	SEGMENT
tv155 = -84						; size = 4
tv140 = -84						; size = 4
_size$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pe$ = 8						; size = 4
_pmove$ = 12						; size = 4
_numhitboxes$ = 16					; size = 4
_PM_HullForStudio PROC					; COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 188  : 	vec3_t	size;
; 189  : 
; 190  : 	VectorSubtract( pmove->player_maxs[pmove->usehull], pmove->player_mins[pmove->usehull], size );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [ecx+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _size$[ebp+eax], xmm0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [eax+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [esi+eax+324856]
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _size$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324904]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [ecx+188], 12
	mov	esi, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+324856]
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [ecx+esi]
	movss	DWORD PTR tv140[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv140[ebp]
	movss	DWORD PTR _size$[ebp+edx], xmm0

; 191  : 	VectorScale( size, 0.5f, size );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _size$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _size$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _size$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _size$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv155[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv155[ebp]
	movss	DWORD PTR _size$[ebp+ecx], xmm0

; 192  : 
; 193  : 	return Mod_HullForStudio( pe->studiomodel, pe->frame, pe->sequence, pe->angles, pe->origin, size, pe->controller, pe->blending, numhitboxes, NULL );

	push	0
	mov	eax, DWORD PTR _numhitboxes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+108]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_Mod_HullForStudio
	add	esp, 40					; 00000028H

; 194  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullForStudio ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_HullForBox
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_PM_HullForBox PROC					; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	pm_boxplanes[0].dist = maxs[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 20					; 00000014H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pm_boxplanes[eax+12], ecx

; 103  : 	pm_boxplanes[1].dist = mins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 20					; 00000014H
	shl	edx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _pm_boxplanes[edx+12], ecx

; 104  : 	pm_boxplanes[2].dist = maxs[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 20					; 00000014H
	shl	ecx, 1
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pm_boxplanes[ecx+12], eax

; 105  : 	pm_boxplanes[3].dist = mins[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _pm_boxplanes[edx+12], eax

; 106  : 	pm_boxplanes[4].dist = maxs[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	mov	edx, DWORD PTR _maxs$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pm_boxplanes[ecx+12], eax

; 107  : 	pm_boxplanes[5].dist = mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _mins$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _pm_boxplanes[edx+12], eax

; 108  : 
; 109  : 	return &pm_boxhull;

	mov	eax, OFFSET _pm_boxhull

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullForBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_ConvertTrace
_TEXT	SEGMENT
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_ent$ = 16						; size = 4
_PM_ConvertTrace PROC					; COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 114  : 	memcpy( out, in, 48 ); // matched

	push	48					; 00000030H
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : 	out->hitgroup = in->hitgroup;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+52], edx

; 116  : 	out->ent = ent;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_ConvertTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_HullPointContents
_TEXT	SEGMENT
tv144 = -76						; size = 4
tv139 = -72						; size = 4
_plane$ = -4						; size = 4
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p$ = 16						; size = 4
_PM_HullPointContents PROC				; COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 127  : 	mplane_t		*plane;
; 128  : 
; 129  : 	if( !hull || !hull->planes )	// fantom bmodels?

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN5@PM_HullPoi
	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@PM_HullPoi
$LN5@PM_HullPoi:

; 130  : 		return CONTENTS_NONE;

	xor	eax, eax
	jmp	$LN1@PM_HullPoi
$LN4@PM_HullPoi:

; 131  : 
; 132  : 	while( num >= 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jl	$LN3@PM_HullPoi

; 133  : 	{
; 134  : 		plane = &hull->planes[hull->clipnodes[num].planenum];

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _num$[ebp]
	imul	eax, DWORD PTR [ecx+edx*8], 20
	mov	ecx, DWORD PTR _hull$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _plane$[ebp], eax

; 135  : 		num = hull->clipnodes[num].children[PlaneDiff( p, plane ) < 0];

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN7@PM_HullPoi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv139[ebp], xmm0
	jmp	SHORT $LN8@PM_HullPoi
$LN7@PM_HullPoi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv139[ebp], xmm0
$LN8@PM_HullPoi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv139[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN9@PM_HullPoi
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN10@PM_HullPoi
$LN9@PM_HullPoi:
	mov	DWORD PTR tv144[ebp], 0
$LN10@PM_HullPoi:
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _num$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR tv144[ebp]
	movsx	edx, WORD PTR [eax+ecx*2+4]
	mov	DWORD PTR _num$[ebp], edx

; 136  : 	}

	jmp	$LN4@PM_HullPoi
$LN3@PM_HullPoi:

; 137  : 	return num;

	mov	eax, DWORD PTR _num$[ebp]
$LN1@PM_HullPoi:

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullPointContents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_TestPlayerPosition
_TEXT	SEGMENT
tv471 = -412						; size = 4
tv431 = -412						; size = 4
tv282 = -412						; size = 4
tv246 = -412						; size = 4
$T1 = -408						; size = 68
_trace$2 = -276						; size = 68
_matrix$3 = -208					; size = 64
_transform_bbox$4 = -144				; size = 4
_pe$ = -140						; size = 4
_trace$ = -136						; size = 68
_maxs$ = -68						; size = 12
_mins$ = -56						; size = 12
_hull$ = -44						; size = 4
_offset$ = -40						; size = 12
_pos_l$ = -28						; size = 12
_hullcount$ = -16					; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pmove$ = 8						; size = 4
_pos$ = 12						; size = 4
_ptrace$ = 16						; size = 4
_pmFilter$ = 20						; size = 4
_PM_TestPlayerPosition PROC				; COMDAT

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 532  : 	int	i, j, hullcount;
; 533  : 	vec3_t	pos_l, offset;
; 534  : 	hull_t	*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 535  : 	vec3_t	mins, maxs;
; 536  : 	pmtrace_t trace;
; 537  : 	physent_t *pe;
; 538  : 
; 539  : 	trace = PM_PlayerTraceExt( pmove, pmove->origin, pmove->origin, 0, pmove->numphysent, pmove->physents, -1, pmFilter );

	mov	eax, DWORD PTR _pmFilter$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _pmove$[ebp]
	add	ecx, 592				; 00000250H
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	mov	eax, DWORD PTR [edx+588]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pmove$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_PM_PlayerTraceExt
	add	esp, 36					; 00000024H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 540  : 	if( ptrace ) *ptrace = trace;

	cmp	DWORD PTR _ptrace$[ebp], 0
	je	SHORT $LN11@PM_TestPla
	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace$[ebp]
	mov	edi, DWORD PTR _ptrace$[ebp]
	rep movsd
$LN11@PM_TestPla:

; 541  : 
; 542  : 	for( i = 0; i < pmove->numphysent; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_TestPla
$LN2@PM_TestPla:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_TestPla:
	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+588]
	jge	$LN3@PM_TestPla

; 543  : 	{
; 544  : 		pe = &pmove->physents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$[ebp], edx

; 545  : 
; 546  : 		// run custom user filter
; 547  : 		if( pmFilter != NULL )

	cmp	DWORD PTR _pmFilter$[ebp], 0
	je	SHORT $LN13@PM_TestPla

; 548  : 		{
; 549  : 			if( pmFilter( pe ))

	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	DWORD PTR _pmFilter$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@PM_TestPla

; 550  : 				continue;

	jmp	SHORT $LN2@PM_TestPla
$LN13@PM_TestPla:

; 551  : 		}
; 552  : 
; 553  : 		if( pe->model != NULL && pe->solid == SOLID_NOT && pe->skin != CONTENTS_NONE )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN14@PM_TestPla
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN14@PM_TestPla
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN14@PM_TestPla

; 554  : 			continue;

	jmp	SHORT $LN2@PM_TestPla
$LN14@PM_TestPla:

; 555  : 
; 556  : 		hullcount = 1;

	mov	DWORD PTR _hullcount$[ebp], 1

; 557  : 
; 558  : 		if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	$LN15@PM_TestPla

; 559  : 		{
; 560  : 			VectorCopy( pmove->player_mins[pmove->usehull], mins );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _mins$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _mins$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins$[ebp+eax], ecx

; 561  : 			VectorCopy( pmove->player_maxs[pmove->usehull], maxs );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _maxs$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _maxs$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs$[ebp+eax], ecx

; 562  : 			VectorClear( offset );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 563  : 		}

	jmp	$LN20@PM_TestPla
$LN15@PM_TestPla:

; 564  : 		else if( pe->model )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN17@PM_TestPla

; 565  : 		{
; 566  : 			hull = PM_HullForBsp( pe, pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 567  : 		}

	jmp	$LN20@PM_TestPla
$LN17@PM_TestPla:

; 568  : 		else if( PM_AllowHitBoxTrace( pe->studiomodel, pmove->usehull ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN19@PM_TestPla
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN19@PM_TestPla
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 512				; 00000200H
	jne	SHORT $LN21@PM_TestPla
	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+188], 2
	jne	SHORT $LN19@PM_TestPla
$LN21@PM_TestPla:

; 569  : 		{
; 570  : 			hull = PM_HullForStudio( pe, pmove, &hullcount );

	lea	eax, DWORD PTR _hullcount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForStudio
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 571  : 			VectorClear( offset );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 572  : 		}

	jmp	$LN20@PM_TestPla
$LN19@PM_TestPla:

; 573  : 		else
; 574  : 		{
; 575  : 			VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324904]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+56]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv246[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv246[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 576  : 			VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324856]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv282[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv282[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0

; 577  : 
; 578  : 			hull = PM_HullForBox( mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 579  : 			VectorCopy( pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _offset$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _offset$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
$LN20@PM_TestPla:

; 580  : 		}
; 581  : 
; 582  : 		// CM_TransformedPointContents :-)
; 583  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	$LN22@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@PM_TestPla
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN22@PM_TestPla
$LN24@PM_TestPla:

; 584  : 		{
; 585  : 			qboolean	transform_bbox = false;

	mov	DWORD PTR _transform_bbox$4[ebp], 0

; 586  : 			matrix4x4	matrix;
; 587  : 
; 588  : 			if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 8
	je	$LN26@PM_TestPla

; 589  : 			{
; 590  : 				if(( check_angles( pe->angles[0] ) || check_angles( pe->angles[2] )) && pmove->usehull != 2 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 90					; 0000005aH
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 180				; 000000b4H
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 270				; 0000010eH
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -90				; ffffffa6H
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -180				; ffffff4cH
	je	$LN28@PM_TestPla
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -270				; fffffef2H
	je	$LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 90					; 0000005aH
	je	$LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 180				; 000000b4H
	je	SHORT $LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 270				; 0000010eH
	je	SHORT $LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -90				; ffffffa6H
	je	SHORT $LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -180				; ffffff4cH
	je	SHORT $LN28@PM_TestPla
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -270				; fffffef2H
	jne	SHORT $LN26@PM_TestPla
$LN28@PM_TestPla:
	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+188], 2
	je	SHORT $LN26@PM_TestPla

; 591  : 					transform_bbox = true;

	mov	DWORD PTR _transform_bbox$4[ebp], 1
$LN26@PM_TestPla:

; 592  :                               }
; 593  : 
; 594  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$4[ebp], 0
	je	SHORT $LN29@PM_TestPla

; 595  : 				Matrix4x4_CreateFromEntity( matrix, pe->angles, pe->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$3[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN30@PM_TestPla
$LN29@PM_TestPla:

; 596  : 			else Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$3[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN30@PM_TestPla:

; 597  : 
; 598  : 			Matrix4x4_VectorITransform( matrix, pos, pos_l );

	lea	eax, DWORD PTR _pos_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$3[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 599  :                               
; 600  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$4[ebp], 0
	je	$LN6@PM_TestPla

; 601  : 			{
; 602  : 				World_TransformAABB( matrix, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324904]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	push	eax
	lea	ecx, DWORD PTR _matrix$3[ebp]
	push	ecx
	call	_World_TransformAABB
	add	esp, 20					; 00000014H

; 603  : 				VectorSubtract( hull->clip_mins, mins, offset );	// calc new local offset

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv431[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv431[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 604  : 
; 605  : 				for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@PM_TestPla
$LN5@PM_TestPla:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@PM_TestPla:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@PM_TestPla

; 606  : 				{
; 607  : 					if( pos_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN32@PM_TestPla

; 608  : 						pos_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _pos_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN33@PM_TestPla
$LN32@PM_TestPla:

; 609  : 					else pos_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _pos_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _pos_l$[ebp+edx*4], xmm0
$LN33@PM_TestPla:

; 610  : 				}

	jmp	SHORT $LN5@PM_TestPla
$LN6@PM_TestPla:

; 611  : 			}
; 612  : 		}

	jmp	$LN23@PM_TestPla
$LN22@PM_TestPla:

; 613  : 		else
; 614  : 		{
; 615  : 			// offset the test point appropriately for this hull.
; 616  : 			VectorSubtract( pos, offset, pos_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pos_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pos_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv471[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv471[ebp]
	movss	DWORD PTR _pos_l$[ebp+eax], xmm0
$LN23@PM_TestPla:

; 617  : 		}
; 618  : 
; 619  : 		if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	$LN34@PM_TestPla

; 620  : 		{
; 621  : 			pmtrace_t	trace;
; 622  : 
; 623  : 			memset( &trace, 0, sizeof( trace ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 624  : 			VectorCopy( pos, trace.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace$2[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace$2[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace$2[ebp+ecx+20], eax

; 625  : 			trace.allsolid = true;

	mov	DWORD PTR _trace$2[ebp], 1

; 626  : 			trace.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace$2[ebp+16], xmm0

; 627  : 
; 628  : 			// run custom sweep callback
; 629  : 			if( pmove->server || Host_IsLocalClient( ))

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN38@PM_TestPla
	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN36@PM_TestPla
$LN38@PM_TestPla:

; 630  : 				SV_ClipPMoveToEntity( pe, pos, mins, maxs, pos, &trace );

	lea	eax, DWORD PTR _trace$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_SV_ClipPMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN37@PM_TestPla
$LN36@PM_TestPla:

; 631  : 			else CL_ClipPMoveToEntity( pe, pos, mins, maxs, pos, &trace );

	lea	eax, DWORD PTR _trace$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_ClipPMoveToEntity
	add	esp, 24					; 00000018H
$LN37@PM_TestPla:

; 632  : 
; 633  : 			// if we inside the custom hull
; 634  : 			if( trace.allsolid )

	cmp	DWORD PTR _trace$2[ebp], 0
	je	SHORT $LN39@PM_TestPla

; 635  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@PM_TestPla
$LN39@PM_TestPla:

; 636  : 		}

	jmp	SHORT $LN9@PM_TestPla
$LN34@PM_TestPla:

; 637  : 		else if( hullcount == 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jne	SHORT $LN40@PM_TestPla

; 638  : 		{
; 639  : 			if( PM_HullPointContents( hull, hull->firstclipnode, pos_l ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _pos_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN42@PM_TestPla

; 640  : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@PM_TestPla
$LN42@PM_TestPla:

; 641  : 		}

	jmp	SHORT $LN9@PM_TestPla
$LN40@PM_TestPla:

; 642  : 		else
; 643  : 		{
; 644  : 			for( j = 0; j < hullcount; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@PM_TestPla
$LN8@PM_TestPla:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@PM_TestPla:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hullcount$[ebp]
	jge	SHORT $LN9@PM_TestPla

; 645  : 			{
; 646  : 				if( PM_HullPointContents( &hull[j], hull[j].firstclipnode, pos_l ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _pos_l$[ebp]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 40
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 40
	add	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN43@PM_TestPla

; 647  : 					return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@PM_TestPla
$LN43@PM_TestPla:

; 648  : 			}

	jmp	SHORT $LN8@PM_TestPla
$LN9@PM_TestPla:

; 649  : 		}
; 650  : 	}

	jmp	$LN2@PM_TestPla
$LN3@PM_TestPla:

; 651  : 
; 652  : 	return -1; // didn't hit anything

	or	eax, -1
$LN1@PM_TestPla:

; 653  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_TestPlayerPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_PlayerTraceExt
_TEXT	SEGMENT
tv769 = -444						; size = 4
tv619 = -444						; size = 4
tv598 = -444						; size = 4
tv541 = -444						; size = 4
tv388 = -444						; size = 4
tv352 = -444						; size = 4
tv298 = -444						; size = 4
tv262 = -444						; size = 4
_last_hitgroup$1 = -376					; size = 4
_hull$ = -372						; size = 4
_transform_bbox$ = -368					; size = 4
_rotated$ = -364					; size = 4
_hullcount$ = -360					; size = 4
_j$ = -356						; size = 4
_i$ = -352						; size = 4
_maxs$ = -348						; size = 12
_mins$ = -336						; size = 12
_temp$ = -324						; size = 12
_end_l$ = -312						; size = 12
_start_l$ = -300					; size = 12
_offset$ = -288						; size = 12
_trace_total$ = -276					; size = 68
_trace_hitbox$ = -208					; size = 68
_trace_bbox$ = -140					; size = 68
_matrix$ = -72						; size = 64
_pe$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddress$ = 8					; size = 4
_pmove$ = 12						; size = 4
_start$ = 16						; size = 4
_end$ = 20						; size = 4
_flags$ = 24						; size = 4
_numents$ = 28						; size = 4
_ents$ = 32						; size = 4
_ignore_pe$ = 36					; size = 4
_pmFilter$ = 40						; size = 4
_PM_PlayerTraceExt PROC					; COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 318  : 	physent_t	*pe;
; 319  : 	matrix4x4	matrix;
; 320  : 	pmtrace_t	trace_bbox;
; 321  : 	pmtrace_t	trace_hitbox;
; 322  : 	pmtrace_t	trace_total;
; 323  : 	vec3_t	offset, start_l, end_l;
; 324  : 	vec3_t	temp, mins, maxs;
; 325  : 	int	i, j, hullcount;
; 326  : 	qboolean	rotated, transform_bbox;
; 327  : 	hull_t	*hull = NULL;

	mov	DWORD PTR _hull$[ebp], 0

; 328  : 
; 329  : 	memset( &trace_total, 0, sizeof( trace_total ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace_total$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 330  : 	VectorCopy( end, trace_total.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_total$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_total$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_total$[ebp+ecx+20], eax

; 331  : 	trace_total.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_total$[ebp+16], xmm0

; 332  : 	trace_total.ent = -1;

	mov	DWORD PTR _trace_total$[ebp+48], -1

; 333  : 
; 334  : 	for( i = 0; i < numents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_PlayerT
$LN2@PM_PlayerT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_PlayerT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numents$[ebp]
	jge	$LN3@PM_PlayerT

; 335  : 	{
; 336  : 		pe = &ents[i];

	imul	eax, DWORD PTR _i$[ebp], 224
	add	eax, DWORD PTR _ents$[ebp]
	mov	DWORD PTR _pe$[ebp], eax

; 337  : 
; 338  : 		if( i != 0 && ( flags & PM_WORLD_ONLY ))

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN11@PM_PlayerT
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN11@PM_PlayerT

; 339  : 			break;

	jmp	$LN3@PM_PlayerT
$LN11@PM_PlayerT:

; 340  : 
; 341  : 		// run custom user filter
; 342  : 		if( pmFilter != NULL )

	cmp	DWORD PTR _pmFilter$[ebp], 0
	je	SHORT $LN12@PM_PlayerT

; 343  : 		{
; 344  : 			if( pmFilter( pe ))

	mov	eax, DWORD PTR _pe$[ebp]
	push	eax
	call	DWORD PTR _pmFilter$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN14@PM_PlayerT

; 345  : 				continue;

	jmp	SHORT $LN2@PM_PlayerT
$LN14@PM_PlayerT:

; 346  : 		}

	jmp	SHORT $LN16@PM_PlayerT
$LN12@PM_PlayerT:

; 347  : 		else if( ignore_pe != -1 )

	cmp	DWORD PTR _ignore_pe$[ebp], -1
	je	SHORT $LN16@PM_PlayerT

; 348  : 		{
; 349  : 			if( i == ignore_pe )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _ignore_pe$[ebp]
	jne	SHORT $LN16@PM_PlayerT

; 350  : 				continue;

	jmp	SHORT $LN2@PM_PlayerT
$LN16@PM_PlayerT:

; 351  : 		}
; 352  : 
; 353  : 		if( pe->model != NULL && pe->solid == SOLID_NOT && pe->skin != CONTENTS_NONE )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN17@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN17@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN17@PM_PlayerT

; 354  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN17@PM_PlayerT:

; 355  : 
; 356  : 		if(( flags & PM_GLASS_IGNORE ) && pe->rendermode != kRenderNormal )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN18@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN18@PM_PlayerT

; 357  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN18@PM_PlayerT:

; 358  : 
; 359  : 		if(( flags & PM_CUSTOM_IGNORE ) && pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN19@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	SHORT $LN19@PM_PlayerT

; 360  : 			continue;

	jmp	$LN2@PM_PlayerT
$LN19@PM_PlayerT:

; 361  : 
; 362  : 		hullcount = 1;

	mov	DWORD PTR _hullcount$[ebp], 1

; 363  : 
; 364  : 		if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	$LN20@PM_PlayerT

; 365  : 		{
; 366  : 			VectorCopy( pmove->player_mins[pmove->usehull], mins );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _mins$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _mins$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324856]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _mins$[ebp+eax], ecx

; 367  : 			VectorCopy( pmove->player_maxs[pmove->usehull], maxs );

	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR _maxs$[ebp+ecx], edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324904]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [eax+ecx]
	mov	DWORD PTR _maxs$[ebp+edx], eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+edx+324904]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _maxs$[ebp+eax], ecx

; 368  : 			VectorClear( offset );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 369  : 		}

	jmp	$LN25@PM_PlayerT
$LN20@PM_PlayerT:

; 370  : 		else if( pe->model )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN22@PM_PlayerT

; 371  : 		{
; 372  : 			hull = PM_HullForBsp( pe, pmove, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForBsp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 373  : 		}

	jmp	$LN25@PM_PlayerT
$LN22@PM_PlayerT:

; 374  : 		else
; 375  : 		{
; 376  : 			if( pe->studiomodel )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN24@PM_PlayerT

; 377  : 			{
; 378  : 				if( FBitSet( flags, PM_STUDIO_IGNORE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN26@PM_PlayerT

; 379  : 					continue;

	jmp	$LN2@PM_PlayerT
$LN26@PM_PlayerT:

; 380  : 
; 381  : 				if( PM_AllowHitBoxTrace( pe->studiomodel, pmove->usehull ) && !FBitSet( flags, PM_STUDIO_BOX ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN27@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN27@PM_PlayerT
	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 512				; 00000200H
	jne	SHORT $LN29@PM_PlayerT
	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+188], 2
	jne	SHORT $LN27@PM_PlayerT
$LN29@PM_PlayerT:
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	SHORT $LN27@PM_PlayerT

; 382  : 				{
; 383  : 					hull = PM_HullForStudio( pe, pmove, &hullcount );

	lea	eax, DWORD PTR _hullcount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pmove$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_PM_HullForStudio
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hull$[ebp], eax

; 384  : 					VectorClear( offset );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 385  : 				}

	jmp	$LN28@PM_PlayerT
$LN27@PM_PlayerT:

; 386  : 				else
; 387  : 				{
; 388  : 					VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324904]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+56]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv262[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv262[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 389  : 					VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324856]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv298[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv298[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0

; 390  : 
; 391  : 					hull = PM_HullForBox( mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 392  : 					VectorCopy( pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _offset$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _offset$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
$LN28@PM_PlayerT:

; 393  : 				}
; 394  : 			}			

	jmp	$LN25@PM_PlayerT
$LN24@PM_PlayerT:

; 395  : 			else
; 396  : 			{
; 397  : 				VectorSubtract( pe->mins, pmove->player_maxs[pmove->usehull], mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324904]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+56]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324904]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+56]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv352[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv352[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 398  : 				VectorSubtract( pe->maxs, pmove->player_mins[pmove->usehull], maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324856]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+68]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	eax, DWORD PTR _pmove$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+324856]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+68]
	subss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv388[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv388[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0

; 399  : 
; 400  : 				hull = PM_HullForBox( mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_PM_HullForBox
	add	esp, 8
	mov	DWORD PTR _hull$[ebp], eax

; 401  : 				VectorCopy( pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _offset$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _offset$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pe$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _offset$[ebp+ecx], eax
$LN25@PM_PlayerT:

; 402  : 			}
; 403  : 
; 404  : 		}
; 405  : 
; 406  : 		if( pe->solid == SOLID_BSP && !VectorIsNull( pe->angles ))

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 4
	jne	SHORT $LN30@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@PM_PlayerT
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+84]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@PM_PlayerT
$LN32@PM_PlayerT:

; 407  : 			rotated = true;

	mov	DWORD PTR _rotated$[ebp], 1
	jmp	SHORT $LN31@PM_PlayerT
$LN30@PM_PlayerT:

; 408  : 		else rotated = false;

	mov	DWORD PTR _rotated$[ebp], 0
$LN31@PM_PlayerT:

; 409  : 
; 410  : 		if( FBitSet( host.features, ENGINE_PHYSICS_PUSHER_EXT ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 8
	je	$LN33@PM_PlayerT

; 411  : 		{
; 412  : 			if(( check_angles( pe->angles[0] ) || check_angles( pe->angles[2] )) && pmove->usehull != 2 )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 90					; 0000005aH
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 180				; 000000b4H
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, 270				; 0000010eH
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -90				; ffffffa6H
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -180				; ffffff4cH
	je	$LN38@PM_PlayerT
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pe$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx+84]
	cmp	eax, -270				; fffffef2H
	je	$LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 90					; 0000005aH
	je	SHORT $LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 180				; 000000b4H
	je	SHORT $LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, 270				; 0000010eH
	je	SHORT $LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -90				; ffffffa6H
	je	SHORT $LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -180				; ffffff4cH
	je	SHORT $LN38@PM_PlayerT
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pe$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+84]
	cmp	edx, -270				; fffffef2H
	jne	SHORT $LN35@PM_PlayerT
$LN38@PM_PlayerT:
	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+188], 2
	je	SHORT $LN35@PM_PlayerT

; 413  : 				transform_bbox = true;

	mov	DWORD PTR _transform_bbox$[ebp], 1
	jmp	SHORT $LN36@PM_PlayerT
$LN35@PM_PlayerT:

; 414  : 			else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN36@PM_PlayerT:

; 415  : 		}

	jmp	SHORT $LN34@PM_PlayerT
$LN33@PM_PlayerT:

; 416  : 		else transform_bbox = false;

	mov	DWORD PTR _transform_bbox$[ebp], 0
$LN34@PM_PlayerT:

; 417  : 
; 418  : 		if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	$LN39@PM_PlayerT

; 419  : 		{
; 420  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	SHORT $LN41@PM_PlayerT

; 421  : 				Matrix4x4_CreateFromEntity( matrix, pe->angles, pe->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pe$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
	jmp	SHORT $LN42@PM_PlayerT
$LN41@PM_PlayerT:

; 422  : 			else Matrix4x4_CreateFromEntity( matrix, pe->angles, offset, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pe$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H
$LN42@PM_PlayerT:

; 423  : 
; 424  : 			Matrix4x4_VectorITransform( matrix, start, start_l );

	lea	eax, DWORD PTR _start_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 425  : 			Matrix4x4_VectorITransform( matrix, end, end_l );

	lea	eax, DWORD PTR _end_l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrix$[ebp]
	push	edx
	call	_Matrix4x4_VectorITransform
	add	esp, 12					; 0000000cH

; 426  :                               
; 427  : 			if( transform_bbox )

	cmp	DWORD PTR _transform_bbox$[ebp], 0
	je	$LN6@PM_PlayerT

; 428  : 			{
; 429  : 				World_TransformAABB( matrix, pmove->player_mins[pmove->usehull], pmove->player_maxs[pmove->usehull], mins, maxs );

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+eax+324904]
	push	edx
	mov	eax, DWORD PTR _pmove$[ebp]
	imul	ecx, DWORD PTR [eax+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+ecx+324856]
	push	eax
	lea	ecx, DWORD PTR _matrix$[ebp]
	push	ecx
	call	_World_TransformAABB
	add	esp, 20					; 00000014H

; 430  : 				VectorSubtract( hull->clip_mins, mins, offset );	// calc new local offset

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _offset$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR _mins$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _offset$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _mins$[ebp+ecx]
	movss	DWORD PTR tv541[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv541[ebp]
	movss	DWORD PTR _offset$[ebp+eax], xmm0

; 431  : 
; 432  : 				for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@PM_PlayerT
$LN5@PM_PlayerT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@PM_PlayerT:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@PM_PlayerT

; 433  : 				{
; 434  : 					if( start_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN44@PM_PlayerT

; 435  : 						start_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN45@PM_PlayerT
$LN44@PM_PlayerT:

; 436  : 					else start_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _start_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _start_l$[ebp+edx*4], xmm0
$LN45@PM_PlayerT:

; 437  : 					if( end_l[j] >= 0.0f )

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN46@PM_PlayerT

; 438  : 						end_l[j] -= offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
	jmp	SHORT $LN47@PM_PlayerT
$LN46@PM_PlayerT:

; 439  : 					else end_l[j] += offset[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _end_l$[ebp+eax*4]
	addss	xmm0, DWORD PTR _offset$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _end_l$[ebp+edx*4], xmm0
$LN47@PM_PlayerT:

; 440  : 				}

	jmp	$LN5@PM_PlayerT
$LN6@PM_PlayerT:

; 441  : 			}
; 442  : 		}

	jmp	$LN40@PM_PlayerT
$LN39@PM_PlayerT:

; 443  : 		else
; 444  : 		{
; 445  : 			VectorSubtract( start, offset, start_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _start_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _start_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv598[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv598[ebp]
	movss	DWORD PTR _start_l$[ebp+eax], xmm0

; 446  : 			VectorSubtract( end, offset, end_l );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _end_l$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _offset$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _end_l$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _offset$[ebp+ecx]
	movss	DWORD PTR tv619[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv619[ebp]
	movss	DWORD PTR _end_l$[ebp+eax], xmm0
$LN40@PM_PlayerT:

; 447  : 		}
; 448  : 
; 449  : 		memset( &trace_bbox, 0, sizeof( trace_bbox ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 450  : 		VectorCopy( end, trace_bbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_bbox$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_bbox$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_bbox$[ebp+ecx+20], eax

; 451  : 		trace_bbox.allsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp], 1

; 452  : 		trace_bbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_bbox$[ebp+16], xmm0

; 453  : 
; 454  : 		if( hullcount < 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jge	SHORT $LN48@PM_PlayerT

; 455  : 		{
; 456  : 			// g-cont. probably this never happens
; 457  : 			trace_bbox.allsolid = false;

	mov	DWORD PTR _trace_bbox$[ebp], 0

; 458  : 		}

	jmp	$LN56@PM_PlayerT
$LN48@PM_PlayerT:

; 459  : 		else if( pe->solid == SOLID_CUSTOM )

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+96], 5
	jne	SHORT $LN50@PM_PlayerT

; 460  : 		{
; 461  : 			// run custom sweep callback
; 462  : 			if( pmove->server || Host_IsLocalClient( ))

	mov	eax, DWORD PTR _pmove$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN54@PM_PlayerT
	call	_Host_IsLocalClient
	test	eax, eax
	je	SHORT $LN52@PM_PlayerT
$LN54@PM_PlayerT:

; 463  : 				SV_ClipPMoveToEntity( pe, start, mins, maxs, end, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_SV_ClipPMoveToEntity
	add	esp, 24					; 00000018H
	jmp	SHORT $LN53@PM_PlayerT
$LN52@PM_PlayerT:

; 464  : 			else CL_ClipPMoveToEntity( pe, start, mins, maxs, end, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _mins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pe$[ebp]
	push	edx
	call	_CL_ClipPMoveToEntity
	add	esp, 24					; 00000018H
$LN53@PM_PlayerT:

; 465  : 		}

	jmp	$LN56@PM_PlayerT
$LN50@PM_PlayerT:

; 466  : 		else if( hullcount == 1 )

	cmp	DWORD PTR _hullcount$[ebp], 1
	jne	SHORT $LN55@PM_PlayerT

; 467  : 		{
; 468  : 			PM_RecursiveHullCheck( hull, hull->firstclipnode, 0, 1, start_l, end_l, &trace_bbox );

	lea	eax, DWORD PTR _trace_bbox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	push	edx
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 469  : 		}

	jmp	$LN56@PM_PlayerT
$LN55@PM_PlayerT:

; 470  : 		else
; 471  : 		{
; 472  : 			int	last_hitgroup;
; 473  : 
; 474  : 			for( last_hitgroup = 0, j = 0; j < hullcount; j++ )

	mov	DWORD PTR _last_hitgroup$1[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@PM_PlayerT
$LN8@PM_PlayerT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@PM_PlayerT:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hullcount$[ebp]
	jge	$LN9@PM_PlayerT

; 475  : 			{
; 476  : 				memset( &trace_hitbox, 0, sizeof( trace_hitbox ));

	push	68					; 00000044H
	push	0
	lea	eax, DWORD PTR _trace_hitbox$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 477  : 				VectorCopy( end, trace_hitbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _trace_hitbox$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _trace_hitbox$[ebp+ecx+20], eax

; 478  : 				trace_hitbox.allsolid = true;

	mov	DWORD PTR _trace_hitbox$[ebp], 1

; 479  : 				trace_hitbox.fraction = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _trace_hitbox$[ebp+16], xmm0

; 480  : 
; 481  : 				PM_RecursiveHullCheck( &hull[j], hull[j].firstclipnode, 0, 1, start_l, end_l, &trace_hitbox );

	lea	eax, DWORD PTR _trace_hitbox$[ebp]
	push	eax
	lea	ecx, DWORD PTR _end_l$[ebp]
	push	ecx
	lea	edx, DWORD PTR _start_l$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _j$[ebp], 40
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	push	edx
	imul	eax, DWORD PTR _j$[ebp], 40
	add	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH

; 482  : 
; 483  : 				if( j == 0 || trace_hitbox.allsolid || trace_hitbox.startsolid || trace_hitbox.fraction < trace_bbox.fraction )

	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $LN58@PM_PlayerT
	cmp	DWORD PTR _trace_hitbox$[ebp], 0
	jne	SHORT $LN58@PM_PlayerT
	cmp	DWORD PTR _trace_hitbox$[ebp+4], 0
	jne	SHORT $LN58@PM_PlayerT
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	comiss	xmm0, DWORD PTR _trace_hitbox$[ebp+16]
	jbe	SHORT $LN57@PM_PlayerT
$LN58@PM_PlayerT:

; 484  : 				{
; 485  : 					if( trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	je	SHORT $LN59@PM_PlayerT

; 486  : 					{
; 487  : 						trace_bbox = trace_hitbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	lea	edi, DWORD PTR _trace_bbox$[ebp]
	rep movsd

; 488  : 						trace_bbox.startsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp+4], 1

; 489  : 					}

	jmp	SHORT $LN60@PM_PlayerT
$LN59@PM_PlayerT:

; 490  : 					else trace_bbox = trace_hitbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_hitbox$[ebp]
	lea	edi, DWORD PTR _trace_bbox$[ebp]
	rep movsd
$LN60@PM_PlayerT:

; 491  : 
; 492  : 					last_hitgroup = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _last_hitgroup$1[ebp], eax
$LN57@PM_PlayerT:

; 493  : 				}
; 494  : 			}

	jmp	$LN8@PM_PlayerT
$LN9@PM_PlayerT:

; 495  : 
; 496  : 			trace_bbox.hitgroup = Mod_HitgroupForStudioHull( last_hitgroup );

	mov	eax, DWORD PTR _last_hitgroup$1[ebp]
	push	eax
	call	_Mod_HitgroupForStudioHull
	add	esp, 4
	mov	DWORD PTR _trace_bbox$[ebp+64], eax
$LN56@PM_PlayerT:

; 497  : 		}
; 498  : 
; 499  : 		if( trace_bbox.allsolid )

	cmp	DWORD PTR _trace_bbox$[ebp], 0
	je	SHORT $LN61@PM_PlayerT

; 500  : 			trace_bbox.startsolid = true;

	mov	DWORD PTR _trace_bbox$[ebp+4], 1
$LN61@PM_PlayerT:

; 501  : 
; 502  : 		if( trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	je	SHORT $LN62@PM_PlayerT

; 503  : 			trace_bbox.fraction = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _trace_bbox$[ebp+16], xmm0
$LN62@PM_PlayerT:

; 504  : 
; 505  : 		if( !trace_bbox.startsolid )

	cmp	DWORD PTR _trace_bbox$[ebp+4], 0
	jne	$LN65@PM_PlayerT

; 506  : 		{
; 507  : 			VectorLerp( start, trace_bbox.fraction, end, trace_bbox.endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _trace_bbox$[ebp+edx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _trace_bbox$[ebp+edx+20], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv769[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv769[ebp]
	movss	DWORD PTR _trace_bbox$[ebp+edx+20], xmm0

; 508  : 
; 509  : 			if( rotated )

	cmp	DWORD PTR _rotated$[ebp], 0
	je	SHORT $LN64@PM_PlayerT

; 510  : 			{
; 511  : 				VectorCopy( trace_bbox.plane.normal, temp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _trace_bbox$[ebp+ecx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace_bbox$[ebp+edx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace_bbox$[ebp+edx+32]
	mov	DWORD PTR _temp$[ebp+eax], ecx

; 512  : 				Matrix4x4_TransformPositivePlane( matrix, temp, trace_bbox.plane.dist, trace_bbox.plane.normal, &trace_bbox.plane.dist );

	lea	eax, DWORD PTR _trace_bbox$[ebp+44]
	push	eax
	lea	ecx, DWORD PTR _trace_bbox$[ebp+32]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+44]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	lea	eax, DWORD PTR _matrix$[ebp]
	push	eax
	call	_Matrix4x4_TransformPositivePlane
	add	esp, 20					; 00000014H

; 513  : 			}

	jmp	SHORT $LN65@PM_PlayerT
$LN64@PM_PlayerT:

; 514  : 			else
; 515  : 			{
; 516  : 				trace_bbox.plane.dist = DotProduct( trace_bbox.endpos, trace_bbox.plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _trace_bbox$[ebp+ecx+20]
	mulss	xmm0, DWORD PTR _trace_bbox$[ebp+eax+32]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _trace_bbox$[ebp+ecx+20]
	mulss	xmm1, DWORD PTR _trace_bbox$[ebp+edx+32]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _trace_bbox$[ebp+eax+20]
	mulss	xmm1, DWORD PTR _trace_bbox$[ebp+ecx+32]
	addss	xmm0, xmm1
	movss	DWORD PTR _trace_bbox$[ebp+44], xmm0
$LN65@PM_PlayerT:

; 517  : 			}
; 518  : 		}
; 519  : 
; 520  : 		if( trace_bbox.fraction < trace_total.fraction )

	movss	xmm0, DWORD PTR _trace_total$[ebp+16]
	comiss	xmm0, DWORD PTR _trace_bbox$[ebp+16]
	jbe	SHORT $LN66@PM_PlayerT

; 521  : 		{
; 522  : 			trace_total = trace_bbox;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_bbox$[ebp]
	lea	edi, DWORD PTR _trace_total$[ebp]
	rep movsd

; 523  : 			trace_total.ent = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _trace_total$[ebp+48], eax
$LN66@PM_PlayerT:

; 524  : 		}
; 525  : 	}

	jmp	$LN2@PM_PlayerT
$LN3@PM_PlayerT:

; 526  : 
; 527  : 	return trace_total;

	mov	ecx, 17					; 00000011H
	lea	esi, DWORD PTR _trace_total$[ebp]
	mov	edi, DWORD PTR __$ReturnAddress$[ebp]
	rep movsd
	mov	eax, DWORD PTR __$ReturnAddress$[ebp]

; 528  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_PlayerTraceExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_RecursiveHullCheck
_TEXT	SEGMENT
tv399 = -112						; size = 4
tv331 = -112						; size = 4
tv251 = -112						; size = 4
tv198 = -112						; size = 4
tv181 = -112						; size = 4
tv149 = -112						; size = 4
_mid$ = -44						; size = 12
_side$ = -32						; size = 4
_midf$ = -28						; size = 4
_frac$ = -24						; size = 4
_t2$ = -20						; size = 4
_t1$ = -16						; size = 4
_plane$ = -12						; size = 4
_node$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hull$ = 8						; size = 4
_num$ = 12						; size = 4
_p1f$ = 16						; size = 4
_p2f$ = 20						; size = 4
_p1$ = 24						; size = 4
_p2$ = 28						; size = 4
_trace$ = 32						; size = 4
_PM_RecursiveHullCheck PROC				; COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
$loc0$32:

; 203  : 	mclipnode_t	*node;
; 204  : 	mplane_t		*plane;
; 205  : 	float		t1, t2;
; 206  : 	float		frac, midf;
; 207  : 	int		side;
; 208  : 	vec3_t		mid;
; 209  : loc0:
; 210  : 	// check for empty
; 211  : 	if( num < 0 )

	cmp	DWORD PTR _num$[ebp], 0
	jge	SHORT $LN4@PM_Recursi

; 212  : 	{
; 213  : 		if( num != CONTENTS_SOLID )

	cmp	DWORD PTR _num$[ebp], -2		; fffffffeH
	je	SHORT $LN5@PM_Recursi

; 214  : 		{
; 215  : 			trace->allsolid = false;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 0

; 216  : 			if( num == CONTENTS_EMPTY )

	cmp	DWORD PTR _num$[ebp], -1
	jne	SHORT $LN7@PM_Recursi

; 217  : 				trace->inopen = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+8], 1
	jmp	SHORT $LN8@PM_Recursi
$LN7@PM_Recursi:

; 218  : 			else trace->inwater = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+12], 1
$LN8@PM_Recursi:

; 219  : 		}

	jmp	SHORT $LN6@PM_Recursi
$LN5@PM_Recursi:

; 220  : 		else trace->startsolid = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+4], 1
$LN6@PM_Recursi:

; 221  : 		return true; // empty

	mov	eax, 1
	jmp	$LN1@PM_Recursi
$LN4@PM_Recursi:

; 222  : 	}
; 223  : 
; 224  : 	if( hull->firstclipnode >= hull->lastclipnode )

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jl	SHORT $LN9@PM_Recursi

; 225  : 	{
; 226  : 		// empty hull?
; 227  : 		trace->allsolid = false;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax], 0

; 228  : 		trace->inopen = true;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	DWORD PTR [eax+8], 1

; 229  : 		return true;

	mov	eax, 1
	jmp	$LN1@PM_Recursi
$LN9@PM_Recursi:

; 230  : 	}
; 231  : 
; 232  : 	if( num < hull->firstclipnode || num > hull->lastclipnode )

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN11@PM_Recursi
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _num$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jle	SHORT $LN10@PM_Recursi
$LN11@PM_Recursi:

; 233  : 		Host_Error( "PM_RecursiveHullCheck: bad node number %i\n", num );

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@GOJPIGLN@PM_RecursiveHullCheck?3?5bad?5node@
	call	_Host_Error
	add	esp, 8
$LN10@PM_Recursi:

; 234  : 		
; 235  : 	// find the point distances
; 236  : 	node = hull->clipnodes + num;

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _num$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _node$[ebp], eax

; 237  : 	plane = hull->planes + node->planenum;

	mov	eax, DWORD PTR _node$[ebp]
	imul	ecx, DWORD PTR [eax], 20
	mov	edx, DWORD PTR _hull$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _plane$[ebp], ecx

; 238  : 
; 239  : 	t1 = PlaneDiff( p1, plane );

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN25@PM_Recursi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv149[ebp], xmm0
	jmp	SHORT $LN26@PM_Recursi
$LN25@PM_Recursi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p1$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv149[ebp], xmm0
$LN26@PM_Recursi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _t1$[ebp], xmm0

; 240  : 	t2 = PlaneDiff( p2, plane );

	mov	eax, DWORD PTR _plane$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 3
	jge	SHORT $LN27@PM_Recursi
	mov	edx, DWORD PTR _plane$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	mov	ecx, DWORD PTR _p2$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR tv181[ebp], xmm0
	jmp	SHORT $LN28@PM_Recursi
$LN27@PM_Recursi:
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	movss	DWORD PTR tv181[ebp], xmm0
$LN28@PM_Recursi:
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	subss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _t2$[ebp], xmm0

; 241  : 
; 242  : 	if( t1 >= 0.0f && t2 >= 0.0f )

	movss	xmm0, DWORD PTR _t1$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@PM_Recursi
	movss	xmm0, DWORD PTR _t2$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@PM_Recursi

; 243  : 	{
; 244  : 		num = node->children[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+ecx+4]
	mov	DWORD PTR _num$[ebp], eax

; 245  : 		goto loc0;

	jmp	$loc0$32
$LN12@PM_Recursi:

; 246  : 	}
; 247  : 
; 248  : 	if( t1 < 0.0f && t2 < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN13@PM_Recursi
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t2$[ebp]
	jbe	SHORT $LN13@PM_Recursi

; 249  : 	{
; 250  : 		num = node->children[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax+4]
	mov	DWORD PTR _num$[ebp], edx

; 251  : 		goto loc0;

	jmp	$loc0$32
$LN13@PM_Recursi:

; 252  : 	}
; 253  : 
; 254  : 	// put the crosspoint DIST_EPSILON pixels on the near side
; 255  : 	side = (t1 < 0.0f);

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _t1$[ebp]
	jbe	SHORT $LN29@PM_Recursi
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN30@PM_Recursi
$LN29@PM_Recursi:
	mov	DWORD PTR tv198[ebp], 0
$LN30@PM_Recursi:
	mov	eax, DWORD PTR tv198[ebp]
	mov	DWORD PTR _side$[ebp], eax

; 256  : 
; 257  : 	if( side ) frac = ( t1 + DIST_EPSILON ) / ( t1 - t2 );

	cmp	DWORD PTR _side$[ebp], 0
	je	SHORT $LN14@PM_Recursi
	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR __real@3d000000
	movss	xmm1, DWORD PTR _t1$[ebp]
	subss	xmm1, DWORD PTR _t2$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
	jmp	SHORT $LN15@PM_Recursi
$LN14@PM_Recursi:

; 258  : 	else frac = ( t1 - DIST_EPSILON ) / ( t1 - t2 );

	movss	xmm0, DWORD PTR _t1$[ebp]
	subss	xmm0, DWORD PTR __real@3d000000
	movss	xmm1, DWORD PTR _t1$[ebp]
	subss	xmm1, DWORD PTR _t2$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
$LN15@PM_Recursi:

; 259  : 
; 260  : 	if( frac < 0.0f ) frac = 0.0f;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN16@PM_Recursi
	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0
$LN16@PM_Recursi:

; 261  : 	if( frac > 1.0f ) frac = 1.0f;

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN17@PM_Recursi
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN17@PM_Recursi:

; 262  : 		
; 263  : 	midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 264  : 	VectorLerp( p1, frac, p2, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv251[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv251[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 265  : 
; 266  : 	// move up to the node
; 267  : 	if( !PM_RecursiveHullCheck( hull, node->children[side], p1f, midf, p1, mid, trace ))

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p1$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN18@PM_Recursi

; 268  : 		return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN18@PM_Recursi:

; 269  : 
; 270  : 	// this recursion can not be optimized because mid would need to be duplicated on a stack
; 271  : 	if( PM_HullPointContents( hull, node->children[side^1], mid ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+4]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN19@PM_Recursi

; 272  : 	{
; 273  : 		// go past the node
; 274  : 		return PM_RecursiveHullCheck( hull, node->children[side^1], midf, p2f, mid, p2, trace );

	mov	eax, DWORD PTR _trace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mid$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _p2f$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_RecursiveHullCheck
	add	esp, 28					; 0000001cH
	jmp	$LN1@PM_Recursi
$LN19@PM_Recursi:

; 275  : 	}	
; 276  : 
; 277  : 	// never got out of the solid area
; 278  : 	if( trace->allsolid )

	mov	eax, DWORD PTR _trace$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@PM_Recursi

; 279  : 		return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN20@PM_Recursi:

; 280  : 		
; 281  : 	// the other side of the node is solid, this is the impact point
; 282  : 	if( !side )

	cmp	DWORD PTR _side$[ebp], 0
	jne	SHORT $LN21@PM_Recursi

; 283  : 	{
; 284  : 		VectorCopy( plane->normal, trace->plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	esi, DWORD PTR _plane$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+32], eax

; 285  : 		trace->plane.dist = plane->dist;

	mov	eax, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _plane$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+44], edx

; 286  : 	}

	jmp	$LN22@PM_Recursi
$LN21@PM_Recursi:

; 287  : 	else
; 288  : 	{
; 289  : 		VectorNegate( plane->normal, trace->plane.normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [edx+ecx+32], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [eax+edx+32], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR tv331[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR tv331[ebp]
	movss	DWORD PTR [ecx+eax+32], xmm0

; 290  : 		trace->plane.dist = -plane->dist;

	mov	eax, DWORD PTR _plane$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _trace$[ebp]
	movss	DWORD PTR [ecx+44], xmm0
$LN22@PM_Recursi:

; 291  : 	}
; 292  : 
; 293  : 	while( PM_HullPointContents( hull, hull->firstclipnode, mid ) == CONTENTS_SOLID )

	lea	eax, DWORD PTR _mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_PM_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	jne	$LN3@PM_Recursi

; 294  : 	{
; 295  : 		// shouldn't really happen, but does occasionally
; 296  : 		frac -= 0.1f;

	movss	xmm0, DWORD PTR _frac$[ebp]
	subss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _frac$[ebp], xmm0

; 297  : 
; 298  : 		if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN23@PM_Recursi

; 299  : 		{
; 300  : 			trace->fraction = midf;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 301  : 			VectorCopy( mid, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _mid$[ebp+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 302  : 			Con_Reportf( S_WARN "trace backed up past 0.0\n" );

	push	OFFSET ??_C@_0CH@OBLIICFO@?$FO3Warning?3?$FO7?5trace?5backed?5up?5pa@
	call	_Con_Reportf
	add	esp, 4

; 303  : 			return false;

	xor	eax, eax
	jmp	$LN1@PM_Recursi
$LN23@PM_Recursi:

; 304  : 		}
; 305  : 
; 306  : 		midf = p1f + ( p2f - p1f ) * frac;

	movss	xmm0, DWORD PTR _p2f$[ebp]
	subss	xmm0, DWORD PTR _p1f$[ebp]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	addss	xmm0, DWORD PTR _p1f$[ebp]
	movss	DWORD PTR _midf$[ebp], xmm0

; 307  : 		VectorLerp( p1, frac, p2, mid );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	eax, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _mid$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _p2$[ebp]
	mov	edi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _frac$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv399[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv399[ebp]
	movss	DWORD PTR _mid$[ebp+edx], xmm0

; 308  : 	}

	jmp	$LN22@PM_Recursi
$LN3@PM_Recursi:

; 309  : 
; 310  : 	trace->fraction = midf;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR _midf$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 311  : 	VectorCopy( mid, trace->endpos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp+ecx]
	mov	DWORD PTR [edx+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR _mid$[ebp+edx]
	mov	DWORD PTR [ecx+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR _mid$[ebp+eax]
	mov	DWORD PTR [edx+ecx+20], eax

; 312  : 
; 313  : 	return false;

	xor	eax, eax
$LN1@PM_Recursi:

; 314  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_RecursiveHullCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_HullForBsp
_TEXT	SEGMENT
tv201 = -72						; size = 4
tv177 = -72						; size = 4
tv140 = -72						; size = 4
tv82 = -72						; size = 4
tv79 = -72						; size = 4
tv70 = -72						; size = 4
_hull$ = -4						; size = 4
_pe$ = 8						; size = 4
_pmove$ = 12						; size = 4
_offset$ = 16						; size = 4
_PM_HullForBsp PROC					; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 149  : 	hull_t	*hull;
; 150  : 
; 151  : 	Assert( pe != NULL );

	cmp	DWORD PTR _pe$[ebp], 0
	je	SHORT $LN9@PM_HullFor
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@PM_HullFor
$LN9@PM_HullFor:
	mov	DWORD PTR tv70[ebp], 0
$LN10@PM_HullFor:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??PM_HullForBsp@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@BKPNJPAO@pe?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 152  : 	Assert( pe->model != NULL );

	mov	eax, DWORD PTR _pe$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN11@PM_HullFor
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN12@PM_HullFor
$LN11@PM_HullFor:
	mov	DWORD PTR tv79[ebp], 0
$LN12@PM_HullFor:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??PM_HullForBsp@@9@9
	add	ecx, 4
	push	ecx
	push	OFFSET ??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BC@HNKHKKMI@pe?9?$DOmodel?5?$CB?$DN?5NULL@
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 153  : 
; 154  : 	switch( pmove->usehull )

	mov	eax, DWORD PTR _pmove$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR tv82[ebp], ecx
	cmp	DWORD PTR tv82[ebp], 1
	je	SHORT $LN4@PM_HullFor
	cmp	DWORD PTR tv82[ebp], 2
	je	SHORT $LN5@PM_HullFor
	cmp	DWORD PTR tv82[ebp], 3
	je	SHORT $LN6@PM_HullFor
	jmp	SHORT $LN7@PM_HullFor
$LN4@PM_HullFor:

; 155  : 	{
; 156  : 	case 1:
; 157  : 		hull = &pe->model->hulls[3];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 3
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx

; 158  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN5@PM_HullFor:

; 159  : 	case 2:
; 160  : 		hull = &pe->model->hulls[0];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+208]
	mov	DWORD PTR _hull$[ebp], ecx

; 161  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN6@PM_HullFor:

; 162  : 	case 3:
; 163  : 		hull = &pe->model->hulls[2];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	shl	edx, 1
	lea	eax, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _hull$[ebp], eax

; 164  : 		break;

	jmp	SHORT $LN2@PM_HullFor
$LN7@PM_HullFor:

; 165  : 	default:
; 166  : 		hull = &pe->model->hulls[1];

	mov	eax, DWORD PTR _pe$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, 40					; 00000028H
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+208]
	mov	DWORD PTR _hull$[ebp], eax
$LN2@PM_HullFor:

; 167  : 		break;
; 168  : 	}
; 169  : 
; 170  : 	Assert( hull != NULL );

	cmp	DWORD PTR _hull$[ebp], 0
	je	SHORT $LN13@PM_HullFor
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN14@PM_HullFor
$LN13@PM_HullFor:
	mov	DWORD PTR tv140[ebp], 0
$LN14@PM_HullFor:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??PM_HullForBsp@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DF@EHDBJAKD@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@MOOOOKHB@hull?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv140[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 171  : 
; 172  : 	// calculate an offset value to center the origin
; 173  : 	VectorSubtract( hull->clip_mins, pmove->player_mins[pmove->usehull], offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324856]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+16]
	subss	xmm0, DWORD PTR [eax+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pmove$[ebp]
	imul	edx, DWORD PTR [ecx+188], 12
	mov	ecx, DWORD PTR _pmove$[ebp]
	lea	edx, DWORD PTR [ecx+edx+324856]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+16]
	subss	xmm0, DWORD PTR [edx+ecx]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pmove$[ebp]
	imul	eax, DWORD PTR [edx+188], 12
	mov	edx, DWORD PTR _pmove$[ebp]
	lea	eax, DWORD PTR [edx+eax+324856]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _hull$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+16]
	subss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv177[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv177[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 174  : 	VectorAdd( offset, pe->origin, offset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR [esi+eax+36]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR [esi+ecx+36]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _offset$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	esi, DWORD PTR _pe$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [esi+eax+36]
	movss	DWORD PTR tv201[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _offset$[ebp]
	movss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 175  : 
; 176  : 	return hull;

	mov	eax, DWORD PTR _hull$[ebp]

; 177  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_HullForBsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _PM_InitBoxHull
_TEXT	SEGMENT
_side$ = -8						; size = 4
_i$ = -4						; size = 4
_PM_InitBoxHull PROC					; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 68   : 	int	i, side;
; 69   : 
; 70   : 	pm_boxhull.clipnodes = pm_boxclipnodes;

	mov	DWORD PTR _pm_boxhull, OFFSET _pm_boxclipnodes

; 71   : 	pm_boxhull.planes = pm_boxplanes;

	mov	DWORD PTR _pm_boxhull+4, OFFSET _pm_boxplanes

; 72   : 	pm_boxhull.firstclipnode = 0;

	mov	DWORD PTR _pm_boxhull+8, 0

; 73   : 	pm_boxhull.lastclipnode = 5;

	mov	DWORD PTR _pm_boxhull+12, 5

; 74   : 
; 75   : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@PM_InitBox
$LN2@PM_InitBox:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@PM_InitBox:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN3@PM_InitBox

; 76   : 	{
; 77   : 		pm_boxclipnodes[i].planenum = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pm_boxclipnodes[eax*8], ecx

; 78   : 		
; 79   : 		side = i & 1;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	mov	DWORD PTR _side$[ebp], eax

; 80   : 		
; 81   : 		pm_boxclipnodes[i].children[side] = CONTENTS_EMPTY;

	mov	eax, DWORD PTR _side$[ebp]
	shl	eax, 1
	or	ecx, -1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[eax+edx*8+4], cx

; 82   : 		if( i != 5 ) pm_boxclipnodes[i].children[side^1] = i + 1;

	cmp	DWORD PTR _i$[ebp], 5
	je	SHORT $LN5@PM_InitBox
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _side$[ebp]
	xor	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[ecx+edx*8+4], ax
	jmp	SHORT $LN6@PM_InitBox
$LN5@PM_InitBox:

; 83   : 		else pm_boxclipnodes[i].children[side^1] = CONTENTS_SOLID;

	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	shl	eax, 1
	mov	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _i$[ebp]
	mov	WORD PTR _pm_boxclipnodes[eax+edx*8+4], cx
$LN6@PM_InitBox:

; 84   : 		
; 85   : 		pm_boxplanes[i].type = i>>1;

	mov	eax, DWORD PTR _i$[ebp]
	sar	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _pm_boxplanes[ecx+16], al

; 86   : 		pm_boxplanes[i].normal[i>>1] = 1.0f;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	ecx, DWORD PTR _i$[ebp]
	sar	ecx, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _pm_boxplanes[eax+ecx*4], xmm0

; 87   : 		pm_boxplanes[i].signbits = 0;

	imul	eax, DWORD PTR _i$[ebp], 20
	mov	BYTE PTR _pm_boxplanes[eax+17], 0

; 88   : 	}

	jmp	$LN2@PM_InitBox
$LN3@PM_InitBox:

; 89   : 	
; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PM_InitBoxHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\pm_trace.c
;	COMDAT _Pmove_Init
_TEXT	SEGMENT
_Pmove_Init PROC					; COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 51   : 	PM_InitBoxHull ();

	call	_PM_InitBoxHull

; 52   : 
; 53   : 	// init default hull sizes
; 54   : 	memcpy( host.player_mins, pm_hullmins, sizeof( pm_hullmins ));

	push	48					; 00000030H
	push	OFFSET _pm_hullmins
	push	OFFSET _host+34236
	call	_memcpy
	add	esp, 12					; 0000000cH

; 55   : 	memcpy( host.player_maxs, pm_hullmaxs, sizeof( pm_hullmaxs ));

	push	48					; 00000030H
	push	OFFSET _pm_hullmaxs
	push	OFFSET _host+34284
	call	_memcpy
	add	esp, 12					; 0000000cH

; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Pmove_Init ENDP
_TEXT	ENDS
END
