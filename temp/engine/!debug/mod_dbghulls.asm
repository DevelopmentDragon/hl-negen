; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\mod_dbghulls.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_Mod_InitDebugHulls
PUBLIC	_Mod_CreatePolygonsForHull
PUBLIC	_Mod_ReleaseHullPolygons
PUBLIC	_R_DrawWorldHull
PUBLIC	_R_DrawModelHull
PUBLIC	??_C@_0CF@COKMLMAP@free_winding?3?5freed?5a?5freed?5win@ ; `string'
PUBLIC	??_C@_0CE@GHCKIFEI@BaseWindingForPlane?3?5no?5axis?5fo@ ; `string'
PUBLIC	??_C@_0BF@PPBLHIAG@node?5stack?5overflow?6@	; `string'
PUBLIC	??_C@_0BG@LGHIECPN@node?5stack?5underflow?6@	; `string'
PUBLIC	??_C@_0BC@KFHKEHHE@bad?5contents?3?5?$CFi?6@	; `string'
PUBLIC	?__LINE__Var@?0??hull_windings_r@@9@9		; `hull_windings_r'::`1'::__LINE__Var
PUBLIC	??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_0CM@HFDKAEGF@?$FO3Warning?3?$FO7?5new?5winding?5was?5cl@ ; `string'
PUBLIC	??_C@_0BB@BFIDKCBM@?$CFi?5clipnodes?4?4?4?6@	; `string'
PUBLIC	??_C@_0P@NICNHBLD@?$CFi?5hull?5polys?6@		; `string'
PUBLIC	?__LINE__Var@?0??Mod_InitDebugHulls@@9@9	; `Mod_InitDebugHulls'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@EHPEPKLJ@generating?5polygons?5for?5hull?5?$CFu@ ; `string'
PUBLIC	??_C@_03JLINDLFM@?$CK?$CFi@			; `string'
PUBLIC	??_C@_0BG@DOCAAMMN@build?5time?5?$CF?43f?5secs?6@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3d23d70a
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@47deb852
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c7deb852
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__atoi:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_Mod_FindName:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_world:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_r_showhull:DWORD
EXTRN	_RI:BYTE
EXTRN	_cl:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_node_stack DD	0100H DUP (?)
_side_stack DD	0100H DUP (?)
_node_stack_depth DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c7deb852
CONST	SEGMENT
__real@c7deb852 DD 0c7deb852r			; -114033
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@47deb852
CONST	SEGMENT
__real@47deb852 DD 047deb852r			; 114033
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d23d70a
CONST	SEGMENT
__real@3d23d70a DD 03d23d70ar			; 0.04
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BG@DOCAAMMN@build?5time?5?$CF?43f?5secs?6@
CONST	SEGMENT
??_C@_0BG@DOCAAMMN@build?5time?5?$CF?43f?5secs?6@ DB 'build time %.3f sec'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JLINDLFM@?$CK?$CFi@
CONST	SEGMENT
??_C@_03JLINDLFM@?$CK?$CFi@ DB '*%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EHPEPKLJ@generating?5polygons?5for?5hull?5?$CFu@
CONST	SEGMENT
??_C@_0CE@EHPEPKLJ@generating?5polygons?5for?5hull?5?$CFu@ DB 'generating'
	DB	' polygons for hull %u...', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_InitDebugHulls@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_InitDebugHulls@@9@9 DD 0297H	; `Mod_InitDebugHulls'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@NICNHBLD@?$CFi?5hull?5polys?6@
CONST	SEGMENT
??_C@_0P@NICNHBLD@?$CFi?5hull?5polys?6@ DB '%i hull polys', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BFIDKCBM@?$CFi?5clipnodes?4?4?4?6@
CONST	SEGMENT
??_C@_0BB@BFIDKCBM@?$CFi?5clipnodes?4?4?4?6@ DB '%i clipnodes...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HFDKAEGF@?$FO3Warning?3?$FO7?5new?5winding?5was?5cl@
CONST	SEGMENT
??_C@_0CM@HFDKAEGF@?$FO3Warning?3?$FO7?5new?5winding?5was?5cl@ DB '^3Warn'
	DB	'ing:^7 new winding was clipped away!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\mod_dbghulls.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??hull_windings_r@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??hull_windings_r@@9@9 DD 0226H		; `hull_windings_r'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@KFHKEHHE@bad?5contents?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BC@KFHKEHHE@bad?5contents?3?5?$CFi?6@ DB 'bad contents: %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LGHIECPN@node?5stack?5underflow?6@
CONST	SEGMENT
??_C@_0BG@LGHIECPN@node?5stack?5underflow?6@ DB 'node stack underflow', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PPBLHIAG@node?5stack?5overflow?6@
CONST	SEGMENT
??_C@_0BF@PPBLHIAG@node?5stack?5overflow?6@ DB 'node stack overflow', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GHCKIFEI@BaseWindingForPlane?3?5no?5axis?5fo@
CONST	SEGMENT
??_C@_0CE@GHCKIFEI@BaseWindingForPlane?3?5no?5axis?5fo@ DB 'BaseWindingFo'
	DB	'rPlane: no axis found', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@COKMLMAP@free_winding?3?5freed?5a?5freed?5win@
CONST	SEGMENT
??_C@_0CF@COKMLMAP@free_winding?3?5freed?5a?5freed?5win@ DB 'free_winding'
	DB	': freed a freed winding', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0653H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	046aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0c14H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01cdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0edH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _make_hull_windings
_TEXT	SEGMENT
_head$ = -8						; size = 8
_hull$ = 8						; size = 4
_model$ = 12						; size = 4
_make_hull_windings PROC				; COMDAT

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 647  : 	hullnode_t head = LIST_HEAD_INIT( head );

	lea	eax, DWORD PTR _head$[ebp]
	mov	DWORD PTR _head$[ebp], eax
	lea	eax, DWORD PTR _head$[ebp]
	mov	DWORD PTR _head$[ebp+4], eax

; 648  : 
; 649  : 	Con_Reportf( "%i clipnodes...\n", hull->lastclipnode - hull->firstclipnode );

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0BB@BFIDKCBM@?$CFi?5clipnodes?4?4?4?6@
	call	_Con_Reportf
	add	esp, 8

; 650  : 
; 651  : 	node_stack_depth = 0;

	mov	DWORD PTR _node_stack_depth, 0

; 652  : 	model->num_polys = 0;

	mov	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR [eax+8], 0

; 653  : 
; 654  : 	if( hull->planes != NULL )

	mov	eax, DWORD PTR _hull$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@make_hull_

; 655  : 	{
; 656  : 		hull_windings_r( hull, hull->clipnodes + hull->firstclipnode, &head, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	lea	ecx, DWORD PTR _head$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _hull$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	push	eax
	mov	ecx, DWORD PTR _hull$[ebp]
	push	ecx
	call	_hull_windings_r
	add	esp, 16					; 00000010H

; 657  : 		remove_paired_polys( model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	_remove_paired_polys
	add	esp, 4
$LN2@make_hull_:

; 658  : 	}
; 659  : 	Con_Reportf( "%i hull polys\n", model->num_polys );

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET ??_C@_0P@NICNHBLD@?$CFi?5hull?5polys?6@
	call	_Con_Reportf
	add	esp, 8

; 660  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_make_hull_windings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _remove_paired_polys
_TEXT	SEGMENT
_next$ = -8						; size = 4
_w$ = -4						; size = 4
_model$ = 8						; size = 4
_remove_paired_polys PROC				; COMDAT

; 631  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 632  : 	winding_t	*w, *next;
; 633  : 
; 634  : 	list_for_each_entry_safe( w, next, &model->polys, chain )

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _next$[ebp], eax
	jmp	SHORT $LN4@remove_pai
$LN2@remove_pai:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR _next$[ebp], edx
$LN4@remove_pai:
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _model$[ebp]
	je	SHORT $LN1@remove_pai

; 635  : 	{
; 636  : 		if( w->pair )

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@remove_pai

; 637  : 		{
; 638  : 			list_del( &w->chain );

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	push	eax
	call	_list_del
	add	esp, 4

; 639  : 			free_winding( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 640  : 			model->num_polys--;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@remove_pai:

; 641  : 		}
; 642  : 	}

	jmp	SHORT $LN2@remove_pai
$LN1@remove_pai:

; 643  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_remove_paired_polys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _do_hull_recursion
_TEXT	SEGMENT
tv86 = -80						; size = 4
_child$1 = -12						; size = 4
_next$ = -8						; size = 4
_w$ = -4						; size = 4
_hull$ = 8						; size = 4
_node$ = 12						; size = 4
_side$ = 16						; size = 4
_polys$ = 20						; size = 4
_model$ = 24						; size = 4
_do_hull_recursion PROC					; COMDAT

; 506  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 507  : 	winding_t	*w, *next;
; 508  : 
; 509  : 	if( node->children[side] >= 0 )

	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	test	edx, edx
	jl	SHORT $LN10@do_hull_re

; 510  : 	{
; 511  : 		mclipnode_t *child = hull->clipnodes + node->children[side];

	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _child$1[ebp], edx

; 512  : 		push_node( node, side );

	mov	eax, DWORD PTR _side$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	_push_node
	add	esp, 8

; 513  : 		hull_windings_r( hull, child, polys, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _polys$[ebp]
	push	ecx
	mov	edx, DWORD PTR _child$1[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_hull_windings_r
	add	esp, 16					; 00000010H

; 514  : 		pop_node();

	call	_pop_node

; 515  : 	}

	jmp	$LN1@do_hull_re
$LN10@do_hull_re:

; 516  : 	else
; 517  : 	{
; 518  : 		switch( node->children[side] )

	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	add	eax, 6
	mov	DWORD PTR tv86[ebp], eax
	cmp	DWORD PTR tv86[ebp], 5
	ja	$LN19@do_hull_re
	mov	ecx, DWORD PTR tv86[ebp]
	jmp	DWORD PTR $LN21@do_hull_re[ecx*4]
$LN15@do_hull_re:

; 519  : 		{
; 520  : 		case CONTENTS_EMPTY:
; 521  : 		case CONTENTS_WATER:
; 522  : 		case CONTENTS_SLIME:
; 523  : 		case CONTENTS_LAVA:
; 524  : 			list_for_each_entry_safe( w, next, polys, chain )

	mov	eax, DWORD PTR _polys$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _next$[ebp], eax
	jmp	SHORT $LN6@do_hull_re
$LN4@do_hull_re:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR _next$[ebp], edx
$LN6@do_hull_re:
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _polys$[ebp]
	je	SHORT $LN5@do_hull_re

; 525  : 			{
; 526  : 				list_del( &w->chain );

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	push	eax
	call	_list_del
	add	esp, 4

; 527  : 				list_add( &w->chain, &model->polys );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	add	ecx, 8
	push	ecx
	call	_list_add
	add	esp, 8

; 528  : 			}

	jmp	SHORT $LN4@do_hull_re
$LN5@do_hull_re:

; 529  : 			break;

	jmp	$LN1@do_hull_re
$LN17@do_hull_re:

; 530  : 		case CONTENTS_SOLID:
; 531  : 		case CONTENTS_SKY:
; 532  : 			// throw away polys...
; 533  : 			list_for_each_entry_safe( w, next, polys, chain )

	mov	eax, DWORD PTR _polys$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _next$[ebp], eax
	jmp	SHORT $LN9@do_hull_re
$LN7@do_hull_re:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR _next$[ebp], edx
$LN9@do_hull_re:
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _polys$[ebp]
	je	SHORT $LN8@do_hull_re

; 534  : 			{
; 535  : 				if( w->pair )

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN18@do_hull_re

; 536  : 					w->pair->pair = NULL;

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], 0
$LN18@do_hull_re:

; 537  : 				list_del( &w->chain );

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	push	eax
	call	_list_del
	add	esp, 4

; 538  : 				free_winding( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 539  : 				model->num_polys--;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 540  : 			}

	jmp	SHORT $LN7@do_hull_re
$LN8@do_hull_re:

; 541  : 			break;

	jmp	SHORT $LN1@do_hull_re
$LN19@do_hull_re:

; 542  : 		default:
; 543  : 			Host_Error( "bad contents: %i\n", node->children[side] );

	mov	eax, DWORD PTR _side$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+4]
	push	edx
	push	OFFSET ??_C@_0BC@KFHKEHHE@bad?5contents?3?5?$CFi?6@
	call	_Host_Error
	add	esp, 8
$LN1@do_hull_re:

; 544  : 			break;
; 545  : 		}
; 546  : 	}
; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@do_hull_re:
	DD	$LN17@do_hull_re
	DD	$LN15@do_hull_re
	DD	$LN15@do_hull_re
	DD	$LN15@do_hull_re
	DD	$LN17@do_hull_re
	DD	$LN15@do_hull_re
_do_hull_recursion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _hull_windings_r
_TEXT	SEGMENT
_tmp$1 = -56						; size = 4
_p$2 = -52						; size = 4
_back2$3 = -48						; size = 4
_front2$4 = -44						; size = 4
_i$ = -40						; size = 4
_back$ = -36						; size = 4
_front$ = -32						; size = 4
_next$ = -28						; size = 4
_w$ = -24						; size = 4
_backlist$ = -20					; size = 8
_frontlist$ = -12					; size = 8
_plane$ = -4						; size = 4
_hull$ = 8						; size = 4
_node$ = 12						; size = 4
_polys$ = 16						; size = 4
_model$ = 20						; size = 4
_hull_windings_r PROC					; COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 551  : 	mplane_t		*plane = hull->planes + node->planenum;

	mov	eax, DWORD PTR _node$[ebp]
	imul	ecx, DWORD PTR [eax], 20
	mov	edx, DWORD PTR _hull$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _plane$[ebp], ecx

; 552  : 	hullnode_t	frontlist = LIST_HEAD_INIT( frontlist );

	lea	eax, DWORD PTR _frontlist$[ebp]
	mov	DWORD PTR _frontlist$[ebp], eax
	lea	eax, DWORD PTR _frontlist$[ebp]
	mov	DWORD PTR _frontlist$[ebp+4], eax

; 553  : 	hullnode_t	backlist = LIST_HEAD_INIT( backlist );

	lea	eax, DWORD PTR _backlist$[ebp]
	mov	DWORD PTR _backlist$[ebp], eax
	lea	eax, DWORD PTR _backlist$[ebp]
	mov	DWORD PTR _backlist$[ebp+4], eax

; 554  : 	winding_t		*w, *next, *front, *back;
; 555  : 	int	i;
; 556  : 
; 557  : 	list_for_each_entry_safe( w, next, polys, chain )

	mov	eax, DWORD PTR _polys$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _next$[ebp], eax
	jmp	SHORT $LN4@hull_windi
$LN2@hull_windi:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR _next$[ebp], edx
$LN4@hull_windi:
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _polys$[ebp]
	je	$LN3@hull_windi

; 558  : 	{
; 559  : 		// PARANIOA - PAIR CHECK
; 560  : 		ASSERT( !w->pair || w->pair->pair == w );

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@hull_windi
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _w$[ebp]
	je	SHORT $LN8@hull_windi
	mov	eax, DWORD PTR ?__LINE__Var@?0??hull_windings_r@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN8@hull_windi:

; 561  : 
; 562  : 		list_del( &w->chain );

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	push	eax
	call	_list_del
	add	esp, 4

; 563  : 		winding_split( w, plane, &front, &back );

	lea	eax, DWORD PTR _back$[ebp]
	push	eax
	lea	ecx, DWORD PTR _front$[ebp]
	push	ecx
	mov	edx, DWORD PTR _plane$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_winding_split
	add	esp, 16					; 00000010H

; 564  : 		if( front ) list_add( &front->chain, &frontlist );

	cmp	DWORD PTR _front$[ebp], 0
	je	SHORT $LN9@hull_windi
	lea	eax, DWORD PTR _frontlist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _front$[ebp]
	add	ecx, 8
	push	ecx
	call	_list_add
	add	esp, 8
$LN9@hull_windi:

; 565  : 		if( back ) list_add( &back->chain, &backlist );

	cmp	DWORD PTR _back$[ebp], 0
	je	SHORT $LN10@hull_windi
	lea	eax, DWORD PTR _backlist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _back$[ebp]
	add	ecx, 8
	push	ecx
	call	_list_add
	add	esp, 8
$LN10@hull_windi:

; 566  : 
; 567  : 		if( front && back )

	cmp	DWORD PTR _front$[ebp], 0
	je	$LN11@hull_windi
	cmp	DWORD PTR _back$[ebp], 0
	je	$LN11@hull_windi

; 568  : 		{
; 569  : 			if( w->pair )

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN12@hull_windi

; 570  : 			{
; 571  : 				// split the paired poly, preserve pairing
; 572  : 				winding_t	*front2, *back2;
; 573  : 
; 574  : 				winding_split( w->pair, plane, &front2, &back2 );

	lea	eax, DWORD PTR _back2$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _front2$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _plane$[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_winding_split
	add	esp, 16					; 00000010H

; 575  : 
; 576  : 				front2->pair = front;

	mov	eax, DWORD PTR _front2$4[ebp]
	mov	ecx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 577  : 				front->pair = front2;

	mov	eax, DWORD PTR _front$[ebp]
	mov	ecx, DWORD PTR _front2$4[ebp]
	mov	DWORD PTR [eax+4], ecx

; 578  : 				back2->pair = back;

	mov	eax, DWORD PTR _back2$3[ebp]
	mov	ecx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 579  : 				back->pair = back2;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR _back2$3[ebp]
	mov	DWORD PTR [eax+4], ecx

; 580  : 
; 581  : 				list_add( &front2->chain, &w->pair->chain );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _front2$4[ebp]
	add	edx, 8
	push	edx
	call	_list_add
	add	esp, 8

; 582  : 				list_add( &back2->chain, &w->pair->chain );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _back2$3[ebp]
	add	edx, 8
	push	edx
	call	_list_add
	add	esp, 8

; 583  : 				list_del( &w->pair->chain );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	call	_list_del
	add	esp, 4

; 584  : 				free_winding( w->pair );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_free_winding
	add	esp, 4

; 585  : 				model->num_polys++;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 586  : 			}

	jmp	SHORT $LN13@hull_windi
$LN12@hull_windi:

; 587  : 			else
; 588  : 			{
; 589  : 				front->pair = NULL;

	mov	eax, DWORD PTR _front$[ebp]
	mov	DWORD PTR [eax+4], 0

; 590  : 				back->pair = NULL;

	mov	eax, DWORD PTR _back$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN13@hull_windi:

; 591  : 			}
; 592  : 
; 593  : 			model->num_polys++;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 594  : 			free_winding( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4
$LN11@hull_windi:

; 595  : 		}
; 596  : 	}

	jmp	$LN2@hull_windi
$LN3@hull_windi:

; 597  : 
; 598  : 	w = winding_for_plane(plane);

	mov	eax, DWORD PTR _plane$[ebp]
	push	eax
	call	_winding_for_plane
	add	esp, 4
	mov	DWORD PTR _w$[ebp], eax

; 599  : 
; 600  : 	for( i = 0; w && i < node_stack_depth; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@hull_windi
$LN5@hull_windi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@hull_windi:
	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN6@hull_windi
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _node_stack_depth
	jae	SHORT $LN6@hull_windi

; 601  : 	{
; 602  : 		mplane_t *p = hull->planes + node_stack[i]->planenum;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _node_stack[eax*4]
	imul	edx, DWORD PTR [ecx], 20
	mov	eax, DWORD PTR _hull$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _p$2[ebp], edx

; 603  : 		w = winding_clip( w, p, false, side_stack[i], 0.00001 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3727c5ac
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _side_stack[eax*4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _p$2[ebp]
	push	edx
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_winding_clip
	add	esp, 20					; 00000014H
	mov	DWORD PTR _w$[ebp], eax

; 604  : 	}

	jmp	SHORT $LN5@hull_windi
$LN6@hull_windi:

; 605  : 
; 606  : 	if( w )

	cmp	DWORD PTR _w$[ebp], 0
	je	$LN14@hull_windi

; 607  : 	{
; 608  : 		winding_t *tmp = winding_copy( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_winding_copy
	add	esp, 4
	mov	DWORD PTR _tmp$1[ebp], eax

; 609  : 		winding_reverse( tmp );

	mov	eax, DWORD PTR _tmp$1[ebp]
	push	eax
	call	_winding_reverse
	add	esp, 4

; 610  : 
; 611  : 		w->pair = tmp;

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _tmp$1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 612  : 		tmp->pair = w;

	mov	eax, DWORD PTR _tmp$1[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 613  : 
; 614  : 		list_add( &w->chain, &frontlist );

	lea	eax, DWORD PTR _frontlist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _w$[ebp]
	add	ecx, 8
	push	ecx
	call	_list_add
	add	esp, 8

; 615  : 		list_add( &tmp->chain, &backlist );

	lea	eax, DWORD PTR _backlist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmp$1[ebp]
	add	ecx, 8
	push	ecx
	call	_list_add
	add	esp, 8

; 616  : 
; 617  : 		// PARANIOA - PAIR CHECK
; 618  : 		ASSERT( !w->pair || w->pair->pair == w );

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN16@hull_windi
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _w$[ebp]
	je	SHORT $LN16@hull_windi
	mov	eax, DWORD PTR ?__LINE__Var@?0??hull_windings_r@@9@9
	add	eax, 68					; 00000044H
	push	eax
	push	OFFSET ??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN16@hull_windi:

; 619  : 		model->num_polys += 2;

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 2
	mov	edx, DWORD PTR _model$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 620  : 	}

	jmp	SHORT $LN15@hull_windi
$LN14@hull_windi:

; 621  : 	else
; 622  : 	{
; 623  : 		Con_Printf( S_WARN "new winding was clipped away!\n" );

	push	OFFSET ??_C@_0CM@HFDKAEGF@?$FO3Warning?3?$FO7?5new?5winding?5was?5cl@
	call	_Con_Printf
	add	esp, 4
$LN15@hull_windi:

; 624  : 	}
; 625  : 
; 626  : 	do_hull_recursion( hull, node, 0, &frontlist, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	lea	ecx, DWORD PTR _frontlist$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_do_hull_recursion
	add	esp, 20					; 00000014H

; 627  : 	do_hull_recursion( hull, node, 1, &backlist, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	lea	ecx, DWORD PTR _backlist$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _hull$[ebp]
	push	eax
	call	_do_hull_recursion
	add	esp, 20					; 00000014H

; 628  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_hull_windings_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _free_hull_polys
_TEXT	SEGMENT
_next$ = -8						; size = 4
_w$ = -4						; size = 4
_hull_polys$ = 8					; size = 4
_free_hull_polys PROC					; COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 494  : 	winding_t	*w, *next;
; 495  : 
; 496  : 	list_for_each_entry_safe( w, next, hull_polys, chain )

	mov	eax, DWORD PTR _hull_polys$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _w$[ebp], ecx
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 8
	mov	DWORD PTR _next$[ebp], eax
	jmp	SHORT $LN4@free_hull_
$LN2@free_hull_:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _w$[ebp], eax
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 8
	mov	DWORD PTR _next$[ebp], edx
$LN4@free_hull_:
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _hull_polys$[ebp]
	je	SHORT $LN1@free_hull_

; 497  : 	{
; 498  : 		list_del( &w->chain );

	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 8
	push	eax
	call	_list_del
	add	esp, 4

; 499  : 		free_winding( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 500  : 	}

	jmp	SHORT $LN2@free_hull_
$LN1@free_hull_:

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_free_hull_polys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _pop_node
_TEXT	SEGMENT
_pop_node PROC						; COMDAT

; 486  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 487  : 	if( !node_stack_depth )

	cmp	DWORD PTR _node_stack_depth, 0
	jne	SHORT $LN2@pop_node

; 488  : 		Host_Error( "node stack underflow\n" );

	push	OFFSET ??_C@_0BG@LGHIECPN@node?5stack?5underflow?6@
	call	_Host_Error
	add	esp, 4
$LN2@pop_node:

; 489  : 	node_stack_depth--;

	mov	eax, DWORD PTR _node_stack_depth
	sub	eax, 1
	mov	DWORD PTR _node_stack_depth, eax

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pop_node ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _push_node
_TEXT	SEGMENT
_node$ = 8						; size = 4
_side$ = 12						; size = 4
_push_node PROC						; COMDAT

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 477  : 	if( node_stack_depth == MAX_CLIPNODE_DEPTH )

	cmp	DWORD PTR _node_stack_depth, 256	; 00000100H
	jne	SHORT $LN2@push_node

; 478  : 		Host_Error( "node stack overflow\n" );

	push	OFFSET ??_C@_0BF@PPBLHIAG@node?5stack?5overflow?6@
	call	_Host_Error
	add	esp, 4
$LN2@push_node:

; 479  : 
; 480  : 	node_stack[node_stack_depth] = node;

	mov	eax, DWORD PTR _node_stack_depth
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _node_stack[eax*4], ecx

; 481  : 	side_stack[node_stack_depth] = side;

	mov	eax, DWORD PTR _node_stack_depth
	mov	ecx, DWORD PTR _side$[ebp]
	mov	DWORD PTR _side_stack[eax*4], ecx

; 482  : 	node_stack_depth++;

	mov	eax, DWORD PTR _node_stack_depth
	add	eax, 1
	mov	DWORD PTR _node_stack_depth, eax

; 483  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_push_node ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_split
_TEXT	SEGMENT
_maxpts$ = -60						; size = 4
_mid$ = -56						; size = 4
_p2$ = -52						; size = 4
_p1$ = -48						; size = 4
_back$ = -44						; size = 4
_front$ = -40						; size = 4
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_dot$ = -28						; size = 4
_counts$ = -24						; size = 12
_sides$ = -12						; size = 4
_dists$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_split$ = 12						; size = 4
_pfront$ = 16						; size = 4
_pback$ = 20						; size = 4
_winding_split PROC					; COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 363  : 	vec_t	*dists;
; 364  : 	int	*sides;
; 365  : 	int	counts[3];
; 366  : 	vec_t	dot;
; 367  : 	int	i, j;
; 368  : 	winding_t	*front, *back;
; 369  : 	vec_t	*p1, *p2, *mid;
; 370  : 	int	maxpts;
; 371  : 
; 372  : 	dists = (vec_t *)malloc(( in->numpoints + 1 ) * sizeof( vec_t ));

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _dists$[ebp], eax

; 373  : 	sides = (int *)malloc(( in->numpoints + 1 ) * sizeof( int ));

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _sides$[ebp], eax

; 374  : 	CalcSides(in, split, sides, dists, counts, 0.04f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3d23d70a
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _counts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dists$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sides$[ebp]
	push	edx
	mov	eax, DWORD PTR _split$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_CalcSides
	add	esp, 24					; 00000018H

; 375  : 
; 376  : 	if( !counts[0] && !counts[1] )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _counts$[ebp+ecx], 0
	jne	SHORT $LN8@winding_sp
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _counts$[ebp+eax], 0
	jne	SHORT $LN8@winding_sp

; 377  : 	{
; 378  : 		// winding on the split plane - return copies on both sides
; 379  : 		*pfront = winding_copy( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_winding_copy
	add	esp, 4
	mov	ecx, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR [ecx], eax

; 380  : 		*pback = winding_copy( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_winding_copy
	add	esp, 4
	mov	ecx, DWORD PTR _pback$[ebp]
	mov	DWORD PTR [ecx], eax

; 381  : 		goto out_free;

	jmp	$out_free$27
$LN8@winding_sp:

; 382  : 	}
; 383  : 
; 384  : 	if( !counts[0] )

	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _counts$[ebp+ecx], 0
	jne	SHORT $LN9@winding_sp

; 385  : 	{
; 386  : 		*pfront = NULL;

	mov	eax, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR [eax], 0

; 387  : 		*pback = in;

	mov	eax, DWORD PTR _pback$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax], ecx

; 388  : 		goto out_free;

	jmp	$out_free$27
$LN9@winding_sp:

; 389  : 	}
; 390  : 
; 391  : 	if( !counts[1] )

	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _counts$[ebp+eax], 0
	jne	SHORT $LN10@winding_sp

; 392  : 	{
; 393  : 		*pfront = in;

	mov	eax, DWORD PTR _pfront$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR [eax], ecx

; 394  : 		*pback = NULL;

	mov	eax, DWORD PTR _pback$[ebp]
	mov	DWORD PTR [eax], 0

; 395  : 		goto out_free;

	jmp	$out_free$27
$LN10@winding_sp:

; 396  : 	}
; 397  : 
; 398  : 	maxpts = in->numpoints + 4;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	mov	DWORD PTR _maxpts$[ebp], ecx

; 399  : 	front = winding_alloc( maxpts );

	mov	eax, DWORD PTR _maxpts$[ebp]
	push	eax
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _front$[ebp], eax

; 400  : 	front->numpoints = 0;

	mov	eax, DWORD PTR _front$[ebp]
	mov	DWORD PTR [eax+16], 0

; 401  : 	front->plane = in->plane;

	mov	eax, DWORD PTR _front$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 402  : 	back = winding_alloc( maxpts );

	mov	eax, DWORD PTR _maxpts$[ebp]
	push	eax
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _back$[ebp], eax

; 403  : 	back->numpoints = 0;

	mov	eax, DWORD PTR _back$[ebp]
	mov	DWORD PTR [eax+16], 0

; 404  : 	back->plane = in->plane;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 405  : 
; 406  : 	for( i = 0; i < in->numpoints; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@winding_sp
$LN2@winding_sp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@winding_sp:
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@winding_sp

; 407  : 	{
; 408  : 		p1 = in->p[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _p1$[ebp], edx

; 409  : 
; 410  : 		if( sides[i] == SIDE_ON )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 2
	jne	$LN11@winding_sp

; 411  : 		{
; 412  : 			VectorCopy( p1, front->p[front->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _front$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _front$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _front$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _front$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _front$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _front$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 413  : 			VectorCopy( p1, back->p[back->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _back$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _back$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _back$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _back$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _back$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _back$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 414  : 			front->numpoints++;

	mov	eax, DWORD PTR _front$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 415  : 			back->numpoints++;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 416  : 			continue;

	jmp	$LN2@winding_sp
$LN11@winding_sp:

; 417  : 		}
; 418  : 
; 419  : 		if( sides[i] == SIDE_FRONT )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	$LN12@winding_sp

; 420  : 		{
; 421  : 			VectorCopy( p1, front->p[front->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _front$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _front$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _front$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _front$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _front$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _front$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 422  : 			front->numpoints++;

	mov	eax, DWORD PTR _front$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 423  : 		}

	jmp	$LN14@winding_sp
$LN12@winding_sp:

; 424  : 		else if( sides[i] == SIDE_BACK )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 1
	jne	$LN14@winding_sp

; 425  : 		{
; 426  : 			VectorCopy( p1, back->p[back->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _back$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _back$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _back$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _back$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _back$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _back$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 427  : 			back->numpoints++;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN14@winding_sp:

; 428  : 		}
; 429  : 
; 430  : 		if( sides[i + 1] == SIDE_ON || sides[i + 1] == sides[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], 2
	je	SHORT $LN16@winding_sp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _sides$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jne	SHORT $LN15@winding_sp
$LN16@winding_sp:

; 431  : 			continue;

	jmp	$LN2@winding_sp
$LN15@winding_sp:

; 432  : 
; 433  : 		// generate a split point
; 434  : 		p2 = in->p[(i + 1) % in->numpoints];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	cdq
	idiv	DWORD PTR [ecx+16]
	imul	edx, edx, 12
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	DWORD PTR _p2$[ebp], ecx

; 435  : 		mid = front->p[front->numpoints++];

	mov	eax, DWORD PTR _front$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	edx, DWORD PTR _front$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	DWORD PTR _mid$[ebp], eax
	mov	ecx, DWORD PTR _front$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _front$[ebp]
	mov	DWORD PTR [eax+16], edx

; 436  : 
; 437  : 		dot = dists[i] / (dists[i] - dists[i + 1]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _dists$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	divss	xmm1, xmm0
	movss	DWORD PTR _dot$[ebp], xmm1

; 438  : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@winding_sp
$LN5@winding_sp:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@winding_sp:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@winding_sp

; 439  : 		{
; 440  : 			// avoid round off error when possible
; 441  : 			if( in->plane->normal[j] == 1.0 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+edx*4]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@winding_sp

; 442  : 				mid[j] = in->plane->dist;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	$LN24@winding_sp
$LN17@winding_sp:

; 443  : 			else if( in->plane->normal[j] == -1.0 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+edx*4]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@winding_sp

; 444  : 				mid[j] = -in->plane->dist;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
	jmp	$LN24@winding_sp
$LN19@winding_sp:

; 445  : 			else if( split->normal[j] == 1.0 )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _split$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@winding_sp

; 446  : 				mid[j] = split->dist;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp]
	mov	edx, DWORD PTR _split$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN24@winding_sp
$LN21@winding_sp:

; 447  : 			else if( split->normal[j] == -1.0 )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _split$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@winding_sp

; 448  : 				mid[j] = -split->dist;

	mov	eax, DWORD PTR _split$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm0
	jmp	SHORT $LN24@winding_sp
$LN23@winding_sp:

; 449  : 			else mid[j] = p1[j] + dot * (p2[j] - p1[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4]
	mulss	xmm0, DWORD PTR _dot$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN24@winding_sp:

; 450  : 		}

	jmp	$LN5@winding_sp
$LN6@winding_sp:

; 451  : 
; 452  : 		if( in->plane->type < 3 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN25@winding_sp

; 453  : 			PushToPlaneAxis( mid, in->plane );

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mid$[ebp]
	push	edx
	call	_PushToPlaneAxis
	add	esp, 8
$LN25@winding_sp:

; 454  : 		VectorCopy( mid, back->p[back->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _back$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _back$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _mid$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _back$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _back$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _mid$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _back$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _back$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _mid$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 455  : 		back->numpoints++;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 456  : 	}

	jmp	$LN2@winding_sp
$LN3@winding_sp:

; 457  : 
; 458  : 	*pfront = winding_shrink( front );

	mov	eax, DWORD PTR _front$[ebp]
	push	eax
	call	_winding_shrink
	add	esp, 4
	mov	ecx, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR [ecx], eax

; 459  : 	*pback = winding_shrink( back );

	mov	eax, DWORD PTR _back$[ebp]
	push	eax
	call	_winding_shrink
	add	esp, 4
	mov	ecx, DWORD PTR _pback$[ebp]
	mov	DWORD PTR [ecx], eax
$out_free$27:

; 460  : out_free:
; 461  : 	free( dists );

	mov	eax, DWORD PTR _dists$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 462  : 	free( sides );

	mov	eax, DWORD PTR _sides$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_split ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_clip
_TEXT	SEGMENT
_maxpts$ = -56						; size = 4
_mid$ = -52						; size = 4
_p2$ = -48						; size = 4
_p1$ = -44						; size = 4
_neww$ = -40						; size = 4
_j$ = -36						; size = 4
_i$ = -32						; size = 4
_dot$ = -28						; size = 4
_counts$ = -24						; size = 12
_sides$ = -12						; size = 4
_dists$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_split$ = 12						; size = 4
_keepon$ = 16						; size = 4
_side$ = 20						; size = 4
_epsilon$ = 24						; size = 4
_winding_clip PROC					; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 259  : 	vec_t	*dists;
; 260  : 	int	*sides;
; 261  : 	int	counts[3];
; 262  : 	vec_t	dot;
; 263  : 	int	i, j;
; 264  : 	winding_t *neww;
; 265  : 	vec_t	*p1, *p2, *mid;
; 266  : 	int	maxpts;
; 267  : 
; 268  : 	dists = (vec_t *)malloc(( in->numpoints + 1 ) * sizeof( vec_t ));

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _dists$[ebp], eax

; 269  : 	sides = (int *)malloc(( in->numpoints + 1 ) * sizeof( int ));

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _sides$[ebp], eax

; 270  : 	CalcSides( in, split, sides, dists, counts, epsilon );

	push	ecx
	movss	xmm0, DWORD PTR _epsilon$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _counts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dists$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sides$[ebp]
	push	edx
	mov	eax, DWORD PTR _split$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_CalcSides
	add	esp, 24					; 00000018H

; 271  : 
; 272  : 	if( keepon && !counts[SIDE_FRONT] && !counts[SIDE_BACK] )

	cmp	DWORD PTR _keepon$[ebp], 0
	je	SHORT $LN8@winding_cl
	mov	eax, 4
	imul	ecx, eax, 0
	cmp	DWORD PTR _counts$[ebp+ecx], 0
	jne	SHORT $LN8@winding_cl
	mov	eax, 4
	shl	eax, 0
	cmp	DWORD PTR _counts$[ebp+eax], 0
	jne	SHORT $LN8@winding_cl

; 273  : 	{
; 274  : 		neww = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _neww$[ebp], eax

; 275  : 		goto out_free;

	jmp	$out_free$25
$LN8@winding_cl:

; 276  : 	}
; 277  : 
; 278  : 	if( !counts[side] )

	mov	eax, DWORD PTR _side$[ebp]
	cmp	DWORD PTR _counts$[ebp+eax*4], 0
	jne	SHORT $LN9@winding_cl

; 279  : 	{
; 280  : 		free_winding( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 281  : 		neww = NULL;

	mov	DWORD PTR _neww$[ebp], 0

; 282  : 		goto out_free;

	jmp	$out_free$25
$LN9@winding_cl:

; 283  : 	}
; 284  : 
; 285  : 	if( !counts[side ^ 1] )

	mov	eax, DWORD PTR _side$[ebp]
	xor	eax, 1
	cmp	DWORD PTR _counts$[ebp+eax*4], 0
	jne	SHORT $LN10@winding_cl

; 286  : 	{
; 287  : 		neww = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _neww$[ebp], eax

; 288  : 		goto out_free;

	jmp	$out_free$25
$LN10@winding_cl:

; 289  : 	}
; 290  : 
; 291  : 	maxpts = in->numpoints + 4;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 4
	mov	DWORD PTR _maxpts$[ebp], ecx

; 292  : 	neww = winding_alloc( maxpts );

	mov	eax, DWORD PTR _maxpts$[ebp]
	push	eax
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _neww$[ebp], eax

; 293  : 	neww->numpoints = 0;

	mov	eax, DWORD PTR _neww$[ebp]
	mov	DWORD PTR [eax+16], 0

; 294  : 	neww->plane = in->plane;

	mov	eax, DWORD PTR _neww$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 295  : 
; 296  : 	for( i = 0; i < in->numpoints; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@winding_cl
$LN2@winding_cl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@winding_cl:
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN3@winding_cl

; 297  : 	{
; 298  : 		p1 = in->p[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _p1$[ebp], edx

; 299  : 
; 300  : 		if( sides[i] == SIDE_ON )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 2
	jne	$LN11@winding_cl

; 301  : 		{
; 302  : 			VectorCopy( p1, neww->p[neww->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _neww$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _neww$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _neww$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _neww$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _neww$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _neww$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 303  : 			neww->numpoints++;

	mov	eax, DWORD PTR _neww$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _neww$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 304  : 			continue;

	jmp	$LN2@winding_cl
$LN11@winding_cl:

; 305  : 		}
; 306  : 
; 307  : 		if( sides[i] == side )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, DWORD PTR _side$[ebp]
	jne	$LN12@winding_cl

; 308  : 		{
; 309  : 			VectorCopy( p1, neww->p[neww->numpoints] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _neww$[ebp]
	imul	eax, DWORD PTR [edx+16], 12
	mov	edx, DWORD PTR _neww$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _neww$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	eax, DWORD PTR _neww$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _p1$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _neww$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	mov	ecx, DWORD PTR _neww$[ebp]
	lea	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _p1$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 310  : 			neww->numpoints++;

	mov	eax, DWORD PTR _neww$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _neww$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN12@winding_cl:

; 311  : 		}
; 312  : 
; 313  : 		if( sides[i + 1] == SIDE_ON || sides[i + 1] == sides[i] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], 2
	je	SHORT $LN14@winding_cl
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _sides$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jne	SHORT $LN13@winding_cl
$LN14@winding_cl:

; 314  : 			continue;

	jmp	$LN2@winding_cl
$LN13@winding_cl:

; 315  : 
; 316  : 		// generate a split point
; 317  : 		p2 = in->p[(i + 1) % in->numpoints];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	cdq
	idiv	DWORD PTR [ecx+16]
	imul	edx, edx, 12
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	DWORD PTR _p2$[ebp], ecx

; 318  : 		mid = neww->p[neww->numpoints++];

	mov	eax, DWORD PTR _neww$[ebp]
	imul	ecx, DWORD PTR [eax+16], 12
	mov	edx, DWORD PTR _neww$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	DWORD PTR _mid$[ebp], eax
	mov	ecx, DWORD PTR _neww$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _neww$[ebp]
	mov	DWORD PTR [eax+16], edx

; 319  : 
; 320  : 		dot = dists[i] / (dists[i] - dists[i + 1]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _dists$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4+4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	divss	xmm1, xmm0
	movss	DWORD PTR _dot$[ebp], xmm1

; 321  : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@winding_cl
$LN5@winding_cl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@winding_cl:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@winding_cl

; 322  : 		{
; 323  : 			// avoid round off error when possible
; 324  : 			if( in->plane->normal[j] == 1.0 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+edx*4]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@winding_cl

; 325  : 				mid[j] = in->plane->dist;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	$LN22@winding_cl
$LN15@winding_cl:

; 326  : 			else if( in->plane->normal[j] == -1.0 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+edx*4]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN17@winding_cl

; 327  : 				mid[j] = -in->plane->dist;

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
	jmp	$LN22@winding_cl
$LN17@winding_cl:

; 328  : 			else if( split->normal[j] == 1.0 )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _split$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@winding_cl

; 329  : 				mid[j] = split->dist;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _mid$[ebp]
	mov	edx, DWORD PTR _split$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN22@winding_cl
$LN19@winding_cl:

; 330  : 			else if( split->normal[j] == -1.0 )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _split$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@winding_cl

; 331  : 				mid[j] = -split->dist;

	mov	eax, DWORD PTR _split$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [edx+ecx*4], xmm0
	jmp	SHORT $LN22@winding_cl
$LN21@winding_cl:

; 332  : 			else mid[j] = p1[j] + dot * (p2[j] - p1[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _p1$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	subss	xmm0, DWORD PTR [esi+edx*4]
	mulss	xmm0, DWORD PTR _dot$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _p1$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _mid$[ebp]
	movss	DWORD PTR [eax+edx*4], xmm0
$LN22@winding_cl:

; 333  : 		}

	jmp	$LN5@winding_cl
$LN6@winding_cl:

; 334  : 
; 335  : 		if( in->plane->type < 3 )

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+16]
	cmp	edx, 3
	jge	SHORT $LN23@winding_cl

; 336  : 			PushToPlaneAxis( mid, in->plane );

	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _mid$[ebp]
	push	edx
	call	_PushToPlaneAxis
	add	esp, 8
$LN23@winding_cl:

; 337  : 	}

	jmp	$LN2@winding_cl
$LN3@winding_cl:

; 338  : 
; 339  : 	// free the original winding
; 340  : 	free_winding( in );

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 341  : 
; 342  : 	// Shrink the winding back to just what it needs...
; 343  : 	neww = winding_shrink(neww);

	mov	eax, DWORD PTR _neww$[ebp]
	push	eax
	call	_winding_shrink
	add	esp, 4
	mov	DWORD PTR _neww$[ebp], eax
$out_free$25:

; 344  : out_free:
; 345  : 	free( dists );

	mov	eax, DWORD PTR _dists$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 346  : 	free( sides );

	mov	eax, DWORD PTR _sides$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 347  : 
; 348  : 	return neww;

	mov	eax, DWORD PTR _neww$[ebp]

; 349  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_clip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _PushToPlaneAxis
_TEXT	SEGMENT
_t$ = -4						; size = 4
_v$ = 8							; size = 4
_p$ = 12						; size = 4
_PushToPlaneAxis PROC					; COMDAT

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 242  : 	const int	t = p->type % 3;

	mov	eax, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [eax+16]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _t$[ebp], edx

; 243  : 
; 244  : 	v[t] = (p->dist - p->normal[(t + 1) % 3] * v[(t + 1) % 3] - p->normal[(t + 2) % 3] * v[(t + 2) % 3]) / p->normal[t];

	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	ecx, edx
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	ecx, edx
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 2
	cdq
	mov	esi, 3
	idiv	esi
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [esi+edx*4]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	divss	xmm1, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm1

; 245  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PushToPlaneAxis ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _CalcSides
_TEXT	SEGMENT
tv72 = -84						; size = 4
_dot$1 = -16						; size = 4
_dot$2 = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_in$ = 8						; size = 4
_split$ = 12						; size = 4
_sides$ = 16						; size = 4
_dists$ = 20						; size = 4
_counts$ = 24						; size = 4
_epsilon$ = 28						; size = 4
_CalcSides PROC						; COMDAT

; 194  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 195  : 	const vec_t	*p;
; 196  : 	int		i;
; 197  : 
; 198  : 	counts[0] = counts[1] = counts[2] = 0;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _counts$[ebp]
	mov	DWORD PTR [ecx+eax], 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _counts$[ebp]
	mov	DWORD PTR [eax+edx], 0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _counts$[ebp]
	mov	DWORD PTR [eax+edx], 0

; 199  : 
; 200  : 	switch( split->type )

	mov	eax, DWORD PTR _split$[ebp]
	mov	cl, BYTE PTR [eax+16]
	mov	BYTE PTR tv72[ebp], cl
	cmp	BYTE PTR tv72[ebp], 0
	je	SHORT $LN10@CalcSides
	cmp	BYTE PTR tv72[ebp], 1
	je	SHORT $LN10@CalcSides
	cmp	BYTE PTR tv72[ebp], 2
	je	SHORT $LN10@CalcSides
	jmp	$LN17@CalcSides
$LN10@CalcSides:

; 201  : 	{
; 202  : 	case PLANE_X:
; 203  : 	case PLANE_Y:
; 204  : 	case PLANE_Z:
; 205  : 		p = in->p[0] + split->type;

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _split$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _p$[ebp], eax

; 206  : 		for( i = 0; i < in->numpoints; i++, p += 3 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CalcSides
$LN4@CalcSides:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], ecx
$LN6@CalcSides:
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN5@CalcSides

; 207  : 		{
; 208  : 			const vec_t dot = *p - split->dist;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _split$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR _dot$2[ebp], xmm0

; 209  : 
; 210  : 			dists[i] = dot;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	movss	xmm0, DWORD PTR _dot$2[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 211  : 			if( dot > epsilon )

	movss	xmm0, DWORD PTR _dot$2[ebp]
	comiss	xmm0, DWORD PTR _epsilon$[ebp]
	jbe	SHORT $LN13@CalcSides

; 212  : 				sides[i] = SIDE_FRONT;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $LN16@CalcSides
$LN13@CalcSides:

; 213  : 			else if( dot < -epsilon )

	movss	xmm0, DWORD PTR _epsilon$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _dot$2[ebp]
	jbe	SHORT $LN15@CalcSides

; 214  : 				sides[i] = SIDE_BACK;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 1
	jmp	SHORT $LN16@CalcSides
$LN15@CalcSides:

; 215  : 			else sides[i] = SIDE_ON;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 2
$LN16@CalcSides:

; 216  : 			counts[sides[i]]++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _counts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _counts$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 217  : 		}

	jmp	$LN4@CalcSides
$LN5@CalcSides:

; 218  : 		break;

	jmp	$LN2@CalcSides
$LN17@CalcSides:

; 219  : 	default:
; 220  : 		p = in->p[0];

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	DWORD PTR _p$[ebp], eax

; 221  : 		for( i = 0; i < in->numpoints; i++, p += 3 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@CalcSides
$LN7@CalcSides:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _p$[ebp], ecx
$LN9@CalcSides:
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN8@CalcSides

; 222  : 		{
; 223  : 			const vec_t dot = DotProduct( split->normal, p ) - split->dist;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _split$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _split$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _split$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _split$[ebp]
	subss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _dot$1[ebp], xmm0

; 224  : 
; 225  : 			dists[i] = dot;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dists$[ebp]
	movss	xmm0, DWORD PTR _dot$1[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0

; 226  : 			if( dot > epsilon )

	movss	xmm0, DWORD PTR _dot$1[ebp]
	comiss	xmm0, DWORD PTR _epsilon$[ebp]
	jbe	SHORT $LN18@CalcSides

; 227  : 				sides[i] = SIDE_FRONT;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $LN21@CalcSides
$LN18@CalcSides:

; 228  : 			else if( dot < -epsilon )

	movss	xmm0, DWORD PTR _epsilon$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _dot$1[ebp]
	jbe	SHORT $LN20@CalcSides

; 229  : 				sides[i] = SIDE_BACK;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 1
	jmp	SHORT $LN21@CalcSides
$LN20@CalcSides:

; 230  : 			else sides[i] = SIDE_ON;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	DWORD PTR [ecx+eax*4], 2
$LN21@CalcSides:

; 231  : 			counts[sides[i]]++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _counts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 1
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _counts$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 232  : 		}

	jmp	$LN7@CalcSides
$LN8@CalcSides:
$LN2@CalcSides:

; 233  : 		break;
; 234  : 	}
; 235  : 
; 236  : 	sides[i] = sides[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _sides$[ebp]
	mov	esi, DWORD PTR _sides$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx*4], ecx

; 237  : 	dists[i] = dists[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _dists$[ebp]
	mov	esi, DWORD PTR _dists$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx*4], ecx

; 238  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CalcSides ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_for_plane
_TEXT	SEGMENT
tv596 = -132						; size = 4
tv557 = -132						; size = 4
tv527 = -132						; size = 4
tv488 = -132						; size = 4
tv458 = -132						; size = 4
tv419 = -132						; size = 4
tv389 = -132						; size = 4
tv350 = -132						; size = 4
tv312 = -132						; size = 4
tv297 = -132						; size = 4
tv282 = -132						; size = 4
tv237 = -132						; size = 4
tv174 = -132						; size = 4
tv80 = -132						; size = 4
_ilength$1 = -64					; size = 4
_w$ = -60						; size = 4
_v$ = -56						; size = 4
_max$ = -52						; size = 4
_axis$ = -48						; size = 4
_i$ = -44						; size = 4
_vup$ = -40						; size = 12
_vright$ = -28						; size = 12
_org$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_winding_for_plane PROC					; COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 127  : 	vec3_t	org, vright, vup;
; 128  : 	int	i, axis;
; 129  : 	vec_t	max, v;
; 130  : 	winding_t	*w;
; 131  : 
; 132  : 	// find the major axis
; 133  : 	max = -BOGUS_RANGE;

	movss	xmm0, DWORD PTR __real@c7deb852
	movss	DWORD PTR _max$[ebp], xmm0

; 134  : 	axis = -1;

	mov	DWORD PTR _axis$[ebp], -1

; 135  : 
; 136  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@winding_fo
$LN2@winding_fo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@winding_fo:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@winding_fo

; 137  : 	{
; 138  : 		v = fabs( p->normal[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	cvtss2sd xmm0, DWORD PTR [ecx+eax*4]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _v$[ebp]

; 139  : 		if( v > max )

	movss	xmm0, DWORD PTR _v$[ebp]
	comiss	xmm0, DWORD PTR _max$[ebp]
	jbe	SHORT $LN7@winding_fo

; 140  : 		{
; 141  : 			axis = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _axis$[ebp], eax

; 142  : 			max = v;

	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR _max$[ebp], xmm0
$LN7@winding_fo:

; 143  : 		}
; 144  : 	}

	jmp	SHORT $LN2@winding_fo
$LN3@winding_fo:

; 145  : 
; 146  : 	VectorClear( vup );

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _vup$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vup$[ebp+ecx], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _vup$[ebp+eax], xmm0

; 147  : 	switch( axis )

	mov	eax, DWORD PTR _axis$[ebp]
	mov	DWORD PTR tv80[ebp], eax
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $LN8@winding_fo
	cmp	DWORD PTR tv80[ebp], 1
	je	SHORT $LN8@winding_fo
	cmp	DWORD PTR tv80[ebp], 2
	je	SHORT $LN10@winding_fo
	jmp	SHORT $LN11@winding_fo
$LN8@winding_fo:

; 148  : 	{
; 149  : 	case 0:
; 150  : 	case 1:
; 151  : 		vup[2] = 1;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vup$[ebp+eax], xmm0

; 152  : 		break;

	jmp	SHORT $LN5@winding_fo
$LN10@winding_fo:

; 153  : 	case 2:
; 154  : 		vup[0] = 1;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vup$[ebp+ecx], xmm0

; 155  : 		break;

	jmp	SHORT $LN5@winding_fo
$LN11@winding_fo:

; 156  : 	default:
; 157  : 		Host_Error( "BaseWindingForPlane: no axis found\n" );

	push	OFFSET ??_C@_0CE@GHCKIFEI@BaseWindingForPlane?3?5no?5axis?5fo@
	call	_Host_Error
	add	esp, 4

; 158  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@winding_fo
$LN5@winding_fo:

; 159  : 	}
; 160  : 
; 161  : 	v = DotProduct( vup, p->normal );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR _vup$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR _vup$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _v$[ebp], xmm0

; 162  : 	VectorMA( vup, -v, p->normal, vup );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _v$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	mulss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vup$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _v$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _vup$[ebp+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vup$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _v$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR _vup$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv174[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv174[ebp]
	movss	DWORD PTR _vup$[ebp+eax], xmm0

; 163  : 	VectorNormalize( vup );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vup$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm1, DWORD PTR _vup$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vup$[ebp+eax]
	mulss	xmm1, DWORD PTR _vup$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@winding_fo
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN12@winding_fo:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vup$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vup$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vup$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vup$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vup$[ebp+ecx], xmm0

; 164  : 	VectorScale( p->normal, p->dist, org );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [edx+12]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _org$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _org$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR tv237[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv237[ebp]
	movss	DWORD PTR _org$[ebp+ecx], xmm0

; 165  : 	CrossProduct( vup, p->normal, vright );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _vup$[ebp+eax]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR _vup$[ebp+eax]
	mulss	xmm1, DWORD PTR [edx+ecx]
	subss	xmm0, xmm1
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vright$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _vup$[ebp+edx]
	mulss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR _vup$[ebp+edx]
	mulss	xmm1, DWORD PTR [ecx+eax]
	subss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vright$[ebp+edx], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm1, DWORD PTR [edx+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR tv282[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv282[ebp]
	movss	DWORD PTR _vright$[ebp+eax], xmm0

; 166  : 	VectorScale( vup, BOGUS_RANGE, vup );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@47deb852
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vup$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@47deb852
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vup$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vup$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@47deb852
	movss	DWORD PTR tv297[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv297[ebp]
	movss	DWORD PTR _vup$[ebp+ecx], xmm0

; 167  : 	VectorScale( vright, BOGUS_RANGE, vright );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vright$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@47deb852
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vright$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vright$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@47deb852
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vright$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vright$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@47deb852
	movss	DWORD PTR tv312[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv312[ebp]
	movss	DWORD PTR _vright$[ebp+ecx], xmm0

; 168  : 
; 169  : 	// project a really big axis aligned box onto the plane
; 170  : 	w = winding_alloc( 4 );

	push	4
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _w$[ebp], eax

; 171  : 	memset( w->p, 0, sizeof( vec3_t ) * 4 );

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _w$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 172  : 	w->numpoints = 4;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax+16], 4

; 173  : 	w->plane = p;

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx

; 174  : 
; 175  : 	VectorSubtract( org, vright, w->p[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	subss	xmm0, DWORD PTR _vright$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	subss	xmm0, DWORD PTR _vright$[ebp+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _org$[ebp+edx]
	subss	xmm0, DWORD PTR _vright$[ebp+eax]
	movss	DWORD PTR tv350[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv350[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 176  : 	VectorAdd( w->p[0], vup, w->p[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR _vup$[ebp+eax]
	movss	DWORD PTR tv389[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv389[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 177  : 	VectorAdd( org, vright, w->p[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	addss	xmm0, DWORD PTR _vright$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _org$[ebp+eax]
	addss	xmm0, DWORD PTR _vright$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _org$[ebp+eax]
	addss	xmm0, DWORD PTR _vright$[ebp+ecx]
	movss	DWORD PTR tv419[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv419[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 178  : 	VectorAdd( w->p[1], vup, w->p[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _vup$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vup$[ebp+ecx]
	movss	DWORD PTR tv458[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv458[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 179  : 	VectorAdd( org, vright, w->p[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	addss	xmm0, DWORD PTR _vright$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _org$[ebp+eax]
	addss	xmm0, DWORD PTR _vright$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _org$[ebp+eax]
	addss	xmm0, DWORD PTR _vright$[ebp+ecx]
	movss	DWORD PTR tv488[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv488[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 180  : 	VectorSubtract( w->p[2], vup, w->p[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR _vup$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _vup$[ebp+ecx]
	movss	DWORD PTR tv527[ebp], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv527[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 181  : 	VectorSubtract( org, vright, w->p[3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	subss	xmm0, DWORD PTR _vright$[ebp+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _org$[ebp+ecx]
	subss	xmm0, DWORD PTR _vright$[ebp+edx]
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _org$[ebp+edx]
	subss	xmm0, DWORD PTR _vright$[ebp+eax]
	movss	DWORD PTR tv557[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv557[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 182  : 	VectorSubtract( w->p[3], vup, w->p[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	movss	xmm0, DWORD PTR [eax+edx]
	subss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR [edx+ecx], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR _vup$[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR [edx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR _vup$[ebp+eax]
	movss	DWORD PTR tv596[ebp], xmm0
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv596[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 183  : 
; 184  : 	return w;

	mov	eax, DWORD PTR _w$[ebp]
$LN1@winding_fo:

; 185  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_for_plane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_shrink
_TEXT	SEGMENT
_neww$ = -4						; size = 4
_w$ = 8							; size = 4
_winding_shrink PROC					; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 113  : 	winding_t	*neww = winding_alloc( w->numpoints );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _neww$[ebp], eax

; 114  : 	memcpy( neww, w, (int)((winding_t *)0)->p[w->numpoints] );

	mov	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _w$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	add	eax, edx
	push	eax
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _neww$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : 	free_winding( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	_free_winding
	add	esp, 4

; 116  : 
; 117  : 	return neww;

	mov	eax, DWORD PTR _neww$[ebp]

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_shrink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_reverse
_TEXT	SEGMENT
_i$ = -20						; size = 4
_point$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_w$ = 8							; size = 4
_winding_reverse PROC					; COMDAT

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 94   : 	vec3_t	point;
; 95   : 	int	i;
; 96   : 
; 97   : 	for( i = 0; i < w->numpoints / 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@winding_re
$LN2@winding_re:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@winding_re:
	mov	eax, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN3@winding_re

; 98   : 	{
; 99   : 		VectorCopy( w->p[i], point );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _point$[ebp+eax], ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _point$[ebp+eax], ecx
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _point$[ebp+eax], ecx

; 100  : 		VectorCopy( w->p[w->numpoints - i - 1], w->p[i] );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	imul	eax, edx, 0
	imul	edx, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [esi+edx+20]
	mov	esi, 4
	imul	esi, esi, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+esi], eax
	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+20]
	mov	esi, 4
	shl	esi, 0
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [ecx+esi], edx
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [eax+edx+20]
	mov	edx, 4
	shl	edx, 1
	imul	eax, DWORD PTR _i$[ebp], 12
	mov	esi, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [esi+eax+20]
	mov	esi, 4
	shl	esi, 1
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR [eax+esi], ecx

; 101  : 		VectorCopy( point, w->p[w->numpoints - i - 1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	imul	edx, eax, 12
	mov	eax, DWORD PTR _w$[ebp]
	lea	edx, DWORD PTR [eax+edx+20]
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _point$[ebp+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	imul	eax, ecx, 12
	mov	ecx, DWORD PTR _w$[ebp]
	lea	eax, DWORD PTR [ecx+eax+20]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _point$[ebp+edx]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	imul	ecx, edx, 12
	mov	edx, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _point$[ebp+eax]
	mov	DWORD PTR [ecx+edx], eax

; 102  : 	}

	jmp	$LN2@winding_re
$LN3@winding_re:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_copy
_TEXT	SEGMENT
_neww$ = -4						; size = 4
_w$ = 8							; size = 4
_winding_copy PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 84   : 	winding_t	*neww;
; 85   : 
; 86   : 	neww = winding_alloc( w->numpoints );

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_winding_alloc
	add	esp, 4
	mov	DWORD PTR _neww$[ebp], eax

; 87   : 	memcpy( neww, w, (int)((winding_t *)0)->p[w->numpoints] );

	mov	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _w$[ebp]
	imul	edx, DWORD PTR [ecx+16], 12
	add	eax, edx
	push	eax
	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	mov	ecx, DWORD PTR _neww$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 88   : 
; 89   : 	return neww;

	mov	eax, DWORD PTR _neww$[ebp]

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_copy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _free_winding
_TEXT	SEGMENT
_w$ = 8							; size = 4
_free_winding PROC					; COMDAT

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 75   : 	// simple sentinel by Carmack
; 76   : 	if( *(unsigned *)w == 0xDEADC0DE )

	mov	eax, DWORD PTR _w$[ebp]
	cmp	DWORD PTR [eax], -559038242		; deadc0deH
	jne	SHORT $LN2@free_windi

; 77   : 		Host_Error( "free_winding: freed a freed winding\n" );

	push	OFFSET ??_C@_0CF@COKMLMAP@free_winding?3?5freed?5a?5freed?5win@
	call	_Host_Error
	add	esp, 4
$LN2@free_windi:

; 78   : 	*(unsigned *)w = 0xDEADC0DE;

	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR [eax], -559038242		; deadc0deH

; 79   : 	free( w );

	mov	eax, DWORD PTR _w$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_free_winding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _winding_alloc
_TEXT	SEGMENT
_numpoints$ = 8						; size = 4
_winding_alloc PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 70   : 	return (winding_t *)malloc( (int)((winding_t *)0)->p[numpoints] );

	mov	eax, 20					; 00000014H
	imul	ecx, DWORD PTR _numpoints$[ebp], 12
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_winding_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _list_del
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_list_del PROC						; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 64   : 	entry->next->prev = entry->prev;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 65   : 	entry->prev->next = entry->next;

	mov	eax, DWORD PTR _entry$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _entry$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_list_del ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _list_add
_TEXT	SEGMENT
_newobj$ = 8						; size = 4
_head$ = 12						; size = 4
_list_add PROC						; COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 53   : 	list_add__( newobj, head, head->next );

	mov	eax, DWORD PTR _head$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _head$[ebp]
	push	edx
	mov	eax, DWORD PTR _newobj$[ebp]
	push	eax
	call	_list_add__
	add	esp, 12					; 0000000cH

; 54   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_list_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _list_add__
_TEXT	SEGMENT
_new$ = 8						; size = 4
_prev$ = 12						; size = 4
_next$ = 16						; size = 4
_list_add__ PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 44   : 	next->prev = new;

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _new$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 45   : 	new->next = next;

	mov	eax, DWORD PTR _new$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax], ecx

; 46   : 	new->prev = prev;

	mov	eax, DWORD PTR _new$[ebp]
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 47   : 	prev->next = new;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _new$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_list_add__ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _R_DrawModelHull
_TEXT	SEGMENT
tv67 = -80						; size = 4
_i$ = -12						; size = 4
_poly$ = -8						; size = 4
_hull$ = -4						; size = 4
_R_DrawModelHull PROC					; COMDAT

; 747  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 748  : 	hull_model_t	*hull;
; 749  : 	winding_t		*poly;
; 750  : 	int		i;
; 751  : 
; 752  : 	if( !CVAR_TO_BOOL( r_showhull ))

	cmp	DWORD PTR _r_showhull, 0
	je	SHORT $LN14@R_DrawMode
	mov	eax, DWORD PTR _r_showhull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@R_DrawMode
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN15@R_DrawMode
$LN14@R_DrawMode:
	mov	DWORD PTR tv67[ebp], 0
$LN15@R_DrawMode:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN8@R_DrawMode

; 753  : 		return;

	jmp	$LN1@R_DrawMode
$LN8@R_DrawMode:

; 754  : 
; 755  : 	if( !RI.currentmodel || RI.currentmodel->name[0] != '*' )

	cmp	DWORD PTR _RI+32, 0
	je	SHORT $LN10@R_DrawMode
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _RI+32
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 42					; 0000002aH
	je	SHORT $LN9@R_DrawMode
$LN10@R_DrawMode:

; 756  : 		return;

	jmp	$LN1@R_DrawMode
$LN9@R_DrawMode:

; 757  : 
; 758  : 	i = atoi( RI.currentmodel->name + 1 );

	mov	eax, DWORD PTR _RI+32
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 759  : 	if( i < 1 || i >= world.num_hull_models )

	cmp	DWORD PTR _i$[ebp], 1
	jl	SHORT $LN12@R_DrawMode
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _world+2584
	jl	SHORT $LN11@R_DrawMode
$LN12@R_DrawMode:

; 760  : 		return; 		

	jmp	$LN1@R_DrawMode
$LN11@R_DrawMode:

; 761  : 
; 762  : 	hull = &world.hull_models[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _world+2580
	mov	DWORD PTR _hull$[ebp], eax

; 763  : 
; 764  : 	pglPolygonOffset( 1.0f, 2.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPolygonOffset

; 765  : 	pglEnable( GL_POLYGON_OFFSET_FILL ); 

	push	32823					; 00008037H
	call	DWORD PTR _pglEnable

; 766  : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 767  : 	list_for_each_entry( poly, &hull->polys, chain )

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _poly$[ebp], ecx
	jmp	SHORT $LN4@R_DrawMode
$LN2@R_DrawMode:
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 8
	mov	DWORD PTR _poly$[ebp], ecx
$LN4@R_DrawMode:
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _hull$[ebp]
	je	$LN3@R_DrawMode

; 768  : 	{
; 769  : 		srand((unsigned long)poly);

	mov	eax, DWORD PTR _poly$[ebp]
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4

; 770  : 		pglColor3f( rand() % 256 / 255.0, rand() % 256 / 255.0, rand() % 256 / 255.0 );

	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN16@R_DrawMode
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN16@R_DrawMode:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN17@R_DrawMode
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN17@R_DrawMode:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN18@R_DrawMode
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN18@R_DrawMode:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 771  : 		pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 772  : 		for( i = 0; i < poly->numpoints; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_DrawMode
$LN5@R_DrawMode:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_DrawMode:
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN6@R_DrawMode

; 773  : 			pglVertex3fv( poly->p[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	DWORD PTR _pglVertex3fv
	jmp	SHORT $LN5@R_DrawMode
$LN6@R_DrawMode:

; 774  : 		pglEnd();

	call	DWORD PTR _pglEnd

; 775  : 	}

	jmp	$LN2@R_DrawMode
$LN3@R_DrawMode:

; 776  : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 777  : 	pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglDisable
$LN1@R_DrawMode:

; 778  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawModelHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _R_DrawWorldHull
_TEXT	SEGMENT
tv78 = -88						; size = 4
tv87 = -84						; size = 4
tv77 = -84						; size = 4
_val$1 = -16						; size = 4
_i$ = -12						; size = 4
_poly$ = -8						; size = 4
_hull$ = -4						; size = 4
_R_DrawWorldHull PROC					; COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 719  : 	hull_model_t	*hull = &world.hull_models[0];

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _world+2580
	mov	DWORD PTR _hull$[ebp], ecx

; 720  : 	winding_t		*poly;
; 721  : 	int		i;
; 722  : 
; 723  : 	if( FBitSet( r_showhull->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _r_showhull
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN8@R_DrawWorl

; 724  : 	{
; 725  : 		int val = bound( 0, (int)r_showhull->value, 3 );

	mov	eax, DWORD PTR _r_showhull
	cvttss2si ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jl	SHORT $LN14@R_DrawWorl
	mov	edx, DWORD PTR _r_showhull
	cvttss2si eax, DWORD PTR [edx+12]
	cmp	eax, 3
	jge	SHORT $LN12@R_DrawWorl
	mov	ecx, DWORD PTR _r_showhull
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv77[ebp], edx
	jmp	SHORT $LN13@R_DrawWorl
$LN12@R_DrawWorl:
	mov	DWORD PTR tv77[ebp], 3
$LN13@R_DrawWorl:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN15@R_DrawWorl
$LN14@R_DrawWorl:
	mov	DWORD PTR tv78[ebp], 0
$LN15@R_DrawWorl:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _val$1[ebp], ecx

; 726  : 		if( val ) Mod_CreatePolygonsForHull( val );

	cmp	DWORD PTR _val$1[ebp], 0
	je	SHORT $LN9@R_DrawWorl
	mov	eax, DWORD PTR _val$1[ebp]
	push	eax
	call	_Mod_CreatePolygonsForHull
	add	esp, 4
$LN9@R_DrawWorl:

; 727  : 		ClearBits( r_showhull->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _r_showhull
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _r_showhull
	mov	DWORD PTR [edx+8], ecx
$LN8@R_DrawWorl:

; 728  : 	}
; 729  : 
; 730  : 	if( !CVAR_TO_BOOL( r_showhull ))

	cmp	DWORD PTR _r_showhull, 0
	je	SHORT $LN16@R_DrawWorl
	mov	eax, DWORD PTR _r_showhull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@R_DrawWorl
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN17@R_DrawWorl
$LN16@R_DrawWorl:
	mov	DWORD PTR tv87[ebp], 0
$LN17@R_DrawWorl:
	cmp	DWORD PTR tv87[ebp], 0
	jne	SHORT $LN10@R_DrawWorl

; 731  : 		return;

	jmp	$LN1@R_DrawWorl
$LN10@R_DrawWorl:

; 732  : 	pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 733  : 
; 734  : 	list_for_each_entry( poly, &hull->polys, chain )

	mov	eax, DWORD PTR _hull$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 8
	mov	DWORD PTR _poly$[ebp], ecx
	jmp	SHORT $LN4@R_DrawWorl
$LN2@R_DrawWorl:
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 8
	mov	DWORD PTR _poly$[ebp], ecx
$LN4@R_DrawWorl:
	mov	eax, DWORD PTR _poly$[ebp]
	add	eax, 8
	cmp	eax, DWORD PTR _hull$[ebp]
	je	$LN3@R_DrawWorl

; 735  : 	{
; 736  : 		srand((unsigned long)poly);

	mov	eax, DWORD PTR _poly$[ebp]
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4

; 737  : 		pglColor3f( rand() % 256 / 255.0, rand() % 256 / 255.0, rand() % 256 / 255.0 );

	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN18@R_DrawWorl
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN18@R_DrawWorl:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN19@R_DrawWorl
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN19@R_DrawWorl:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__rand
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN20@R_DrawWorl
	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN20@R_DrawWorl:
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 738  : 		pglBegin( GL_POLYGON );

	push	9
	call	DWORD PTR _pglBegin

; 739  : 		for( i = 0; i < poly->numpoints; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_DrawWorl
$LN5@R_DrawWorl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_DrawWorl:
	mov	eax, DWORD PTR _poly$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN6@R_DrawWorl

; 740  : 			pglVertex3fv( poly->p[i] );

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _poly$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	DWORD PTR _pglVertex3fv
	jmp	SHORT $LN5@R_DrawWorl
$LN6@R_DrawWorl:

; 741  : 		pglEnd();

	call	DWORD PTR _pglEnd

; 742  : 	}

	jmp	$LN2@R_DrawWorl
$LN3@R_DrawWorl:

; 743  : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN1@R_DrawWorl:

; 744  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawWorldHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _Mod_ReleaseHullPolygons
_TEXT	SEGMENT
_model$1 = -8						; size = 4
_i$ = -4						; size = 4
_Mod_ReleaseHullPolygons PROC				; COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 706  : 	int	i;
; 707  : 
; 708  : 	// release ploygons
; 709  : 	for( i = 0; i < world.num_hull_models; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Releas
$LN2@Mod_Releas:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Releas:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _world+2584
	jge	SHORT $LN3@Mod_Releas

; 710  : 	{
; 711  : 		hull_model_t *model = &world.hull_models[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _world+2580
	mov	DWORD PTR _model$1[ebp], eax

; 712  : 		free_hull_polys( &model->polys );

	mov	eax, DWORD PTR _model$1[ebp]
	push	eax
	call	_free_hull_polys
	add	esp, 4

; 713  : 	}

	jmp	SHORT $LN2@Mod_Releas
$LN3@Mod_Releas:

; 714  : 	world.num_hull_models = 0;

	mov	DWORD PTR _world+2584, 0

; 715  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_ReleaseHullPolygons ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _Mod_CreatePolygonsForHull
_TEXT	SEGMENT
_model$1 = -40						; size = 4
_i$ = -36						; size = 4
_name$ = -32						; size = 8
_end$ = -24						; size = 8
_start$ = -16						; size = 8
_mod$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hullnum$ = 8						; size = 4
_Mod_CreatePolygonsForHull PROC				; COMDAT

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 680  : 	model_t	*mod = cl.worldmodel;

	mov	eax, DWORD PTR _cl+4579004
	mov	DWORD PTR _mod$[ebp], eax

; 681  : 	double	start, end;
; 682  : 	char	name[8];
; 683  : 	int	i;
; 684  : 
; 685  : 	if( hullnum < 1 || hullnum > 3 )

	cmp	DWORD PTR _hullnum$[ebp], 1
	jl	SHORT $LN6@Mod_Create
	cmp	DWORD PTR _hullnum$[ebp], 3
	jle	SHORT $LN5@Mod_Create
$LN6@Mod_Create:

; 686  : 		return;

	jmp	$LN1@Mod_Create
$LN5@Mod_Create:

; 687  : 
; 688  : 	Con_Printf( "generating polygons for hull %u...\n", hullnum );

	mov	eax, DWORD PTR _hullnum$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@EHPEPKLJ@generating?5polygons?5for?5hull?5?$CFu@
	call	_Con_Printf
	add	esp, 8

; 689  : 	start = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _start$[ebp]

; 690  : 
; 691  : 	// rebuild hulls list
; 692  : 	for( i = 0; i < world.num_hull_models; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Create
$LN2@Mod_Create:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Create:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _world+2584
	jge	SHORT $LN3@Mod_Create

; 693  : 	{
; 694  : 		hull_model_t *model = &world.hull_models[i];

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _world+2580
	mov	DWORD PTR _model$1[ebp], eax

; 695  : 		free_hull_polys( &model->polys );

	mov	eax, DWORD PTR _model$1[ebp]
	push	eax
	call	_free_hull_polys
	add	esp, 4

; 696  : 		make_hull_windings( &mod->hulls[hullnum], model );

	mov	eax, DWORD PTR _model$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _hullnum$[ebp], 40
	mov	edx, DWORD PTR _mod$[ebp]
	lea	eax, DWORD PTR [edx+ecx+208]
	push	eax
	call	_make_hull_windings
	add	esp, 8

; 697  : 		Q_snprintf( name, sizeof( name ), "*%i", i + 1 );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_03JLINDLFM@?$CK?$CFi@
	push	8
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 698  : 		mod = Mod_FindName( name, false );

	push	0
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Mod_FindName
	add	esp, 8
	mov	DWORD PTR _mod$[ebp], eax

; 699  : 	}

	jmp	SHORT $LN2@Mod_Create
$LN3@Mod_Create:

; 700  : 	end = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _end$[ebp]

; 701  : 	Con_Printf( "build time %.3f secs\n", end - start );

	movsd	xmm0, QWORD PTR _end$[ebp]
	subsd	xmm0, QWORD PTR _start$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BG@DOCAAMMN@build?5time?5?$CF?43f?5secs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN1@Mod_Create:

; 702  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CreatePolygonsForHull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\mod_dbghulls.c
;	COMDAT _Mod_InitDebugHulls
_TEXT	SEGMENT
_poly$1 = -8						; size = 4
_i$ = -4						; size = 4
_Mod_InitDebugHulls PROC				; COMDAT

; 663  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 664  : 	int	i;
; 665  : 
; 666  : 	world.hull_models = Mem_Calloc( loadmodel->mempool, sizeof( hull_model_t ) * loadmodel->numsubmodels );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_InitDebugHulls@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DJ@LOGLOBHA@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _loadmodel
	imul	edx, DWORD PTR [ecx+120], 12
	push	edx
	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _world+2580, eax

; 667  : 	world.num_hull_models = loadmodel->numsubmodels;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR _world+2584, ecx

; 668  : 
; 669  : 	// initialize list
; 670  : 	for( i = 0; i < world.num_hull_models; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_InitDe
$LN2@Mod_InitDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_InitDe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _world+2584
	jge	SHORT $LN1@Mod_InitDe

; 671  : 	{
; 672  : 		hullnode_t *poly = &world.hull_models[i].polys;

	imul	eax, DWORD PTR _i$[ebp], 12
	add	eax, DWORD PTR _world+2580
	mov	DWORD PTR _poly$1[ebp], eax

; 673  : 		poly->next = poly;

	mov	eax, DWORD PTR _poly$1[ebp]
	mov	ecx, DWORD PTR _poly$1[ebp]
	mov	DWORD PTR [eax], ecx

; 674  : 		poly->prev = poly;

	mov	eax, DWORD PTR _poly$1[ebp]
	mov	ecx, DWORD PTR _poly$1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 675  : 	}

	jmp	SHORT $LN2@Mod_InitDe
$LN1@Mod_InitDe:

; 676  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_InitDebugHulls ENDP
_TEXT	ENDS
END
