; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\sys_win.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_error_on_exit
_BSS	SEGMENT
_error_on_exit DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_Sys_Sleep
PUBLIC	_Sys_DoubleTime
PUBLIC	_Sys_GetClipboardData
PUBLIC	_Sys_GetCurrentUser
PUBLIC	_Sys_CheckParm
PUBLIC	_Sys_Error
PUBLIC	_Sys_LoadLibrary
PUBLIC	_Sys_GetProcAddress
PUBLIC	_Sys_FreeLibrary
PUBLIC	_Sys_ParseCommandLine
PUBLIC	_Sys_MergeCommandLine
PUBLIC	_Sys_Crash@4
PUBLIC	_Sys_SetClipboardData
PUBLIC	__Sys_GetParmFromCmdLine
PUBLIC	_Sys_ShellExecute
PUBLIC	_Sys_GetMachineKey
PUBLIC	_Sys_SendKeyEvents
PUBLIC	_Sys_Print
PUBLIC	_Sys_Quit
PUBLIC	_Sys_WaitForQuit
PUBLIC	?__LINE__Var@?0??Sys_GetClipboardData@@9@9	; `Sys_GetClipboardData'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@IFFDAPML@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CH@EGIADOFJ@?$FO1Error?3?$FO7?5unable?5to?5write?5scre@ ; `string'
PUBLIC	??_C@_0N@INAGJMNN@advapi32?4dll@		; `string'
PUBLIC	??_C@_0N@EEKCKEJG@GetUserNameA@			; `string'
PUBLIC	??_C@_06BALNJMNP@player@			; `string'
PUBLIC	??_C@_0L@IKBIFNGI@rpcrt4?4dll@			; `string'
PUBLIC	??_C@_0BF@DJFPALMK@UuidCreateSequential@	; `string'
PUBLIC	??_C@_0BO@GHBLPFMO@?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X@ ; `string'
PUBLIC	??_C@_0M@KFDNOLCO@shell32?4dll@			; `string'
PUBLIC	??_C@_0O@MOHFGHHE@ShellExecuteA@		; `string'
PUBLIC	??_C@_04PMOCAHAA@open@				; `string'
PUBLIC	??_C@_08CHPFJPNL@censored@			; `string'
PUBLIC	??_C@_03JACLIBNI@exe@				; `string'
PUBLIC	??_C@_05FACLEBO@?9game@				; `string'
PUBLIC	??_C@_05NDFLFHAD@?$CLgame@			; `string'
PUBLIC	??_C@_04CAKKOBMI@?$CLmap@			; `string'
PUBLIC	??_C@_05FEFFNJAE@?$CLload@			; `string'
PUBLIC	??_C@_0N@FPCHJOAK@?$CLchangelevel@		; `string'
PUBLIC	??_C@_0BM@BKNDDBKO@Sys_LoadLibrary?3?5Loading?5?$CFs@ ; `string'
PUBLIC	??_C@_0CD@OIFBLFOH@Sys_LoadLibrary?3?5couldn?8t?5load?5@ ; `string'
PUBLIC	??_C@_0DG@EDDNHCNN@Sys_LoadLibrary?3?5?$CFs?5missing?5or?5@ ; `string'
PUBLIC	??_C@_06KPFALOP@?5?9?5ok?6@			; `string'
PUBLIC	??_C@_0L@NLADGNPD@?5?9?5failed?6@		; `string'
PUBLIC	??_C@_0M@LPMAAKMD@?$FO1Error?3?$FO7?5@		; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_0CI@LPEJNEKE@Sys_FreeLibrary?3?5hold?5?$CFs?5for?5de@ ; `string'
PUBLIC	??_C@_0BP@HELNEIHJ@Sys_FreeLibrary?3?5Unloading?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CH@PKCEIFMA@unhandled?5exception?3?5?$CFp?5at?5addr@ ; `string'
PUBLIC	??_C@_0L@COIOLHLA@Xash?5Error@			; `string'
PUBLIC	__real@00000000
EXTRN	_memcpy:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalSize@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__GlobalFree@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__SetClipboardData@8:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__EmptyClipboard@0:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__exit:PROC
EXTRN	_Sys_PrintLog:PROC
EXTRN	_Con_ShowConsole:PROC
EXTRN	_Con_WinPrint:PROC
EXTRN	_Con_DestroyConsole:PROC
EXTRN	_Con_RegisterHotkeys:PROC
EXTRN	_Con_DisableInput:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Host_Shutdown:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_SV_SysError:PROC
EXTRN	_CL_Crashed:PROC
EXTRN	_Con_Print:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ltod3:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	8

?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9 DQ 01H DUP (?) ; `Sys_DoubleTime'::`2'::g_PerformanceFrequency
?g_ClockStart@?1??Sys_DoubleTime@@9@9 DQ 01H DUP (?)	; `Sys_DoubleTime'::`2'::g_ClockStart
?data@?1??Sys_GetClipboardData@@9@9 DD 01H DUP (?)	; `Sys_GetClipboardData'::`2'::data
?sys_user_name@?1??Sys_GetCurrentUser@@9@9 DB 0100H DUP (?) ; `Sys_GetCurrentUser'::`2'::sys_user_name
?key@?1??Sys_GetMachineKey@@9@9 DB 020H DUP (?)		; `Sys_GetMachineKey'::`2'::key
?commandline@?1??Sys_ParseCommandLine@@9@9 DB 0400H DUP (?) ; `Sys_ParseCommandLine'::`2'::commandline
?commandline@?1??Sys_MergeCommandLine@@9@9 DB 0400H DUP (?) ; `Sys_MergeCommandLine'::`2'::commandline
?buffer@?1??Sys_Print@@9@9 DB 02000H DUP (?)		; `Sys_Print'::`2'::buffer
?logbuf@?1??Sys_Print@@9@9 DB 02020H DUP (?)		; `Sys_Print'::`2'::logbuf
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0L@COIOLHLA@Xash?5Error@
CONST	SEGMENT
??_C@_0L@COIOLHLA@Xash?5Error@ DB 'Xash Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PKCEIFMA@unhandled?5exception?3?5?$CFp?5at?5addr@
CONST	SEGMENT
??_C@_0CH@PKCEIFMA@unhandled?5exception?3?5?$CFp?5at?5addr@ DB 'unhandled'
	DB	' exception: %p at address %p', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HELNEIHJ@Sys_FreeLibrary?3?5Unloading?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@HELNEIHJ@Sys_FreeLibrary?3?5Unloading?5?$CFs?6@ DB 'Sys_FreeLib'
	DB	'rary: Unloading %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LPEJNEKE@Sys_FreeLibrary?3?5hold?5?$CFs?5for?5de@
CONST	SEGMENT
??_C@_0CI@LPEJNEKE@Sys_FreeLibrary?3?5hold?5?$CFs?5for?5de@ DB 'Sys_FreeL'
	DB	'ibrary: hold %s for debugging', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPMAAKMD@?$FO1Error?3?$FO7?5@
CONST	SEGMENT
??_C@_0M@LPMAAKMD@?$FO1Error?3?$FO7?5@ DB '^1Error:^7 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLADGNPD@?5?9?5failed?6@
CONST	SEGMENT
??_C@_0L@NLADGNPD@?5?9?5failed?6@ DB ' - failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPFALOP@?5?9?5ok?6@
CONST	SEGMENT
??_C@_06KPFALOP@?5?9?5ok?6@ DB ' - ok', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EDDNHCNN@Sys_LoadLibrary?3?5?$CFs?5missing?5or?5@
CONST	SEGMENT
??_C@_0DG@EDDNHCNN@Sys_LoadLibrary?3?5?$CFs?5missing?5or?5@ DB 'Sys_LoadL'
	DB	'ibrary: %s missing or invalid function (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OIFBLFOH@Sys_LoadLibrary?3?5couldn?8t?5load?5@
CONST	SEGMENT
??_C@_0CD@OIFBLFOH@Sys_LoadLibrary?3?5couldn?8t?5load?5@ DB 'Sys_LoadLibr'
	DB	'ary: couldn''t load %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BKNDDBKO@Sys_LoadLibrary?3?5Loading?5?$CFs@
CONST	SEGMENT
??_C@_0BM@BKNDDBKO@Sys_LoadLibrary?3?5Loading?5?$CFs@ DB 'Sys_LoadLibrary'
	DB	': Loading %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPCHJOAK@?$CLchangelevel@
CONST	SEGMENT
??_C@_0N@FPCHJOAK@?$CLchangelevel@ DB '+changelevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FEFFNJAE@?$CLload@
CONST	SEGMENT
??_C@_05FEFFNJAE@?$CLload@ DB '+load', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAKKOBMI@?$CLmap@
CONST	SEGMENT
??_C@_04CAKKOBMI@?$CLmap@ DB '+map', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NDFLFHAD@?$CLgame@
CONST	SEGMENT
??_C@_05NDFLFHAD@?$CLgame@ DB '+game', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FACLEBO@?9game@
CONST	SEGMENT
??_C@_05FACLEBO@?9game@ DB '-game', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JACLIBNI@exe@
CONST	SEGMENT
??_C@_03JACLIBNI@exe@ DB 'exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHPFJPNL@censored@
CONST	SEGMENT
??_C@_08CHPFJPNL@censored@ DB 'censored', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open@
CONST	SEGMENT
??_C@_04PMOCAHAA@open@ DB 'open', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MOHFGHHE@ShellExecuteA@
CONST	SEGMENT
??_C@_0O@MOHFGHHE@ShellExecuteA@ DB 'ShellExecuteA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KFDNOLCO@shell32?4dll@
CONST	SEGMENT
??_C@_0M@KFDNOLCO@shell32?4dll@ DB 'shell32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GHBLPFMO@?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X@
CONST	SEGMENT
??_C@_0BO@GHBLPFMO@?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X@ DB '%'
	DB	'02X-%02X-%02X-%02X-%02X-%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DJFPALMK@UuidCreateSequential@
CONST	SEGMENT
??_C@_0BF@DJFPALMK@UuidCreateSequential@ DB 'UuidCreateSequential', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKBIFNGI@rpcrt4?4dll@
CONST	SEGMENT
??_C@_0L@IKBIFNGI@rpcrt4?4dll@ DB 'rpcrt4.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BALNJMNP@player@
CONST	SEGMENT
??_C@_06BALNJMNP@player@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEKCKEJG@GetUserNameA@
CONST	SEGMENT
??_C@_0N@EEKCKEJG@GetUserNameA@ DB 'GetUserNameA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INAGJMNN@advapi32?4dll@
CONST	SEGMENT
??_C@_0N@INAGJMNN@advapi32?4dll@ DB 'advapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EGIADOFJ@?$FO1Error?3?$FO7?5unable?5to?5write?5scre@
CONST	SEGMENT
??_C@_0CH@EGIADOFJ@?$FO1Error?3?$FO7?5unable?5to?5write?5scre@ DB '^1Erro'
	DB	'r:^7 unable to write screenshot', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IFFDAPML@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@IFFDAPML@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\sys_win.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Sys_GetClipboardData@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Sys_GetClipboardData@@9@9 DD 032H	; `Sys_GetClipboardData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	010cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	010bH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_WaitForQuit
_TEXT	SEGMENT
_msg$ = -28						; size = 28
_Sys_WaitForQuit PROC					; COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 450  : 	MSG	msg;
; 451  : 
; 452  : 	Con_RegisterHotkeys();		

	call	_Con_RegisterHotkeys

; 453  : 
; 454  : 	msg.message = 0;

	mov	DWORD PTR _msg$[ebp+4], 0
$LN2@Sys_WaitFo:

; 455  : 
; 456  : 	// wait for the user to quit
; 457  : 	while( msg.message != WM_QUIT )

	cmp	DWORD PTR _msg$[ebp+4], 18		; 00000012H
	je	SHORT $LN1@Sys_WaitFo

; 458  : 	{
; 459  : 		if( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))

	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	SHORT $LN4@Sys_WaitFo

; 460  : 		{
; 461  : 			TranslateMessage( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4

; 462  : 			DispatchMessage( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4

; 463  : 		} 

	jmp	SHORT $LN5@Sys_WaitFo
$LN4@Sys_WaitFo:

; 464  : 		else Sys_Sleep( 20 );

	push	20					; 00000014H
	call	_Sys_Sleep
	add	esp, 4
$LN5@Sys_WaitFo:

; 465  : 	}

	jmp	SHORT $LN2@Sys_WaitFo
$LN1@Sys_WaitFo:

; 466  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_WaitForQuit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_Quit
_TEXT	SEGMENT
_Sys_Quit PROC						; COMDAT

; 553  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 554  : 	Host_Shutdown();

	call	_Host_Shutdown

; 555  : 	exit( error_on_exit );

	mov	eax, DWORD PTR _error_on_exit
	push	eax
	call	DWORD PTR __imp__exit
$LN2@Sys_Quit:

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_Quit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_Print
_TEXT	SEGMENT
_i$ = -16						; size = 4
_c$ = -12						; size = 4
_b$ = -8						; size = 4
_msg$ = -4						; size = 4
_pMsg$ = 8						; size = 4
_Sys_Print PROC						; COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 567  : 	const char	*msg;
; 568  : 	static char	buffer[MAX_PRINT_MSG];
; 569  : 	static char	logbuf[MAX_PRINT_MSG];
; 570  : 	char		*b = buffer;

	mov	DWORD PTR _b$[ebp], OFFSET ?buffer@?1??Sys_Print@@9@9

; 571  : 	char		*c = logbuf;	

	mov	DWORD PTR _c$[ebp], OFFSET ?logbuf@?1??Sys_Print@@9@9

; 572  : 	int		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 573  : 
; 574  : 	if( host.type == HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN4@Sys_Print

; 575  : 		Con_Print( pMsg );

	mov	eax, DWORD PTR _pMsg$[ebp]
	push	eax
	call	_Con_Print
	add	esp, 4
$LN4@Sys_Print:

; 576  : 
; 577  : 	// if the message is REALLY long, use just the last portion of it
; 578  : 	if( Q_strlen( pMsg ) > sizeof( buffer ) - 1 )

	mov	eax, DWORD PTR _pMsg$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 8191				; 00001fffH
	jbe	SHORT $LN5@Sys_Print

; 579  : 		msg = pMsg + Q_strlen( pMsg ) - sizeof( buffer ) + 1;

	mov	eax, DWORD PTR _pMsg$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pMsg$[ebp]
	lea	edx, DWORD PTR [ecx+eax-8191]
	mov	DWORD PTR _msg$[ebp], edx
	jmp	SHORT $LN2@Sys_Print
$LN5@Sys_Print:

; 580  : 	else msg = pMsg;

	mov	eax, DWORD PTR _pMsg$[ebp]
	mov	DWORD PTR _msg$[ebp], eax
$LN2@Sys_Print:

; 581  : 
; 582  : 	// copy into an intermediate buffer
; 583  : 	while( msg[i] && (( b - buffer ) < sizeof( buffer ) - 1 ))

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Sys_Print
	mov	eax, DWORD PTR _b$[ebp]
	sub	eax, OFFSET ?buffer@?1??Sys_Print@@9@9
	cmp	eax, 8191				; 00001fffH
	jae	$LN3@Sys_Print

; 584  : 	{
; 585  : 		if( msg[i] == '\n' && msg[i+1] == '\r' )

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN7@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@Sys_Print

; 586  : 		{
; 587  : 			b[0] = '\r';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx+ecx], 13			; 0000000dH

; 588  : 			b[1] = c[0] = '\n';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [edx+ecx], 10			; 0000000aH
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx+eax], 10			; 0000000aH

; 589  : 			b += 2, c++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 2
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 590  : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 591  : 		}

	jmp	$LN8@Sys_Print
$LN7@Sys_Print:

; 592  : 		else if( msg[i] == '\r' )

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@Sys_Print

; 593  : 		{
; 594  : 			b[0] = c[0] = '\r';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [edx+ecx], 13			; 0000000dH
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx+ecx], 13			; 0000000dH

; 595  : 			b[1] = '\n';

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx+eax], 10			; 0000000aH

; 596  : 			b += 2, c++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 2
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 597  : 		}

	jmp	$LN8@Sys_Print
$LN9@Sys_Print:

; 598  : 		else if( msg[i] == '\n' )

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN11@Sys_Print

; 599  : 		{
; 600  : 			b[0] = '\r';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [edx+ecx], 13			; 0000000dH

; 601  : 			b[1] = c[0] = '\n';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [edx+ecx], 10			; 0000000aH
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx+eax], 10			; 0000000aH

; 602  : 			b += 2, c++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 2
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx

; 603  : 		}

	jmp	$LN8@Sys_Print
$LN11@Sys_Print:

; 604  : 		else if( msg[i] == '\35' || msg[i] == '\36' || msg[i] == '\37' )

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 29					; 0000001dH
	je	SHORT $LN15@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 30					; 0000001eH
	je	SHORT $LN15@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 31					; 0000001fH
	jne	SHORT $LN13@Sys_Print
$LN15@Sys_Print:

; 605  : 		{
; 606  : 			i++; // skip console pseudo graph

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 607  : 		}

	jmp	$LN8@Sys_Print
$LN13@Sys_Print:

; 608  : 		else if( IsColorString( &msg[i] ))

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	je	SHORT $LN16@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN16@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN16@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN16@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN16@Sys_Print

; 609  : 		{
; 610  : 			i++; // skip color prefix

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 611  : 		}

	jmp	SHORT $LN8@Sys_Print
$LN16@Sys_Print:

; 612  : 		else
; 613  : 		{
; 614  : 			if( msg[i] == '\1' || msg[i] == '\2' )

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN19@Sys_Print
	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 2
	jne	SHORT $LN18@Sys_Print
$LN19@Sys_Print:

; 615  : 				i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@Sys_Print:

; 616  : 			*b = *c = msg[i];

	mov	eax, DWORD PTR _msg$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 617  : 			b++, c++;

	mov	eax, DWORD PTR _b$[ebp]
	add	eax, 1
	mov	DWORD PTR _b$[ebp], eax
	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 1
	mov	DWORD PTR _c$[ebp], ecx
$LN8@Sys_Print:

; 618  : 		}
; 619  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 620  : 	}

	jmp	$LN2@Sys_Print
$LN3@Sys_Print:

; 621  : 
; 622  : 	*b = *c = 0; // terminator

	mov	eax, DWORD PTR _c$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], 0

; 623  : 
; 624  : 	Sys_PrintLog( logbuf );

	push	OFFSET ?logbuf@?1??Sys_Print@@9@9
	call	_Sys_PrintLog
	add	esp, 4

; 625  : 	Con_WinPrint( buffer );

	push	OFFSET ?buffer@?1??Sys_Print@@9@9
	call	_Con_WinPrint
	add	esp, 4

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_SendKeyEvents
_TEXT	SEGMENT
_msg$ = -28						; size = 28
_Sys_SendKeyEvents PROC					; COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
$LN2@Sys_SendKe:

; 347  : 	MSG	msg;
; 348  : 
; 349  : 	while( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ))

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	SHORT $LN1@Sys_SendKe

; 350  : 	{
; 351  : 		if( !GetMessage( &msg, NULL, 0, 0 ))

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	jne	SHORT $LN4@Sys_SendKe

; 352  : 			Sys_Quit ();

	call	_Sys_Quit
$LN4@Sys_SendKe:

; 353  : 
; 354  :       		TranslateMessage( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4

; 355  :       		DispatchMessage( &msg );

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4

; 356  : 	}

	jmp	SHORT $LN2@Sys_SendKe
$LN1@Sys_SendKe:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_SendKeyEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_GetMachineKey
_TEXT	SEGMENT
_i$ = -40						; size = 4
_uuid$ = -36						; size = 16
_mac$ = -20						; size = 8
_pUuidCreateSequential$ = -12				; size = 4
_rpcrt4_dll$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_nLength$ = 8						; size = 4
_Sys_GetMachineKey PROC					; COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 153  : 	HINSTANCE		rpcrt4_dll = LoadLibrary( "rpcrt4.dll" );

	push	OFFSET ??_C@_0L@IKBIFNGI@rpcrt4?4dll@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _rpcrt4_dll$[ebp], eax

; 154  : 	RPC_STATUS	(_stdcall *pUuidCreateSequential)( UUID __RPC_FAR *Uuid ) = NULL;

	mov	DWORD PTR _pUuidCreateSequential$[ebp], 0

; 155  : 	static byte	key[32];
; 156  : 	byte		mac[8];
; 157  : 	UUID		uuid;
; 158  : 	int		i;
; 159  : 
; 160  : 	if( rpcrt4_dll ) pUuidCreateSequential = (void *)GetProcAddress( rpcrt4_dll, "UuidCreateSequential" );

	cmp	DWORD PTR _rpcrt4_dll$[ebp], 0
	je	SHORT $LN5@Sys_GetMac
	push	OFFSET ??_C@_0BF@DJFPALMK@UuidCreateSequential@
	mov	eax, DWORD PTR _rpcrt4_dll$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pUuidCreateSequential$[ebp], eax
$LN5@Sys_GetMac:

; 161  : 	if( pUuidCreateSequential ) pUuidCreateSequential( &uuid );	// ask OS to create UUID

	cmp	DWORD PTR _pUuidCreateSequential$[ebp], 0
	je	SHORT $LN6@Sys_GetMac
	lea	eax, DWORD PTR _uuid$[ebp]
	push	eax
	call	DWORD PTR _pUuidCreateSequential$[ebp]
$LN6@Sys_GetMac:

; 162  : 	if( rpcrt4_dll ) FreeLibrary( rpcrt4_dll ); // no need anymore...

	cmp	DWORD PTR _rpcrt4_dll$[ebp], 0
	je	SHORT $LN7@Sys_GetMac
	mov	eax, DWORD PTR _rpcrt4_dll$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4
$LN7@Sys_GetMac:

; 163  : 
; 164  : 	for( i = 2; i < 8; i++ ) // bytes 2 through 7 inclusive are MAC address

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN4@Sys_GetMac
$LN2@Sys_GetMac:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Sys_GetMac:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN3@Sys_GetMac

; 165  : 		mac[i-2] = uuid.Data4[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _uuid$[ebp+ecx+8]
	mov	BYTE PTR _mac$[ebp+eax-2], dl
	jmp	SHORT $LN2@Sys_GetMac
$LN3@Sys_GetMac:

; 166  : 
; 167  : 	Q_snprintf( key, sizeof( key ), "%02X-%02X-%02X-%02X-%02X-%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] );

	mov	eax, 1
	imul	ecx, eax, 5
	movzx	edx, BYTE PTR _mac$[ebp+ecx]
	push	edx
	mov	eax, 1
	shl	eax, 2
	movzx	ecx, BYTE PTR _mac$[ebp+eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 3
	movzx	ecx, BYTE PTR _mac$[ebp+eax]
	push	ecx
	mov	edx, 1
	shl	edx, 1
	movzx	eax, BYTE PTR _mac$[ebp+edx]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _mac$[ebp+ecx]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _mac$[ebp+ecx]
	push	edx
	push	OFFSET ??_C@_0BO@GHBLPFMO@?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X?9?$CF02X@
	push	32					; 00000020H
	push	OFFSET ?key@?1??Sys_GetMachineKey@@9@9
	call	_Q_snprintf
	add	esp, 36					; 00000024H

; 168  : 
; 169  : 	if( nLength ) *nLength = Q_strlen( key );

	cmp	DWORD PTR _nLength$[ebp], 0
	je	SHORT $LN8@Sys_GetMac
	push	OFFSET ?key@?1??Sys_GetMachineKey@@9@9
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR [ecx], eax
$LN8@Sys_GetMac:

; 170  : 	return key;

	mov	eax, OFFSET ?key@?1??Sys_GetMachineKey@@9@9

; 171  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_GetMachineKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_ShellExecute
_TEXT	SEGMENT
_pShellExecuteA$ = -8					; size = 4
_shell32_dll$ = -4					; size = 4
_path$ = 8						; size = 4
_parms$ = 12						; size = 4
_exit$ = 16						; size = 4
_Sys_ShellExecute PROC					; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 180  : 	HINSTANCE	shell32_dll = LoadLibrary( "shell32.dll" );

	push	OFFSET ??_C@_0M@KFDNOLCO@shell32?4dll@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _shell32_dll$[ebp], eax

; 181  : 	HINSTANCE (_stdcall *pShellExecuteA)( HWND hwnd, LPCSTR lpOp, LPCSTR lpFile, LPCSTR lpParam, LPCSTR lpDir, INT nShowCmd ) = NULL;

	mov	DWORD PTR _pShellExecuteA$[ebp], 0

; 182  : 	if( shell32_dll ) pShellExecuteA = (void *)GetProcAddress( shell32_dll, "ShellExecuteA" );

	cmp	DWORD PTR _shell32_dll$[ebp], 0
	je	SHORT $LN2@Sys_ShellE
	push	OFFSET ??_C@_0O@MOHFGHHE@ShellExecuteA@
	mov	eax, DWORD PTR _shell32_dll$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pShellExecuteA$[ebp], eax
$LN2@Sys_ShellE:

; 183  : 	if( pShellExecuteA ) pShellExecuteA( NULL, "open", path, parms, NULL, SW_SHOW );

	cmp	DWORD PTR _pShellExecuteA$[ebp], 0
	je	SHORT $LN3@Sys_ShellE
	push	5
	push	0
	mov	eax, DWORD PTR _parms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	push	OFFSET ??_C@_04PMOCAHAA@open@
	push	0
	call	DWORD PTR _pShellExecuteA$[ebp]
$LN3@Sys_ShellE:

; 184  : 	if( shell32_dll ) FreeLibrary( shell32_dll ); // no need anymore...

	cmp	DWORD PTR _shell32_dll$[ebp], 0
	je	SHORT $LN4@Sys_ShellE
	mov	eax, DWORD PTR _shell32_dll$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4
$LN4@Sys_ShellE:

; 185  : 
; 186  : 	if( exit ) Sys_Quit();

	cmp	DWORD PTR _exit$[ebp], 0
	je	SHORT $LN1@Sys_ShellE
	call	_Sys_Quit
$LN1@Sys_ShellE:

; 187  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_ShellExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT __Sys_GetParmFromCmdLine
_TEXT	SEGMENT
_argc$ = -4						; size = 4
_parm$ = 8						; size = 4
_out$ = 12						; size = 4
_size$ = 16						; size = 4
__Sys_GetParmFromCmdLine PROC				; COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 335  : 	int	argc = Sys_CheckParm( parm );

	mov	eax, DWORD PTR _parm$[ebp]
	push	eax
	call	_Sys_CheckParm
	add	esp, 4
	mov	DWORD PTR _argc$[ebp], eax

; 336  : 
; 337  : 	if( !argc || !out || !host.argv[argc + 1] )

	cmp	DWORD PTR _argc$[ebp], 0
	je	SHORT $LN3@Sys_GetPar
	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $LN3@Sys_GetPar
	mov	eax, DWORD PTR _argc$[ebp]
	cmp	DWORD PTR _host[eax*4+928], 0
	jne	SHORT $LN2@Sys_GetPar
$LN3@Sys_GetPar:

; 338  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Sys_GetPar
$LN2@Sys_GetPar:

; 339  : 
; 340  : 	Q_strncpy( out, host.argv[argc+1], size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+928]
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 341  : 
; 342  : 	return true;

	mov	eax, 1
$LN1@Sys_GetPar:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Sys_GetParmFromCmdLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_SetClipboardData
_TEXT	SEGMENT
_bufferCopy$1 = -8					; size = 4
_hResult$2 = -4						; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_Sys_SetClipboardData PROC				; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 89   : 	EmptyClipboard();

	call	DWORD PTR __imp__EmptyClipboard@0

; 90   : 
; 91   : 	if( OpenClipboard( NULL ) != 0 )

	push	0
	call	DWORD PTR __imp__OpenClipboard@4
	test	eax, eax
	je	SHORT $LN1@Sys_SetCli

; 92   : 	{
; 93   : 		HGLOBAL hResult = GlobalAlloc( GMEM_MOVEABLE, size ); 

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	2
	call	DWORD PTR __imp__GlobalAlloc@8
	mov	DWORD PTR _hResult$2[ebp], eax

; 94   : 		byte *bufferCopy = (byte *)GlobalLock( hResult ); 

	mov	eax, DWORD PTR _hResult$2[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalLock@4
	mov	DWORD PTR _bufferCopy$1[ebp], eax

; 95   : 
; 96   : 		memcpy( bufferCopy, buffer, size ); 

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bufferCopy$1[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 97   : 		GlobalUnlock( hResult ); 

	mov	eax, DWORD PTR _hResult$2[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalUnlock@4

; 98   : 
; 99   : 		if( SetClipboardData( CF_DIB, hResult ) == NULL )

	mov	eax, DWORD PTR _hResult$2[ebp]
	push	eax
	push	8
	call	DWORD PTR __imp__SetClipboardData@8
	test	eax, eax
	jne	SHORT $LN3@Sys_SetCli

; 100  : 		{
; 101  : 			Con_Printf( S_ERROR "unable to write screenshot\n" );

	push	OFFSET ??_C@_0CH@EGIADOFJ@?$FO1Error?3?$FO7?5unable?5to?5write?5scre@
	call	_Con_Printf
	add	esp, 4

; 102  : 			GlobalFree( hResult );

	mov	eax, DWORD PTR _hResult$2[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalFree@4
$LN3@Sys_SetCli:

; 103  : 		}
; 104  : 		CloseClipboard();

	call	DWORD PTR __imp__CloseClipboard@0
$LN1@Sys_SetCli:

; 105  : 	}
; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_SetClipboardData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_Crash@4
_TEXT	SEGMENT
_pInfo$ = 8						; size = 4
_Sys_Crash@4 PROC					; COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 470  : 	// save config
; 471  : 	if( host.status != HOST_CRASHED )

	cmp	DWORD PTR _host+12, 6
	je	SHORT $LN2@Sys_Crash

; 472  : 	{
; 473  : 		// check to avoid recursive call
; 474  : 		error_on_exit = true;

	mov	DWORD PTR _error_on_exit, 1

; 475  : 		host.crashed = true;

	mov	DWORD PTR _host+34408, 1

; 476  : 
; 477  : 		if( host.type == HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN3@Sys_Crash

; 478  : 			CL_Crashed(); // tell client about crash

	call	_CL_Crashed
	jmp	SHORT $LN4@Sys_Crash
$LN3@Sys_Crash:

; 479  : 		else host.status = HOST_CRASHED;

	mov	DWORD PTR _host+12, 6
$LN4@Sys_Crash:

; 480  : 
; 481  : 		Con_Printf( "unhandled exception: %p at address %p\n", pInfo->ExceptionRecord->ExceptionAddress, pInfo->ExceptionRecord->ExceptionCode );

	mov	eax, DWORD PTR _pInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET ??_C@_0CH@PKCEIFMA@unhandled?5exception?3?5?$CFp?5at?5addr@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 482  : 
; 483  : 		if( !host_developer.value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Sys_Crash

; 484  : 		{
; 485  : 			// for non-development mode
; 486  : 			Sys_Quit();

	call	_Sys_Quit

; 487  : 			return EXCEPTION_CONTINUE_EXECUTION;

	or	eax, -1
	jmp	SHORT $LN1@Sys_Crash
$LN5@Sys_Crash:

; 488  : 		}
; 489  : 
; 490  : 		// all other states keep unchanged to let debugger find bug
; 491  : 		Con_DestroyConsole();

	call	_Con_DestroyConsole
$LN2@Sys_Crash:

; 492  : 	}
; 493  : 
; 494  : 	if( host.oldFilter )

	cmp	DWORD PTR _host+8, 0
	je	SHORT $LN6@Sys_Crash

; 495  : 		return host.oldFilter( pInfo );

	mov	eax, DWORD PTR _pInfo$[ebp]
	push	eax
	call	DWORD PTR _host+8
	jmp	SHORT $LN1@Sys_Crash
$LN6@Sys_Crash:

; 496  : 	return EXCEPTION_CONTINUE_EXECUTION;

	or	eax, -1
$LN1@Sys_Crash:

; 497  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_Sys_Crash@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_MergeCommandLine
_TEXT	SEGMENT
_lpCmdLine$ = 8						; size = 4
_Sys_MergeCommandLine PROC				; COMDAT

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 264  : 	static char	commandline[MAX_SYSPATH];
; 265  : 
; 266  : 	if( !host.change_game ) return;

	cmp	DWORD PTR _host+34368, 0
	jne	SHORT $LN10@Sys_MergeC
	jmp	$LN1@Sys_MergeC
$LN10@Sys_MergeC:

; 267  : 
; 268  : 	Q_strncpy( commandline, lpCmdLine, Q_strlen( lpCmdLine ) + 1 );

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	push	ecx
	push	OFFSET ?commandline@?1??Sys_MergeCommandLine@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 269  : 	lpCmdLine = commandline; // to prevent modify original commandline

	mov	DWORD PTR _lpCmdLine$[ebp], OFFSET ?commandline@?1??Sys_MergeCommandLine@@9@9
$LN2@Sys_MergeC:

; 270  : 
; 271  : 	while( *lpCmdLine && ( host.argc < MAX_NUM_ARGVS ))

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN1@Sys_MergeC
	cmp	DWORD PTR _host+920, 128		; 00000080H
	jge	$LN1@Sys_MergeC
$LN4@Sys_MergeC:

; 272  : 	{
; 273  : 		while( *lpCmdLine && *lpCmdLine <= ' ' )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Sys_MergeC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN5@Sys_MergeC

; 274  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN4@Sys_MergeC
$LN5@Sys_MergeC:

; 275  : 		if( !*lpCmdLine ) break;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN11@Sys_MergeC
	jmp	$LN1@Sys_MergeC
$LN11@Sys_MergeC:

; 276  : 
; 277  : 		if( *lpCmdLine == '\"' )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN12@Sys_MergeC

; 278  : 		{
; 279  : 			// quoted string
; 280  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax

; 281  : 			host.argv[host.argc] = lpCmdLine;

	mov	eax, DWORD PTR _host+920
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx

; 282  : 			host.argc++;

	mov	eax, DWORD PTR _host+920
	add	eax, 1
	mov	DWORD PTR _host+920, eax
$LN6@Sys_MergeC:

; 283  : 			while( *lpCmdLine && ( *lpCmdLine != '\"' ))

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@Sys_MergeC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN7@Sys_MergeC

; 284  : 				lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN6@Sys_MergeC
$LN7@Sys_MergeC:

; 285  : 		}

	jmp	SHORT $LN13@Sys_MergeC
$LN12@Sys_MergeC:

; 286  : 		else
; 287  : 		{
; 288  : 			// unquoted word
; 289  : 			host.argv[host.argc] = lpCmdLine;

	mov	eax, DWORD PTR _host+920
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx

; 290  : 			host.argc++;

	mov	eax, DWORD PTR _host+920
	add	eax, 1
	mov	DWORD PTR _host+920, eax
$LN8@Sys_MergeC:

; 291  : 			while( *lpCmdLine && *lpCmdLine > ' ')

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@Sys_MergeC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN13@Sys_MergeC

; 292  : 				lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN8@Sys_MergeC
$LN13@Sys_MergeC:

; 293  : 		}
; 294  : 
; 295  : 		if( *lpCmdLine )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN14@Sys_MergeC

; 296  : 		{
; 297  : 			*lpCmdLine = 0;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	mov	BYTE PTR [eax], 0

; 298  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
$LN14@Sys_MergeC:

; 299  : 		}
; 300  : 	}

	jmp	$LN2@Sys_MergeC
$LN1@Sys_MergeC:

; 301  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_MergeCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_ParseCommandLine
_TEXT	SEGMENT
_i$ = -8						; size = 4
_blank$ = -4						; size = 4
_lpCmdLine$ = 8						; size = 4
_uncensored$ = 12					; size = 4
_Sys_ParseCommandLine PROC				; COMDAT

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 197  : 	const char	*blank = "censored";

	mov	DWORD PTR _blank$[ebp], OFFSET ??_C@_08CHPFJPNL@censored@

; 198  : 	static char	commandline[MAX_SYSPATH];
; 199  : 	int		i;
; 200  : 
; 201  : 	host.argc = 1;

	mov	DWORD PTR _host+920, 1

; 202  : 	host.argv[0] = "exe";

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _host[ecx+924], OFFSET ??_C@_03JACLIBNI@exe@

; 203  : 
; 204  : 	Q_strncpy( commandline, lpCmdLine, Q_strlen( lpCmdLine ) + 1 );

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	push	ecx
	push	OFFSET ?commandline@?1??Sys_ParseCommandLine@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 205  : 	lpCmdLine = commandline; // to prevent modify original commandline

	mov	DWORD PTR _lpCmdLine$[ebp], OFFSET ?commandline@?1??Sys_ParseCommandLine@@9@9
$LN2@Sys_ParseC:

; 206  : 
; 207  : 	while( *lpCmdLine && ( host.argc < MAX_NUM_ARGVS ))

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Sys_ParseC
	cmp	DWORD PTR _host+920, 128		; 00000080H
	jge	$LN3@Sys_ParseC
$LN4@Sys_ParseC:

; 208  : 	{
; 209  : 		while( *lpCmdLine && *lpCmdLine <= ' ' )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Sys_ParseC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN5@Sys_ParseC

; 210  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN4@Sys_ParseC
$LN5@Sys_ParseC:

; 211  : 		if( !*lpCmdLine ) break;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN13@Sys_ParseC
	jmp	$LN3@Sys_ParseC
$LN13@Sys_ParseC:

; 212  : 
; 213  : 		if( *lpCmdLine == '\"' )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN14@Sys_ParseC

; 214  : 		{
; 215  : 			// quoted string
; 216  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax

; 217  : 			host.argv[host.argc] = lpCmdLine;

	mov	eax, DWORD PTR _host+920
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx

; 218  : 			host.argc++;

	mov	eax, DWORD PTR _host+920
	add	eax, 1
	mov	DWORD PTR _host+920, eax
$LN6@Sys_ParseC:

; 219  : 			while( *lpCmdLine && ( *lpCmdLine != '\"' ))

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@Sys_ParseC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN7@Sys_ParseC

; 220  : 				lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN6@Sys_ParseC
$LN7@Sys_ParseC:

; 221  : 		}

	jmp	SHORT $LN15@Sys_ParseC
$LN14@Sys_ParseC:

; 222  : 		else
; 223  : 		{
; 224  : 			// unquoted word
; 225  : 			host.argv[host.argc] = lpCmdLine;

	mov	eax, DWORD PTR _host+920
	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx

; 226  : 			host.argc++;

	mov	eax, DWORD PTR _host+920
	add	eax, 1
	mov	DWORD PTR _host+920, eax
$LN8@Sys_ParseC:

; 227  : 			while( *lpCmdLine && *lpCmdLine > ' ')

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN15@Sys_ParseC
	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN15@Sys_ParseC

; 228  : 				lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
	jmp	SHORT $LN8@Sys_ParseC
$LN15@Sys_ParseC:

; 229  : 		}
; 230  : 
; 231  : 		if( *lpCmdLine )

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN16@Sys_ParseC

; 232  : 		{
; 233  : 			*lpCmdLine = 0;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	mov	BYTE PTR [eax], 0

; 234  : 			lpCmdLine++;

	mov	eax, DWORD PTR _lpCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpCmdLine$[ebp], eax
$LN16@Sys_ParseC:

; 235  : 		}
; 236  : 	}

	jmp	$LN2@Sys_ParseC
$LN3@Sys_ParseC:

; 237  : 
; 238  : 	if( uncensored || !host.change_game )

	cmp	DWORD PTR _uncensored$[ebp], 0
	jne	SHORT $LN18@Sys_ParseC
	cmp	DWORD PTR _host+34368, 0
	jne	SHORT $LN17@Sys_ParseC
$LN18@Sys_ParseC:

; 239  : 		return;

	jmp	$LN1@Sys_ParseC
$LN17@Sys_ParseC:

; 240  : 
; 241  : 	for( i = 0; i < host.argc; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@Sys_ParseC
$LN10@Sys_ParseC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@Sys_ParseC:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+920
	jge	$LN1@Sys_ParseC

; 242  : 	{
; 243  : 		// we wan't return to first game
; 244  : 		if( !Q_stricmp( "-game", host.argv[i] )) host.argv[i] = (char *)blank;

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	push	OFFSET ??_C@_05FACLEBO@?9game@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@Sys_ParseC
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx
$LN19@Sys_ParseC:

; 245  : 		// probably it's timewaster, because engine rejected second change
; 246  : 		if( !Q_stricmp( "+game", host.argv[i] )) host.argv[i] = (char *)blank;

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	push	OFFSET ??_C@_05NDFLFHAD@?$CLgame@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@Sys_ParseC
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx
$LN20@Sys_ParseC:

; 247  : 		// you sure what is map exists in new game?
; 248  : 		if( !Q_stricmp( "+map", host.argv[i] )) host.argv[i] = (char *)blank;

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	push	OFFSET ??_C@_04CAKKOBMI@?$CLmap@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Sys_ParseC
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx
$LN21@Sys_ParseC:

; 249  : 		// just stupid action
; 250  : 		if( !Q_stricmp( "+load", host.argv[i] )) host.argv[i] = (char *)blank;

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	push	OFFSET ??_C@_05FEFFNJAE@?$CLload@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@Sys_ParseC
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx
$LN22@Sys_ParseC:

; 251  : 		// changelevel beetwen games? wow it's great idea!
; 252  : 		if( !Q_stricmp( "+changelevel", host.argv[i] )) host.argv[i] = (char *)blank;

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	push	OFFSET ??_C@_0N@FPCHJOAK@?$CLchangelevel@
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@Sys_ParseC
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _blank$[ebp]
	mov	DWORD PTR _host[eax*4+924], ecx
$LN23@Sys_ParseC:

; 253  : 	}

	jmp	$LN10@Sys_ParseC
$LN1@Sys_ParseC:

; 254  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_ParseCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_FreeLibrary
_TEXT	SEGMENT
_dll$ = 8						; size = 4
_Sys_FreeLibrary PROC					; COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 423  : 	// invalid desc or alredy freed
; 424  : 	if( !dll || !dll->link )

	cmp	DWORD PTR _dll$[ebp], 0
	je	SHORT $LN3@Sys_FreeLi
	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN2@Sys_FreeLi
$LN3@Sys_FreeLi:

; 425  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Sys_FreeLi
$LN2@Sys_FreeLi:

; 426  : 
; 427  : 	if( host.status == HOST_CRASHED )

	cmp	DWORD PTR _host+12, 6
	jne	SHORT $LN4@Sys_FreeLi

; 428  : 	{
; 429  : 		// we need to hold down all modules, while MSVC can find error
; 430  : 		Con_Reportf( "Sys_FreeLibrary: hold %s for debugging\n", dll->name );

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CI@LPEJNEKE@Sys_FreeLibrary?3?5hold?5?$CFs?5for?5de@
	call	_Con_Reportf
	add	esp, 8

; 431  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@Sys_FreeLi

; 432  : 	}

	jmp	SHORT $LN5@Sys_FreeLi
$LN4@Sys_FreeLi:

; 433  : 	else Con_Reportf( "Sys_FreeLibrary: Unloading %s\n", dll->name );

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BP@HELNEIHJ@Sys_FreeLibrary?3?5Unloading?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 8
$LN5@Sys_FreeLi:

; 434  : 
; 435  : 	FreeLibrary( dll->link );

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4

; 436  : 	dll->link = NULL;

	mov	eax, DWORD PTR _dll$[ebp]
	mov	DWORD PTR [eax+12], 0

; 437  : 
; 438  : 	return true;

	mov	eax, 1
$LN1@Sys_FreeLi:

; 439  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_FreeLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_GetProcAddress
_TEXT	SEGMENT
_dll$ = 8						; size = 4
_name$ = 12						; size = 4
_Sys_GetProcAddress PROC				; COMDAT

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 415  : 	if( !dll || !dll->link ) // invalid desc

	cmp	DWORD PTR _dll$[ebp], 0
	je	SHORT $LN3@Sys_GetPro
	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN2@Sys_GetPro
$LN3@Sys_GetPro:

; 416  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Sys_GetPro
$LN2@Sys_GetPro:

; 417  : 
; 418  : 	return (void *)GetProcAddress( dll->link, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dll$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
$LN1@Sys_GetPro:

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_GetProcAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_LoadLibrary
_TEXT	SEGMENT
tv136 = -332						; size = 4
_errorstring$ = -264					; size = 256
_func$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_dll$ = 8						; size = 4
_Sys_LoadLibrary PROC					; COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 364  : 	const dllfunc_t	*func;
; 365  : 	string		errorstring;
; 366  : 
; 367  : 	// check errors
; 368  : 	if( !dll ) return false;	// invalid desc

	cmp	DWORD PTR _dll$[ebp], 0
	jne	SHORT $LN8@Sys_LoadLi
	xor	eax, eax
	jmp	$LN1@Sys_LoadLi
$LN8@Sys_LoadLi:

; 369  : 	if( dll->link ) return true;	// already loaded

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN9@Sys_LoadLi
	mov	eax, 1
	jmp	$LN1@Sys_LoadLi
$LN9@Sys_LoadLi:

; 370  : 
; 371  : 	if( !dll->name || !*dll->name )

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@Sys_LoadLi
	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN10@Sys_LoadLi
$LN11@Sys_LoadLi:

; 372  : 		return false; // nothing to load

	xor	eax, eax
	jmp	$LN1@Sys_LoadLi
$LN10@Sys_LoadLi:

; 373  : 
; 374  : 	Con_Reportf( "Sys_LoadLibrary: Loading %s", dll->name );

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BM@BKNDDBKO@Sys_LoadLibrary?3?5Loading?5?$CFs@
	call	_Con_Reportf
	add	esp, 8

; 375  : 
; 376  : 	if( dll->fcts ) 

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN12@Sys_LoadLi

; 377  : 	{
; 378  : 		// lookup export table
; 379  : 		for( func = dll->fcts; func && func->name != NULL; func++ )

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _func$[ebp], ecx
	jmp	SHORT $LN4@Sys_LoadLi
$LN2@Sys_LoadLi:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN4@Sys_LoadLi:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN12@Sys_LoadLi
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN12@Sys_LoadLi

; 380  : 			*func->func = NULL;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@Sys_LoadLi
$LN12@Sys_LoadLi:

; 381  : 	}
; 382  : 
; 383  : 	if( !dll->link ) dll->link = LoadLibrary ( dll->name ); // environment pathes

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN13@Sys_LoadLi
	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	edx, DWORD PTR _dll$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN13@Sys_LoadLi:

; 384  : 
; 385  : 	// no DLL found
; 386  : 	if( !dll->link ) 

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN14@Sys_LoadLi

; 387  : 	{
; 388  : 		Q_snprintf( errorstring, sizeof( errorstring ), "Sys_LoadLibrary: couldn't load %s\n", dll->name );

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CD@OIFBLFOH@Sys_LoadLibrary?3?5couldn?8t?5load?5@
	push	256					; 00000100H
	lea	edx, DWORD PTR _errorstring$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 389  : 		goto error;

	jmp	$error$19
$LN14@Sys_LoadLi:

; 390  : 	}
; 391  : 
; 392  : 	// Get the function adresses
; 393  : 	for( func = dll->fcts; func && func->name != NULL; func++ )

	mov	eax, DWORD PTR _dll$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _func$[ebp], ecx
	jmp	SHORT $LN7@Sys_LoadLi
$LN5@Sys_LoadLi:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN7@Sys_LoadLi:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN6@Sys_LoadLi
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Sys_LoadLi

; 394  : 	{
; 395  : 		if( !( *func->func = Sys_GetProcAddress( dll, func->name )))

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _dll$[ebp]
	push	edx
	call	_Sys_GetProcAddress
	add	esp, 8
	mov	DWORD PTR tv136[ebp], eax
	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR tv136[ebp], 0
	jne	SHORT $LN15@Sys_LoadLi

; 396  : 		{
; 397  : 			Q_snprintf( errorstring, sizeof( errorstring ), "Sys_LoadLibrary: %s missing or invalid function (%s)\n", dll->name, func->name );

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _dll$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DG@EDDNHCNN@Sys_LoadLibrary?3?5?$CFs?5missing?5or?5@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _errorstring$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 398  : 			goto error;

	jmp	SHORT $error$19
$LN15@Sys_LoadLi:

; 399  : 		}
; 400  : 	}

	jmp	SHORT $LN5@Sys_LoadLi
$LN6@Sys_LoadLi:

; 401  :           Con_Reportf( " - ok\n" );

	push	OFFSET ??_C@_06KPFALOP@?5?9?5ok?6@
	call	_Con_Reportf
	add	esp, 4

; 402  : 
; 403  : 	return true;

	mov	eax, 1
	jmp	SHORT $LN1@Sys_LoadLi
$error$19:

; 404  : error:
; 405  : 	Con_Reportf( " - failed\n" );

	push	OFFSET ??_C@_0L@NLADGNPD@?5?9?5failed?6@
	call	_Con_Reportf
	add	esp, 4

; 406  : 	Sys_FreeLibrary( dll ); // trying to free 

	mov	eax, DWORD PTR _dll$[ebp]
	push	eax
	call	_Sys_FreeLibrary
	add	esp, 4

; 407  : 	if( dll->crash ) Sys_Error( errorstring );

	mov	eax, DWORD PTR _dll$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN16@Sys_LoadLi
	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	call	_Sys_Error
	add	esp, 4
	jmp	SHORT $LN17@Sys_LoadLi
$LN16@Sys_LoadLi:

; 408  : 	else Con_DPrintf( "%s%s", S_ERROR, errorstring );			

	lea	eax, DWORD PTR _errorstring$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@LPMAAKMD@?$FO1Error?3?$FO7?5@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN17@Sys_LoadLi:

; 409  : 
; 410  : 	return false;

	xor	eax, eax
$LN1@Sys_LoadLi:

; 411  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_LoadLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_Error
_TEXT	SEGMENT
_text$ = -1032						; size = 1024
_argptr$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_error$ = 8						; size = 4
_Sys_Error PROC						; COMDAT

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 509  : 	va_list	argptr;
; 510  : 	char	text[MAX_SYSPATH];
; 511  :          
; 512  : 	if( host.status == HOST_ERR_FATAL )

	cmp	DWORD PTR _host+12, 3
	jne	SHORT $LN2@Sys_Error

; 513  : 		return; // don't multiple executes

	jmp	$LN1@Sys_Error
$LN2@Sys_Error:

; 514  : 
; 515  : 	// make sure what console received last message
; 516  : 	if( host.change_game ) Sys_Sleep( 200 );

	cmp	DWORD PTR _host+34368, 0
	je	SHORT $LN3@Sys_Error
	push	200					; 000000c8H
	call	_Sys_Sleep
	add	esp, 4
$LN3@Sys_Error:

; 517  : 
; 518  : 	error_on_exit = true;

	mov	DWORD PTR _error_on_exit, 1

; 519  : 	host.status = HOST_ERR_FATAL;	

	mov	DWORD PTR _host+12, 3

; 520  : 	va_start( argptr, error );

	lea	eax, DWORD PTR _error$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 521  : 	Q_vsprintf( text, error, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _error$[ebp]
	push	ecx
	push	99999					; 0001869fH
	lea	edx, DWORD PTR _text$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 522  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 523  : 
; 524  : 	SV_SysError( text );

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_SV_SysError
	add	esp, 4

; 525  : 
; 526  : 	if( host.type == HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN5@Sys_Error

; 527  : 	{
; 528  : 		if( host.hWnd ) ShowWindow( host.hWnd, SW_HIDE );

	cmp	DWORD PTR _host+34332, 0
	je	SHORT $LN5@Sys_Error
	push	0
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN5@Sys_Error:

; 529  : 	}
; 530  : 
; 531  : 	if( host_developer.value )

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@Sys_Error

; 532  : 	{
; 533  : 		Con_ShowConsole( true );

	push	1
	call	_Con_ShowConsole
	add	esp, 4

; 534  : 		Con_DisableInput();	// disable input line for dedicated server

	call	_Con_DisableInput

; 535  : 		Sys_Print( text );	// print error message

	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Sys_Print
	add	esp, 4

; 536  : 		Sys_WaitForQuit();

	call	_Sys_WaitForQuit

; 537  : 	}

	jmp	SHORT $LN7@Sys_Error
$LN6@Sys_Error:

; 538  : 	else
; 539  : 	{
; 540  : 		Con_ShowConsole( false );

	push	0
	call	_Con_ShowConsole
	add	esp, 4

; 541  : 		MSGBOX( text );

	push	65552					; 00010010H
	push	OFFSET ??_C@_0L@COIOLHLA@Xash?5Error@
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__MessageBoxA@16
$LN7@Sys_Error:

; 542  : 	}
; 543  : 
; 544  : 	Sys_Quit();

	call	_Sys_Quit
$LN1@Sys_Error:

; 545  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_Error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_CheckParm
_TEXT	SEGMENT
_i$ = -4						; size = 4
_parm$ = 8						; size = 4
_Sys_CheckParm PROC					; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 313  : 	int	i;
; 314  : 
; 315  : 	for( i = 1; i < host.argc; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Sys_CheckP
$LN2@Sys_CheckP:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Sys_CheckP:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+920
	jge	SHORT $LN3@Sys_CheckP

; 316  : 	{
; 317  : 		if( !host.argv[i] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _host[eax*4+924], 0
	jne	SHORT $LN5@Sys_CheckP

; 318  : 			continue;

	jmp	SHORT $LN2@Sys_CheckP
$LN5@Sys_CheckP:

; 319  : 
; 320  : 		if( !Q_stricmp( parm, host.argv[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	mov	edx, DWORD PTR _parm$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@Sys_CheckP

; 321  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@Sys_CheckP
$LN6@Sys_CheckP:

; 322  : 	}

	jmp	SHORT $LN2@Sys_CheckP
$LN3@Sys_CheckP:

; 323  : 	return 0;

	xor	eax, eax
$LN1@Sys_CheckP:

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_CheckParm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_GetCurrentUser
_TEXT	SEGMENT
_pGetUserNameA$1 = -12					; size = 4
_advapi32_dll$2 = -8					; size = 4
_size$ = -4						; size = 4
_Sys_GetCurrentUser PROC				; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 130  : 	static string	sys_user_name;
; 131  : 	dword		size = sizeof( sys_user_name );

	mov	DWORD PTR _size$[ebp], 256		; 00000100H

; 132  : 
; 133  : 	if( !sys_user_name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR ?sys_user_name@?1??Sys_GetCurrentUser@@9@9[ecx]
	test	edx, edx
	jne	SHORT $LN2@Sys_GetCur

; 134  : 	{
; 135  : 		HINSTANCE	advapi32_dll = LoadLibrary( "advapi32.dll" );

	push	OFFSET ??_C@_0N@INAGJMNN@advapi32?4dll@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _advapi32_dll$2[ebp], eax

; 136  : 		BOOL (_stdcall *pGetUserNameA)( LPSTR lpBuffer, LPDWORD nSize ) = NULL;

	mov	DWORD PTR _pGetUserNameA$1[ebp], 0

; 137  : 		if( advapi32_dll ) pGetUserNameA = (void *)GetProcAddress( advapi32_dll, "GetUserNameA" );

	cmp	DWORD PTR _advapi32_dll$2[ebp], 0
	je	SHORT $LN3@Sys_GetCur
	push	OFFSET ??_C@_0N@EEKCKEJG@GetUserNameA@
	mov	eax, DWORD PTR _advapi32_dll$2[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pGetUserNameA$1[ebp], eax
$LN3@Sys_GetCur:

; 138  : 		if( pGetUserNameA) pGetUserNameA( sys_user_name, &size );

	cmp	DWORD PTR _pGetUserNameA$1[ebp], 0
	je	SHORT $LN4@Sys_GetCur
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	OFFSET ?sys_user_name@?1??Sys_GetCurrentUser@@9@9
	call	DWORD PTR _pGetUserNameA$1[ebp]
$LN4@Sys_GetCur:

; 139  : 		if( advapi32_dll ) FreeLibrary( advapi32_dll ); // no need anymore...

	cmp	DWORD PTR _advapi32_dll$2[ebp], 0
	je	SHORT $LN5@Sys_GetCur
	mov	eax, DWORD PTR _advapi32_dll$2[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4
$LN5@Sys_GetCur:

; 140  : 		if( !sys_user_name[0] ) Q_strcpy( sys_user_name, "player" );

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR ?sys_user_name@?1??Sys_GetCurrentUser@@9@9[ecx]
	test	edx, edx
	jne	SHORT $LN2@Sys_GetCur
	push	99999					; 0001869fH
	push	OFFSET ??_C@_06BALNJMNP@player@
	push	OFFSET ?sys_user_name@?1??Sys_GetCurrentUser@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN2@Sys_GetCur:

; 141  : 	}
; 142  : 
; 143  : 	return sys_user_name;

	mov	eax, OFFSET ?sys_user_name@?1??Sys_GetCurrentUser@@9@9

; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_GetCurrentUser ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_GetClipboardData
_TEXT	SEGMENT
_hClipboardData$1 = -8					; size = 4
_cliptext$ = -4						; size = 4
_Sys_GetClipboardData PROC				; COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 51   : 	static char	*data = NULL;
; 52   : 	char		*cliptext;
; 53   : 
; 54   : 	if( data )

	cmp	DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9, 0
	je	SHORT $LN2@Sys_GetCli

; 55   : 	{
; 56   : 		// release previous cbd
; 57   : 		Z_Free( data );

	cmp	DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9, 0
	je	SHORT $LN3@Sys_GetCli
	mov	eax, DWORD PTR ?__LINE__Var@?0??Sys_GetClipboardData@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DE@IFFDAPML@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@Sys_GetCli:

; 58   : 		data = NULL;

	mov	DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9, 0
$LN2@Sys_GetCli:

; 59   : 	}
; 60   : 
; 61   : 	if( OpenClipboard( NULL ) != 0 )

	push	0
	call	DWORD PTR __imp__OpenClipboard@4
	test	eax, eax
	je	SHORT $LN4@Sys_GetCli

; 62   : 	{
; 63   : 		HANDLE	hClipboardData;
; 64   : 
; 65   : 		if(( hClipboardData = GetClipboardData( CF_TEXT )) != 0 )

	push	1
	call	DWORD PTR __imp__GetClipboardData@4
	mov	DWORD PTR _hClipboardData$1[ebp], eax
	cmp	DWORD PTR _hClipboardData$1[ebp], 0
	je	SHORT $LN5@Sys_GetCli

; 66   : 		{
; 67   : 			if(( cliptext = GlobalLock( hClipboardData )) != 0 ) 

	mov	eax, DWORD PTR _hClipboardData$1[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalLock@4
	mov	DWORD PTR _cliptext$[ebp], eax
	cmp	DWORD PTR _cliptext$[ebp], 0
	je	SHORT $LN5@Sys_GetCli

; 68   : 			{
; 69   : 				data = Z_Malloc( GlobalSize( hClipboardData ) + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Sys_GetClipboardData@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DE@IFFDAPML@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _hClipboardData$1[ebp]
	push	ecx
	call	DWORD PTR __imp__GlobalSize@4
	add	eax, 1
	push	eax
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9, eax

; 70   : 				Q_strcpy( data, cliptext );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cliptext$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 71   : 				GlobalUnlock( hClipboardData );

	mov	eax, DWORD PTR _hClipboardData$1[ebp]
	push	eax
	call	DWORD PTR __imp__GlobalUnlock@4
$LN5@Sys_GetCli:

; 72   : 			}
; 73   : 		}
; 74   : 		CloseClipboard();

	call	DWORD PTR __imp__CloseClipboard@0
$LN4@Sys_GetCli:

; 75   : 	}
; 76   : 
; 77   : 	return data;

	mov	eax, DWORD PTR ?data@?1??Sys_GetClipboardData@@9@9

; 78   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_GetClipboardData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_DoubleTime
_TEXT	SEGMENT
tv88 = -88						; size = 8
tv91 = -80						; size = 8
_CurrentTime$ = -8					; size = 8
_Sys_DoubleTime PROC					; COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 28   : 	static LARGE_INTEGER	g_PerformanceFrequency;
; 29   : 	static LARGE_INTEGER	g_ClockStart;
; 30   : 	LARGE_INTEGER		CurrentTime;
; 31   : 
; 32   : 	if( !g_PerformanceFrequency.QuadPart )

	mov	eax, DWORD PTR ?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9
	or	eax, DWORD PTR ?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9+4
	jne	SHORT $LN2@Sys_Double

; 33   : 	{
; 34   : 		QueryPerformanceFrequency( &g_PerformanceFrequency );

	push	OFFSET ?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 35   : 		QueryPerformanceCounter( &g_ClockStart );

	push	OFFSET ?g_ClockStart@?1??Sys_DoubleTime@@9@9
	call	DWORD PTR __imp__QueryPerformanceCounter@4
$LN2@Sys_Double:

; 36   : 	}
; 37   : 	QueryPerformanceCounter( &CurrentTime );

	lea	eax, DWORD PTR _CurrentTime$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 38   : 
; 39   : 	return (double)( CurrentTime.QuadPart - g_ClockStart.QuadPart ) / (double)( g_PerformanceFrequency.QuadPart );

	mov	ecx, DWORD PTR _CurrentTime$[ebp]
	sub	ecx, DWORD PTR ?g_ClockStart@?1??Sys_DoubleTime@@9@9
	mov	edx, DWORD PTR _CurrentTime$[ebp+4]
	sbb	edx, DWORD PTR ?g_ClockStart@?1??Sys_DoubleTime@@9@9+4
	call	__ltod3
	mov	edx, DWORD PTR ?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9+4
	mov	ecx, DWORD PTR ?g_PerformanceFrequency@?1??Sys_DoubleTime@@9@9
	movsd	QWORD PTR tv91[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv91[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR tv88[ebp], xmm1
	fld	QWORD PTR tv88[ebp]

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_DoubleTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\sys_win.c
;	COMDAT _Sys_Sleep
_TEXT	SEGMENT
tv67 = -72						; size = 4
tv66 = -68						; size = 4
_msec$ = 8						; size = 4
_Sys_Sleep PROC						; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 117  : 	msec = bound( 0, msec, 1000 );

	cmp	DWORD PTR _msec$[ebp], 0
	jl	SHORT $LN5@Sys_Sleep
	cmp	DWORD PTR _msec$[ebp], 1000		; 000003e8H
	jge	SHORT $LN3@Sys_Sleep
	mov	eax, DWORD PTR _msec$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Sys_Sleep
$LN3@Sys_Sleep:
	mov	DWORD PTR tv66[ebp], 1000		; 000003e8H
$LN4@Sys_Sleep:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Sys_Sleep
$LN5@Sys_Sleep:
	mov	DWORD PTR tv67[ebp], 0
$LN6@Sys_Sleep:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _msec$[ebp], edx

; 118  : 	Sleep( msec );

	mov	eax, DWORD PTR _msec$[ebp]
	push	eax
	call	DWORD PTR __imp__Sleep@4

; 119  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sys_Sleep ENDP
_TEXT	ENDS
END
