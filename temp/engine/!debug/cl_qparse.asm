; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_qparse.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetNumBitsLeft
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParseQuakeMessage
PUBLIC	_CL_ParseQuakeEntityData
PUBLIC	_CL_ParseQuakeParticle
PUBLIC	_CL_ParseQuakeStaticSound
PUBLIC	_CL_QuakeStuffText
PUBLIC	_CL_QuakeExecStuff
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	??_C@_05BMAFBINF@Stats@				; `string'
PUBLIC	??_C@_08JJGOBBMF@GameMode@			; `string'
PUBLIC	?__LINE__Var@?0??CL_ParseQuakeServerInfo@@9@9	; `CL_ParseQuakeServerInfo'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@ ; `string'
PUBLIC	??_C@_0DL@FCAPPBJA@?6?$FO1Error?3?$FO7?5Server?5use?5invalid?5@ ; `string'
PUBLIC	??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@ ; `string'
PUBLIC	??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@		; `string'
PUBLIC	??_C@_08EOJKMECK@user?4scr@			; `string'
PUBLIC	??_C@_08HELCJCPN@r_decals@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0DG@EHGMHDBG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_04CELKIKPL@16x9@				; `string'
PUBLIC	??_C@_03PHLBDMN@4x3@				; `string'
PUBLIC	??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@	; `string'
PUBLIC	??_C@_0BC@CBJAHLIN@cl_levelshot_name@		; `string'
PUBLIC	??_C@_0M@DKOEGGOG@scr_loading@			; `string'
PUBLIC	??_C@_06PCEOMGLN@?$CFs?4bmp@			; `string'
PUBLIC	??_C@_06FPKCCFDN@?$CKblack@			; `string'
PUBLIC	??_C@_05CCNNDGIA@Items@				; `string'
PUBLIC	??_C@_06KGFFMMMJ@Damage@			; `string'
PUBLIC	??_C@_0EC@MJJJFFHI@?$FO1Error?3?$FO7?5CL_ParseStaticEntity@ ; `string'
PUBLIC	??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@ ; `string'
PUBLIC	??_C@_0L@KJBJBAKD@TempEntity@			; `string'
PUBLIC	??_C@_0P@OFEFFGOA@CL_Signon?3?5?$CFd?6@		; `string'
PUBLIC	??_C@_0CA@OHJCAFNC@?$FO3Warning?3?$FO7?5?8?$CFs?8?5is?5not?5exist?6@ ; `string'
PUBLIC	??_C@_08KNNNHPIP@playdemo@			; `string'
PUBLIC	??_C@_07JEMFJBEN@UserMsg@			; `string'
PUBLIC	??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@ ; `string'
PUBLIC	??_C@_0CF@DJJOJFKE@Server?5is?5protocol?5?$CFi?5instead?5o@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_06BALNJMNP@player@			; `string'
PUBLIC	??_C@_07JNEKKACO@HudText@			; `string'
PUBLIC	??_C@_0M@GLGMCOOM@KillMonster@			; `string'
PUBLIC	??_C@_0M@BINHEOKF@FoundSecret@			; `string'
PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_0DB@FPIIIAAE@CL_ParseServerMessage?3?5Illegibl@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3d800000
PUBLIC	__real@3f800000
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb40000
PUBLIC	__real@41800000
PUBLIC	__real@41b00000
PUBLIC	__real@42800000
PUBLIC	__real@437f0000
PUBLIC	__real@44480000
PUBLIC	__real@44fa0000
PUBLIC	__real@465d7000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_DoubleTime:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Exists:PROC
EXTRN	_Cmd_ExecuteString:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_Exists:PROC
EXTRN	_Cvar_Reset:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Host_AbortCurrentFrame:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CSCR_LoadDefaultCVars:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_StopPlayback:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_Print:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_StopSound:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_sqrt:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_Clear:PROC
EXTRN	_MSG_WriteByte:PROC
EXTRN	_MSG_WriteWord:PROC
EXTRN	_MSG_WriteLong:PROC
EXTRN	_MSG_WriteCoord:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	_MSG_ReadCmd:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadLong:PROC
EXTRN	_MSG_ReadCoord:PROC
EXTRN	_MSG_ReadFloat:PROC
EXTRN	_MSG_ReadVec3Coord:PROC
EXTRN	_MSG_ReadStringExt:PROC
EXTRN	_CL_SetLightstyle:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_Parse_Debug:PROC
EXTRN	_CL_Parse_RecordCommand:PROC
EXTRN	_CL_ResetFrame:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_ClearState:PROC
EXTRN	_CL_DemoCompleted:PROC
EXTRN	_CL_BatchResourceRequest:PROC
EXTRN	_CL_ParseFinaleCutscene:PROC
EXTRN	_CL_InitEdicts:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_DispatchUserMessage:PROC
EXTRN	_CL_ParseViewEntity:PROC
EXTRN	_CL_ParseServerTime:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_ResetLatchedVars:PROC
EXTRN	_CL_ProcessPacket:PROC
EXTRN	_CL_IsPlayerIndex:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_Con_FixedFont:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_R_AddEfrags:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_IN_MouseRestorePos:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_mp_decals:BYTE
EXTRN	_cl_levelshot_name:DWORD
EXTRN	_glState:BYTE
EXTRN	_r_decals:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_cmd_buf DB	02000H DUP (?)
_msg_buf DB	02020H DUP (?)
_msg_demo DB	014H DUP (?)
_BSS	ENDS
;	COMDAT __real@465d7000
CONST	SEGMENT
__real@465d7000 DD 0465d7000r			; 14172
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@41b00000
CONST	SEGMENT
__real@41b00000 DD 041b00000r			; 22
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DB@FPIIIAAE@CL_ParseServerMessage?3?5Illegibl@
CONST	SEGMENT
??_C@_0DB@FPIIIAAE@CL_ParseServerMessage?3?5Illegibl@ DB 'CL_ParseServerM'
	DB	'essage: Illegible server message', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BINHEOKF@FoundSecret@
CONST	SEGMENT
??_C@_0M@BINHEOKF@FoundSecret@ DB 'FoundSecret', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GLGMCOOM@KillMonster@
CONST	SEGMENT
??_C@_0M@GLGMCOOM@KillMonster@ DB 'KillMonster', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNEKKACO@HudText@
CONST	SEGMENT
??_C@_07JNEKKACO@HudText@ DB 'HudText', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BALNJMNP@player@
CONST	SEGMENT
??_C@_06BALNJMNP@player@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DJJOJFKE@Server?5is?5protocol?5?$CFi?5instead?5o@
CONST	SEGMENT
??_C@_0CF@DJJOJFKE@Server?5is?5protocol?5?$CFi?5instead?5o@ DB 'Server is'
	DB	' protocol %i instead of %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@
CONST	SEGMENT
??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@ DB 'CL_ParseServerM'
	DB	'essage: overflow!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JEMFJBEN@UserMsg@
CONST	SEGMENT
??_C@_07JEMFJBEN@UserMsg@ DB 'UserMsg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNNNHPIP@playdemo@
CONST	SEGMENT
??_C@_08KNNNHPIP@playdemo@ DB 'playdemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OHJCAFNC@?$FO3Warning?3?$FO7?5?8?$CFs?8?5is?5not?5exist?6@
CONST	SEGMENT
??_C@_0CA@OHJCAFNC@?$FO3Warning?3?$FO7?5?8?$CFs?8?5is?5not?5exist?6@ DB '^'
	DB	'3Warning:^7 ''%s'' is not exist', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFEFFGOA@CL_Signon?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0P@OFEFFGOA@CL_Signon?3?5?$CFd?6@ DB 'CL_Signon: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KJBJBAKD@TempEntity@
CONST	SEGMENT
??_C@_0L@KJBJBAKD@TempEntity@ DB 'TempEntity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@
CONST	SEGMENT
??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@ DB 'CL_AllocEdict'
	DB	': no free edicts', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MJJJFFHI@?$FO1Error?3?$FO7?5CL_ParseStaticEntity@
CONST	SEGMENT
??_C@_0EC@MJJJFFHI@?$FO1Error?3?$FO7?5CL_ParseStaticEntity@ DB '^1Error:^'
	DB	'7 CL_ParseStaticEntity: static entities limit exceeded!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06KGFFMMMJ@Damage@
CONST	SEGMENT
??_C@_06KGFFMMMJ@Damage@ DB 'Damage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCNNDGIA@Items@
CONST	SEGMENT
??_C@_05CCNNDGIA@Items@ DB 'Items', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPKCCFDN@?$CKblack@
CONST	SEGMENT
??_C@_06FPKCCFDN@?$CKblack@ DB '*black', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCEOMGLN@?$CFs?4bmp@
CONST	SEGMENT
??_C@_06PCEOMGLN@?$CFs?4bmp@ DB '%s.bmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKOEGGOG@scr_loading@
CONST	SEGMENT
??_C@_0M@DKOEGGOG@scr_loading@ DB 'scr_loading', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
CONST	SEGMENT
??_C@_0BC@CBJAHLIN@cl_levelshot_name@ DB 'cl_levelshot_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
CONST	SEGMENT
??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@ DB 'levelshots/%s_%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHLBDMN@4x3@
CONST	SEGMENT
??_C@_03PHLBDMN@4x3@ DB '4x3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CELKIKPL@16x9@
CONST	SEGMENT
??_C@_04CELKIKPL@16x9@ DB '16x9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EHGMHDBG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@EHGMHDBG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_qparse.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08HELCJCPN@r_decals@
CONST	SEGMENT
??_C@_08HELCJCPN@r_decals@ DB 'r_decals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOJKMECK@user?4scr@
CONST	SEGMENT
??_C@_08EOJKMECK@user?4scr@ DB 'user.scr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@
CONST	SEGMENT
??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@ DB '%c%s', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@
CONST	SEGMENT
??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@ DB 0aH
	DB	01dH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH, 01eH
	DB	01eH, 01eH, 01eH, 01fH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FCAPPBJA@?6?$FO1Error?3?$FO7?5Server?5use?5invalid?5@
CONST	SEGMENT
??_C@_0DL@FCAPPBJA@?6?$FO1Error?3?$FO7?5Server?5use?5invalid?5@ DB 0aH, '^'
	DB	'1Error:^7 Server use invalid protocol (%i should be %i)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@
CONST	SEGMENT
??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@ DB 'Serverdata packe'
	DB	't received.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ParseQuakeServerInfo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ParseQuakeServerInfo@@9@9 DD 0b7H	; `CL_ParseQuakeServerInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08JJGOBBMF@GameMode@
CONST	SEGMENT
??_C@_08JJGOBBMF@GameMode@ DB 'GameMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMAFBINF@Stats@
CONST	SEGMENT
??_C@_05BMAFBINF@Stats@ DB 'Stats', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0209H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	039eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0a5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0ddH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0115H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	015eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	08efH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_QuakeExecStuff
_TEXT	SEGMENT
$T1 = -336						; size = 4
_argc$ = -268						; size = 4
_token$ = -264						; size = 256
_text$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_QuakeExecStuff PROC					; COMDAT

; 839  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 840  : 	char	*text = cmd_buf;

	mov	DWORD PTR _text$[ebp], OFFSET _cmd_buf

; 841  : 	char	token[256];
; 842  : 	int	argc = 0;

	mov	DWORD PTR _argc$[ebp], 0

; 843  : 
; 844  : 	// check if no commands this frame
; 845  : 	if( !COM_CheckString( text ))

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CL_QuakeEx

; 846  : 		return;

	jmp	$LN15@CL_QuakeEx
$LN2@CL_QuakeEx:

; 847  : 
; 848  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@CL_QuakeEx
$LN4@CL_QuakeEx:

; 849  : 	{
; 850  : 		// skip whitespace up to a /n
; 851  : 		while( *text && ((byte)*text) <= ' ' && *text != '\r' && *text != '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@CL_QuakeEx
	mov	eax, DWORD PTR _text$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN5@CL_QuakeEx
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN5@CL_QuakeEx
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN5@CL_QuakeEx

; 852  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	jmp	SHORT $LN4@CL_QuakeEx
$LN5@CL_QuakeEx:

; 853  : 
; 854  : 		if( *text == '\n' || *text == '\r' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN8@CL_QuakeEx
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN7@CL_QuakeEx
$LN8@CL_QuakeEx:

; 855  : 		{
; 856  : 			// a newline seperates commands in the buffer
; 857  : 			if( *text == '\r' && text[1] == '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@CL_QuakeEx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN9@CL_QuakeEx

; 858  : 				text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN9@CL_QuakeEx:

; 859  : 			argc = 0;

	mov	DWORD PTR _argc$[ebp], 0

; 860  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN7@CL_QuakeEx:

; 861  : 		}
; 862  : 
; 863  : 		if( !*text ) break;

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@CL_QuakeEx
	jmp	$LN3@CL_QuakeEx
$LN10@CL_QuakeEx:

; 864  : 
; 865  : 		host.com_ignorebracket = true;

	mov	DWORD PTR _host+34364, 1

; 866  : 		text = COM_ParseFile( text, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _text$[ebp], eax

; 867  : 		host.com_ignorebracket = false;

	mov	DWORD PTR _host+34364, 0

; 868  : 
; 869  : 		if( !text ) break;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN11@CL_QuakeEx
	jmp	SHORT $LN3@CL_QuakeEx
$LN11@CL_QuakeEx:

; 870  : 
; 871  : 		if( argc == 0 )

	cmp	DWORD PTR _argc$[ebp], 0
	jne	SHORT $LN12@CL_QuakeEx

; 872  : 		{
; 873  : 			// debug: find all missed commands and cvars to add them into QWrap
; 874  : 			if( !Cvar_Exists( token ) && !Cmd_Exists( token ))

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Cvar_Exists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@CL_QuakeEx
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@CL_QuakeEx

; 875  : 				Con_Printf( S_WARN "'%s' is not exist\n", token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@OHJCAFNC@?$FO3Warning?3?$FO7?5?8?$CFs?8?5is?5not?5exist?6@
	call	_Con_Printf
	add	esp, 8
$LN13@CL_QuakeEx:

; 876  : //			else Msg( "cmd: %s\n", token );
; 877  : 
; 878  : 			// process some special commands
; 879  : 			if( !Q_stricmp( token, "playdemo" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08KNNNHPIP@playdemo@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@CL_QuakeEx

; 880  : 				cls.changedemo = true;

	mov	DWORD PTR _cls+12, 1
$LN14@CL_QuakeEx:

; 881  : 			argc++;

	mov	eax, DWORD PTR _argc$[ebp]
	add	eax, 1
	mov	DWORD PTR _argc$[ebp], eax
$LN12@CL_QuakeEx:

; 882  : 		}
; 883  : 	}

	jmp	$LN2@CL_QuakeEx
$LN3@CL_QuakeEx:

; 884  : 
; 885  : 	// reset the buffer
; 886  : 	cmd_buf[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 8192		; 00002000H
	jae	SHORT $LN16@CL_QuakeEx
	jmp	SHORT $LN17@CL_QuakeEx
$LN16@CL_QuakeEx:
	call	___report_rangecheckfailure
$LN17@CL_QuakeEx:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd_buf[edx], 0
$LN15@CL_QuakeEx:

; 887  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QuakeExecStuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_QuakeStuffText
_TEXT	SEGMENT
_text$ = 8						; size = 4
_CL_QuakeStuffText PROC					; COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 828  : 	Q_strncat( cmd_buf, text, sizeof( cmd_buf ));

	push	8192					; 00002000H
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET _cmd_buf
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 829  : 	Cbuf_AddText( text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 830  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QuakeStuffText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseNehahraHideLMP
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseNehahraHideLMP PROC				; COMDAT

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 816  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 817  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET ??_C@_05BMAFBINF@Stats@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseNehahraHideLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseNehahraShowLMP
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseNehahraShowLMP PROC				; COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 800  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 801  : 	MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8

; 802  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 803  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 804  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET ??_C@_05BMAFBINF@Stats@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 805  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseNehahraShowLMP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeSignon
_TEXT	SEGMENT
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeSignon PROC				; COMDAT

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 785  : 	int	i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 786  : 
; 787  : 	if( i == 3 ) cls.signon = SIGNONS - 1;

	cmp	DWORD PTR _i$[ebp], 3
	jne	SHORT $LN2@CL_ParseQu
	mov	DWORD PTR _cls+64, 1
$LN2@CL_ParseQu:

; 788  : 	Con_Reportf( "CL_Signon: %d\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@OFEFFGOA@CL_Signon?3?5?$CFd?6@
	call	_Con_Reportf
	add	esp, 8

; 789  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeSignon ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeTempEntity
_TEXT	SEGMENT
_type$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeTempEntity PROC				; COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 737  : 	int	type = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 738  : 
; 739  : 	MSG_WriteByte( &msg_demo, type );

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 740  : 
; 741  : 	if( type == 17 )

	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN2@CL_ParseQu

; 742  : 		MSG_WriteString( &msg_demo, MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteString
	add	esp, 8
$LN2@CL_ParseQu:

; 743  : 
; 744  : 	// TE_LIGHTNING1, TE_LIGHTNING2, TE_LIGHTNING3, TE_BEAM, TE_LIGHTNING4
; 745  : 	if( type == 5 || type == 6 || type == 9 || type == 13 || type == 17 )

	cmp	DWORD PTR _type$[ebp], 5
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 6
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 9
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 13		; 0000000dH
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN3@CL_ParseQu
$LN4@CL_ParseQu:

; 746  : 		MSG_WriteWord( &msg_demo, MSG_ReadWord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteWord
	add	esp, 8
$LN3@CL_ParseQu:

; 747  : 
; 748  : 	// all temp ents have position at beginning
; 749  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 750  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 751  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 752  : 
; 753  : 	// TE_LIGHTNING1, TE_LIGHTNING2, TE_LIGHTNING3, TE_BEAM, TE_EXPLOSION3, TE_LIGHTNING4
; 754  : 	if( type == 5 || type == 6 || type == 9 || type == 13 || type == 16 || type == 17 )

	cmp	DWORD PTR _type$[ebp], 5
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 6
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 9
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 13		; 0000000dH
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 16		; 00000010H
	je	SHORT $LN6@CL_ParseQu
	cmp	DWORD PTR _type$[ebp], 17		; 00000011H
	jne	SHORT $LN5@CL_ParseQu
$LN6@CL_ParseQu:

; 755  : 	{
; 756  : 		// write endpos for beams
; 757  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 758  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 759  : 		MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8
$LN5@CL_ParseQu:

; 760  : 	}
; 761  : 
; 762  : 	// TE_EXPLOSION2
; 763  : 	if( type == 12 )

	cmp	DWORD PTR _type$[ebp], 12		; 0000000cH
	jne	SHORT $LN7@CL_ParseQu

; 764  : 	{
; 765  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 766  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8
$LN7@CL_ParseQu:

; 767  : 	}
; 768  : 
; 769  : 	// TE_SMOKE (nehahra)
; 770  : 	if( type == 18 )

	cmp	DWORD PTR _type$[ebp], 18		; 00000012H
	jne	SHORT $LN8@CL_ParseQu

; 771  : 		MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8
$LN8@CL_ParseQu:

; 772  : 
; 773  : 	CL_DispatchQuakeMessage( "TempEntity" );

	push	OFFSET ??_C@_0L@KJBJBAKD@TempEntity@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 774  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeTempEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeBaseline
_TEXT	SEGMENT
_newnum$ = -464						; size = 4
_ent$ = -460						; size = 4
_state$ = -456						; size = 452
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeBaseline PROC				; COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 698  : 	entity_state_t	state;
; 699  : 	cl_entity_t	*ent;
; 700  : 	int		newnum;
; 701  : 
; 702  : 	memset( &state, 0, sizeof( state ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 703  : 	newnum = MSG_ReadWord( msg ); // entnum

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax

; 704  : 
; 705  : 	if( newnum >= clgame.maxEntities )

	mov	eax, DWORD PTR _newnum$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jl	SHORT $LN2@CL_ParseQu

; 706  : 		Host_Error( "CL_AllocEdict: no free edicts\n" );

	push	OFFSET ??_C@_0BP@BCIECMFG@CL_AllocEdict?3?5no?5free?5edicts?6@
	call	_Host_Error
	add	esp, 4
$LN2@CL_ParseQu:

; 707  : 
; 708  : 	ent = CL_EDICT_NUM( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 709  : 	memset( &ent->prevstate, 0, sizeof( ent->prevstate ));

	push	452					; 000001c4H
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 710  : 	ent->index = newnum;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 711  : 
; 712  : 	// parse baseline
; 713  : 	state.modelindex = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+40], eax

; 714  : 	state.frame = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _state$[ebp+48], xmm0

; 715  : 	state.colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+52], eax

; 716  : 	state.skin = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+136], eax

; 717  : 	state.origin[0] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _state$[ebp+edx+16]

; 718  : 	state.angles[0] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _state$[ebp+edx+28], xmm0

; 719  : 	state.origin[1] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 720  : 	state.angles[1] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 721  : 	state.origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 722  : 	state.angles[2] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 723  : 	ent->player = CL_IsPlayerIndex( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 724  : 
; 725  : 	memcpy( &ent->baseline, &state, sizeof( entity_state_t ));

	push	452					; 000001c4H
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 8
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 726  : 	memcpy( &ent->prevstate, &state, sizeof( entity_state_t ));

	push	452					; 000001c4H
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 460				; 000001ccH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 727  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeBaseline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeStaticEntity
_TEXT	SEGMENT
_i$ = -464						; size = 4
_ent$ = -460						; size = 4
_state$ = -456						; size = 452
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeStaticEntity PROC				; COMDAT

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 634  : 	entity_state_t	state;
; 635  : 	cl_entity_t	*ent;
; 636  : 	int		i;
; 637  : 
; 638  : 	memset( &state, 0, sizeof( state ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 639  : 
; 640  : 	state.modelindex = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+40], eax

; 641  : 	state.frame = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _state$[ebp+48], xmm0

; 642  : 	state.colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+52], eax

; 643  : 	state.skin = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _state$[ebp+136], eax

; 644  : 	state.origin[0] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _state$[ebp+edx+16]

; 645  : 	state.angles[0] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _state$[ebp+edx+28], xmm0

; 646  : 	state.origin[1] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 647  : 	state.angles[1] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 648  : 	state.origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _state$[ebp+ecx+16]

; 649  : 	state.angles[2] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _state$[ebp+ecx+28], xmm0

; 650  : 
; 651  : 	i = clgame.numStatics;

	mov	eax, DWORD PTR _clgame+1016
	mov	DWORD PTR _i$[ebp], eax

; 652  : 	if( i >= MAX_STATIC_ENTITIES )

	cmp	DWORD PTR _i$[ebp], 3096		; 00000c18H
	jl	SHORT $LN2@CL_ParseQu

; 653  : 	{
; 654  : 		Con_Printf( S_ERROR "CL_ParseStaticEntity: static entities limit exceeded!\n" );

	push	OFFSET ??_C@_0EC@MJJJFFHI@?$FO1Error?3?$FO7?5CL_ParseStaticEntity@
	call	_Con_Printf
	add	esp, 4

; 655  : 		return;

	jmp	$LN1@CL_ParseQu
$LN2@CL_ParseQu:

; 656  : 	}
; 657  : 
; 658  : 	ent = &clgame.static_entities[i];

	imul	eax, DWORD PTR _i$[ebp], 3336
	add	eax, DWORD PTR _clgame+1000
	mov	DWORD PTR _ent$[ebp], eax

; 659  : 	clgame.numStatics++;

	mov	eax, DWORD PTR _clgame+1016
	add	eax, 1
	mov	DWORD PTR _clgame+1016, eax

; 660  : 
; 661  : 	ent->index = 0; // ???

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax], 0

; 662  : 	ent->baseline = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 8
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 663  : 	ent->curstate = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 912				; 00000390H
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 664  : 	ent->prevstate = state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 460				; 000001ccH
	mov	ecx, 113				; 00000071H
	lea	esi, DWORD PTR _state$[ebp]
	rep movsd

; 665  : 
; 666  : 	// statics may be respawned in game e.g. for demo recording
; 667  : 	if( cls.state == ca_connected || cls.state == ca_validate )

	cmp	DWORD PTR _cls, 2
	je	SHORT $LN4@CL_ParseQu
	cmp	DWORD PTR _cls, 3
	jne	SHORT $LN3@CL_ParseQu
$LN4@CL_ParseQu:

; 668  : 		ent->trivial_accept = INVALID_HANDLE;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+3296], 65535		; 0000ffffH
$LN3@CL_ParseQu:

; 669  : 
; 670  : 	// setup the new static entity
; 671  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 672  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 673  : 	ent->model = CL_ModelHandle( state.modelindex );

	mov	eax, DWORD PTR _state$[ebp+40]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+3300], eax

; 674  : 	ent->curstate.framerate = 1.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1008], xmm0

; 675  : 	CL_ResetLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8

; 676  : 
; 677  : 	if( ent->model != NULL )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN6@CL_ParseQu

; 678  : 	{
; 679  : 		// auto 'solid' faces
; 680  : 		if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN6@CL_ParseQu
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN6@CL_ParseQu

; 681  : 		{
; 682  : 			ent->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+984], 4

; 683  : 			ent->curstate.renderamt = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN6@CL_ParseQu:

; 684  : 		}
; 685  : 	}
; 686  : 
; 687  : 	R_AddEfrags( ent );	// add link

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_AddEfrags
	add	esp, 4
$LN1@CL_ParseQu:

; 688  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeStaticEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeDamage
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseQuakeDamage PROC				; COMDAT

; 617  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 618  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// armor

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 619  : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// blood

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 620  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 621  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 622  : 	MSG_WriteCoord( &msg_demo, MSG_ReadCoord( msg ));	// direction

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	DWORD PTR [esp]
	push	OFFSET _msg_demo
	call	_MSG_WriteCoord
	add	esp, 8

; 623  : 	CL_DispatchQuakeMessage( "Damage" );

	push	OFFSET ??_C@_06KGFFMMMJ@Damage@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeDamage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeStaticSound
_TEXT	SEGMENT
_org$ = -28						; size = 12
_attn$ = -16						; size = 4
_vol$ = -12						; size = 4
_sound_num$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeStaticSound PROC				; COMDAT

; 596  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 597  : 	int	sound_num;
; 598  : 	float 	vol, attn;
; 599  : 	vec3_t	org;
; 600  : 
; 601  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 602  : 	sound_num = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _sound_num$[ebp], eax

; 603  : 	vol = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _vol$[ebp], xmm0

; 604  : 	attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0

; 605  : 
; 606  : 	S_StartSound( org, 0, CHAN_STATIC, cl.sound_index[sound_num], vol, attn, PITCH_NORM, 0 );	

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _sound_num$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	push	ecx
	push	7
	push	0
	lea	edx, DWORD PTR _org$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 607  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeStaticSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeParticle
_TEXT	SEGMENT
_dir$ = -36						; size = 12
_org$ = -24						; size = 12
_color$ = -12						; size = 4
_count$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeParticle PROC				; COMDAT

; 574  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 575  : 	int	count, color;
; 576  : 	vec3_t	org, dir;
; 577  : 	
; 578  : 	MSG_ReadVec3Coord( msg, org );	

	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 579  : 	dir[0] = MSG_ReadChar( msg ) * 0.0625f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 580  : 	dir[1] = MSG_ReadChar( msg ) * 0.0625f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 581  : 	dir[2] = MSG_ReadChar( msg ) * 0.0625f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 582  : 	count = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 583  : 	color = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 584  : 	if( count == 255 ) count = 1024;

	cmp	DWORD PTR _count$[ebp], 255		; 000000ffH
	jne	SHORT $LN2@CL_ParseQu
	mov	DWORD PTR _count$[ebp], 1024		; 00000400H
$LN2@CL_ParseQu:

; 585  : 
; 586  : 	R_RunParticleEffect( org, dir, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dir$[ebp]
	push	edx
	lea	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeParticle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeEntityData
_TEXT	SEGMENT
tv354 = -108						; size = 4
tv518 = -104						; size = 4
tv351 = -104						; size = 4
_alpha$1 = -36						; size = 4
_temp$2 = -32						; size = 4
_ent$ = -28						; size = 4
_frame$ = -24						; size = 4
_state$ = -20						; size = 4
_forcelink$ = -16					; size = 4
_pack$ = -12						; size = 4
_newnum$ = -8						; size = 4
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_bits$ = 12						; size = 4
_CL_ParseQuakeEntityData PROC				; COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 424  : 	int		i, newnum, pack;
; 425  : 	qboolean		forcelink;
; 426  : 	entity_state_t	*state;
; 427  : 	frame_t		*frame;
; 428  : 	cl_entity_t	*ent;
; 429  : 
; 430  : 	// first update is the final signon stage where we actually receive an entity (i.e., the world at least)
; 431  : 	if( cls.signon == ( SIGNONS - 1 ))

	cmp	DWORD PTR _cls+64, 1
	jne	SHORT $LN2@CL_ParseQu

; 432  : 	{
; 433  : 		// we are done with signon sequence.
; 434  : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 435  : 
; 436  : 		// Clear loading plaque.
; 437  : 		CL_SignonReply ();

	call	_CL_SignonReply
$LN2@CL_ParseQu:

; 438  : 	}
; 439  : 
; 440  : 	// alloc next slot to store update
; 441  : 	state = &cls.packet_entities[cls.next_client_entities % cls.num_client_entities];

	mov	eax, DWORD PTR _cls+295008
	cdq
	idiv	DWORD PTR _cls+295004
	imul	eax, edx, 452
	add	eax, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], eax

; 442  : 	cl.validsequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _cl+4, eax

; 443  : 	frame = &cl.frames[cl.parsecountmod];

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], eax

; 444  : 	pack = frame->num_entities;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24044]
	mov	DWORD PTR _pack$[ebp], ecx

; 445  : 
; 446  : 	if( FBitSet( bits, U_MOREBITS ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1
	je	SHORT $LN3@CL_ParseQu

; 447  : 	{
; 448  : 		i = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 449  : 		SetBits( bits, i << 8 );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 8
	or	eax, DWORD PTR _bits$[ebp]
	mov	DWORD PTR _bits$[ebp], eax
$LN3@CL_ParseQu:

; 450  : 	}
; 451  : 
; 452  : 	if( FBitSet( bits, U_LONGENTITY ))	

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 16384				; 00004000H
	je	SHORT $LN4@CL_ParseQu

; 453  : 		newnum = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax
	jmp	SHORT $LN5@CL_ParseQu
$LN4@CL_ParseQu:

; 454  : 	else newnum = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _newnum$[ebp], eax
$LN5@CL_ParseQu:

; 455  : 
; 456  : 	memset( state, 0, sizeof( *state ));

	push	452					; 000001c4H
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 457  : 	SetBits( state->entityType, ENTITY_NORMAL );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], ecx

; 458  : 	state->number = newnum;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 459  : 
; 460  : 	// mark all the players
; 461  : 	ent = CL_EDICT_NUM( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 462  : 	ent->index = newnum; // enumerate entity index

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 463  : 	ent->player = CL_IsPlayerIndex( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 464  : 	state->animtime = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	mov	edx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [edx+92], xmm0

; 465  : 
; 466  : 	if( ent->curstate.msg_time != cl.mtime[1] )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+920]
	mov	ecx, 8
	shl	ecx, 0
	ucomisd	xmm0, QWORD PTR _cl[ecx+32]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_ParseQu

; 467  : 		forcelink = true;	// no previous frame to lerp from

	mov	DWORD PTR _forcelink$[ebp], 1
	jmp	SHORT $LN7@CL_ParseQu
$LN6@CL_ParseQu:

; 468  : 	else forcelink = false;

	mov	DWORD PTR _forcelink$[ebp], 0
$LN7@CL_ParseQu:

; 469  : 	
; 470  : 	if( FBitSet( bits, U_MODEL ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN8@CL_ParseQu

; 471  : 		state->modelindex = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN9@CL_ParseQu
$LN8@CL_ParseQu:

; 472  : 	else state->modelindex = ent->baseline.modelindex;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+40], edx
$LN9@CL_ParseQu:

; 473  : 
; 474  : 	if( FBitSet( bits, U_FRAME ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN10@CL_ParseQu

; 475  : 		state->frame = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [ecx+48], xmm0
	jmp	SHORT $LN11@CL_ParseQu
$LN10@CL_ParseQu:

; 476  : 	else state->frame = ent->baseline.frame;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+48], edx
$LN11@CL_ParseQu:

; 477  : 
; 478  : 	if( FBitSet( bits, U_COLORMAP ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN12@CL_ParseQu

; 479  : 		state->colormap = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+52], eax
	jmp	SHORT $LN13@CL_ParseQu
$LN12@CL_ParseQu:

; 480  : 	else state->colormap = ent->baseline.colormap;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+52], edx
$LN13@CL_ParseQu:

; 481  : 
; 482  : 	if( FBitSet( bits, U_SKIN ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN14@CL_ParseQu

; 483  : 		state->skin = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+136], eax
	jmp	SHORT $LN15@CL_ParseQu
$LN14@CL_ParseQu:

; 484  : 	else state->skin = ent->baseline.skin;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR [eax+136], edx
$LN15@CL_ParseQu:

; 485  : 
; 486  : 	if( FBitSet( bits, U_EFFECTS ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 8192				; 00002000H
	je	SHORT $LN16@CL_ParseQu

; 487  : 		state->effects = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+60], eax
	jmp	SHORT $LN17@CL_ParseQu
$LN16@CL_ParseQu:

; 488  : 	else state->effects = ent->baseline.effects;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+60], edx
$LN17@CL_ParseQu:

; 489  : 
; 490  : 	if( FBitSet( bits, U_ORIGIN1 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 2
	je	SHORT $LN18@CL_ParseQu

; 491  : 		state->origin[0] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [eax+edx+16]
	jmp	SHORT $LN19@CL_ParseQu
$LN18@CL_ParseQu:

; 492  : 	else state->origin[0] = ent->baseline.origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+24]
	mov	DWORD PTR [edx+eax+16], ecx
$LN19@CL_ParseQu:

; 493  : 
; 494  : 	if( FBitSet( bits, U_ANGLE1 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN20@CL_ParseQu

; 495  : 		state->angles[0] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _state$[ebp]
	movss	DWORD PTR [eax+edx+28], xmm0
	jmp	SHORT $LN21@CL_ParseQu
$LN20@CL_ParseQu:

; 496  : 	else state->angles[0] = ent->baseline.angles[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [edx+eax+28], ecx
$LN21@CL_ParseQu:

; 497  : 
; 498  : 	if( FBitSet( bits, U_ORIGIN2 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 4
	je	SHORT $LN22@CL_ParseQu

; 499  : 		state->origin[1] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [edx+ecx+16]
	jmp	SHORT $LN23@CL_ParseQu
$LN22@CL_ParseQu:

; 500  : 	else state->origin[1] = ent->baseline.origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+24]
	mov	DWORD PTR [edx+ecx+16], eax
$LN23@CL_ParseQu:

; 501  : 
; 502  : 	if( FBitSet( bits, U_ANGLE2 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN24@CL_ParseQu

; 503  : 		state->angles[1] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [edx+ecx+28], xmm0
	jmp	SHORT $LN25@CL_ParseQu
$LN24@CL_ParseQu:

; 504  : 	else state->angles[1] = ent->baseline.angles[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [edx+ecx+28], eax
$LN25@CL_ParseQu:

; 505  : 
; 506  : 	if( FBitSet( bits, U_ORIGIN3 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 8
	je	SHORT $LN26@CL_ParseQu

; 507  : 		state->origin[2] = MSG_ReadCoord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	fstp	DWORD PTR [edx+ecx+16]
	jmp	SHORT $LN27@CL_ParseQu
$LN26@CL_ParseQu:

; 508  : 	else state->origin[2] = ent->baseline.origin[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+24]
	mov	DWORD PTR [edx+ecx+16], eax
$LN27@CL_ParseQu:

; 509  : 
; 510  : 	if( FBitSet( bits, U_ANGLE3 ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN28@CL_ParseQu

; 511  : 		state->angles[2] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [edx+ecx+28], xmm0
	jmp	SHORT $LN29@CL_ParseQu
$LN28@CL_ParseQu:

; 512  : 	else state->angles[2] = ent->baseline.angles[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+36]
	mov	DWORD PTR [edx+ecx+28], eax
$LN29@CL_ParseQu:

; 513  : 
; 514  : 	if( FBitSet( bits, U_TRANS ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 32768				; 00008000H
	je	$LN33@CL_ParseQu

; 515  : 	{
; 516  : 		int	temp = MSG_ReadFloat( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	call	__ftol2_sse
	mov	DWORD PTR _temp$2[ebp], eax

; 517  : 		float	alpha = MSG_ReadFloat( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR _alpha$1[ebp]

; 518  : 
; 519  : 		if( alpha == 0.0f ) alpha = 1.0f;

	movss	xmm0, DWORD PTR _alpha$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@CL_ParseQu
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _alpha$1[ebp], xmm0
$LN31@CL_ParseQu:

; 520  : 
; 521  : 		if( alpha < 1.0f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _alpha$1[ebp]
	jbe	SHORT $LN32@CL_ParseQu

; 522  : 		{
; 523  : 			state->rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+72], 2

; 524  : 			state->renderamt = (int)(alpha * 255.0f);

	movss	xmm0, DWORD PTR _alpha$1[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+76], eax
$LN32@CL_ParseQu:

; 525  : 		}
; 526  : 
; 527  : 		if( temp == 2 && MSG_ReadFloat( msg ))

	cmp	DWORD PTR _temp$2[ebp], 2
	jne	SHORT $LN33@CL_ParseQu
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	fstp	DWORD PTR tv518[ebp]
	movss	xmm0, DWORD PTR tv518[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN33@CL_ParseQu

; 528  : 			SetBits( state->effects, EF_FULLBRIGHT );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	or	ecx, 134217728				; 08000000H
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+60], ecx
$LN33@CL_ParseQu:

; 529  : 	}
; 530  : 
; 531  : 	if( FBitSet( bits, U_NOLERP ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN34@CL_ParseQu

; 532  : 		state->movetype = MOVETYPE_STEP;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+88], 4
	jmp	SHORT $LN35@CL_ParseQu
$LN34@CL_ParseQu:

; 533  : 	else state->movetype = MOVETYPE_NOCLIP;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+88], 8
$LN35@CL_ParseQu:

; 534  : 
; 535  : 	if( CL_QuakeEntityTeleported( ent, state ))

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_QuakeEntityTeleported
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@CL_ParseQu

; 536  : 	{
; 537  : 		// remove smooth stepping
; 538  : 		if( cl.viewentity == ent->index )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cl+2212780
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN37@CL_ParseQu

; 539  : 			cl.skip_interp = true;

	mov	DWORD PTR _cl+76, 1
$LN37@CL_ParseQu:

; 540  : 		forcelink = true;

	mov	DWORD PTR _forcelink$[ebp], 1
$LN36@CL_ParseQu:

; 541  : 	}
; 542  : 
; 543  : 	if( FBitSet( state->effects, 16 ))

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 16					; 00000010H
	je	SHORT $LN38@CL_ParseQu

; 544  : 		SetBits( state->effects, EF_NODRAW );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+60], ecx
$LN38@CL_ParseQu:

; 545  : 
; 546  : 	if(( newnum - 1 ) == cl.playernum )

	mov	eax, DWORD PTR _newnum$[ebp]
	sub	eax, 1
	cmp	eax, DWORD PTR _cl+2213000
	jne	SHORT $LN39@CL_ParseQu

; 547  : 		VectorCopy( state->origin, frame->clientdata.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+32], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+32], eax
$LN39@CL_ParseQu:

; 548  : 
; 549  : 	if( forcelink )

	cmp	DWORD PTR _forcelink$[ebp], 0
	je	$LN40@CL_ParseQu

; 550  : 	{
; 551  : 		VectorCopy( state->origin, ent->baseline.vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+412], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+412], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+412], eax

; 552  : 
; 553  : 		SetBits( state->effects, EF_NOINTERP );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+60], ecx

; 554  : 
; 555  : 		// interpolation must be reset
; 556  : 		SETVISBIT( frame->flags, pack );

	cmp	DWORD PTR _pack$[ebp], 0
	jl	SHORT $LN42@CL_ParseQu
	mov	eax, DWORD PTR _pack$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _pack$[ebp]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+23786]
	or	eax, edx
	mov	DWORD PTR tv351[ebp], eax
	mov	ecx, DWORD PTR _pack$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _frame$[ebp]
	mov	al, BYTE PTR tv351[ebp]
	mov	BYTE PTR [edx+ecx+23786], al
	movzx	ecx, BYTE PTR tv351[ebp]
	mov	DWORD PTR tv354[ebp], ecx
	jmp	SHORT $LN43@CL_ParseQu
$LN42@CL_ParseQu:
	mov	DWORD PTR tv354[ebp], 0
$LN43@CL_ParseQu:

; 557  : 
; 558  : 		// release beams from previous entity
; 559  : 		CL_KillDeadBeams( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_KillDeadBeams
	add	esp, 4
$LN40@CL_ParseQu:

; 560  : 	}
; 561  : 
; 562  : 	// add entity to packet
; 563  : 	cls.next_client_entities++;

	mov	eax, DWORD PTR _cls+295008
	add	eax, 1
	mov	DWORD PTR _cls+295008, eax

; 564  : 	frame->num_entities++;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24044]
	add	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+24044], ecx

; 565  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeEntityData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeClientData
_TEXT	SEGMENT
_frame$ = -12						; size = 4
_bits$ = -8						; size = 4
_i$ = -4						; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeClientData PROC				; COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 347  : 	int	i, bits = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _bits$[ebp], eax

; 348  : 	frame_t	*frame;
; 349  : 
; 350  : 	// this is the frame update that this message corresponds to
; 351  : 	i = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _i$[ebp], eax

; 352  : 
; 353  : 	cl.parsecount = i;					// ack'd incoming messages.  

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cl+8, eax

; 354  : 	cl.parsecountmod = cl.parsecount & CL_UPDATE_MASK;	// index into window.     

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cl+8
	mov	DWORD PTR _cl+12, eax

; 355  : 	frame = &cl.frames[cl.parsecountmod];			// frame at index.

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _frame$[ebp], eax

; 356  : 	frame->time = cl.mtime[0];				// mark network received time

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	movsd	QWORD PTR [edx+16], xmm0

; 357  : 	frame->receivedtime = host.realtime;			// time now that we are parsing.  

	mov	eax, DWORD PTR _frame$[ebp]
	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR [eax], xmm0

; 358  : 	memset( &frame->graphdata, 0, sizeof( netbandwidthgraph_t ));

	push	18					; 00000012H
	push	0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 23768				; 00005cd8H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 359  : 	memset( frame->flags, 0, sizeof( frame->flags ));

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 23786				; 00005ceaH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 360  : 	frame->first_entity = cls.next_client_entities;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _cls+295008
	mov	DWORD PTR [eax+24048], ecx

; 361  : 	frame->num_entities = 0;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax+24044], 0

; 362  : 	frame->valid = true; // assume valid

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax+24], 1

; 363  : 
; 364  : 	if( FBitSet( bits, SU_VIEWHEIGHT ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1
	je	SHORT $LN5@CL_ParseQu

; 365  : 		frame->clientdata.view_ofs[2] = MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [edx+ecx+88], xmm0
	jmp	SHORT $LN6@CL_ParseQu
$LN5@CL_ParseQu:

; 366  : 	else frame->clientdata.view_ofs[2] = 22.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _frame$[ebp]
	movss	xmm0, DWORD PTR __real@41b00000
	movss	DWORD PTR [ecx+eax+88], xmm0
$LN6@CL_ParseQu:

; 367  : 
; 368  : 	if( FBitSet( bits, SU_IDEALPITCH ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 2
	je	SHORT $LN7@CL_ParseQu

; 369  : 		cl.local.idealpitch = MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _cl+2212644, xmm0
	jmp	SHORT $LN8@CL_ParseQu
$LN7@CL_ParseQu:

; 370  : 	else cl.local.idealpitch = 0;

	xorps	xmm0, xmm0
	movss	DWORD PTR _cl+2212644, xmm0
$LN8@CL_ParseQu:

; 371  : 
; 372  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseQu
$LN2@CL_ParseQu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@CL_ParseQu

; 373  : 	{
; 374  : 		if( FBitSet( bits, SU_PUNCH1 << i ))

	mov	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _bits$[ebp]
	je	SHORT $LN9@CL_ParseQu

; 375  : 			frame->clientdata.punchangle[i] = (float)MSG_ReadChar( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [edx+ecx*4+64], xmm0
	jmp	SHORT $LN10@CL_ParseQu
$LN9@CL_ParseQu:

; 376  : 		else frame->clientdata.punchangle[i] = 0.0f;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+64], xmm0
$LN10@CL_ParseQu:

; 377  : 
; 378  : 		if( FBitSet( bits, ( SU_VELOCITY1 << i )))

	mov	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	and	eax, DWORD PTR _bits$[ebp]
	je	SHORT $LN11@CL_ParseQu

; 379  : 			frame->clientdata.velocity[i] = MSG_ReadChar( msg ) * 16.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41800000
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _frame$[ebp]
	movss	DWORD PTR [edx+ecx*4+44], xmm0
	jmp	SHORT $LN12@CL_ParseQu
$LN11@CL_ParseQu:

; 380  : 		else frame->clientdata.velocity[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax*4+44], xmm0
$LN12@CL_ParseQu:

; 381  : 	}

	jmp	$LN2@CL_ParseQu
$LN3@CL_ParseQu:

; 382  : 
; 383  : 	if( FBitSet( bits, SU_ONGROUND ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN13@CL_ParseQu

; 384  : 		SetBits( frame->clientdata.flags, FL_ONGROUND );

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN13@CL_ParseQu:

; 385  : 	if( FBitSet( bits, SU_INWATER ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN14@CL_ParseQu

; 386  : 		SetBits( frame->clientdata.flags, FL_INWATER );

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN14@CL_ParseQu:

; 387  : 
; 388  : 	// [always sent]
; 389  : 	MSG_WriteLong( &msg_demo, MSG_ReadLong( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 390  : 	CL_DispatchQuakeMessage( "Items" );

	push	OFFSET ??_C@_05CCNNDGIA@Items@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 391  : 
; 392  : 	if( FBitSet( bits, SU_WEAPONFRAME ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN15@CL_ParseQu

; 393  : 		CL_UpdateQuakeStats( msg, STAT_WEAPONFRAME, true );

	push	1
	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@CL_ParseQu
$LN15@CL_ParseQu:

; 394  : 	else CL_UpdateQuakeStats( msg, STAT_WEAPONFRAME, false );

	push	0
	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 395  : 
; 396  : 	if( FBitSet( bits, SU_ARMOR ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 8192				; 00002000H
	je	SHORT $LN17@CL_ParseQu

; 397  : 		CL_UpdateQuakeStats( msg, STAT_ARMOR, true );

	push	1
	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@CL_ParseQu
$LN17@CL_ParseQu:

; 398  : 	else CL_UpdateQuakeStats( msg, STAT_ARMOR, false );

	push	0
	push	4
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
$LN18@CL_ParseQu:

; 399  : 
; 400  : 	if( FBitSet( bits, SU_WEAPON ))

	mov	eax, DWORD PTR _bits$[ebp]
	and	eax, 16384				; 00004000H
	je	SHORT $LN19@CL_ParseQu

; 401  : 		frame->clientdata.viewmodel = CL_UpdateQuakeStats( msg, STAT_WEAPON, true );

	push	1
	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+56], eax
	jmp	SHORT $LN20@CL_ParseQu
$LN19@CL_ParseQu:

; 402  : 	else frame->clientdata.viewmodel = CL_UpdateQuakeStats( msg, STAT_WEAPON, false );

	push	0
	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [ecx+56], eax
$LN20@CL_ParseQu:

; 403  : 
; 404  : 	cl.local.health = CL_UpdateQuakeStats( msg, STAT_HEALTH, true );

	push	1
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cl+2212656, eax

; 405  : 	CL_UpdateQuakeStats( msg, STAT_AMMO, true );

	push	1
	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 406  : 	CL_UpdateQuakeStats( msg, STAT_SHELLS, true );

	push	1
	push	6
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 407  : 	CL_UpdateQuakeStats( msg, STAT_NAILS, true );

	push	1
	push	7
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 408  : 	CL_UpdateQuakeStats( msg, STAT_ROCKETS, true );

	push	1
	push	8
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 409  : 	CL_UpdateQuakeStats( msg, STAT_CELLS, true );

	push	1
	push	9
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 410  : 	CL_UpdateQuakeStats( msg, STAT_ACTIVEWEAPON, true );

	push	1
	push	10					; 0000000aH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_UpdateQuakeStats
	add	esp, 12					; 0000000cH

; 411  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeClientData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeServerInfo
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv255 = -84						; size = 4
tv247 = -84						; size = 4
tv83 = -84						; size = 4
tv69 = -84						; size = 4
_i$ = -16						; size = 4
_gametype$ = -12					; size = 4
_pResName$ = -8						; size = 4
_pResource$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeServerInfo PROC				; COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 184  : 	resource_t	*pResource;
; 185  : 	const char	*pResName;
; 186  : 	int		gametype;
; 187  : 	int		i;
; 188  : 
; 189  : 	Con_Reportf( "Serverdata packet received.\n" );

	push	OFFSET ??_C@_0BN@MIBLBBKG@Serverdata?5packet?5received?4?6@
	call	_Con_Reportf
	add	esp, 4

; 190  : 	cls.timestart = Sys_DoubleTime();

	call	_Sys_DoubleTime
	fstp	QWORD PTR _cls+16

; 191  : 
; 192  : 	cls.demowaiting = false;	// server is changed

	mov	DWORD PTR _cls+300832, 0

; 193  : 
; 194  : 	// wipe the client_t struct
; 195  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN8@CL_ParseQu
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN8@CL_ParseQu

; 196  : 		CL_ClearState ();

	call	_CL_ClearState
$LN8@CL_ParseQu:

; 197  : 	cl.background = (cls.demonum != -1) ? true : false;

	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN32@CL_ParseQu
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN33@CL_ParseQu
$LN32@CL_ParseQu:
	mov	DWORD PTR tv69[ebp], 0
$LN33@CL_ParseQu:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _cl+64, eax

; 198  : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 199  : 
; 200  : 	// parse protocol version number
; 201  : 	i = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 202  : 
; 203  : 	if( i != PROTOCOL_VERSION_QUAKE )

	cmp	DWORD PTR _i$[ebp], 15			; 0000000fH
	je	SHORT $LN9@CL_ParseQu

; 204  : 	{
; 205  : 		Con_Printf( "\n" S_ERROR "Server use invalid protocol (%i should be %i)\n", i, PROTOCOL_VERSION_QUAKE );

	push	15					; 0000000fH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DL@FCAPPBJA@?6?$FO1Error?3?$FO7?5Server?5use?5invalid?5@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 206  : 		CL_StopPlayback();

	call	_CL_StopPlayback

; 207  : 		Host_AbortCurrentFrame();

	call	_Host_AbortCurrentFrame
$LN9@CL_ParseQu:

; 208  : 	}
; 209  : 
; 210  : 	cl.maxclients = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+2213004, eax

; 211  : 	gametype = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _gametype$[ebp], eax

; 212  : 	clgame.maxEntities = GI->max_edicts;

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1656]
	mov	DWORD PTR _clgame+1008, ecx

; 213  : 	clgame.maxEntities = bound( 600, clgame.maxEntities, MAX_EDICTS );

	cmp	DWORD PTR _clgame+1008, 600		; 00000258H
	jl	SHORT $LN36@CL_ParseQu
	cmp	DWORD PTR _clgame+1008, 8192		; 00002000H
	jge	SHORT $LN34@CL_ParseQu
	mov	eax, DWORD PTR _clgame+1008
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN35@CL_ParseQu
$LN34@CL_ParseQu:
	mov	DWORD PTR tv83[ebp], 8192		; 00002000H
$LN35@CL_ParseQu:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN37@CL_ParseQu
$LN36@CL_ParseQu:
	mov	DWORD PTR tv84[ebp], 600		; 00000258H
$LN37@CL_ParseQu:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _clgame+1008, edx

; 214  : 	clgame.maxModels = MAX_MODELS;

	mov	DWORD PTR _clgame+1020, 1024		; 00000400H

; 215  : 	Q_strncpy( clgame.maptitle, MSG_ReadString( msg ), MAX_STRING );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+484
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 216  : 
; 217  : 	// Re-init hud video, especially if we changed game directories
; 218  : 	clgame.dllFuncs.pfnVidInit();

	call	DWORD PTR _clgame+12

; 219  : 
; 220  : 	if( Con_FixedFont( ))

	call	_Con_FixedFont
	test	eax, eax
	je	SHORT $LN10@CL_ParseQu

; 221  : 	{
; 222  : 		// seperate the printfs so the server message can have a color
; 223  : 		Con_Print( "\n\35\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\36\37\n" );

	push	OFFSET ??_C@_0CI@EJCMMMBF@?6?$BN?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO?$BO@
	call	_Con_Print
	add	esp, 4

; 224  : 		Con_Print( va( "%c%s\n\n", 2, clgame.maptitle ));

	push	OFFSET _clgame+484
	push	2
	push	OFFSET ??_C@_06PGKFIJBE@?$CFc?$CFs?6?6@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_Con_Print
	add	esp, 4
$LN10@CL_ParseQu:

; 225  : 	}
; 226  : 
; 227  : 	// multiplayer game?
; 228  : 	if( cl.maxclients > 1 )	

	cmp	DWORD PTR _cl+2213004, 1
	jle	SHORT $LN11@CL_ParseQu

; 229  : 	{
; 230  : 		// allow console in multiplayer games
; 231  : 		host.allow_console = true;

	mov	DWORD PTR _host+34336, 1

; 232  : 
; 233  : 		// loading user settings
; 234  : 		CSCR_LoadDefaultCVars( "user.scr" );

	push	OFFSET ??_C@_08EOJKMECK@user?4scr@
	call	_CSCR_LoadDefaultCVars
	add	esp, 4

; 235  : 
; 236  : 		if( r_decals->value > mp_decals.value )

	mov	eax, DWORD PTR _r_decals
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _mp_decals+12
	jbe	SHORT $LN13@CL_ParseQu

; 237  : 			Cvar_SetValue( "r_decals", mp_decals.value );

	push	ecx
	movss	xmm0, DWORD PTR _mp_decals+12
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08HELCJCPN@r_decals@
	call	_Cvar_SetValue
	add	esp, 8
$LN13@CL_ParseQu:

; 238  : 	}

	jmp	SHORT $LN12@CL_ParseQu
$LN11@CL_ParseQu:

; 239  : 	else Cvar_Reset( "r_decals" );

	push	OFFSET ??_C@_08HELCJCPN@r_decals@
	call	_Cvar_Reset
	add	esp, 4
$LN12@CL_ParseQu:

; 240  : 
; 241  : 	// re-init mouse
; 242  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN14@CL_ParseQu

; 243  : 		host.mouse_visible = false;

	mov	DWORD PTR _host+34372, 0
$LN14@CL_ParseQu:

; 244  : 
; 245  : 	if( cl.background )	// tell the game parts about background state

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN15@CL_ParseQu

; 246  : 		Cvar_FullSet( "cl_background", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@CL_ParseQu
$LN15@CL_ParseQu:

; 247  : 	else Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 248  : 
; 249  : 	S_StopBackgroundTrack ();

	call	_S_StopBackgroundTrack

; 250  : 
; 251  : 	if( !cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN17@CL_ParseQu

; 252  : 		UI_SetActiveMenu( cl.background );

	mov	eax, DWORD PTR _cl+64
	push	eax
	call	_UI_SetActiveMenu
	add	esp, 4
	jmp	SHORT $LN19@CL_ParseQu
$LN17@CL_ParseQu:

; 253  : 	else if( !cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN19@CL_ParseQu

; 254  : 		Key_SetKeyDest( key_menu );

	push	2
	call	_Key_SetKeyDest
	add	esp, 4
$LN19@CL_ParseQu:

; 255  : 
; 256  : 	// don't reset cursor in background mode
; 257  : 	if( cl.background )

	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN20@CL_ParseQu

; 258  : 		IN_MouseRestorePos();

	call	_IN_MouseRestorePos
$LN20@CL_ParseQu:

; 259  : 
; 260  : 	// will be changed later
; 261  : 	cl.viewentity = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	DWORD PTR _cl+2212780, eax

; 262  : 	gameui.globals->maxClients = cl.maxclients;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _cl+2213004
	mov	DWORD PTR [eax+16], ecx

; 263  : 	Q_strncpy( gameui.globals->maptitle, clgame.maptitle, sizeof( gameui.globals->maptitle ));

	push	64					; 00000040H
	push	OFFSET _clgame+484
	mov	eax, DWORD PTR _gameui+7048
	add	eax, 96					; 00000060H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 264  : 
; 265  : 	if( !cls.changelevel && !cls.changedemo )

	cmp	DWORD PTR _cls+8, 0
	jne	SHORT $LN21@CL_ParseQu
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN21@CL_ParseQu

; 266  : 		CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts
$LN21@CL_ParseQu:

; 267  : 
; 268  : 	// Quake just have a large packet of initialization data
; 269  : 	for( i = 1; i < MAX_MODELS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_ParseQu
$LN2@CL_ParseQu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@CL_ParseQu

; 270  : 	{
; 271  : 		pResName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pResName$[ebp], eax

; 272  : 
; 273  : 		if( !COM_CheckString( pResName ))

	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@CL_ParseQu

; 274  : 			break; // end of list

	jmp	$LN3@CL_ParseQu
$LN22@CL_ParseQu:

; 275  : 
; 276  : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseQuakeServerInfo@@9@9
	add	eax, 93					; 0000005dH
	push	eax
	push	OFFSET ??_C@_0DG@EHGMHDBG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 277  : 		pResource->type = t_model;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+64], 2

; 278  : 
; 279  : 		Q_strncpy( pResource->szFileName, pResName, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 280  : 		if( i == 1 ) Q_strncpy( clgame.mapname, pResName, sizeof( clgame.mapname ));

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $LN23@CL_ParseQu
	push	256					; 00000100H
	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	push	OFFSET _clgame+228
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN23@CL_ParseQu:

; 281  : 		pResource->nDownloadSize = -1;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+72], -1

; 282  : 		pResource->nIndex = i;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 283  : 
; 284  : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 285  : 	}

	jmp	$LN2@CL_ParseQu
$LN3@CL_ParseQu:

; 286  : 
; 287  : 	for( i = 1; i < MAX_SOUNDS; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN7@CL_ParseQu
$LN5@CL_ParseQu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_ParseQu:
	cmp	DWORD PTR _i$[ebp], 8192		; 00002000H
	jge	$LN6@CL_ParseQu

; 288  : 	{
; 289  : 		pResName = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _pResName$[ebp], eax

; 290  : 
; 291  : 		if( !COM_CheckString( pResName ))

	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@CL_ParseQu

; 292  : 			break; // end of list

	jmp	SHORT $LN6@CL_ParseQu
$LN24@CL_ParseQu:

; 293  : 
; 294  : 		pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ParseQuakeServerInfo@@9@9
	add	eax, 111				; 0000006fH
	push	eax
	push	OFFSET ??_C@_0DG@EHGMHDBG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 295  : 		pResource->type = t_sound;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+64], 0

; 296  : 
; 297  : 		Q_strncpy( pResource->szFileName, pResName, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pResName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 298  : 		pResource->nDownloadSize = -1;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+72], -1

; 299  : 		pResource->nIndex = i;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 300  : 
; 301  : 		CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8

; 302  : 	}

	jmp	$LN5@CL_ParseQu
$LN6@CL_ParseQu:

; 303  : 
; 304  : 	// get splash name
; 305  : 	if( cls.demoplayback && ( cls.demonum != -1 ))

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN25@CL_ParseQu
	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN25@CL_ParseQu

; 306  : 		Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", cls.demoname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN38@CL_ParseQu
	mov	DWORD PTR tv247[ebp], OFFSET ??_C@_04CELKIKPL@16x9@
	jmp	SHORT $LN39@CL_ParseQu
$LN38@CL_ParseQu:
	mov	DWORD PTR tv247[ebp], OFFSET ??_C@_03PHLBDMN@4x3@
$LN39@CL_ParseQu:
	mov	eax, DWORD PTR tv247[ebp]
	push	eax
	push	OFFSET _cls+300840
	push	OFFSET ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
	jmp	SHORT $LN26@CL_ParseQu
$LN25@CL_ParseQu:

; 307  : 	else Cvar_Set( "cl_levelshot_name", va( "levelshots/%s_%s", clgame.mapname, glState.wideScreen ? "16x9" : "4x3" ));

	cmp	DWORD PTR _glState+12, 0
	je	SHORT $LN40@CL_ParseQu
	mov	DWORD PTR tv255[ebp], OFFSET ??_C@_04CELKIKPL@16x9@
	jmp	SHORT $LN41@CL_ParseQu
$LN40@CL_ParseQu:
	mov	DWORD PTR tv255[ebp], OFFSET ??_C@_03PHLBDMN@4x3@
$LN41@CL_ParseQu:
	mov	eax, DWORD PTR tv255[ebp]
	push	eax
	push	OFFSET _clgame+228
	push	OFFSET ??_C@_0BB@EEMHGEDI@levelshots?1?$CFs_?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
$LN26@CL_ParseQu:

; 308  : 	Cvar_SetValue( "scr_loading", 0.0f ); // reset progress bar

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0M@DKOEGGOG@scr_loading@
	call	_Cvar_SetValue
	add	esp, 8

; 309  : 
; 310  : 	if(( cl_allow_levelshots->value && !cls.changelevel ) || cl.background )

	mov	eax, DWORD PTR _cl_allow_levelshots
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN29@CL_ParseQu
	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN28@CL_ParseQu
$LN29@CL_ParseQu:
	cmp	DWORD PTR _cl+64, 0
	je	SHORT $LN27@CL_ParseQu
$LN28@CL_ParseQu:

; 311  : 	{
; 312  : 		if( !FS_FileExists( va( "%s.bmp", cl_levelshot_name->string ), true )) 

	push	1
	mov	eax, DWORD PTR _cl_levelshot_name
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_06PCEOMGLN@?$CFs?4bmp@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@CL_ParseQu

; 313  : 			Cvar_Set( "cl_levelshot_name", "*black" ); // render a black screen

	push	OFFSET ??_C@_06FPKCCFDN@?$CKblack@
	push	OFFSET ??_C@_0BC@CBJAHLIN@cl_levelshot_name@
	call	_Cvar_Set
	add	esp, 8
$LN30@CL_ParseQu:

; 314  : 		cls.scrshot_request = scrshot_plaque; // request levelshot even if exist (check filetime)

	mov	DWORD PTR _cls+296304, 3
$LN27@CL_ParseQu:

; 315  : 	}
; 316  : 
; 317  : 	memset( &clgame.movevars, 0, sizeof( clgame.movevars ));

	push	160					; 000000a0H
	push	0
	push	OFFSET _clgame+1024
	call	_memset
	add	esp, 12					; 0000000cH

; 318  : 	memset( &clgame.oldmovevars, 0, sizeof( clgame.oldmovevars ));

	push	160					; 000000a0H
	push	0
	push	OFFSET _clgame+1184
	call	_memset
	add	esp, 12					; 0000000cH

; 319  : 	memset( &clgame.centerPrint, 0, sizeof( clgame.centerPrint ));

	push	2068					; 00000814H
	push	0
	push	OFFSET _clgame+215004
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	cl.video_prepped = false;

	mov	DWORD PTR _cl+16, 0

; 321  : 	cl.audio_prepped = false;

	mov	DWORD PTR _cl+20, 0

; 322  : 
; 323  : 	// GAME_COOP or GAME_DEATHMATCH
; 324  : 	CL_UpdateQuakeGameMode( gametype );

	mov	eax, DWORD PTR _gametype$[ebp]
	push	eax
	call	_CL_UpdateQuakeGameMode
	add	esp, 4

; 325  : 
; 326  : 	// now we can start to precache
; 327  : 	CL_BatchResourceRequest( true );

	push	1
	call	_CL_BatchResourceRequest
	add	esp, 4

; 328  : 
; 329  : 	clgame.movevars.wateralpha = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _clgame+1180, xmm0

; 330  : 	clgame.entities->curstate.scale = 0.0f;

	mov	eax, DWORD PTR _clgame+996
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+976], xmm0

; 331  : 	clgame.movevars.waveHeight = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _clgame+1084, xmm0

; 332  : 	clgame.movevars.zmax = 14172.0f;	// 8192 * 1.74

	movss	xmm0, DWORD PTR __real@465d7000
	movss	DWORD PTR _clgame+1080, xmm0

; 333  : 	clgame.movevars.gravity = 800.0f;	// quake doesn't write gravity in demos

	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR _clgame+1024, xmm0

; 334  : 	clgame.movevars.maxvelocity = 2000.0f;

	movss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _clgame+1076, xmm0

; 335  : 
; 336  : 	memcpy( &clgame.oldmovevars, &clgame.movevars, sizeof( movevars_t ));

	push	160					; 000000a0H
	push	OFFSET _clgame+1024
	push	OFFSET _clgame+1184
	call	_memcpy
	add	esp, 12					; 0000000cH

; 337  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeServerInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeSound
_TEXT	SEGMENT
_pos$ = -44						; size = 12
_handle$ = -32						; size = 4
_attn$ = -28						; size = 4
_volume$ = -24						; size = 4
_entnum$ = -20						; size = 4
_flags$ = -16						; size = 4
_sound$ = -12						; size = 4
_channel$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseQuakeSound PROC				; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 142  : 	int 	channel, sound;
; 143  : 	int	flags, entnum;
; 144  : 	float 	volume, attn;
; 145  : 	sound_t	handle;
; 146  : 	vec3_t	pos;
; 147  : 
; 148  : 	flags = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 149  : 
; 150  : 	if( FBitSet( flags, SND_VOLUME ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@CL_ParseQu

; 151  : 		volume = (float)MSG_ReadByte( msg ) / 255.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR _volume$[ebp], xmm0
	jmp	SHORT $LN3@CL_ParseQu
$LN2@CL_ParseQu:

; 152  : 	else volume = VOL_NORM;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _volume$[ebp], xmm0
$LN3@CL_ParseQu:

; 153  : 
; 154  : 	if( FBitSet( flags, SND_ATTENUATION ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@CL_ParseQu

; 155  : 		attn = (float)MSG_ReadByte( msg ) / 64.0f;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _attn$[ebp], xmm0
	jmp	SHORT $LN5@CL_ParseQu
$LN4@CL_ParseQu:

; 156  : 	else attn = ATTN_NONE;

	xorps	xmm0, xmm0
	movss	DWORD PTR _attn$[ebp], xmm0
$LN5@CL_ParseQu:

; 157  : 
; 158  : 	channel = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _channel$[ebp], eax

; 159  : 	sound = MSG_ReadByte( msg );	// Quake1 have max 255 precached sounds. erm

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _sound$[ebp], eax

; 160  : 
; 161  : 	// positioned in space
; 162  : 	MSG_ReadVec3Coord( msg, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadVec3Coord
	add	esp, 8

; 163  : 
; 164  : 	entnum = channel >> 3;	// entity reletive

	mov	eax, DWORD PTR _channel$[ebp]
	sar	eax, 3
	mov	DWORD PTR _entnum$[ebp], eax

; 165  : 	channel &= 7;

	mov	eax, DWORD PTR _channel$[ebp]
	and	eax, 7
	mov	DWORD PTR _channel$[ebp], eax

; 166  : 
; 167  : 	// see precached sound
; 168  : 	handle = cl.sound_index[sound];

	mov	eax, DWORD PTR _sound$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4561596]
	mov	DWORD PTR _handle$[ebp], ecx

; 169  : 
; 170  : 	if( !cl.audio_prepped )

	cmp	DWORD PTR _cl+20, 0
	jne	SHORT $LN6@CL_ParseQu

; 171  : 		return; // too early

	jmp	SHORT $LN1@CL_ParseQu
$LN6@CL_ParseQu:

; 172  : 
; 173  : 	S_StartSound( pos, entnum, channel, handle, volume, attn, PITCH_NORM, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR _attn$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _channel$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@CL_ParseQu:

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_UpdateQuakeGameMode
_TEXT	SEGMENT
_gamemode$ = 8						; size = 4
_CL_UpdateQuakeGameMode PROC				; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 130  : 	MSG_WriteByte( &msg_demo, gamemode );

	mov	eax, DWORD PTR _gamemode$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 131  : 	CL_DispatchQuakeMessage( "GameMode" );

	push	OFFSET ??_C@_08JJGOBBMF@GameMode@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateQuakeGameMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_UpdateQuakeStats
_TEXT	SEGMENT
_value$ = -4						; size = 4
_msg$ = 8						; size = 4
_statnum$ = 12						; size = 4
_has_update$ = 16					; size = 4
_CL_UpdateQuakeStats PROC				; COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 104  : 	int 	value = 0;

	mov	DWORD PTR _value$[ebp], 0

; 105  : 
; 106  : 	MSG_WriteByte( &msg_demo, statnum );	// stat num

	mov	eax, DWORD PTR _statnum$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 107  : 
; 108  : 	if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN2@CL_UpdateQ

; 109  : 	{
; 110  : 		if( statnum == STAT_HEALTH )

	cmp	DWORD PTR _statnum$[ebp], 0
	jne	SHORT $LN3@CL_UpdateQ

; 111  : 			value = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _value$[ebp], eax
	jmp	SHORT $LN2@CL_UpdateQ
$LN3@CL_UpdateQ:

; 112  : 		else value = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _value$[ebp], eax
$LN2@CL_UpdateQ:

; 113  : 	}
; 114  : 
; 115  : 	MSG_WriteLong( &msg_demo, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 116  : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET ??_C@_05BMAFBINF@Stats@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 117  : 
; 118  : 	return value;

	mov	eax, DWORD PTR _value$[ebp]

; 119  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateQuakeStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_QuakeEntityTeleported
_TEXT	SEGMENT
tv151 = -92						; size = 4
tv90 = -92						; size = 4
_delta$ = -24						; size = 12
_maxlen$ = -12						; size = 4
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_newstate$ = 12						; size = 4
_CL_QuakeEntityTeleported PROC				; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 83   : 	float	len, maxlen;
; 84   : 	vec3_t	delta;
; 85   : 
; 86   : 	VectorSubtract( newstate->origin, ent->prevstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+16]
	subss	xmm0, DWORD PTR [esi+eax+476]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+16]
	subss	xmm0, DWORD PTR [esi+eax+476]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _newstate$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR [esi+ecx+476]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 87   : 
; 88   : 	// compute potential max movement in units per frame and compare with entity movement
; 89   : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1076
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxlen$[ebp], xmm0

; 90   : 	len = VectorLength( delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _len$[ebp]

; 91   : 
; 92   : 	return (len > maxlen);

	movss	xmm0, DWORD PTR _len$[ebp]
	comiss	xmm0, DWORD PTR _maxlen$[ebp]
	jbe	SHORT $LN3@CL_QuakeEn
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_QuakeEn
$LN3@CL_QuakeEn:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_QuakeEn:
	mov	eax, DWORD PTR tv151[ebp]

; 93   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QuakeEntityTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeStats
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_CL_ParseQuakeStats PROC				; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 68   : 	MSG_WriteByte( &msg_demo, MSG_ReadByte( msg ));	// stat num

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteByte
	add	esp, 8

; 69   : 	MSG_WriteLong( &msg_demo, MSG_ReadLong( msg ));	// stat value

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	OFFSET _msg_demo
	call	_MSG_WriteLong
	add	esp, 8

; 70   : 	CL_DispatchQuakeMessage( "Stats" );

	push	OFFSET ??_C@_05BMAFBINF@Stats@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseQuakeStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_DispatchQuakeMessage
_TEXT	SEGMENT
_name$ = 8						; size = 4
_CL_DispatchQuakeMessage PROC				; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 55   : 	CL_DispatchUserMessage( name, msg_demo.iCurBit >> 3, msg_demo.pData );

	mov	eax, DWORD PTR _msg_demo+8
	push	eax
	mov	ecx, DWORD PTR _msg_demo+12
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH

; 56   : 	MSG_Clear( &msg_demo ); // don't forget to clear buffer

	push	OFFSET _msg_demo
	call	_MSG_Clear
	add	esp, 4

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DispatchQuakeMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_qparse.c
;	COMDAT _CL_ParseQuakeMessage
_TEXT	SEGMENT
tv170 = -124						; size = 4
tv141 = -124						; size = 4
_packed_fog$1 = -56					; size = 16
_fog_settings$2 = -40					; size = 16
_str$ = -24						; size = 4
_bufStart$ = -20					; size = 4
_param2$ = -16						; size = 4
_param1$ = -12						; size = 4
_cmd$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_normal_message$ = 12					; size = 4
_CL_ParseQuakeMessage PROC				; COMDAT

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 897  : 	int		cmd, param1, param2;
; 898  : 	size_t		bufStart;
; 899  : 	const char	*str;
; 900  : 
; 901  : 	cls.starting_count = MSG_GetNumBytesRead( msg );	// updates each frame

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _cls+290584, eax

; 902  : 	CL_Parse_Debug( true );			// begin parsing

	push	1
	call	_CL_Parse_Debug
	add	esp, 4

; 903  : 
; 904  : 	// init excise buffer
; 905  : 	MSG_Init( &msg_demo, "UserMsg", msg_buf, sizeof( msg_buf ));

	push	-1
	push	8192					; 00002000H
	push	OFFSET _msg_buf
	push	OFFSET ??_C@_07JEMFJBEN@UserMsg@
	push	OFFSET _msg_demo
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 906  : 
; 907  : 	if( normal_message )

	cmp	DWORD PTR _normal_message$[ebp], 0
	je	SHORT $LN8@CL_ParseQu

; 908  : 	{
; 909  : 		// assume no entity/player update this packet
; 910  : 		if( cls.state == ca_active )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN7@CL_ParseQu

; 911  : 		{
; 912  : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].valid = false;   

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	mov	DWORD PTR _cl[ecx+112], 0

; 913  : 			cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK].choked = false;

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	mov	DWORD PTR _cl[ecx+116], 0

; 914  : 		}

	jmp	SHORT $LN8@CL_ParseQu
$LN7@CL_ParseQu:

; 915  : 		else
; 916  : 		{
; 917  : 			CL_ResetFrame( &cl.frames[cls.netchan.incoming_sequence & CL_UPDATE_MASK] );

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cls+26864
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+88
	push	ecx
	call	_CL_ResetFrame
	add	esp, 4
$LN8@CL_ParseQu:

; 918  : 		}
; 919  : 	}
; 920  : 
; 921  : 	// parse the message
; 922  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@CL_ParseQu

; 923  : 	{
; 924  : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@CL_ParseQu

; 925  : 		{
; 926  : 			Host_Error( "CL_ParseServerMessage: overflow!\n" );

	push	OFFSET ??_C@_0CC@MGOFLPNB@CL_ParseServerMessage?3?5overflow@
	call	_Host_Error
	add	esp, 4

; 927  : 			return;

	jmp	$LN1@CL_ParseQu
$LN9@CL_ParseQu:

; 928  : 		}
; 929  : 
; 930  : 		// mark start position
; 931  : 		bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 932  : 
; 933  : 		// end of message (align bits)
; 934  : 		if( MSG_GetNumBitsLeft( msg ) < 8 )

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBitsLeft
	add	esp, 4
	cmp	eax, 8
	jge	SHORT $LN10@CL_ParseQu

; 935  : 			break;		

	jmp	$LN3@CL_ParseQu
$LN10@CL_ParseQu:

; 936  : 
; 937  : 		cmd = MSG_ReadServerCmd( msg );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCmd
	add	esp, 8
	mov	DWORD PTR _cmd$[ebp], eax

; 938  : 
; 939  : 		// if the high bit of the command byte is set, it is a fast update
; 940  : 		if( FBitSet( cmd, 128 ))

	mov	eax, DWORD PTR _cmd$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN11@CL_ParseQu

; 941  : 		{
; 942  : 			CL_ParseQuakeEntityData( msg, cmd & 127 );

	mov	eax, DWORD PTR _cmd$[ebp]
	and	eax, 127				; 0000007fH
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_CL_ParseQuakeEntityData
	add	esp, 8

; 943  : 			continue;

	jmp	$LN8@CL_ParseQu
$LN11@CL_ParseQu:

; 944  : 		}
; 945  : 
; 946  : 		// record command for debugging spew on parse problem
; 947  : 		CL_Parse_RecordCommand( cmd, bufStart );

	mov	eax, DWORD PTR _bufStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_CL_Parse_RecordCommand
	add	esp, 8

; 948  : 
; 949  : 		// other commands
; 950  : 		switch( cmd )

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR tv141[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv141[ebp], ecx
	cmp	DWORD PTR tv141[ebp], 50		; 00000032H
	ja	$LN54@CL_ParseQu
	mov	edx, DWORD PTR tv141[ebp]
	jmp	DWORD PTR $LN59@CL_ParseQu[edx*4]
$LN12@CL_ParseQu:

; 951  : 		{
; 952  : 		case svc_nop:
; 953  : 			// this does nothing
; 954  : 			break;

	jmp	$LN4@CL_ParseQu
$LN13@CL_ParseQu:

; 955  : 		case svc_disconnect:
; 956  : 			CL_DemoCompleted ();

	call	_CL_DemoCompleted

; 957  : 			break;

	jmp	$LN4@CL_ParseQu
$LN14@CL_ParseQu:

; 958  : 		case svc_updatestat:
; 959  : 			CL_ParseQuakeStats( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeStats
	add	esp, 4

; 960  : 			break;

	jmp	$LN4@CL_ParseQu
$LN15@CL_ParseQu:

; 961  : 		case svc_version:
; 962  : 			param1 = MSG_ReadLong( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 963  : 			if( param1 != PROTOCOL_VERSION_QUAKE )

	cmp	DWORD PTR _param1$[ebp], 15		; 0000000fH
	je	SHORT $LN16@CL_ParseQu

; 964  : 				Host_Error( "Server is protocol %i instead of %i\n", param1, PROTOCOL_VERSION_QUAKE );

	push	15					; 0000000fH
	mov	eax, DWORD PTR _param1$[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@DJJOJFKE@Server?5is?5protocol?5?$CFi?5instead?5o@
	call	_Host_Error
	add	esp, 12					; 0000000cH
$LN16@CL_ParseQu:

; 965  : 			break;

	jmp	$LN4@CL_ParseQu
$LN17@CL_ParseQu:

; 966  : 		case svc_setview:
; 967  : 			CL_ParseViewEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseViewEntity
	add	esp, 4

; 968  : 			break;

	jmp	$LN4@CL_ParseQu
$LN18@CL_ParseQu:

; 969  : 		case svc_sound:
; 970  : 			CL_ParseQuakeSound( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeSound
	add	esp, 4

; 971  : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23864]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23864], cx

; 972  : 			break;

	jmp	$LN4@CL_ParseQu
$LN19@CL_ParseQu:

; 973  : 		case svc_time:
; 974  : 			Cbuf_AddText( "\n" ); // new frame was started

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4

; 975  : 			CL_ParseServerTime( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseServerTime
	add	esp, 4

; 976  : 			break;

	jmp	$LN4@CL_ParseQu
$LN20@CL_ParseQu:

; 977  : 		case svc_print:
; 978  : 			str = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 979  : 			Con_Printf( "%s%s", str, *str == 2 ? "\n" : "" );

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 2
	jne	SHORT $LN56@CL_ParseQu
	mov	DWORD PTR tv170[ebp], OFFSET ??_C@_01EEMJAFIK@?6@
	jmp	SHORT $LN57@CL_ParseQu
$LN56@CL_ParseQu:
	mov	DWORD PTR tv170[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN57@CL_ParseQu:
	mov	edx, DWORD PTR tv170[ebp]
	push	edx
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 980  : 			break;

	jmp	$LN4@CL_ParseQu
$LN21@CL_ParseQu:

; 981  : 		case svc_stufftext:
; 982  : 			CL_QuakeStuffText( MSG_ReadString( msg ));

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_CL_QuakeStuffText
	add	esp, 4

; 983  : 			break;

	jmp	$LN4@CL_ParseQu
$LN22@CL_ParseQu:

; 984  : 		case svc_setangle:
; 985  : 			cl.viewangles[0] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+2212784], xmm0

; 986  : 			cl.viewangles[1] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cl[ecx+2212784], xmm0

; 987  : 			cl.viewangles[2] = MSG_ReadAngle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _cl[ecx+2212784], xmm0

; 988  : 			break;

	jmp	$LN4@CL_ParseQu
$LN23@CL_ParseQu:

; 989  : 		case svc_serverdata:
; 990  : 			Cbuf_Execute(); // make sure any stuffed commands are done

	call	_Cbuf_Execute

; 991  : 			CL_ParseQuakeServerInfo( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeServerInfo
	add	esp, 4

; 992  : 			break;

	jmp	$LN4@CL_ParseQu
$LN24@CL_ParseQu:

; 993  : 		case svc_lightstyle:
; 994  : 			param1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 995  : 			str = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 996  : 			CL_SetLightstyle( param1, str, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	eax, DWORD PTR _param1$[ebp]
	push	eax
	call	_CL_SetLightstyle
	add	esp, 12					; 0000000cH

; 997  : 			break;

	jmp	$LN4@CL_ParseQu
$LN25@CL_ParseQu:

; 998  : 		case svc_updatename:
; 999  : 			param1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1000 : 			Q_strncpy( cl.players[param1].name, MSG_ReadString( msg ), sizeof( cl.players[0].name ));

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	imul	ecx, DWORD PTR _param1$[ebp], 584
	add	ecx, OFFSET _cl+2185200
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1001 : 			Q_strncpy( cl.players[param1].model, "player", sizeof( cl.players[0].name ));

	push	32					; 00000020H
	push	OFFSET ??_C@_06BALNJMNP@player@
	imul	eax, DWORD PTR _param1$[ebp], 584
	add	eax, OFFSET _cl+2185244
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1002 : 			break;

	jmp	$LN4@CL_ParseQu
$LN26@CL_ParseQu:

; 1003 : 		case svc_updatefrags:
; 1004 : 			param1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1005 : 			param2 = MSG_ReadShort( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 1006 : 			// HACKHACK: store frags into spectator
; 1007 : 			cl.players[param1].spectator = param2;

	imul	eax, DWORD PTR _param1$[ebp], 584
	mov	ecx, DWORD PTR _param2$[ebp]
	mov	DWORD PTR _cl[eax+2185232], ecx

; 1008 : 			break;

	jmp	$LN4@CL_ParseQu
$LN27@CL_ParseQu:

; 1009 : 		case svc_clientdata:
; 1010 : 			CL_ParseQuakeClientData( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeClientData
	add	esp, 4

; 1011 : 			cl.frames[cl.parsecountmod].graphdata.client += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23856]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23856], cx

; 1012 : 			break;

	jmp	$LN4@CL_ParseQu
$LN28@CL_ParseQu:

; 1013 : 		case svc_stopsound:
; 1014 : 			param1 = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1015 : 			S_StopSound( param1 >> 3, param1 & 7, NULL );

	push	0
	mov	eax, DWORD PTR _param1$[ebp]
	and	eax, 7
	push	eax
	mov	ecx, DWORD PTR _param1$[ebp]
	sar	ecx, 3
	push	ecx
	call	_S_StopSound
	add	esp, 12					; 0000000cH

; 1016 : 			cl.frames[cl.parsecountmod].graphdata.sound += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23864]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23864], cx

; 1017 : 			break;

	jmp	$LN4@CL_ParseQu
$LN29@CL_ParseQu:

; 1018 : 		case svc_updatecolors:
; 1019 : 			param1 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param1$[ebp], eax

; 1020 : 			param2 = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _param2$[ebp], eax

; 1021 : 			cl.players[param1].topcolor = param2 & 0xF;

	mov	eax, DWORD PTR _param2$[ebp]
	and	eax, 15					; 0000000fH
	imul	ecx, DWORD PTR _param1$[ebp], 584
	mov	DWORD PTR _cl[ecx+2185308], eax

; 1022 : 			cl.players[param1].bottomcolor = (param2 & 0xF0) >> 4;

	mov	eax, DWORD PTR _param2$[ebp]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	imul	ecx, DWORD PTR _param1$[ebp], 584
	mov	DWORD PTR _cl[ecx+2185312], eax

; 1023 : 			break;

	jmp	$LN4@CL_ParseQu
$LN30@CL_ParseQu:

; 1024 : 		case svc_particle:
; 1025 : 			CL_ParseQuakeParticle( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeParticle
	add	esp, 4

; 1026 : 			break;

	jmp	$LN4@CL_ParseQu
$LN31@CL_ParseQu:

; 1027 : 		case svc_damage:
; 1028 : 			CL_ParseQuakeDamage( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeDamage
	add	esp, 4

; 1029 : 			break;

	jmp	$LN4@CL_ParseQu
$LN32@CL_ParseQu:

; 1030 : 		case svc_spawnstatic:
; 1031 : 			CL_ParseQuakeStaticEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeStaticEntity
	add	esp, 4

; 1032 : 			break;

	jmp	$LN4@CL_ParseQu
$LN33@CL_ParseQu:

; 1033 : 		case svc_spawnbinary:
; 1034 : 			// never used in Quake
; 1035 : 			break;

	jmp	$LN4@CL_ParseQu
$LN34@CL_ParseQu:

; 1036 : 		case svc_spawnbaseline:
; 1037 : 			CL_ParseQuakeBaseline( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeBaseline
	add	esp, 4

; 1038 : 			break;

	jmp	$LN4@CL_ParseQu
$LN35@CL_ParseQu:

; 1039 : 		case svc_temp_entity:
; 1040 : 			CL_ParseQuakeTempEntity( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeTempEntity
	add	esp, 4

; 1041 : 			cl.frames[cl.parsecountmod].graphdata.tentities += MSG_GetNumBytesRead( msg ) - bufStart;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	movzx	ecx, WORD PTR _cl[esi+23862]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23862], cx

; 1042 : 			break;

	jmp	$LN4@CL_ParseQu
$LN36@CL_ParseQu:

; 1043 : 		case svc_setpause:
; 1044 : 			cl.paused = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _cl+24, eax

; 1045 : 			break;

	jmp	$LN4@CL_ParseQu
$LN37@CL_ParseQu:

; 1046 : 		case svc_signonnum:
; 1047 : 			CL_ParseQuakeSignon( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeSignon
	add	esp, 4

; 1048 : 			break;

	jmp	$LN4@CL_ParseQu
$LN38@CL_ParseQu:

; 1049 : 		case svc_centerprint:
; 1050 : 			str = MSG_ReadString( msg );

	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	mov	DWORD PTR _str$[ebp], eax

; 1051 : 			CL_DispatchUserMessage( "HudText", Q_strlen( str ), (void *)str );

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_07JNEKKACO@HudText@
	call	_CL_DispatchUserMessage
	add	esp, 12					; 0000000cH

; 1052 : 			break;

	jmp	$LN4@CL_ParseQu
$LN39@CL_ParseQu:

; 1053 : 		case svc_killedmonster:
; 1054 : 			CL_DispatchQuakeMessage( "KillMonster" ); // just an event

	push	OFFSET ??_C@_0M@GLGMCOOM@KillMonster@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 1055 : 			break;

	jmp	$LN4@CL_ParseQu
$LN40@CL_ParseQu:

; 1056 : 		case svc_foundsecret:
; 1057 : 			CL_DispatchQuakeMessage( "FoundSecret" ); // just an event

	push	OFFSET ??_C@_0M@BINHEOKF@FoundSecret@
	call	_CL_DispatchQuakeMessage
	add	esp, 4

; 1058 : 			break;

	jmp	$LN4@CL_ParseQu
$LN41@CL_ParseQu:

; 1059 : 		case svc_spawnstaticsound:
; 1060 : 			CL_ParseQuakeStaticSound( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseQuakeStaticSound
	add	esp, 4

; 1061 : 			break;

	jmp	$LN4@CL_ParseQu
$LN42@CL_ParseQu:

; 1062 : 		case svc_intermission:
; 1063 : 			cl.intermission = 1;

	mov	DWORD PTR _cl+2212820, 1

; 1064 : 			break;

	jmp	$LN4@CL_ParseQu
$LN43@CL_ParseQu:

; 1065 : 		case svc_finale:
; 1066 : 			CL_ParseFinaleCutscene( msg, 2 );

	push	2
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 1067 : 			break;

	jmp	$LN4@CL_ParseQu
$LN44@CL_ParseQu:

; 1068 : 		case svc_cdtrack:
; 1069 : 			S_StartBackgroundTrack(MSG_ReadString(msg), MSG_ReadString(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), MSG_ReadLong(msg), true );

	push	1
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadLong
	add	esp, 4
	push	eax
	push	0
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	0
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	call	_S_StartBackgroundTrack
	add	esp, 28					; 0000001cH

; 1070 : 			break;

	jmp	$LN4@CL_ParseQu
$LN45@CL_ParseQu:

; 1071 : 		case svc_sellscreen:
; 1072 : 			Cmd_ExecuteString( "help" );	// open quake menu

	push	OFFSET ??_C@_04PCJFHION@help@
	call	_Cmd_ExecuteString
	add	esp, 4

; 1073 : 			break;

	jmp	$LN4@CL_ParseQu
$LN46@CL_ParseQu:

; 1074 : 		case svc_cutscene:
; 1075 : 			CL_ParseFinaleCutscene( msg, 3 );

	push	3
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseFinaleCutscene
	add	esp, 8

; 1076 : 			break;

	jmp	$LN4@CL_ParseQu
$LN47@CL_ParseQu:

; 1077 : 		case svc_hidelmp:
; 1078 : 			CL_ParseNehahraHideLMP( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseNehahraHideLMP
	add	esp, 4

; 1079 : 			break;

	jmp	$LN4@CL_ParseQu
$LN48@CL_ParseQu:

; 1080 : 		case svc_showlmp:
; 1081 : 			CL_ParseNehahraShowLMP( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_ParseNehahraShowLMP
	add	esp, 4

; 1082 : 			break;

	jmp	$LN4@CL_ParseQu
$LN49@CL_ParseQu:

; 1083 : 		case svc_skybox:
; 1084 : 			Q_strncpy( clgame.movevars.skyName, MSG_ReadString( msg ), sizeof( clgame.movevars.skyName ));

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadStringExt
	add	esp, 8
	push	eax
	push	OFFSET _clgame+1092
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1085 : 			break;

	jmp	$LN4@CL_ParseQu
$LN50@CL_ParseQu:

; 1086 : 		case svc_skyboxsize:
; 1087 : 			MSG_ReadCoord( msg ); // obsolete

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadCoord
	fstp	ST(0)
	add	esp, 4

; 1088 : 			break;

	jmp	$LN4@CL_ParseQu
$LN51@CL_ParseQu:

; 1089 : 		case svc_fog:
; 1090 : 			if( MSG_ReadByte( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	test	eax, eax
	je	$LN52@CL_ParseQu

; 1091 : 			{
; 1092 : 				float	fog_settings[4];
; 1093 : 				int	packed_fog[4];
; 1094 : 
; 1095 : 				fog_settings[3] = MSG_ReadFloat( msg );	// density

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadFloat
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 3
	fstp	DWORD PTR _fog_settings$2[ebp+edx]

; 1096 : 				fog_settings[0] = MSG_ReadByte( msg );	// red

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+edx], xmm0

; 1097 : 				fog_settings[1] = MSG_ReadByte( msg );	// green

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+ecx], xmm0

; 1098 : 				fog_settings[2] = MSG_ReadByte( msg );	// blue

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _fog_settings$2[ebp+ecx], xmm0

; 1099 : 				packed_fog[0] = fog_settings[0] * 255;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	imul	eax, edx, 0
	cvttss2si ecx, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+eax], ecx

; 1100 : 				packed_fog[1] = fog_settings[1] * 255;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+eax]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	shl	ecx, 0
	cvttss2si edx, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+ecx], edx

; 1101 : 				packed_fog[2] = fog_settings[2] * 255;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+eax]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, 4
	shl	ecx, 1
	cvttss2si edx, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+ecx], edx

; 1102 : 				packed_fog[3] = fog_settings[3] * 255;

	mov	eax, 4
	imul	ecx, eax, 3
	movss	xmm0, DWORD PTR _fog_settings$2[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@437f0000
	mov	edx, 4
	imul	eax, edx, 3
	cvttss2si ecx, xmm0
	mov	DWORD PTR _packed_fog$1[ebp+eax], ecx

; 1103 : 				clgame.movevars.fog_settings = (packed_fog[1]<<24)|(packed_fog[2]<<16)|(packed_fog[3]<<8)|packed_fog[0];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _packed_fog$1[ebp+eax]
	shl	ecx, 24					; 00000018H
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _packed_fog$1[ebp+edx]
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _packed_fog$1[ebp+eax]
	shl	edx, 8
	or	ecx, edx
	mov	eax, 4
	imul	edx, eax, 0
	or	ecx, DWORD PTR _packed_fog$1[ebp+edx]
	mov	DWORD PTR _clgame+1176, ecx

; 1104 : 			}

	jmp	SHORT $LN53@CL_ParseQu
$LN52@CL_ParseQu:

; 1105 : 			else
; 1106 : 			{
; 1107 : 				clgame.movevars.fog_settings = 0;

	mov	DWORD PTR _clgame+1176, 0
$LN53@CL_ParseQu:

; 1108 : 			}
; 1109 : 			break;

	jmp	SHORT $LN4@CL_ParseQu
$LN54@CL_ParseQu:

; 1110 : 		default:
; 1111 : 			Host_Error( "CL_ParseServerMessage: Illegible server message\n" );

	push	OFFSET ??_C@_0DB@FPIIIAAE@CL_ParseServerMessage?3?5Illegibl@
	call	_Host_Error
	add	esp, 4
$LN4@CL_ParseQu:

; 1112 : 			break;
; 1113 : 		}
; 1114 : 	}

	jmp	$LN8@CL_ParseQu
$LN3@CL_ParseQu:

; 1115 : 
; 1116 : 	cl.frames[cl.parsecountmod].graphdata.msgbytes += MSG_GetNumBytesRead( msg ) - cls.starting_count;

	imul	esi, DWORD PTR _cl+12, 24056
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _cls+290584
	movzx	ecx, WORD PTR _cl[esi+23870]
	add	ecx, eax
	imul	edx, DWORD PTR _cl+12, 24056
	mov	WORD PTR _cl[edx+23870], cx

; 1117 : 	CL_Parse_Debug( false ); // done

	push	0
	call	_CL_Parse_Debug
	add	esp, 4

; 1118 : 
; 1119 : 	// now process packet.
; 1120 : 	CL_ProcessPacket( &cl.frames[cl.parsecountmod] );

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_ProcessPacket
	add	esp, 4

; 1121 : 
; 1122 : 	// add new entities into physic lists
; 1123 : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 1124 : 
; 1125 : 	// check deferred cmds
; 1126 : 	CL_QuakeExecStuff();

	call	_CL_QuakeExecStuff
$LN1@CL_ParseQu:

; 1127 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN59@CL_ParseQu:
	DD	$LN12@CL_ParseQu
	DD	$LN13@CL_ParseQu
	DD	$LN14@CL_ParseQu
	DD	$LN15@CL_ParseQu
	DD	$LN17@CL_ParseQu
	DD	$LN18@CL_ParseQu
	DD	$LN19@CL_ParseQu
	DD	$LN20@CL_ParseQu
	DD	$LN21@CL_ParseQu
	DD	$LN22@CL_ParseQu
	DD	$LN23@CL_ParseQu
	DD	$LN24@CL_ParseQu
	DD	$LN25@CL_ParseQu
	DD	$LN26@CL_ParseQu
	DD	$LN27@CL_ParseQu
	DD	$LN28@CL_ParseQu
	DD	$LN29@CL_ParseQu
	DD	$LN30@CL_ParseQu
	DD	$LN31@CL_ParseQu
	DD	$LN32@CL_ParseQu
	DD	$LN33@CL_ParseQu
	DD	$LN34@CL_ParseQu
	DD	$LN35@CL_ParseQu
	DD	$LN36@CL_ParseQu
	DD	$LN37@CL_ParseQu
	DD	$LN38@CL_ParseQu
	DD	$LN39@CL_ParseQu
	DD	$LN40@CL_ParseQu
	DD	$LN41@CL_ParseQu
	DD	$LN42@CL_ParseQu
	DD	$LN43@CL_ParseQu
	DD	$LN44@CL_ParseQu
	DD	$LN45@CL_ParseQu
	DD	$LN46@CL_ParseQu
	DD	$LN48@CL_ParseQu
	DD	$LN47@CL_ParseQu
	DD	$LN49@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN54@CL_ParseQu
	DD	$LN50@CL_ParseQu
	DD	$LN51@CL_ParseQu
_CL_ParseQuakeMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 876  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jge	SHORT $LN2@CL_EDICT_N

; 877  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 878  : 
; 879  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 880  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBitsLeft
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBitsLeft PROC				; COMDAT

; 107  : _inline int MSG_GetNumBitsLeft( sizebuf_t *sb ) { return sb->nDataBits - sb->iCurBit; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBitsLeft ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
END
