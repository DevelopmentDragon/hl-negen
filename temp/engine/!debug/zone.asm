; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\zone.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_poolchain
PUBLIC	??_C@_0N@IOEJNPKC@?$DMcorrupted?$DO?$AA@	; `string'
_BSS	SEGMENT
_poolchain DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@IOEJNPKC@?$DMcorrupted?$DO?$AA@
CONST	SEGMENT
??_C@_0N@IOEJNPKC@?$DMcorrupted?$DO?$AA@ DB '<corrupted>', 00H, 00H ; `string'
CONST	ENDS
PUBLIC	_Memory_Init
PUBLIC	__Mem_Realloc
PUBLIC	__Mem_Alloc
PUBLIC	__Mem_AllocPool
PUBLIC	__Mem_FreePool
PUBLIC	__Mem_EmptyPool
PUBLIC	__Mem_Free
PUBLIC	__Mem_Check
PUBLIC	_Mem_IsAllocatedExt
PUBLIC	_Mem_PrintList
PUBLIC	_Mem_PrintStats
PUBLIC	_Mem_CheckAlloc
PUBLIC	_Mem_CheckHeaderSentinels
PUBLIC	??_C@_0CK@PJGHPDGO@Mem_Alloc?3?5pool?5?$DN?$DN?5NULL?5?$CIalloc?5@ ; `string'
PUBLIC	??_C@_0CL@IHPCDDLI@Mem_Alloc?3?5out?5of?5memory?5?$CIalloc@ ; `string'
PUBLIC	??_C@_0EF@GDBGGLLM@Mem_Free?3?5trashed?5header?5sentin@ ; `string'
PUBLIC	??_C@_0EF@OIMFFFKF@Mem_Free?3?5trashed?5header?5sentin@ ; `string'
PUBLIC	??_C@_0DJ@LEGECKLG@Mem_Free?3?5not?5allocated?5or?5doub@ ; `string'
PUBLIC	??_C@_0CK@OBBIBBEG@Mem_Free?3?5data?5?$DN?$DN?5NULL?5?$CIcalled?5@ ; `string'
PUBLIC	??_C@_0DD@PCKMJCCH@Mem_AllocPool?3?5out?5of?5memory?5?$CIa@ ; `string'
PUBLIC	??_C@_0DF@FCPLCOKN@Mem_FreePool?3?5pool?5already?5free@ ; `string'
PUBLIC	??_C@_0EP@JKKFAOOC@Mem_FreePool?3?5trashed?5pool?5sent@ ; `string'
PUBLIC	??_C@_0EP@FDJBBFOP@Mem_FreePool?3?5trashed?5pool?5sent@ ; `string'
PUBLIC	??_C@_0DC@KJFGJBDI@Mem_EmptyPool?3?5pool?5?$DN?$DN?5NULL?5?$CIem@ ; `string'
PUBLIC	??_C@_0FB@OKKCFNHL@Mem_EmptyPool?3?5trashed?5pool?5sen@ ; `string'
PUBLIC	??_C@_0FB@JENKBFNN@Mem_EmptyPool?3?5trashed?5pool?5sen@ ; `string'
PUBLIC	??_C@_0DM@OIOICHMA@Mem_CheckSentinels?3?5data?5?$DN?$DN?5NUL@ ; `string'
PUBLIC	??_C@_0GD@HOBAACBB@Mem_CheckSentinels?3?5trashed?5hea@ ; `string'
PUBLIC	??_C@_0GD@BIBENHCB@Mem_CheckSentinels?3?5trashed?5hea@ ; `string'
PUBLIC	??_C@_0GB@JLPDALOF@Mem_CheckSentinelsGlobal?3?5trash@ ; `string'
PUBLIC	??_C@_0GB@NBGKHMJB@Mem_CheckSentinelsGlobal?3?5trash@ ; `string'
PUBLIC	?__LINE__Var@?0??Mem_PrintStats@@9@9		; `Mem_PrintStats'::`1'::__LINE__Var
PUBLIC	??_C@_0DB@CODJEGED@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CH@JFFAGNDM@?$FO3?$CFlu?$FO7?5memory?5pools?0?5totalling@ ; `string'
PUBLIC	??_C@_0BM@IGHJKDDG@total?5allocated?5size?3?5?$FO1?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??Mem_PrintList@@9@9		; `Mem_PrintList'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@JCNDNIJL@memory?5pool?5list?3?6?5?5?$FO3size?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CH@GDHICOIO@?$CF10s?5?$CI?$CF10s?5actual?$CJ?5?$CFs?5?$CI?$FO7?$CFc?$CFs?5c@ ; `string'
PUBLIC	??_C@_0BF@DJCNNKMO@?$CF5s?5?$CI?$CF5s?5actual?$CJ?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BJ@CMOCNHOH@?$CF10s?5allocated?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_abs:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Con_Printf:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CMOCNHOH@?$CF10s?5allocated?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BJ@CMOCNHOH@?$CF10s?5allocated?5at?5?$CFs?3?$CFi?6@ DB '%10s alloc'
	DB	'ated at %s:%i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DJCNNKMO@?$CF5s?5?$CI?$CF5s?5actual?$CJ?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@DJCNNKMO@?$CF5s?5?$CI?$CF5s?5actual?$CJ?5?$CFs?6@ DB '%5s (%5s '
	DB	'actual) %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GDHICOIO@?$CF10s?5?$CI?$CF10s?5actual?$CJ?5?$CFs?5?$CI?$FO7?$CFc?$CFs?5c@
CONST	SEGMENT
??_C@_0CH@GDHICOIO@?$CF10s?5?$CI?$CF10s?5actual?$CJ?5?$CFs?5?$CI?$FO7?$CFc?$CFs?5c@ DB '%'
	DB	'10s (%10s actual) %s (^7%c%s change)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@JCNDNIJL@memory?5pool?5list?3?6?5?5?$FO3size?5?5?5?5?5@
CONST	SEGMENT
??_C@_0DK@JCNDNIJL@memory?5pool?5list?3?6?5?5?$FO3size?5?5?5?5?5@ DB 'mem'
	DB	'ory pool list:', 0aH, '  ^3size                          name'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mem_PrintList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mem_PrintList@@9@9 DD 013bH		; `Mem_PrintList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@IGHJKDDG@total?5allocated?5size?3?5?$FO1?$CFs?6@
CONST	SEGMENT
??_C@_0BM@IGHJKDDG@total?5allocated?5size?3?5?$FO1?$CFs?6@ DB 'total allo'
	DB	'cated size: ^1%s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JFFAGNDM@?$FO3?$CFlu?$FO7?5memory?5pools?0?5totalling@
CONST	SEGMENT
??_C@_0CH@JFFAGNDM@?$FO3?$CFlu?$FO7?5memory?5pools?0?5totalling@ DB '^3%l'
	DB	'u^7 memory pools, totalling: ^1%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CODJEGED@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DB@CODJEGED@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\zone.c', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mem_PrintStats@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mem_PrintStats@@9@9 DD 012aH		; `Mem_PrintStats'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GB@NBGKHMJB@Mem_CheckSentinelsGlobal?3?5trash@
CONST	SEGMENT
??_C@_0GB@NBGKHMJB@Mem_CheckSentinelsGlobal?3?5trash@ DB 'Mem_CheckSentin'
	DB	'elsGlobal: trashed pool sentinel 2 (allocpool at %s:%i, senti'
	DB	'nel check at %s:%i)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@JLPDALOF@Mem_CheckSentinelsGlobal?3?5trash@
CONST	SEGMENT
??_C@_0GB@JLPDALOF@Mem_CheckSentinelsGlobal?3?5trash@ DB 'Mem_CheckSentin'
	DB	'elsGlobal: trashed pool sentinel 1 (allocpool at %s:%i, senti'
	DB	'nel check at %s:%i)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@BIBENHCB@Mem_CheckSentinels?3?5trashed?5hea@
CONST	SEGMENT
??_C@_0GD@BIBENHCB@Mem_CheckSentinels?3?5trashed?5hea@ DB 'Mem_CheckSenti'
	DB	'nels: trashed header sentinel 2 (block allocated at %s:%i, se'
	DB	'ntinel check at %s:%i)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@HOBAACBB@Mem_CheckSentinels?3?5trashed?5hea@
CONST	SEGMENT
??_C@_0GD@HOBAACBB@Mem_CheckSentinels?3?5trashed?5hea@ DB 'Mem_CheckSenti'
	DB	'nels: trashed header sentinel 1 (block allocated at %s:%i, se'
	DB	'ntinel check at %s:%i)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@OIOICHMA@Mem_CheckSentinels?3?5data?5?$DN?$DN?5NUL@
CONST	SEGMENT
??_C@_0DM@OIOICHMA@Mem_CheckSentinels?3?5data?5?$DN?$DN?5NUL@ DB 'Mem_Che'
	DB	'ckSentinels: data == NULL (sentinel check at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@JENKBFNN@Mem_EmptyPool?3?5trashed?5pool?5sen@
CONST	SEGMENT
??_C@_0FB@JENKBFNN@Mem_EmptyPool?3?5trashed?5pool?5sen@ DB 'Mem_EmptyPool'
	DB	': trashed pool sentinel 2 (allocpool at %s:%i, emptypool at %'
	DB	's:%i)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@OKKCFNHL@Mem_EmptyPool?3?5trashed?5pool?5sen@
CONST	SEGMENT
??_C@_0FB@OKKCFNHL@Mem_EmptyPool?3?5trashed?5pool?5sen@ DB 'Mem_EmptyPool'
	DB	': trashed pool sentinel 1 (allocpool at %s:%i, emptypool at %'
	DB	's:%i)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KJFGJBDI@Mem_EmptyPool?3?5pool?5?$DN?$DN?5NULL?5?$CIem@
CONST	SEGMENT
??_C@_0DC@KJFGJBDI@Mem_EmptyPool?3?5pool?5?$DN?$DN?5NULL?5?$CIem@ DB 'Mem'
	DB	'_EmptyPool: pool == NULL (emptypool at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@FDJBBFOP@Mem_FreePool?3?5trashed?5pool?5sent@
CONST	SEGMENT
??_C@_0EP@FDJBBFOP@Mem_FreePool?3?5trashed?5pool?5sent@ DB 'Mem_FreePool:'
	DB	' trashed pool sentinel 2 (allocpool at %s:%i, freepool at %s:'
	DB	'%i)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@JKKFAOOC@Mem_FreePool?3?5trashed?5pool?5sent@
CONST	SEGMENT
??_C@_0EP@JKKFAOOC@Mem_FreePool?3?5trashed?5pool?5sent@ DB 'Mem_FreePool:'
	DB	' trashed pool sentinel 1 (allocpool at %s:%i, freepool at %s:'
	DB	'%i)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FCPLCOKN@Mem_FreePool?3?5pool?5already?5free@
CONST	SEGMENT
??_C@_0DF@FCPLCOKN@Mem_FreePool?3?5pool?5already?5free@ DB 'Mem_FreePool:'
	DB	' pool already free (freepool at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PCKMJCCH@Mem_AllocPool?3?5out?5of?5memory?5?$CIa@
CONST	SEGMENT
??_C@_0DD@PCKMJCCH@Mem_AllocPool?3?5out?5of?5memory?5?$CIa@ DB 'Mem_Alloc'
	DB	'Pool: out of memory (allocpool at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OBBIBBEG@Mem_Free?3?5data?5?$DN?$DN?5NULL?5?$CIcalled?5@
CONST	SEGMENT
??_C@_0CK@OBBIBBEG@Mem_Free?3?5data?5?$DN?$DN?5NULL?5?$CIcalled?5@ DB 'Me'
	DB	'm_Free: data == NULL (called at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LEGECKLG@Mem_Free?3?5not?5allocated?5or?5doub@
CONST	SEGMENT
??_C@_0DJ@LEGECKLG@Mem_Free?3?5not?5allocated?5or?5doub@ DB 'Mem_Free: no'
	DB	't allocated or double freed (free at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@OIMFFFKF@Mem_Free?3?5trashed?5header?5sentin@
CONST	SEGMENT
??_C@_0EF@OIMFFFKF@Mem_Free?3?5trashed?5header?5sentin@ DB 'Mem_Free: tra'
	DB	'shed header sentinel 2 (alloc at %s:%i, free at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GDBGGLLM@Mem_Free?3?5trashed?5header?5sentin@
CONST	SEGMENT
??_C@_0EF@GDBGGLLM@Mem_Free?3?5trashed?5header?5sentin@ DB 'Mem_Free: tra'
	DB	'shed header sentinel 1 (alloc at %s:%i, free at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?dummy@?1??Mem_CheckFilename@@9@9 DD FLAT:??_C@_0N@IOEJNPKC@?$DMcorrupted?$DO?$AA@ ; `Mem_CheckFilename'::`2'::dummy
_DATA	ENDS
;	COMDAT ??_C@_0CL@IHPCDDLI@Mem_Alloc?3?5out?5of?5memory?5?$CIalloc@
CONST	SEGMENT
??_C@_0CL@IHPCDDLI@Mem_Alloc?3?5out?5of?5memory?5?$CIalloc@ DB 'Mem_Alloc'
	DB	': out of memory (alloc at %s:%i)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PJGHPDGO@Mem_Alloc?3?5pool?5?$DN?$DN?5NULL?5?$CIalloc?5@
CONST	SEGMENT
??_C@_0CK@PJGHPDGO@Mem_Alloc?3?5pool?5?$DN?$DN?5NULL?5?$CIalloc?5@ DB 'Me'
	DB	'm_Alloc: pool == NULL (alloc at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_CheckHeaderSentinels
_TEXT	SEGMENT
_mem$ = -4						; size = 4
_data$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_Mem_CheckHeaderSentinels PROC				; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 259  : 	memheader_t *mem;
; 260  : 
; 261  : 	if( data == NULL )

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@Mem_CheckH

; 262  : 		Sys_Error( "Mem_CheckSentinels: data == NULL (sentinel check at %s:%i)\n", filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@OIOICHMA@Mem_CheckSentinels?3?5data?5?$DN?$DN?5NUL@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_CheckH:

; 263  : 
; 264  : 	mem = (memheader_t *)((byte *) data - sizeof(memheader_t));

	mov	eax, DWORD PTR _data$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _mem$[ebp], eax

; 265  : 
; 266  : 	if( mem->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+24], -559026163		; deadf00dH
	je	SHORT $LN3@Mem_CheckH

; 267  : 	{
; 268  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 269  : 		Sys_Error( "Mem_CheckSentinels: trashed header sentinel 1 (block allocated at %s:%i, sentinel check at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0GD@HOBAACBB@Mem_CheckSentinels?3?5trashed?5hea@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN3@Mem_CheckH:

; 270  : 	}
; 271  : 
; 272  : 	if( *((byte *) mem + sizeof(memheader_t) + mem->size) != MEMHEADER_SENTINEL2 )

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mem$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+28]
	cmp	eax, 223				; 000000dfH
	je	SHORT $LN1@Mem_CheckH

; 273  : 	{	
; 274  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 275  : 		Sys_Error( "Mem_CheckSentinels: trashed header sentinel 2 (block allocated at %s:%i, sentinel check at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0GD@BIBENHCB@Mem_CheckSentinels?3?5trashed?5hea@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN1@Mem_CheckH:

; 276  : 	}
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckHeaderSentinels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_CheckAlloc
_TEXT	SEGMENT
_target$ = -8						; size = 4
_header$ = -4						; size = 4
_pool$ = 8						; size = 4
_data$ = 12						; size = 4
_Mem_CheckAlloc PROC					; COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 225  : 	memheader_t *header, *target;
; 226  : 
; 227  : 	if( pool )

	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN8@Mem_CheckA

; 228  : 	{
; 229  : 		// search only one pool
; 230  : 		target = (memheader_t *)((byte *)data - sizeof( memheader_t ));

	mov	eax, DWORD PTR _data$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _target$[ebp], eax

; 231  : 		for( header = pool->chain; header; header = header->next )

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _header$[ebp], ecx
	jmp	SHORT $LN4@Mem_CheckA
$LN2@Mem_CheckA:
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _header$[ebp], ecx
$LN4@Mem_CheckA:
	cmp	DWORD PTR _header$[ebp], 0
	je	SHORT $LN3@Mem_CheckA

; 232  : 			if( header == target ) return true;

	mov	eax, DWORD PTR _header$[ebp]
	cmp	eax, DWORD PTR _target$[ebp]
	jne	SHORT $LN10@Mem_CheckA
	mov	eax, 1
	jmp	SHORT $LN1@Mem_CheckA
$LN10@Mem_CheckA:
	jmp	SHORT $LN2@Mem_CheckA
$LN3@Mem_CheckA:

; 233  : 	}

	jmp	SHORT $LN9@Mem_CheckA
$LN8@Mem_CheckA:

; 234  : 	else
; 235  : 	{
; 236  : 		// search all pools
; 237  : 		for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN7@Mem_CheckA
$LN5@Mem_CheckA:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN7@Mem_CheckA:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN9@Mem_CheckA

; 238  : 			if( Mem_CheckAlloc( pool, data ))

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	push	ecx
	call	_Mem_CheckAlloc
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@Mem_CheckA

; 239  : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@Mem_CheckA
$LN11@Mem_CheckA:
	jmp	SHORT $LN5@Mem_CheckA
$LN9@Mem_CheckA:

; 240  : 	}
; 241  : 	return false;

	xor	eax, eax
$LN1@Mem_CheckA:

; 242  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_FreeBlock
_TEXT	SEGMENT
tv132 = -80						; size = 4
tv135 = -76						; size = 4
tv133 = -72						; size = 4
_pool$ = -4						; size = 4
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_Mem_FreeBlock PROC					; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 102  : 	mempool_t		*pool;
; 103  : 
; 104  : 	if( mem->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+24], -559026163		; deadf00dH
	je	SHORT $LN2@Mem_FreeBl

; 105  : 	{
; 106  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 107  : 		Sys_Error( "Mem_Free: trashed header sentinel 1 (alloc at %s:%i, free at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0EF@GDBGGLLM@Mem_Free?3?5trashed?5header?5sentin@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN2@Mem_FreeBl:

; 108  : 	}
; 109  : 
; 110  : 	if( *((byte *)mem + sizeof( memheader_t ) + mem->size ) != MEMHEADER_SENTINEL2 )

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mem$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+28]
	cmp	eax, 223				; 000000dfH
	je	SHORT $LN3@Mem_FreeBl

; 111  : 	{	
; 112  : 		mem->filename = Mem_CheckFilename( mem->filename ); // make sure what we don't crash var_args

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_Mem_CheckFilename
	add	esp, 4
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [edx+16], eax

; 113  : 		Sys_Error( "Mem_Free: trashed header sentinel 2 (alloc at %s:%i, free at %s:%i)\n", mem->filename, mem->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	OFFSET ??_C@_0EF@OIMFFFKF@Mem_Free?3?5trashed?5header?5sentin@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN3@Mem_FreeBl:

; 114  : 	}
; 115  : 
; 116  : 	pool = mem->pool;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pool$[ebp], ecx

; 117  : 	// unlink memheader from doubly linked list
; 118  : 	if(( mem->prev ? mem->prev->next != mem : pool->chain != mem ) || ( mem->next && mem->next->prev != mem ))

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN14@Mem_FreeBl
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _mem$[ebp]
	je	SHORT $LN12@Mem_FreeBl
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN13@Mem_FreeBl
$LN12@Mem_FreeBl:
	mov	DWORD PTR tv133[ebp], 0
$LN13@Mem_FreeBl:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN15@Mem_FreeBl
$LN14@Mem_FreeBl:
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _mem$[ebp]
	je	SHORT $LN10@Mem_FreeBl
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN11@Mem_FreeBl
$LN10@Mem_FreeBl:
	mov	DWORD PTR tv132[ebp], 0
$LN11@Mem_FreeBl:
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv135[ebp], ecx
$LN15@Mem_FreeBl:
	cmp	DWORD PTR tv135[ebp], 0
	jne	SHORT $LN5@Mem_FreeBl
	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Mem_FreeBl
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _mem$[ebp]
	je	SHORT $LN4@Mem_FreeBl
$LN5@Mem_FreeBl:

; 119  : 		Sys_Error( "Mem_Free: not allocated or double freed (free at %s:%i)\n", filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DJ@LEGECKLG@Mem_Free?3?5not?5allocated?5or?5doub@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_FreeBl:

; 120  : 
; 121  : 	if( mem->prev ) mem->prev->next = mem->next;

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@Mem_FreeBl
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN7@Mem_FreeBl
$LN6@Mem_FreeBl:

; 122  : 	else pool->chain = mem->next;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx
$LN7@Mem_FreeBl:

; 123  : 
; 124  : 	if( mem->next )

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Mem_FreeBl

; 125  : 		mem->next->prev = mem->prev;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
$LN8@Mem_FreeBl:

; 126  : 
; 127  : 	// memheader has been unlinked, do the actual free now
; 128  : 	pool->totalsize -= mem->size;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+8], edx

; 129  : 
; 130  : 	pool->realsize -= sizeof( memheader_t ) + mem->size + sizeof( int );

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 131  : 	free( mem );

	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_FreeBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_CheckFilename
_TEXT	SEGMENT
_i$ = -8						; size = 4
_out$ = -4						; size = 4
_filename$ = 8						; size = 4
_Mem_CheckFilename PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 84   : 	static const char	*dummy = "<corrupted>\0";
; 85   : 	const char	*out = filename;

	mov	eax, DWORD PTR _filename$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 86   : 	int		i;
; 87   : 
; 88   : 	if( !COM_CheckString( out ))

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Mem_CheckF

; 89   : 		return dummy;

	mov	eax, DWORD PTR ?dummy@?1??Mem_CheckFilename@@9@9
	jmp	SHORT $LN1@Mem_CheckF
$LN5@Mem_CheckF:

; 90   : 
; 91   : 	for( i = 0; i < MAX_OSPATH; i++, out++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mem_CheckF
$LN2@Mem_CheckF:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
$LN4@Mem_CheckF:
	cmp	DWORD PTR _i$[ebp], 260			; 00000104H
	jge	SHORT $LN3@Mem_CheckF

; 92   : 	{
; 93   : 		if( *out == '\0' )

	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@Mem_CheckF

; 94   : 			return filename; // valid name

	mov	eax, DWORD PTR _filename$[ebp]
	jmp	SHORT $LN1@Mem_CheckF
$LN6@Mem_CheckF:

; 95   : 	}

	jmp	SHORT $LN2@Mem_CheckF
$LN3@Mem_CheckF:

; 96   : 
; 97   : 	return dummy;

	mov	eax, DWORD PTR ?dummy@?1??Mem_CheckFilename@@9@9
$LN1@Mem_CheckF:

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_CheckFilename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_PrintStats
_TEXT	SEGMENT
tv146 = -92						; size = 8
tv134 = -92						; size = 8
tv142 = -84						; size = 4
tv130 = -84						; size = 4
_pool$ = -16						; size = 4
_realsize$ = -12					; size = 4
_size$ = -8						; size = 4
_count$ = -4						; size = 4
_Mem_PrintStats PROC					; COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 299  : 	size_t	count = 0, size = 0, realsize = 0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _size$[ebp], 0
	mov	DWORD PTR _realsize$[ebp], 0

; 300  : 	mempool_t	*pool;
; 301  : 
; 302  : 	Mem_Check();

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mem_PrintStats@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DB@CODJEGED@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	__Mem_Check
	add	esp, 8

; 303  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_PrintS
$LN2@Mem_PrintS:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN4@Mem_PrintS:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@Mem_PrintS

; 304  : 	{
; 305  : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 306  : 		size += pool->totalsize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	add	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _size$[ebp], ecx

; 307  : 		realsize += pool->realsize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _realsize$[ebp]
	add	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _realsize$[ebp], ecx

; 308  : 	}

	jmp	SHORT $LN2@Mem_PrintS
$LN3@Mem_PrintS:

; 309  : 
; 310  : 	Con_Printf( "^3%lu^7 memory pools, totalling: ^1%s\n", (dword)count, Q_memprint( size ));

	push	2
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv130[ebp]
	mov	ecx, DWORD PTR tv130[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv134[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv134[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@JFFAGNDM@?$FO3?$CFlu?$FO7?5memory?5pools?0?5totalling@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 311  : 	Con_Printf( "total allocated size: ^1%s\n", Q_memprint( realsize ));

	push	2
	mov	eax, DWORD PTR _realsize$[ebp]
	mov	DWORD PTR tv142[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv142[ebp]
	mov	ecx, DWORD PTR tv142[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv146[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv146[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BM@IGHJKDDG@total?5allocated?5size?3?5?$FO1?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 312  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_PrintStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_PrintList
_TEXT	SEGMENT
tv221 = -104						; size = 8
tv196 = -104						; size = 8
tv217 = -96						; size = 4
tv192 = -96						; size = 4
tv242 = -92						; size = 8
tv209 = -92						; size = 8
tv184 = -92						; size = 8
tv238 = -84						; size = 4
tv205 = -84						; size = 4
tv180 = -84						; size = 4
tv75 = -84						; size = 4
_sign$1 = -13						; size = 1
_changed_size$2 = -12					; size = 4
_mem$ = -8						; size = 4
_pool$ = -4						; size = 4
_minallocationsize$ = 8					; size = 4
_Mem_PrintList PROC					; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 316  : 	mempool_t		*pool;
; 317  : 	memheader_t	*mem;
; 318  : 
; 319  : 	Mem_Check();

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mem_PrintList@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DB@CODJEGED@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	call	__Mem_Check
	add	esp, 8

; 320  : 
; 321  : 	Con_Printf( "memory pool list:\n""  ^3size                          name\n");

	push	OFFSET ??_C@_0DK@JCNDNIJL@memory?5pool?5list?3?6?5?5?$FO3size?5?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 322  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_PrintL
$LN2@Mem_PrintL:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN4@Mem_PrintL:
	cmp	DWORD PTR _pool$[ebp], 0
	je	$LN3@Mem_PrintL

; 323  : 	{
; 324  : 		long	changed_size = (long)pool->totalsize - (long)pool->lastchecksize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _changed_size$2[ebp], edx

; 325  : 
; 326  : 		// poolnames can contain color symbols, make sure what color is reset
; 327  : 		if( changed_size != 0 )

	je	$LN8@Mem_PrintL

; 328  : 		{
; 329  : 			char	sign = (changed_size < 0) ? '-' : '+';

	cmp	DWORD PTR _changed_size$2[ebp], 0
	jge	SHORT $LN12@Mem_PrintL
	mov	DWORD PTR tv75[ebp], 45			; 0000002dH
	jmp	SHORT $LN13@Mem_PrintL
$LN12@Mem_PrintL:
	mov	DWORD PTR tv75[ebp], 43			; 0000002bH
$LN13@Mem_PrintL:
	mov	al, BYTE PTR tv75[ebp]
	mov	BYTE PTR _sign$1[ebp], al

; 330  : 
; 331  : 			Con_Printf( "%10s (%10s actual) %s (^7%c%s change)\n", Q_memprint( pool->totalsize ), Q_memprint( pool->realsize ),

	push	2
	mov	eax, DWORD PTR _changed_size$2[ebp]
	push	eax
	call	_abs
	add	esp, 4
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	movsx	ecx, BYTE PTR _sign$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	push	2
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv180[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv180[ebp]
	mov	edx, DWORD PTR tv180[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv184[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv184[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv192[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv192[ebp]
	mov	edx, DWORD PTR tv192[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv196[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv196[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0CH@GDHICOIO@?$CF10s?5?$CI?$CF10s?5actual?$CJ?5?$CFs?5?$CI?$FO7?$CFc?$CFs?5c@
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 332  : 			pool->name, sign, Q_memprint( abs( changed_size )));
; 333  : 		}

	jmp	$LN9@Mem_PrintL
$LN8@Mem_PrintL:

; 334  : 		else
; 335  : 		{
; 336  : 			Con_Printf( "%5s (%5s actual) %s\n", Q_memprint( pool->totalsize ), Q_memprint( pool->realsize ), pool->name );

	mov	eax, DWORD PTR _pool$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	push	2
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv205[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv205[ebp]
	mov	eax, DWORD PTR tv205[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv209[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv209[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	2
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv217[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv217[ebp]
	mov	eax, DWORD PTR tv217[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv221[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv221[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BF@DJCNNKMO@?$CF5s?5?$CI?$CF5s?5actual?$CJ?5?$CFs?6@
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN9@Mem_PrintL:

; 337  : 		}
; 338  : 
; 339  : 		pool->lastchecksize = pool->totalsize;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx

; 340  : 		for( mem = pool->chain; mem; mem = mem->next )

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _mem$[ebp], ecx
	jmp	SHORT $LN7@Mem_PrintL
$LN5@Mem_PrintL:
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mem$[ebp], ecx
$LN7@Mem_PrintL:
	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN6@Mem_PrintL

; 341  : 			if( mem->size >= minallocationsize )

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _minallocationsize$[ebp]
	jb	SHORT $LN10@Mem_PrintL

; 342  : 				Con_Printf( "%10s allocated at %s:%i\n", Q_memprint( mem->size ), mem->filename, mem->fileline );

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	2
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv238[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv238[ebp]
	mov	eax, DWORD PTR tv238[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv242[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv242[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BJ@CMOCNHOH@?$CF10s?5allocated?5at?5?$CFs?3?$CFi?6@
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN10@Mem_PrintL:
	jmp	SHORT $LN5@Mem_PrintL
$LN6@Mem_PrintL:

; 343  : 	}

	jmp	$LN2@Mem_PrintL
$LN3@Mem_PrintL:

; 344  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_PrintList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Mem_IsAllocatedExt
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_data$ = 12						; size = 4
_Mem_IsAllocatedExt PROC				; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 251  : 	mempool_t	*pool = NULL;

	mov	DWORD PTR _pool$[ebp], 0

; 252  : 	if( poolptr ) pool = (mempool_t *)poolptr;

	cmp	DWORD PTR _poolptr$[ebp], 0
	je	SHORT $LN2@Mem_IsAllo
	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax
$LN2@Mem_IsAllo:

; 253  : 
; 254  : 	return Mem_CheckAlloc( pool, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	push	ecx
	call	_Mem_CheckAlloc
	add	esp, 8

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mem_IsAllocatedExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_Check
_TEXT	SEGMENT
_pool$ = -8						; size = 4
_mem$ = -4						; size = 4
_filename$ = 8						; size = 4
_fileline$ = 12						; size = 4
__Mem_Check PROC					; COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 281  : 	memheader_t	*mem;
; 282  : 	mempool_t		*pool;
; 283  : 
; 284  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN4@Mem_Check
$LN2@Mem_Check:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN4@Mem_Check:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN3@Mem_Check

; 285  : 	{
; 286  : 		if( pool->sentinel1 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax], -559026163		; deadf00dH
	je	SHORT $LN11@Mem_Check

; 287  : 			Sys_Error( "Mem_CheckSentinelsGlobal: trashed pool sentinel 1 (allocpool at %s:%i, sentinel check at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0GB@JLPDALOF@Mem_CheckSentinelsGlobal?3?5trash@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN11@Mem_Check:

; 288  : 		if( pool->sentinel2 != MEMHEADER_SENTINEL1 )

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+96], -559026163		; deadf00dH
	je	SHORT $LN12@Mem_Check

; 289  : 			Sys_Error( "Mem_CheckSentinelsGlobal: trashed pool sentinel 2 (allocpool at %s:%i, sentinel check at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0GB@NBGKHMJB@Mem_CheckSentinelsGlobal?3?5trash@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN12@Mem_Check:

; 290  : 	}

	jmp	SHORT $LN2@Mem_Check
$LN3@Mem_Check:

; 291  : 
; 292  : 	for( pool = poolchain; pool; pool = pool->next )

	mov	eax, DWORD PTR _poolchain
	mov	DWORD PTR _pool$[ebp], eax
	jmp	SHORT $LN7@Mem_Check
$LN5@Mem_Check:
	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pool$[ebp], ecx
$LN7@Mem_Check:
	cmp	DWORD PTR _pool$[ebp], 0
	je	SHORT $LN1@Mem_Check

; 293  : 		for( mem = pool->chain; mem; mem = mem->next )

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _mem$[ebp], ecx
	jmp	SHORT $LN10@Mem_Check
$LN8@Mem_Check:
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _mem$[ebp], ecx
$LN10@Mem_Check:
	cmp	DWORD PTR _mem$[ebp], 0
	je	SHORT $LN9@Mem_Check

; 294  : 			Mem_CheckHeaderSentinels((void *)((byte *) mem + sizeof(memheader_t)), filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	_Mem_CheckHeaderSentinels
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@Mem_Check
$LN9@Mem_Check:
	jmp	SHORT $LN5@Mem_Check
$LN1@Mem_Check:

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_Free
_TEXT	SEGMENT
_data$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_Free PROC						; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 136  : 	if( data == NULL ) Sys_Error( "Mem_Free: data == NULL (called at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@Mem_Free
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CK@OBBIBBEG@Mem_Free?3?5data?5?$DN?$DN?5NULL?5?$CIcalled?5@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_Free:

; 137  : 	Mem_FreeBlock((memheader_t *)((byte *)data - sizeof( memheader_t )), filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	sub	edx, 28					; 0000001cH
	push	edx
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH

; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_EmptyPool
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_EmptyPool PROC					; COMDAT

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 213  : 	mempool_t *pool = (mempool_t *)poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax

; 214  : 	if( poolptr == NULL ) Sys_Error( "Mem_EmptyPool: pool == NULL (emptypool at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _poolptr$[ebp], 0
	jne	SHORT $LN4@Mem_EmptyP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DC@KJFGJBDI@Mem_EmptyPool?3?5pool?5?$DN?$DN?5NULL?5?$CIem@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_EmptyP:

; 215  : 
; 216  : 	if( pool->sentinel1 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_EmptyPool: trashed pool sentinel 1 (allocpool at %s:%i, emptypool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax], -559026163		; deadf00dH
	je	SHORT $LN5@Mem_EmptyP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0FB@OKKCFNHL@Mem_EmptyPool?3?5trashed?5pool?5sen@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN5@Mem_EmptyP:

; 217  : 	if( pool->sentinel2 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_EmptyPool: trashed pool sentinel 2 (allocpool at %s:%i, emptypool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+96], -559026163		; deadf00dH
	je	SHORT $LN2@Mem_EmptyP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0FB@JENKBFNN@Mem_EmptyPool?3?5trashed?5pool?5sen@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN2@Mem_EmptyP:

; 218  : 
; 219  : 	// free memory owned by the pool
; 220  : 	while( pool->chain ) Mem_FreeBlock( pool->chain, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Mem_EmptyP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Mem_EmptyP
$LN1@Mem_EmptyP:

; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_EmptyPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_FreePool
_TEXT	SEGMENT
_chainaddress$ = -8					; size = 4
_pool$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_FreePool PROC					; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 190  : 	mempool_t	*pool = (mempool_t *)*poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pool$[ebp], ecx

; 191  : 	mempool_t	**chainaddress;
; 192  :           
; 193  : 	if( pool )

	cmp	DWORD PTR _pool$[ebp], 0
	je	$LN1@Mem_FreePo

; 194  : 	{
; 195  : 		// unlink pool from chain
; 196  : 		for( chainaddress = &poolchain; *chainaddress && *chainaddress != pool; chainaddress = &((*chainaddress)->next));

	mov	DWORD PTR _chainaddress$[ebp], OFFSET _poolchain
	jmp	SHORT $LN4@Mem_FreePo
$LN2@Mem_FreePo:
	mov	eax, DWORD PTR _chainaddress$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _chainaddress$[ebp], ecx
$LN4@Mem_FreePo:
	mov	eax, DWORD PTR _chainaddress$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Mem_FreePo
	mov	eax, DWORD PTR _chainaddress$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pool$[ebp]
	je	SHORT $LN3@Mem_FreePo
	jmp	SHORT $LN2@Mem_FreePo
$LN3@Mem_FreePo:

; 197  : 		if( *chainaddress != pool ) Sys_Error( "Mem_FreePool: pool already free (freepool at %s:%i)\n", filename, fileline );

	mov	eax, DWORD PTR _chainaddress$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pool$[ebp]
	je	SHORT $LN8@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@FCPLCOKN@Mem_FreePool?3?5pool?5already?5free@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN8@Mem_FreePo:

; 198  : 		if( pool->sentinel1 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_FreePool: trashed pool sentinel 1 (allocpool at %s:%i, freepool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax], -559026163		; deadf00dH
	je	SHORT $LN9@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0EP@JKKFAOOC@Mem_FreePool?3?5trashed?5pool?5sent@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN9@Mem_FreePo:

; 199  : 		if( pool->sentinel2 != MEMHEADER_SENTINEL1 ) Sys_Error( "Mem_FreePool: trashed pool sentinel 2 (allocpool at %s:%i, freepool at %s:%i)\n", pool->filename, pool->fileline, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+96], -559026163		; deadf00dH
	je	SHORT $LN10@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0EP@FDJBBFOP@Mem_FreePool?3?5trashed?5pool?5sent@
	call	_Sys_Error
	add	esp, 20					; 00000014H
$LN10@Mem_FreePo:

; 200  : 		*chainaddress = pool->next;

	mov	eax, DWORD PTR _chainaddress$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], edx
$LN5@Mem_FreePo:

; 201  : 
; 202  : 		// free memory owned by the pool
; 203  : 		while( pool->chain ) Mem_FreeBlock( pool->chain, filename, fileline );

	mov	eax, DWORD PTR _pool$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN6@Mem_FreePo
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_Mem_FreeBlock
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@Mem_FreePo
$LN6@Mem_FreePo:

; 204  : 		// free the pool itself
; 205  : 		memset( pool, 0xBF, sizeof( mempool_t ));

	push	100					; 00000064H
	push	191					; 000000bfH
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 206  : 		free( pool );

	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 207  : 		*poolptr = NULL;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Mem_FreePo:

; 208  : 	}
; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_FreePool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_AllocPool
_TEXT	SEGMENT
_pool$ = -4						; size = 4
_name$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
__Mem_AllocPool PROC					; COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 167  : 	mempool_t *pool;
; 168  : 
; 169  : 	pool = (mempool_t *)malloc( sizeof( mempool_t ));

	push	100					; 00000064H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pool$[ebp], eax

; 170  : 	if( pool == NULL ) Sys_Error( "Mem_AllocPool: out of memory (allocpool at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _pool$[ebp], 0
	jne	SHORT $LN2@Mem_AllocP
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@PCKMJCCH@Mem_AllocPool?3?5out?5of?5memory?5?$CIa@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@Mem_AllocP:

; 171  : 	memset( pool, 0, sizeof( mempool_t ));

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 172  : 
; 173  : 	// fill header
; 174  : 	pool->sentinel1 = MEMHEADER_SENTINEL1;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax], -559026163		; deadf00dH

; 175  : 	pool->sentinel2 = MEMHEADER_SENTINEL1;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+96], -559026163		; deadf00dH

; 176  : 	pool->filename = filename;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 177  : 	pool->fileline = fileline;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _fileline$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 178  : 	pool->chain = NULL;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+4], 0

; 179  : 	pool->totalsize = 0;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+8], 0

; 180  : 	pool->realsize = sizeof( mempool_t );

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+12], 100			; 00000064H

; 181  : 	Q_strncpy( pool->name, name, sizeof( pool->name ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 182  : 	pool->next = poolchain;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _poolchain
	mov	DWORD PTR [eax+20], ecx

; 183  : 	poolchain = pool;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR _poolchain, eax

; 184  : 
; 185  : 	return (byte *)pool;

	mov	eax, DWORD PTR _pool$[ebp]

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_AllocPool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_Alloc
_TEXT	SEGMENT
_pool$ = -8						; size = 4
_mem$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_size$ = 12						; size = 4
_clear$ = 16						; size = 4
_filename$ = 20						; size = 4
_fileline$ = 24						; size = 4
__Mem_Alloc PROC					; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 52   : 	memheader_t	*mem;
; 53   : 	mempool_t		*pool = (mempool_t *)poolptr;

	mov	eax, DWORD PTR _poolptr$[ebp]
	mov	DWORD PTR _pool$[ebp], eax

; 54   : 
; 55   : 	if( size <= 0 ) return NULL;

	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN2@Mem_Alloc
	xor	eax, eax
	jmp	$LN1@Mem_Alloc
$LN2@Mem_Alloc:

; 56   : 	if( poolptr == NULL ) Sys_Error( "Mem_Alloc: pool == NULL (alloc at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _poolptr$[ebp], 0
	jne	SHORT $LN3@Mem_Alloc
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CK@PJGHPDGO@Mem_Alloc?3?5pool?5?$DN?$DN?5NULL?5?$CIalloc?5@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN3@Mem_Alloc:

; 57   : 	pool->totalsize += size;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 58   : 
; 59   : 	// big allocations are not clumped
; 60   : 	pool->realsize += sizeof( memheader_t ) + size + sizeof( int );

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+ecx+32]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 61   : 	mem = (memheader_t *)malloc( sizeof( memheader_t ) + size + sizeof( int ));

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _mem$[ebp], eax

; 62   : 	if( mem == NULL ) Sys_Error( "Mem_Alloc: out of memory (alloc at %s:%i)\n", filename, fileline );

	cmp	DWORD PTR _mem$[ebp], 0
	jne	SHORT $LN4@Mem_Alloc
	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@IHPCDDLI@Mem_Alloc?3?5out?5of?5memory?5?$CIalloc@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@Mem_Alloc:

; 63   : 
; 64   : 	mem->filename = filename;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _filename$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 65   : 	mem->fileline = fileline;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _fileline$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 66   : 	mem->size = size;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 67   : 	mem->pool = pool;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 68   : 	mem->sentinel1 = MEMHEADER_SENTINEL1;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax+24], -559026163		; deadf00dH

; 69   : 	// we have to use only a single byte for this sentinel, because it may not be aligned
; 70   : 	// and some platforms can't use unaligned accesses
; 71   : 	*((byte *)mem + sizeof( memheader_t ) + mem->size ) = MEMHEADER_SENTINEL2;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _mem$[ebp]
	mov	BYTE PTR [edx+ecx+28], 223		; 000000dfH

; 72   : 	// append to head of list
; 73   : 	mem->next = pool->chain;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 74   : 	mem->prev = NULL;

	mov	eax, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax+4], 0

; 75   : 	pool->chain = mem;

	mov	eax, DWORD PTR _pool$[ebp]
	mov	ecx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 76   : 	if( mem->next ) mem->next->prev = mem;

	mov	eax, DWORD PTR _mem$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Mem_Alloc
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _mem$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN5@Mem_Alloc:

; 77   : 	if( clear ) memset((void *)((byte *)mem + sizeof( memheader_t )), 0, mem->size );

	cmp	DWORD PTR _clear$[ebp], 0
	je	SHORT $LN6@Mem_Alloc
	mov	eax, DWORD PTR _mem$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	0
	mov	edx, DWORD PTR _mem$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@Mem_Alloc:

; 78   : 
; 79   : 	return (void *)((byte *)mem + sizeof( memheader_t ));

	mov	eax, DWORD PTR _mem$[ebp]
	add	eax, 28					; 0000001cH
$LN1@Mem_Alloc:

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT __Mem_Realloc
_TEXT	SEGMENT
tv79 = -80						; size = 4
_newsize$1 = -12					; size = 4
_nb$ = -8						; size = 4
_memhdr$ = -4						; size = 4
_poolptr$ = 8						; size = 4
_memptr$ = 12						; size = 4
_size$ = 16						; size = 4
_clear$ = 20						; size = 4
_filename$ = 24						; size = 4
_fileline$ = 28						; size = 4
__Mem_Realloc PROC					; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 142  : 	memheader_t	*memhdr = NULL;

	mov	DWORD PTR _memhdr$[ebp], 0

; 143  : 	char		*nb;
; 144  : 
; 145  : 	if( size <= 0 ) return memptr; // no need to reallocate

	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN2@Mem_Reallo
	mov	eax, DWORD PTR _memptr$[ebp]
	jmp	$LN1@Mem_Reallo
$LN2@Mem_Reallo:

; 146  : 
; 147  : 	if( memptr )

	cmp	DWORD PTR _memptr$[ebp], 0
	je	SHORT $LN3@Mem_Reallo

; 148  : 	{
; 149  : 		memhdr = (memheader_t *)((byte *)memptr - sizeof( memheader_t ));

	mov	eax, DWORD PTR _memptr$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _memhdr$[ebp], eax

; 150  : 		if( size == memhdr->size ) return memptr;

	mov	eax, DWORD PTR _memhdr$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN3@Mem_Reallo
	mov	eax, DWORD PTR _memptr$[ebp]
	jmp	SHORT $LN1@Mem_Reallo
$LN3@Mem_Reallo:

; 151  : 	}
; 152  : 
; 153  : 	nb = _Mem_Alloc( poolptr, size, clear, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clear$[ebp]
	push	edx
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poolptr$[ebp]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _nb$[ebp], eax

; 154  : 
; 155  : 	if( memptr ) // first allocate?

	cmp	DWORD PTR _memptr$[ebp], 0
	je	SHORT $LN5@Mem_Reallo

; 156  : 	{ 
; 157  : 		size_t newsize = memhdr->size < size ? memhdr->size : size; // upper data can be trucnated!

	mov	eax, DWORD PTR _memhdr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN7@Mem_Reallo
	mov	edx, DWORD PTR _memhdr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN8@Mem_Reallo
$LN7@Mem_Reallo:
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv79[ebp], ecx
$LN8@Mem_Reallo:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _newsize$1[ebp], edx

; 158  : 		memcpy( nb, memptr, newsize );

	mov	eax, DWORD PTR _newsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _memptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nb$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 159  : 		_Mem_Free( memptr, filename, fileline ); // free unused old block

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _memptr$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@Mem_Reallo:

; 160  :           }
; 161  : 
; 162  : 	return (void *)nb;

	mov	eax, DWORD PTR _nb$[ebp]
$LN1@Mem_Reallo:

; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__Mem_Realloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\zone.c
;	COMDAT _Memory_Init
_TEXT	SEGMENT
_Memory_Init PROC					; COMDAT

; 352  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 353  : 	poolchain = NULL; // init mem chain

	mov	DWORD PTR _poolchain, 0

; 354  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Memory_Init ENDP
_TEXT	ENDS
END
