; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\img_quant.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_alphadec:DWORD
_DATA	ENDS
PUBLIC	_Image_Quantize
PUBLIC	_initnet
PUBLIC	_unbiasnet
PUBLIC	_inxbuild
PUBLIC	_inxsearch
PUBLIC	_contest
PUBLIC	_altersingle
PUBLIC	_alterneigh
PUBLIC	_learn
PUBLIC	?__LINE__Var@?0??Image_Quantize@@9@9		; `Image_Quantize'::`1'::__LINE__Var
PUBLIC	??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Image_CopyParms:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_image:BYTE
_BSS	SEGMENT
_thepicture DD	01H DUP (?)
_lengthcount DD	01H DUP (?)
_samplefac DD	01H DUP (?)
_network DD	0400H DUP (?)
_netindex DD	0100H DUP (?)
_bias	DD	0100H DUP (?)
_freq	DD	0100H DUP (?)
_radpower DD	020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\imagelib\img_quant.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Image_Quantize@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Image_Quantize@@9@9 DD 01aeH		; `Image_Quantize'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _learn
_TEXT	SEGMENT
_lim$ = -52						; size = 4
_samplepixels$ = -48					; size = 4
_delta$ = -44						; size = 4
_step$ = -40						; size = 4
_alpha$ = -36						; size = 4
_rad$ = -32						; size = 4
_radius$ = -28						; size = 4
_b$ = -24						; size = 4
_g$ = -20						; size = 4
_r$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_p$ = -4						; size = 4
_learn	PROC						; COMDAT

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 359  : 	register byte	*p;
; 360  : 	register int	i, j, r, g, b;
; 361  : 	int		radius, rad, alpha, step;
; 362  : 	int		delta, samplepixels;
; 363  : 	byte		*lim;
; 364  : 
; 365  : 	alphadec = 30 + ((samplefac - 1) / 3);

	mov	eax, DWORD PTR _samplefac
	sub	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _alphadec, eax

; 366  : 	p = thepicture;

	mov	eax, DWORD PTR _thepicture
	mov	DWORD PTR _p$[ebp], eax

; 367  : 	lim = thepicture + lengthcount;

	mov	eax, DWORD PTR _thepicture
	add	eax, DWORD PTR _lengthcount
	mov	DWORD PTR _lim$[ebp], eax

; 368  : 	samplepixels = lengthcount / (image.bpp * samplefac);

	mov	ecx, DWORD PTR _image+36
	imul	ecx, DWORD PTR _samplefac
	mov	eax, DWORD PTR _lengthcount
	cdq
	idiv	ecx
	mov	DWORD PTR _samplepixels$[ebp], eax

; 369  : 	delta = samplepixels / ncycles;

	mov	eax, DWORD PTR _samplepixels$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _delta$[ebp], eax

; 370  : 	alpha = initalpha;

	mov	DWORD PTR _alpha$[ebp], 1024		; 00000400H

; 371  : 	radius = initradius;

	mov	DWORD PTR _radius$[ebp], 2048		; 00000800H

; 372  : 	
; 373  : 	rad = radius >> radiusbiasshift;

	mov	eax, DWORD PTR _radius$[ebp]
	sar	eax, 6
	mov	DWORD PTR _rad$[ebp], eax

; 374  : 	if( rad <= 1 ) rad = 0;

	cmp	DWORD PTR _rad$[ebp], 1
	jg	SHORT $LN10@learn
	mov	DWORD PTR _rad$[ebp], 0
$LN10@learn:

; 375  : 
; 376  : 	for( i = 0; i < rad; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@learn
$LN2@learn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@learn:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _rad$[ebp]
	jge	SHORT $LN3@learn

; 377  : 		radpower[i] = alpha * ((( rad * rad - i * i ) * radbias ) / ( rad * rad ));	

	mov	eax, DWORD PTR _rad$[ebp]
	imul	eax, DWORD PTR _rad$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _i$[ebp]
	sub	eax, ecx
	shl	eax, 8
	mov	ecx, DWORD PTR _rad$[ebp]
	imul	ecx, DWORD PTR _rad$[ebp]
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _alpha$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _radpower[edx*4], eax
	jmp	SHORT $LN2@learn
$LN3@learn:

; 378  : 
; 379  : 	if( delta <= 0 ) return;

	cmp	DWORD PTR _delta$[ebp], 0
	jg	SHORT $LN11@learn
	jmp	$LN1@learn
$LN11@learn:

; 380  : 
; 381  : 	if(( lengthcount % prime1 ) != 0 )

	mov	eax, DWORD PTR _lengthcount
	cdq
	mov	ecx, 499				; 000001f3H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN12@learn

; 382  : 	{
; 383  : 		step = prime1 * image.bpp;

	imul	eax, DWORD PTR _image+36, 499
	mov	DWORD PTR _step$[ebp], eax

; 384  : 	}

	jmp	SHORT $LN13@learn
$LN12@learn:

; 385  : 	else if(( lengthcount % prime2 ) != 0 )

	mov	eax, DWORD PTR _lengthcount
	cdq
	mov	ecx, 491				; 000001ebH
	idiv	ecx
	test	edx, edx
	je	SHORT $LN14@learn

; 386  : 	{
; 387  : 		step = prime2 * image.bpp;

	imul	eax, DWORD PTR _image+36, 491
	mov	DWORD PTR _step$[ebp], eax

; 388  : 	}

	jmp	SHORT $LN13@learn
$LN14@learn:

; 389  : 	else if(( lengthcount % prime3 ) != 0 )

	mov	eax, DWORD PTR _lengthcount
	cdq
	mov	ecx, 487				; 000001e7H
	idiv	ecx
	test	edx, edx
	je	SHORT $LN16@learn

; 390  : 	{
; 391  : 		step = prime3 * image.bpp;

	imul	eax, DWORD PTR _image+36, 487
	mov	DWORD PTR _step$[ebp], eax

; 392  : 	}

	jmp	SHORT $LN13@learn
$LN16@learn:

; 393  : 	else
; 394  : 	{
; 395  : 		step = prime4 * image.bpp;

	imul	eax, DWORD PTR _image+36, 503
	mov	DWORD PTR _step$[ebp], eax
$LN13@learn:

; 396  : 	}
; 397  : 	
; 398  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN5@learn:

; 399  : 
; 400  : 	while( i < samplepixels )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _samplepixels$[ebp]
	jge	$LN1@learn

; 401  : 	{
; 402  : 		r = p[0] << netbiasshift;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	shl	eax, 4
	mov	DWORD PTR _r$[ebp], eax

; 403  : 		g = p[1] << netbiasshift;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	shl	edx, 4
	mov	DWORD PTR _g$[ebp], edx

; 404  : 		b = p[2] << netbiasshift;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	shl	edx, 4
	mov	DWORD PTR _b$[ebp], edx

; 405  : 		j = contest( r, g, b );

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	call	_contest
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _j$[ebp], eax

; 406  : 
; 407  : 		altersingle( alpha, j, r, g, b );

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _alpha$[ebp]
	push	ecx
	call	_altersingle
	add	esp, 20					; 00000014H

; 408  : 		if( rad ) alterneigh( rad, j, r, g, b );   // alter neighbours

	cmp	DWORD PTR _rad$[ebp], 0
	je	SHORT $LN18@learn
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g$[ebp]
	push	ecx
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rad$[ebp]
	push	ecx
	call	_alterneigh
	add	esp, 20					; 00000014H
$LN18@learn:

; 409  : 
; 410  : 		p += step;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 411  : 		if( p >= lim ) p -= lengthcount;

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _lim$[ebp]
	jb	SHORT $LN19@learn
	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _lengthcount
	mov	DWORD PTR _p$[ebp], eax
$LN19@learn:

; 412  : 	
; 413  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 414  : 
; 415  : 		if( i % delta == 0 )

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _delta$[ebp]
	test	edx, edx
	jne	$LN20@learn

; 416  : 		{	
; 417  : 			alpha -= alpha / alphadec;

	mov	eax, DWORD PTR _alpha$[ebp]
	cdq
	idiv	DWORD PTR _alphadec
	mov	ecx, DWORD PTR _alpha$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _alpha$[ebp], ecx

; 418  : 			radius -= radius / radiusdec;

	mov	eax, DWORD PTR _radius$[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, DWORD PTR _radius$[ebp]
	sub	edx, eax
	mov	DWORD PTR _radius$[ebp], edx

; 419  : 			rad = radius >> radiusbiasshift;

	mov	eax, DWORD PTR _radius$[ebp]
	sar	eax, 6
	mov	DWORD PTR _rad$[ebp], eax

; 420  : 			if( rad <= 1 ) rad = 0;

	cmp	DWORD PTR _rad$[ebp], 1
	jg	SHORT $LN21@learn
	mov	DWORD PTR _rad$[ebp], 0
$LN21@learn:

; 421  : 
; 422  : 			for( j = 0; j < rad; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@learn
$LN7@learn:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@learn:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _rad$[ebp]
	jge	SHORT $LN20@learn

; 423  : 				radpower[j] = alpha * ((( rad * rad - j * j ) * radbias ) / ( rad * rad ));

	mov	eax, DWORD PTR _rad$[ebp]
	imul	eax, DWORD PTR _rad$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, DWORD PTR _j$[ebp]
	sub	eax, ecx
	shl	eax, 8
	mov	ecx, DWORD PTR _rad$[ebp]
	imul	ecx, DWORD PTR _rad$[ebp]
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _alpha$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _radpower[edx*4], eax
	jmp	SHORT $LN7@learn
$LN20@learn:

; 424  : 		}
; 425  : 	}

	jmp	$LN5@learn
$LN1@learn:

; 426  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_learn	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _alterneigh
_TEXT	SEGMENT
_q$ = -28						; size = 4
_p$ = -24						; size = 4
_a$ = -20						; size = 4
_hi$ = -16						; size = 4
_lo$ = -12						; size = 4
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_rad$ = 8						; size = 4
_i$ = 12						; size = 4
_r$ = 16						; size = 4
_g$ = 20						; size = 4
_b$ = 24						; size = 4
_alterneigh PROC					; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 316  : 	register int	j, k, lo, hi, a;
; 317  : 	register int	*p, *q;
; 318  : 
; 319  : 	lo = i - rad;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _rad$[ebp]
	mov	DWORD PTR _lo$[ebp], eax

; 320  : 	if( lo < -1 ) lo = -1;

	cmp	DWORD PTR _lo$[ebp], -1
	jge	SHORT $LN4@alterneigh
	mov	DWORD PTR _lo$[ebp], -1
$LN4@alterneigh:

; 321  : 	hi = i + rad;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _rad$[ebp]
	mov	DWORD PTR _hi$[ebp], eax

; 322  : 	if( hi > netsize ) hi = netsize;

	cmp	DWORD PTR _hi$[ebp], 256		; 00000100H
	jle	SHORT $LN5@alterneigh
	mov	DWORD PTR _hi$[ebp], 256		; 00000100H
$LN5@alterneigh:

; 323  : 
; 324  : 	j = i + 1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 325  : 	k = i - 1;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 326  : 	q = radpower;

	mov	DWORD PTR _q$[ebp], OFFSET _radpower
$LN2@alterneigh:

; 327  : 
; 328  : 	while(( j < hi ) || ( k > lo ))

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hi$[ebp]
	jl	SHORT $LN6@alterneigh
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lo$[ebp]
	jle	$LN1@alterneigh
$LN6@alterneigh:

; 329  : 	{
; 330  : 		a = (*(++q));

	mov	eax, DWORD PTR _q$[ebp]
	add	eax, 4
	mov	DWORD PTR _q$[ebp], eax
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _a$[ebp], edx

; 331  : 
; 332  : 		if( j < hi )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _hi$[ebp]
	jge	$LN7@alterneigh

; 333  : 		{
; 334  : 			p = network[j];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 335  : 			*p -= (a * (*p - r)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _r$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 336  : 			p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 337  : 			*p -= (a * (*p - g)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _g$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 338  : 			p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 339  : 			*p -= (a * (*p - b)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _b$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 340  : 			j++;

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@alterneigh:

; 341  : 		}
; 342  : 
; 343  : 		if( k > lo )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lo$[ebp]
	jle	$LN8@alterneigh

; 344  : 		{
; 345  : 			p = network[k];

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 346  : 			*p -= (a * (*p - r)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _r$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 347  : 			p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 348  : 			*p -= (a * (*p - g)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _g$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 349  : 			p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 350  : 			*p -= (a * (*p - b)) / alpharadbias;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _b$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _a$[ebp]
	cdq
	and	edx, 262143				; 0003ffffH
	add	eax, edx
	sar	eax, 18					; 00000012H
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx

; 351  : 			k--;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN8@alterneigh:

; 352  : 		}
; 353  : 	}

	jmp	$LN2@alterneigh
$LN1@alterneigh:

; 354  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_alterneigh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _altersingle
_TEXT	SEGMENT
_n$ = -4						; size = 4
_alpha$ = 8						; size = 4
_i$ = 12						; size = 4
_r$ = 16						; size = 4
_g$ = 20						; size = 4
_b$ = 24						; size = 4
_altersingle PROC					; COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 303  : 	register int	*n;
; 304  : 
; 305  : 	n = network[i];	// alter hit neuron

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _n$[ebp], eax

; 306  : 	*n -= (alpha * (*n - r)) / initalpha;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _r$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _alpha$[ebp]
	cdq
	and	edx, 1023				; 000003ffH
	add	eax, edx
	sar	eax, 10					; 0000000aH
	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx

; 307  : 	n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 4
	mov	DWORD PTR _n$[ebp], eax

; 308  : 	*n -= (alpha * (*n - g)) / initalpha;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _g$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _alpha$[ebp]
	cdq
	and	edx, 1023				; 000003ffH
	add	eax, edx
	sar	eax, 10					; 0000000aH
	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx

; 309  : 	n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 4
	mov	DWORD PTR _n$[ebp], eax

; 310  : 	*n -= (alpha * (*n - b)) / initalpha;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _b$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _alpha$[ebp]
	cdq
	and	edx, 1023				; 000003ffH
	add	eax, edx
	sar	eax, 10					; 0000000aH
	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx], ecx

; 311  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_altersingle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _contest
_TEXT	SEGMENT
_bestbiasd$ = -48					; size = 4
_bestd$ = -44						; size = 4
_bestbiaspos$ = -40					; size = 4
_bestpos$ = -36						; size = 4
_betafreq$ = -32					; size = 4
_biasdist$ = -28					; size = 4
_a$ = -24						; size = 4
_dist$ = -20						; size = 4
_i$ = -16						; size = 4
_n$ = -12						; size = 4
_f$ = -8						; size = 4
_p$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_contest PROC						; COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 248  : 	register int	*p, *f, *n;
; 249  : 	register int	i, dist, a, biasdist, betafreq;
; 250  : 	int		bestpos, bestbiaspos, bestd, bestbiasd;
; 251  : 
; 252  : 	// finds closest neuron (min dist) and updates freq
; 253  : 	// finds best neuron (min dist-bias) and returns position
; 254  : 	// for frequently chosen neurons, freq[i] is high and bias[i] is negative
; 255  : 	// bias[i] = gamma * ((1 / netsize) - freq[i])
; 256  : 	bestd = ~(1<<31);

	mov	DWORD PTR _bestd$[ebp], 2147483647	; 7fffffffH

; 257  : 	bestbiasd = bestd;

	mov	eax, DWORD PTR _bestd$[ebp]
	mov	DWORD PTR _bestbiasd$[ebp], eax

; 258  : 	bestpos = -1;

	mov	DWORD PTR _bestpos$[ebp], -1

; 259  : 	bestbiaspos = bestpos;

	mov	eax, DWORD PTR _bestpos$[ebp]
	mov	DWORD PTR _bestbiaspos$[ebp], eax

; 260  : 	p = bias;

	mov	DWORD PTR _p$[ebp], OFFSET _bias

; 261  : 	f = freq;

	mov	DWORD PTR _f$[ebp], OFFSET _freq

; 262  : 
; 263  : 	for( i = 0; i < netsize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@contest
$LN2@contest:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@contest:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@contest

; 264  : 	{
; 265  : 		n = network[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _n$[ebp], eax

; 266  : 		dist = n[2] - b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _dist$[ebp], edx

; 267  : 		if( dist < 0 ) dist = -dist;

	jns	SHORT $LN5@contest
	mov	eax, DWORD PTR _dist$[ebp]
	neg	eax
	mov	DWORD PTR _dist$[ebp], eax
$LN5@contest:

; 268  : 		a = n[1] - g;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 269  : 		if( a < 0 ) a = -a;

	jns	SHORT $LN6@contest
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN6@contest:

; 270  : 		dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 271  : 		a = n[0] - r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 272  : 		if( a < 0 ) a = -a;

	jns	SHORT $LN7@contest
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN7@contest:

; 273  : 		dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 274  : 
; 275  : 		if( dist < bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jge	SHORT $LN8@contest

; 276  : 		{
; 277  : 			bestd = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _bestd$[ebp], eax

; 278  : 			bestpos = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bestpos$[ebp], eax
$LN8@contest:

; 279  : 		}
; 280  : 
; 281  : 		biasdist = dist - ((*p) >> (intbiasshift - netbiasshift));

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _dist$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _biasdist$[ebp], edx

; 282  : 
; 283  : 		if( biasdist < bestbiasd )

	mov	eax, DWORD PTR _biasdist$[ebp]
	cmp	eax, DWORD PTR _bestbiasd$[ebp]
	jge	SHORT $LN9@contest

; 284  : 		{
; 285  : 			bestbiasd = biasdist;

	mov	eax, DWORD PTR _biasdist$[ebp]
	mov	DWORD PTR _bestbiasd$[ebp], eax

; 286  : 			bestbiaspos = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bestbiaspos$[ebp], eax
$LN9@contest:

; 287  : 		}
; 288  : 
; 289  : 		betafreq = (*f >> betashift);

	mov	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 10					; 0000000aH
	mov	DWORD PTR _betafreq$[ebp], ecx

; 290  : 		*f++ -= betafreq;

	mov	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _betafreq$[ebp]
	mov	edx, DWORD PTR _f$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 4
	mov	DWORD PTR _f$[ebp], eax

; 291  : 		*p++ += (betafreq << gammashift);

	mov	eax, DWORD PTR _betafreq$[ebp]
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax

; 292  : 	}

	jmp	$LN2@contest
$LN3@contest:

; 293  : 
; 294  : 	freq[bestpos] += beta;

	mov	eax, DWORD PTR _bestpos$[ebp]
	mov	ecx, DWORD PTR _freq[eax*4]
	add	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _bestpos$[ebp]
	mov	DWORD PTR _freq[edx*4], ecx

; 295  : 	bias[bestpos] -= betagamma;

	mov	eax, DWORD PTR _bestpos$[ebp]
	mov	ecx, DWORD PTR _bias[eax*4]
	sub	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _bestpos$[ebp]
	mov	DWORD PTR _bias[edx*4], ecx

; 296  : 
; 297  : 	return bestbiaspos;

	mov	eax, DWORD PTR _bestbiaspos$[ebp]

; 298  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_contest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _inxsearch
_TEXT	SEGMENT
_best$ = -28						; size = 4
_p$ = -24						; size = 4
_bestd$ = -20						; size = 4
_a$ = -16						; size = 4
_dist$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_inxsearch PROC						; COMDAT

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 167  : 	register int	i, j, dist, a, bestd;
; 168  : 	register int	*p;
; 169  : 	int		best;
; 170  : 
; 171  : 	bestd = 1000;	// biggest possible dist is 256 * 3

	mov	DWORD PTR _bestd$[ebp], 1000		; 000003e8H

; 172  : 	best = -1;

	mov	DWORD PTR _best$[ebp], -1

; 173  : 	i = netindex[g];	// index on g

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _netindex[eax*4]
	mov	DWORD PTR _i$[ebp], ecx

; 174  : 	j = i - 1;	// start at netindex[g] and work outwards

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN2@inxsearch:

; 175  : 
; 176  : 	while(( i < netsize ) || ( j >= 0 ))

	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jl	SHORT $LN4@inxsearch
	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN3@inxsearch
$LN4@inxsearch:

; 177  : 	{
; 178  : 		if( i < netsize )

	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN5@inxsearch

; 179  : 		{
; 180  : 			p = network[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 181  : 			dist = p[1] - g;		// inx key

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _dist$[ebp], edx

; 182  : 
; 183  : 			if( dist >= bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jl	SHORT $LN6@inxsearch

; 184  : 			{
; 185  : 				i = netsize;	// stop iter

	mov	DWORD PTR _i$[ebp], 256			; 00000100H

; 186  : 			}

	jmp	$LN5@inxsearch
$LN6@inxsearch:

; 187  : 			else
; 188  : 			{
; 189  : 				i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 190  : 				if( dist < 0 ) dist = -dist;

	cmp	DWORD PTR _dist$[ebp], 0
	jge	SHORT $LN8@inxsearch
	mov	eax, DWORD PTR _dist$[ebp]
	neg	eax
	mov	DWORD PTR _dist$[ebp], eax
$LN8@inxsearch:

; 191  : 				a = p[2] - b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 192  : 				if( a < 0 ) a = -a;

	jns	SHORT $LN9@inxsearch
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN9@inxsearch:

; 193  : 				dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 194  : 
; 195  : 				if( dist < bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jge	SHORT $LN5@inxsearch

; 196  : 				{
; 197  : 					a = p[0] - r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 198  : 					if( a < 0 ) a = -a;

	jns	SHORT $LN11@inxsearch
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN11@inxsearch:

; 199  : 					dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 200  : 
; 201  : 					if( dist < bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jge	SHORT $LN5@inxsearch

; 202  : 					{
; 203  : 						bestd = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _bestd$[ebp], eax

; 204  : 						best = p[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _best$[ebp], eax
$LN5@inxsearch:

; 205  : 					}
; 206  : 				}
; 207  : 			}
; 208  : 		}
; 209  : 
; 210  : 		if( j >= 0 )

	cmp	DWORD PTR _j$[ebp], 0
	jl	$LN13@inxsearch

; 211  : 		{
; 212  : 			p = network[j];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 213  : 			dist = g - p[1]; // inx key - reverse dif

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	sub	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _dist$[ebp], edx

; 214  : 
; 215  : 			if( dist >= bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jl	SHORT $LN14@inxsearch

; 216  : 			{
; 217  : 				j = -1; // stop iter

	mov	DWORD PTR _j$[ebp], -1

; 218  : 			}

	jmp	$LN13@inxsearch
$LN14@inxsearch:

; 219  : 			else
; 220  : 			{
; 221  : 				j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 222  : 				if( dist < 0 ) dist = -dist;

	cmp	DWORD PTR _dist$[ebp], 0
	jge	SHORT $LN16@inxsearch
	mov	eax, DWORD PTR _dist$[ebp]
	neg	eax
	mov	DWORD PTR _dist$[ebp], eax
$LN16@inxsearch:

; 223  : 				a = p[2] - b;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 224  : 				if( a < 0 ) a = -a;

	jns	SHORT $LN17@inxsearch
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN17@inxsearch:

; 225  : 				dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 226  : 
; 227  : 				if( dist < bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jge	SHORT $LN13@inxsearch

; 228  : 				{
; 229  : 					a = p[0] - r;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 230  : 					if( a < 0 ) a = -a;

	jns	SHORT $LN19@inxsearch
	mov	eax, DWORD PTR _a$[ebp]
	neg	eax
	mov	DWORD PTR _a$[ebp], eax
$LN19@inxsearch:

; 231  : 					dist += a;

	mov	eax, DWORD PTR _dist$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _dist$[ebp], eax

; 232  : 					if( dist < bestd )

	mov	eax, DWORD PTR _dist$[ebp]
	cmp	eax, DWORD PTR _bestd$[ebp]
	jge	SHORT $LN13@inxsearch

; 233  : 					{
; 234  : 						bestd = dist;

	mov	eax, DWORD PTR _dist$[ebp]
	mov	DWORD PTR _bestd$[ebp], eax

; 235  : 						best = p[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _best$[ebp], eax
$LN13@inxsearch:

; 236  : 					}
; 237  : 				}
; 238  : 			}
; 239  : 		}
; 240  : 	}

	jmp	$LN2@inxsearch
$LN3@inxsearch:

; 241  : 
; 242  : 	return best;

	mov	eax, DWORD PTR _best$[ebp]

; 243  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_inxsearch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _inxbuild
_TEXT	SEGMENT
_startpos$ = -32					; size = 4
_previouscol$ = -28					; size = 4
_smallval$ = -24					; size = 4
_smallpos$ = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_q$ = -8						; size = 4
_p$ = -4						; size = 4
_inxbuild PROC						; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 108  : 	register int	*p, *q;
; 109  : 	register int	i, j, smallpos, smallval;
; 110  : 	int		previouscol, startpos;
; 111  : 
; 112  : 	previouscol = 0;

	mov	DWORD PTR _previouscol$[ebp], 0

; 113  : 	startpos = 0;

	mov	DWORD PTR _startpos$[ebp], 0

; 114  : 
; 115  : 	for( i = 0; i < netsize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@inxbuild
$LN2@inxbuild:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@inxbuild:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	$LN3@inxbuild

; 116  : 	{
; 117  : 		p = network[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 118  : 		smallpos = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _smallpos$[ebp], eax

; 119  : 		smallval = p[1];			// index on g

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _smallval$[ebp], edx

; 120  : 
; 121  : 		// find smallest in i..netsize-1
; 122  : 		for( j = i + 1; j < netsize; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@inxbuild
$LN5@inxbuild:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@inxbuild:
	cmp	DWORD PTR _j$[ebp], 256			; 00000100H
	jge	SHORT $LN6@inxbuild

; 123  : 		{
; 124  : 			q = network[j];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _q$[ebp], eax

; 125  : 			if( q[1] < smallval )

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	cmp	edx, DWORD PTR _smallval$[ebp]
	jge	SHORT $LN14@inxbuild

; 126  : 			{
; 127  : 				// index on g
; 128  : 				smallpos = j;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _smallpos$[ebp], eax

; 129  : 				smallval = q[1];	// index on g

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _smallval$[ebp], edx
$LN14@inxbuild:

; 130  : 			}
; 131  : 		}

	jmp	SHORT $LN5@inxbuild
$LN6@inxbuild:

; 132  : 
; 133  : 		q = network[smallpos];

	mov	eax, DWORD PTR _smallpos$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _q$[ebp], eax

; 134  : 
; 135  : 		// swap p (i) and q (smallpos) entries
; 136  : 		if( i != smallpos )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _smallpos$[ebp]
	je	$LN15@inxbuild

; 137  : 		{
; 138  : 			j = q[0];   q[0] = p[0];   p[0] = j;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _j$[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 139  : 			j = q[1];   q[1] = p[1];   p[1] = j;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 140  : 			j = q[2];   q[2] = p[2];   p[2] = j;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _q$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 141  : 			j = q[3];   q[3] = p[3];   p[3] = j;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _j$[ebp], eax
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	imul	eax, edx, 3
	mov	edx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [edx+ecx], eax
$LN15@inxbuild:

; 142  : 		}
; 143  : 
; 144  : 		// smallval entry is now in position i
; 145  : 		if( smallval != previouscol )

	mov	eax, DWORD PTR _smallval$[ebp]
	cmp	eax, DWORD PTR _previouscol$[ebp]
	je	SHORT $LN16@inxbuild

; 146  : 		{
; 147  : 			netindex[previouscol] = (startpos+i) >> 1;

	mov	eax, DWORD PTR _startpos$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _previouscol$[ebp]
	mov	DWORD PTR _netindex[ecx*4], eax

; 148  : 
; 149  : 			for( j = previouscol + 1; j < smallval; j++ )

	mov	eax, DWORD PTR _previouscol$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN10@inxbuild
$LN8@inxbuild:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@inxbuild:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _smallval$[ebp]
	jge	SHORT $LN9@inxbuild

; 150  : 				netindex[j] = i;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _netindex[eax*4], ecx
	jmp	SHORT $LN8@inxbuild
$LN9@inxbuild:

; 151  : 
; 152  : 			previouscol = smallval;

	mov	eax, DWORD PTR _smallval$[ebp]
	mov	DWORD PTR _previouscol$[ebp], eax

; 153  : 			startpos = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _startpos$[ebp], eax
$LN16@inxbuild:

; 154  : 		}
; 155  : 	}

	jmp	$LN2@inxbuild
$LN3@inxbuild:

; 156  : 
; 157  : 	netindex[previouscol] = (startpos + maxnetpos)>>1;

	mov	eax, DWORD PTR _startpos$[ebp]
	add	eax, 255				; 000000ffH
	sar	eax, 1
	mov	ecx, DWORD PTR _previouscol$[ebp]
	mov	DWORD PTR _netindex[ecx*4], eax

; 158  : 
; 159  : 	for( j = previouscol + 1; j < 256; j++ )

	mov	eax, DWORD PTR _previouscol$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN13@inxbuild
$LN11@inxbuild:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@inxbuild:
	cmp	DWORD PTR _j$[ebp], 256			; 00000100H
	jge	SHORT $LN1@inxbuild

; 160  : 		netindex[j] = maxnetpos; // really 256

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _netindex[eax*4], 255		; 000000ffH
	jmp	SHORT $LN11@inxbuild
$LN1@inxbuild:

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_inxbuild ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _unbiasnet
_TEXT	SEGMENT
_temp$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_unbiasnet PROC						; COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 88   : 	int	i, j, temp;
; 89   : 
; 90   : 	for( i = 0; i < netsize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@unbiasnet
$LN2@unbiasnet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@unbiasnet:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@unbiasnet

; 91   : 	{
; 92   : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@unbiasnet
$LN5@unbiasnet:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@unbiasnet:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@unbiasnet

; 93   : 		{
; 94   : 			// OLD CODE: network[i][j] >>= netbiasshift;
; 95   : 			// Fix based on bug report by Juergen Weigert jw@suse.de
; 96   : 			temp = (network[i][j] + (1 << (netbiasshift - 1))) >> netbiasshift;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _network[eax+ecx*4]
	add	edx, 8
	sar	edx, 4
	mov	DWORD PTR _temp$[ebp], edx

; 97   : 			if( temp > 255 ) temp = 255;

	cmp	DWORD PTR _temp$[ebp], 255		; 000000ffH
	jle	SHORT $LN8@unbiasnet
	mov	DWORD PTR _temp$[ebp], 255		; 000000ffH
$LN8@unbiasnet:

; 98   : 			network[i][j] = temp;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _network[eax+ecx*4], edx

; 99   : 		}

	jmp	SHORT $LN5@unbiasnet
$LN6@unbiasnet:

; 100  : 
; 101  : 		network[i][3] = i; // record colour num

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _network[eax+edx], ecx

; 102  : 	}

	jmp	$LN2@unbiasnet
$LN1@unbiasnet:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_unbiasnet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _initnet
_TEXT	SEGMENT
tv75 = -76						; size = 4
_p$ = -8						; size = 4
_i$ = -4						; size = 4
_thepic$ = 8						; size = 4
_len$ = 12						; size = 4
_sample$ = 16						; size = 4
_initnet PROC						; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 70   : 	register int	i, *p;
; 71   : 	
; 72   : 	thepicture = thepic;

	mov	eax, DWORD PTR _thepic$[ebp]
	mov	DWORD PTR _thepicture, eax

; 73   : 	lengthcount = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _lengthcount, eax

; 74   : 	samplefac = sample;

	mov	eax, DWORD PTR _sample$[ebp]
	mov	DWORD PTR _samplefac, eax

; 75   : 	
; 76   : 	for( i = 0; i < netsize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@initnet
$LN2@initnet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@initnet:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN1@initnet

; 77   : 	{
; 78   : 		p = network[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET _network
	mov	DWORD PTR _p$[ebp], eax

; 79   : 		p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 12					; 0000000cH
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	mov	DWORD PTR tv75[ebp], eax
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 80   : 		freq[i] = intbias / netsize;	// 1 / netsize

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _freq[eax*4], 256		; 00000100H

; 81   : 		bias[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bias[eax*4], 0

; 82   : 	}

	jmp	$LN2@initnet
$LN1@initnet:

; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_initnet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\imagelib\img_quant.c
;	COMDAT _Image_Quantize
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pic$ = 8						; size = 4
_Image_Quantize PROC					; COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 431  : 	int	i;
; 432  : 
; 433  : 	// quick case to reject unneeded conversions
; 434  : 	if( pic->type == PF_INDEXED_24 || pic->type ==  PF_INDEXED_32 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 1
	je	SHORT $LN9@Image_Quan
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN8@Image_Quan
$LN9@Image_Quan:

; 435  : 		return pic;

	mov	eax, DWORD PTR _pic$[ebp]
	jmp	$LN1@Image_Quan
$LN8@Image_Quan:

; 436  : 
; 437  : 	Image_CopyParms( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_CopyParms
	add	esp, 4

; 438  : 	image.size = image.width * image.height;

	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	mov	DWORD PTR _image+28, eax

; 439  : 	image.bpp = PFDesc[pic->type].bpp;

	mov	eax, DWORD PTR _pic$[ebp]
	imul	ecx, DWORD PTR [eax+8], 28
	mov	edx, DWORD PTR _PFDesc[ecx+24]
	mov	DWORD PTR _image+36, edx

; 440  : 	image.ptr = 0;

	mov	DWORD PTR _image+32, 0

; 441  : 
; 442  : 	// allocate 8-bit buffer
; 443  : 	image.tempbuffer = Mem_Realloc( host.imagepool, image.tempbuffer, image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Quantize@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _image+84
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _image+84, eax

; 444  : 
; 445  : 	initnet( pic->buffer, pic->size, 10 );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_initnet
	add	esp, 12					; 0000000cH

; 446  : 	learn();

	call	_learn

; 447  : 	unbiasnet();

	call	_unbiasnet

; 448  : 
; 449  : 	pic->palette = Mem_Malloc( host.imagepool, netsize * 3 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Quantize@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	768					; 00000300H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+20], eax

; 450  : 
; 451  : 	for( i = 0; i < netsize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Image_Quan
$LN2@Image_Quan:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Image_Quan:
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jge	SHORT $LN3@Image_Quan

; 452  : 	{
; 453  : 		pic->palette[i*3+0] = network[i][0];	// red

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _i$[ebp], 3
	mov	esi, DWORD PTR _pic$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	dl, BYTE PTR _network[eax+edx]
	mov	BYTE PTR [esi+ecx], dl

; 454  : 		pic->palette[i*3+1] = network[i][1];	// green

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _i$[ebp], 3
	mov	esi, DWORD PTR _pic$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	al, BYTE PTR _network[eax+ecx]
	mov	BYTE PTR [esi+edx+1], al

; 455  : 		pic->palette[i*3+2] = network[i][2];	// blue 

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _i$[ebp], 3
	mov	esi, DWORD PTR _pic$[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	al, BYTE PTR _network[eax+ecx]
	mov	BYTE PTR [esi+edx+2], al

; 456  : 	}

	jmp	SHORT $LN2@Image_Quan
$LN3@Image_Quan:

; 457  : 
; 458  : 	inxbuild();

	call	_inxbuild

; 459  : 
; 460  : 	for( i = 0; i < image.width * image.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Image_Quan
$LN5@Image_Quan:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Image_Quan:
	movzx	eax, WORD PTR _image+8
	movzx	ecx, WORD PTR _image+10
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN6@Image_Quan

; 461  : 	{
; 462  : 		image.tempbuffer[i] = inxsearch( pic->buffer[i*image.bpp+0], pic->buffer[i*image.bpp+1], pic->buffer[i*image.bpp+2] );

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, DWORD PTR _image+36
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movzx	eax, BYTE PTR [edx+eax+2]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, DWORD PTR _image+36
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movzx	ecx, BYTE PTR [eax+ecx+1]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, DWORD PTR _image+36
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	movzx	edx, BYTE PTR [ecx+edx]
	push	edx
	call	_inxsearch
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _image+84
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al

; 463  : 	}

	jmp	SHORT $LN5@Image_Quan
$LN6@Image_Quan:

; 464  : 
; 465  : 	pic->buffer = Mem_Realloc( host.imagepool, pic->buffer, image.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Image_Quantize@@9@9
	add	eax, 35					; 00000023H
	push	eax
	push	OFFSET ??_C@_0DP@HOHJKNJM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _image+28
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+24], eax

; 466  : 	memcpy( pic->buffer, image.tempbuffer, image.size );

	mov	eax, DWORD PTR _image+28
	push	eax
	mov	ecx, DWORD PTR _image+84
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 467  : 	pic->type = PF_INDEXED_24;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [eax+8], 1

; 468  : 	pic->size = image.size;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _image+28
	mov	DWORD PTR [eax+32], ecx

; 469  : 
; 470  : 	return pic;

	mov	eax, DWORD PTR _pic$[ebp]
$LN1@Image_Quan:

; 471  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Image_Quantize ENDP
_TEXT	ENDS
END
