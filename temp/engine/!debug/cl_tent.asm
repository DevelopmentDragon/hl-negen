; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_tent.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cl_sprite_dot
PUBLIC	_cl_sprite_shell
PUBLIC	_cl_tempents
PUBLIC	_cl_sprite_ricochet
PUBLIC	_cl_sprite_glow
PUBLIC	_cl_default_sprites
PUBLIC	??_C@_0BJ@EJELEIK@sprites?1muzzleflash1?4spr@	; `string'
PUBLIC	??_C@_0BJ@ICAAMGCE@sprites?1muzzleflash2?4spr@	; `string'
PUBLIC	??_C@_0BJ@EJFMBFIB@sprites?1muzzleflash3?4spr@	; `string'
PUBLIC	??_C@_0BA@NAEHANAC@sprites?1dot?4spr@		; `string'
PUBLIC	??_C@_0BH@MLJLEIH@sprites?1animglow01?4spr@	; `string'
PUBLIC	??_C@_0BD@JLHHJFDC@sprites?1richo1?4spr@	; `string'
PUBLIC	??_C@_0BI@EMLINFOG@sprites?1shellchrome?4spr@	; `string'
PUBLIC	_cl_player_shell_sounds
PUBLIC	??_C@_0BF@NLBBFLDH@player?1pl_shell1?4wav@	; `string'
PUBLIC	??_C@_0BF@FNIFCJJJ@player?1pl_shell2?4wav@	; `string'
PUBLIC	??_C@_0BF@JGNJPKDM@player?1pl_shell3?4wav@	; `string'
PUBLIC	_cl_weapon_shell_sounds
PUBLIC	??_C@_0BE@KBKMFHDL@weapons?1sshell1?4wav@	; `string'
PUBLIC	??_C@_0BE@CHDICFJF@weapons?1sshell2?4wav@	; `string'
PUBLIC	??_C@_0BE@OMGEPGDA@weapons?1sshell3?4wav@	; `string'
PUBLIC	_cl_ricochet_sounds
PUBLIC	??_C@_0BB@MNBCLJOD@weapons?1ric1?4wav@		; `string'
PUBLIC	??_C@_0BB@ELIGMLEN@weapons?1ric2?4wav@		; `string'
PUBLIC	??_C@_0BB@IANKBIOI@weapons?1ric3?4wav@		; `string'
PUBLIC	??_C@_0BB@JNNPCIFA@weapons?1ric4?4wav@		; `string'
PUBLIC	??_C@_0BB@FGIDPLPF@weapons?1ric5?4wav@		; `string'
PUBLIC	_cl_explode_sounds
PUBLIC	??_C@_0BF@JODNKDND@weapons?1explode3?4wav@	; `string'
PUBLIC	??_C@_0BF@IDDIJDGL@weapons?1explode4?4wav@	; `string'
PUBLIC	??_C@_0BF@EIGEEAMO@weapons?1explode5?4wav@	; `string'
_BSS	SEGMENT
_cl_sprite_dot DD 01H DUP (?)
_cl_sprite_shell DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_cl_dlights:BYTE:0500H
COMM	_cl_elights:BYTE:0a00H
COMM	_cl_active_tents:DWORD
COMM	_cl_free_tents:DWORD
_DATA	ENDS
_BSS	SEGMENT
_cl_tempents DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_cl_sprite_muzzleflash:DWORD:03H
_DATA	ENDS
_BSS	SEGMENT
_cl_sprite_ricochet DD 01H DUP (?)
_cl_sprite_glow DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_cl_efrags:BYTE:020000H
_DATA	ENDS
;	COMDAT ??_C@_0BF@EIGEEAMO@weapons?1explode5?4wav@
CONST	SEGMENT
??_C@_0BF@EIGEEAMO@weapons?1explode5?4wav@ DB 'weapons/explode5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IDDIJDGL@weapons?1explode4?4wav@
CONST	SEGMENT
??_C@_0BF@IDDIJDGL@weapons?1explode4?4wav@ DB 'weapons/explode4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JODNKDND@weapons?1explode3?4wav@
CONST	SEGMENT
??_C@_0BF@JODNKDND@weapons?1explode3?4wav@ DB 'weapons/explode3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGIDPLPF@weapons?1ric5?4wav@
CONST	SEGMENT
??_C@_0BB@FGIDPLPF@weapons?1ric5?4wav@ DB 'weapons/ric5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNNPCIFA@weapons?1ric4?4wav@
CONST	SEGMENT
??_C@_0BB@JNNPCIFA@weapons?1ric4?4wav@ DB 'weapons/ric4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IANKBIOI@weapons?1ric3?4wav@
CONST	SEGMENT
??_C@_0BB@IANKBIOI@weapons?1ric3?4wav@ DB 'weapons/ric3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ELIGMLEN@weapons?1ric2?4wav@
CONST	SEGMENT
??_C@_0BB@ELIGMLEN@weapons?1ric2?4wav@ DB 'weapons/ric2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNBCLJOD@weapons?1ric1?4wav@
CONST	SEGMENT
??_C@_0BB@MNBCLJOD@weapons?1ric1?4wav@ DB 'weapons/ric1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OMGEPGDA@weapons?1sshell3?4wav@
CONST	SEGMENT
??_C@_0BE@OMGEPGDA@weapons?1sshell3?4wav@ DB 'weapons/sshell3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHDICFJF@weapons?1sshell2?4wav@
CONST	SEGMENT
??_C@_0BE@CHDICFJF@weapons?1sshell2?4wav@ DB 'weapons/sshell2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBKMFHDL@weapons?1sshell1?4wav@
CONST	SEGMENT
??_C@_0BE@KBKMFHDL@weapons?1sshell1?4wav@ DB 'weapons/sshell1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JGNJPKDM@player?1pl_shell3?4wav@
CONST	SEGMENT
??_C@_0BF@JGNJPKDM@player?1pl_shell3?4wav@ DB 'player/pl_shell3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNIFCJJJ@player?1pl_shell2?4wav@
CONST	SEGMENT
??_C@_0BF@FNIFCJJJ@player?1pl_shell2?4wav@ DB 'player/pl_shell2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NLBBFLDH@player?1pl_shell1?4wav@
CONST	SEGMENT
??_C@_0BF@NLBBFLDH@player?1pl_shell1?4wav@ DB 'player/pl_shell1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EMLINFOG@sprites?1shellchrome?4spr@
CONST	SEGMENT
??_C@_0BI@EMLINFOG@sprites?1shellchrome?4spr@ DB 'sprites/shellchrome.spr'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLHHJFDC@sprites?1richo1?4spr@
CONST	SEGMENT
??_C@_0BD@JLHHJFDC@sprites?1richo1?4spr@ DB 'sprites/richo1.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MLJLEIH@sprites?1animglow01?4spr@
CONST	SEGMENT
??_C@_0BH@MLJLEIH@sprites?1animglow01?4spr@ DB 'sprites/animglow01.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAEHANAC@sprites?1dot?4spr@
CONST	SEGMENT
??_C@_0BA@NAEHANAC@sprites?1dot?4spr@ DB 'sprites/dot.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EJFMBFIB@sprites?1muzzleflash3?4spr@
CONST	SEGMENT
??_C@_0BJ@EJFMBFIB@sprites?1muzzleflash3?4spr@ DB 'sprites/muzzleflash3.s'
	DB	'pr', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICAAMGCE@sprites?1muzzleflash2?4spr@
CONST	SEGMENT
??_C@_0BJ@ICAAMGCE@sprites?1muzzleflash2?4spr@ DB 'sprites/muzzleflash2.s'
	DB	'pr', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EJELEIK@sprites?1muzzleflash1?4spr@
CONST	SEGMENT
??_C@_0BJ@EJELEIK@sprites?1muzzleflash1?4spr@ DB 'sprites/muzzleflash1.sp'
	DB	'r', 00H					; `string'
CONST	ENDS
_DATA	SEGMENT
_cl_default_sprites DD FLAT:??_C@_0BJ@EJELEIK@sprites?1muzzleflash1?4spr@
	DD	FLAT:??_C@_0BJ@ICAAMGCE@sprites?1muzzleflash2?4spr@
	DD	FLAT:??_C@_0BJ@EJFMBFIB@sprites?1muzzleflash3?4spr@
	DD	FLAT:??_C@_0BA@NAEHANAC@sprites?1dot?4spr@
	DD	FLAT:??_C@_0BH@MLJLEIH@sprites?1animglow01?4spr@
	DD	FLAT:??_C@_0BD@JLHHJFDC@sprites?1richo1?4spr@
	DD	FLAT:??_C@_0BI@EMLINFOG@sprites?1shellchrome?4spr@
_cl_player_shell_sounds DD FLAT:??_C@_0BF@NLBBFLDH@player?1pl_shell1?4wav@
	DD	FLAT:??_C@_0BF@FNIFCJJJ@player?1pl_shell2?4wav@
	DD	FLAT:??_C@_0BF@JGNJPKDM@player?1pl_shell3?4wav@
_cl_weapon_shell_sounds DD FLAT:??_C@_0BE@KBKMFHDL@weapons?1sshell1?4wav@
	DD	FLAT:??_C@_0BE@CHDICFJF@weapons?1sshell2?4wav@
	DD	FLAT:??_C@_0BE@OMGEPGDA@weapons?1sshell3?4wav@
_cl_ricochet_sounds DD FLAT:??_C@_0BB@MNBCLJOD@weapons?1ric1?4wav@
	DD	FLAT:??_C@_0BB@ELIGMLEN@weapons?1ric2?4wav@
	DD	FLAT:??_C@_0BB@IANKBIOI@weapons?1ric3?4wav@
	DD	FLAT:??_C@_0BB@JNNPCIFA@weapons?1ric4?4wav@
	DD	FLAT:??_C@_0BB@FGIDPLPF@weapons?1ric5?4wav@
_cl_explode_sounds DD FLAT:??_C@_0BF@JODNKDND@weapons?1explode3?4wav@
	DD	FLAT:??_C@_0BF@IDDIJDGL@weapons?1explode4?4wav@
	DD	FLAT:??_C@_0BF@EIGEEAMO@weapons?1explode5?4wav@
_DATA	ENDS
PUBLIC	_CL_SetLightstyle
PUBLIC	_CL_DecayLights
PUBLIC	_CL_ParseTempEntity
PUBLIC	_CL_ClearEffects
PUBLIC	_CL_ClearEfrags
PUBLIC	_CL_TestLights
PUBLIC	_CL_FireCustomDecal
PUBLIC	_CL_DecalShoot
PUBLIC	_CL_PlayerDecal
PUBLIC	_CL_AddClientResource
PUBLIC	_CL_AddClientResources
PUBLIC	_CL_FxBlend
PUBLIC	_CL_InitTempEnts
PUBLIC	_CL_ClearTempEnts
PUBLIC	_CL_FreeTempEnts
PUBLIC	_CL_TempEntUpdate
PUBLIC	_CL_LoadClientSprites
PUBLIC	_R_Explosion
PUBLIC	_R_SparkShower
PUBLIC	_CL_TempEntAlloc
PUBLIC	_CL_TempEntAllocHigh
PUBLIC	_CL_TempEntAllocNoModel
PUBLIC	_CL_TempEntAllocCustom
PUBLIC	_R_FizzEffect
PUBLIC	_R_Bubbles
PUBLIC	_R_BubbleTrail
PUBLIC	_R_AttachTentToPlayer
PUBLIC	_R_KillAttachedTents
PUBLIC	_R_RicochetSprite
PUBLIC	_R_RocketFlare
PUBLIC	_R_MuzzleFlash
PUBLIC	_R_BloodSprite
PUBLIC	_R_BreakModel
PUBLIC	_R_TempModel
PUBLIC	_R_TempSprite
PUBLIC	_R_DefaultSprite
PUBLIC	_R_Sprite_Explode
PUBLIC	_R_Sprite_Smoke
PUBLIC	_R_Spray
PUBLIC	_R_Sprite_Spray
PUBLIC	_R_Sprite_Trail
PUBLIC	_R_FunnelSprite
PUBLIC	_R_SparkEffect
PUBLIC	_R_Projectile
PUBLIC	_R_TempSphereModel
PUBLIC	_R_MultiGunshot
PUBLIC	_R_FireField
PUBLIC	_R_PlayerSprites
PUBLIC	_R_Sprite_WallPuff
PUBLIC	_R_RicochetSound
PUBLIC	_CL_AllocDlight
PUBLIC	_CL_AllocElight
PUBLIC	_CL_UpdateFlashlight
PUBLIC	_CL_AddEntityEffects
PUBLIC	_CL_AddModelEffects
PUBLIC	_CL_DecalRemoveAll
PUBLIC	_CL_DecalIndexFromName
PUBLIC	_CL_DecalIndex
PUBLIC	_CL_PrepareTEnt
PUBLIC	_CL_TempEntPlaySound
PUBLIC	_CL_TempEntAddEntity
PUBLIC	_CL_FreeLowPriorityTempEnt
PUBLIC	_CL_ClearLightStyles
PUBLIC	_CL_ClearDlights
PUBLIC	?__LINE__Var@?0??CL_AddClientResource@@9@9	; `CL_AddClientResource'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_06PBLIODKG@sound?1@			; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	?__LINE__Var@?0??CL_InitTempEnts@@9@9		; `CL_InitTempEnts'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CL_FreeTempEnts@@9@9		; `CL_FreeTempEnts'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??CL_TempEntPlaySound@@9@9	; `CL_TempEntPlaySound'::`1'::__LINE__Var
PUBLIC	??_C@_0O@JHIJGBPP@pTemp?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0BD@LELGLKED@debris?1glass?$CFi?4wav@	; `string'
PUBLIC	??_C@_0BD@MDOGGPHL@debris?1metal?$CFi?4wav@	; `string'
PUBLIC	??_C@_0BD@HCJHLCL@debris?1flesh?$CFi?4wav@	; `string'
PUBLIC	??_C@_0BC@IGHOLFCC@debris?1wood?$CFi?4wav@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0BG@HDCPKBJB@debris?1concrete?$CFi?4wav@	; `string'
PUBLIC	?__LINE__Var@?0??CL_TempEntAddEntity@@9@9	; `CL_TempEntAddEntity'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@LOGAJLJO@pEntity?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0BN@IBFHIBLB@Overflow?5?$CFd?5temporary?5ents?$CB?6@ ; `string'
PUBLIC	??_C@_0CG@FKBCOHFI@Couldn?8t?5alloc?5a?5high?5priority?5@ ; `string'
PUBLIC	??_C@_0P@FJBFKKAM@No?5Sprite?5?$CFd?$CB?6@	; `string'
PUBLIC	??_C@_0BJ@DIEJGHFK@?$FO1Error?3?$FO7?5No?5model?5?$CFd?$CB?6@ ; `string'
PUBLIC	??_C@_0O@ICEDCNLF@No?5model?5?$CFd?$CB?6@	; `string'
PUBLIC	??_C@_0BJ@PFCNBPIC@?$FO1Error?3?$FO7?5no?5model?5?$CFd?$CB?6@ ; `string'
PUBLIC	??_C@_0L@KJBJBAKD@TempEntity@			; `string'
PUBLIC	??_C@_0DF@GBPNOJNL@?$FO1Error?3?$FO7?5ParseTempEntity?3?5ill@ ; `string'
PUBLIC	??_C@_0DD@EGMOAPEI@?$FO3Warning?3?$FO7?5ParseTempEntity?3?5o@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_SetLightstyle@@9@9		; `CL_SetLightstyle'::`1'::__LINE__Var
PUBLIC	??_C@_09EGGCOFMI@s?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0CG@IJIGLMMD@style?5?$DO?$DN?50?5?$CG?$CG?5style?5?$DM?5MAX_LIGHT@ ; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes@				; `string'
PUBLIC	??_C@_02JINPPBEP@No@				; `string'
PUBLIC	??_C@_0BP@LJEJFAAK@Lightstyle?5?$CFi?5?$CI?$CFs?$CJ?0?5interp?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0P@GPNCHLMC@player?$CFdlogo?$CFd@		; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b23d70a
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f333333
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3f99999a
PUBLIC	__real@3fa00000
PUBLIC	__real@3fb40000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fd6666660000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4031000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4037000000000000
PUBLIC	__real@40400000
PUBLIC	__real@4042000000000000
PUBLIC	__real@40490fdb
PUBLIC	__real@4050000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@41000000
PUBLIC	__real@41100000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41700000
PUBLIC	__real@41800000
PUBLIC	__real@41900000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41e00000
PUBLIC	__real@41f00000
PUBLIC	__real@42000000
PUBLIC	__real@420c0000
PUBLIC	__real@42100000
PUBLIC	__real@42340000
PUBLIC	__real@42700000
PUBLIC	__real@42800000
PUBLIC	__real@42a00000
PUBLIC	__real@42be0000
PUBLIC	__real@42c80000
PUBLIC	__real@43000000
PUBLIC	__real@43160000
PUBLIC	__real@43480000
PUBLIC	__real@43670000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43960000
PUBLIC	__real@43af0000
PUBLIC	__real@43b40000
PUBLIC	__real@43b58000
PUBLIC	__real@43c80000
PUBLIC	__real@43d78000
PUBLIC	__real@43d80000
PUBLIC	__real@43e10000
PUBLIC	__real@43fa0000
PUBLIC	__real@43ff8000
PUBLIC	__real@44480000
PUBLIC	__real@44fa0000
PUBLIC	__real@45800000
PUBLIC	__real@be800000
PUBLIC	__real@bf000000
PUBLIC	__real@bf800000
PUBLIC	__real@c0490fdb
PUBLIC	__real@c1200000
PUBLIC	__real@c1a00000
PUBLIC	__real@c2000000
PUBLIC	__real@c2c00000
PUBLIC	__real@c2c80000
PUBLIC	__real@c2fe0000
PUBLIC	__real@c3480000
PUBLIC	__real@c37f0000
PUBLIC	__real@c3800000
PUBLIC	__real@c3960000
PUBLIC	__real@c4000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	_abs:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Image_SetForceFlags:PROC
EXTRN	_Image_ClearForceFlags:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_CL_PointContents:PROC
EXTRN	_R_DecalRemoveAll:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_SinCos:PROC
EXTRN	_VectorNormalizeLength2:PROC
EXTRN	_VectorVectors:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_Mod_AliasExtradata:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_ReadChar:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_MSG_ReadShort:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadCoord:PROC
EXTRN	_MSG_ReadBytes:PROC
EXTRN	_CL_AddToResourceList:PROC
EXTRN	_CL_ParseTextMessage:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_LoadClientSprite:PROC
EXTRN	_CL_VisTraceLine:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_AddVisibleEntity:PROC
EXTRN	_CL_ClearParticles:PROC
EXTRN	_CL_ClearViewBeams:PROC
EXTRN	_CL_ParseViewBeam:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_StartSound:PROC
EXTRN	_R_ParticleExplosion2:PROC
EXTRN	_R_Implosion:PROC
EXTRN	_R_Blood:PROC
EXTRN	_R_BloodStream:PROC
EXTRN	_R_BlobExplosion:PROC
EXTRN	_R_EntityParticles:PROC
EXTRN	_R_FlickerParticles:PROC
EXTRN	_R_RunParticleEffect:PROC
EXTRN	_R_ParticleBurst:PROC
EXTRN	_R_LavaSplash:PROC
EXTRN	_R_TeleportSplash:PROC
EXTRN	_R_RocketTrail:PROC
EXTRN	_R_TracerEffect:PROC
EXTRN	_R_UserTracerParticle:PROC
EXTRN	_R_ParticleLine:PROC
EXTRN	_R_ParticleBox:PROC
EXTRN	_R_ShowLine:PROC
EXTRN	_R_BulletImpactParticles:PROC
EXTRN	_R_LargeFunnel:PROC
EXTRN	_R_StreakSplash:PROC
EXTRN	_R_SparkStreaks:PROC
EXTRN	_TriBoxInPVS:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_R_DecalShoot:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_vec3_origin:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_testlights:DWORD
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c4000000
CONST	SEGMENT
__real@c4000000 DD 0c4000000r			; -512
CONST	ENDS
;	COMDAT __real@c3960000
CONST	SEGMENT
__real@c3960000 DD 0c3960000r			; -300
CONST	ENDS
;	COMDAT __real@c3800000
CONST	SEGMENT
__real@c3800000 DD 0c3800000r			; -256
CONST	ENDS
;	COMDAT __real@c37f0000
CONST	SEGMENT
__real@c37f0000 DD 0c37f0000r			; -255
CONST	ENDS
;	COMDAT __real@c3480000
CONST	SEGMENT
__real@c3480000 DD 0c3480000r			; -200
CONST	ENDS
;	COMDAT __real@c2fe0000
CONST	SEGMENT
__real@c2fe0000 DD 0c2fe0000r			; -127
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c2c00000
CONST	SEGMENT
__real@c2c00000 DD 0c2c00000r			; -96
CONST	ENDS
;	COMDAT __real@c2000000
CONST	SEGMENT
__real@c2000000 DD 0c2000000r			; -32
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@be800000
CONST	SEGMENT
__real@be800000 DD 0be800000r			; -0.25
CONST	ENDS
;	COMDAT __real@45800000
CONST	SEGMENT
__real@45800000 DD 045800000r			; 4096
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@43ff8000
CONST	SEGMENT
__real@43ff8000 DD 043ff8000r			; 511
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43e10000
CONST	SEGMENT
__real@43e10000 DD 043e10000r			; 450
CONST	ENDS
;	COMDAT __real@43d80000
CONST	SEGMENT
__real@43d80000 DD 043d80000r			; 432
CONST	ENDS
;	COMDAT __real@43d78000
CONST	SEGMENT
__real@43d78000 DD 043d78000r			; 431
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@43b58000
CONST	SEGMENT
__real@43b58000 DD 043b58000r			; 363
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43af0000
CONST	SEGMENT
__real@43af0000 DD 043af0000r			; 350
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43670000
CONST	SEGMENT
__real@43670000 DD 043670000r			; 231
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43160000
CONST	SEGMENT
__real@43160000 DD 043160000r			; 150
CONST	ENDS
;	COMDAT __real@43000000
CONST	SEGMENT
__real@43000000 DD 043000000r			; 128
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42be0000
CONST	SEGMENT
__real@42be0000 DD 042be0000r			; 95
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42800000
CONST	SEGMENT
__real@42800000 DD 042800000r			; 64
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42100000
CONST	SEGMENT
__real@42100000 DD 042100000r			; 36
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41e00000
CONST	SEGMENT
__real@41e00000 DD 041e00000r			; 28
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4050000000000000
CONST	SEGMENT
__real@4050000000000000 DQ 04050000000000000r	; 64
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4042000000000000
CONST	SEGMENT
__real@4042000000000000 DQ 04042000000000000r	; 36
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@4037000000000000
CONST	SEGMENT
__real@4037000000000000 DQ 04037000000000000r	; 23
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4031000000000000
CONST	SEGMENT
__real@4031000000000000 DQ 04031000000000000r	; 17
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd6666660000000
CONST	SEGMENT
__real@3fd6666660000000 DQ 03fd6666660000000r	; 0.35
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fb40000
CONST	SEGMENT
__real@3fb40000 DD 03fb40000r			; 1.40625
CONST	ENDS
;	COMDAT __real@3fa00000
CONST	SEGMENT
__real@3fa00000 DD 03fa00000r			; 1.25
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b23d70a
CONST	SEGMENT
__real@3b23d70a DD 03b23d70ar			; 0.0025
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0P@GPNCHLMC@player?$CFdlogo?$CFd@
CONST	SEGMENT
??_C@_0P@GPNCHLMC@player?$CFdlogo?$CFd@ DB 'player%dlogo%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LJEJFAAK@Lightstyle?5?$CFi?5?$CI?$CFs?$CJ?0?5interp?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@LJEJFAAK@Lightstyle?5?$CFi?5?$CI?$CFs?$CJ?0?5interp?5?$CFs?6@ DB 'L'
	DB	'ightstyle %i (%s), interp %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No@
CONST	SEGMENT
??_C@_02JINPPBEP@No@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IJIGLMMD@style?5?$DO?$DN?50?5?$CG?$CG?5style?5?$DM?5MAX_LIGHT@
CONST	SEGMENT
??_C@_0CG@IJIGLMMD@style?5?$DO?$DN?50?5?$CG?$CG?5style?5?$DM?5MAX_LIGHT@ DB 's'
	DB	'tyle >= 0 && style < MAX_LIGHTSTYLES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EGGCOFMI@s?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_09EGGCOFMI@s?5?$CB?$DN?5NULL@ DB 's != NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_SetLightstyle@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_SetLightstyle@@9@9 DD 09edH		; `CL_SetLightstyle'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@EGMOAPEI@?$FO3Warning?3?$FO7?5ParseTempEntity?3?5o@
CONST	SEGMENT
??_C@_0DD@EGMOAPEI@?$FO3Warning?3?$FO7?5ParseTempEntity?3?5o@ DB '^3Warni'
	DB	'ng:^7 ParseTempEntity: overflow TE message', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GBPNOJNL@?$FO1Error?3?$FO7?5ParseTempEntity?3?5ill@
CONST	SEGMENT
??_C@_0DF@GBPNOJNL@?$FO1Error?3?$FO7?5ParseTempEntity?3?5ill@ DB '^1Error'
	DB	':^7 ParseTempEntity: illegible TE message %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KJBJBAKD@TempEntity@
CONST	SEGMENT
??_C@_0L@KJBJBAKD@TempEntity@ DB 'TempEntity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PFCNBPIC@?$FO1Error?3?$FO7?5no?5model?5?$CFd?$CB?6@
CONST	SEGMENT
??_C@_0BJ@PFCNBPIC@?$FO1Error?3?$FO7?5no?5model?5?$CFd?$CB?6@ DB '^1Error'
	DB	':^7 no model %d!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICEDCNLF@No?5model?5?$CFd?$CB?6@
CONST	SEGMENT
??_C@_0O@ICEDCNLF@No?5model?5?$CFd?$CB?6@ DB 'No model %d!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DIEJGHFK@?$FO1Error?3?$FO7?5No?5model?5?$CFd?$CB?6@
CONST	SEGMENT
??_C@_0BJ@DIEJGHFK@?$FO1Error?3?$FO7?5No?5model?5?$CFd?$CB?6@ DB '^1Error'
	DB	':^7 No model %d!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJBFKKAM@No?5Sprite?5?$CFd?$CB?6@
CONST	SEGMENT
??_C@_0P@FJBFKKAM@No?5Sprite?5?$CFd?$CB?6@ DB 'No Sprite %d!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FKBCOHFI@Couldn?8t?5alloc?5a?5high?5priority?5@
CONST	SEGMENT
??_C@_0CG@FKBCOHFI@Couldn?8t?5alloc?5a?5high?5priority?5@ DB 'Couldn''t a'
	DB	'lloc a high priority TENT!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IBFHIBLB@Overflow?5?$CFd?5temporary?5ents?$CB?6@
CONST	SEGMENT
??_C@_0BN@IBFHIBLB@Overflow?5?$CFd?5temporary?5ents?$CB?6@ DB 'Overflow %'
	DB	'd temporary ents!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LOGAJLJO@pEntity?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0BA@LOGAJLJO@pEntity?5?$CB?$DN?5NULL@ DB 'pEntity != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_TempEntAddEntity@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_TempEntAddEntity@@9@9 DD 01feH	; `CL_TempEntAddEntity'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@HDCPKBJB@debris?1concrete?$CFi?4wav@
CONST	SEGMENT
??_C@_0BG@HDCPKBJB@debris?1concrete?$CFi?4wav@ DB 'debris/concrete%i.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGHOLFCC@debris?1wood?$CFi?4wav@
CONST	SEGMENT
??_C@_0BC@IGHOLFCC@debris?1wood?$CFi?4wav@ DB 'debris/wood%i.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCJHLCL@debris?1flesh?$CFi?4wav@
CONST	SEGMENT
??_C@_0BD@HCJHLCL@debris?1flesh?$CFi?4wav@ DB 'debris/flesh%i.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDOGGPHL@debris?1metal?$CFi?4wav@
CONST	SEGMENT
??_C@_0BD@MDOGGPHL@debris?1metal?$CFi?4wav@ DB 'debris/metal%i.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LELGLKED@debris?1glass?$CFi?4wav@
CONST	SEGMENT
??_C@_0BD@LELGLKED@debris?1glass?$CFi?4wav@ DB 'debris/glass%i.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JHIJGBPP@pTemp?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0O@JHIJGBPP@pTemp?5?$CB?$DN?5NULL@ DB 'pTemp != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_TempEntPlaySound@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_TempEntPlaySound@@9@9 DD 01aaH	; `CL_TempEntPlaySound'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CL_FreeTempEnts@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_FreeTempEnts@@9@9 DD 016dH		; `CL_FreeTempEnts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??CL_InitTempEnts@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_InitTempEnts@@9@9 DD 0147H		; `CL_InitTempEnts'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBLIODKG@sound?1@
CONST	SEGMENT
??_C@_06PBLIODKG@sound?1@ DB 'sound/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_tent.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_AddClientResource@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_AddClientResource@@9@9 DD 076H	; `CL_AddClientResource'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03acH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	036aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0459H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0527H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	05cfH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0b5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	05deH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	035fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03bdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02b6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0513H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0613H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	052dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	056eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	01deH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0301H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	02bdH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0375H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0771H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01a4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	026b3H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ClearDlights
_TEXT	SEGMENT
_CL_ClearDlights PROC					; COMDAT

; 2594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2595 : 	memset( cl_dlights, 0, sizeof( cl_dlights ));

	push	1280					; 00000500H
	push	0
	push	OFFSET _cl_dlights
	call	_memset
	add	esp, 12					; 0000000cH

; 2596 : 	memset( cl_elights, 0, sizeof( cl_elights ));

	push	2560					; 00000a00H
	push	0
	push	OFFSET _cl_elights
	call	_memset
	add	esp, 12					; 0000000cH

; 2597 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearDlights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ClearLightStyles
_TEXT	SEGMENT
_CL_ClearLightStyles PROC				; COMDAT

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2537 : 	memset( cl.lightstyles, 0, sizeof( cl.lightstyles ));

	push	82944					; 00014400H
	push	0
	push	OFFSET _cl+2897300
	call	_memset
	add	esp, 12					; 0000000cH

; 2538 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearLightStyles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_FreeLowPriorityTempEnt
_TEXT	SEGMENT
_pPrev$ = -8						; size = 4
_pActive$ = -4						; size = 4
_CL_FreeLowPriorityTempEnt PROC				; COMDAT

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 564  : 	TEMPENTITY	*pActive = cl_active_tents;

	mov	eax, DWORD PTR _cl_active_tents
	mov	DWORD PTR _pActive$[ebp], eax

; 565  : 	TEMPENTITY	*pPrev = NULL;

	mov	DWORD PTR _pPrev$[ebp], 0
$LN2@CL_FreeLow:

; 566  : 
; 567  : 	while( pActive )

	cmp	DWORD PTR _pActive$[ebp], 0
	je	SHORT $LN3@CL_FreeLow

; 568  : 	{
; 569  : 		if( pActive->priority == TENTPRIORITY_LOW )

	mov	eax, DWORD PTR _pActive$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN4@CL_FreeLow

; 570  : 		{
; 571  : 			// remove from the active list.
; 572  : 			if( pPrev ) pPrev->next = pActive->next;

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $LN5@CL_FreeLow
	mov	eax, DWORD PTR _pPrev$[ebp]
	mov	ecx, DWORD PTR _pActive$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	jmp	SHORT $LN6@CL_FreeLow
$LN5@CL_FreeLow:

; 573  : 			else cl_active_tents = pActive->next;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _cl_active_tents, ecx
$LN6@CL_FreeLow:

; 574  : 
; 575  : 			// add to the free list.
; 576  : 			pActive->next = cl_free_tents;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	ecx, DWORD PTR _cl_free_tents
	mov	DWORD PTR [eax+44], ecx

; 577  : 			cl_free_tents = pActive;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	DWORD PTR _cl_free_tents, eax

; 578  : 
; 579  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_FreeLow
$LN4@CL_FreeLow:

; 580  : 		}
; 581  : 
; 582  : 		pPrev = pActive;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	DWORD PTR _pPrev$[ebp], eax

; 583  : 		pActive = pActive->next;

	mov	eax, DWORD PTR _pActive$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _pActive$[ebp], ecx

; 584  : 	}

	jmp	SHORT $LN2@CL_FreeLow
$LN3@CL_FreeLow:

; 585  : 
; 586  : 	return false;

	xor	eax, eax
$LN1@CL_FreeLow:

; 587  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeLowPriorityTempEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntAddEntity
_TEXT	SEGMENT
tv165 = -96						; size = 4
tv135 = -96						; size = 4
tv70 = -96						; size = 4
_maxs$ = -28						; size = 12
_mins$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pEntity$ = 8						; size = 4
_CL_TempEntAddEntity PROC				; COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 511  : 	vec3_t mins, maxs;
; 512  : 
; 513  : 	Assert( pEntity != NULL );

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $LN6@CL_TempEnt
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@CL_TempEnt
$LN6@CL_TempEnt:
	mov	DWORD PTR tv70[ebp], 0
$LN7@CL_TempEnt:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_TempEntAddEntity@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BA@LOGAJLJO@pEntity?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 514  : 
; 515  : 	if( !pEntity->model )

	mov	eax, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN2@CL_TempEnt

; 516  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN2@CL_TempEnt:

; 517  : 
; 518  : 	VectorAdd( pEntity->origin, pEntity->model->mins, mins );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+3300]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+3224]
	addss	xmm0, DWORD PTR [eax+edx+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+84]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _mins$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+84]
	movss	DWORD PTR tv135[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR _mins$[ebp+ecx], xmm0

; 519  : 	VectorAdd( pEntity->origin, pEntity->model->maxs, maxs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+3300]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+3224]
	addss	xmm0, DWORD PTR [eax+edx+96]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+96]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pEntity$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+3224]
	addss	xmm0, DWORD PTR [ecx+eax+96]
	movss	DWORD PTR tv165[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _maxs$[ebp+ecx], xmm0

; 520  : 
; 521  : 	// g-cont. just use PVS from previous frame
; 522  : 	if( TriBoxInPVS( mins, maxs ))

	lea	eax, DWORD PTR _maxs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$[ebp]
	push	ecx
	call	_TriBoxInPVS
	add	esp, 8
	test	eax, eax
	je	$LN3@CL_TempEnt

; 523  : 	{
; 524  : 		VectorCopy( pEntity->angles, pEntity->curstate.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3236]
	mov	DWORD PTR [edx+eax+940], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+3236]
	mov	DWORD PTR [ecx+eax+940], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+3236]
	mov	DWORD PTR [edx+ecx+940], eax

; 525  : 		VectorCopy( pEntity->origin, pEntity->curstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+928], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+928], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+928], eax

; 526  : 		VectorCopy( pEntity->angles, pEntity->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3236]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+3236]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+3236]
	mov	DWORD PTR [edx+ecx+3192], eax

; 527  : 		VectorCopy( pEntity->origin, pEntity->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	esi, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+3180], eax

; 528  : 	
; 529  : 		// add to list
; 530  : 		if( CL_AddVisibleEntity( pEntity, ET_TEMPENTITY ))

	push	2
	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@CL_TempEnt

; 531  : 			r_stats.c_active_tents_count++;

	mov	eax, DWORD PTR _r_stats+24
	add	eax, 1
	mov	DWORD PTR _r_stats+24, eax
$LN4@CL_TempEnt:

; 532  : 
; 533  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@CL_TempEnt
$LN3@CL_TempEnt:

; 534  : 	}
; 535  : 
; 536  : 	return 0;

	xor	eax, eax
$LN1@CL_TempEnt:

; 537  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntPlaySound
_TEXT	SEGMENT
tv208 = -124						; size = 4
tv197 = -124						; size = 4
tv73 = -124						; size = 4
tv70 = -124						; size = 4
_handle$1 = -56						; size = 4
_pitch$2 = -52						; size = 4
_zvel$ = -48						; size = 4
_isshellcasing$ = -44					; size = 4
_soundname$ = -40					; size = 32
_fvol$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTemp$ = 8						; size = 4
_damp$ = 12						; size = 4
_CL_TempEntPlaySound PROC				; COMDAT

; 426  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 427  : 	float	fvol;
; 428  : 	char	soundname[32];
; 429  : 	qboolean	isshellcasing = false;

	mov	DWORD PTR _isshellcasing$[ebp], 0

; 430  : 	int	zvel;
; 431  : 
; 432  : 	Assert( pTemp != NULL );

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN23@CL_TempEnt
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN24@CL_TempEnt
$LN23@CL_TempEnt:
	mov	DWORD PTR tv70[ebp], 0
$LN24@CL_TempEnt:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_TempEntPlaySound@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0O@JHIJGBPP@pTemp?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 433  : 
; 434  : 	fvol = 0.8f;

	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR _fvol$[ebp], xmm0

; 435  : 
; 436  : 	switch( pTemp->hitSound )

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	sub	edx, 1
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 127		; 0000007fH
	ja	$LN12@CL_TempEnt
	mov	eax, DWORD PTR tv73[ebp]
	movzx	ecx, BYTE PTR $LN29@CL_TempEnt[eax]
	jmp	DWORD PTR $LN30@CL_TempEnt[ecx*4]
$LN4@CL_TempEnt:

; 437  : 	{
; 438  : 	case BOUNCE_GLASS:
; 439  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/glass%i.wav", COM_RandomLong( 1, 4 ));

	push	4
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BD@LELGLKED@debris?1glass?$CFi?4wav@
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 440  : 		break;

	jmp	$LN2@CL_TempEnt
$LN5@CL_TempEnt:

; 441  : 	case BOUNCE_METAL:
; 442  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/metal%i.wav", COM_RandomLong( 1, 6 ));

	push	6
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BD@MDOGGPHL@debris?1metal?$CFi?4wav@
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 443  : 		break;

	jmp	$LN2@CL_TempEnt
$LN6@CL_TempEnt:

; 444  : 	case BOUNCE_FLESH:
; 445  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/flesh%i.wav", COM_RandomLong( 1, 7 ));

	push	7
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BD@HCJHLCL@debris?1flesh?$CFi?4wav@
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 446  : 		break;

	jmp	$LN2@CL_TempEnt
$LN7@CL_TempEnt:

; 447  : 	case BOUNCE_WOOD:
; 448  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/wood%i.wav", COM_RandomLong( 1, 4 ));

	push	4
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BC@IGHOLFCC@debris?1wood?$CFi?4wav@
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 449  : 		break;

	jmp	$LN2@CL_TempEnt
$LN8@CL_TempEnt:

; 450  : 	case BOUNCE_SHRAP:
; 451  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_ricochet_sounds[COM_RandomLong( 0, 4 )] );

	push	4
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_ricochet_sounds[eax*4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 452  : 		break;

	jmp	$LN2@CL_TempEnt
$LN9@CL_TempEnt:

; 453  : 	case BOUNCE_SHOTSHELL:
; 454  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_weapon_shell_sounds[COM_RandomLong( 0, 2 )] );

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_weapon_shell_sounds[eax*4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 455  : 		isshellcasing = true; // shell casings have different playback parameters

	mov	DWORD PTR _isshellcasing$[ebp], 1

; 456  : 		fvol = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _fvol$[ebp], xmm0

; 457  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN10@CL_TempEnt:

; 458  : 	case BOUNCE_SHELL:
; 459  : 		Q_snprintf( soundname, sizeof( soundname ), "%s", cl_player_shell_sounds[COM_RandomLong( 0, 2 )] );

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_player_shell_sounds[eax*4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundname$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 460  : 		isshellcasing = true; // shell casings have different playback parameters

	mov	DWORD PTR _isshellcasing$[ebp], 1

; 461  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN11@CL_TempEnt:

; 462  : 	case BOUNCE_CONCRETE:
; 463  : 		Q_snprintf( soundname, sizeof( soundname ), "debris/concrete%i.wav", COM_RandomLong( 1, 3 ));

	push	3
	push	1
	call	_COM_RandomLong
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BG@HDCPKBJB@debris?1concrete?$CFi?4wav@
	push	32					; 00000020H
	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 464  : 		break;

	jmp	SHORT $LN2@CL_TempEnt
$LN12@CL_TempEnt:

; 465  : 	default:	// null sound
; 466  : 		return;

	jmp	$LN17@CL_TempEnt
$LN2@CL_TempEnt:

; 467  : 	}
; 468  : 
; 469  : 	zvel = abs( pTemp->entity.baseline.origin[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax+92]
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _zvel$[ebp], eax

; 470  : 		
; 471  : 	// only play one out of every n
; 472  : 	if( isshellcasing )

	cmp	DWORD PTR _isshellcasing$[ebp], 0
	je	SHORT $LN13@CL_TempEnt

; 473  : 	{	
; 474  : 		// play first bounce, then 1 out of 3		
; 475  : 		if( zvel < 200 && COM_RandomLong( 0, 3 ))

	cmp	DWORD PTR _zvel$[ebp], 200		; 000000c8H
	jge	SHORT $LN15@CL_TempEnt
	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@CL_TempEnt

; 476  : 			return;

	jmp	$LN17@CL_TempEnt
$LN15@CL_TempEnt:

; 477  : 	}

	jmp	SHORT $LN16@CL_TempEnt
$LN13@CL_TempEnt:

; 478  : 	else
; 479  : 	{
; 480  : 		if( COM_RandomLong( 0, 5 )) 

	push	5
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@CL_TempEnt

; 481  : 			return;

	jmp	$LN17@CL_TempEnt
$LN16@CL_TempEnt:

; 482  : 	}
; 483  : 
; 484  : 	if( damp > 0.0f )

	movss	xmm0, DWORD PTR _damp$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN17@CL_TempEnt

; 485  : 	{
; 486  : 		int	pitch;
; 487  : 		sound_t	handle;
; 488  : 		
; 489  : 		if( isshellcasing )

	cmp	DWORD PTR _isshellcasing$[ebp], 0
	je	SHORT $LN18@CL_TempEnt

; 490  : 			fvol *= min ( 1.0f, ((float)zvel) / 350.0f ); 

	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43af0000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN25@CL_TempEnt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv197[ebp], xmm0
	jmp	SHORT $LN26@CL_TempEnt
$LN25@CL_TempEnt:
	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43af0000
	movss	DWORD PTR tv197[ebp], xmm0
$LN26@CL_TempEnt:
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR tv197[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0
	jmp	SHORT $LN19@CL_TempEnt
$LN18@CL_TempEnt:

; 491  : 		else fvol *= min ( 1.0f, ((float)zvel) / 450.0f ); 

	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN27@CL_TempEnt
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv208[ebp], xmm0
	jmp	SHORT $LN28@CL_TempEnt
$LN27@CL_TempEnt:
	cvtsi2ss xmm0, DWORD PTR _zvel$[ebp]
	divss	xmm0, DWORD PTR __real@43e10000
	movss	DWORD PTR tv208[ebp], xmm0
$LN28@CL_TempEnt:
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR tv208[ebp]
	movss	DWORD PTR _fvol$[ebp], xmm0
$LN19@CL_TempEnt:

; 492  : 		
; 493  : 		if( !COM_RandomLong( 0, 3 ) && !isshellcasing )

	push	3
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@CL_TempEnt
	cmp	DWORD PTR _isshellcasing$[ebp], 0
	jne	SHORT $LN20@CL_TempEnt

; 494  : 			pitch = COM_RandomLong( 95, 105 );

	push	105					; 00000069H
	push	95					; 0000005fH
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _pitch$2[ebp], eax
	jmp	SHORT $LN21@CL_TempEnt
$LN20@CL_TempEnt:

; 495  : 		else pitch = PITCH_NORM;

	mov	DWORD PTR _pitch$2[ebp], 100		; 00000064H
$LN21@CL_TempEnt:

; 496  : 
; 497  : 		handle = S_RegisterSound( soundname );

	lea	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$1[ebp], eax

; 498  : 		S_StartSound( pTemp->entity.origin, -(pTemp - cl_tempents), CHAN_BODY, handle, fvol, ATTN_NORM, pitch, SND_STOP_LOOPING );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _pitch$2[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$1[ebp]
	push	ecx
	push	4
	mov	eax, DWORD PTR _pTemp$[ebp]
	sub	eax, DWORD PTR _cl_tempents
	cdq
	mov	ecx, 3404				; 00000d4cH
	idiv	ecx
	neg	eax
	push	eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	add	edx, 3292				; 00000cdcH
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN17@CL_TempEnt:

; 499  : 	}
; 500  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@CL_TempEnt:
	DD	$LN4@CL_TempEnt
	DD	$LN5@CL_TempEnt
	DD	$LN6@CL_TempEnt
	DD	$LN7@CL_TempEnt
	DD	$LN8@CL_TempEnt
	DD	$LN10@CL_TempEnt
	DD	$LN11@CL_TempEnt
	DD	$LN9@CL_TempEnt
	DD	$LN12@CL_TempEnt
$LN29@CL_TempEnt:
	DB	0
	DB	1
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
_CL_TempEntPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_PrepareTEnt
_TEXT	SEGMENT
tv88 = -80						; size = 4
_modelHandle$ = -12					; size = 4
_modelIndex$ = -8					; size = 4
_frameCount$ = -4					; size = 4
_pTemp$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_PrepareTEnt PROC					; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 380  : 	int	frameCount = 0;

	mov	DWORD PTR _frameCount$[ebp], 0

; 381  : 	int	modelIndex = 0;

	mov	DWORD PTR _modelIndex$[ebp], 0

; 382  : 	int	modelHandle = pTemp->entity.trivial_accept;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+3364]
	mov	DWORD PTR _modelHandle$[ebp], ecx

; 383  : 
; 384  : 	memset( pTemp, 0, sizeof( *pTemp ));

	push	3404					; 00000d4cH
	push	0
	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 385  : 
; 386  : 	// use these to set per-frame and termination conditions / actions
; 387  : 	pTemp->entity.trivial_accept = modelHandle; // keep unchanged

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _modelHandle$[ebp]
	mov	DWORD PTR [eax+3364], ecx

; 388  : 	pTemp->flags = FTENT_NONE;		

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 0

; 389  : 	pTemp->die = cl.time + 0.75f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fe8000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 390  : 
; 391  : 	if( pmodel ) frameCount = pmodel->numframes;

	cmp	DWORD PTR _pmodel$[ebp], 0
	je	SHORT $LN2@CL_Prepare
	mov	eax, DWORD PTR _pmodel$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _frameCount$[ebp], ecx
	jmp	SHORT $LN3@CL_Prepare
$LN2@CL_Prepare:

; 392  : 	else pTemp->flags |= FTENT_NOMODEL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN3@CL_Prepare:

; 393  : 
; 394  : 	pTemp->entity.curstate.modelindex = modelIndex;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	mov	DWORD PTR [eax+1020], ecx

; 395  : 	pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 0

; 396  : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 0

; 397  : 	pTemp->entity.curstate.rendercolor.r = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [eax+1060], 255		; 000000ffH

; 398  : 	pTemp->entity.curstate.rendercolor.g = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [eax+1061], 255		; 000000ffH

; 399  : 	pTemp->entity.curstate.rendercolor.b = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	BYTE PTR [eax+1062], 255		; 000000ffH

; 400  : 	pTemp->frameMax = Q_max( 0, frameCount - 1 );

	mov	eax, DWORD PTR _frameCount$[ebp]
	sub	eax, 1
	jns	SHORT $LN5@CL_Prepare
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN6@CL_Prepare
$LN5@CL_Prepare:
	mov	ecx, DWORD PTR _frameCount$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv88[ebp], ecx
$LN6@CL_Prepare:
	cvtsi2ss xmm0, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 401  : 	pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 402  : 	pTemp->entity.curstate.body = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1100], 0

; 403  : 	pTemp->entity.curstate.skin = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1116], 0

; 404  : 	pTemp->entity.curstate.viewmodelbody = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1104], 0

; 405  : 	pTemp->entity.curstate.armmodelbody = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1112], 0

; 406  : 	pTemp->entity.curstate.playmodelbody = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1108], 0

; 407  : 	pTemp->entity.curstate.viewmodelskin = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1120], 0

; 408  : 	pTemp->entity.curstate.armmodelskin = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1124], 0

; 409  : 	pTemp->entity.curstate.playmodelskin = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1128], 0

; 410  : 	pTemp->entity.model = pmodel;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pmodel$[ebp]
	mov	DWORD PTR [eax+3368], ecx

; 411  : 	pTemp->fadeSpeed = 0.5f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+24], xmm0

; 412  : 	pTemp->hitSound = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+32], 0

; 413  : 	pTemp->clientIndex = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	WORD PTR [ecx+52], ax

; 414  : 	pTemp->bounceFactor = 1;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+28], xmm0

; 415  : 	pTemp->entity.curstate.scale = 1.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1044], xmm0

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PrepareTEnt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_DecalIndex
_TEXT	SEGMENT
tv67 = -72						; size = 4
tv66 = -68						; size = 4
_id$ = 8						; size = 4
_CL_DecalIndex PROC					; COMDAT

; 3067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3068 : 	id = bound( 0, id, MAX_DECALS - 1 );

	cmp	DWORD PTR _id$[ebp], 0
	jl	SHORT $LN6@CL_DecalIn
	cmp	DWORD PTR _id$[ebp], 511		; 000001ffH
	jge	SHORT $LN4@CL_DecalIn
	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN5@CL_DecalIn
$LN4@CL_DecalIn:
	mov	DWORD PTR tv66[ebp], 511		; 000001ffH
$LN5@CL_DecalIn:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN7@CL_DecalIn
$LN6@CL_DecalIn:
	mov	DWORD PTR tv67[ebp], 0
$LN7@CL_DecalIn:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 3069 : 
; 3070 : 	if( cl.decal_index[id] == 0 )

	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4577980]
	test	ecx, ecx
	jne	SHORT $LN2@CL_DecalIn

; 3071 : 	{
; 3072 : 		Image_SetForceFlags( IL_LOAD_DECAL );

	push	32					; 00000020H
	call	_Image_SetForceFlags
	add	esp, 4

; 3073 : 		cl.decal_index[id] = GL_LoadTexture( host.draw_decals[id], NULL, 0, TF_DECAL );

	push	2048					; 00000800H
	push	0
	push	0
	mov	eax, DWORD PTR _id$[ebp]
	shl	eax, 6
	add	eax, OFFSET _host+1468
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _id$[ebp]
	mov	WORD PTR _cl[ecx*2+4577980], ax

; 3074 : 		Image_ClearForceFlags();

	call	_Image_ClearForceFlags
$LN2@CL_DecalIn:

; 3075 : 	}
; 3076 : 
; 3077 : 	return cl.decal_index[id];

	mov	eax, DWORD PTR _id$[ebp]
	movsx	eax, WORD PTR _cl[eax*2+4577980]

; 3078 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_DecalIndexFromName
_TEXT	SEGMENT
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_DecalIndexFromName PROC				; COMDAT

; 3044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3045 : 	int	i;
; 3046 : 
; 3047 : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_DecalIn

; 3048 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DecalIn
$LN5@CL_DecalIn:

; 3049 : 
; 3050 : 	// look through the loaded sprite name list for SpriteName
; 3051 : 	for( i = 1; i < MAX_DECALS && host.draw_decals[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_DecalIn
$LN2@CL_DecalIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_DecalIn:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@CL_DecalIn
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _host[eax+edx+1468]
	test	eax, eax
	je	SHORT $LN3@CL_DecalIn

; 3052 : 	{
; 3053 : 		if( !Q_stricmp( name, host.draw_decals[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	add	eax, OFFSET _host+1468
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_DecalIn

; 3054 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@CL_DecalIn
$LN6@CL_DecalIn:

; 3055 : 	}

	jmp	SHORT $LN2@CL_DecalIn
$LN3@CL_DecalIn:

; 3056 : 	return 0; // invalid decal

	xor	eax, eax
$LN1@CL_DecalIn:

; 3057 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalIndexFromName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_DecalRemoveAll
_TEXT	SEGMENT
tv67 = -76						; size = 4
tv66 = -72						; size = 4
_id$ = -4						; size = 4
_textureIndex$ = 8					; size = 4
_CL_DecalRemoveAll PROC					; COMDAT

; 3088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3089 : 	int id = bound( 0, textureIndex, MAX_DECALS - 1 );	

	cmp	DWORD PTR _textureIndex$[ebp], 0
	jl	SHORT $LN5@CL_DecalRe
	cmp	DWORD PTR _textureIndex$[ebp], 511	; 000001ffH
	jge	SHORT $LN3@CL_DecalRe
	mov	eax, DWORD PTR _textureIndex$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@CL_DecalRe
$LN3@CL_DecalRe:
	mov	DWORD PTR tv66[ebp], 511		; 000001ffH
$LN4@CL_DecalRe:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@CL_DecalRe
$LN5@CL_DecalRe:
	mov	DWORD PTR tv67[ebp], 0
$LN6@CL_DecalRe:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _id$[ebp], edx

; 3090 : 	R_DecalRemoveAll( cl.decal_index[id] );

	mov	eax, DWORD PTR _id$[ebp]
	movsx	ecx, WORD PTR _cl[eax*2+4577980]
	push	ecx
	call	_R_DecalRemoveAll
	add	esp, 4

; 3091 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalRemoveAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AddModelEffects
_TEXT	SEGMENT
tv257 = -100						; size = 4
tv68 = -100						; size = 4
_dl$1 = -32						; size = 4
_oldorigin$ = -28					; size = 12
_neworigin$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_AddModelEffects PROC				; COMDAT

; 2872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2873 : 	vec3_t	neworigin;
; 2874 : 	vec3_t	oldorigin;
; 2875 : 
; 2876 : 	if( !ent->model ) return;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN4@CL_AddMode
	jmp	$LN19@CL_AddMode
$LN4@CL_AddMode:

; 2877 : 
; 2878 : 	switch( ent->model->type )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 2
	je	SHORT $LN5@CL_AddMode
	cmp	DWORD PTR tv68[ebp], 3
	je	SHORT $LN5@CL_AddMode
	jmp	SHORT $LN7@CL_AddMode
$LN5@CL_AddMode:

; 2879 : 	{
; 2880 : 	case mod_alias:
; 2881 : 	case mod_studio:
; 2882 : 		break;

	jmp	SHORT $LN2@CL_AddMode
$LN7@CL_AddMode:

; 2883 : 	default:	return;

	jmp	$LN19@CL_AddMode
$LN2@CL_AddMode:

; 2884 : 	}
; 2885 : 
; 2886 : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	$LN8@CL_AddMode

; 2887 : 	{
; 2888 : 		VectorCopy( ent->baseline.vuser1, oldorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+412]
	mov	DWORD PTR _oldorigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+412]
	mov	DWORD PTR _oldorigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+412]
	mov	DWORD PTR _oldorigin$[ebp+ecx], eax

; 2889 : 		VectorCopy( ent->origin, ent->baseline.vuser1 );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+412], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+412], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+412], eax

; 2890 : 		VectorCopy( ent->origin, neworigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _neworigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _neworigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _neworigin$[ebp+ecx], eax

; 2891 : 	}

	jmp	$LN9@CL_AddMode
$LN8@CL_AddMode:

; 2892 : 	else
; 2893 : 	{
; 2894 : 		VectorCopy( ent->prevstate.origin, oldorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+476]
	mov	DWORD PTR _oldorigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+476]
	mov	DWORD PTR _oldorigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+476]
	mov	DWORD PTR _oldorigin$[ebp+ecx], eax

; 2895 : 		VectorCopy( ent->curstate.origin, neworigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+928]
	mov	DWORD PTR _neworigin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+928]
	mov	DWORD PTR _neworigin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+928]
	mov	DWORD PTR _neworigin$[ebp+ecx], eax
$LN9@CL_AddMode:

; 2896 : 	}
; 2897 : 
; 2898 : 	// NOTE: this completely over control about angles and don't broke interpolation
; 2899 : 	if( FBitSet( ent->model->flags, STUDIO_ROTATE ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN10@CL_AddMode

; 2900 : 		ent->angles[1] = anglemod( 100.0f * cl.time );

	movsd	xmm0, QWORD PTR __real@4059000000000000
	mulsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [ecx+eax+3236]
$LN10@CL_AddMode:

; 2901 : 
; 2902 : 	if( FBitSet( ent->model->flags, STUDIO_GIB ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 4
	je	SHORT $LN11@CL_AddMode

; 2903 : 		R_RocketTrail( oldorigin, neworigin, 2 );

	push	2
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN11@CL_AddMode:

; 2904 : 
; 2905 : 	if( FBitSet( ent->model->flags, STUDIO_ZOMGIB ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 32					; 00000020H
	je	SHORT $LN12@CL_AddMode

; 2906 : 		R_RocketTrail( oldorigin, neworigin, 4 );

	push	4
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN12@CL_AddMode:

; 2907 : 
; 2908 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 16					; 00000010H
	je	SHORT $LN13@CL_AddMode

; 2909 : 		R_RocketTrail( oldorigin, neworigin, 3 );

	push	3
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN13@CL_AddMode:

; 2910 : 
; 2911 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER2 ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 64					; 00000040H
	je	SHORT $LN14@CL_AddMode

; 2912 : 		R_RocketTrail( oldorigin, neworigin, 5 );

	push	5
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN14@CL_AddMode:

; 2913 : 
; 2914 : 	if( FBitSet( ent->model->flags, STUDIO_ROCKET ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 1
	je	$LN15@CL_AddMode

; 2915 : 	{
; 2916 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 2917 : 
; 2918 : 		dl->color.r = dl->color.g = dl->color.b = 200;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+18], 200			; 000000c8H
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [ecx+17], 200			; 000000c8H
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [edx+16], 200			; 000000c8H

; 2919 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 2920 : 
; 2921 : 		// XASH SPECIFIC: get radius from head entity
; 2922 : 		if( ent->curstate.rendermode != kRenderNormal )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN16@CL_AddMode

; 2923 : 			dl->radius = Q_max( 0, ent->curstate.renderamt - 55 );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	sub	ecx, 55					; 00000037H
	jns	SHORT $LN21@CL_AddMode
	mov	DWORD PTR tv257[ebp], 0
	jmp	SHORT $LN22@CL_AddMode
$LN21@CL_AddMode:
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+988]
	sub	eax, 55					; 00000037H
	mov	DWORD PTR tv257[ebp], eax
$LN22@CL_AddMode:
	cvtsi2ss xmm0, DWORD PTR tv257[ebp]
	mov	ecx, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	jmp	SHORT $LN17@CL_AddMode
$LN16@CL_AddMode:

; 2924 : 		else dl->radius = 200;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [eax+12], xmm0
$LN17@CL_AddMode:

; 2925 : 
; 2926 : 		dl->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2927 : 
; 2928 : 		R_RocketTrail( oldorigin, neworigin, 0 );

	push	0
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN15@CL_AddMode:

; 2929 : 	}
; 2930 : 
; 2931 : 	if( FBitSet( ent->model->flags, STUDIO_GRENADE ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 2
	je	SHORT $LN18@CL_AddMode

; 2932 : 		R_RocketTrail( oldorigin, neworigin, 1 );

	push	1
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN18@CL_AddMode:

; 2933 : 
; 2934 : 	if( FBitSet( ent->model->flags, STUDIO_TRACER3 ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 128				; 00000080H
	je	SHORT $LN19@CL_AddMode

; 2935 : 		R_RocketTrail( oldorigin, neworigin, 6 );

	push	6
	lea	eax, DWORD PTR _neworigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldorigin$[ebp]
	push	ecx
	call	_R_RocketTrail
	add	esp, 12					; 0000000cH
$LN19@CL_AddMode:

; 2936 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddModelEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AddEntityEffects
_TEXT	SEGMENT
tv291 = -100						; size = 4
_fv$1 = -32						; size = 12
_dl$2 = -20						; size = 4
_dl$3 = -16						; size = 4
_dl$4 = -12						; size = 4
_dl$5 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_AddEntityEffects PROC				; COMDAT

; 2803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2804 : 	// yellow flies effect 'monster stuck in the wall'
; 2805 : 	if( FBitSet( ent->curstate.effects, EF_BRIGHTFIELD ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 1
	je	SHORT $LN2@CL_AddEnti

; 2806 : 		R_EntityParticles( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_R_EntityParticles
	add	esp, 4
$LN2@CL_AddEnti:

; 2807 : 
; 2808 : 	if( FBitSet( ent->curstate.effects, EF_DIMLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 8
	je	$LN5@CL_AddEnti

; 2809 : 	{
; 2810 : 		if( ent->player && !CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@CL_AddEnti
	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN4@CL_AddEnti

; 2811 : 		{
; 2812 : 			CL_UpdateFlashlight( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_UpdateFlashlight
	add	esp, 4

; 2813 : 		}

	jmp	$LN5@CL_AddEnti
$LN4@CL_AddEnti:

; 2814 : 		else
; 2815 : 		{
; 2816 : 			dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$5[ebp], eax

; 2817 : 			dl->color.r = dl->color.g = dl->color.b = 100;

	mov	eax, DWORD PTR _dl$5[ebp]
	mov	BYTE PTR [eax+18], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$5[ebp]
	mov	BYTE PTR [ecx+17], 100			; 00000064H
	mov	edx, DWORD PTR _dl$5[ebp]
	mov	BYTE PTR [edx+16], 100			; 00000064H

; 2818 : 			dl->radius = COM_RandomFloat( 200, 231 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43670000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _dl$5[ebp]
	fstp	DWORD PTR [eax+12]

; 2819 : 			VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$5[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$5[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$5[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 2820 : 			dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$5[ebp]
	movss	DWORD PTR [eax+20], xmm0
$LN5@CL_AddEnti:

; 2821 : 		}
; 2822 : 	}	
; 2823 : 
; 2824 : 	if( FBitSet( ent->curstate.effects, EF_BRIGHTLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 4
	je	$LN6@CL_AddEnti

; 2825 : 	{			
; 2826 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$4[ebp], eax

; 2827 : 		dl->color.r = dl->color.g = dl->color.b = 250;

	mov	eax, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [eax+18], 250			; 000000faH
	mov	ecx, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [ecx+17], 250			; 000000faH
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	BYTE PTR [edx+16], 250			; 000000faH

; 2828 : 		if( ent->player ) dl->radius = 400; // don't flickering

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN7@CL_AddEnti
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [eax+12], xmm0
	jmp	SHORT $LN8@CL_AddEnti
$LN7@CL_AddEnti:

; 2829 : 		else dl->radius = COM_RandomFloat( 400, 431 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43d78000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _dl$4[ebp]
	fstp	DWORD PTR [eax+12]
$LN8@CL_AddEnti:

; 2830 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$4[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 2831 : 		dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2832 : 		dl->origin[2] += 16.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$4[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$4[ebp]
	movss	DWORD PTR [eax+edx], xmm0
$LN6@CL_AddEnti:

; 2833 : 	}
; 2834 : 
; 2835 : 	// add light effect
; 2836 : 	if( FBitSet( ent->curstate.effects, EF_LIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 64					; 00000040H
	je	$LN9@CL_AddEnti

; 2837 : 	{
; 2838 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$3[ebp], eax

; 2839 : 		dl->color.r = dl->color.g = dl->color.b = 100;

	mov	eax, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [eax+18], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [ecx+17], 100			; 00000064H
	mov	edx, DWORD PTR _dl$3[ebp]
	mov	BYTE PTR [edx+16], 100			; 00000064H

; 2840 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$3[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 2841 : 		R_RocketFlare( ent->origin );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	call	_R_RocketFlare
	add	esp, 4

; 2842 : 		dl->die = cl.time + 0.001;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f50624dd2f1a9fc
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$3[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2843 : 		dl->radius = 200;

	mov	eax, DWORD PTR _dl$3[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [eax+12], xmm0
$LN9@CL_AddEnti:

; 2844 : 	}
; 2845 : 
; 2846 : 	// studio models are handle muzzleflashes difference
; 2847 : 	if( FBitSet( ent->curstate.effects, EF_MUZZLEFLASH ) && Mod_AliasExtradata( ent->model ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 2
	je	$LN10@CL_AddEnti
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	call	_Mod_AliasExtradata
	add	esp, 4
	test	eax, eax
	je	$LN10@CL_AddEnti

; 2848 : 	{
; 2849 : 		dlight_t	*dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$2[ebp], eax

; 2850 : 		vec3_t	fv;
; 2851 : 
; 2852 : 		ClearBits( ent->curstate.effects, EF_MUZZLEFLASH );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+972], ecx

; 2853 : 		dl->color.r = dl->color.g = dl->color.b = 100;

	mov	eax, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [eax+18], 100			; 00000064H
	mov	ecx, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [ecx+17], 100			; 00000064H
	mov	edx, DWORD PTR _dl$2[ebp]
	mov	BYTE PTR [edx+16], 100			; 00000064H

; 2854 : 		VectorCopy( ent->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$2[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 2855 : 		AngleVectors( ent->angles, fv, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _fv$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2856 : 		dl->origin[2] += 16.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _dl$2[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$2[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 2857 : 		VectorMA( dl->origin, 18, fv, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$1[ebp+eax]
	mov	edx, DWORD PTR _dl$2[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dl$2[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$1[ebp+ecx]
	mov	edx, DWORD PTR _dl$2[ebp]
	addss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$2[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@41900000
	mulss	xmm0, DWORD PTR _fv$1[ebp+eax]
	mov	ecx, DWORD PTR _dl$2[ebp]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm1, xmm0
	movss	DWORD PTR tv291[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _dl$2[ebp]
	movss	xmm0, DWORD PTR tv291[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 2858 : 		dl->radius = COM_RandomFloat( 200, 231 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43670000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _dl$2[ebp]
	fstp	DWORD PTR [eax+12]

; 2859 : 		dl->die = cl.time + 0.1;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fb999999999999a
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$2[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2860 : 		dl->minlight = 32;

	mov	eax, DWORD PTR _dl$2[ebp]
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR [eax+28], xmm0
$LN10@CL_AddEnti:

; 2861 : 	}
; 2862 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddEntityEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_UpdateFlashlight
_TEXT	SEGMENT
tv288 = -152						; size = 4
tv276 = -152						; size = 4
tv264 = -152						; size = 4
tv287 = -148						; size = 4
tv275 = -148						; size = 4
tv263 = -148						; size = 4
tv189 = -148						; size = 4
tv165 = -148						; size = 4
_v_angle$1 = -80					; size = 12
_dl$ = -68						; size = 4
_hit$ = -64						; size = 4
_trace$ = -60						; size = 4
_falloff$ = -56						; size = 4
_vecEnd$ = -52						; size = 12
_vecSrc$ = -40						; size = 12
_view_ofs$ = -28					; size = 12
_forward$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_UpdateFlashlight PROC				; COMDAT

; 2734 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2735 : 	vec3_t		forward, view_ofs;
; 2736 : 	vec3_t		vecSrc, vecEnd;
; 2737 : 	float		falloff;
; 2738 : 	pmtrace_t		*trace;
; 2739 : 	cl_entity_t	*hit;
; 2740 : 	dlight_t		*dl;
; 2741 : 
; 2742 : 	if( ent->index == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN2@CL_UpdateF

; 2743 : 	{
; 2744 : 		// local player case
; 2745 : 		AngleVectors( cl.viewangles, forward, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _forward$[ebp]
	push	eax
	push	OFFSET _cl+2212784
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2746 : 		VectorCopy( cl.viewheight, view_ofs );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212796]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212796]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212796]
	mov	DWORD PTR _view_ofs$[ebp+eax], ecx

; 2747 : 	}

	jmp	$LN5@CL_UpdateF
$LN2@CL_UpdateF:

; 2748 : 	else	// non-local player case
; 2749 : 	{
; 2750 : 		vec3_t	v_angle;
; 2751 : 
; 2752 : 		// NOTE: pitch divided by 3.0 twice. So we need apply 3^2 = 9
; 2753 : 		v_angle[PITCH] = ent->curstate.angles[PITCH] * 9.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+940]
	mulss	xmm0, DWORD PTR __real@41100000
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _v_angle$1[ebp+ecx], xmm0

; 2754 : 		v_angle[YAW] = ent->angles[YAW];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+3236]
	mov	DWORD PTR _v_angle$1[ebp+ecx], eax

; 2755 : 		v_angle[ROLL] = 0.0f; // roll not used

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _v_angle$1[ebp+eax], xmm0

; 2756 : 
; 2757 : 		AngleVectors( v_angle, forward, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _forward$[ebp]
	push	eax
	lea	ecx, DWORD PTR _v_angle$1[ebp]
	push	ecx
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 2758 : 		view_ofs[0] = view_ofs[1] = 0.0f;

	mov	eax, 4
	shl	eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _view_ofs$[ebp+eax], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _view_ofs$[ebp+edx], xmm0

; 2759 : 
; 2760 : 		// FIXME: these values are hardcoded ...
; 2761 : 		if( ent->curstate.usehull == 1 )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1224], 1
	jne	SHORT $LN4@CL_UpdateF

; 2762 : 			view_ofs[2] = 12.0f;	// VEC_DUCK_VIEW;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR _view_ofs$[ebp+eax], xmm0
	jmp	SHORT $LN5@CL_UpdateF
$LN4@CL_UpdateF:

; 2763 : 		else view_ofs[2] = 28.0f;		// DEFAULT_VIEWHEIGHT

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@41e00000
	movss	DWORD PTR _view_ofs$[ebp+eax], xmm0
$LN5@CL_UpdateF:

; 2764 : 	}
; 2765 : 
; 2766 : 	VectorAdd( ent->origin, view_ofs, vecSrc );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR _view_ofs$[ebp+ecx]
	movss	DWORD PTR tv165[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv165[ebp]
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 2767 : 	VectorMA( vecSrc, FLASHLIGHT_DISTANCE, forward, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+ecx]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@44fa0000
	mulss	xmm0, DWORD PTR _forward$[ebp+ecx]
	movss	xmm1, DWORD PTR _vecSrc$[ebp+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv189[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv189[ebp]
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0

; 2768 : 
; 2769 : 	trace = CL_VisTraceLine( vecSrc, vecEnd, PM_STUDIO_BOX );

	push	2
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	_CL_VisTraceLine
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _trace$[ebp], eax

; 2770 : 
; 2771 : 	// update flashlight endpos
; 2772 : 	dl = CL_AllocDlight( ent->index );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2773 : #if 1
; 2774 : 	hit = CL_GetEntityByIndex( clgame.pmove->visents[trace->ent].info );

	mov	eax, DWORD PTR _trace$[ebp]
	imul	ecx, DWORD PTR [eax+48], 224
	mov	edx, DWORD PTR _clgame+1344
	mov	eax, DWORD PTR [edx+ecx+149416]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _hit$[ebp], eax

; 2775 : 	if( hit && hit->model && ( hit->model->type == mod_alias || hit->model->type == mod_studio ))

	cmp	DWORD PTR _hit$[ebp], 0
	je	$LN6@CL_UpdateF
	mov	eax, DWORD PTR _hit$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN6@CL_UpdateF
	mov	eax, DWORD PTR _hit$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	je	SHORT $LN8@CL_UpdateF
	mov	eax, DWORD PTR _hit$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN6@CL_UpdateF
$LN8@CL_UpdateF:

; 2776 : 		VectorCopy( hit->origin, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _hit$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax
	jmp	SHORT $LN7@CL_UpdateF
$LN6@CL_UpdateF:

; 2777 : 	else VectorCopy( trace->endpos, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+20]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	edx, DWORD PTR [esi+edx+20]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	mov	esi, DWORD PTR _trace$[ebp]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+ecx], eax
$LN7@CL_UpdateF:

; 2778 : #else
; 2779 : 	VectorCopy( trace->endpos, dl->origin );
; 2780 : #endif
; 2781 : 	// compute falloff
; 2782 : 	falloff = trace->fraction * FLASHLIGHT_DISTANCE;

	mov	eax, DWORD PTR _trace$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR __real@44fa0000
	movss	DWORD PTR _falloff$[ebp], xmm0

; 2783 : 	if( falloff < 500.0f ) falloff = 1.0f;

	movss	xmm0, DWORD PTR __real@43fa0000
	comiss	xmm0, DWORD PTR _falloff$[ebp]
	jbe	SHORT $LN9@CL_UpdateF
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _falloff$[ebp], xmm0
	jmp	SHORT $LN10@CL_UpdateF
$LN9@CL_UpdateF:

; 2784 : 	else falloff = 500.0f / falloff;

	movss	xmm0, DWORD PTR __real@43fa0000
	divss	xmm0, DWORD PTR _falloff$[ebp]
	movss	DWORD PTR _falloff$[ebp], xmm0
$LN10@CL_UpdateF:

; 2785 : 	falloff *= falloff;

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR _falloff$[ebp]
	movss	DWORD PTR _falloff$[ebp], xmm0

; 2786 : 
; 2787 : 	// apply brigthness to dlight			
; 2788 : 	dl->color.r = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN14@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN12@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv263[ebp], xmm0
	jmp	SHORT $LN13@CL_UpdateF
$LN12@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv263[ebp], xmm0
$LN13@CL_UpdateF:
	movss	xmm0, DWORD PTR tv263[ebp]
	movss	DWORD PTR tv264[ebp], xmm0
	jmp	SHORT $LN15@CL_UpdateF
$LN14@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv264[ebp], xmm0
$LN15@CL_UpdateF:
	cvttss2si eax, DWORD PTR tv264[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+16], al

; 2789 : 	dl->color.g = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN18@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN16@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv275[ebp], xmm0
	jmp	SHORT $LN17@CL_UpdateF
$LN16@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv275[ebp], xmm0
$LN17@CL_UpdateF:
	movss	xmm0, DWORD PTR tv275[ebp]
	movss	DWORD PTR tv276[ebp], xmm0
	jmp	SHORT $LN19@CL_UpdateF
$LN18@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv276[ebp], xmm0
$LN19@CL_UpdateF:
	cvttss2si eax, DWORD PTR tv276[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2790 : 	dl->color.b = bound( 0, falloff * 255, 255 );

	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN22@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN20@CL_UpdateF
	movss	xmm0, DWORD PTR _falloff$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv287[ebp], xmm0
	jmp	SHORT $LN21@CL_UpdateF
$LN20@CL_UpdateF:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv287[ebp], xmm0
$LN21@CL_UpdateF:
	movss	xmm0, DWORD PTR tv287[ebp]
	movss	DWORD PTR tv288[ebp], xmm0
	jmp	SHORT $LN23@CL_UpdateF
$LN22@CL_UpdateF:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv288[ebp], xmm0
$LN23@CL_UpdateF:
	cvttss2si eax, DWORD PTR tv288[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+18], al

; 2791 : 	dl->die = cl.time + 0.01f; // die on next frame

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2792 : 	dl->radius = 80;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [eax+12], xmm0

; 2793 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateFlashlight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AllocElight
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dl$ = -4						; size = 4
_key$ = 8						; size = 4
_CL_AllocElight PROC					; COMDAT

; 2651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2652 : 	dlight_t	*dl;
; 2653 : 	int	i;
; 2654 : 
; 2655 : 	// first look for an exact key match
; 2656 : 	if( key )

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN3@CL_AllocEl

; 2657 : 	{
; 2658 : 		for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN4@CL_AllocEl
$LN2@CL_AllocEl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_AllocEl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_AllocEl

; 2659 : 		{
; 2660 : 			if( dl->key == key )

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _key$[ebp]
	jne	SHORT $LN9@CL_AllocEl

; 2661 : 			{
; 2662 : 				// reuse this light
; 2663 : 				memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2664 : 				dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2665 : 				return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	$LN1@CL_AllocEl
$LN9@CL_AllocEl:

; 2666 : 			}
; 2667 : 		}

	jmp	SHORT $LN2@CL_AllocEl
$LN3@CL_AllocEl:

; 2668 : 	}
; 2669 : 
; 2670 : 	// then look for anything else
; 2671 : 	for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN7@CL_AllocEl
$LN5@CL_AllocEl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN7@CL_AllocEl:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN6@CL_AllocEl

; 2672 : 	{
; 2673 : 		if( dl->die < cl.time && dl->key == 0 )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	SHORT $LN10@CL_AllocEl
	mov	eax, DWORD PTR _dl$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN10@CL_AllocEl

; 2674 : 		{
; 2675 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2676 : 			dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2677 : 			return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	SHORT $LN1@CL_AllocEl
$LN10@CL_AllocEl:

; 2678 : 		}
; 2679 : 	}

	jmp	SHORT $LN5@CL_AllocEl
$LN6@CL_AllocEl:

; 2680 : 
; 2681 : 	// otherwise grab first dlight
; 2682 : 	dl = &cl_elights[0];

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	add	ecx, OFFSET _cl_elights
	mov	DWORD PTR _dl$[ebp], ecx

; 2683 : 	memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2684 : 	dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2685 : 
; 2686 : 	return dl;

	mov	eax, DWORD PTR _dl$[ebp]
$LN1@CL_AllocEl:

; 2687 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AllocElight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AllocDlight
_TEXT	SEGMENT
_i$ = -8						; size = 4
_dl$ = -4						; size = 4
_key$ = 8						; size = 4
_CL_AllocDlight PROC					; COMDAT

; 2606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2607 : 	dlight_t	*dl;
; 2608 : 	int	i;
; 2609 : 
; 2610 : 	// first look for an exact key match
; 2611 : 	if( key )

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN3@CL_AllocDl

; 2612 : 	{
; 2613 : 		for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@CL_AllocDl
$LN2@CL_AllocDl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_AllocDl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@CL_AllocDl

; 2614 : 		{
; 2615 : 			if( dl->key == key )

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _key$[ebp]
	jne	SHORT $LN9@CL_AllocDl

; 2616 : 			{
; 2617 : 				// reuse this light
; 2618 : 				memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2619 : 				dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2620 : 				return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	$LN1@CL_AllocDl
$LN9@CL_AllocDl:

; 2621 : 			}
; 2622 : 		}

	jmp	SHORT $LN2@CL_AllocDl
$LN3@CL_AllocDl:

; 2623 : 	}
; 2624 : 
; 2625 : 	// then look for anything else
; 2626 : 	for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN7@CL_AllocDl
$LN5@CL_AllocDl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN7@CL_AllocDl:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN6@CL_AllocDl

; 2627 : 	{
; 2628 : 		if( dl->die < cl.time && dl->key == 0 )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	jbe	SHORT $LN10@CL_AllocDl
	mov	eax, DWORD PTR _dl$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN10@CL_AllocDl

; 2629 : 		{
; 2630 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2631 : 			dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2632 : 			return dl;

	mov	eax, DWORD PTR _dl$[ebp]
	jmp	SHORT $LN1@CL_AllocDl
$LN10@CL_AllocDl:

; 2633 : 		}
; 2634 : 	}

	jmp	SHORT $LN5@CL_AllocDl
$LN6@CL_AllocDl:

; 2635 : 
; 2636 : 	// otherwise grab first dlight
; 2637 : 	dl = &cl_dlights[0];

	mov	eax, 40					; 00000028H
	imul	ecx, eax, 0
	add	ecx, OFFSET _cl_dlights
	mov	DWORD PTR _dl$[ebp], ecx

; 2638 : 	memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2639 : 	dl->key = key;

	mov	eax, DWORD PTR _dl$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2640 : 
; 2641 : 	return dl;

	mov	eax, DWORD PTR _dl$[ebp]
$LN1@CL_AllocDl:

; 2642 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AllocDlight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_RicochetSound
_TEXT	SEGMENT
_handle$ = -48						; size = 4
_soundpath$ = -44					; size = 32
_fvol$ = -12						; size = 4
_iPitch$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_R_RicochetSound PROC					; COMDAT

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1647 : 	int	iPitch = COM_RandomLong( 90, 105 );

	push	105					; 00000069H
	push	90					; 0000005aH
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _iPitch$[ebp], eax

; 1648 : 	float	fvol = COM_RandomFloat( 0.7f, 0.9f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f333333
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _fvol$[ebp]

; 1649 : 	char	soundpath[32];
; 1650 : 	sound_t	handle;
; 1651 : 
; 1652 : 	Q_snprintf( soundpath, sizeof( soundpath ), "%s", cl_ricochet_sounds[COM_RandomLong( 0, 4 )] );

	push	4
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_ricochet_sounds[eax*4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	32					; 00000020H
	lea	ecx, DWORD PTR _soundpath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1653 : 	handle = S_RegisterSound( soundpath );

	lea	eax, DWORD PTR _soundpath$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _handle$[ebp], eax

; 1654 : 
; 1655 : 	S_StartSound( pos, 0, CHAN_AUTO, handle, fvol, ATTN_NORM, iPitch, 0 );

	push	0
	mov	eax, DWORD PTR _iPitch$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fvol$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_S_StartSound
	add	esp, 32					; 00000020H

; 1656 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RicochetSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Sprite_WallPuff
_TEXT	SEGMENT
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_R_Sprite_WallPuff PROC					; COMDAT

; 2011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2012 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_W
	jmp	$LN1@R_Sprite_W
$LN2@R_Sprite_W:

; 2013 : 
; 2014 : 	pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 2015 : 	pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 2016 : 	pTemp->entity.angles[ROLL] = COM_RandomLong( 0, 359 );

	push	359					; 00000167H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+3304], xmm0

; 2017 : 	pTemp->entity.baseline.origin[2] = 30;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [ecx+eax+92], xmm0

; 2018 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 2019 : 	pTemp->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN1@R_Sprite_W:

; 2020 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_WallPuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_PlayerSprites
_TEXT	SEGMENT
tv360 = -116						; size = 4
tv349 = -116						; size = 4
tv338 = -116						; size = 4
tv260 = -116						; size = 4
tv206 = -116						; size = 4
tv177 = -116						; size = 4
_ilength$1 = -48					; size = 4
_i$ = -44						; size = 4
_vel$ = -40						; size = 4
_dir$ = -36						; size = 12
_position$ = -24					; size = 12
_pEnt$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_client$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_count$ = 16						; size = 4
_size$ = 20						; size = 4
_R_PlayerSprites PROC					; COMDAT

; 1815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1816 : 	TEMPENTITY	*pTemp;
; 1817 : 	cl_entity_t	*pEnt;
; 1818 : 	vec3_t		position;
; 1819 : 	vec3_t		dir;
; 1820 : 	float		vel;
; 1821 : 	int		i;
; 1822 : 
; 1823 : 	pEnt = CL_GetEntityByIndex( client );

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 1824 : 
; 1825 : 	if( !pEnt || !pEnt->player )

	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $LN6@R_PlayerSp
	mov	eax, DWORD PTR _pEnt$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@R_PlayerSp
$LN6@R_PlayerSp:

; 1826 : 		return;

	jmp	$LN3@R_PlayerSp
$LN5@R_PlayerSp:

; 1827 : 
; 1828 : 	vel = 128;

	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR _vel$[ebp], xmm0

; 1829 : 
; 1830 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_PlayerSp
$LN2@R_PlayerSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_PlayerSp:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_PlayerSp

; 1831 : 	{
; 1832 : 		VectorCopy( pEnt->origin, position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _position$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _position$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _position$[ebp+ecx], eax

; 1833 : 		position[0] += COM_RandomFloat( -10.0f, 10.0f );

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv338[ebp]
	movss	xmm0, DWORD PTR tv338[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _position$[ebp+edx], xmm0

; 1834 : 		position[1] += COM_RandomFloat( -10.0f, 10.0f );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv349[ebp]
	movss	xmm0, DWORD PTR tv349[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _position$[ebp+eax], xmm0

; 1835 : 		position[2] += COM_RandomFloat( -20.0f, 36.0f );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@42100000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c1a00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv360[ebp]
	movss	xmm0, DWORD PTR tv360[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _position$[ebp+eax], xmm0

; 1836 : 
; 1837 : 		pTemp = CL_TempEntAlloc( position, CL_ModelHandle( modelIndex ));

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _position$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1838 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_PlayerSp
	jmp	$LN3@R_PlayerSp
$LN7@R_PlayerSp:

; 1839 : 
; 1840 : 		VectorSubtract( pTemp->entity.origin, pEnt->origin, pTemp->tentOffset );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3292]
	subss	xmm0, DWORD PTR [esi+eax+3224]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+56], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3292]
	subss	xmm0, DWORD PTR [esi+ecx+3224]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+56], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3292]
	subss	xmm0, DWORD PTR [esi+eax+3224]
	movss	DWORD PTR tv177[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv177[ebp]
	movss	DWORD PTR [eax+edx+56], xmm0

; 1841 : 
; 1842 : 		if ( i != 0 )

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN8@R_PlayerSp

; 1843 : 		{
; 1844 : 			pTemp->flags |= FTENT_PLYRATTACHMENT;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1845 : 			pTemp->clientIndex = client;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+52], cx

; 1846 : 		}

	jmp	$LN9@R_PlayerSp
$LN8@R_PlayerSp:

; 1847 : 		else
; 1848 : 		{
; 1849 : 			VectorSubtract( position, pEnt->origin, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+3224]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+3224]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pEnt$[ebp]
	movss	xmm0, DWORD PTR _position$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+3224]
	movss	DWORD PTR tv206[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv206[ebp]
	movss	DWORD PTR _dir$[ebp+eax], xmm0

; 1850 : 			VectorNormalize( dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _dir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _dir$[ebp+eax]
	mulss	xmm1, DWORD PTR _dir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_PlayerSp
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN10@R_PlayerSp:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 1851 : 			VectorScale( dir, 60, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@42700000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@42700000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR tv260[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 1852 : 			VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _dir$[ebp+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _dir$[ebp+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1853 : 			pTemp->entity.baseline.origin[1] = COM_RandomFloat( 20.0f, 60.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]
$LN9@R_PlayerSp:

; 1854 : 		}
; 1855 : 
; 1856 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1857 : 		pTemp->entity.curstate.framerate = COM_RandomFloat( 1.0f - (size / 100.0f ), 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1076]

; 1858 : 
; 1859 : 		if( pTemp->frameMax > 1 )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN11@R_PlayerSp

; 1860 : 		{
; 1861 : 			pTemp->flags |= FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1862 : 			pTemp->entity.curstate.framerate = 20.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [eax+1076], xmm0

; 1863 : 			pTemp->die = cl.time + (pTemp->frameMax * 0.05f);

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1864 : 		}

	jmp	SHORT $LN12@R_PlayerSp
$LN11@R_PlayerSp:

; 1865 : 		else
; 1866 : 		{
; 1867 : 			pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN12@R_PlayerSp:

; 1868 : 		}
; 1869 : 	}

	jmp	$LN2@R_PlayerSp
$LN3@R_PlayerSp:

; 1870 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_PlayerSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_FireField
_TEXT	SEGMENT
tv285 = -100						; size = 4
tv253 = -100						; size = 4
tv242 = -100						; size = 4
tv232 = -100						; size = 4
_i$ = -32						; size = 4
_pos$ = -28						; size = 12
_time$ = -16						; size = 4
_pmodel$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_radius$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_flags$ = 24						; size = 4
_life$ = 28						; size = 4
_R_FireField PROC					; COMDAT

; 1880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1881 : 	TEMPENTITY	*pTemp;
; 1882 : 	model_t		*pmodel;
; 1883 : 	float		time;
; 1884 : 	vec3_t		pos;
; 1885 : 	int		i;
; 1886 : 
; 1887 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_FireFiel

; 1888 : 		return;

	jmp	$LN3@R_FireFiel
$LN5@R_FireFiel:

; 1889 : 
; 1890 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_FireFiel
$LN2@R_FireFiel:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_FireFiel:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_FireFiel

; 1891 : 	{
; 1892 : 		VectorCopy( org, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$[ebp+ecx], eax

; 1893 : 		pos[0] += COM_RandomFloat( -radius, radius );

	mov	eax, 4
	imul	esi, eax, 0
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _radius$[ebp]
	neg	ecx
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _pos$[ebp+eax], xmm0

; 1894 : 		pos[1] += COM_RandomFloat( -radius, radius );

	mov	esi, 4
	shl	esi, 0
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _radius$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv242[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _pos$[ebp+ecx], xmm0

; 1895 : 
; 1896 : 		if( !FBitSet( flags, TEFIRE_FLAG_PLANAR ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	jne	SHORT $LN6@R_FireFiel

; 1897 : 			pos[2] += COM_RandomFloat( -radius, radius );

	mov	esi, 4
	shl	esi, 1
	cvtsi2ss xmm0, DWORD PTR _radius$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _radius$[ebp]
	neg	eax
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv253[ebp]
	movss	xmm0, DWORD PTR tv253[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _pos$[ebp+ecx], xmm0
$LN6@R_FireFiel:

; 1898 : 
; 1899 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1900 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_FireFiel
	jmp	$LN3@R_FireFiel
$LN7@R_FireFiel:

; 1901 : 
; 1902 : 		if( FBitSet( flags, TEFIRE_FLAG_ALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	je	SHORT $LN8@R_FireFiel

; 1903 : 		{
; 1904 : 			pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 1905 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1906 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 128;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 128		; 00000080H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 128		; 00000080H

; 1907 : 		}

	jmp	SHORT $LN11@R_FireFiel
$LN8@R_FireFiel:

; 1908 : 		else if( FBitSet( flags, TEFIRE_FLAG_ADDITIVE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN10@R_FireFiel

; 1909 : 		{
; 1910 : 			pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 5

; 1911 : 			pTemp->entity.curstate.renderamt = 80;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 80		; 00000050H

; 1912 : 		}

	jmp	SHORT $LN11@R_FireFiel
$LN10@R_FireFiel:

; 1913 : 		else
; 1914 : 		{
; 1915 : 			pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 0

; 1916 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1917 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 255		; 000000ffH
$LN11@R_FireFiel:

; 1918 : 		}
; 1919 : 
; 1920 : 		pTemp->entity.curstate.framerate = COM_RandomFloat( 0.75f, 1.25f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fa00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f400000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1076]

; 1921 : 		time = life + COM_RandomFloat( -0.25f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@be800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv285[ebp]
	movss	xmm0, DWORD PTR tv285[ebp]
	addss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR _time$[ebp], xmm0

; 1922 : 		pTemp->die = cl.time + time;

	cvtss2sd xmm0, DWORD PTR _time$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1923 : 
; 1924 : 		if( pTemp->frameMax > 1 )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@R_FireFiel

; 1925 : 		{
; 1926 : 			pTemp->flags |= FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1927 : 
; 1928 : 			if( FBitSet( flags, TEFIRE_FLAG_LOOP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN13@R_FireFiel

; 1929 : 			{
; 1930 : 				pTemp->entity.curstate.framerate = 15.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41700000
	movss	DWORD PTR [eax+1076], xmm0

; 1931 : 				pTemp->flags |= FTENT_SPRANIMATELOOP;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1932 : 			}

	jmp	SHORT $LN14@R_FireFiel
$LN13@R_FireFiel:

; 1933 : 			else
; 1934 : 			{
; 1935 : 				pTemp->entity.curstate.framerate = pTemp->frameMax / time;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	divss	xmm0, DWORD PTR _time$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+1076], xmm0
$LN14@R_FireFiel:

; 1936 : 			}
; 1937 : 		}
; 1938 : 
; 1939 : 		if( FBitSet( flags, TEFIRE_FLAG_ALLFLOAT ) || ( FBitSet( flags, TEFIRE_FLAG_SOMEFLOAT ) && !COM_RandomLong( 0, 1 )))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	jne	SHORT $LN16@R_FireFiel
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN15@R_FireFiel
	push	1
	push	0
	call	_COM_RandomLong
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@R_FireFiel
$LN16@R_FireFiel:

; 1940 : 		{
; 1941 : 			// drift sprite upward
; 1942 : 			pTemp->entity.baseline.origin[2] = COM_RandomFloat( 10.0f, 30.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]
$LN15@R_FireFiel:

; 1943 : 		}
; 1944 : 	}

	jmp	$LN2@R_FireFiel
$LN3@R_FireFiel:

; 1945 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FireField ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_MultiGunshot
_TEXT	SEGMENT
tv249 = -308						; size = 4
tv233 = -308						; size = 4
tv304 = -304						; size = 4
tv302 = -304						; size = 4
tv241 = -300						; size = 4
tv225 = -300						; size = 4
$T1 = -296						; size = 68
_e$2 = -164						; size = 4
_pe$3 = -160						; size = 4
_z$4 = -156						; size = 4
_y$5 = -152						; size = 4
_x$6 = -148						; size = 4
_decalIndex$ = -144					; size = 4
_j$ = -140						; size = 4
_i$ = -136						; size = 4
_vecEnd$ = -132						; size = 12
_vecDir$ = -120						; size = 12
_vecSrc$ = -108						; size = 12
_up$ = -96						; size = 12
_right$ = -84						; size = 12
_trace$ = -72						; size = 68
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_dir$ = 12						; size = 4
_noise$ = 16						; size = 4
_count$ = 20						; size = 4
_decalCount$ = 24					; size = 4
_decalIndices$ = 28					; size = 4
_R_MultiGunshot PROC					; COMDAT

; 1955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1956 : 	pmtrace_t	trace;
; 1957 : 	vec3_t	right, up;
; 1958 : 	vec3_t	vecSrc, vecDir, vecEnd;
; 1959 : 	int	i, j, decalIndex;
; 1960 : 
; 1961 : 	VectorVectors( dir, right, up );

	lea	eax, DWORD PTR _up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dir$[ebp]
	push	edx
	call	_VectorVectors
	add	esp, 12					; 0000000cH

; 1962 : 	VectorCopy( org, vecSrc );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _vecSrc$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _vecSrc$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _vecSrc$[ebp+ecx], eax

; 1963 : 
; 1964 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_MultiGun
$LN2@R_MultiGun:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_MultiGun:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_MultiGun
$LN7@R_MultiGun:

; 1965 : 	{
; 1966 : 		// get circular gaussian spread
; 1967 : 		float x, y, z;
; 1968 : 		do {
; 1969 : 			x = COM_RandomFloat( -0.5f, 0.5f ) + COM_RandomFloat( -0.5f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv225[ebp]
	movss	xmm0, DWORD PTR tv225[ebp]
	push	ecx
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv302[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv233[ebp]
	movss	xmm0, DWORD PTR tv302[ebp]
	addss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR _x$6[ebp], xmm0

; 1970 : 			y = COM_RandomFloat( -0.5f, 0.5f ) + COM_RandomFloat( -0.5f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	push	ecx
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	movss	xmm1, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv304[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv249[ebp]
	movss	xmm0, DWORD PTR tv304[ebp]
	addss	xmm0, DWORD PTR tv249[ebp]
	movss	DWORD PTR _y$5[ebp], xmm0

; 1971 : 			z = x * x + y * y;

	movss	xmm0, DWORD PTR _x$6[ebp]
	mulss	xmm0, DWORD PTR _x$6[ebp]
	movss	xmm1, DWORD PTR _y$5[ebp]
	mulss	xmm1, DWORD PTR _y$5[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _z$4[ebp], xmm0

; 1972 : 		} while( z > 1.0f );

	movss	xmm0, DWORD PTR _z$4[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	ja	$LN7@R_MultiGun

; 1973 : 
; 1974 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@R_MultiGun
$LN8@R_MultiGun:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@R_MultiGun:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN9@R_MultiGun

; 1975 : 		{
; 1976 : 			vecDir[j] = dir[j] + x * noise[0] * right[j] + y * noise[1] * up[j];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _noise$[ebp]
	movss	xmm0, DWORD PTR _x$6[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _j$[ebp]
	mulss	xmm0, DWORD PTR _right$[ebp+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx*4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _noise$[ebp]
	movss	xmm1, DWORD PTR _y$5[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _j$[ebp]
	mulss	xmm1, DWORD PTR _up$[ebp+edx*4]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _j$[ebp]
	movss	DWORD PTR _vecDir$[ebp+eax*4], xmm0

; 1977 : 			vecEnd[j] = vecSrc[j] + 4096.0f * vecDir[j];

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR __real@45800000
	mulss	xmm0, DWORD PTR _vecDir$[ebp+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$[ebp]
	movss	DWORD PTR _vecEnd$[ebp+edx*4], xmm0

; 1978 : 		}

	jmp	$LN8@R_MultiGun
$LN9@R_MultiGun:

; 1979 : 
; 1980 : 		trace = CL_TraceLine( vecSrc, vecEnd, PM_STUDIO_IGNORE );

	push	1
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$[ebp]
	rep movsd

; 1981 : 
; 1982 : 		// paint decals
; 1983 : 		if( trace.fraction != 1.0f )

	movss	xmm0, DWORD PTR _trace$[ebp+16]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN14@R_MultiGun

; 1984 : 		{
; 1985 : 			physent_t	*pe = NULL;

	mov	DWORD PTR _pe$3[ebp], 0

; 1986 : 
; 1987 : 			if( i & 2 ) R_RicochetSound( trace.endpos );

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 2
	je	SHORT $LN12@R_MultiGun
	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	call	_R_RicochetSound
	add	esp, 4
$LN12@R_MultiGun:

; 1988 : 			R_BulletImpactParticles( trace.endpos );

	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	call	_R_BulletImpactParticles
	add	esp, 4

; 1989 : 
; 1990 : 			if( trace.ent >= 0 && trace.ent < clgame.pmove->numphysent )

	cmp	DWORD PTR _trace$[ebp+48], 0
	jl	SHORT $LN13@R_MultiGun
	mov	eax, DWORD PTR _clgame+1344
	mov	ecx, DWORD PTR _trace$[ebp+48]
	cmp	ecx, DWORD PTR [eax+588]
	jge	SHORT $LN13@R_MultiGun

; 1991 : 				pe = &clgame.pmove->physents[trace.ent];

	imul	eax, DWORD PTR _trace$[ebp+48], 224
	mov	ecx, DWORD PTR _clgame+1344
	lea	edx, DWORD PTR [ecx+eax+592]
	mov	DWORD PTR _pe$3[ebp], edx
$LN13@R_MultiGun:

; 1992 : 
; 1993 : 			if( pe && ( pe->solid == SOLID_BSP || pe->movetype == MOVETYPE_PUSHSTEP ))

	cmp	DWORD PTR _pe$3[ebp], 0
	je	SHORT $LN14@R_MultiGun
	mov	eax, DWORD PTR _pe$3[ebp]
	cmp	DWORD PTR [eax+96], 4
	je	SHORT $LN15@R_MultiGun
	mov	eax, DWORD PTR _pe$3[ebp]
	cmp	DWORD PTR [eax+124], 13			; 0000000dH
	jne	SHORT $LN14@R_MultiGun
$LN15@R_MultiGun:

; 1994 : 			{
; 1995 : 				cl_entity_t *e = CL_GetEntityByIndex( pe->info );

	mov	eax, DWORD PTR _pe$3[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _e$2[ebp], eax

; 1996 : 				decalIndex = CL_DecalIndex( decalIndices[COM_RandomLong( 0, decalCount-1 )] );

	mov	eax, DWORD PTR _decalCount$[ebp]
	sub	eax, 1
	push	eax
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, DWORD PTR _decalIndices$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 1997 : 				CL_DecalShoot( decalIndex, e->index, 0, trace.endpos, 0 );

	push	0
	lea	eax, DWORD PTR _trace$[ebp+20]
	push	eax
	push	0
	mov	ecx, DWORD PTR _e$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H
$LN14@R_MultiGun:

; 1998 : 			}
; 1999 : 		}
; 2000 : 	}

	jmp	$LN2@R_MultiGun
$LN3@R_MultiGun:

; 2001 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_MultiGunshot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_TempSphereModel
_TEXT	SEGMENT
tv247 = -80						; size = 4
_ilength$1 = -12					; size = 4
_i$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_speed$ = 12						; size = 4
_life$ = 16						; size = 4
_count$ = 20						; size = 4
_modelIndex$ = 24					; size = 4
_R_TempSphereModel PROC					; COMDAT

; 1715 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1716 : 	TEMPENTITY	*pTemp;
; 1717 : 	int		i;
; 1718 : 
; 1719 : 	// create temp models
; 1720 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_TempSphe
$LN2@R_TempSphe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_TempSphe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_TempSphe

; 1721 : 	{
; 1722 : 		pTemp = CL_TempEntAlloc( pos, CL_ModelHandle( modelIndex ));

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1723 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_TempSphe
	jmp	$LN3@R_TempSphe
$LN5@R_TempSphe:

; 1724 : 
; 1725 : 		pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+1100], eax

; 1726 : 
; 1727 : 		if( COM_RandomLong( 0, 255 ) < 10 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN6@R_TempSphe

; 1728 : 			pTemp->flags |= FTENT_SLOWGRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN7@R_TempSphe
$LN6@R_TempSphe:

; 1729 : 		else pTemp->flags |= FTENT_GRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@R_TempSphe:

; 1730 : 
; 1731 : 		if( COM_RandomLong( 0, 255 ) < 200 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 200				; 000000c8H
	jge	$LN8@R_TempSphe

; 1732 : 		{
; 1733 : 			pTemp->flags |= FTENT_ROTATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1734 : 			pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1735 : 			pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1736 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]
$LN8@R_TempSphe:

; 1737 : 		}
; 1738 : 
; 1739 : 		if( COM_RandomLong( 0, 255 ) < 100 )

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN9@R_TempSphe

; 1740 : 			pTemp->flags |= FTENT_SMOKETRAIL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN9@R_TempSphe:

; 1741 : 
; 1742 : 		pTemp->flags |= FTENT_FLICKER | FTENT_COLLIDEWORLD;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1743 : 		pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 0

; 1744 : 		pTemp->entity.curstate.effects = i & 31;

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 31					; 0000001fH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1040], eax

; 1745 : 		pTemp->entity.baseline.origin[0] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1746 : 		pTemp->entity.baseline.origin[1] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1747 : 		pTemp->entity.baseline.origin[2] = COM_RandomFloat( -1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1748 : 
; 1749 : 		VectorNormalize( pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR [esi+eax+92]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+92]
	mulss	xmm1, DWORD PTR [esi+ecx+92]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+92]
	mulss	xmm1, DWORD PTR [esi+ecx+92]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_TempSphe
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN10@R_TempSphe:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+92]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0

; 1750 : 		VectorScale( pTemp->entity.baseline.origin, speed, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+92]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv247[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv247[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1751 : 		pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1752 : 	}

	jmp	$LN2@R_TempSphe
$LN3@R_TempSphe:

; 1753 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempSphereModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Projectile
_TEXT	SEGMENT
tv183 = -100						; size = 4
tv182 = -96						; size = 4
_ilength$1 = -28					; size = 4
_dir$ = -24						; size = 12
_pmodel$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_origin$ = 8						; size = 4
_velocity$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_life$ = 20						; size = 4
_owner$ = 24						; size = 4
_hitcallback$ = 28					; size = 4
_R_Projectile PROC					; COMDAT

; 1666 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1667 : 	TEMPENTITY	*pTemp;
; 1668 : 	model_t		*pmodel;
; 1669 : 	vec3_t		dir;
; 1670 : 
; 1671 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN2@R_Projecti

; 1672 : 		return;

	jmp	$LN1@R_Projecti
$LN2@R_Projecti:

; 1673 : 
; 1674 : 	pTemp = CL_TempEntAllocHigh( origin, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1675 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_Projecti
	jmp	$LN1@R_Projecti
$LN3@R_Projecti:

; 1676 : 
; 1677 : 	VectorCopy( velocity, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1678 : 
; 1679 : 	if( pmodel->type == mod_sprite )

	mov	eax, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	SHORT $LN4@R_Projecti

; 1680 : 	{
; 1681 : 		SetBits( pTemp->flags, FTENT_SPRANIMATE );

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1682 : 
; 1683 : 		if( pTemp->frameMax < 10 )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN6@R_Projecti

; 1684 : 		{
; 1685 : 			SetBits( pTemp->flags, FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP );

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65792				; 00010100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1686 : 			pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 1687 : 		}

	jmp	SHORT $LN7@R_Projecti
$LN6@R_Projecti:

; 1688 : 		else
; 1689 : 		{
; 1690 : 			pTemp->entity.curstate.framerate = pTemp->frameMax / life;

	cvtsi2ss xmm0, DWORD PTR _life$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm1, DWORD PTR [eax+8]
	divss	xmm1, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+1076], xmm1
$LN7@R_Projecti:

; 1691 : 		}
; 1692 : 	}

	jmp	$LN5@R_Projecti
$LN4@R_Projecti:

; 1693 : 	else
; 1694 : 	{
; 1695 : 		pTemp->frameMax = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 1696 : 		VectorNormalize2( velocity, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _velocity$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR [esi+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@R_Projecti
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN8@R_Projecti:
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _dir$[ebp+edx], xmm0

; 1697 : 		VectorAngles( dir, pTemp->entity.angles );

	mov	eax, DWORD PTR _pTemp$[ebp]
	add	eax, 3304				; 00000ce8H
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	_VectorAngles
	add	esp, 8
$LN5@R_Projecti:

; 1698 : 	}
; 1699 : 
; 1700 : 	pTemp->flags |= FTENT_COLLIDEALL|FTENT_PERSIST|FTENT_COLLIDEKILL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 28672				; 00007000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1701 : 	pTemp->clientIndex = bound( 1, owner, cl.maxclients );

	cmp	DWORD PTR _owner$[ebp], 1
	jl	SHORT $LN12@R_Projecti
	mov	eax, DWORD PTR _owner$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jge	SHORT $LN10@R_Projecti
	mov	ecx, DWORD PTR _owner$[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN11@R_Projecti
$LN10@R_Projecti:
	mov	edx, DWORD PTR _cl+2213004
	mov	DWORD PTR tv182[ebp], edx
$LN11@R_Projecti:
	mov	eax, DWORD PTR tv182[ebp]
	mov	DWORD PTR tv183[ebp], eax
	jmp	SHORT $LN13@R_Projecti
$LN12@R_Projecti:
	mov	DWORD PTR tv183[ebp], 1
$LN13@R_Projecti:
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	dx, WORD PTR tv183[ebp]
	mov	WORD PTR [ecx+52], dx

; 1702 : 	pTemp->entity.baseline.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 255		; 000000ffH

; 1703 : 	pTemp->hitcallback = hitcallback;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _hitcallback$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1704 : 	pTemp->die = cl.time + life;

	cvtsi2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN1@R_Projecti:

; 1705 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Projectile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_SparkEffect
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_count$ = 12						; size = 4
_velocityMin$ = 16					; size = 4
_velocityMax$ = 20					; size = 4
_R_SparkEffect PROC					; COMDAT

; 1633 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1634 : 	R_RicochetSprite( pos, cl_sprite_ricochet, 0.1f, COM_RandomFloat( 0.5f, 1.0f ));

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl_sprite_ricochet
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSprite
	add	esp, 16					; 00000010H

; 1635 : 	R_SparkStreaks( pos, count, velocityMin, velocityMax );

	mov	eax, DWORD PTR _velocityMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _velocityMin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_SparkStreaks
	add	esp, 16					; 00000010H

; 1636 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SparkEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_FunnelSprite
_TEXT	SEGMENT
tv398 = -120						; size = 4
tv291 = -120						; size = 4
tv256 = -120						; size = 4
tv211 = -120						; size = 4
tv172 = -120						; size = 4
_j$ = -52						; size = 4
_i$ = -48						; size = 4
_pmodel$ = -44						; size = 4
_vel$ = -40						; size = 4
_dist$ = -36						; size = 4
_dest$ = -32						; size = 12
_dir$ = -20						; size = 12
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_reverse$ = 16						; size = 4
_R_FunnelSprite PROC					; COMDAT

; 1571 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1572 : 	TEMPENTITY	*pTemp;
; 1573 : 	vec3_t		dir, dest;
; 1574 : 	float		dist, vel;
; 1575 : 	model_t		*pmodel;
; 1576 : 	int		i, j;
; 1577 : 
; 1578 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN8@R_FunnelSp

; 1579 : 	{
; 1580 : 		Con_Reportf( S_ERROR "no model %d!\n", modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@PFCNBPIC@?$FO1Error?3?$FO7?5no?5model?5?$CFd?$CB?6@
	call	_Con_Reportf
	add	esp, 8

; 1581 : 		return;

	jmp	$LN3@R_FunnelSp
$LN8@R_FunnelSp:

; 1582 : 	}
; 1583 : 
; 1584 : 	for( i = -8; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], -8			; fffffff8H
	jmp	SHORT $LN4@R_FunnelSp
$LN2@R_FunnelSp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_FunnelSp:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@R_FunnelSp

; 1585 : 	{
; 1586 : 		for( j = -8; j < 8; j++ )

	mov	DWORD PTR _j$[ebp], -8			; fffffff8H
	jmp	SHORT $LN7@R_FunnelSp
$LN5@R_FunnelSp:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_FunnelSp:
	cmp	DWORD PTR _j$[ebp], 8
	jge	$LN6@R_FunnelSp

; 1587 : 		{
; 1588 : 			pTemp = CL_TempEntAlloc( org, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1589 : 			if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_FunnelSp
	jmp	$LN3@R_FunnelSp
$LN9@R_FunnelSp:

; 1590 : 
; 1591 : 			dest[0] = (i * 32.0f) + org[0];

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	mulss	xmm0, DWORD PTR __real@42000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dest$[ebp+ecx], xmm0

; 1592 : 			dest[1] = (j * 32.0f) + org[1];

	cvtsi2ss xmm0, DWORD PTR _j$[ebp]
	mulss	xmm0, DWORD PTR __real@42000000
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dest$[ebp+edx], xmm0

; 1593 : 			dest[2] = org[2] + COM_RandomFloat( 100.0f, 800.0f );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@44480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv291[ebp]
	mov	eax, DWORD PTR _org$[ebp]
	movss	xmm0, DWORD PTR tv291[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dest$[ebp+ecx], xmm0

; 1594 : 
; 1595 : 			if( reverse )

	cmp	DWORD PTR _reverse$[ebp], 0
	je	$LN10@R_FunnelSp

; 1596 : 			{
; 1597 : 				VectorCopy( org, pTemp->entity.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+3292], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+3292], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+3292], eax

; 1598 : 				VectorSubtract( dest, pTemp->entity.origin, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax+3292]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax+3292]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _dest$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx+3292]
	movss	DWORD PTR tv172[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _dir$[ebp+eax], xmm0

; 1599 : 			}

	jmp	$LN11@R_FunnelSp
$LN10@R_FunnelSp:

; 1600 : 			else
; 1601 : 			{
; 1602 : 				VectorCopy( dest, pTemp->entity.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3292], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _dest$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3292], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _dest$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3292], eax

; 1603 : 				VectorSubtract( org, pTemp->entity.origin, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax+3292]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax+3292]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	esi, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx+3292]
	movss	DWORD PTR tv211[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR _dir$[ebp+eax], xmm0
$LN11@R_FunnelSp:

; 1604 : 			}
; 1605 : 
; 1606 : 			pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 3

; 1607 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1608 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 200;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 200		; 000000c8H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 200		; 000000c8H

; 1609 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -100.0f, 100.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c80000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1610 : 			pTemp->entity.curstate.framerate = COM_RandomFloat( 0.1f, 0.4f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3ecccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1076]

; 1611 : 			pTemp->flags = FTENT_ROTATE|FTENT_FADEOUT;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 132			; 00000084H

; 1612 : 			pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 1613 : 
; 1614 : 			vel = dest[2] / 8.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dest$[ebp+eax]
	divss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vel$[ebp], xmm0

; 1615 : 			if( vel < 64.0f ) vel = 64.0f;

	movss	xmm0, DWORD PTR __real@42800000
	comiss	xmm0, DWORD PTR _vel$[ebp]
	jbe	SHORT $LN12@R_FunnelSp
	movss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _vel$[ebp], xmm0
$LN12@R_FunnelSp:

; 1616 : 			dist = VectorNormalizeLength( dir );

	lea	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 1617 : 			vel += COM_RandomFloat( 64.0f, 128.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv398[ebp]
	movss	xmm0, DWORD PTR tv398[ebp]
	addss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR _vel$[ebp], xmm0

; 1618 : 			VectorScale( dir, vel, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _dir$[ebp+edx]
	mulss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR tv256[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv256[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1619 : 			pTemp->die = cl.time + (dist / vel) - 0.5f;

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _vel$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1620 : 			pTemp->fadeSpeed = 2.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+24], xmm0

; 1621 : 		}

	jmp	$LN5@R_FunnelSp
$LN6@R_FunnelSp:

; 1622 : 	}

	jmp	$LN2@R_FunnelSp
$LN3@R_FunnelSp:

; 1623 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FunnelSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Sprite_Trail
_TEXT	SEGMENT
tv499 = -148						; size = 8
tv502 = -140						; size = 8
tv452 = -136						; size = 4
tv441 = -136						; size = 4
tv430 = -136						; size = 4
tv239 = -136						; size = 4
tv219 = -136						; size = 4
tv87 = -136						; size = 4
_vel$1 = -68						; size = 12
_pos$2 = -56						; size = 12
_ilength$3 = -44					; size = 4
_i$ = -40						; size = 4
_pmodel$ = -36						; size = 4
_dir$ = -32						; size = 12
_delta$ = -20						; size = 12
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_start$ = 12						; size = 4
_end$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_life$ = 28						; size = 4
_size$ = 32						; size = 4
_amp$ = 36						; size = 4
_renderamt$ = 40					; size = 4
_speed$ = 44						; size = 4
_R_Sprite_Trail PROC					; COMDAT

; 1519 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1520 : 	TEMPENTITY	*pTemp;
; 1521 : 	vec3_t		delta, dir;
; 1522 : 	model_t		*pmodel;
; 1523 : 	int		i;
; 1524 : 
; 1525 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_Sprite_T

; 1526 : 		return;

	jmp	$LN3@R_Sprite_T
$LN5@R_Sprite_T:

; 1527 : 
; 1528 : 	VectorSubtract( end, start, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx]
	subss	xmm0, DWORD PTR [esi+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [edx+eax]
	subss	xmm0, DWORD PTR [esi+ecx]
	movss	DWORD PTR tv87[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 1529 : 	VectorNormalize2( delta, dir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_Sprite_T
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN6@R_Sprite_T:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dir$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _dir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _dir$[ebp+ecx], xmm0

; 1530 : 
; 1531 : 	amp /= 256.0f;

	movss	xmm0, DWORD PTR _amp$[ebp]
	divss	xmm0, DWORD PTR __real@43800000
	movss	DWORD PTR _amp$[ebp], xmm0

; 1532 : 
; 1533 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Sprite_T
$LN2@R_Sprite_T:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Sprite_T:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_Sprite_T

; 1534 : 	{
; 1535 : 		vec3_t	pos, vel;
; 1536 : 
; 1537 : 		// Be careful of divide by 0 when using 'count' here...
; 1538 : 		if( i == 0 ) VectorCopy( start, pos );

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN7@R_Sprite_T
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$2[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _start$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$2[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$2[ebp+ecx], eax
	jmp	$LN8@R_Sprite_T
$LN7@R_Sprite_T:

; 1539 : 		else VectorMA( start, ( i / ( count - 1.0f )), delta, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _pos$2[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _pos$2[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	cvtsi2ss xmm1, DWORD PTR _count$[ebp]
	subss	xmm1, DWORD PTR __real@3f800000
	divss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv219[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv219[ebp]
	movss	DWORD PTR _pos$2[ebp+eax], xmm0
$LN8@R_Sprite_T:

; 1540 : 
; 1541 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$2[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1542 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_Sprite_T
	jmp	$LN3@R_Sprite_T
$LN9@R_Sprite_T:

; 1543 : 
; 1544 : 		pTemp->flags = (FTENT_COLLIDEWORLD|FTENT_SPRCYCLE|FTENT_FADEOUT|FTENT_SLOWGRAVITY);

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 2216			; 000008a8H

; 1545 : 
; 1546 : 		VectorScale( dir, speed, vel );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vel$1[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vel$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dir$[ebp+eax]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv239[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv239[ebp]
	movss	DWORD PTR _vel$1[ebp+ecx], xmm0

; 1547 : 		vel[0] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv430[ebp]
	movss	xmm0, DWORD PTR tv430[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$1[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vel$1[ebp+edx], xmm0

; 1548 : 		vel[1] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv441[ebp]
	movss	xmm0, DWORD PTR tv441[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$1[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vel$1[ebp+eax], xmm0

; 1549 : 		vel[2] += COM_RandomFloat( -127.0f, 128.0f ) * amp;

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@43000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2fe0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv452[ebp]
	movss	xmm0, DWORD PTR tv452[ebp]
	mulss	xmm0, DWORD PTR _amp$[ebp]
	addss	xmm0, DWORD PTR _vel$1[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vel$1[ebp+eax], xmm0

; 1550 : 		VectorCopy( vel, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _vel$1[ebp+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _vel$1[ebp+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _vel$1[ebp+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1551 : 		VectorCopy( pos, pTemp->entity.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pos$2[ebp+ecx]
	mov	DWORD PTR [edx+eax+3292], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _pos$2[ebp+edx]
	mov	DWORD PTR [ecx+eax+3292], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _pos$2[ebp+eax]
	mov	DWORD PTR [edx+ecx+3292], eax

; 1552 : 
; 1553 : 		pTemp->entity.curstate.scale = size;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 1554 : 		pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 3

; 1555 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1556 : 		pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = renderamt;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _renderamt$[ebp]
	mov	DWORD PTR [eax+152], ecx
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _renderamt$[ebp]
	mov	DWORD PTR [edx+1056], eax

; 1557 : 
; 1558 : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 1559 : 		pTemp->die = cl.time + life + COM_RandomFloat( 0.0f, 4.0f );

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	xmm1, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	xorps	xmm1, xmm1
	movss	DWORD PTR [esp], xmm1
	movsd	QWORD PTR tv502[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv499[ebp]
	movsd	xmm0, QWORD PTR tv502[ebp]
	addsd	xmm0, QWORD PTR tv499[ebp]
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1560 : 	}

	jmp	$LN2@R_Sprite_T
$LN3@R_Sprite_T:

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Trail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Sprite_Spray
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_speed$ = 24						; size = 4
_spread$ = 28						; size = 4
_R_Sprite_Spray PROC					; COMDAT

; 1506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1507 : 	R_Spray( pos, dir, modelIndex, count, speed, spread, kRenderGlow );

	push	3
	mov	eax, DWORD PTR _spread$[ebp]
	push	eax
	mov	ecx, DWORD PTR _speed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_Spray
	add	esp, 28					; 0000001cH

; 1508 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Spray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Spray
_TEXT	SEGMENT
tv233 = -100						; size = 4
tv356 = -96						; size = 4
tv344 = -92						; size = 4
tv332 = -88						; size = 4
tv320 = -88						; size = 4
tv307 = -88						; size = 4
tv294 = -88						; size = 4
tv76 = -88						; size = 4
_i$ = -20						; size = 4
_pmodel$ = -16						; size = 4
_znoise$ = -12						; size = 4
_noise$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_modelIndex$ = 16					; size = 4
_count$ = 20						; size = 4
_speed$ = 24						; size = 4
_spread$ = 28						; size = 4
_rendermode$ = 32					; size = 4
_R_Spray PROC						; COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 1441 : 	TEMPENTITY	*pTemp;
; 1442 : 	float		noise;
; 1443 : 	float		znoise;
; 1444 : 	model_t		*pmodel;
; 1445 : 	int		i;
; 1446 : 
; 1447 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN5@R_Spray

; 1448 : 	{
; 1449 : 		Con_Reportf( "No model %d!\n", modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@ICEDCNLF@No?5model?5?$CFd?$CB?6@
	call	_Con_Reportf
	add	esp, 8

; 1450 : 		return;

	jmp	$LN3@R_Spray
$LN5@R_Spray:

; 1451 : 	}
; 1452 : 
; 1453 : 	noise = (float)spread / 100.0f;

	cvtsi2ss xmm0, DWORD PTR _spread$[ebp]
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _noise$[ebp], xmm0

; 1454 : 
; 1455 : 	// more vertical displacement
; 1456 : 	znoise = Q_min( 1.0f, noise * 1.5f );

	movss	xmm0, DWORD PTR _noise$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN12@R_Spray
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN13@R_Spray
$LN12@R_Spray:
	movss	xmm0, DWORD PTR _noise$[ebp]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR tv76[ebp], xmm0
$LN13@R_Spray:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR _znoise$[ebp], xmm0

; 1457 : 
; 1458 : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Spray
$LN2@R_Spray:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Spray:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_Spray

; 1459 : 	{
; 1460 : 		pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1461 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_Spray
	jmp	$LN3@R_Spray
$LN6@R_Spray:

; 1462 : 
; 1463 : 		pTemp->entity.curstate.rendermode = rendermode;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR [eax+1052], ecx

; 1464 : 		pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 255		; 000000ffH

; 1465 : 		pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 1466 : 
; 1467 : 		if( rendermode != kRenderGlow )

	cmp	DWORD PTR _rendermode$[ebp], 3
	je	$LN7@R_Spray

; 1468 : 		{
; 1469 : 			// spray
; 1470 : 			pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_SLOWGRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1471 : 
; 1472 : 			if( pTemp->frameMax > 1 )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN9@R_Spray

; 1473 : 			{
; 1474 : 				pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_SLOWGRAVITY | FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 296				; 00000128H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1475 : 				pTemp->die = cl.time + (pTemp->frameMax * 0.1f);

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1476 : 				pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 1477 : 			}

	jmp	SHORT $LN10@R_Spray
$LN9@R_Spray:

; 1478 : 			else pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN10@R_Spray:

; 1479 : 		}

	jmp	SHORT $LN8@R_Spray
$LN7@R_Spray:

; 1480 : 		else
; 1481 : 		{
; 1482 : 			// sprite spray
; 1483 : 			pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 1484 : 			pTemp->flags |= FTENT_FADEOUT | FTENT_SLOWGRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 136				; 00000088H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1485 : 			pTemp->entity.curstate.framerate = 0.5;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+1076], xmm0

; 1486 : 			pTemp->die = cl.time + 0.35f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fd6666660000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1487 : 			pTemp->fadeSpeed = 2.0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [eax+24], xmm0
$LN8@R_Spray:

; 1488 : 		}
; 1489 : 
; 1490 : 		// make the spittle fly the direction indicated, but mix in some noise.
; 1491 : 		pTemp->entity.baseline.origin[0] = dir[0] + COM_RandomFloat( -noise, noise );

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _noise$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _noise$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv294[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv294[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1492 : 		pTemp->entity.baseline.origin[1] = dir[1] + COM_RandomFloat( -noise, noise );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR _noise$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _noise$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv307[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv307[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1493 : 		pTemp->entity.baseline.origin[2] = dir[2] + COM_RandomFloat( 0, znoise );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR _znoise$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv320[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv320[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1494 : 		VectorScale( pTemp->entity.baseline.origin, COM_RandomFloat(( speed * 0.8f ), ( speed * 1.2f )), pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	esi, eax, 0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv332[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv332[ebp]
	mulss	xmm0, DWORD PTR [ecx+esi+92]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	esi, 4
	shl	esi, 0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv344[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv344[ebp]
	mulss	xmm0, DWORD PTR [edx+esi+92]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	esi, 4
	shl	esi, 1
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f99999a
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv356[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [edx+esi+92]
	mulss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR tv233[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR tv233[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1495 : 	}

	jmp	$LN2@R_Spray
$LN3@R_Spray:

; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Spray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Sprite_Smoke
_TEXT	SEGMENT
_iColor$ = -4						; size = 4
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_R_Sprite_Smoke PROC					; COMDAT

; 1416 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1417 : 	int	iColor;
; 1418 : 
; 1419 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_S
	jmp	$LN1@R_Sprite_S
$LN2@R_Sprite_S:

; 1420 : 
; 1421 : 	iColor = COM_RandomLong( 20, 35 );

	push	35					; 00000023H
	push	20					; 00000014H
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _iColor$[ebp], eax

; 1422 : 	pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 1423 : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 0

; 1424 : 	pTemp->entity.baseline.origin[2] = 30;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41f00000
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1425 : 	pTemp->entity.curstate.rendercolor.r = iColor;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cl, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [eax+1060], cl

; 1426 : 	pTemp->entity.curstate.rendercolor.g = iColor;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cl, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [eax+1061], cl

; 1427 : 	pTemp->entity.curstate.rendercolor.b = iColor;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cl, BYTE PTR _iColor$[ebp]
	mov	BYTE PTR [eax+1062], cl

; 1428 : 	pTemp->entity.origin[2] += 20;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3292]
	addss	xmm0, DWORD PTR __real@41a00000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+3292], xmm0

; 1429 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0
$LN1@R_Sprite_S:

; 1430 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Smoke ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Sprite_Explode
_TEXT	SEGMENT
_pTemp$ = 8						; size = 4
_scale$ = 12						; size = 4
_flags$ = 16						; size = 4
_R_Sprite_Explode PROC					; COMDAT

; 1374 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1375 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Sprite_E
	jmp	$LN1@R_Sprite_E
$LN2@R_Sprite_E:

; 1376 : 
; 1377 : 	if( FBitSet( flags, TE_EXPLFLAG_NOADDITIVE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN3@R_Sprite_E

; 1378 : 	{
; 1379 : 		// solid sprite
; 1380 : 		pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 0

; 1381 : 		pTemp->entity.curstate.renderamt = 255; 

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 1382 : 	}

	jmp	SHORT $LN6@R_Sprite_E
$LN3@R_Sprite_E:

; 1383 : 	else if( FBitSet( flags, TE_EXPLFLAG_DRAWALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN5@R_Sprite_E

; 1384 : 	{
; 1385 : 		// alpha sprite (came from hl2)
; 1386 : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 1387 : 		pTemp->entity.curstate.renderamt = 180;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 180		; 000000b4H

; 1388 : 	}

	jmp	SHORT $LN6@R_Sprite_E
$LN5@R_Sprite_E:

; 1389 : 	else
; 1390 : 	{
; 1391 : 		// additive sprite
; 1392 : 		pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 5

; 1393 : 		pTemp->entity.curstate.renderamt = 180;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 180		; 000000b4H
$LN6@R_Sprite_E:

; 1394 : 	}
; 1395 : 
; 1396 : 	if( FBitSet( flags, TE_EXPLFLAG_ROTATE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN7@R_Sprite_E

; 1397 : 	{
; 1398 : 		// came from hl2
; 1399 : 		pTemp->entity.angles[2] = COM_RandomLong( 0, 360 );

	push	360					; 00000168H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+3304], xmm0
$LN7@R_Sprite_E:

; 1400 : 	}
; 1401 : 
; 1402 : 	pTemp->entity.curstate.renderfx = kRenderFxNone;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 0

; 1403 : 	pTemp->entity.baseline.origin[2] = 8;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1404 : 	pTemp->entity.origin[2] += 10;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3292]
	addss	xmm0, DWORD PTR __real@41200000
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+edx+3292], xmm0

; 1405 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0
$LN1@R_Sprite_E:

; 1406 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Sprite_Explode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_DefaultSprite
_TEXT	SEGMENT
_psprite$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_spriteIndex$ = 12					; size = 4
_framerate$ = 16					; size = 4
_R_DefaultSprite PROC					; COMDAT

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1276 : 	TEMPENTITY	*pTemp;
; 1277 : 	model_t		*psprite;
; 1278 : 
; 1279 : 	// don't spawn while paused
; 1280 : 	if( cl.time == cl.oldtime )

	movsd	xmm0, QWORD PTR _cl+2167640
	ucomisd	xmm0, QWORD PTR _cl+2167648
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_DefaultS

; 1281 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN2@R_DefaultS:

; 1282 : 
; 1283 : 	if(( psprite = CL_ModelHandle( spriteIndex )) == NULL || psprite->type != mod_sprite )

	mov	eax, DWORD PTR _spriteIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _psprite$[ebp], eax
	cmp	DWORD PTR _psprite$[ebp], 0
	je	SHORT $LN4@R_DefaultS
	mov	eax, DWORD PTR _psprite$[ebp]
	cmp	DWORD PTR [eax+68], 1
	je	SHORT $LN3@R_DefaultS
$LN4@R_DefaultS:

; 1284 : 	{
; 1285 : 		Con_Reportf( "No Sprite %d!\n", spriteIndex );

	mov	eax, DWORD PTR _spriteIndex$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@FJBFKKAM@No?5Sprite?5?$CFd?$CB?6@
	call	_Con_Reportf
	add	esp, 8

; 1286 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN3@R_DefaultS:

; 1287 : 	}
; 1288 : 
; 1289 : 	pTemp = CL_TempEntAlloc( pos, psprite );

	mov	eax, DWORD PTR _psprite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1290 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_DefaultS
	xor	eax, eax
	jmp	$LN1@R_DefaultS
$LN5@R_DefaultS:

; 1291 : 
; 1292 : 	pTemp->entity.curstate.scale = 1.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1044], xmm0

; 1293 : 	pTemp->flags |= FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1294 : 	if( framerate == 0 ) framerate = 10;

	movss	xmm0, DWORD PTR _framerate$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DefaultS
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _framerate$[ebp], xmm0
$LN6@R_DefaultS:

; 1295 : 
; 1296 : 	pTemp->entity.curstate.framerate = framerate;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _framerate$[ebp]
	movss	DWORD PTR [eax+1076], xmm0

; 1297 : 	pTemp->die = cl.time + (float)pTemp->frameMax / framerate;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	divss	xmm0, DWORD PTR _framerate$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 1298 : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1028], xmm0

; 1299 : 
; 1300 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_DefaultS:

; 1301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DefaultSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_TempSprite
_TEXT	SEGMENT
_pmodel$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_scale$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_rendermode$ = 24					; size = 4
_renderfx$ = 28						; size = 4
_a$ = 32						; size = 4
_life$ = 36						; size = 4
_flags$ = 40						; size = 4
_R_TempSprite PROC					; COMDAT

; 1336 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1337 : 	TEMPENTITY	*pTemp;
; 1338 : 	model_t		*pmodel;
; 1339 : 
; 1340 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN2@R_TempSpri

; 1341 : 	{
; 1342 : 		Con_Reportf( S_ERROR "No model %d!\n", modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	push	OFFSET ??_C@_0BJ@DIEJGHFK@?$FO1Error?3?$FO7?5No?5model?5?$CFd?$CB?6@
	call	_Con_Reportf
	add	esp, 8

; 1343 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_TempSpri
$LN2@R_TempSpri:

; 1344 : 	}
; 1345 : 
; 1346 : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1347 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_TempSpri
	xor	eax, eax
	jmp	$LN1@R_TempSpri
$LN3@R_TempSpri:

; 1348 : 
; 1349 : 	pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 1350 : 	pTemp->entity.curstate.rendermode = rendermode;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _rendermode$[ebp]
	mov	DWORD PTR [eax+1052], ecx

; 1351 : 	pTemp->entity.curstate.renderfx = renderfx;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _renderfx$[ebp]
	mov	DWORD PTR [eax+1064], ecx

; 1352 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 1353 : 	pTemp->entity.baseline.renderamt = a * 255;

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 1354 : 	pTemp->entity.curstate.renderamt = a * 255;

	movss	xmm0, DWORD PTR _a$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], eax

; 1355 : 	pTemp->flags |= flags;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1356 : 
; 1357 : 	VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1358 : 
; 1359 : 	if( life ) pTemp->die = cl.time + life;

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@R_TempSpri
	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	jmp	SHORT $LN5@R_TempSpri
$LN4@R_TempSpri:

; 1360 : 	else pTemp->die = cl.time + ( pTemp->frameMax * 0.1f ) + 1.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
$LN5@R_TempSpri:

; 1361 : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1028], xmm0

; 1362 : 
; 1363 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_TempSpri:

; 1364 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_TempModel
_TEXT	SEGMENT
tv135 = -76						; size = 4
_pmodel$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_dir$ = 12						; size = 4
_angles$ = 16						; size = 4
_life$ = 20						; size = 4
_modelIndex$ = 24					; size = 4
_soundtype$ = 28					; size = 4
_R_TempModel PROC					; COMDAT

; 1224 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1225 : 	// alloc a new tempent
; 1226 : 	TEMPENTITY	*pTemp;
; 1227 : 	model_t		*pmodel;
; 1228 : 
; 1229 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN4@R_TempMode

; 1230 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@R_TempMode
$LN4@R_TempMode:

; 1231 : 
; 1232 : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1233 : 	if( !pTemp ) return NULL;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN5@R_TempMode
	xor	eax, eax
	jmp	$LN1@R_TempMode
$LN5@R_TempMode:

; 1234 : 
; 1235 : 	pTemp->flags = (FTENT_COLLIDEWORLD|FTENT_GRAVITY);

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 34			; 00000022H

; 1236 : 	VectorCopy( dir, pTemp->entity.baseline.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+92], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+92], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _dir$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+92], eax

; 1237 : 	VectorCopy( angles, pTemp->entity.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+3304], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+3304], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+3304], eax

; 1238 : 
; 1239 : 	// keep track of shell type
; 1240 : 	switch( soundtype )

	mov	eax, DWORD PTR _soundtype$[ebp]
	mov	DWORD PTR tv135[ebp], eax
	cmp	DWORD PTR tv135[ebp], 1
	je	SHORT $LN6@R_TempMode
	cmp	DWORD PTR tv135[ebp], 2
	je	$LN7@R_TempMode
	jmp	$LN2@R_TempMode
$LN6@R_TempMode:

; 1241 : 	{
; 1242 : 	case TE_BOUNCE_SHELL:
; 1243 : 		pTemp->hitSound = BOUNCE_SHELL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+32], 32			; 00000020H

; 1244 : 		pTemp->entity.baseline.angles[0] = COM_RandomFloat( -512, 511 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43ff8000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c4000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1245 : 		pTemp->entity.baseline.angles[1] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1246 : 		pTemp->entity.baseline.angles[2] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1247 : 		pTemp->flags |= FTENT_ROTATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1248 : 		break;

	jmp	$LN2@R_TempMode
$LN7@R_TempMode:

; 1249 : 	case TE_BOUNCE_SHOTSHELL:
; 1250 : 		pTemp->hitSound = BOUNCE_SHOTSHELL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+32], 128			; 00000080H

; 1251 : 		pTemp->entity.baseline.angles[0] = COM_RandomFloat( -512, 511 );

	push	ecx
	movss	xmm0, DWORD PTR __real@43ff8000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c4000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1252 : 		pTemp->entity.baseline.angles[1] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1253 : 		pTemp->entity.baseline.angles[2] = COM_RandomFloat( -255, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1254 : 		pTemp->flags |= FTENT_ROTATE|FTENT_SLOWGRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@R_TempMode:

; 1255 : 		break;
; 1256 : 	}
; 1257 : 
; 1258 : 	if( pmodel->type == mod_sprite )

	mov	eax, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	SHORT $LN8@R_TempMode

; 1259 : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0
	jmp	SHORT $LN9@R_TempMode
$LN8@R_TempMode:

; 1260 : 	else pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+1100], eax
$LN9@R_TempMode:

; 1261 : 
; 1262 : 	pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1263 : 
; 1264 : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@R_TempMode:

; 1265 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_TempModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_BreakModel
_TEXT	SEGMENT
tv446 = -116						; size = 8
tv449 = -108						; size = 8
tv432 = -104						; size = 4
tv419 = -104						; size = 4
tv406 = -104						; size = 4
tv337 = -104						; size = 4
tv323 = -104						; size = 4
tv309 = -104						; size = 4
_vecSpot$1 = -36					; size = 12
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_type$ = -13						; size = 1
_pmodel$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pos$ = 8						; size = 4
_size$ = 12						; size = 4
_dir$ = 16						; size = 4
_random$ = 20						; size = 4
_life$ = 24						; size = 4
_count$ = 28						; size = 4
_modelIndex$ = 32					; size = 4
_flags$ = 36						; size = 1
_R_BreakModel PROC					; COMDAT

; 1136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1137 : 	TEMPENTITY	*pTemp;
; 1138 : 	model_t		*pmodel;
; 1139 : 	char		type;
; 1140 : 	int		i, j;
; 1141 : 
; 1142 : 	if(( pmodel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pmodel$[ebp], eax
	cmp	DWORD PTR _pmodel$[ebp], 0
	jne	SHORT $LN8@R_BreakMod

; 1143 : 		return;

	jmp	$LN3@R_BreakMod
$LN8@R_BreakMod:

; 1144 : 
; 1145 : 	type = flags & BREAK_TYPEMASK;

	movsx	eax, BYTE PTR _flags$[ebp]
	and	eax, 79					; 0000004fH
	mov	BYTE PTR _type$[ebp], al

; 1146 : 
; 1147 : 	if( count == 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN9@R_BreakMod

; 1148 : 	{
; 1149 : 		// assume surface (not volume)
; 1150 : 		count = (size[0] * size[1] + size[1] * size[2] + size[2] * size[0]) / (3 * SHARD_VOLUME * SHARD_VOLUME);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, DWORD PTR [esi+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx]
	mulss	xmm1, DWORD PTR [esi+edx]
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _size$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [edx+ecx]
	mulss	xmm1, DWORD PTR [esi+eax]
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@43d80000
	cvttss2si eax, xmm0
	mov	DWORD PTR _count$[ebp], eax
$LN9@R_BreakMod:

; 1151 : 	}
; 1152 : 
; 1153 : 	// limit to 100 pieces
; 1154 : 	if( count > 100 ) count = 100;

	cmp	DWORD PTR _count$[ebp], 100		; 00000064H
	jle	SHORT $LN10@R_BreakMod
	mov	DWORD PTR _count$[ebp], 100		; 00000064H
$LN10@R_BreakMod:

; 1155 : 
; 1156 : 	for( i = 0; i < count; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BreakMod
$LN2@R_BreakMod:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_BreakMod:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_BreakMod

; 1157 : 	{
; 1158 : 		vec3_t	vecSpot;
; 1159 : 
; 1160 : 		for( j = 0; j < 32; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@R_BreakMod
$LN5@R_BreakMod:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@R_BreakMod:
	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jge	$LN6@R_BreakMod

; 1161 : 		{
; 1162 : 			// fill up the box with stuff
; 1163 : 			vecSpot[0] = pos[0] + COM_RandomFloat( -0.5f, 0.5f ) * size[0];

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv309[ebp]
	movss	xmm0, DWORD PTR tv309[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSpot$1[ebp+eax], xmm0

; 1164 : 			vecSpot[1] = pos[1] + COM_RandomFloat( -0.5f, 0.5f ) * size[1];

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv323[ebp]
	movss	xmm0, DWORD PTR tv323[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _vecSpot$1[ebp+eax], xmm0

; 1165 : 			vecSpot[2] = pos[2] + COM_RandomFloat( -0.5f, 0.5f ) * size[2];

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv337[ebp]
	movss	xmm0, DWORD PTR tv337[ebp]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _size$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _pos$[ebp]
	addss	xmm0, DWORD PTR [edx+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _vecSpot$1[ebp+eax], xmm0

; 1166 : 
; 1167 : 			if( CL_PointContents( vecSpot ) != CONTENTS_SOLID )

	lea	eax, DWORD PTR _vecSpot$1[ebp]
	push	eax
	call	_CL_PointContents
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN11@R_BreakMod

; 1168 : 				break; // valid spot

	jmp	SHORT $LN6@R_BreakMod
$LN11@R_BreakMod:

; 1169 : 		}

	jmp	$LN5@R_BreakMod
$LN6@R_BreakMod:

; 1170 : 
; 1171 : 		if( j == 32 ) continue; // a piece completely stuck in the wall, ignore it

	cmp	DWORD PTR _j$[ebp], 32			; 00000020H
	jne	SHORT $LN12@R_BreakMod
	jmp	$LN2@R_BreakMod
$LN12@R_BreakMod:

; 1172 : 
; 1173 : 		pTemp = CL_TempEntAlloc( vecSpot, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSpot$1[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1174 : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN13@R_BreakMod
	jmp	$LN3@R_BreakMod
$LN13@R_BreakMod:

; 1175 : 
; 1176 : 		// keep track of break_type, so we know how to play sound on collision
; 1177 : 		pTemp->hitSound = type;

	movsx	eax, BYTE PTR _type$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 1178 : 		
; 1179 : 		if( pmodel->type == mod_sprite )

	mov	eax, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	SHORT $LN14@R_BreakMod

; 1180 : 			pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0
	jmp	SHORT $LN16@R_BreakMod
$LN14@R_BreakMod:

; 1181 : 		else if( pmodel->type == mod_studio )

	mov	eax, DWORD PTR _pmodel$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN16@R_BreakMod

; 1182 : 			pTemp->entity.curstate.body = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx+1100], eax
$LN16@R_BreakMod:

; 1183 : 
; 1184 : 		pTemp->flags |= FTENT_COLLIDEWORLD | FTENT_FADEOUT | FTENT_SLOWGRAVITY;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1185 : 
; 1186 : 		if( COM_RandomLong( 0, 255 ) < 200 ) 

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 200				; 000000c8H
	jge	$LN17@R_BreakMod

; 1187 : 		{
; 1188 : 			pTemp->flags |= FTENT_ROTATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 4
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1189 : 			pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1190 : 			pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1191 : 			pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256, 255 );

	push	ecx
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]
$LN17@R_BreakMod:

; 1192 : 		}
; 1193 : 
; 1194 : 		if (( COM_RandomLong( 0, 255 ) < 100 ) && FBitSet( flags, BREAK_SMOKE ))

	push	255					; 000000ffH
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN18@R_BreakMod
	movsx	eax, BYTE PTR _flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN18@R_BreakMod

; 1195 : 			pTemp->flags |= FTENT_SMOKETRAIL;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx
$LN18@R_BreakMod:

; 1196 : 
; 1197 : 		if(( type == BREAK_GLASS ) || FBitSet( flags, BREAK_TRANS ))

	movsx	eax, BYTE PTR _type$[ebp]
	cmp	eax, 1
	je	SHORT $LN21@R_BreakMod
	movsx	eax, BYTE PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN19@R_BreakMod
$LN21@R_BreakMod:

; 1198 : 		{
; 1199 : 			pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 2

; 1200 : 			pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 128;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 128		; 00000080H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], 128		; 00000080H

; 1201 : 		}

	jmp	SHORT $LN20@R_BreakMod
$LN19@R_BreakMod:

; 1202 : 		else
; 1203 : 		{
; 1204 : 			pTemp->entity.curstate.rendermode = kRenderNormal;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 0

; 1205 : 			pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 255; // set this for fadeout

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 255		; 000000ffH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], 255		; 000000ffH
$LN20@R_BreakMod:

; 1206 : 		}
; 1207 : 
; 1208 : 		pTemp->entity.baseline.origin[0] = dir[0] + COM_RandomFloat( -random, random );

	mov	eax, 4
	imul	esi, eax, 0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv406[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv406[ebp]
	addss	xmm0, DWORD PTR [ecx+esi]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0

; 1209 : 		pTemp->entity.baseline.origin[1] = dir[1] + COM_RandomFloat( -random, random );

	mov	esi, 4
	shl	esi, 0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv419[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv419[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1210 : 		pTemp->entity.baseline.origin[2] = dir[2] + COM_RandomFloat( 0, random );

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv432[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	movss	xmm0, DWORD PTR tv432[ebp]
	addss	xmm0, DWORD PTR [eax+esi]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1211 : 
; 1212 : 		pTemp->die = cl.time + life + COM_RandomFloat( 0.0f, 1.0f ); // Add an extra 0-1 secs of life

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	push	ecx
	movss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm1
	push	ecx
	xorps	xmm1, xmm1
	movss	DWORD PTR [esp], xmm1
	movsd	QWORD PTR tv449[ebp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv446[ebp]
	movsd	xmm0, QWORD PTR tv449[ebp]
	addsd	xmm0, QWORD PTR tv446[ebp]
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1213 : 	}

	jmp	$LN2@R_BreakMod
$LN3@R_BreakMod:

; 1214 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BreakModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_BloodSprite
_TEXT	SEGMENT
tv423 = -116						; size = 8
tv442 = -112						; size = 4
tv296 = -112						; size = 4
_pos$ = -44						; size = 12
_pTemp$ = -32						; size = 4
_splatter$ = -28					; size = 4
_i$ = -24						; size = 4
_spatterindex$ = -20					; size = 4
_impactindex$ = -16					; size = 4
_pModel2$ = -12						; size = 4
_pModel$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_org$ = 8						; size = 4
_colorIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_modelIndex2$ = 20					; size = 4
_size$ = 24						; size = 4
_R_BloodSprite PROC					; COMDAT

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1051 : 	model_t		*pModel, *pModel2;
; 1052 : 	int		impactindex;
; 1053 : 	int		spatterindex;
; 1054 : 	int		i, splatter;
; 1055 : 	TEMPENTITY	*pTemp;
; 1056 : 	vec3_t		pos;
; 1057 : 
; 1058 : 	colorIndex += COM_RandomLong( 1, 3 );

	push	3
	push	1
	call	_COM_RandomLong
	add	esp, 8
	add	eax, DWORD PTR _colorIndex$[ebp]
	mov	DWORD PTR _colorIndex$[ebp], eax

; 1059 : 	impactindex = colorIndex;

	mov	eax, DWORD PTR _colorIndex$[ebp]
	mov	DWORD PTR _impactindex$[ebp], eax

; 1060 : 	spatterindex = colorIndex - 1;

	mov	eax, DWORD PTR _colorIndex$[ebp]
	sub	eax, 1
	mov	DWORD PTR _spatterindex$[ebp], eax

; 1061 : 
; 1062 : 	// validate the model first
; 1063 : 	if(( pModel = CL_ModelHandle( modelIndex )) != NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax
	cmp	DWORD PTR _pModel$[ebp], 0
	je	$LN6@R_BloodSpr

; 1064 : 	{
; 1065 : 		VectorCopy( org, pos );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _pos$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _pos$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _pos$[ebp+ecx], eax

; 1066 : 		pos[2] += COM_RandomFloat( 2.0f, 4.0f ); // make offset from ground (snarks issues)

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv296[ebp]
	movss	xmm0, DWORD PTR tv296[ebp]
	addss	xmm0, DWORD PTR _pos$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _pos$[ebp+eax], xmm0

; 1067 : 
; 1068 : 		// large, single blood sprite is a high-priority tent
; 1069 : 		if(( pTemp = CL_TempEntAllocHigh( pos, pModel )) != NULL )

	mov	eax, DWORD PTR _pModel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN6@R_BloodSpr

; 1070 : 		{
; 1071 : 			pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 2

; 1072 : 			pTemp->entity.curstate.renderfx = kRenderFxClampMinScale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 20		; 00000014H

; 1073 : 			pTemp->entity.curstate.scale = COM_RandomFloat( size / 25.0f, size / 35.0f );

	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@420c0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1044]

; 1074 : 			pTemp->flags = FTENT_SPRANIMATE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 256			; 00000100H

; 1075 : 
; 1076 : 			pTemp->entity.curstate.rendercolor = clgame.palette[impactindex];

	imul	eax, DWORD PTR _impactindex$[ebp], 3
	add	eax, OFFSET _clgame+217656
	mov	ecx, DWORD PTR _pTemp$[ebp]
	add	ecx, 1060				; 00000424H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al

; 1077 : 			pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 250;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 250		; 000000faH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 250		; 000000faH

; 1078 : 
; 1079 : 			pTemp->entity.curstate.framerate = pTemp->frameMax * 4.0f; // Finish in 0.250 seconds

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+1076], xmm0

; 1080 : 			pTemp->die = cl.time + (pTemp->frameMax / pTemp->entity.curstate.framerate ); // play the whole thing once

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	divss	xmm0, DWORD PTR [ecx+1076]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 1081 : 
; 1082 : 			pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1028], xmm0

; 1083 : 			pTemp->bounceFactor = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+28], xmm0

; 1084 : 			pTemp->entity.angles[2] = COM_RandomLong( 0, 360 );

	push	360					; 00000168H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+3304], xmm0
$LN6@R_BloodSpr:

; 1085 : 		}
; 1086 : 	}
; 1087 : 
; 1088 : 	// validate the model first
; 1089 : 	if(( pModel2 = CL_ModelHandle( modelIndex2 )) != NULL )

	mov	eax, DWORD PTR _modelIndex2$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel2$[ebp], eax
	cmp	DWORD PTR _pModel2$[ebp], 0
	je	$LN3@R_BloodSpr

; 1090 : 	{
; 1091 : 		splatter = size + ( COM_RandomLong( 1, 8 ) + COM_RandomLong( 1, 8 ));

	push	8
	push	1
	call	_COM_RandomLong
	add	esp, 8
	mov	esi, eax
	push	8
	push	1
	call	_COM_RandomLong
	add	esp, 8
	add	esi, eax
	cvtsi2ss xmm0, esi
	addss	xmm0, DWORD PTR _size$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _splatter$[ebp], eax

; 1092 : 
; 1093 : 		for( i = 0; i < splatter; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BloodSpr
$LN2@R_BloodSpr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_BloodSpr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _splatter$[ebp]
	jge	$LN3@R_BloodSpr

; 1094 : 		{
; 1095 : 			// create blood drips
; 1096 : 			if(( pTemp = CL_TempEntAlloc( org, pModel2 )) != NULL )

	mov	eax, DWORD PTR _pModel2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN8@R_BloodSpr

; 1097 : 			{
; 1098 : 				pTemp->entity.curstate.rendermode = kRenderTransTexture;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 2

; 1099 : 				pTemp->entity.curstate.renderfx = kRenderFxClampMinScale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 20		; 00000014H

; 1100 : 				pTemp->entity.curstate.scale = COM_RandomFloat( size / 15.0f, size / 25.0f );

	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41c80000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	divss	xmm0, DWORD PTR __real@41700000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1044]

; 1101 : 				pTemp->flags = FTENT_ROTATE | FTENT_SLOWGRAVITY | FTENT_COLLIDEWORLD;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 1102 : 
; 1103 : 				pTemp->entity.curstate.rendercolor = clgame.palette[spatterindex];

	imul	eax, DWORD PTR _spatterindex$[ebp], 3
	add	eax, OFFSET _clgame+217656
	mov	ecx, DWORD PTR _pTemp$[ebp]
	add	ecx, 1060				; 00000424H
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al

; 1104 : 				pTemp->entity.baseline.renderamt = pTemp->entity.curstate.renderamt = 250;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 250		; 000000faH
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], 250		; 000000faH

; 1105 : 
; 1106 : 				pTemp->entity.baseline.origin[0] = COM_RandomFloat( -96.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1107 : 				pTemp->entity.baseline.origin[1] = COM_RandomFloat( -96.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1108 : 				pTemp->entity.baseline.origin[2] = COM_RandomFloat( -32.0f, 95.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@42be0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c2000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1109 : 				pTemp->entity.baseline.angles[0] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+104]

; 1110 : 				pTemp->entity.baseline.angles[1] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1111 : 				pTemp->entity.baseline.angles[2] = COM_RandomFloat( -256.0f, -255.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c37f0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+104]

; 1112 : 
; 1113 : 				pTemp->die = cl.time + COM_RandomFloat( 1.0f, 3.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	QWORD PTR tv423[ebp]
	movsd	xmm0, QWORD PTR tv423[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1114 : 
; 1115 : 				pTemp->entity.curstate.frame = COM_RandomLong( 1, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	1
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 1116 : 
; 1117 : 				if( pTemp->entity.curstate.frame > 8.0f )

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR [eax+1028]
	comiss	xmm0, DWORD PTR __real@41000000
	jbe	SHORT $LN9@R_BloodSpr

; 1118 : 					pTemp->entity.curstate.frame = pTemp->frameMax;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+1028], edx
$LN9@R_BloodSpr:

; 1119 : 
; 1120 : 				pTemp->entity.baseline.origin[2] += COM_RandomFloat( 4.0f, 16.0f ) * size;

	mov	esi, 4
	shl	esi, 1
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv442[ebp]
	movss	xmm0, DWORD PTR tv442[ebp]
	mulss	xmm0, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	addss	xmm0, DWORD PTR [eax+esi+92]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0

; 1121 : 				pTemp->entity.angles[2] = COM_RandomFloat( 0.0f, 360.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+3304]

; 1122 : 				pTemp->bounceFactor	= 0.0f;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+28], xmm0
$LN8@R_BloodSpr:

; 1123 : 			}
; 1124 : 		}

	jmp	$LN2@R_BloodSpr
$LN3@R_BloodSpr:

; 1125 : 	}
; 1126 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BloodSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_MuzzleFlash
_TEXT	SEGMENT
_scale$ = -12						; size = 4
_index$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_type$ = 12						; size = 4
_R_MuzzleFlash PROC					; COMDAT

; 1011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1012 : 	TEMPENTITY	*pTemp;
; 1013 : 	int		index;
; 1014 : 	float		scale;
; 1015 : 
; 1016 : 	index = ( type % 10 ) % MAX_MUZZLEFLASH;

	mov	eax, DWORD PTR _type$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	eax, edx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _index$[ebp], edx

; 1017 : 	scale = ( type / 10 ) * 0.1f;

	mov	eax, DWORD PTR _type$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 1018 : 	if( scale == 0.0f ) scale = 0.5f;

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_MuzzleFl
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _scale$[ebp], xmm0
$LN2@R_MuzzleFl:

; 1019 : 
; 1020 : 	if( !cl_sprite_muzzleflash[index] )

	mov	eax, DWORD PTR _index$[ebp]
	cmp	DWORD PTR _cl_sprite_muzzleflash[eax*4], 0
	jne	SHORT $LN3@R_MuzzleFl

; 1021 : 		return;

	jmp	$LN1@R_MuzzleFl
$LN3@R_MuzzleFl:

; 1022 : 
; 1023 : 	// must set position for right culling on render
; 1024 : 	pTemp = CL_TempEntAllocHigh( pos, cl_sprite_muzzleflash[index] );

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _cl_sprite_muzzleflash[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 1025 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN4@R_MuzzleFl
	jmp	$LN1@R_MuzzleFl
$LN4@R_MuzzleFl:

; 1026 : 	pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 5

; 1027 : 	pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 1028 : 	pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 1029 : 	pTemp->entity.curstate.renderfx = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 0

; 1030 : 	pTemp->die = cl.time + 0.01; // die at next frame

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae147ae147b
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1031 : 	pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 1032 : 	pTemp->flags |= FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65792				; 00010100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1033 : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 1034 : 
; 1035 : 	if( index == 0 ) pTemp->entity.angles[2] = COM_RandomLong( 0, 20 ); // rifle flash

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN5@R_MuzzleFl
	push	20					; 00000014H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+3304], xmm0
	jmp	SHORT $LN6@R_MuzzleFl
$LN5@R_MuzzleFl:

; 1036 : 	else pTemp->entity.angles[2] = COM_RandomLong( 0, 359 );

	push	359					; 00000167H
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+3304], xmm0
$LN6@R_MuzzleFl:

; 1037 : 
; 1038 : 	CL_TempEntAddEntity( &pTemp->entity );

	mov	eax, DWORD PTR _pTemp$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	_CL_TempEntAddEntity
	add	esp, 4
$LN1@R_MuzzleFl:

; 1039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_MuzzleFlash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_RocketFlare
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_R_RocketFlare PROC					; COMDAT

; 985  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 986  : 	TEMPENTITY	*pTemp;
; 987  : 
; 988  : 	if( !cl_sprite_glow ) return;

	cmp	DWORD PTR _cl_sprite_glow, 0
	jne	SHORT $LN2@R_RocketFl
	jmp	$LN1@R_RocketFl
$LN2@R_RocketFl:

; 989  : 
; 990  : 	pTemp = CL_TempEntAlloc( pos, cl_sprite_glow );

	mov	eax, DWORD PTR _cl_sprite_glow
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 991  : 	if ( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN3@R_RocketFl
	jmp	$LN1@R_RocketFl
$LN3@R_RocketFl:

; 992  : 
; 993  : 	pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 3

; 994  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 995  : 	pTemp->entity.curstate.renderamt = 200;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 200		; 000000c8H

; 996  : 	pTemp->entity.curstate.framerate = 1.0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1076], xmm0

; 997  : 	pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 998  : 	pTemp->entity.curstate.scale = 1.0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1044], xmm0

; 999  : 	pTemp->die = cl.time + 0.01f;	// when 100 fps die at next frame

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 1000 : 	pTemp->entity.curstate.effects = EF_NOINTERP;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1040], 32		; 00000020H
$LN1@R_RocketFl:

; 1001 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RocketFlare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_RicochetSprite
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_duration$ = 16						; size = 4
_scale$ = 20						; size = 4
_R_RicochetSprite PROC					; COMDAT

; 959  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 960  : 	TEMPENTITY	*pTemp;
; 961  : 
; 962  : 	pTemp = CL_TempEntAlloc( pos, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 963  : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_Ricochet
	jmp	$LN1@R_Ricochet
$LN2@R_Ricochet:

; 964  : 
; 965  : 	pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 3

; 966  : 	pTemp->entity.curstate.renderamt = pTemp->entity.baseline.renderamt = 200;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+152], 200		; 000000c8H
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], 200		; 000000c8H

; 967  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 968  : 	pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 969  : 	pTemp->die = cl.time + duration;

	cvtss2sd xmm0, DWORD PTR _duration$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 970  : 	pTemp->flags = FTENT_FADEOUT;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 128			; 00000080H

; 971  : 	pTemp->fadeSpeed = 8;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR [eax+24], xmm0

; 972  : 
; 973  : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1028], xmm0

; 974  : 	pTemp->entity.angles[ROLL] = 45.0f * COM_RandomLong( 0, 7 );

	push	7
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@42340000
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+3304], xmm0
$LN1@R_Ricochet:

; 975  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RicochetSprite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_KillAttachedTents
_TEXT	SEGMENT
_pTemp$1 = -8						; size = 4
_i$ = -4						; size = 4
_client$ = 8						; size = 4
_R_KillAttachedTents PROC				; COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 929  : 	int	i;
; 930  : 
; 931  : 	if( client <= 0 || client > cl.maxclients )

	cmp	DWORD PTR _client$[ebp], 0
	jle	SHORT $LN6@R_KillAtta
	mov	eax, DWORD PTR _client$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jle	SHORT $LN5@R_KillAtta
$LN6@R_KillAtta:

; 932  : 		return;

	jmp	SHORT $LN3@R_KillAtta
$LN5@R_KillAtta:

; 933  : 
; 934  : 	for( i = 0; i < GI->max_tents; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_KillAtta
$LN2@R_KillAtta:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_KillAtta:
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1660]
	jge	SHORT $LN3@R_KillAtta

; 935  : 	{
; 936  : 		TEMPENTITY *pTemp = &cl_tempents[i];

	imul	eax, DWORD PTR _i$[ebp], 3404
	add	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR _pTemp$1[ebp], eax

; 937  : 
; 938  : 		if( !FBitSet( pTemp->flags, FTENT_PLYRATTACHMENT ))

	mov	eax, DWORD PTR _pTemp$1[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 32768				; 00008000H
	jne	SHORT $LN7@R_KillAtta

; 939  : 			continue;

	jmp	SHORT $LN2@R_KillAtta
$LN7@R_KillAtta:

; 940  : 
; 941  : 		// this TEMPENTITY is player attached.
; 942  : 		// if it is attached to this client, set it to die instantly.
; 943  : 		if( pTemp->clientIndex == client )

	mov	eax, DWORD PTR _pTemp$1[ebp]
	movsx	ecx, WORD PTR [eax+52]
	cmp	ecx, DWORD PTR _client$[ebp]
	jne	SHORT $LN8@R_KillAtta

; 944  : 		{
; 945  : 			// good enough, it will die on next tent update. 
; 946  : 			pTemp->die = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _pTemp$1[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN8@R_KillAtta:

; 947  : 		}
; 948  : 	}

	jmp	SHORT $LN2@R_KillAtta
$LN3@R_KillAtta:

; 949  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_KillAttachedTents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_AttachTentToPlayer
_TEXT	SEGMENT
_pModel$ = -28						; size = 4
_pClient$ = -24						; size = 4
_position$ = -20					; size = 12
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_client$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_zoffset$ = 16						; size = 4
_life$ = 20						; size = 4
_R_AttachTentToPlayer PROC				; COMDAT

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 873  : 	TEMPENTITY	*pTemp;
; 874  : 	vec3_t		position;
; 875  : 	cl_entity_t	*pClient;
; 876  : 	model_t		*pModel;
; 877  : 
; 878  : 	if( client <= 0 || client > cl.maxclients )

	cmp	DWORD PTR _client$[ebp], 0
	jle	SHORT $LN3@R_AttachTe
	mov	eax, DWORD PTR _client$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jle	SHORT $LN2@R_AttachTe
$LN3@R_AttachTe:

; 879  : 		return;

	jmp	$LN1@R_AttachTe
$LN2@R_AttachTe:

; 880  : 
; 881  : 	pClient = CL_GetEntityByIndex( client );

	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pClient$[ebp], eax

; 882  : 
; 883  : 	if( !pClient || pClient->curstate.messagenum != cl.parsecount )

	cmp	DWORD PTR _pClient$[ebp], 0
	je	SHORT $LN5@R_AttachTe
	mov	eax, DWORD PTR _pClient$[ebp]
	mov	ecx, DWORD PTR [eax+924]
	cmp	ecx, DWORD PTR _cl+8
	je	SHORT $LN4@R_AttachTe
$LN5@R_AttachTe:

; 884  : 		return;

	jmp	$LN1@R_AttachTe
$LN4@R_AttachTe:

; 885  : 
; 886  : 	if(( pModel = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _pModel$[ebp], eax
	cmp	DWORD PTR _pModel$[ebp], 0
	jne	SHORT $LN6@R_AttachTe

; 887  : 		return;

	jmp	$LN1@R_AttachTe
$LN6@R_AttachTe:

; 888  : 
; 889  : 	VectorCopy( pClient->origin, position );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pClient$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _position$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pClient$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _position$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pClient$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _position$[ebp+ecx], eax

; 890  : 	position[2] += zoffset;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _position$[ebp+eax]
	addss	xmm0, DWORD PTR _zoffset$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _position$[ebp+ecx], xmm0

; 891  : 
; 892  : 	pTemp = CL_TempEntAllocHigh( position, pModel );

	mov	eax, DWORD PTR _pModel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _position$[ebp]
	push	ecx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 893  : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN7@R_AttachTe
	jmp	$LN1@R_AttachTe
$LN7@R_AttachTe:

; 894  : 
; 895  : 	pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 896  : 	pTemp->entity.curstate.framerate = 1;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+1076], xmm0

; 897  : 	
; 898  : 	pTemp->clientIndex = client;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	cx, WORD PTR _client$[ebp]
	mov	WORD PTR [eax+52], cx

; 899  : 	pTemp->tentOffset[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+56], xmm0

; 900  : 	pTemp->tentOffset[1] = 0;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax+56], xmm0

; 901  : 	pTemp->tentOffset[2] = zoffset;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zoffset$[ebp]
	movss	DWORD PTR [ecx+eax+56], xmm0

; 902  : 	pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 903  : 	pTemp->flags |= FTENT_PLYRATTACHMENT|FTENT_PERSIST;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 40960				; 0000a000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 904  : 
; 905  : 	// is the model a sprite?
; 906  : 	if( pModel->type == mod_sprite )

	mov	eax, DWORD PTR _pModel$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	SHORT $LN8@R_AttachTe

; 907  : 	{
; 908  : 		pTemp->flags |= FTENT_SPRANIMATE|FTENT_SPRANIMATELOOP;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65792				; 00010100H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 909  : 		pTemp->entity.curstate.framerate = 10;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [eax+1076], xmm0

; 910  : 	}

	jmp	SHORT $LN9@R_AttachTe
$LN8@R_AttachTe:

; 911  : 	else
; 912  : 	{
; 913  : 		// no animation support for attached clientside studio models.
; 914  : 		pTemp->frameMax = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0
$LN9@R_AttachTe:

; 915  : 	}
; 916  : 
; 917  : 	pTemp->entity.curstate.frame = 0;

	mov	eax, DWORD PTR _pTemp$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+1028], xmm0
$LN1@R_AttachTe:

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AttachTentToPlayer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_BubbleTrail
_TEXT	SEGMENT
tv298 = -116						; size = 4
tv139 = -116						; size = 4
_i$ = -48						; size = 4
_mod$ = -44						; size = 4
_origin$ = -40						; size = 12
_angle$ = -28						; size = 4
_dist$ = -24						; size = 4
_zspeed$ = -20						; size = 4
_cosine$ = -16						; size = 4
_sine$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_start$ = 8						; size = 4
_end$ = 12						; size = 4
_height$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_speed$ = 28						; size = 4
_R_BubbleTrail PROC					; COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 828  : 	TEMPENTITY	*pTemp;
; 829  : 	float		sine, cosine, zspeed;
; 830  : 	float		dist, angle;
; 831  : 	vec3_t		origin;
; 832  : 	model_t		*mod;
; 833  : 	int		i;
; 834  : 
; 835  : 	if(( mod = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN5@R_BubbleTr

; 836  : 		return;

	jmp	$LN3@R_BubbleTr
$LN5@R_BubbleTr:

; 837  : 
; 838  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_BubbleTr
$LN2@R_BubbleTr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_BubbleTr:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_BubbleTr

; 839  : 	{
; 840  : 		dist = COM_RandomFloat( 0, 1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 841  : 		VectorLerp( start, dist, end, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	subss	xmm0, DWORD PTR [edi+edx]
	mulss	xmm0, DWORD PTR _dist$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv139[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 842  : 		pTemp = CL_TempEntAlloc( origin, mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 843  : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_BubbleTr
	jmp	$LN3@R_BubbleTr
$LN6@R_BubbleTr:

; 844  : 
; 845  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 846  : 
; 847  : 		pTemp->x = origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+12], eax

; 848  : 		pTemp->y = origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+16], edx

; 849  : 		angle = COM_RandomFloat( -M_PI, M_PI );

	push	ecx
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0490fdb
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _angle$[ebp]

; 850  : 		SinCos( angle, &sine, &cosine );

	lea	eax, DWORD PTR _cosine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sine$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 851  : 
; 852  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 853  : 		VectorSet( pTemp->entity.baseline.origin, speed * cosine, speed * sine, zspeed );

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _cosine$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _sine$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0

; 854  : 		pTemp->die = cl.time + ((height - (origin[2] - start[2])) / zspeed) - 0.1f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _start$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 855  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 856  : 
; 857  : 		// Set sprite scale
; 858  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv298[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv298[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 859  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 860  : 		pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 861  : 	}

	jmp	$LN2@R_BubbleTr
$LN3@R_BubbleTr:

; 862  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_BubbleTrail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Bubbles
_TEXT	SEGMENT
tv273 = -112						; size = 4
_i$ = -44						; size = 4
_mod$ = -40						; size = 4
_origin$ = -36						; size = 12
_zspeed$ = -24						; size = 4
_angle$ = -20						; size = 4
_cosine$ = -16						; size = 4
_sine$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
_height$ = 16						; size = 4
_modelIndex$ = 20					; size = 4
_count$ = 24						; size = 4
_speed$ = 28						; size = 4
_R_Bubbles PROC						; COMDAT

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 782  : 	TEMPENTITY	*pTemp;
; 783  : 	float		sine, cosine;
; 784  : 	float		angle, zspeed;
; 785  : 	vec3_t		origin;
; 786  : 	model_t		*mod;
; 787  : 	int		i;
; 788  : 
; 789  : 	if(( mod = CL_ModelHandle( modelIndex )) == NULL )

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN5@R_Bubbles

; 790  : 		return;

	jmp	$LN3@R_Bubbles
$LN5@R_Bubbles:

; 791  : 
; 792  : 	for ( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Bubbles
$LN2@R_Bubbles:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Bubbles:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_Bubbles

; 793  : 	{
; 794  : 		origin[0] = COM_RandomLong( mins[0], maxs[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _maxs$[ebp]
	cvttss2si eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _mins$[ebp]
	cvttss2si ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_COM_RandomLong
	add	esp, 8
	mov	edx, 4
	imul	ecx, edx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 795  : 		origin[1] = COM_RandomLong( mins[1], maxs[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _maxs$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mins$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 0
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 796  : 		origin[2] = COM_RandomLong( mins[2], maxs[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _maxs$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mins$[ebp]
	cvttss2si edx, DWORD PTR [ecx+eax]
	push	edx
	call	_COM_RandomLong
	add	esp, 8
	mov	ecx, 4
	shl	ecx, 1
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 797  : 		pTemp = CL_TempEntAlloc( origin, mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 798  : 		if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN6@R_Bubbles
	jmp	$LN3@R_Bubbles
$LN6@R_Bubbles:

; 799  : 
; 800  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 801  : 
; 802  : 		pTemp->x = origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+12], eax

; 803  : 		pTemp->y = origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+16], edx

; 804  : 		angle = COM_RandomFloat( -M_PI, M_PI );

	push	ecx
	movss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c0490fdb
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR _angle$[ebp]

; 805  : 		SinCos( angle, &sine, &cosine );

	lea	eax, DWORD PTR _cosine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sine$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 806  : 		
; 807  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 808  : 		VectorSet( pTemp->entity.baseline.origin, speed * cosine, speed * sine, zspeed );

	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _cosine$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	movss	xmm0, DWORD PTR _speed$[ebp]
	mulss	xmm0, DWORD PTR _sine$[ebp]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0

; 809  : 		pTemp->die = cl.time + ((height - (origin[2] - mins[2])) / zspeed) - 0.1f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mins$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	xmm1, DWORD PTR _height$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 810  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 811  : 		
; 812  : 		// Set sprite scale
; 813  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv273[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv273[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 814  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 815  : 		pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 816  : 	}

	jmp	$LN2@R_Bubbles
$LN3@R_Bubbles:

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Bubbles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_FizzEffect
_TEXT	SEGMENT
tv315 = -132						; size = 4
_mod$ = -64						; size = 4
_origin$ = -60						; size = 12
_zspeed$ = -48						; size = 4
_yspeed$ = -44						; size = 4
_xspeed$ = -40						; size = 4
_speed$ = -36						; size = 4
_maxHeight$ = -32					; size = 4
_angle$ = -28						; size = 4
_count$ = -24						; size = 4
_depth$ = -20						; size = 4
_width$ = -16						; size = 4
_i$ = -12						; size = 4
_pTemp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pent$ = 8						; size = 4
_modelIndex$ = 12					; size = 4
_density$ = 16						; size = 4
_R_FizzEffect PROC					; COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 719  : 	TEMPENTITY	*pTemp;
; 720  : 	int		i, width, depth, count;
; 721  : 	float		angle, maxHeight, speed;
; 722  : 	float		xspeed, yspeed, zspeed;
; 723  : 	vec3_t		origin;
; 724  : 	model_t		*mod;
; 725  : 
; 726  : 	if( !pent || pent->curstate.modelindex <= 0 )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $LN6@R_FizzEffe
	mov	eax, DWORD PTR _pent$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jg	SHORT $LN5@R_FizzEffe
$LN6@R_FizzEffe:

; 727  : 		return;

	jmp	$LN3@R_FizzEffe
$LN5@R_FizzEffe:

; 728  : 
; 729  : 	if(( mod = CL_ModelHandle( pent->curstate.modelindex )) == NULL )

	mov	eax, DWORD PTR _pent$[ebp]
	mov	ecx, DWORD PTR [eax+952]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	DWORD PTR _mod$[ebp], eax
	cmp	DWORD PTR _mod$[ebp], 0
	jne	SHORT $LN7@R_FizzEffe

; 730  : 		return;

	jmp	$LN3@R_FizzEffe
$LN7@R_FizzEffe:

; 731  : 
; 732  : 	count = density + 1;

	mov	eax, DWORD PTR _density$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 733  : 	density = count * 3 + 6;

	imul	eax, DWORD PTR _count$[ebp], 3
	add	eax, 6
	mov	DWORD PTR _density$[ebp], eax

; 734  : 	maxHeight = mod->maxs[2] - mod->mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+96]
	subss	xmm0, DWORD PTR [esi+ecx+84]
	movss	DWORD PTR _maxHeight$[ebp], xmm0

; 735  : 	width = mod->maxs[0] - mod->mins[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+96]
	subss	xmm0, DWORD PTR [esi+eax+84]
	cvttss2si eax, xmm0
	mov	DWORD PTR _width$[ebp], eax

; 736  : 	depth = mod->maxs[1] - mod->mins[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _mod$[ebp]
	mov	esi, DWORD PTR _mod$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+96]
	subss	xmm0, DWORD PTR [esi+ecx+84]
	cvttss2si eax, xmm0
	mov	DWORD PTR _depth$[ebp], eax

; 737  : 
; 738  : 	speed = ( pent->curstate.rendercolor.r<<8 | pent->curstate.rendercolor.g );

	mov	eax, DWORD PTR _pent$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	shl	ecx, 8
	mov	edx, DWORD PTR _pent$[ebp]
	movzx	eax, BYTE PTR [edx+993]
	or	ecx, eax
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _speed$[ebp], xmm0

; 739  : 	if( pent->curstate.rendercolor.b )

	mov	eax, DWORD PTR _pent$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	test	ecx, ecx
	je	SHORT $LN8@R_FizzEffe

; 740  : 		speed = -speed;

	movss	xmm0, DWORD PTR _speed$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _speed$[ebp], xmm0
$LN8@R_FizzEffe:

; 741  : 
; 742  : 	angle = DEG2RAD( pent->angles[YAW] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pent$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+3236]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	movss	DWORD PTR _angle$[ebp], xmm0

; 743  : 	SinCos( angle, &yspeed, &xspeed );

	lea	eax, DWORD PTR _xspeed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _yspeed$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SinCos
	add	esp, 12					; 0000000cH

; 744  : 
; 745  : 	xspeed *= speed;

	movss	xmm0, DWORD PTR _xspeed$[ebp]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _xspeed$[ebp], xmm0

; 746  : 	yspeed *= speed;

	movss	xmm0, DWORD PTR _yspeed$[ebp]
	mulss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR _yspeed$[ebp], xmm0

; 747  : 
; 748  : 	for( i = 0; i < count; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_FizzEffe
$LN2@R_FizzEffe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_FizzEffe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jge	$LN3@R_FizzEffe

; 749  : 	{
; 750  : 		origin[0] = mod->mins[0] + COM_RandomLong( 0, width - 1 );

	mov	eax, 4
	imul	esi, eax, 0
	mov	ecx, DWORD PTR _width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _mod$[ebp]
	addss	xmm0, DWORD PTR [edx+esi+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0

; 751  : 		origin[1] = mod->mins[1] + COM_RandomLong( 0, depth - 1 );

	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR _depth$[ebp]
	sub	eax, 1
	push	eax
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _mod$[ebp]
	addss	xmm0, DWORD PTR [ecx+esi+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0

; 752  : 		origin[2] = mod->mins[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+eax+84]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 753  : 		pTemp = CL_TempEntAlloc( origin, CL_ModelHandle( modelIndex ));

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	_CL_ModelHandle
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 754  : 
; 755  : 		if ( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN9@R_FizzEffe
	jmp	$LN3@R_FizzEffe
$LN9@R_FizzEffe:

; 756  : 
; 757  : 		pTemp->flags |= FTENT_SINEWAVE;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 758  : 
; 759  : 		pTemp->x = origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+12], eax

; 760  : 		pTemp->y = origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [ecx+16], edx

; 761  : 
; 762  : 		zspeed = COM_RandomLong( 80, 140 );

	push	140					; 0000008cH
	push	80					; 00000050H
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _zspeed$[ebp], xmm0

; 763  : 		VectorSet( pTemp->entity.baseline.origin, xspeed, yspeed, zspeed );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _xspeed$[ebp]
	movss	DWORD PTR [edx+ecx+92], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _yspeed$[ebp]
	movss	DWORD PTR [ecx+eax+92], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _zspeed$[ebp]
	movss	DWORD PTR [eax+edx+92], xmm0

; 764  : 		pTemp->die = cl.time + ( maxHeight / zspeed ) - 0.1f;

	movss	xmm0, DWORD PTR _maxHeight$[ebp]
	divss	xmm0, DWORD PTR _zspeed$[ebp]
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR __real@3fb99999a0000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 765  : 		pTemp->entity.curstate.frame = COM_RandomLong( 0, pTemp->frameMax );

	mov	eax, DWORD PTR _pTemp$[ebp]
	cvttss2si ecx, DWORD PTR [eax+8]
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	cvtsi2ss xmm0, eax
	mov	edx, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [edx+1028], xmm0

; 766  : 		// Set sprite scale
; 767  : 		pTemp->entity.curstate.scale = 1.0f / COM_RandomFloat( 2.0f, 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	fstp	DWORD PTR tv315[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv315[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 768  : 		pTemp->entity.curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 4

; 769  : 		pTemp->entity.curstate.renderamt = 255;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1056], 255		; 000000ffH

; 770  : 	}

	jmp	$LN2@R_FizzEffe
$LN3@R_FizzEffe:

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_FizzEffect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntAllocCustom
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_model$ = 12						; size = 4
_high$ = 16						; size = 4
_pfn$ = 20						; size = 4
_CL_TempEntAllocCustom PROC				; COMDAT

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 682  : 	TEMPENTITY	*pTemp;
; 683  : 
; 684  : 	if( high )

	cmp	DWORD PTR _high$[ebp], 0
	je	SHORT $LN2@CL_TempEnt

; 685  : 	{
; 686  : 		pTemp = CL_TempEntAllocHigh( org, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_CL_TempEntAllocHigh
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax

; 687  : 	}

	jmp	SHORT $LN3@CL_TempEnt
$LN2@CL_TempEnt:

; 688  : 	else
; 689  : 	{
; 690  : 		pTemp = CL_TempEntAlloc( org, model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	mov	ecx, DWORD PTR _org$[ebp]
	push	ecx
	call	_CL_TempEntAlloc
	add	esp, 8
	mov	DWORD PTR _pTemp$[ebp], eax
$LN3@CL_TempEnt:

; 691  : 	}
; 692  : 
; 693  : 	if( pTemp && pfn )

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN4@CL_TempEnt
	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $LN4@CL_TempEnt

; 694  : 	{
; 695  : 		pTemp->flags |= FTENT_CLIENTCUSTOM;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 696  : 		pTemp->callback = pfn;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _pfn$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 697  : 		pTemp->die = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN4@CL_TempEnt:

; 698  : 	}
; 699  : 
; 700  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAllocCustom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntAllocNoModel
_TEXT	SEGMENT
_org$ = 8						; size = 4
_CL_TempEntAllocNoModel PROC				; COMDAT

; 669  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 670  : 	return CL_TempEntAlloc( org, NULL );

	push	0
	mov	eax, DWORD PTR _org$[ebp]
	push	eax
	call	_CL_TempEntAlloc
	add	esp, 8

; 671  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAllocNoModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntAllocHigh
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_TempEntAllocHigh PROC				; COMDAT

; 628  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 629  : 	TEMPENTITY	*pTemp;
; 630  : 
; 631  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN2@CL_TempEnt

; 632  : 	{
; 633  : 		// no temporary ents free, so find the first active low-priority temp ent 
; 634  : 		// and overwrite it.
; 635  : 		CL_FreeLowPriorityTempEnt();

	call	_CL_FreeLowPriorityTempEnt
$LN2@CL_TempEnt:

; 636  : 	}
; 637  : 
; 638  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN3@CL_TempEnt

; 639  : 	{
; 640  : 		// didn't find anything? The tent list is either full of high-priority tents
; 641  : 		// or all tents in the list are still due to live for > 10 seconds. 
; 642  : 		Con_DPrintf( "Couldn't alloc a high priority TENT!\n" );

	push	OFFSET ??_C@_0CG@FKBCOHFI@Couldn?8t?5alloc?5a?5high?5priority?5@
	call	_Con_DPrintf
	add	esp, 4

; 643  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN3@CL_TempEnt:

; 644  : 	}
; 645  : 
; 646  : 	// Move out of the free list and into the active list.
; 647  : 	pTemp = cl_free_tents;

	mov	eax, DWORD PTR _cl_free_tents
	mov	DWORD PTR _pTemp$[ebp], eax

; 648  : 	cl_free_tents = pTemp->next;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _cl_free_tents, ecx

; 649  : 
; 650  : 	CL_PrepareTEnt( pTemp, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_CL_PrepareTEnt
	add	esp, 8

; 651  : 
; 652  : 	pTemp->priority = TENTPRIORITY_HIGH;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+48], 1

; 653  : 	if( org ) VectorCopy( org, pTemp->entity.origin );

	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN4@CL_TempEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+3292], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+3292], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+3292], eax
$LN4@CL_TempEnt:

; 654  : 
; 655  : 	pTemp->next = cl_active_tents;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _cl_active_tents
	mov	DWORD PTR [eax+44], ecx

; 656  : 	cl_active_tents = pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR _cl_active_tents, eax

; 657  : 
; 658  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@CL_TempEnt:

; 659  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAllocHigh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntAlloc
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_org$ = 8						; size = 4
_pmodel$ = 12						; size = 4
_CL_TempEntAlloc PROC					; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 598  : 	TEMPENTITY	*pTemp;
; 599  : 
; 600  : 	if( !cl_free_tents )

	cmp	DWORD PTR _cl_free_tents, 0
	jne	SHORT $LN2@CL_TempEnt

; 601  : 	{
; 602  : 		Con_DPrintf( "Overflow %d temporary ents!\n", GI->max_tents );

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1660]
	push	ecx
	push	OFFSET ??_C@_0BN@IBFHIBLB@Overflow?5?$CFd?5temporary?5ents?$CB?6@
	call	_Con_DPrintf
	add	esp, 8

; 603  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@CL_TempEnt
$LN2@CL_TempEnt:

; 604  : 	}
; 605  : 
; 606  : 	pTemp = cl_free_tents;

	mov	eax, DWORD PTR _cl_free_tents
	mov	DWORD PTR _pTemp$[ebp], eax

; 607  : 	cl_free_tents = pTemp->next;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _cl_free_tents, ecx

; 608  : 
; 609  : 	CL_PrepareTEnt( pTemp, pmodel );

	mov	eax, DWORD PTR _pmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_CL_PrepareTEnt
	add	esp, 8

; 610  : 
; 611  : 	pTemp->priority = TENTPRIORITY_LOW;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+48], 0

; 612  : 	if( org ) VectorCopy( org, pTemp->entity.origin );

	cmp	DWORD PTR _org$[ebp], 0
	je	SHORT $LN3@CL_TempEnt
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+3292], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+3292], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	esi, DWORD PTR _org$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+3292], eax
$LN3@CL_TempEnt:

; 613  : 
; 614  : 	pTemp->next = cl_active_tents;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR _cl_active_tents
	mov	DWORD PTR [eax+44], ecx

; 615  : 	cl_active_tents = pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR _cl_active_tents, eax

; 616  : 
; 617  : 	return pTemp;

	mov	eax, DWORD PTR _pTemp$[ebp]
$LN1@CL_TempEnt:

; 618  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_SparkShower
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pos$ = 8						; size = 4
_R_SparkShower PROC					; COMDAT

; 1311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1312 : 	TEMPENTITY	*pTemp;
; 1313 : 
; 1314 : 	pTemp = CL_TempEntAllocNoModel( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_CL_TempEntAllocNoModel
	add	esp, 4
	mov	DWORD PTR _pTemp$[ebp], eax

; 1315 : 	if( !pTemp ) return;

	cmp	DWORD PTR _pTemp$[ebp], 0
	jne	SHORT $LN2@R_SparkSho
	jmp	$LN1@R_SparkSho
$LN2@R_SparkSho:

; 1316 : 
; 1317 : 	pTemp->entity.baseline.origin[0] = COM_RandomFloat( -300.0f, 300.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3960000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [edx+ecx+92]

; 1318 : 	pTemp->entity.baseline.origin[1] = COM_RandomFloat( -300.0f, 300.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43960000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3960000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1319 : 	pTemp->entity.baseline.origin[2] = COM_RandomFloat( -200.0f, 200.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@c3480000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [ecx+eax+92]

; 1320 : 
; 1321 : 	pTemp->flags |= FTENT_SLOWGRAVITY | FTENT_COLLIDEWORLD | FTENT_SPARKSHOWER;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 131112				; 00020028H
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], ecx

; 1322 : 
; 1323 : 	pTemp->entity.curstate.framerate = COM_RandomFloat( 0.5f, 1.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_COM_RandomFloat
	add	esp, 8
	mov	eax, DWORD PTR _pTemp$[ebp]
	fstp	DWORD PTR [eax+1076]

; 1324 : 	pTemp->entity.curstate.scale = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 1325 : 	pTemp->die = cl.time + 0.5;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN1@R_SparkSho:

; 1326 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SparkShower ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _R_Explosion
_TEXT	SEGMENT
_dl$1 = -8						; size = 4
_hSound$ = -4						; size = 4
_pos$ = 8						; size = 4
_model$ = 12						; size = 4
_scale$ = 16						; size = 4
_framerate$ = 20					; size = 4
_flags$ = 24						; size = 4
_R_Explosion PROC					; COMDAT

; 1763 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1764 : 	sound_t	hSound;
; 1765 : 
; 1766 : 	if( scale != 0.0f )

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@R_Explosio

; 1767 : 	{
; 1768 : 		// create explosion sprite
; 1769 : 		R_Sprite_Explode( R_DefaultSprite( pos, model, framerate ), scale, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _framerate$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	push	eax
	call	_R_Sprite_Explode
	add	esp, 12					; 0000000cH

; 1770 : 
; 1771 : 		if( !FBitSet( flags, TE_EXPLFLAG_NOPARTICLES ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	jne	SHORT $LN3@R_Explosio

; 1772 : 			R_FlickerParticles( pos );

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_FlickerParticles
	add	esp, 4
$LN3@R_Explosio:

; 1773 : 
; 1774 : 		if( !FBitSet( flags, TE_EXPLFLAG_NODLIGHTS ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	$LN4@R_Explosio

; 1775 : 		{
; 1776 : 			dlight_t	*dl;
; 1777 : 
; 1778 : 			// big flash
; 1779 : 			dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 1780 : 			VectorCopy( pos, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1781 : 			dl->radius = 200;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [eax+12], xmm0

; 1782 : 			dl->color.r = 250;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+16], 250			; 000000faH

; 1783 : 			dl->color.g = 250;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+17], 250			; 000000faH

; 1784 : 			dl->color.b = 150;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+18], 150			; 00000096H

; 1785 : 			dl->die = cl.time + 0.01f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3f847ae140000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 1786 : 			dl->decay = 80;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@42a00000
	movss	DWORD PTR [eax+24], xmm0

; 1787 : 
; 1788 : 			// red glow
; 1789 : 			dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$1[ebp], eax

; 1790 : 			VectorCopy( pos, dl->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$1[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1791 : 			dl->radius = 150;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43160000
	movss	DWORD PTR [eax+12], xmm0

; 1792 : 			dl->color.r = 255;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+16], 255			; 000000ffH

; 1793 : 			dl->color.g = 190;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+17], 190			; 000000beH

; 1794 : 			dl->color.b = 40;

	mov	eax, DWORD PTR _dl$1[ebp]
	mov	BYTE PTR [eax+18], 40			; 00000028H

; 1795 : 			dl->die = cl.time + 1.0f;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$1[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 1796 : 			dl->decay = 200;

	mov	eax, DWORD PTR _dl$1[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	movss	DWORD PTR [eax+24], xmm0
$LN4@R_Explosio:

; 1797 : 		}
; 1798 : 	}
; 1799 : 
; 1800 : 	if( !FBitSet( flags, TE_EXPLFLAG_NOSOUND ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	jne	SHORT $LN5@R_Explosio

; 1801 : 	{
; 1802 : 		hSound = S_RegisterSound( va( "%s", cl_explode_sounds[COM_RandomLong( 0, 2 )] ));

	push	2
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	eax, DWORD PTR _cl_explode_sounds[eax*4]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _hSound$[ebp], eax

; 1803 : 		S_StartSound( pos, 0, CHAN_STATIC, hSound, VOL_NORM, 0.3f, PITCH_NORM, 0 );

	push	0
	push	100					; 00000064H
	push	ecx
	movss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _hSound$[ebp]
	push	eax
	push	7
	push	0
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN5@R_Explosio:

; 1804 : 	}
; 1805 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Explosion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_LoadClientSprites
_TEXT	SEGMENT
_CL_LoadClientSprites PROC				; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 100  : 	cl_sprite_muzzleflash[0] = CL_LoadClientSprite( cl_default_sprites[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 101  : 	cl_sprite_muzzleflash[1] = CL_LoadClientSprite( cl_default_sprites[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 102  : 	cl_sprite_muzzleflash[2] = CL_LoadClientSprite( cl_default_sprites[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _cl_sprite_muzzleflash[edx], eax

; 103  : 
; 104  : 	cl_sprite_dot = CL_LoadClientSprite( cl_default_sprites[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_dot, eax

; 105  : 	cl_sprite_glow = CL_LoadClientSprite( cl_default_sprites[4] );

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _cl_default_sprites[eax]
	push	ecx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_glow, eax

; 106  : 	cl_sprite_ricochet = CL_LoadClientSprite( cl_default_sprites[5] );

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_ricochet, eax

; 107  : 	cl_sprite_shell = CL_LoadClientSprite( cl_default_sprites[6] );

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _cl_default_sprites[ecx]
	push	edx
	call	_CL_LoadClientSprite
	add	esp, 4
	mov	DWORD PTR _cl_sprite_shell, eax

; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LoadClientSprites ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TempEntUpdate
_TEXT	SEGMENT
_gravity$ = -12						; size = 4
_ft$ = -8						; size = 8
_CL_TempEntUpdate PROC					; COMDAT

; 548  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 549  : 	double	ft = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	movsd	QWORD PTR _ft$[ebp], xmm0

; 550  : 	float	gravity = clgame.movevars.gravity;

	movss	xmm0, DWORD PTR _clgame+1024
	movss	DWORD PTR _gravity$[ebp], xmm0

; 551  : 
; 552  : 	clgame.dllFuncs.pfnTempEntUpdate( ft, cl.time, gravity, &cl_free_tents, &cl_active_tents, CL_TempEntAddEntity, CL_TempEntPlaySound );

	push	OFFSET _CL_TempEntPlaySound
	push	OFFSET _CL_TempEntAddEntity
	push	OFFSET _cl_active_tents
	push	OFFSET _cl_free_tents
	cvtss2sd xmm0, DWORD PTR _gravity$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _ft$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _clgame+144
	add	esp, 40					; 00000028H

; 553  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TempEntUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_FreeTempEnts
_TEXT	SEGMENT
_CL_FreeTempEnts PROC					; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 366  : 	if( cl_tempents )

	cmp	DWORD PTR _cl_tempents, 0
	je	SHORT $LN2@CL_FreeTem

; 367  : 		Mem_Free( cl_tempents );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_FreeTempEnts@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cl_tempents
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@CL_FreeTem:

; 368  : 	cl_tempents = NULL;

	mov	DWORD PTR _cl_tempents, 0

; 369  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FreeTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ClearTempEnts
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearTempEnts PROC					; COMDAT

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 343  : 	int	i;
; 344  : 
; 345  : 	if( !cl_tempents ) return;

	cmp	DWORD PTR _cl_tempents, 0
	jne	SHORT $LN5@CL_ClearTe
	jmp	$LN1@CL_ClearTe
$LN5@CL_ClearTe:

; 346  : 
; 347  : 	for( i = 0; i < GI->max_tents - 1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearTe
$LN2@CL_ClearTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearTe:
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1660]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN3@CL_ClearTe

; 348  : 	{
; 349  : 		cl_tempents[i].next = &cl_tempents[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	ecx, eax, 3404
	add	ecx, DWORD PTR _cl_tempents
	imul	edx, DWORD PTR _i$[ebp], 3404
	mov	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR [eax+edx+44], ecx

; 350  : 		cl_tempents[i].entity.trivial_accept = INVALID_HANDLE;

	imul	eax, DWORD PTR _i$[ebp], 3404
	mov	ecx, DWORD PTR _cl_tempents
	mov	DWORD PTR [ecx+eax+3364], 65535		; 0000ffffH

; 351  : 	}

	jmp	SHORT $LN2@CL_ClearTe
$LN3@CL_ClearTe:

; 352  : 
; 353  : 	cl_tempents[GI->max_tents-1].next = NULL;

	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR [eax+1660]
	sub	ecx, 1
	imul	edx, ecx, 3404
	mov	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR [eax+edx+44], 0

; 354  : 	cl_free_tents = cl_tempents;

	mov	eax, DWORD PTR _cl_tempents
	mov	DWORD PTR _cl_free_tents, eax

; 355  : 	cl_active_tents = NULL;

	mov	DWORD PTR _cl_active_tents, 0
$LN1@CL_ClearTe:

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_InitTempEnts
_TEXT	SEGMENT
_CL_InitTempEnts PROC					; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 328  : 	cl_tempents = Mem_Calloc( cls.mempool, sizeof( TEMPENTITY ) * GI->max_tents );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_InitTempEnts@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _SI+768
	imul	edx, DWORD PTR [ecx+1660], 3404
	push	edx
	mov	eax, DWORD PTR _cls+40
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cl_tempents, eax

; 329  : 	CL_ClearTempEnts();

	call	_CL_ClearTempEnts

; 330  : 
; 331  : 	// load tempent sprites (glowshell, muzzleflashes etc)
; 332  : 	CL_LoadClientSprites ();

	call	_CL_LoadClientSprites

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InitTempEnts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_FxBlend
_TEXT	SEGMENT
tv446 = -116						; size = 8
tv431 = -116						; size = 8
tv546 = -108						; size = 8
tv544 = -108						; size = 8
tv363 = -108						; size = 8
tv355 = -108						; size = 8
tv347 = -108						; size = 8
tv339 = -108						; size = 8
tv510 = -100						; size = 8
tv508 = -100						; size = 8
tv506 = -100						; size = 8
tv504 = -100						; size = 8
tv440 = -100						; size = 8
tv425 = -100						; size = 8
tv416 = -100						; size = 8
tv407 = -100						; size = 8
tv398 = -100						; size = 8
tv312 = -100						; size = 4
tv311 = -96						; size = 4
tv267 = -96						; size = 4
tv68 = -96						; size = 4
_tmp$ = -28						; size = 12
_dist$ = -16						; size = 4
_offset$ = -12						; size = 4
_blend$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_CL_FxBlend PROC					; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 207  : 	int	blend = 0;

	mov	DWORD PTR _blend$[ebp], 0

; 208  : 	float	offset, dist;
; 209  : 	vec3_t	tmp;
; 210  : 
; 211  : 	offset = ((int)e->index ) * 363.0f; // Use ent index to de-sync these fx

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@43b58000
	movss	DWORD PTR _offset$[ebp], xmm0

; 212  : 
; 213  : 	switch( e->curstate.renderfx ) 

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+996]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 1
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 15			; 0000000fH
	ja	$LN46@CL_FxBlend
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN52@CL_FxBlend[eax*4]
$LN4@CL_FxBlend:

; 214  : 	{
; 215  : 	case kRenderFxPulseSlowWide:
; 216  : 		blend = e->curstate.renderamt + 0x40 * sin( cl.time * 2 + offset );	

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+988]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv504[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv339[ebp]
	movsd	xmm0, QWORD PTR tv339[ebp]
	mulsd	xmm0, QWORD PTR __real@4050000000000000
	movsd	xmm1, QWORD PTR tv504[ebp]
	addsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx

; 217  : 		break;

	jmp	$LN2@CL_FxBlend
$LN5@CL_FxBlend:

; 218  : 	case kRenderFxPulseFastWide:
; 219  : 		blend = e->curstate.renderamt + 0x40 * sin( cl.time * 8 + offset );

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+988]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv506[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv347[ebp]
	movsd	xmm0, QWORD PTR tv347[ebp]
	mulsd	xmm0, QWORD PTR __real@4050000000000000
	movsd	xmm1, QWORD PTR tv506[ebp]
	addsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx

; 220  : 		break;

	jmp	$LN2@CL_FxBlend
$LN6@CL_FxBlend:

; 221  : 	case kRenderFxPulseSlow:
; 222  : 		blend = e->curstate.renderamt + 0x10 * sin( cl.time * 2 + offset );

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+988]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv508[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv355[ebp]
	movsd	xmm0, QWORD PTR tv355[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	movsd	xmm1, QWORD PTR tv508[ebp]
	addsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx

; 223  : 		break;

	jmp	$LN2@CL_FxBlend
$LN7@CL_FxBlend:

; 224  : 	case kRenderFxPulseFast:
; 225  : 		blend = e->curstate.renderamt + 0x10 * sin( cl.time * 8 + offset );

	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+988]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4020000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv510[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv363[ebp]
	movsd	xmm0, QWORD PTR tv363[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	movsd	xmm1, QWORD PTR tv510[ebp]
	addsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx

; 226  : 		break;

	jmp	$LN2@CL_FxBlend
$LN8@CL_FxBlend:

; 227  : 	case kRenderFxFadeSlow:			
; 228  : 		if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN11@CL_FxBlend

; 229  : 		{
; 230  : 			if( e->curstate.renderamt > 0 ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+988], 0
	jle	SHORT $LN10@CL_FxBlend

; 231  : 				e->curstate.renderamt -= 1;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	sub	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+988], ecx
	jmp	SHORT $LN11@CL_FxBlend
$LN10@CL_FxBlend:

; 232  : 			else e->curstate.renderamt = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+988], 0
$LN11@CL_FxBlend:

; 233  : 		}
; 234  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx

; 235  : 		break;

	jmp	$LN2@CL_FxBlend
$LN12@CL_FxBlend:

; 236  : 	case kRenderFxFadeFast:
; 237  : 		if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN15@CL_FxBlend

; 238  : 		{
; 239  : 			if( e->curstate.renderamt > 3 ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+988], 3
	jle	SHORT $LN14@CL_FxBlend

; 240  : 				e->curstate.renderamt -= 4;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	sub	ecx, 4
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+988], ecx
	jmp	SHORT $LN15@CL_FxBlend
$LN14@CL_FxBlend:

; 241  : 			else e->curstate.renderamt = 0;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+988], 0
$LN15@CL_FxBlend:

; 242  : 		}
; 243  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx

; 244  : 		break;

	jmp	$LN2@CL_FxBlend
$LN16@CL_FxBlend:

; 245  : 	case kRenderFxSolidSlow:
; 246  : 		if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN19@CL_FxBlend

; 247  : 		{
; 248  : 			if( e->curstate.renderamt < 255 ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+988], 255		; 000000ffH
	jge	SHORT $LN18@CL_FxBlend

; 249  : 				e->curstate.renderamt += 1;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	add	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+988], ecx
	jmp	SHORT $LN19@CL_FxBlend
$LN18@CL_FxBlend:

; 250  : 			else e->curstate.renderamt = 255;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN19@CL_FxBlend:

; 251  : 		}
; 252  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx

; 253  : 		break;

	jmp	$LN2@CL_FxBlend
$LN20@CL_FxBlend:

; 254  : 	case kRenderFxSolidFast:
; 255  : 		if( RP_NORMALPASS( ))

	mov	eax, DWORD PTR _RI
	and	eax, 3
	jne	SHORT $LN23@CL_FxBlend

; 256  : 		{
; 257  : 			if( e->curstate.renderamt < 252 ) 

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+988], 252		; 000000fcH
	jge	SHORT $LN22@CL_FxBlend

; 258  : 				e->curstate.renderamt += 4;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	add	ecx, 4
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [edx+988], ecx
	jmp	SHORT $LN23@CL_FxBlend
$LN22@CL_FxBlend:

; 259  : 			else e->curstate.renderamt = 255;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN23@CL_FxBlend:

; 260  : 		}
; 261  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx

; 262  : 		break;

	jmp	$LN2@CL_FxBlend
$LN24@CL_FxBlend:

; 263  : 	case kRenderFxStrobeSlow:
; 264  : 		blend = 20 * sin( cl.time * 4 + offset );

	movsd	xmm0, QWORD PTR _cl+2167640
	mulsd	xmm0, QWORD PTR __real@4010000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv398[ebp]
	movsd	xmm0, QWORD PTR tv398[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 265  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN25@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN26@CL_FxBlend
$LN25@CL_FxBlend:

; 266  : 		else blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN26@CL_FxBlend:

; 267  : 		break;

	jmp	$LN2@CL_FxBlend
$LN27@CL_FxBlend:

; 268  : 	case kRenderFxStrobeFast:
; 269  : 		blend = 20 * sin( cl.time * 16 + offset );

	movsd	xmm0, QWORD PTR _cl+2167640
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv407[ebp]
	movsd	xmm0, QWORD PTR tv407[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 270  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN28@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN29@CL_FxBlend
$LN28@CL_FxBlend:

; 271  : 		else blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN29@CL_FxBlend:

; 272  : 		break;

	jmp	$LN2@CL_FxBlend
$LN30@CL_FxBlend:

; 273  : 	case kRenderFxStrobeFaster:
; 274  : 		blend = 20 * sin( cl.time * 36 + offset );

	movsd	xmm0, QWORD PTR _cl+2167640
	mulsd	xmm0, QWORD PTR __real@4042000000000000
	cvtss2sd xmm1, DWORD PTR _offset$[ebp]
	addsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv416[ebp]
	movsd	xmm0, QWORD PTR tv416[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 275  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN31@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN32@CL_FxBlend
$LN31@CL_FxBlend:

; 276  : 		else blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN32@CL_FxBlend:

; 277  : 		break;

	jmp	$LN2@CL_FxBlend
$LN33@CL_FxBlend:

; 278  : 	case kRenderFxFlickerSlow:
; 279  : 		blend = 20 * (sin( cl.time * 2 ) + sin( cl.time * 17 + offset ));

	movsd	xmm0, QWORD PTR _cl+2167640
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv425[ebp]
	movsd	xmm0, QWORD PTR tv425[ebp]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4031000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv544[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv431[ebp]
	movsd	xmm0, QWORD PTR tv544[ebp]
	addsd	xmm0, QWORD PTR tv431[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 280  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN34@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN35@CL_FxBlend
$LN34@CL_FxBlend:

; 281  : 		else blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN35@CL_FxBlend:

; 282  : 		break;

	jmp	$LN2@CL_FxBlend
$LN36@CL_FxBlend:

; 283  : 	case kRenderFxFlickerFast:
; 284  : 		blend = 20 * (sin( cl.time * 16 ) + sin( cl.time * 23 + offset ));

	movsd	xmm0, QWORD PTR _cl+2167640
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv440[ebp]
	movsd	xmm0, QWORD PTR tv440[ebp]
	movsd	xmm1, QWORD PTR _cl+2167640
	mulsd	xmm1, QWORD PTR __real@4037000000000000
	cvtss2sd xmm2, DWORD PTR _offset$[ebp]
	addsd	xmm1, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv546[ebp], xmm0
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv446[ebp]
	movsd	xmm0, QWORD PTR tv546[ebp]
	addsd	xmm0, QWORD PTR tv446[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _blend$[ebp], eax

; 285  : 		if( blend < 0 ) blend = 0;

	cmp	DWORD PTR _blend$[ebp], 0
	jge	SHORT $LN37@CL_FxBlend
	mov	DWORD PTR _blend$[ebp], 0
	jmp	SHORT $LN38@CL_FxBlend
$LN37@CL_FxBlend:

; 286  : 		else blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN38@CL_FxBlend:

; 287  : 		break;

	jmp	$LN2@CL_FxBlend
$LN39@CL_FxBlend:

; 288  : 	case kRenderFxHologram:
; 289  : 	case kRenderFxDistort:
; 290  : 		VectorCopy( e->origin, tmp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _tmp$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _tmp$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _tmp$[ebp+ecx], eax

; 291  : 		VectorSubtract( tmp, RI.vieworg, tmp );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+ecx]
	subss	xmm0, DWORD PTR _RI[eax+200]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _tmp$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+eax]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _tmp$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _tmp$[ebp+eax]
	subss	xmm0, DWORD PTR _RI[ecx+200]
	movss	DWORD PTR tv267[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv267[ebp]
	movss	DWORD PTR _tmp$[ebp+edx], xmm0

; 292  : 		dist = DotProduct( tmp, RI.vforward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _tmp$[ebp+ecx]
	mulss	xmm0, DWORD PTR _RI[eax+224]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _tmp$[ebp+ecx]
	mulss	xmm1, DWORD PTR _RI[edx+224]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _tmp$[ebp+eax]
	mulss	xmm1, DWORD PTR _RI[ecx+224]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 293  : 			
; 294  : 		// turn off distance fade
; 295  : 		if( e->curstate.renderfx == kRenderFxDistort )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+996], 15			; 0000000fH
	jne	SHORT $LN41@CL_FxBlend

; 296  : 			dist = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dist$[ebp], xmm0
$LN41@CL_FxBlend:

; 297  : 
; 298  : 		if( dist <= 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jb	SHORT $LN42@CL_FxBlend

; 299  : 		{
; 300  : 			blend = 0;

	mov	DWORD PTR _blend$[ebp], 0

; 301  : 		}

	jmp	SHORT $LN43@CL_FxBlend
$LN42@CL_FxBlend:

; 302  : 		else 
; 303  : 		{
; 304  : 			e->curstate.renderamt = 180;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax+988], 180		; 000000b4H

; 305  : 			if( dist <= 100 ) blend = e->curstate.renderamt;

	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jb	SHORT $LN44@CL_FxBlend
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
	jmp	SHORT $LN45@CL_FxBlend
$LN44@CL_FxBlend:

; 306  : 			else blend = (int) ((1.0f - ( dist - 100 ) * ( 1.0f / 400.0f )) * e->curstate.renderamt );

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR __real@3b23d70a
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mov	eax, DWORD PTR _e$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+988]
	mulss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	DWORD PTR _blend$[ebp], ecx
$LN45@CL_FxBlend:

; 307  : 			blend += COM_RandomLong( -32, 31 );

	push	31					; 0000001fH
	push	-32					; ffffffe0H
	call	_COM_RandomLong
	add	esp, 8
	add	eax, DWORD PTR _blend$[ebp]
	mov	DWORD PTR _blend$[ebp], eax
$LN43@CL_FxBlend:

; 308  : 		}
; 309  : 		break;

	jmp	SHORT $LN2@CL_FxBlend
$LN46@CL_FxBlend:

; 310  : 	default:
; 311  : 		blend = e->curstate.renderamt;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	DWORD PTR _blend$[ebp], ecx
$LN2@CL_FxBlend:

; 312  : 		break;
; 313  : 	}
; 314  : 
; 315  : 	blend = bound( 0, blend, 255 );

	cmp	DWORD PTR _blend$[ebp], 0
	jl	SHORT $LN50@CL_FxBlend
	cmp	DWORD PTR _blend$[ebp], 255		; 000000ffH
	jge	SHORT $LN48@CL_FxBlend
	mov	eax, DWORD PTR _blend$[ebp]
	mov	DWORD PTR tv311[ebp], eax
	jmp	SHORT $LN49@CL_FxBlend
$LN48@CL_FxBlend:
	mov	DWORD PTR tv311[ebp], 255		; 000000ffH
$LN49@CL_FxBlend:
	mov	ecx, DWORD PTR tv311[ebp]
	mov	DWORD PTR tv312[ebp], ecx
	jmp	SHORT $LN51@CL_FxBlend
$LN50@CL_FxBlend:
	mov	DWORD PTR tv312[ebp], 0
$LN51@CL_FxBlend:
	mov	edx, DWORD PTR tv312[ebp]
	mov	DWORD PTR _blend$[ebp], edx

; 316  : 
; 317  : 	return blend;

	mov	eax, DWORD PTR _blend$[ebp]

; 318  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN52@CL_FxBlend:
	DD	$LN6@CL_FxBlend
	DD	$LN7@CL_FxBlend
	DD	$LN4@CL_FxBlend
	DD	$LN5@CL_FxBlend
	DD	$LN8@CL_FxBlend
	DD	$LN12@CL_FxBlend
	DD	$LN16@CL_FxBlend
	DD	$LN20@CL_FxBlend
	DD	$LN24@CL_FxBlend
	DD	$LN27@CL_FxBlend
	DD	$LN30@CL_FxBlend
	DD	$LN33@CL_FxBlend
	DD	$LN36@CL_FxBlend
	DD	$LN46@CL_FxBlend
	DD	$LN39@CL_FxBlend
	DD	$LN39@CL_FxBlend
_CL_FxBlend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AddClientResources
_TEXT	SEGMENT
_i$ = -72						; size = 4
_filepath$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_CL_AddClientResources PROC				; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 150  : 	char	filepath[MAX_QPATH];
; 151  : 	int	i;
; 152  : 
; 153  : 	// don't request resources from localhost or in quake-compatibility mode
; 154  : 	if( cl.maxclients <= 1 || CL_IsQuakeCompatible( ))

	cmp	DWORD PTR _cl+2213004, 1
	jle	SHORT $LN15@CL_AddClie
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN14@CL_AddClie
$LN15@CL_AddClie:

; 155  : 		return;

	jmp	$LN1@CL_AddClie
$LN14@CL_AddClie:

; 156  : 
; 157  : 	// check sprites first
; 158  : 	for( i = 0; i < ARRAYSIZE( cl_default_sprites ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_AddClie
$LN2@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 7
	jae	SHORT $LN3@CL_AddClie

; 159  : 	{
; 160  : 		if( !FS_FileExists( cl_default_sprites[i], false ))

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_default_sprites[eax*4]
	push	ecx
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@CL_AddClie

; 161  : 			CL_AddClientResource( cl_default_sprites[i], t_model );

	push	2
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_default_sprites[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN16@CL_AddClie:

; 162  : 	}

	jmp	SHORT $LN2@CL_AddClie
$LN3@CL_AddClie:

; 163  : 
; 164  : 	// then check sounds
; 165  : 	for( i = 0; i < ARRAYSIZE( cl_player_shell_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@CL_AddClie
$LN5@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN6@CL_AddClie

; 166  : 	{
; 167  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_player_shell_sounds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_player_shell_sounds[eax*4]
	push	ecx
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	64					; 00000040H
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 168  : 
; 169  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN17@CL_AddClie

; 170  : 			CL_AddClientResource( cl_player_shell_sounds[i], t_sound );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_player_shell_sounds[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN17@CL_AddClie:

; 171  : 	}

	jmp	SHORT $LN5@CL_AddClie
$LN6@CL_AddClie:

; 172  : 
; 173  : 	for( i = 0; i < ARRAYSIZE( cl_weapon_shell_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@CL_AddClie
$LN8@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN9@CL_AddClie

; 174  : 	{
; 175  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_weapon_shell_sounds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_weapon_shell_sounds[eax*4]
	push	ecx
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	64					; 00000040H
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 176  : 
; 177  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@CL_AddClie

; 178  : 			CL_AddClientResource( cl_weapon_shell_sounds[i], t_sound );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_weapon_shell_sounds[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN18@CL_AddClie:

; 179  : 	}

	jmp	SHORT $LN8@CL_AddClie
$LN9@CL_AddClie:

; 180  : 
; 181  : 	for( i = 0; i < ARRAYSIZE( cl_explode_sounds ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@CL_AddClie
$LN11@CL_AddClie:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@CL_AddClie:
	cmp	DWORD PTR _i$[ebp], 3
	jae	SHORT $LN1@CL_AddClie

; 182  : 	{
; 183  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_explode_sounds[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_explode_sounds[eax*4]
	push	ecx
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	64					; 00000040H
	lea	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 184  : 
; 185  : 		if( !FS_FileExists( filepath, false ))

	push	0
	lea	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@CL_AddClie

; 186  : 			CL_AddClientResource( cl_explode_sounds[i], t_sound );

	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cl_explode_sounds[eax*4]
	push	ecx
	call	_CL_AddClientResource
	add	esp, 8
$LN19@CL_AddClie:

; 187  : 	}

	jmp	SHORT $LN11@CL_AddClie
$LN1@CL_AddClie:

; 188  : 
; 189  : #if 0	// ric sounds was precached by server-side
; 190  : 	for( i = 0; i < ARRAYSIZE( cl_ricochet_sounds ); i++ )
; 191  : 	{
; 192  : 		Q_snprintf( filepath, sizeof( filepath ), "%s%s", DEFAULT_SOUNDPATH, cl_ricochet_sounds[i] );
; 193  : 
; 194  : 		if( !FS_FileExists( filepath, false ))
; 195  : 			CL_AddClientResource( cl_ricochet_sounds[i], t_sound );
; 196  : 	}
; 197  : #endif
; 198  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddClientResources ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_AddClientResource
_TEXT	SEGMENT
_pResource$ = -8					; size = 4
_p$ = -4						; size = 4
_filename$ = 8						; size = 4
_type$ = 12						; size = 4
_CL_AddClientResource PROC				; COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 119  : 	resource_t	*p, *pResource;
; 120  : 
; 121  : 	for( p = cl.resourcesneeded.pNext; p != &cl.resourcesneeded; p = p->pNext )

	mov	eax, DWORD PTR _cl+3029680
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $LN4@CL_AddClie
$LN2@CL_AddClie:
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _p$[ebp], ecx
$LN4@CL_AddClie:
	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	SHORT $LN3@CL_AddClie

; 122  : 	{
; 123  : 		if( !Q_stricmp( p->szFileName, filename ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@CL_AddClie

; 124  : 			break;

	jmp	SHORT $LN3@CL_AddClie
$LN5@CL_AddClie:

; 125  : 	}

	jmp	SHORT $LN2@CL_AddClie
$LN3@CL_AddClie:

; 126  : 
; 127  : 	if( p != &cl.resourcesneeded )

	cmp	DWORD PTR _p$[ebp], OFFSET _cl+3029552
	je	SHORT $LN6@CL_AddClie

; 128  : 		return; // already in list?

	jmp	SHORT $LN1@CL_AddClie
$LN6@CL_AddClie:

; 129  : 
; 130  : 	pResource = Mem_Calloc( cls.mempool, sizeof( resource_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_AddClientResource@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pResource$[ebp], eax

; 131  : 
; 132  : 	Q_strncpy( pResource->szFileName, filename, sizeof( pResource->szFileName ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pResource$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 133  : 	pResource->type = type;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 134  : 	pResource->nIndex = -1; // client resource marker

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+68], -1

; 135  : 	pResource->nDownloadSize = 1;

	mov	eax, DWORD PTR _pResource$[ebp]
	mov	DWORD PTR [eax+72], 1

; 136  : 	pResource->ucFlags |= RES_WASMISSING;

	mov	eax, DWORD PTR _pResource$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	or	ecx, 2
	mov	edx, DWORD PTR _pResource$[ebp]
	mov	BYTE PTR [edx+76], cl

; 137  : 
; 138  : 	CL_AddToResourceList( pResource, &cl.resourcesneeded );

	push	OFFSET _cl+3029552
	mov	eax, DWORD PTR _pResource$[ebp]
	push	eax
	call	_CL_AddToResourceList
	add	esp, 8
$LN1@CL_AddClie:

; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddClientResource ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_PlayerDecal
_TEXT	SEGMENT
_decalname$1 = -12					; size = 4
_pCust$ = -8						; size = 4
_textureIndex$ = -4					; size = 4
_playernum$ = 8						; size = 4
_customIndex$ = 12					; size = 4
_entityIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_CL_PlayerDecal PROC					; COMDAT

; 3013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 3014 : 	int		textureIndex = 0;

	mov	DWORD PTR _textureIndex$[ebp], 0

; 3015 : 	customization_t	*pCust = NULL;

	mov	DWORD PTR _pCust$[ebp], 0

; 3016 : 
; 3017 : 	if( playernum < MAX_CLIENTS )

	cmp	DWORD PTR _playernum$[ebp], 32		; 00000020H
	jge	SHORT $LN2@CL_PlayerD

; 3018 : 		pCust = cl.players[playernum].customdata.pNext;

	imul	eax, DWORD PTR _playernum$[ebp], 584
	mov	ecx, DWORD PTR _cl[eax+2185504]
	mov	DWORD PTR _pCust$[ebp], ecx
$LN2@CL_PlayerD:

; 3019 : 
; 3020 : 	if( pCust != NULL && pCust->pBuffer != NULL && pCust->pInfo != NULL )

	cmp	DWORD PTR _pCust$[ebp], 0
	je	$LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+156], 0
	je	$LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	$LN4@CL_PlayerD

; 3021 : 	{
; 3022 : 		if( FBitSet( pCust->resource.ucFlags, RES_CUSTOM ) && pCust->resource.type == t_decal && pCust->bTranslated )

	mov	eax, DWORD PTR _pCust$[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	and	ecx, 4
	je	SHORT $LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+68], 3
	jne	SHORT $LN4@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+140], 0
	je	SHORT $LN4@CL_PlayerD

; 3023 : 		{
; 3024 : 			if( !pCust->nUserData1 && pCust->pInfo != NULL )

	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+144], 0
	jne	SHORT $LN5@CL_PlayerD
	mov	eax, DWORD PTR _pCust$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN5@CL_PlayerD

; 3025 : 			{
; 3026 : 				const char *decalname = va( "player%dlogo%d", playernum, customIndex );

	mov	eax, DWORD PTR _customIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _playernum$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@GPNCHLMC@player?$CFdlogo?$CFd@
	call	_va
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _decalname$1[ebp], eax

; 3027 : 				pCust->nUserData1 = GL_LoadTextureInternal( decalname, pCust->pInfo, TF_DECAL );

	push	0
	push	2048					; 00000800H
	mov	eax, DWORD PTR _pCust$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	push	ecx
	mov	edx, DWORD PTR _decalname$1[ebp]
	push	edx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _pCust$[ebp]
	mov	DWORD PTR [ecx+144], eax
$LN5@CL_PlayerD:

; 3028 : 			}
; 3029 : 			textureIndex = pCust->nUserData1;

	mov	eax, DWORD PTR _pCust$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _textureIndex$[ebp], ecx
$LN4@CL_PlayerD:

; 3030 : 		}
; 3031 : 	}
; 3032 : 
; 3033 : 	R_DecalShoot( textureIndex, entityIndex, 0, pos, FDECAL_CUSTOM, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	4
	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _textureIndex$[ebp]
	push	edx
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 3034 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayerDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_DecalShoot
_TEXT	SEGMENT
_textureIndex$ = 8					; size = 4
_entityIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_flags$ = 24						; size = 4
_CL_DecalShoot PROC					; COMDAT

; 2989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2990 : 	R_DecalShoot( textureIndex, entityIndex, modelIndex, pos, flags, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _textureIndex$[ebp]
	push	ecx
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 2991 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecalShoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_FireCustomDecal
_TEXT	SEGMENT
_textureIndex$ = 8					; size = 4
_entityIndex$ = 12					; size = 4
_modelIndex$ = 16					; size = 4
_pos$ = 20						; size = 4
_flags$ = 24						; size = 4
_scale$ = 28						; size = 4
_CL_FireCustomDecal PROC				; COMDAT

; 3001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3002 : 	R_DecalShoot( textureIndex, entityIndex, modelIndex, pos, flags, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _textureIndex$[ebp]
	push	ecx
	call	_R_DecalShoot
	add	esp, 24					; 00000018H

; 3003 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FireCustomDecal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_TestLights
_TEXT	SEGMENT
tv75 = -96						; size = 4
tv163 = -92						; size = 4
tv74 = -92						; size = 4
_dl$ = -24						; size = 4
_numLights$ = -20					; size = 4
_r$ = -16						; size = 4
_f$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_TestLights PROC					; COMDAT

; 2946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 2947 : 	int	i, j;
; 2948 : 	float	f, r;
; 2949 : 	int	numLights;
; 2950 : 	dlight_t	*dl;
; 2951 : 
; 2952 : 	if( !cl_testlights->value ) return;

	mov	eax, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_TestLig
	jmp	$LN3@CL_TestLig
$LN8@CL_TestLig:

; 2953 : 
; 2954 : 	numLights = bound( 1, cl_testlights->value, MAX_DLIGHTS );

	mov	eax, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@3f800000
	jb	SHORT $LN12@CL_TestLig
	mov	ecx, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR __real@42000000
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN10@CL_TestLig
	mov	edx, DWORD PTR _cl_testlights
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN11@CL_TestLig
$LN10@CL_TestLig:
	movss	xmm0, DWORD PTR __real@42000000
	movss	DWORD PTR tv74[ebp], xmm0
$LN11@CL_TestLig:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN13@CL_TestLig
$LN12@CL_TestLig:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv75[ebp], xmm0
$LN13@CL_TestLig:
	cvttss2si eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _numLights$[ebp], eax

; 2955 : 	
; 2956 : 	for( i = 0; i < numLights; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_TestLig
$LN2@CL_TestLig:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_TestLig:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numLights$[ebp]
	jge	$LN3@CL_TestLig

; 2957 : 	{
; 2958 : 		dl = &cl_dlights[i];

	imul	eax, DWORD PTR _i$[ebp], 40
	add	eax, OFFSET _cl_dlights
	mov	DWORD PTR _dl$[ebp], eax

; 2959 : 
; 2960 : 		r = 64 * ((i % 4) - 1.5f );

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN16@CL_TestLig
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN16@CL_TestLig:
	cvtsi2ss xmm0, eax
	subss	xmm0, DWORD PTR __real@3fc00000
	mulss	xmm0, DWORD PTR __real@42800000
	movss	DWORD PTR _r$[ebp], xmm0

; 2961 : 		f = 64 * ( i / 4) + 128;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	shl	eax, 6
	add	eax, 128				; 00000080H
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _f$[ebp], xmm0

; 2962 : 
; 2963 : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@CL_TestLig
$LN5@CL_TestLig:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@CL_TestLig:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN6@CL_TestLig

; 2964 : 			dl->origin[j] = RI.vieworg[j] + RI.vforward[j] * f + RI.vright[j] * r;

	mov	eax, DWORD PTR _j$[ebp]
	movss	xmm0, DWORD PTR _RI[eax*4+224]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	addss	xmm0, DWORD PTR _RI[ecx*4+200]
	mov	edx, DWORD PTR _j$[ebp]
	movss	xmm1, DWORD PTR _RI[edx*4+236]
	mulss	xmm1, DWORD PTR _r$[ebp]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
	jmp	SHORT $LN5@CL_TestLig
$LN6@CL_TestLig:

; 2965 : 
; 2966 : 		dl->color.r = ((((i % 6) + 1) & 1)>>0) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 1
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+16], dl

; 2967 : 		dl->color.g = ((((i % 6) + 1) & 2)>>1) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 2
	sar	edx, 1
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+17], dl

; 2968 : 		dl->color.b = ((((i % 6) + 1) & 4)>>2) * 255;

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	add	edx, 1
	and	edx, 4
	sar	edx, 2
	imul	edx, edx, 255
	mov	eax, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [eax+18], dl

; 2969 : 		dl->radius = Q_max( 64, 200 - 5 * numLights );

	imul	eax, DWORD PTR _numLights$[ebp], 5
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN14@CL_TestLig
	mov	DWORD PTR tv163[ebp], 64		; 00000040H
	jmp	SHORT $LN15@CL_TestLig
$LN14@CL_TestLig:
	imul	edx, DWORD PTR _numLights$[ebp], 5
	mov	eax, 200				; 000000c8H
	sub	eax, edx
	mov	DWORD PTR tv163[ebp], eax
$LN15@CL_TestLig:
	cvtsi2ss xmm0, DWORD PTR tv163[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 2970 : 		dl->die = cl.time + host.frametime;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR _host+1448
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2971 : 	}

	jmp	$LN2@CL_TestLig
$LN3@CL_TestLig:

; 2972 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TestLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ClearEfrags
_TEXT	SEGMENT
_i$ = -4						; size = 4
_CL_ClearEfrags PROC					; COMDAT

; 3108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 3109 : 	int	i;
; 3110 : 
; 3111 : 	memset( cl_efrags, 0, sizeof( cl_efrags ));

	push	131072					; 00020000H
	push	0
	push	OFFSET _cl_efrags
	call	_memset
	add	esp, 12					; 0000000cH

; 3112 : 
; 3113 : 	// allocate the efrags and chain together into a free list
; 3114 : 	clgame.free_efrags = cl_efrags;

	mov	DWORD PTR _clgame+260428, OFFSET _cl_efrags

; 3115 : 	for( i = 0; i < MAX_EFRAGS - 1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ClearEf
$LN2@CL_ClearEf:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ClearEf:
	cmp	DWORD PTR _i$[ebp], 8191		; 00001fffH
	jge	SHORT $LN3@CL_ClearEf

; 3116 : 		clgame.free_efrags[i].entnext = &clgame.free_efrags[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	shl	eax, 4
	add	eax, DWORD PTR _clgame+260428
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _clgame+260428
	mov	DWORD PTR [edx+ecx+12], eax
	jmp	SHORT $LN2@CL_ClearEf
$LN3@CL_ClearEf:

; 3117 : 	clgame.free_efrags[i].entnext = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _clgame+260428
	mov	DWORD PTR [ecx+eax+12], 0

; 3118 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearEfrags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ClearEffects
_TEXT	SEGMENT
_CL_ClearEffects PROC					; COMDAT

; 3126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3127 : 	CL_ClearEfrags ();

	call	_CL_ClearEfrags

; 3128 : 	CL_ClearDlights ();

	call	_CL_ClearDlights

; 3129 : 	CL_ClearTempEnts ();

	call	_CL_ClearTempEnts

; 3130 : 	CL_ClearViewBeams ();

	call	_CL_ClearViewBeams

; 3131 : 	CL_ClearParticles ();

	call	_CL_ClearParticles

; 3132 : 	CL_ClearLightStyles ();

	call	_CL_ClearLightStyles

; 3133 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ClearEffects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_ParseTempEntity
_TEXT	SEGMENT
tv2508 = -468						; size = 4
tv2502 = -468						; size = 4
tv2496 = -468						; size = 4
tv2490 = -468						; size = 4
tv2484 = -468						; size = 4
tv76 = -468						; size = 4
_dl$ = -400						; size = 4
_pEnt$ = -396						; size = 4
_pTemp$ = -392						; size = 4
_decalIndices$ = -388					; size = 4
_ang$ = -384						; size = 12
_pos2$ = -372						; size = 12
_pos$ = -360						; size = 12
_b$ = -348						; size = 4
_g$ = -344						; size = 4
_r$ = -340						; size = 4
_brightness$ = -336					; size = 4
_random$ = -332						; size = 4
_vel$ = -328						; size = 4
_frameRate$ = -324					; size = 4
_life$ = -320						; size = 4
_scale$ = -316						; size = 4
_entityIndex$ = -312					; size = 4
_modelIndex$ = -308					; size = 4
_decalIndex$ = -304					; size = 4
_flags$ = -300						; size = 4
_count$ = -296						; size = 4
_color$ = -292						; size = 4
_type$ = -288						; size = 4
_iSize$ = -284						; size = 4
_pbuf$ = -280						; size = 256
_buf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseTempEntity PROC				; COMDAT

; 2030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2031 : 	sizebuf_t		buf;
; 2032 : 	byte		pbuf[256];
; 2033 : 	int		iSize = MSG_ReadWord( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax

; 2034 : 	int		type, color, count, flags;
; 2035 : 	int		decalIndex, modelIndex, entityIndex;
; 2036 : 	float		scale, life, frameRate, vel, random;
; 2037 : 	float		brightness, r, g, b;
; 2038 : 	vec3_t		pos, pos2, ang;
; 2039 : 	int		decalIndices[1];	// just stub
; 2040 : 	TEMPENTITY	*pTemp;
; 2041 : 	cl_entity_t	*pEnt;
; 2042 : 	dlight_t		*dl;
; 2043 : 
; 2044 : 	decalIndex = modelIndex = entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0
	mov	eax, DWORD PTR _entityIndex$[ebp]
	mov	DWORD PTR _modelIndex$[ebp], eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	mov	DWORD PTR _decalIndex$[ebp], ecx

; 2045 : 
; 2046 : 	// parse user message into buffer
; 2047 : 	MSG_ReadBytes( msg, pbuf, iSize );

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadBytes
	add	esp, 12					; 0000000cH

; 2048 : 
; 2049 : 	// init a safe tempbuffer
; 2050 : 	MSG_Init( &buf, "TempEntity", pbuf, iSize );

	push	-1
	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@KJBJBAKD@TempEntity@
	lea	edx, DWORD PTR _buf$[ebp]
	push	edx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 2051 : 
; 2052 : 	type = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _type$[ebp], eax

; 2053 : 
; 2054 : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	cmp	DWORD PTR tv76[ebp], 127		; 0000007fH
	ja	$LN83@CL_ParseTe
	mov	ecx, DWORD PTR tv76[ebp]
	movzx	edx, BYTE PTR $LN86@CL_ParseTe[ecx]
	jmp	DWORD PTR $LN87@CL_ParseTe[edx*4]
$LN4@CL_ParseTe:

; 2055 : 	{
; 2056 : 	case TE_BEAMPOINTS:
; 2057 : 	case TE_BEAMENTPOINT:
; 2058 : 	case TE_LIGHTNING:
; 2059 : 	case TE_BEAMENTS:
; 2060 : 	case TE_BEAM:
; 2061 : 	case TE_BEAMSPRITE:
; 2062 : 	case TE_BEAMTORUS:
; 2063 : 	case TE_BEAMDISK:
; 2064 : 	case TE_BEAMCYLINDER:
; 2065 : 	case TE_BEAMFOLLOW:
; 2066 : 	case TE_BEAMRING:
; 2067 : 	case TE_BEAMHOSE:
; 2068 : 	case TE_KILLBEAM:
; 2069 : 		CL_ParseViewBeam( &buf, type );

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_CL_ParseViewBeam
	add	esp, 8

; 2070 : 		break;

	jmp	$LN2@CL_ParseTe
$LN17@CL_ParseTe:

; 2071 : 	case TE_GUNSHOT:
; 2072 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2073 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2074 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2075 : 		R_RicochetSound( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_RicochetSound
	add	esp, 4

; 2076 : 		R_RunParticleEffect( pos, vec3_origin, 0, 20 );

	push	20					; 00000014H
	push	0
	push	OFFSET _vec3_origin
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_RunParticleEffect
	add	esp, 16					; 00000010H

; 2077 : 		break;

	jmp	$LN2@CL_ParseTe
$LN18@CL_ParseTe:

; 2078 : 	case TE_EXPLOSION:
; 2079 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2080 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2081 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2082 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2083 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2084 : 		frameRate = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _frameRate$[ebp], xmm0

; 2085 : 		flags = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2086 : 		R_Explosion( pos, modelIndex, scale, frameRate, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frameRate$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_Explosion
	add	esp, 20					; 00000014H

; 2087 : 		break;

	jmp	$LN2@CL_ParseTe
$LN19@CL_ParseTe:

; 2088 : 	case TE_TAREXPLOSION:
; 2089 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2090 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2091 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2092 : 		R_BlobExplosion( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BlobExplosion
	add	esp, 4

; 2093 : 		break;

	jmp	$LN2@CL_ParseTe
$LN20@CL_ParseTe:

; 2094 : 	case TE_SMOKE:
; 2095 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2096 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2097 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2098 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2099 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2100 : 		frameRate = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _frameRate$[ebp], xmm0

; 2101 : 		pTemp = R_DefaultSprite( pos, modelIndex, frameRate );

	push	ecx
	movss	xmm0, DWORD PTR _frameRate$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax

; 2102 : 		R_Sprite_Smoke( pTemp, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_R_Sprite_Smoke
	add	esp, 8

; 2103 : 		break;

	jmp	$LN2@CL_ParseTe
$LN21@CL_ParseTe:

; 2104 : 	case TE_TRACER:
; 2105 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2106 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2107 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2108 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2109 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2110 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2111 : 		R_TracerEffect( pos, pos2 );

	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_TracerEffect
	add	esp, 8

; 2112 : 		break;

	jmp	$LN2@CL_ParseTe
$LN22@CL_ParseTe:

; 2113 : 	case TE_SPARKS:
; 2114 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2115 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2116 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2117 : 		R_SparkShower( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_SparkShower
	add	esp, 4

; 2118 : 		break;

	jmp	$LN2@CL_ParseTe
$LN23@CL_ParseTe:

; 2119 : 	case TE_LAVASPLASH:
; 2120 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2121 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2122 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2123 : 		R_LavaSplash( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_LavaSplash
	add	esp, 4

; 2124 : 		break;

	jmp	$LN2@CL_ParseTe
$LN24@CL_ParseTe:

; 2125 : 	case TE_TELEPORT:
; 2126 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2127 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2128 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2129 : 		R_TeleportSplash( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_TeleportSplash
	add	esp, 4

; 2130 : 		break;

	jmp	$LN2@CL_ParseTe
$LN25@CL_ParseTe:

; 2131 : 	case TE_EXPLOSION2:
; 2132 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2133 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2134 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2135 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2136 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2137 : 		R_ParticleExplosion2( pos, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_ParticleExplosion2
	add	esp, 12					; 0000000cH

; 2138 : 		break;

	jmp	$LN2@CL_ParseTe
$LN26@CL_ParseTe:

; 2139 : 	case TE_BSPDECAL:
; 2140 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2141 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2142 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2143 : 		decalIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2144 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2145 : 		if( entityIndex ) modelIndex = MSG_ReadShort( &buf );

	cmp	DWORD PTR _entityIndex$[ebp], 0
	je	SHORT $LN27@CL_ParseTe
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax
$LN27@CL_ParseTe:

; 2146 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, pos, FDECAL_PERMANENT );

	push	1
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2147 : 		break;

	jmp	$LN2@CL_ParseTe
$LN28@CL_ParseTe:

; 2148 : 	case TE_IMPLOSION:
; 2149 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2150 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2151 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2152 : 		scale = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2153 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2154 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2155 : 		R_Implosion( pos, scale, count, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Implosion
	add	esp, 16					; 00000010H

; 2156 : 		break;

	jmp	$LN2@CL_ParseTe
$LN29@CL_ParseTe:

; 2157 : 	case TE_SPRITETRAIL:
; 2158 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2159 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2160 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2161 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2162 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2163 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2164 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2165 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2166 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2167 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2168 : 		vel = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2169 : 		random = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2170 : 		R_Sprite_Trail( type, pos, pos2, modelIndex, count, life, scale, random, 255, vel );

	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	255					; 000000ffH
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	call	_R_Sprite_Trail
	add	esp, 40					; 00000028H

; 2171 : 		break;

	jmp	$LN2@CL_ParseTe
$LN30@CL_ParseTe:

; 2172 : 	case TE_SPRITE:
; 2173 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2174 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2175 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2176 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2177 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2178 : 		brightness = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _brightness$[ebp], xmm0

; 2179 : 
; 2180 : 		if(( pTemp = R_DefaultSprite( pos, modelIndex, 0 )) != NULL )

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $LN31@CL_ParseTe

; 2181 : 		{
; 2182 : 			pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 2183 : 			pTemp->entity.baseline.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 2184 : 			pTemp->entity.curstate.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], eax

; 2185 : 			pTemp->entity.curstate.rendermode = kRenderTransAdd;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 5
$LN31@CL_ParseTe:

; 2186 : 		}
; 2187 : 		break;

	jmp	$LN2@CL_ParseTe
$LN32@CL_ParseTe:

; 2188 : 	case TE_GLOWSPRITE:
; 2189 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2190 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2191 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2192 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2193 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2194 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2195 : 		brightness = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _brightness$[ebp], xmm0

; 2196 : 
; 2197 : 		if(( pTemp = R_DefaultSprite( pos, modelIndex, 0 )) != NULL )

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_DefaultSprite
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTemp$[ebp], eax
	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN33@CL_ParseTe

; 2198 : 		{
; 2199 : 			pTemp->entity.curstate.scale = scale;

	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [eax+1044], xmm0

; 2200 : 			pTemp->entity.curstate.rendermode = kRenderGlow;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1052], 3

; 2201 : 			pTemp->entity.curstate.renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+1064], 14		; 0000000eH

; 2202 : 			pTemp->entity.baseline.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+152], eax

; 2203 : 			pTemp->entity.curstate.renderamt = brightness;

	cvttss2si eax, DWORD PTR _brightness$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx+1056], eax

; 2204 : 			pTemp->flags = FTENT_FADEOUT;

	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], 128			; 00000080H

; 2205 : 			pTemp->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _pTemp$[ebp]
	movss	DWORD PTR [eax+4], xmm0
$LN33@CL_ParseTe:

; 2206 : 		}
; 2207 : 		break;

	jmp	$LN2@CL_ParseTe
$LN34@CL_ParseTe:

; 2208 : 	case TE_STREAK_SPLASH:
; 2209 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2210 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2211 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2212 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2213 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2214 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2215 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2216 : 		count = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2217 : 		vel = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2218 : 		random = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2219 : 		R_StreakSplash( pos, pos2, color, count, vel, -random, random );

	cvttss2si eax, DWORD PTR _random$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _random$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si ecx, xmm0
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_StreakSplash
	add	esp, 28					; 0000001cH

; 2220 : 		break;

	jmp	$LN2@CL_ParseTe
$LN35@CL_ParseTe:

; 2221 : 	case TE_DLIGHT:
; 2222 : 		dl = CL_AllocDlight( 0 );

	push	0
	call	_CL_AllocDlight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2223 : 		dl->origin[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [eax+edx]

; 2224 : 		dl->origin[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 2225 : 		dl->origin[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 2226 : 		dl->radius = (float)(MSG_ReadByte( &buf ) * 10.0f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 2227 : 		dl->color.r = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+16], al

; 2228 : 		dl->color.g = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2229 : 		dl->color.b = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+18], al

; 2230 : 		dl->die = cl.time + (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvtss2sd xmm0, xmm0
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 2231 : 		dl->decay = (float)(MSG_ReadByte( &buf ) * 10.0f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+24], xmm0

; 2232 : 		break;

	jmp	$LN2@CL_ParseTe
$LN36@CL_ParseTe:

; 2233 : 	case TE_ELIGHT:
; 2234 : 		dl = CL_AllocElight( MSG_ReadShort( &buf ));

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	push	eax
	call	_CL_AllocElight
	add	esp, 4
	mov	DWORD PTR _dl$[ebp], eax

; 2235 : 		dl->origin[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [eax+edx]

; 2236 : 		dl->origin[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 2237 : 		dl->origin[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [edx+ecx]

; 2238 : 		dl->radius = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+12]

; 2239 : 		dl->color.r = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+16], al

; 2240 : 		dl->color.g = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+17], al

; 2241 : 		dl->color.b = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	mov	BYTE PTR [ecx+18], al

; 2242 : 		life = (float)MSG_ReadByte( &buf ) * 0.1f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2243 : 		dl->die = cl.time + life;

	cvtss2sd xmm0, DWORD PTR _life$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2244 : 		dl->decay = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, DWORD PTR _dl$[ebp]
	fstp	DWORD PTR [ecx+24]

; 2245 : 		if( life != 0 ) dl->decay /= life;

	movss	xmm0, DWORD PTR _life$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN37@CL_ParseTe
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+24]
	divss	xmm0, DWORD PTR _life$[ebp]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [ecx+24], xmm0
$LN37@CL_ParseTe:

; 2246 : 		break;

	jmp	$LN2@CL_ParseTe
$LN38@CL_ParseTe:

; 2247 : 	case TE_TEXTMESSAGE:
; 2248 : 		CL_ParseTextMessage( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_CL_ParseTextMessage
	add	esp, 4

; 2249 : 		break;

	jmp	$LN2@CL_ParseTe
$LN39@CL_ParseTe:

; 2250 : 	case TE_LINE:
; 2251 : 	case TE_BOX:
; 2252 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2253 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2254 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2255 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2256 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2257 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2258 : 		life = (float)(MSG_ReadShort( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2259 : 		r = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _r$[ebp], xmm0

; 2260 : 		g = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _g$[ebp], xmm0

; 2261 : 		b = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _b$[ebp], xmm0

; 2262 : 		if( type == TE_LINE ) R_ParticleLine( pos, pos2, r, g, b, life );

	cmp	DWORD PTR _type$[ebp], 30		; 0000001eH
	jne	SHORT $LN41@CL_ParseTe
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvttss2si eax, DWORD PTR _b$[ebp]
	movzx	ecx, al
	push	ecx
	cvttss2si edx, DWORD PTR _g$[ebp]
	movzx	eax, dl
	push	eax
	cvttss2si ecx, DWORD PTR _r$[ebp]
	movzx	edx, cl
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_ParticleLine
	add	esp, 24					; 00000018H
	jmp	SHORT $LN42@CL_ParseTe
$LN41@CL_ParseTe:

; 2263 : 		else R_ParticleBox( pos, pos2, r, g, b, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvttss2si eax, DWORD PTR _b$[ebp]
	movzx	ecx, al
	push	ecx
	cvttss2si edx, DWORD PTR _g$[ebp]
	movzx	eax, dl
	push	eax
	cvttss2si ecx, DWORD PTR _r$[ebp]
	movzx	edx, cl
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_ParticleBox
	add	esp, 24					; 00000018H
$LN42@CL_ParseTe:

; 2264 : 		break;

	jmp	$LN2@CL_ParseTe
$LN43@CL_ParseTe:

; 2265 : 	case TE_LARGEFUNNEL:
; 2266 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2267 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2268 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2269 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2270 : 		flags = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2271 : 		R_LargeFunnel( pos, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_LargeFunnel
	add	esp, 8

; 2272 : 		R_FunnelSprite( pos, modelIndex, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_FunnelSprite
	add	esp, 12					; 0000000cH

; 2273 : 		break;

	jmp	$LN2@CL_ParseTe
$LN44@CL_ParseTe:

; 2274 : 	case TE_BLOODSTREAM:
; 2275 : 	case TE_BLOOD:
; 2276 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2277 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2278 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2279 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2280 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2281 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2282 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2283 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2284 : 		if( type == TE_BLOOD ) R_Blood( pos, pos2, color, count );

	cmp	DWORD PTR _type$[ebp], 103		; 00000067H
	jne	SHORT $LN46@CL_ParseTe
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_Blood
	add	esp, 16					; 00000010H
	jmp	SHORT $LN47@CL_ParseTe
$LN46@CL_ParseTe:

; 2285 : 		else R_BloodStream( pos, pos2, color, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BloodStream
	add	esp, 16					; 00000010H
$LN47@CL_ParseTe:

; 2286 : 		break;

	jmp	$LN2@CL_ParseTe
$LN48@CL_ParseTe:

; 2287 : 	case TE_SHOWLINE:
; 2288 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2289 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2290 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2291 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2292 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2293 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2294 : 		R_ShowLine( pos, pos2 );

	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_ShowLine
	add	esp, 8

; 2295 : 		break;

	jmp	$LN2@CL_ParseTe
$LN49@CL_ParseTe:

; 2296 : 	case TE_DECAL:
; 2297 : 	case TE_DECALHIGH:
; 2298 : 	case TE_WORLDDECAL:
; 2299 : 	case TE_WORLDDECALHIGH:
; 2300 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2301 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2302 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2303 : 		decalIndex = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2304 : 		if( type == TE_DECAL || type == TE_DECALHIGH )

	cmp	DWORD PTR _type$[ebp], 104		; 00000068H
	je	SHORT $LN55@CL_ParseTe
	cmp	DWORD PTR _type$[ebp], 118		; 00000076H
	jne	SHORT $LN53@CL_ParseTe
$LN55@CL_ParseTe:

; 2305 : 			entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax
	jmp	SHORT $LN54@CL_ParseTe
$LN53@CL_ParseTe:

; 2306 : 		else entityIndex = 0;

	mov	DWORD PTR _entityIndex$[ebp], 0
$LN54@CL_ParseTe:

; 2307 : 		if( type == TE_DECALHIGH || type == TE_WORLDDECALHIGH )

	cmp	DWORD PTR _type$[ebp], 118		; 00000076H
	je	SHORT $LN57@CL_ParseTe
	cmp	DWORD PTR _type$[ebp], 117		; 00000075H
	jne	SHORT $LN56@CL_ParseTe
$LN57@CL_ParseTe:

; 2308 : 			decalIndex += 256;

	mov	eax, DWORD PTR _decalIndex$[ebp]
	add	eax, 256				; 00000100H
	mov	DWORD PTR _decalIndex$[ebp], eax
$LN56@CL_ParseTe:

; 2309 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2310 : 		if( pEnt ) modelIndex = pEnt->curstate.modelindex;

	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $LN58@CL_ParseTe
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+952]
	mov	DWORD PTR _modelIndex$[ebp], ecx
$LN58@CL_ParseTe:

; 2311 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, modelIndex, pos, 0 );

	push	0
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entityIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2312 : 		break;

	jmp	$LN2@CL_ParseTe
$LN59@CL_ParseTe:

; 2313 : 	case TE_FIZZ:
; 2314 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2315 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2316 : 		scale = MSG_ReadByte( &buf );	// same as density

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2317 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2318 : 		R_FizzEffect( pEnt, modelIndex, scale );

	cvttss2si eax, DWORD PTR _scale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEnt$[ebp]
	push	edx
	call	_R_FizzEffect
	add	esp, 12					; 0000000cH

; 2319 : 		break;

	jmp	$LN2@CL_ParseTe
$LN60@CL_ParseTe:

; 2320 : 	case TE_MODEL:
; 2321 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2322 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2323 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2324 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2325 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2326 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2327 : 		ang[0] = 0.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2328 : 		ang[1] = MSG_ReadAngle( &buf ); // yaw angle

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadChar
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3fb40000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2329 : 		ang[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+eax], xmm0

; 2330 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2331 : 		flags = MSG_ReadByte( &buf );	// sound flags

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2332 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2333 : 		R_TempModel( pos, pos2, ang, life, modelIndex, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _ang$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_TempModel
	add	esp, 24					; 00000018H

; 2334 : 		break;

	jmp	$LN2@CL_ParseTe
$LN61@CL_ParseTe:

; 2335 : 	case TE_EXPLODEMODEL:
; 2336 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2337 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2338 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2339 : 		vel = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _vel$[ebp]

; 2340 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2341 : 		count = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2342 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2343 : 		R_TempSphereModel( pos, vel, life, count, modelIndex );

	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_TempSphereModel
	add	esp, 20					; 00000014H

; 2344 : 		break;

	jmp	$LN2@CL_ParseTe
$LN62@CL_ParseTe:

; 2345 : 	case TE_BREAKMODEL:
; 2346 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2347 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2348 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2349 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2350 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2351 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2352 : 		ang[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _ang$[ebp+edx]

; 2353 : 		ang[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _ang$[ebp+ecx]

; 2354 : 		ang[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _ang$[ebp+ecx]

; 2355 : 		random = (float)MSG_ReadByte( &buf ) * 10.0f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _random$[ebp], xmm0

; 2356 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2357 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2358 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2359 : 		flags = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2360 : 		R_BreakModel( pos, pos2, ang, random, life, count, modelIndex, (char)flags );

	movzx	eax, BYTE PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _random$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _ang$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_BreakModel
	add	esp, 32					; 00000020H

; 2361 : 		break;

	jmp	$LN2@CL_ParseTe
$LN63@CL_ParseTe:

; 2362 : 	case TE_GUNSHOTDECAL:
; 2363 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2364 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2365 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2366 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2367 : 		decalIndex = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2368 : 		pEnt = CL_GetEntityByIndex( entityIndex );

	mov	eax, DWORD PTR _entityIndex$[ebp]
	push	eax
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 2369 : 		CL_DecalShoot( CL_DecalIndex( decalIndex ), entityIndex, 0, pos, 0 );

	push	0
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	call	_CL_DecalIndex
	add	esp, 4
	push	eax
	call	_CL_DecalShoot
	add	esp, 20					; 00000014H

; 2370 : 		R_BulletImpactParticles( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BulletImpactParticles
	add	esp, 4

; 2371 : 		R_RicochetSound( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_RicochetSound
	add	esp, 4

; 2372 : 		break;

	jmp	$LN2@CL_ParseTe
$LN64@CL_ParseTe:

; 2373 : 	case TE_SPRAY:
; 2374 : 	case TE_SPRITE_SPRAY:
; 2375 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2376 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2377 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2378 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2379 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2380 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2381 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2382 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2383 : 		vel = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _vel$[ebp], xmm0

; 2384 : 		random = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2385 : 		if( type == TE_SPRAY )

	cmp	DWORD PTR _type$[ebp], 120		; 00000078H
	jne	SHORT $LN66@CL_ParseTe

; 2386 : 		{
; 2387 : 			flags = MSG_ReadByte( &buf );	// rendermode

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2388 : 			R_Spray( pos, pos2, modelIndex, count, vel, random, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _random$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _vel$[ebp]
	push	edx
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_Spray
	add	esp, 28					; 0000001cH

; 2389 : 		}

	jmp	SHORT $LN67@CL_ParseTe
$LN66@CL_ParseTe:

; 2390 : 		else R_Sprite_Spray( pos, pos2, modelIndex, count, vel * 2.0f, random );

	cvttss2si eax, DWORD PTR _random$[ebp]
	push	eax
	movss	xmm0, DWORD PTR _vel$[ebp]
	mulss	xmm0, DWORD PTR __real@40000000
	cvttss2si ecx, xmm0
	push	ecx
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_Sprite_Spray
	add	esp, 24					; 00000018H
$LN67@CL_ParseTe:

; 2391 : 		break;

	jmp	$LN2@CL_ParseTe
$LN68@CL_ParseTe:

; 2392 : 	case TE_ARMOR_RICOCHET:
; 2393 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2394 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2395 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2396 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2397 : 		R_RicochetSprite( pos, cl_sprite_ricochet, 0.1f, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cl_sprite_ricochet
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_RicochetSprite
	add	esp, 16					; 00000010H

; 2398 : 		R_RicochetSound( pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_RicochetSound
	add	esp, 4

; 2399 : 		break;

	jmp	$LN2@CL_ParseTe
$LN69@CL_ParseTe:

; 2400 : 	case TE_PLAYERDECAL:
; 2401 : 		color = MSG_ReadByte( &buf ) - 1; // playernum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _color$[ebp], eax

; 2402 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2403 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2404 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2405 : 		entityIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _entityIndex$[ebp], eax

; 2406 : 		decalIndex = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2407 : 		CL_PlayerDecal( color, decalIndex, entityIndex, pos );

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decalIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_CL_PlayerDecal
	add	esp, 16					; 00000010H

; 2408 : 		break;

	jmp	$LN2@CL_ParseTe
$LN70@CL_ParseTe:

; 2409 : 	case TE_BUBBLES:
; 2410 : 	case TE_BUBBLETRAIL:
; 2411 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2412 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2413 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2414 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2415 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2416 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2417 : 		scale = MSG_ReadCoord( &buf );	// water height

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _scale$[ebp]

; 2418 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2419 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2420 : 		vel = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _vel$[ebp]

; 2421 : 		if( type == TE_BUBBLES ) R_Bubbles( pos, pos2, scale, modelIndex, count, vel );

	cmp	DWORD PTR _type$[ebp], 113		; 00000071H
	jne	SHORT $LN72@CL_ParseTe
	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_Bubbles
	add	esp, 24					; 00000018H
	jmp	SHORT $LN73@CL_ParseTe
$LN72@CL_ParseTe:

; 2422 : 		else R_BubbleTrail( pos, pos2, scale, modelIndex, count, vel );

	push	ecx
	movss	xmm0, DWORD PTR _vel$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _pos2$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BubbleTrail
	add	esp, 24					; 00000018H
$LN73@CL_ParseTe:

; 2423 : 		break;

	jmp	$LN2@CL_ParseTe
$LN74@CL_ParseTe:

; 2424 : 	case TE_BLOODSPRITE:
; 2425 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2426 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2427 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2428 : 		modelIndex = MSG_ReadShort( &buf );	// sprite #1

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2429 : 		decalIndex = MSG_ReadShort( &buf );	// sprite #2

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _decalIndex$[ebp], eax

; 2430 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2431 : 		scale = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2432 : 		R_BloodSprite( pos, color, modelIndex, decalIndex, scale );

	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _decalIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	_R_BloodSprite
	add	esp, 20					; 00000014H

; 2433 : 		break;

	jmp	$LN2@CL_ParseTe
$LN75@CL_ParseTe:

; 2434 : 	case TE_PROJECTILE:
; 2435 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2436 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2437 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2438 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2439 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2440 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2441 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2442 : 		life = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _life$[ebp], xmm0

; 2443 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2444 : 		R_Projectile( pos, pos2, modelIndex, life, color, NULL );

	push	0
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _life$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_Projectile
	add	esp, 24					; 00000018H

; 2445 : 		break;

	jmp	$LN2@CL_ParseTe
$LN76@CL_ParseTe:

; 2446 : 	case TE_PLAYERSPRITES:
; 2447 : 		color = MSG_ReadShort( &buf );	// entitynum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2448 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2449 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2450 : 		random = (float)MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _random$[ebp], xmm0

; 2451 : 		R_PlayerSprites( color, modelIndex, count, random );

	cvttss2si eax, DWORD PTR _random$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_R_PlayerSprites
	add	esp, 16					; 00000010H

; 2452 : 		break;

	jmp	$LN2@CL_ParseTe
$LN77@CL_ParseTe:

; 2453 : 	case TE_PARTICLEBURST:
; 2454 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2455 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2456 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2457 : 		scale = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2458 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2459 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2460 : 		R_ParticleBurst( pos, scale, color, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _scale$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_ParticleBurst
	add	esp, 16					; 00000010H

; 2461 : 		break;

	jmp	$LN2@CL_ParseTe
$LN78@CL_ParseTe:

; 2462 : 	case TE_FIREFIELD:
; 2463 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2464 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2465 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2466 : 		scale = (float)MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	movss	DWORD PTR _scale$[ebp], xmm0

; 2467 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2468 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2469 : 		flags = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 2470 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2471 : 		R_FireField( pos, scale, modelIndex, count, flags, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _scale$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_FireField
	add	esp, 24					; 00000018H

; 2472 : 		break;

	jmp	$LN2@CL_ParseTe
$LN79@CL_ParseTe:

; 2473 : 	case TE_PLAYERATTACHMENT:
; 2474 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2475 : 		scale = MSG_ReadCoord( &buf );	// height

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR _scale$[ebp]

; 2476 : 		modelIndex = MSG_ReadShort( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 2477 : 		life = (float)(MSG_ReadShort( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadShort
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2478 : 		R_AttachTentToPlayer( color, modelIndex, scale, life );

	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	call	_R_AttachTentToPlayer
	add	esp, 16					; 00000010H

; 2479 : 		break;

	jmp	$LN2@CL_ParseTe
$LN80@CL_ParseTe:

; 2480 : 	case TE_KILLPLAYERATTACHMENTS:
; 2481 : 		color = MSG_ReadByte( &buf );	// playernum

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2482 : 		R_KillAttachedTents( color );

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	_R_KillAttachedTents
	add	esp, 4

; 2483 : 		break;

	jmp	$LN2@CL_ParseTe
$LN81@CL_ParseTe:

; 2484 : 	case TE_MULTIGUNSHOT:
; 2485 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2486 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2487 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2488 : 		pos2[0] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2484[ebp]
	movss	xmm0, DWORD PTR tv2484[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _pos2$[ebp+edx], xmm0

; 2489 : 		pos2[1] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2490[ebp]
	movss	xmm0, DWORD PTR tv2490[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _pos2$[ebp+ecx], xmm0

; 2490 : 		pos2[2] = MSG_ReadCoord( &buf ) * 0.1f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2496[ebp]
	movss	xmm0, DWORD PTR tv2496[ebp]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _pos2$[ebp+ecx], xmm0

; 2491 : 		ang[0] = MSG_ReadCoord( &buf ) * 0.01f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2502[ebp]
	movss	xmm0, DWORD PTR tv2502[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _ang$[ebp+edx], xmm0

; 2492 : 		ang[1] = MSG_ReadCoord( &buf ) * 0.01f;

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	fstp	DWORD PTR tv2508[ebp]
	movss	xmm0, DWORD PTR tv2508[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _ang$[ebp+ecx], xmm0

; 2493 : 		ang[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _ang$[ebp+eax], xmm0

; 2494 : 		count = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _count$[ebp], eax

; 2495 : 		decalIndices[0] = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _decalIndices$[ebp+edx], eax

; 2496 : 		R_MultiGunshot( pos, pos2, ang, count, 1, decalIndices );

	lea	eax, DWORD PTR _decalIndices$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ang$[ebp]
	push	edx
	lea	eax, DWORD PTR _pos2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_R_MultiGunshot
	add	esp, 24					; 00000018H

; 2497 : 		break;

	jmp	$LN2@CL_ParseTe
$LN82@CL_ParseTe:

; 2498 : 	case TE_USERTRACER:
; 2499 : 		pos[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos$[ebp+edx]

; 2500 : 		pos[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2501 : 		pos[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos$[ebp+ecx]

; 2502 : 		pos2[0] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	fstp	DWORD PTR _pos2$[ebp+edx]

; 2503 : 		pos2[1] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 0
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2504 : 		pos2[2] = MSG_ReadCoord( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadCoord
	add	esp, 4
	mov	ecx, 4
	shl	ecx, 1
	fstp	DWORD PTR _pos2$[ebp+ecx]

; 2505 : 		life = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _life$[ebp], xmm0

; 2506 : 		color = MSG_ReadByte( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _color$[ebp], eax

; 2507 : 		scale = (float)(MSG_ReadByte( &buf ) * 0.1f);

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _scale$[ebp], xmm0

; 2508 : 		R_UserTracerParticle( pos, pos2, life, color, scale, 0, NULL );

	push	0
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _life$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _pos2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pos$[ebp]
	push	edx
	call	_R_UserTracerParticle
	add	esp, 28					; 0000001cH

; 2509 : 		break;

	jmp	SHORT $LN2@CL_ParseTe
$LN83@CL_ParseTe:

; 2510 : 	default:
; 2511 : 		Con_DPrintf( S_ERROR "ParseTempEntity: illegible TE message %i\n", type );

	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@GBPNOJNL@?$FO1Error?3?$FO7?5ParseTempEntity?3?5ill@
	call	_Con_DPrintf
	add	esp, 8
$LN2@CL_ParseTe:

; 2512 : 		break;
; 2513 : 	}
; 2514 : 
; 2515 : 	// throw warning
; 2516 : 	if( MSG_CheckOverflow( &buf ))

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN84@CL_ParseTe

; 2517 : 		Con_DPrintf( S_WARN "ParseTempEntity: overflow TE message\n" );

	push	OFFSET ??_C@_0DD@EGMOAPEI@?$FO3Warning?3?$FO7?5ParseTempEntity?3?5o@
	call	_Con_DPrintf
	add	esp, 4
$LN84@CL_ParseTe:

; 2518 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN87@CL_ParseTe:
	DD	$LN4@CL_ParseTe
	DD	$LN17@CL_ParseTe
	DD	$LN18@CL_ParseTe
	DD	$LN19@CL_ParseTe
	DD	$LN20@CL_ParseTe
	DD	$LN21@CL_ParseTe
	DD	$LN22@CL_ParseTe
	DD	$LN23@CL_ParseTe
	DD	$LN24@CL_ParseTe
	DD	$LN25@CL_ParseTe
	DD	$LN26@CL_ParseTe
	DD	$LN28@CL_ParseTe
	DD	$LN29@CL_ParseTe
	DD	$LN30@CL_ParseTe
	DD	$LN32@CL_ParseTe
	DD	$LN34@CL_ParseTe
	DD	$LN35@CL_ParseTe
	DD	$LN36@CL_ParseTe
	DD	$LN38@CL_ParseTe
	DD	$LN39@CL_ParseTe
	DD	$LN43@CL_ParseTe
	DD	$LN44@CL_ParseTe
	DD	$LN48@CL_ParseTe
	DD	$LN49@CL_ParseTe
	DD	$LN59@CL_ParseTe
	DD	$LN60@CL_ParseTe
	DD	$LN61@CL_ParseTe
	DD	$LN62@CL_ParseTe
	DD	$LN63@CL_ParseTe
	DD	$LN64@CL_ParseTe
	DD	$LN68@CL_ParseTe
	DD	$LN69@CL_ParseTe
	DD	$LN70@CL_ParseTe
	DD	$LN74@CL_ParseTe
	DD	$LN75@CL_ParseTe
	DD	$LN76@CL_ParseTe
	DD	$LN77@CL_ParseTe
	DD	$LN78@CL_ParseTe
	DD	$LN79@CL_ParseTe
	DD	$LN80@CL_ParseTe
	DD	$LN81@CL_ParseTe
	DD	$LN82@CL_ParseTe
	DD	$LN83@CL_ParseTe
$LN86@CL_ParseTe:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	0
	DB	0
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	0
	DB	13					; 0000000dH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	14					; 0000000eH
	DB	0
	DB	15					; 0000000fH
	DB	0
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	42					; 0000002aH
	DB	0
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	21					; 00000015H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	34					; 00000022H
	DB	29					; 0000001dH
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
_CL_ParseTempEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_DecayLights
_TEXT	SEGMENT
_i$ = -12						; size = 4
_time$ = -8						; size = 4
_dl$ = -4						; size = 4
_CL_DecayLights PROC					; COMDAT

; 2696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2697 : 	dlight_t	*dl;
; 2698 : 	float	time;
; 2699 : 	int	i;
; 2700 : 	
; 2701 : 	time = cl.time - cl.oldtime;

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _time$[ebp], xmm0

; 2702 : 
; 2703 : 	for( i = 0, dl = cl_dlights; i < MAX_DLIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@CL_DecayLi
$LN2@CL_DecayLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@CL_DecayLi:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_DecayLi

; 2704 : 	{
; 2705 : 		if( !dl->radius ) continue;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@CL_DecayLi
	jmp	SHORT $LN2@CL_DecayLi
$LN8@CL_DecayLi:

; 2706 : 
; 2707 : 		dl->radius -= time * dl->decay;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _time$[ebp]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [edx+12], xmm1

; 2708 : 		if( dl->radius < 0 ) dl->radius = 0;

	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN9@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+12], xmm0
$LN9@CL_DecayLi:

; 2709 : 
; 2710 : 		if( dl->die < cl.time || !dl->radius ) 

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN11@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@CL_DecayLi
$LN11@CL_DecayLi:

; 2711 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@CL_DecayLi:

; 2712 : 	}

	jmp	$LN2@CL_DecayLi
$LN3@CL_DecayLi:

; 2713 : 
; 2714 : 	for( i = 0, dl = cl_elights; i < MAX_ELIGHTS; i++, dl++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_elights
	jmp	SHORT $LN7@CL_DecayLi
$LN5@CL_DecayLi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN7@CL_DecayLi:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN6@CL_DecayLi

; 2715 : 	{
; 2716 : 		if( !dl->radius ) continue;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@CL_DecayLi
	jmp	SHORT $LN5@CL_DecayLi
$LN12@CL_DecayLi:

; 2717 : 
; 2718 : 		dl->radius -= time * dl->decay;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _time$[ebp]
	mulss	xmm0, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _dl$[ebp]
	movss	DWORD PTR [edx+12], xmm1

; 2719 : 		if( dl->radius < 0 ) dl->radius = 0;

	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN13@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+12], xmm0
$LN13@CL_DecayLi:

; 2720 : 
; 2721 : 		if( dl->die < cl.time || !dl->radius ) 

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _cl+2167640
	comisd	xmm1, xmm0
	ja	SHORT $LN15@CL_DecayLi
	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_DecayLi
$LN15@CL_DecayLi:

; 2722 : 			memset( dl, 0, sizeof( *dl ));

	push	40					; 00000028H
	push	0
	mov	eax, DWORD PTR _dl$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN14@CL_DecayLi:

; 2723 : 	}

	jmp	$LN5@CL_DecayLi
$LN6@CL_DecayLi:

; 2724 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DecayLights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_tent.c
;	COMDAT _CL_SetLightstyle
_TEXT	SEGMENT
tv210 = -92						; size = 8
tv162 = -88						; size = 4
tv137 = -88						; size = 4
tv79 = -88						; size = 4
tv70 = -88						; size = 4
_val2$ = -20						; size = 4
_val1$ = -16						; size = 4
_ls$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_style$ = 8						; size = 4
_s$ = 12						; size = 4
_f$ = 16						; size = 4
_CL_SetLightstyle PROC					; COMDAT

; 2541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 2542 : 	int		i, k;
; 2543 : 	lightstyle_t	*ls;
; 2544 : 	float		val1, val2;
; 2545 : 
; 2546 : 	Assert( s != NULL );

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN10@CL_SetLigh
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN11@CL_SetLigh
$LN10@CL_SetLigh:
	mov	DWORD PTR tv70[ebp], 0
$LN11@CL_SetLigh:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_SetLightstyle@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_09EGGCOFMI@s?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2547 : 	Assert( style >= 0 && style < MAX_LIGHTSTYLES );

	cmp	DWORD PTR _style$[ebp], 0
	jl	SHORT $LN12@CL_SetLigh
	cmp	DWORD PTR _style$[ebp], 64		; 00000040H
	jge	SHORT $LN12@CL_SetLigh
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN13@CL_SetLigh
$LN12@CL_SetLigh:
	mov	DWORD PTR tv79[ebp], 0
$LN13@CL_SetLigh:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_SetLightstyle@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DE@EPAHEIKG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CG@IJIGLMMD@style?5?$DO?$DN?50?5?$CG?$CG?5style?5?$DM?5MAX_LIGHT@
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 2548 : 
; 2549 : 	ls = &cl.lightstyles[style];

	imul	eax, DWORD PTR _style$[ebp], 1296
	add	eax, OFFSET _cl+2897300
	mov	DWORD PTR _ls$[ebp], eax

; 2550 : 
; 2551 : 	Q_strncpy( ls->pattern, s, sizeof( ls->pattern ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ls$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2552 : 
; 2553 : 	ls->length = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _ls$[ebp]
	mov	DWORD PTR [ecx+1280], eax

; 2554 : 	ls->time = f; // set local time

	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [eax+1292], xmm0

; 2555 : 
; 2556 : 	for( i = 0; i < ls->length; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetLigh
$LN2@CL_SetLigh:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetLigh:
	mov	eax, DWORD PTR _ls$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1280]
	jge	SHORT $LN3@CL_SetLigh

; 2557 : 		ls->map[i] = (float)(s[i] - 'a');

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 97					; 00000061H
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	DWORD PTR [eax+edx*4+256], xmm0
	jmp	SHORT $LN2@CL_SetLigh
$LN3@CL_SetLigh:

; 2558 : 
; 2559 : 	ls->interp = (ls->length <= 1) ? false : true;

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1280], 1
	jg	SHORT $LN14@CL_SetLigh
	mov	DWORD PTR tv137[ebp], 0
	jmp	SHORT $LN15@CL_SetLigh
$LN14@CL_SetLigh:
	mov	DWORD PTR tv137[ebp], 1
$LN15@CL_SetLigh:
	mov	ecx, DWORD PTR _ls$[ebp]
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR [ecx+1288], edx

; 2560 : 
; 2561 : 	// check for allow interpolate
; 2562 : 	// NOTE: fast flickering styles looks ugly when interpolation is running
; 2563 : 	for( k = 0; k < (ls->length - 1); k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@CL_SetLigh
$LN5@CL_SetLigh:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@CL_SetLigh:
	mov	eax, DWORD PTR _ls$[ebp]
	mov	ecx, DWORD PTR [eax+1280]
	sub	ecx, 1
	cmp	DWORD PTR _k$[ebp], ecx
	jge	$LN6@CL_SetLigh

; 2564 : 	{
; 2565 : 		val1 = ls->map[(k+0) % ls->length];

	mov	ecx, DWORD PTR _ls$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	movss	DWORD PTR _val1$[ebp], xmm0

; 2566 : 		val2 = ls->map[(k+1) % ls->length];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ls$[ebp]
	cdq
	idiv	DWORD PTR [ecx+1280]
	mov	eax, DWORD PTR _ls$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+256]
	movss	DWORD PTR _val2$[ebp], xmm0

; 2567 : 
; 2568 : 		if( fabs( val1 - val2 ) > STYLE_LERPING_THRESHOLD )

	movss	xmm0, DWORD PTR _val1$[ebp]
	subss	xmm0, DWORD PTR _val2$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv210[ebp]
	movsd	xmm0, QWORD PTR tv210[ebp]
	comisd	xmm0, QWORD PTR __real@4008000000000000
	jbe	SHORT $LN8@CL_SetLigh

; 2569 : 		{
; 2570 : 			ls->interp = false;

	mov	eax, DWORD PTR _ls$[ebp]
	mov	DWORD PTR [eax+1288], 0

; 2571 : 			break;

	jmp	SHORT $LN6@CL_SetLigh
$LN8@CL_SetLigh:

; 2572 : 		}
; 2573 : 	}

	jmp	$LN5@CL_SetLigh
$LN6@CL_SetLigh:

; 2574 : 
; 2575 : 	Con_Reportf( "Lightstyle %i (%s), interp %s\n", style, ls->pattern, ls->interp ? "Yes" : "No" );

	mov	eax, DWORD PTR _ls$[ebp]
	cmp	DWORD PTR [eax+1288], 0
	je	SHORT $LN16@CL_SetLigh
	mov	DWORD PTR tv162[ebp], OFFSET ??_C@_03CCLAEDDF@Yes@
	jmp	SHORT $LN17@CL_SetLigh
$LN16@CL_SetLigh:
	mov	DWORD PTR tv162[ebp], OFFSET ??_C@_02JINPPBEP@No@
$LN17@CL_SetLigh:
	mov	ecx, DWORD PTR tv162[ebp]
	push	ecx
	mov	edx, DWORD PTR _ls$[ebp]
	push	edx
	mov	eax, DWORD PTR _style$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@LJEJFAAK@Lightstyle?5?$CFi?5?$CI?$CFs?$CJ?0?5interp?5?$CFs?6@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 2576 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetLightstyle ENDP
_TEXT	ENDS
END
