; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\crtlib.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	_Q_strnupr
PUBLIC	_Q_strnlwr
PUBLIC	_Q_strlen
PUBLIC	_Q_colorstr
PUBLIC	_Q_toupper
PUBLIC	_Q_tolower
PUBLIC	_Q_strncat
PUBLIC	_Q_strncpy
PUBLIC	__copystring
PUBLIC	_Q_hashkey
PUBLIC	_Q_isdigit
PUBLIC	_Q_atoi
PUBLIC	_Q_atof
PUBLIC	_Q_atov
PUBLIC	_Q_strchr
PUBLIC	_Q_strrchr
PUBLIC	_Q_strnicmp
PUBLIC	_Q_strncmp
PUBLIC	_Q_stricmpext
PUBLIC	_Q_timestamp
PUBLIC	_Q_stristr
PUBLIC	_Q_strstr
PUBLIC	_Q_vsnprintf
PUBLIC	_Q_snprintf
PUBLIC	_Q_sprintf
PUBLIC	_Q_pretifymem
PUBLIC	_va
PUBLIC	??_C@_0BD@JKKKLBJP@?$CFb?$CFd?5?$CFY?5?$FL?$CFH?3?$CFM?4?$CFS?$FN@ ; `string'
PUBLIC	??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@		; `string'
PUBLIC	??_C@_08DPAEFFBF@?$CFH?3?$CFM?4?$CFS@		; `string'
PUBLIC	??_C@_05JFBIHENH@?$CFH?3?$CFM@			; `string'
PUBLIC	??_C@_02FFEBEEPL@?$CFY@				; `string'
PUBLIC	??_C@_0BB@JFCHFJN@?$CFb?$CFY?9?$CFd_?$CFH?4?$CFM?4?$CFS@ ; `string'
PUBLIC	??_C@_0BN@IPMECMAK@?$FO1sprintf?5throw?5exception?$FO7?6@ ; `string'
PUBLIC	??_C@_03FBAAJIGL@?5Mb@				; `string'
PUBLIC	??_C@_03FFINOENJ@?5Kb@				; `string'
PUBLIC	??_C@_06LCIDCBMH@?5bytes@			; `string'
PUBLIC	??_C@_04EMEGLOCB@?$CFi?$CFs@			; `string'
PUBLIC	??_C@_08BIBOIFBG@?$CF?$CF?4?$CFif?$CFs@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__real@4024000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@4048000000000000
PUBLIC	__real@4050400000000000
PUBLIC	__real@4058400000000000
PUBLIC	__real@44800000
EXTRN	_fabs:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___localtime64:PROC
EXTRN	__imp__strftime:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	_memset:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	_host:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?timestamp@?1??Q_timestamp@@9@9 DB 0100H DUP (?)	; `Q_timestamp'::`2'::timestamp
?output@?1??Q_pretifymem@@9@9 DB 0100H DUP (?)		; `Q_pretifymem'::`2'::output
?current@?1??Q_pretifymem@@9@9 DD 01H DUP (?)		; `Q_pretifymem'::`2'::current
?string@?1??va@@9@9 DB 040000H DUP (?)			; `va'::`2'::string
?s@?1??va@@9@9 DD 01H DUP (?)				; `va'::`2'::s
?stringindex@?1??va@@9@9 DD 01H DUP (?)			; `va'::`2'::stringindex
_BSS	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@4058400000000000
CONST	SEGMENT
__real@4058400000000000 DQ 04058400000000000r	; 97
CONST	ENDS
;	COMDAT __real@4050400000000000
CONST	SEGMENT
__real@4050400000000000 DQ 04050400000000000r	; 65
CONST	ENDS
;	COMDAT __real@4048000000000000
CONST	SEGMENT
__real@4048000000000000 DQ 04048000000000000r	; 48
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BIBOIFBG@?$CF?$CF?4?$CFif?$CFs@
CONST	SEGMENT
??_C@_08BIBOIFBG@?$CF?$CF?4?$CFif?$CFs@ DB '%%.%if%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EMEGLOCB@?$CFi?$CFs@
CONST	SEGMENT
??_C@_04EMEGLOCB@?$CFi?$CFs@ DB '%i%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCIDCBMH@?5bytes@
CONST	SEGMENT
??_C@_06LCIDCBMH@?5bytes@ DB ' bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFINOENJ@?5Kb@
CONST	SEGMENT
??_C@_03FFINOENJ@?5Kb@ DB ' Kb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBAAJIGL@?5Mb@
CONST	SEGMENT
??_C@_03FBAAJIGL@?5Mb@ DB ' Mb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IPMECMAK@?$FO1sprintf?5throw?5exception?$FO7?6@
CONST	SEGMENT
??_C@_0BN@IPMECMAK@?$FO1sprintf?5throw?5exception?$FO7?6@ DB '^1sprintf t'
	DB	'hrow exception^7', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFCHFJN@?$CFb?$CFY?9?$CFd_?$CFH?4?$CFM?4?$CFS@
CONST	SEGMENT
??_C@_0BB@JFCHFJN@?$CFb?$CFY?9?$CFd_?$CFH?4?$CFM?4?$CFS@ DB '%b%Y-%d_%H.%'
	DB	'M.%S', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02FFEBEEPL@?$CFY@
CONST	SEGMENT
??_C@_02FFEBEEPL@?$CFY@ DB '%Y', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JFBIHENH@?$CFH?3?$CFM@
CONST	SEGMENT
??_C@_05JFBIHENH@?$CFH?3?$CFM@ DB '%H:%M', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPAEFFBF@?$CFH?3?$CFM?4?$CFS@
CONST	SEGMENT
??_C@_08DPAEFFBF@?$CFH?3?$CFM?4?$CFS@ DB '%H:%M.%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@
CONST	SEGMENT
??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@ DB '%b%d %Y', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKKKLBJP@?$CFb?$CFd?5?$CFY?5?$FL?$CFH?3?$CFM?4?$CFS?$FN@
CONST	SEGMENT
??_C@_0BD@JKKKLBJP@?$CFb?$CFd?5?$CFY?5?$FL?$CFH?3?$CFM?4?$CFS?$FN@ DB '%b'
	DB	'%d %Y [%H:%M.%S]', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0227H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_Q_vsnprintf DD 0fffffffeH
	DD	00H
	DD	0ffffff94H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN12@Q_vsnprint
	DD	FLAT:$LN8@Q_vsnprint
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	013fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0faH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_starcmp
_TEXT	SEGMENT
tv129 = -80						; size = 4
tv82 = -80						; size = 4
tv75 = -80						; size = 4
tv67 = -80						; size = 4
_t$ = -12						; size = 4
_p$ = -8						; size = 4
_c1$ = -2						; size = 1
_c$ = -1						; size = 1
_pattern$ = 8						; size = 4
_text$ = 12						; size = 4
_Q_starcmp PROC						; COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 423  : 	char		c, c1;
; 424  : 	const char	*p = pattern, *t = text;

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR _t$[ebp], eax
$LN2@Q_starcmp:

; 425  : 
; 426  : 	while(( c = *p++ ) == '?' || c == '*' )

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
	movsx	edx, BYTE PTR _c$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR tv67[ebp], 63			; 0000003fH
	je	SHORT $LN7@Q_starcmp
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN3@Q_starcmp
$LN7@Q_starcmp:

; 427  : 	{
; 428  : 		if( c == '?' && *t++ == '\0' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN8@Q_starcmp
	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
	cmp	DWORD PTR tv75[ebp], 0
	jne	SHORT $LN8@Q_starcmp

; 429  : 			return false;

	xor	eax, eax
	jmp	$LN1@Q_starcmp
$LN8@Q_starcmp:

; 430  : 	}

	jmp	SHORT $LN2@Q_starcmp
$LN3@Q_starcmp:

; 431  : 
; 432  : 	if( c == '\0' ) return true;

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN9@Q_starcmp
	mov	eax, 1
	jmp	SHORT $LN1@Q_starcmp
$LN9@Q_starcmp:

; 433  : 
; 434  : 	for( c1 = (( c == '\\' ) ? *p : c ); ; )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN13@Q_starcmp
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN14@Q_starcmp
$LN13@Q_starcmp:
	movsx	eax, BYTE PTR _c$[ebp]
	mov	DWORD PTR tv82[ebp], eax
$LN14@Q_starcmp:
	mov	cl, BYTE PTR tv82[ebp]
	mov	BYTE PTR _c1$[ebp], cl
$LN6@Q_starcmp:

; 435  : 	{
; 436  : 		if( Q_tolower( *t ) == c1 && Q_stricmpext( p - 1, t ))

	mov	eax, DWORD PTR _t$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	movsx	eax, BYTE PTR _c1$[ebp]
	cmp	edx, eax
	jne	SHORT $LN10@Q_starcmp
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, 1
	push	ecx
	call	_Q_stricmpext
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@Q_starcmp

; 437  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Q_starcmp
$LN10@Q_starcmp:

; 438  : 		if( *t++ == '\0' ) return false;

	mov	eax, DWORD PTR _t$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv129[ebp], ecx
	mov	edx, DWORD PTR _t$[ebp]
	add	edx, 1
	mov	DWORD PTR _t$[ebp], edx
	cmp	DWORD PTR tv129[ebp], 0
	jne	SHORT $LN11@Q_starcmp
	xor	eax, eax
	jmp	SHORT $LN1@Q_starcmp
$LN11@Q_starcmp:

; 439  : 	}

	jmp	SHORT $LN6@Q_starcmp
$LN1@Q_starcmp:

; 440  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_starcmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _va
_TEXT	SEGMENT
_argptr$ = -4						; size = 4
_format$ = 8						; size = 4
_va	PROC						; COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 711  : 	va_list		argptr;
; 712  : 	static char	string[256][1024], *s;
; 713  : 	static int	stringindex = 0;
; 714  : 
; 715  : 	s = string[stringindex];

	mov	eax, DWORD PTR ?stringindex@?1??va@@9@9
	shl	eax, 10					; 0000000aH
	add	eax, OFFSET ?string@?1??va@@9@9
	mov	DWORD PTR ?s@?1??va@@9@9, eax

; 716  : 	stringindex = (stringindex + 1) & 255;

	mov	eax, DWORD PTR ?stringindex@?1??va@@9@9
	add	eax, 1
	and	eax, 255				; 000000ffH
	mov	DWORD PTR ?stringindex@?1??va@@9@9, eax

; 717  : 	va_start( argptr, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _argptr$[ebp], eax

; 718  : 	Q_vsnprintf( s, sizeof( string[0] ), format, argptr );

	mov	eax, DWORD PTR _argptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edx, DWORD PTR ?s@?1??va@@9@9
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H

; 719  : 	va_end( argptr );

	mov	DWORD PTR _argptr$[ebp], 0

; 720  : 
; 721  : 	return s;

	mov	eax, DWORD PTR ?s@?1??va@@9@9

; 722  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_va	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_pretifymem
_TEXT	SEGMENT
tv170 = -176						; size = 8
tv80 = -172						; size = 4
_fmt$1 = -104						; size = 32
_pos$ = -72						; size = 4
_dot$ = -68						; size = 4
_o$ = -64						; size = 4
_i$ = -60						; size = 4
_val$ = -56						; size = 32
_out$ = -24						; size = 4
_suffix$ = -20						; size = 8
_onemb$ = -12						; size = 4
_onekb$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_digitsafterdecimal$ = 12				; size = 4
_Q_pretifymem PROC					; COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 630  : 	static char	output[8][32];
; 631  : 	static int	current;
; 632  : 	float		onekb = 1024.0f;

	movss	xmm0, DWORD PTR __real@44800000
	movss	DWORD PTR _onekb$[ebp], xmm0

; 633  : 	float		onemb = onekb * onekb;

	movss	xmm0, DWORD PTR _onekb$[ebp]
	mulss	xmm0, DWORD PTR _onekb$[ebp]
	movss	DWORD PTR _onemb$[ebp], xmm0

; 634  : 	char		suffix[8];
; 635  : 	char		*out = output[current];

	mov	eax, DWORD PTR ?current@?1??Q_pretifymem@@9@9
	shl	eax, 5
	add	eax, OFFSET ?output@?1??Q_pretifymem@@9@9
	mov	DWORD PTR _out$[ebp], eax

; 636  : 	char		val[32], *i, *o, *dot;
; 637  : 	int		pos;
; 638  : 
; 639  : 	current = ( current + 1 ) & ( 8 - 1 );

	mov	eax, DWORD PTR ?current@?1??Q_pretifymem@@9@9
	add	eax, 1
	and	eax, 7
	mov	DWORD PTR ?current@?1??Q_pretifymem@@9@9, eax

; 640  : 
; 641  : 	// first figure out which bin to use
; 642  : 	if( value > onemb )

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _onemb$[ebp]
	jbe	SHORT $LN4@Q_pretifym

; 643  : 	{
; 644  : 		value /= onemb;

	movss	xmm0, DWORD PTR _value$[ebp]
	divss	xmm0, DWORD PTR _onemb$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 645  : 		Q_sprintf( suffix, " Mb" );

	push	OFFSET ??_C@_03FBAAJIGL@?5Mb@
	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 8

; 646  : 	}

	jmp	SHORT $LN7@Q_pretifym
$LN4@Q_pretifym:

; 647  : 	else if( value > onekb )

	movss	xmm0, DWORD PTR _value$[ebp]
	comiss	xmm0, DWORD PTR _onekb$[ebp]
	jbe	SHORT $LN6@Q_pretifym

; 648  : 	{
; 649  : 		value /= onekb;

	movss	xmm0, DWORD PTR _value$[ebp]
	divss	xmm0, DWORD PTR _onekb$[ebp]
	movss	DWORD PTR _value$[ebp], xmm0

; 650  : 		Q_sprintf( suffix, " Kb" );

	push	OFFSET ??_C@_03FFINOENJ@?5Kb@
	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 8

; 651  : 	}

	jmp	SHORT $LN7@Q_pretifym
$LN6@Q_pretifym:

; 652  : 	else Q_sprintf( suffix, " bytes" );

	push	OFFSET ??_C@_06LCIDCBMH@?5bytes@
	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	call	_Q_sprintf
	add	esp, 8
$LN7@Q_pretifym:

; 653  : 
; 654  : 	// clamp to >= 0
; 655  : 	digitsafterdecimal = max( digitsafterdecimal, 0 );

	cmp	DWORD PTR _digitsafterdecimal$[ebp], 0
	jle	SHORT $LN14@Q_pretifym
	mov	eax, DWORD PTR _digitsafterdecimal$[ebp]
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN15@Q_pretifym
$LN14@Q_pretifym:
	mov	DWORD PTR tv80[ebp], 0
$LN15@Q_pretifym:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _digitsafterdecimal$[ebp], ecx

; 656  : 
; 657  : 	// if it's basically integral, don't do any decimals
; 658  : 	if( fabs( value - (int)value ) < 0.00001 )

	cvttss2si eax, DWORD PTR _value$[ebp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _value$[ebp]
	subss	xmm1, xmm0
	cvtss2sd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv170[ebp]
	movsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	comisd	xmm0, QWORD PTR tv170[ebp]
	jbe	SHORT $LN8@Q_pretifym

; 659  : 	{
; 660  : 		Q_sprintf( val, "%i%s", (int)value, suffix );

	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET ??_C@_04EMEGLOCB@?$CFi?$CFs@
	lea	edx, DWORD PTR _val$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 661  : 	}

	jmp	SHORT $LN9@Q_pretifym
$LN8@Q_pretifym:

; 662  : 	else
; 663  : 	{
; 664  : 		char fmt[32];
; 665  : 
; 666  : 		// otherwise, create a format string for the decimals
; 667  : 		Q_sprintf( fmt, "%%.%if%s", digitsafterdecimal, suffix );

	lea	eax, DWORD PTR _suffix$[ebp]
	push	eax
	mov	ecx, DWORD PTR _digitsafterdecimal$[ebp]
	push	ecx
	push	OFFSET ??_C@_08BIBOIFBG@?$CF?$CF?4?$CFif?$CFs@
	lea	edx, DWORD PTR _fmt$1[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 668  : 		Q_sprintf( val, fmt, value );

	cvtss2sd xmm0, DWORD PTR _value$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _fmt$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H
$LN9@Q_pretifym:

; 669  : 	}
; 670  : 
; 671  : 	// copy from in to out
; 672  : 	i = val;

	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 673  : 	o = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _o$[ebp], eax

; 674  : 
; 675  : 	// search for decimal or if it was integral, find the space after the raw number
; 676  : 	dot = Q_strstr( i, "." );

	push	OFFSET ??_C@_01LFCBOECM@?4@
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax

; 677  : 	if( !dot ) dot = Q_strstr( i, " " );

	cmp	DWORD PTR _dot$[ebp], 0
	jne	SHORT $LN10@Q_pretifym
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	mov	DWORD PTR _dot$[ebp], eax
$LN10@Q_pretifym:

; 678  : 
; 679  : 	pos = dot - i;	// compute position of dot

	mov	eax, DWORD PTR _dot$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 680  : 	pos -= 3;		// don't put a comma if it's <= 3 long

	mov	eax, DWORD PTR _pos$[ebp]
	sub	eax, 3
	mov	DWORD PTR _pos$[ebp], eax
$LN2@Q_pretifym:

; 681  : 
; 682  : 	while( *i )

	mov	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_pretifym

; 683  : 	{
; 684  : 		// if pos is still valid then insert a comma every third digit, except if we would be
; 685  : 		// putting one in the first spot
; 686  : 		if( pos >= 0 && !( pos % 3 ))

	cmp	DWORD PTR _pos$[ebp], 0
	jl	SHORT $LN12@Q_pretifym
	mov	eax, DWORD PTR _pos$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN12@Q_pretifym

; 687  : 		{
; 688  : 			// never in first spot
; 689  : 			if( o != out ) *o++ = ',';

	mov	eax, DWORD PTR _o$[ebp]
	cmp	eax, DWORD PTR _out$[ebp]
	je	SHORT $LN12@Q_pretifym
	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 44			; 0000002cH
	mov	ecx, DWORD PTR _o$[ebp]
	add	ecx, 1
	mov	DWORD PTR _o$[ebp], ecx
$LN12@Q_pretifym:

; 690  : 		}
; 691  : 
; 692  : 		pos--;		// count down comma position

	mov	eax, DWORD PTR _pos$[ebp]
	sub	eax, 1
	mov	DWORD PTR _pos$[ebp], eax

; 693  : 		*o++ = *i++;	// copy rest of data as normal

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 694  : 	}

	jmp	SHORT $LN2@Q_pretifym
$LN3@Q_pretifym:

; 695  : 	*o = 0; // terminate

	mov	eax, DWORD PTR _o$[ebp]
	mov	BYTE PTR [eax], 0

; 696  : 
; 697  : 	return out;

	mov	eax, DWORD PTR _out$[ebp]

; 698  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_pretifymem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_sprintf
_TEXT	SEGMENT
_result$ = -8						; size = 4
_args$ = -4						; size = 4
_buffer$ = 8						; size = 4
_format$ = 12						; size = 4
_Q_sprintf PROC						; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 598  : 	va_list	args;
; 599  : 	int	result;
; 600  : 
; 601  : 	va_start( args, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 602  : 	result = Q_vsnprintf( buffer, 99999, format, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 603  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 604  : 
; 605  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 606  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_snprintf
_TEXT	SEGMENT
_result$ = -8						; size = 4
_args$ = -4						; size = 4
_buffer$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_format$ = 16						; size = 4
_Q_snprintf PROC					; COMDAT

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 586  : 	va_list	args;
; 587  : 	int	result;
; 588  : 
; 589  : 	va_start( args, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 590  : 	result = Q_vsnprintf( buffer, buffersize, format, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffersize$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 591  : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 592  : 
; 593  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 594  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_vsnprintf
_TEXT	SEGMENT
_result$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_buffer$ = 8						; size = 4
_buffersize$ = 12					; size = 4
_format$ = 16						; size = 4
_args$ = 20						; size = 4
_Q_vsnprintf PROC					; COMDAT

; 561  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_Q_vsnprintf
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -76				; ffffffb4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 562  : 	size_t	result;
; 563  : 
; 564  : 	__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 565  : 	{
; 566  : 		result = _vsnprintf( buffer, buffersize, format, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffersize$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	__vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], eax

; 567  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN10@Q_vsnprint
$LN7@Q_vsnprint:
$LN12@Q_vsnprint:

; 568  : 
; 569  : 	// to prevent crash while output
; 570  : 	__except( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN9@Q_vsnprint:
$LN11@Q_vsnprint:
	ret	0
$LN8@Q_vsnprint:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 571  : 	{
; 572  : 		Q_strncpy( buffer, "^1sprintf throw exception^7\n", buffersize );

	mov	eax, DWORD PTR _buffersize$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@IPMECMAK@?$FO1sprintf?5throw?5exception?$FO7?6@
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 573  : 		result = buffersize;

	mov	eax, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 567  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN10@Q_vsnprint:

; 574  : 	}
; 575  : 
; 576  : 	if( result < 0 || result >= buffersize )

	cmp	DWORD PTR _result$[ebp], 0
	jb	SHORT $LN4@Q_vsnprint
	mov	eax, DWORD PTR _result$[ebp]
	cmp	eax, DWORD PTR _buffersize$[ebp]
	jb	SHORT $LN3@Q_vsnprint
$LN4@Q_vsnprint:

; 577  : 	{
; 578  : 		buffer[buffersize - 1] = '\0';

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _buffersize$[ebp]
	mov	BYTE PTR [eax-1], 0

; 579  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN6@Q_vsnprint
$LN3@Q_vsnprint:

; 580  : 	}
; 581  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN6@Q_vsnprint:

; 582  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strstr
_TEXT	SEGMENT
_len$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_string2$ = 12						; size = 4
_Q_strstr PROC						; COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 514  : 	int	c, len;
; 515  : 
; 516  : 	if( !string || !string2 ) return NULL;

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN8@Q_strstr
	cmp	DWORD PTR _string2$[ebp], 0
	jne	SHORT $LN7@Q_strstr
$LN8@Q_strstr:
	xor	eax, eax
	jmp	SHORT $LN1@Q_strstr
$LN7@Q_strstr:

; 517  : 
; 518  : 	c = *string2;

	mov	eax, DWORD PTR _string2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx

; 519  : 	len = Q_strlen( string2 );

	mov	eax, DWORD PTR _string2$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_strstr:

; 520  : 
; 521  : 	while( string )

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@Q_strstr
	jmp	SHORT $LN6@Q_strstr
$LN4@Q_strstr:

; 522  : 	{
; 523  : 		for( ; *string && *string != c; string++ );

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax
$LN6@Q_strstr:
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Q_strstr
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, DWORD PTR _c$[ebp]
	je	SHORT $LN5@Q_strstr
	jmp	SHORT $LN4@Q_strstr
$LN5@Q_strstr:

; 524  : 
; 525  : 		if( *string )

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@Q_strstr

; 526  : 		{
; 527  : 			if( !Q_strncmp( string, string2, len ))

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Q_strstr

; 528  : 				break;

	jmp	SHORT $LN3@Q_strstr
$LN11@Q_strstr:

; 529  : 			string++;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax

; 530  : 		}

	jmp	SHORT $LN10@Q_strstr
$LN9@Q_strstr:

; 531  : 		else return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Q_strstr
$LN10@Q_strstr:

; 532  : 	}

	jmp	SHORT $LN2@Q_strstr
$LN3@Q_strstr:

; 533  : 	return (char *)string;

	mov	eax, DWORD PTR _string$[ebp]
$LN1@Q_strstr:

; 534  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_stristr
_TEXT	SEGMENT
_len$ = -8						; size = 4
_c$ = -4						; size = 4
_string$ = 8						; size = 4
_string2$ = 12						; size = 4
_Q_stristr PROC						; COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 538  : 	int	c, len;
; 539  : 
; 540  : 	if( !string || !string2 ) return NULL;

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN8@Q_stristr
	cmp	DWORD PTR _string2$[ebp], 0
	jne	SHORT $LN7@Q_stristr
$LN8@Q_stristr:
	xor	eax, eax
	jmp	$LN1@Q_stristr
$LN7@Q_stristr:

; 541  : 
; 542  : 	c = Q_tolower( *string2 );

	mov	eax, DWORD PTR _string2$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR _c$[ebp], edx

; 543  : 	len = Q_strlen( string2 );

	mov	eax, DWORD PTR _string2$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_stristr:

; 544  : 
; 545  : 	while( string )

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@Q_stristr
	jmp	SHORT $LN6@Q_stristr
$LN4@Q_stristr:

; 546  : 	{
; 547  : 		for( ; *string && Q_tolower( *string ) != c; string++ );

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax
$LN6@Q_stristr:
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Q_stristr
	mov	eax, DWORD PTR _string$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	cmp	edx, DWORD PTR _c$[ebp]
	je	SHORT $LN5@Q_stristr
	jmp	SHORT $LN4@Q_stristr
$LN5@Q_stristr:

; 548  : 
; 549  : 		if( *string )

	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@Q_stristr

; 550  : 		{
; 551  : 			if( !Q_strnicmp( string, string2, len ))

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _string2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _string$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@Q_stristr

; 552  : 				break;

	jmp	SHORT $LN3@Q_stristr
$LN11@Q_stristr:

; 553  : 			string++;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax

; 554  : 		}

	jmp	SHORT $LN10@Q_stristr
$LN9@Q_stristr:

; 555  : 		else return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Q_stristr
$LN10@Q_stristr:

; 556  : 	}

	jmp	SHORT $LN2@Q_stristr
$LN3@Q_stristr:

; 557  : 	return (char *)string;

	mov	eax, DWORD PTR _string$[ebp]
$LN1@Q_stristr:

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_stristr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_timestamp
_TEXT	SEGMENT
tv67 = -340						; size = 4
_timestring$ = -272					; size = 256
_crt_tm$ = -16						; size = 4
_crt_time$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_format$ = 8						; size = 4
_Q_timestamp PROC					; COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 470  : 	static string	timestamp;
; 471  : 	time_t		crt_time;
; 472  : 	const struct tm	*crt_tm;
; 473  : 	string		timestring;
; 474  : 
; 475  : 	time( &crt_time );

	lea	eax, DWORD PTR _crt_time$[ebp]
	push	eax
	call	_time
	add	esp, 4

; 476  : 	crt_tm = localtime( &crt_time );

	lea	eax, DWORD PTR _crt_time$[ebp]
	push	eax
	call	_localtime
	add	esp, 4
	mov	DWORD PTR _crt_tm$[ebp], eax

; 477  : 
; 478  : 	switch( format )

	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 5
	ja	$LN10@Q_timestam
	mov	ecx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN12@Q_timestam[ecx*4]
$LN4@Q_timestam:

; 479  : 	{
; 480  : 	case TIME_FULL:
; 481  : 		// Build the full timestamp (ex: "Apr03 2007 [23:31.55]");
; 482  : 		strftime( timestring, sizeof( timestring ), "%b%d %Y [%H:%M.%S]", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@JKKKLBJP@?$CFb?$CFd?5?$CFY?5?$FL?$CFH?3?$CFM?4?$CFS?$FN@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 483  : 		break;

	jmp	$LN2@Q_timestam
$LN5@Q_timestam:

; 484  : 	case TIME_DATE_ONLY:
; 485  : 		// Build the date stamp only (ex: "Apr03 2007");
; 486  : 		strftime( timestring, sizeof( timestring ), "%b%d %Y", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_07PJHMJJEI@?$CFb?$CFd?5?$CFY@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 487  : 		break;

	jmp	$LN2@Q_timestam
$LN6@Q_timestam:

; 488  : 	case TIME_TIME_ONLY:
; 489  : 		// Build the time stamp only (ex: "23:31.55");
; 490  : 		strftime( timestring, sizeof( timestring ), "%H:%M.%S", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_08DPAEFFBF@?$CFH?3?$CFM?4?$CFS@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 491  : 		break;

	jmp	SHORT $LN2@Q_timestam
$LN7@Q_timestam:

; 492  : 	case TIME_NO_SECONDS:
; 493  : 		// Build the time stamp exclude seconds (ex: "13:46");
; 494  : 		strftime( timestring, sizeof( timestring ), "%H:%M", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_05JFBIHENH@?$CFH?3?$CFM@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 495  : 		break;

	jmp	SHORT $LN2@Q_timestam
$LN8@Q_timestam:

; 496  : 	case TIME_YEAR_ONLY:
; 497  : 		// Build the date stamp year only (ex: "2006");
; 498  : 		strftime( timestring, sizeof( timestring ), "%Y", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_02FFEBEEPL@?$CFY@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 499  : 		break;

	jmp	SHORT $LN2@Q_timestam
$LN9@Q_timestam:

; 500  : 	case TIME_FILENAME:
; 501  : 		// Build a timestamp that can use for filename (ex: "Nov2006-26 (19.14.28)");
; 502  : 		strftime( timestring, sizeof( timestring ), "%b%Y-%d_%H.%M.%S", crt_tm );

	mov	eax, DWORD PTR _crt_tm$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@JFCHFJN@?$CFb?$CFY?9?$CFd_?$CFH?4?$CFM?4?$CFS@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _timestring$[ebp]
	push	ecx
	call	DWORD PTR __imp__strftime
	add	esp, 16					; 00000010H

; 503  : 		break;

	jmp	SHORT $LN2@Q_timestam
$LN10@Q_timestam:

; 504  : 	default: return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@Q_timestam
$LN2@Q_timestam:

; 505  : 	}
; 506  : 
; 507  : 	Q_strncpy( timestamp, timestring, sizeof( timestamp ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _timestring$[ebp]
	push	eax
	push	OFFSET ?timestamp@?1??Q_timestamp@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 508  : 
; 509  : 	return timestamp;

	mov	eax, OFFSET ?timestamp@?1??Q_timestamp@@9@9
$LN1@Q_timestam:

; 510  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@Q_timestam:
	DD	$LN4@Q_timestam
	DD	$LN5@Q_timestam
	DD	$LN6@Q_timestam
	DD	$LN7@Q_timestam
	DD	$LN8@Q_timestam
	DD	$LN9@Q_timestam
_Q_timestamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_stricmpext
_TEXT	SEGMENT
tv132 = -76						; size = 4
tv86 = -76						; size = 4
tv140 = -72						; size = 4
tv131 = -72						; size = 4
tv85 = -72						; size = 4
tv73 = -72						; size = 4
tv69 = -72						; size = 4
tv67 = -72						; size = 4
tv81 = -67						; size = 1
tv95 = -66						; size = 1
tv76 = -66						; size = 1
_c$ = -1						; size = 1
_pattern$ = 8						; size = 4
_text$ = 12						; size = 4
_Q_stricmpext PROC					; COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
$LN2@Q_stricmpe:

; 444  : 	char	c;
; 445  : 
; 446  : 	while(( c = *pattern++ ) != '\0' )

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
	movsx	edx, BYTE PTR _c$[ebp]
	mov	DWORD PTR tv67[ebp], edx
	mov	eax, DWORD PTR _pattern$[ebp]
	add	eax, 1
	mov	DWORD PTR _pattern$[ebp], eax
	cmp	DWORD PTR tv67[ebp], 0
	je	$LN3@Q_stricmpe

; 447  : 	{
; 448  : 		switch( c )

	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR tv69[ebp], al
	cmp	BYTE PTR tv69[ebp], 42			; 0000002aH
	je	$LN10@Q_stricmpe
	cmp	BYTE PTR tv69[ebp], 63			; 0000003fH
	je	SHORT $LN6@Q_stricmpe
	cmp	BYTE PTR tv69[ebp], 92			; 0000005cH
	je	SHORT $LN8@Q_stricmpe
	jmp	$LN11@Q_stricmpe
$LN6@Q_stricmpe:

; 449  : 		{
; 450  : 		case '?':
; 451  : 			if( *text++ == '\0' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _text$[ebp]
	add	edx, 1
	mov	DWORD PTR _text$[ebp], edx
	cmp	DWORD PTR tv73[ebp], 0
	jne	SHORT $LN7@Q_stricmpe

; 452  : 				return false;

	xor	eax, eax
	jmp	$LN1@Q_stricmpe
$LN7@Q_stricmpe:

; 453  : 			break;

	jmp	$LN4@Q_stricmpe
$LN8@Q_stricmpe:

; 454  : 		case '\\':
; 455  : 			if( Q_tolower( *pattern++ ) != Q_tolower( *text++ ))

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv76[ebp], cl
	mov	edx, DWORD PTR _text$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv81[ebp], al
	movzx	ecx, BYTE PTR tv76[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR tv85[ebp], edx
	movzx	eax, BYTE PTR tv81[ebp]
	push	eax
	call	_Q_tolower
	add	esp, 4
	movsx	ecx, al
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR _text$[ebp]
	add	edx, 1
	mov	DWORD PTR _text$[ebp], edx
	mov	eax, DWORD PTR _pattern$[ebp]
	add	eax, 1
	mov	DWORD PTR _pattern$[ebp], eax
	mov	ecx, DWORD PTR tv85[ebp]
	cmp	ecx, DWORD PTR tv86[ebp]
	je	SHORT $LN9@Q_stricmpe

; 456  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@Q_stricmpe
$LN9@Q_stricmpe:

; 457  : 			break;

	jmp	SHORT $LN4@Q_stricmpe
$LN10@Q_stricmpe:

; 458  : 		case '*':
; 459  : 			return Q_starcmp( pattern, text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_Q_starcmp
	add	esp, 8
	jmp	SHORT $LN1@Q_stricmpe
$LN11@Q_stricmpe:

; 460  : 		default:
; 461  : 			if( Q_tolower( c ) != Q_tolower( *text++ ))

	mov	eax, DWORD PTR _text$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv95[ebp], cl
	movzx	edx, BYTE PTR _c$[ebp]
	push	edx
	call	_Q_tolower
	add	esp, 4
	movsx	eax, al
	mov	DWORD PTR tv131[ebp], eax
	movzx	ecx, BYTE PTR tv95[ebp]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR tv132[ebp], edx
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	cmp	ecx, DWORD PTR tv132[ebp]
	je	SHORT $LN4@Q_stricmpe

; 462  : 				return false;

	xor	eax, eax
	jmp	SHORT $LN1@Q_stricmpe
$LN4@Q_stricmpe:

; 463  : 		}
; 464  : 	}

	jmp	$LN2@Q_stricmpe
$LN3@Q_stricmpe:

; 465  : 	return ( *text == '\0' );

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN14@Q_stricmpe
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN15@Q_stricmpe
$LN14@Q_stricmpe:
	mov	DWORD PTR tv140[ebp], 0
$LN15@Q_stricmpe:
	mov	eax, DWORD PTR tv140[ebp]
$LN1@Q_stricmpe:

; 466  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_stricmpext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strncmp
_TEXT	SEGMENT
tv76 = -76						; size = 4
tv73 = -76						; size = 4
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
_Q_strncmp PROC						; COMDAT

; 393  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 394  : 	int	c1, c2;
; 395  : 
; 396  : 	if( s1 == NULL )

	cmp	DWORD PTR _s1$[ebp], 0
	jne	SHORT $LN5@Q_strncmp

; 397  : 	{
; 398  : 		if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN7@Q_strncmp

; 399  : 			return 0;

	xor	eax, eax
	jmp	$LN1@Q_strncmp
	jmp	SHORT $LN8@Q_strncmp
$LN7@Q_strncmp:

; 400  : 		else return -1;

	or	eax, -1
	jmp	SHORT $LN1@Q_strncmp
$LN8@Q_strncmp:

; 401  : 	}

	jmp	SHORT $LN4@Q_strncmp
$LN5@Q_strncmp:

; 402  : 	else if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN4@Q_strncmp

; 403  : 	{
; 404  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Q_strncmp
$LN4@Q_strncmp:

; 405  : 	}	
; 406  : 
; 407  : 	do {
; 408  : 		c1 = *s1++;

	mov	eax, DWORD PTR _s1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$[ebp], ecx
	mov	edx, DWORD PTR _s1$[ebp]
	add	edx, 1
	mov	DWORD PTR _s1$[ebp], edx

; 409  : 		c2 = *s2++;

	mov	eax, DWORD PTR _s2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c2$[ebp], ecx
	mov	edx, DWORD PTR _s2$[ebp]
	add	edx, 1
	mov	DWORD PTR _s2$[ebp], edx

; 410  : 
; 411  : 		// strings are equal until end point
; 412  : 		if( !n-- ) return 0;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	jne	SHORT $LN10@Q_strncmp
	xor	eax, eax
	jmp	SHORT $LN1@Q_strncmp
$LN10@Q_strncmp:

; 413  : 		if( c1 != c2 ) return c1 < c2 ? -1 : 1;

	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strncmp
	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	jge	SHORT $LN13@Q_strncmp
	mov	DWORD PTR tv76[ebp], -1
	jmp	SHORT $LN14@Q_strncmp
$LN13@Q_strncmp:
	mov	DWORD PTR tv76[ebp], 1
$LN14@Q_strncmp:
	mov	eax, DWORD PTR tv76[ebp]
	jmp	SHORT $LN1@Q_strncmp
$LN2@Q_strncmp:

; 414  : 
; 415  : 	} while( c1 );

	cmp	DWORD PTR _c1$[ebp], 0
	jne	SHORT $LN4@Q_strncmp

; 416  : 	
; 417  : 	// strings are equal
; 418  : 	return 0;

	xor	eax, eax
$LN1@Q_strncmp:

; 419  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strncmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strnicmp
_TEXT	SEGMENT
tv83 = -76						; size = 4
tv73 = -76						; size = 4
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
_Q_strnicmp PROC					; COMDAT

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 361  : 	int	c1, c2;
; 362  : 
; 363  : 	if( s1 == NULL )

	cmp	DWORD PTR _s1$[ebp], 0
	jne	SHORT $LN5@Q_strnicmp

; 364  : 	{
; 365  : 		if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN7@Q_strnicmp

; 366  : 			return 0;

	xor	eax, eax
	jmp	$LN1@Q_strnicmp
	jmp	SHORT $LN8@Q_strnicmp
$LN7@Q_strnicmp:

; 367  : 		else return -1;

	or	eax, -1
	jmp	$LN1@Q_strnicmp
$LN8@Q_strnicmp:

; 368  : 	}

	jmp	SHORT $LN4@Q_strnicmp
$LN5@Q_strnicmp:

; 369  : 	else if( s2 == NULL )

	cmp	DWORD PTR _s2$[ebp], 0
	jne	SHORT $LN4@Q_strnicmp

; 370  : 	{
; 371  : 		return 1;

	mov	eax, 1
	jmp	$LN1@Q_strnicmp
$LN4@Q_strnicmp:

; 372  :           }
; 373  : 
; 374  : 	do {
; 375  : 		c1 = *s1++;

	mov	eax, DWORD PTR _s1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c1$[ebp], ecx
	mov	edx, DWORD PTR _s1$[ebp]
	add	edx, 1
	mov	DWORD PTR _s1$[ebp], edx

; 376  : 		c2 = *s2++;

	mov	eax, DWORD PTR _s2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c2$[ebp], ecx
	mov	edx, DWORD PTR _s2$[ebp]
	add	edx, 1
	mov	DWORD PTR _s2$[ebp], edx

; 377  : 
; 378  : 		if( !n-- ) return 0; // strings are equal until end point

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 0
	jne	SHORT $LN10@Q_strnicmp
	xor	eax, eax
	jmp	SHORT $LN1@Q_strnicmp
$LN10@Q_strnicmp:

; 379  : 		
; 380  : 		if( c1 != c2 )

	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strnicmp

; 381  : 		{
; 382  : 			if( c1 >= 'a' && c1 <= 'z' ) c1 -= ('a' - 'A');

	cmp	DWORD PTR _c1$[ebp], 97			; 00000061H
	jl	SHORT $LN12@Q_strnicmp
	cmp	DWORD PTR _c1$[ebp], 122		; 0000007aH
	jg	SHORT $LN12@Q_strnicmp
	mov	eax, DWORD PTR _c1$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _c1$[ebp], eax
$LN12@Q_strnicmp:

; 383  : 			if( c2 >= 'a' && c2 <= 'z' ) c2 -= ('a' - 'A');

	cmp	DWORD PTR _c2$[ebp], 97			; 00000061H
	jl	SHORT $LN13@Q_strnicmp
	cmp	DWORD PTR _c2$[ebp], 122		; 0000007aH
	jg	SHORT $LN13@Q_strnicmp
	mov	eax, DWORD PTR _c2$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR _c2$[ebp], eax
$LN13@Q_strnicmp:

; 384  : 			if( c1 != c2 ) return c1 < c2 ? -1 : 1;

	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	je	SHORT $LN2@Q_strnicmp
	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	jge	SHORT $LN16@Q_strnicmp
	mov	DWORD PTR tv83[ebp], -1
	jmp	SHORT $LN17@Q_strnicmp
$LN16@Q_strnicmp:
	mov	DWORD PTR tv83[ebp], 1
$LN17@Q_strnicmp:
	mov	eax, DWORD PTR tv83[ebp]
	jmp	SHORT $LN1@Q_strnicmp
$LN2@Q_strnicmp:

; 385  : 		}
; 386  : 	} while( c1 );

	cmp	DWORD PTR _c1$[ebp], 0
	jne	$LN4@Q_strnicmp

; 387  : 
; 388  : 	// strings are equal
; 389  : 	return 0;

	xor	eax, eax
$LN1@Q_strnicmp:

; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strnicmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strrchr
_TEXT	SEGMENT
tv69 = -72						; size = 4
_len$ = -4						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 1
_Q_strrchr PROC						; COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 347  : 	int	len = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 348  : 
; 349  : 	s += len;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _s$[ebp], eax
$LN2@Q_strrchr:

; 350  : 
; 351  : 	while( len-- )

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@Q_strrchr

; 352  : 	{
; 353  : 		if( *--s == c )

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Q_strrchr

; 354  : 			return (char *)s;

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@Q_strrchr
$LN4@Q_strrchr:

; 355  : 	}

	jmp	SHORT $LN2@Q_strrchr
$LN3@Q_strrchr:

; 356  : 	return 0;

	xor	eax, eax
$LN1@Q_strrchr:

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strrchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strchr
_TEXT	SEGMENT
tv68 = -72						; size = 4
_len$ = -4						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 1
_Q_strchr PROC						; COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 335  : 	int	len = Q_strlen( s );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax
$LN2@Q_strchr:

; 336  : 
; 337  : 	while( len-- )

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _len$[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN3@Q_strchr

; 338  : 	{
; 339  : 		if( *++s == c )

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@Q_strchr

; 340  : 			return (char *)s;

	mov	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN1@Q_strchr
$LN4@Q_strchr:

; 341  : 	}

	jmp	SHORT $LN2@Q_strchr
$LN3@Q_strchr:

; 342  : 	return 0;

	xor	eax, eax
$LN1@Q_strchr:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_atov
_TEXT	SEGMENT
_j$ = -272						; size = 4
_pfront$ = -268						; size = 4
_pstr$ = -264						; size = 4
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_vec$ = 8						; size = 4
_str$ = 12						; size = 4
_siz$ = 16						; size = 4
_Q_atov	PROC						; COMDAT

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 311  : 	string	buffer;
; 312  : 	char	*pstr, *pfront;
; 313  : 	int	j;
; 314  : 
; 315  : 	Q_strncpy( buffer, str, sizeof( buffer ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 316  : 	memset( vec, 0, sizeof( vec_t ) * siz );

	mov	eax, DWORD PTR _siz$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 317  : 	pstr = pfront = buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pfront$[ebp], eax
	mov	ecx, DWORD PTR _pfront$[ebp]
	mov	DWORD PTR _pstr$[ebp], ecx

; 318  : 
; 319  : 	for( j = 0; j < siz; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@Q_atov
$LN2@Q_atov:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@Q_atov:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _siz$[ebp]
	jae	SHORT $LN3@Q_atov

; 320  : 	{
; 321  : 		vec[j] = Q_atof( pfront );

	mov	eax, DWORD PTR _pfront$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fstp	DWORD PTR [edx+ecx*4]
$LN5@Q_atov:

; 322  : 
; 323  : 		// valid separator is space
; 324  : 		while( *pstr && *pstr != ' ' )

	mov	eax, DWORD PTR _pstr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@Q_atov
	mov	eax, DWORD PTR _pstr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN6@Q_atov

; 325  : 			pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax
	jmp	SHORT $LN5@Q_atov
$LN6@Q_atov:

; 326  : 
; 327  : 		if( !*pstr ) break;

	mov	eax, DWORD PTR _pstr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Q_atov
	jmp	SHORT $LN3@Q_atov
$LN7@Q_atov:

; 328  : 		pstr++;

	mov	eax, DWORD PTR _pstr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pstr$[ebp], eax

; 329  : 		pfront = pstr;

	mov	eax, DWORD PTR _pstr$[ebp]
	mov	DWORD PTR _pfront$[ebp], eax

; 330  : 	}

	jmp	$LN2@Q_atov
$LN3@Q_atov:

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_atov	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_atof
_TEXT	SEGMENT
tv210 = -96						; size = 4
tv228 = -92						; size = 4
tv221 = -92						; size = 4
tv209 = -92						; size = 4
tv201 = -92						; size = 4
_total$ = -24						; size = 4
_decimal$ = -20						; size = 4
_sign$ = -16						; size = 4
_c$ = -12						; size = 4
_val$ = -8						; size = 8
_str$ = 8						; size = 4
_Q_atof	PROC						; COMDAT

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 243  : 	double	val = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _val$[ebp], xmm0

; 244  : 	int	c, sign, decimal, total;
; 245  : 
; 246  : 	if( !str ) return 0.0f;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN10@Q_atof
	fldz
	jmp	$LN1@Q_atof
$LN10@Q_atof:

; 247  : 
; 248  : 	// check for empty charachters in string
; 249  : 	while( str && *str == ' ' )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@Q_atof
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@Q_atof

; 250  : 		str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	jmp	SHORT $LN10@Q_atof
$LN3@Q_atof:

; 251  : 
; 252  : 	if( !str ) return 0.0f;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN11@Q_atof
	fldz
	jmp	$LN1@Q_atof
$LN11@Q_atof:

; 253  : 	
; 254  : 	if( *str == '-' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN12@Q_atof

; 255  : 	{
; 256  : 		sign = -1;

	mov	DWORD PTR _sign$[ebp], -1

; 257  : 		str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 258  : 	}

	jmp	SHORT $LN13@Q_atof
$LN12@Q_atof:

; 259  : 	else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN13@Q_atof:

; 260  : 		
; 261  : 	// check for hex
; 262  : 	if( str[0] == '0' && ( str[1] == 'x' || str[1] == 'X' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jne	$LN5@Q_atof
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	je	SHORT $LN15@Q_atof
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 88					; 00000058H
	jne	$LN5@Q_atof
$LN15@Q_atof:

; 263  : 	{
; 264  : 		str += 2;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 2
	mov	DWORD PTR _str$[ebp], eax
$LN4@Q_atof:

; 265  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@Q_atof

; 266  : 		{
; 267  : 			c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 268  : 			if( c >= '0' && c <= '9' ) val = (val * 16) + c - '0';

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN16@Q_atof
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN16@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4048000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	$LN21@Q_atof
$LN16@Q_atof:

; 269  : 			else if( c >= 'a' && c <= 'f' ) val = (val * 16) + c - 'a' + 10;

	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN18@Q_atof
	cmp	DWORD PTR _c$[ebp], 102			; 00000066H
	jg	SHORT $LN18@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4058400000000000
	addsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	SHORT $LN21@Q_atof
$LN18@Q_atof:

; 270  : 			else if( c >= 'A' && c <= 'F' ) val = (val * 16) + c - 'A' + 10;

	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN20@Q_atof
	cmp	DWORD PTR _c$[ebp], 70			; 00000046H
	jg	SHORT $LN20@Q_atof
	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4030000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4050400000000000
	addsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0
	jmp	SHORT $LN21@Q_atof
$LN20@Q_atof:

; 271  : 			else return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv201[ebp], xmm0
	fld	DWORD PTR tv201[ebp]
	jmp	$LN1@Q_atof
$LN21@Q_atof:

; 272  : 		}

	jmp	$LN4@Q_atof
$LN5@Q_atof:

; 273  : 	}
; 274  : 	
; 275  : 	// check for character
; 276  : 	if( str[0] == '\'' ) return sign * str[1];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN22@Q_atof
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	imul	edx, DWORD PTR _sign$[ebp]
	mov	DWORD PTR tv209[ebp], edx
	fild	DWORD PTR tv209[ebp]
	fstp	DWORD PTR tv210[ebp]
	fld	DWORD PTR tv210[ebp]
	jmp	$LN1@Q_atof
$LN22@Q_atof:

; 277  : 	
; 278  : 	// assume decimal
; 279  : 	decimal = -1;

	mov	DWORD PTR _decimal$[ebp], -1

; 280  : 	total = 0;

	mov	DWORD PTR _total$[ebp], 0
$LN28@Q_atof:

; 281  : 
; 282  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@Q_atof

; 283  : 	{
; 284  : 		c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 285  : 		if( c == '.' )

	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	jne	SHORT $LN23@Q_atof

; 286  : 		{
; 287  : 			decimal = total;

	mov	eax, DWORD PTR _total$[ebp]
	mov	DWORD PTR _decimal$[ebp], eax

; 288  : 			continue;

	jmp	SHORT $LN28@Q_atof
$LN23@Q_atof:

; 289  : 		}
; 290  : 
; 291  : 		if( c < '0' || c > '9' )

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN25@Q_atof
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	SHORT $LN24@Q_atof
$LN25@Q_atof:

; 292  : 			break;

	jmp	SHORT $LN7@Q_atof
$LN24@Q_atof:

; 293  : 		val = val * 10 + c - '0';

	movsd	xmm0, QWORD PTR _val$[ebp]
	mulsd	xmm0, QWORD PTR __real@4024000000000000
	cvtsi2sd xmm1, DWORD PTR _c$[ebp]
	addsd	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@4048000000000000
	movsd	QWORD PTR _val$[ebp], xmm0

; 294  : 		total++;

	mov	eax, DWORD PTR _total$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax

; 295  : 	}

	jmp	SHORT $LN28@Q_atof
$LN7@Q_atof:

; 296  : 
; 297  : 	if( decimal == -1 )

	cmp	DWORD PTR _decimal$[ebp], -1
	jne	SHORT $LN26@Q_atof

; 298  : 		return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv221[ebp], xmm0
	fld	DWORD PTR tv221[ebp]
	jmp	SHORT $LN1@Q_atof
$LN26@Q_atof:

; 299  : 
; 300  : 	while( total > decimal )

	mov	eax, DWORD PTR _total$[ebp]
	cmp	eax, DWORD PTR _decimal$[ebp]
	jle	SHORT $LN9@Q_atof

; 301  : 	{
; 302  : 		val /= 10;

	movsd	xmm0, QWORD PTR _val$[ebp]
	divsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _val$[ebp], xmm0

; 303  : 		total--;

	mov	eax, DWORD PTR _total$[ebp]
	sub	eax, 1
	mov	DWORD PTR _total$[ebp], eax

; 304  : 	}

	jmp	SHORT $LN26@Q_atof
$LN9@Q_atof:

; 305  : 	
; 306  : 	return val * sign;

	cvtsi2sd xmm0, DWORD PTR _sign$[ebp]
	mulsd	xmm0, QWORD PTR _val$[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv228[ebp], xmm0
	fld	DWORD PTR tv228[ebp]
$LN1@Q_atof:

; 307  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_atof	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_atoi
_TEXT	SEGMENT
_sign$ = -12						; size = 4
_c$ = -8						; size = 4
_val$ = -4						; size = 4
_str$ = 8						; size = 4
_Q_atoi	PROC						; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 194  : 	int       val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 195  : 	int	c, sign;
; 196  : 
; 197  : 	if( !str ) return 0;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN2@Q_atoi
	xor	eax, eax
	jmp	$LN1@Q_atoi
$LN2@Q_atoi:

; 198  : 
; 199  : 	// check for empty charachters in string
; 200  : 	while( str && *str == ' ' )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN3@Q_atoi
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN3@Q_atoi

; 201  : 		str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	jmp	SHORT $LN2@Q_atoi
$LN3@Q_atoi:

; 202  : 
; 203  : 	if( !str ) return 0;

	cmp	DWORD PTR _str$[ebp], 0
	jne	SHORT $LN9@Q_atoi
	xor	eax, eax
	jmp	$LN1@Q_atoi
$LN9@Q_atoi:

; 204  : 	
; 205  : 	if( *str == '-' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN10@Q_atoi

; 206  : 	{
; 207  : 		sign = -1;

	mov	DWORD PTR _sign$[ebp], -1

; 208  : 		str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 209  : 	}

	jmp	SHORT $LN11@Q_atoi
$LN10@Q_atoi:

; 210  : 	else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN11@Q_atoi:

; 211  : 		
; 212  : 	// check for hex
; 213  : 	if( str[0] == '0' && ( str[1] == 'x' || str[1] == 'X' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jne	$LN12@Q_atoi
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	je	SHORT $LN13@Q_atoi
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 88					; 00000058H
	jne	$LN12@Q_atoi
$LN13@Q_atoi:

; 214  : 	{
; 215  : 		str += 2;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 2
	mov	DWORD PTR _str$[ebp], eax
$LN4@Q_atoi:

; 216  : 		while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN12@Q_atoi

; 217  : 		{
; 218  : 			c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 219  : 			if( c >= '0' && c <= '9' ) val = (val<<4) + c - '0';

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN14@Q_atoi
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jg	SHORT $LN14@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN14@Q_atoi:

; 220  : 			else if( c >= 'a' && c <= 'f' ) val = (val<<4) + c - 'a' + 10;

	cmp	DWORD PTR _c$[ebp], 97			; 00000061H
	jl	SHORT $LN16@Q_atoi
	cmp	DWORD PTR _c$[ebp], 102			; 00000066H
	jg	SHORT $LN16@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-87]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN16@Q_atoi:

; 221  : 			else if( c >= 'A' && c <= 'F' ) val = (val<<4) + c - 'A' + 10;

	cmp	DWORD PTR _c$[ebp], 65			; 00000041H
	jl	SHORT $LN18@Q_atoi
	cmp	DWORD PTR _c$[ebp], 70			; 00000046H
	jg	SHORT $LN18@Q_atoi
	mov	eax, DWORD PTR _val$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-55]
	mov	DWORD PTR _val$[ebp], edx
	jmp	SHORT $LN15@Q_atoi
$LN18@Q_atoi:

; 222  : 			else return val * sign;

	mov	eax, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN15@Q_atoi:

; 223  : 		}

	jmp	SHORT $LN4@Q_atoi
$LN12@Q_atoi:

; 224  : 	}
; 225  : 	
; 226  : 	// check for character
; 227  : 	if( str[0] == '\'' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN6@Q_atoi

; 228  : 		return sign * str[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	eax, edx
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN6@Q_atoi:

; 229  : 	
; 230  : 	// assume decimal
; 231  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@Q_atoi

; 232  : 	{
; 233  : 		c = *str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	mov	DWORD PTR _str$[ebp], edx

; 234  : 		if( c < '0' || c > '9' )

	cmp	DWORD PTR _c$[ebp], 48			; 00000030H
	jl	SHORT $LN22@Q_atoi
	cmp	DWORD PTR _c$[ebp], 57			; 00000039H
	jle	SHORT $LN21@Q_atoi
$LN22@Q_atoi:

; 235  : 			return val * sign;

	mov	eax, DWORD PTR _val$[ebp]
	imul	eax, DWORD PTR _sign$[ebp]
	jmp	SHORT $LN1@Q_atoi
$LN21@Q_atoi:

; 236  : 		val = val * 10 + c - '0';

	imul	eax, DWORD PTR _val$[ebp], 10
	mov	ecx, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _val$[ebp], edx

; 237  : 	}

	jmp	SHORT $LN6@Q_atoi
$LN7@Q_atoi:

; 238  : 	return 0;

	xor	eax, eax
$LN1@Q_atoi:

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_atoi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_isdigit
_TEXT	SEGMENT
_str$ = 8						; size = 4
_Q_isdigit PROC						; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 49   : 	if( str && *str )

	cmp	DWORD PTR _str$[ebp], 0
	je	SHORT $LN4@Q_isdigit
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Q_isdigit
$LN2@Q_isdigit:

; 50   : 	{
; 51   : 		while( isdigit( *str )) str++;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Q_isdigit
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	jmp	SHORT $LN2@Q_isdigit
$LN3@Q_isdigit:

; 52   : 		if( !*str ) return true;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@Q_isdigit
	mov	eax, 1
	jmp	SHORT $LN1@Q_isdigit
$LN4@Q_isdigit:

; 53   : 	}
; 54   : 	return false;

	xor	eax, eax
$LN1@Q_isdigit:

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_isdigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_hashkey
_TEXT	SEGMENT
_hashKey$ = -8						; size = 4
_i$ = -4						; size = 4
_string$ = 8						; size = 4
_hashSize$ = 12						; size = 4
_caseinsensitive$ = 16					; size = 4
_Q_hashkey PROC						; COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 610  : 	uint	i, hashKey = 0;

	mov	DWORD PTR _hashKey$[ebp], 0

; 611  : 
; 612  : 	if( caseinsensitive )

	cmp	DWORD PTR _caseinsensitive$[ebp], 0
	je	SHORT $LN8@Q_hashkey

; 613  : 	{
; 614  : 		for( i = 0; string[i]; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Q_hashkey
$LN2@Q_hashkey:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Q_hashkey:
	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_hashkey

; 615  : 			hashKey += (i * 119) * Q_tolower( string[i] );

	imul	esi, DWORD PTR _i$[ebp], 119
	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	imul	esi, edx
	add	esi, DWORD PTR _hashKey$[ebp]
	mov	DWORD PTR _hashKey$[ebp], esi
	jmp	SHORT $LN2@Q_hashkey
$LN3@Q_hashkey:

; 616  : 	}

	jmp	SHORT $LN9@Q_hashkey
$LN8@Q_hashkey:

; 617  : 	else
; 618  : 	{
; 619  : 		for( i = 0; string[i]; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Q_hashkey
$LN5@Q_hashkey:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Q_hashkey:
	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@Q_hashkey

; 620  : 			hashKey += (i + 119) * (int)string[i];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 119				; 00000077H
	mov	ecx, DWORD PTR _string$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movsx	edx, BYTE PTR [ecx]
	imul	eax, edx
	add	eax, DWORD PTR _hashKey$[ebp]
	mov	DWORD PTR _hashKey$[ebp], eax
	jmp	SHORT $LN5@Q_hashkey
$LN9@Q_hashkey:

; 621  : 	}
; 622  : 
; 623  : 	hashKey = ((hashKey ^ (hashKey >> 10)) ^ (hashKey >> 20)) & (hashSize - 1);

	mov	eax, DWORD PTR _hashKey$[ebp]
	shr	eax, 10					; 0000000aH
	xor	eax, DWORD PTR _hashKey$[ebp]
	mov	ecx, DWORD PTR _hashKey$[ebp]
	shr	ecx, 20					; 00000014H
	xor	eax, ecx
	mov	edx, DWORD PTR _hashSize$[ebp]
	sub	edx, 1
	and	eax, edx
	mov	DWORD PTR _hashKey$[ebp], eax

; 624  : 
; 625  : 	return hashKey;

	mov	eax, DWORD PTR _hashKey$[ebp]

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_hashkey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT __copystring
_TEXT	SEGMENT
_b$ = -4						; size = 4
_mempool$ = 8						; size = 4
_s$ = 12						; size = 4
_filename$ = 16						; size = 4
_fileline$ = 20						; size = 4
__copystring PROC					; COMDAT

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 181  : 	char	*b;
; 182  : 
; 183  : 	if( !s ) return NULL;

	cmp	DWORD PTR _s$[ebp], 0
	jne	SHORT $LN2@copystring
	xor	eax, eax
	jmp	SHORT $LN1@copystring
$LN2@copystring:

; 184  : 	if( !mempool ) mempool = host.mempool;

	cmp	DWORD PTR _mempool$[ebp], 0
	jne	SHORT $LN3@copystring
	mov	eax, DWORD PTR _host+236
	mov	DWORD PTR _mempool$[ebp], eax
$LN3@copystring:

; 185  : 
; 186  : 	b = _Mem_Alloc( mempool, Q_strlen( s ) + 1, false, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	mov	eax, DWORD PTR _mempool$[ebp]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _b$[ebp], eax

; 187  : 	Q_strcpy( b, s );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 188  : 
; 189  : 	return b;

	mov	eax, DWORD PTR _b$[ebp]
$LN1@copystring:

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__copystring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strncpy
_TEXT	SEGMENT
tv82 = -80						; size = 4
tv74 = -80						; size = 4
_n$ = -12						; size = 4
_s$ = -8						; size = 4
_d$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_Q_strncpy PROC						; COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 152  : 	register char	*d = dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 153  : 	register const char	*s = src;

	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 154  : 	register size_t	n = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 155  : 
; 156  : 	if( !dst || !src || !size )

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN8@Q_strncpy
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN8@Q_strncpy
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN7@Q_strncpy
$LN8@Q_strncpy:

; 157  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@Q_strncpy
$LN7@Q_strncpy:

; 158  : 
; 159  : 	// copy as many bytes as will fit
; 160  : 	if( n != 0 && --n != 0 )

	cmp	DWORD PTR _n$[ebp], 0
	je	SHORT $LN9@Q_strncpy
	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	je	SHORT $LN9@Q_strncpy
$LN4@Q_strncpy:

; 161  : 	{
; 162  : 		do
; 163  : 		{
; 164  : 			if(( *d++ = *s++ ) == 0 )

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _d$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR _d$[ebp]
	add	edx, 1
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
	cmp	DWORD PTR tv74[ebp], 0
	jne	SHORT $LN2@Q_strncpy

; 165  : 				break;

	jmp	SHORT $LN9@Q_strncpy
$LN2@Q_strncpy:

; 166  : 		} while( --n != 0 );

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
	jne	SHORT $LN4@Q_strncpy
$LN9@Q_strncpy:

; 167  : 	}
; 168  : 
; 169  : 	// not enough room in dst, add NULL and traverse rest of src
; 170  : 	if( n == 0 )

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN11@Q_strncpy

; 171  : 	{
; 172  : 		if( size != 0 )

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN5@Q_strncpy

; 173  : 			*d = '\0'; // NULL-terminate dst

	mov	eax, DWORD PTR _d$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@Q_strncpy:

; 174  : 		while( *s++ );

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv82[ebp], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN11@Q_strncpy
	jmp	SHORT $LN5@Q_strncpy
$LN11@Q_strncpy:

; 175  : 	}
; 176  : 	return ( s - src - 1 ); // count does not include NULL

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _src$[ebp]
	sub	eax, 1
$LN1@Q_strncpy:

; 177  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strncat
_TEXT	SEGMENT
tv69 = -84						; size = 4
_dlen$ = -16						; size = 4
_n$ = -12						; size = 4
_s$ = -8						; size = 4
_d$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_Q_strncat PROC						; COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 121  : 	register char	*d = dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 122  : 	register const char	*s = src;

	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR _s$[ebp], eax

; 123  : 	register size_t	n = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 124  : 	size_t		dlen;
; 125  : 
; 126  : 	if( !dst || !src || !size )

	cmp	DWORD PTR _dst$[ebp], 0
	je	SHORT $LN7@Q_strncat
	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $LN7@Q_strncat
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN2@Q_strncat
$LN7@Q_strncat:

; 127  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Q_strncat
$LN2@Q_strncat:

; 128  : 
; 129  : 	// find the end of dst and adjust bytes left but don't go past end
; 130  : 	while( n-- != 0 && *d != '\0' ) d++;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN3@Q_strncat
	mov	eax, DWORD PTR _d$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strncat
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1
	mov	DWORD PTR _d$[ebp], eax
	jmp	SHORT $LN2@Q_strncat
$LN3@Q_strncat:

; 131  : 	dlen = d - dst;

	mov	eax, DWORD PTR _d$[ebp]
	sub	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dlen$[ebp], eax

; 132  : 	n = size - dlen;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _dlen$[ebp]
	mov	DWORD PTR _n$[ebp], eax

; 133  : 
; 134  : 	if( n == 0 ) return( dlen + Q_strlen( s ));

	jne	SHORT $LN4@Q_strncat
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, DWORD PTR _dlen$[ebp]
	jmp	SHORT $LN1@Q_strncat
$LN4@Q_strncat:

; 135  : 
; 136  : 	while( *s != '\0' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@Q_strncat

; 137  : 	{
; 138  : 		if( n != 1 )

	cmp	DWORD PTR _n$[ebp], 1
	je	SHORT $LN9@Q_strncat

; 139  : 		{
; 140  : 			*d++ = *s;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, 1
	mov	DWORD PTR _d$[ebp], eax

; 141  : 			n--;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN9@Q_strncat:

; 142  : 		}
; 143  : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 144  : 	}

	jmp	SHORT $LN4@Q_strncat
$LN5@Q_strncat:

; 145  : 
; 146  : 	*d = '\0';

	mov	eax, DWORD PTR _d$[ebp]
	mov	BYTE PTR [eax], 0

; 147  : 	return( dlen + ( s - src )); // count does not include NULL

	mov	eax, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR _src$[ebp]
	add	eax, DWORD PTR _dlen$[ebp]
$LN1@Q_strncat:

; 148  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strncat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_tolower
_TEXT	SEGMENT
_out$ = -1						; size = 1
_in$ = 8						; size = 1
_Q_tolower PROC						; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 110  : 	char	out;
; 111  : 
; 112  : 	if( in >= 'A' && in <= 'Z' )

	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN2@Q_tolower
	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN2@Q_tolower

; 113  : 		out = in + 'a' - 'A';

	movsx	eax, BYTE PTR _in$[ebp]
	add	eax, 32					; 00000020H
	mov	BYTE PTR _out$[ebp], al
	jmp	SHORT $LN3@Q_tolower
$LN2@Q_tolower:

; 114  : 	else out = in;

	mov	al, BYTE PTR _in$[ebp]
	mov	BYTE PTR _out$[ebp], al
$LN3@Q_tolower:

; 115  : 
; 116  : 	return out;

	movzx	eax, BYTE PTR _out$[ebp]

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_tolower ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_toupper
_TEXT	SEGMENT
_out$ = -1						; size = 1
_in$ = 8						; size = 1
_Q_toupper PROC						; COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 99   : 	char	out;
; 100  : 
; 101  : 	if( in >= 'a' && in <= 'z' )

	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN2@Q_toupper
	movsx	eax, BYTE PTR _in$[ebp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN2@Q_toupper

; 102  : 		out = in + 'A' - 'a';

	movsx	eax, BYTE PTR _in$[ebp]
	sub	eax, 32					; 00000020H
	mov	BYTE PTR _out$[ebp], al
	jmp	SHORT $LN3@Q_toupper
$LN2@Q_toupper:

; 103  : 	else out = in;

	mov	al, BYTE PTR _in$[ebp]
	mov	BYTE PTR _out$[ebp], al
$LN3@Q_toupper:

; 104  : 
; 105  : 	return out;

	movzx	eax, BYTE PTR _out$[ebp]

; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_toupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_colorstr
_TEXT	SEGMENT
_p$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_Q_colorstr PROC					; COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 76   : 	int		len;
; 77   : 	const char	*p;
; 78   : 
; 79   : 	if( !string ) return 0;

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@Q_colorstr
	xor	eax, eax
	jmp	SHORT $LN1@Q_colorstr
$LN4@Q_colorstr:

; 80   : 
; 81   : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 82   : 	p = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@Q_colorstr:

; 83   : 	while( *p )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_colorstr

; 84   : 	{
; 85   : 		if( IsColorString( p ))

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN5@Q_colorstr
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 94					; 0000005eH
	jne	SHORT $LN5@Q_colorstr
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN5@Q_colorstr
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN5@Q_colorstr
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN5@Q_colorstr

; 86   : 		{
; 87   : 			len += 2;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 2
	mov	DWORD PTR _len$[ebp], eax

; 88   : 			p += 2;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 89   : 			continue;

	jmp	SHORT $LN2@Q_colorstr
$LN5@Q_colorstr:

; 90   : 		}
; 91   : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 92   : 	}

	jmp	SHORT $LN2@Q_colorstr
$LN3@Q_colorstr:

; 93   : 
; 94   : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@Q_colorstr:

; 95   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_colorstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strlen
_TEXT	SEGMENT
_p$ = -8						; size = 4
_len$ = -4						; size = 4
_string$ = 8						; size = 4
_Q_strlen PROC						; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 59   : 	int		len;
; 60   : 	const char	*p;
; 61   : 
; 62   : 	if( !string ) return 0;

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN4@Q_strlen
	xor	eax, eax
	jmp	SHORT $LN1@Q_strlen
$LN4@Q_strlen:

; 63   : 
; 64   : 	len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 65   : 	p = string;

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@Q_strlen:

; 66   : 	while( *p )

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strlen

; 67   : 	{
; 68   : 		p++;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 69   : 		len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 70   : 	}

	jmp	SHORT $LN2@Q_strlen
$LN3@Q_strlen:

; 71   : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@Q_strlen:

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strnlwr
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size_out$ = 16						; size = 4
_Q_strnlwr PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	if( size_out == 0 ) return;

	cmp	DWORD PTR _size_out$[ebp], 0
	jne	SHORT $LN2@Q_strnlwr
	jmp	SHORT $LN1@Q_strnlwr
$LN2@Q_strnlwr:

; 36   : 
; 37   : 	while( *in && size_out > 1 )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strnlwr
	cmp	DWORD PTR _size_out$[ebp], 1
	jbe	SHORT $LN3@Q_strnlwr

; 38   : 	{
; 39   : 		if( *in >= 'A' && *in <= 'Z' )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN5@Q_strnlwr
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $LN5@Q_strnlwr

; 40   : 			*out++ = *in++ + 'a' - 'A';

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN6@Q_strnlwr
$LN5@Q_strnlwr:

; 41   : 		else *out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
$LN6@Q_strnlwr:

; 42   : 		size_out--;

	mov	eax, DWORD PTR _size_out$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size_out$[ebp], eax

; 43   : 	}

	jmp	SHORT $LN2@Q_strnlwr
$LN3@Q_strnlwr:

; 44   : 	*out = '\0';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Q_strnlwr:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strnlwr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\crtlib.c
;	COMDAT _Q_strnupr
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_size_out$ = 16						; size = 4
_Q_strnupr PROC						; COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 21   : 	if( size_out == 0 ) return;

	cmp	DWORD PTR _size_out$[ebp], 0
	jne	SHORT $LN2@Q_strnupr
	jmp	SHORT $LN1@Q_strnupr
$LN2@Q_strnupr:

; 22   : 
; 23   : 	while( *in && size_out > 1 )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Q_strnupr
	cmp	DWORD PTR _size_out$[ebp], 1
	jbe	SHORT $LN3@Q_strnupr

; 24   : 	{
; 25   : 		if( *in >= 'a' && *in <= 'z' )

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN5@Q_strnupr
	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jg	SHORT $LN5@Q_strnupr

; 26   : 			*out++ = *in++ + 'A' - 'a';

	mov	eax, DWORD PTR _in$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
	jmp	SHORT $LN6@Q_strnupr
$LN5@Q_strnupr:

; 27   : 		else *out++ = *in++;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx
$LN6@Q_strnupr:

; 28   : 		size_out--;

	mov	eax, DWORD PTR _size_out$[ebp]
	sub	eax, 1
	mov	DWORD PTR _size_out$[ebp], eax

; 29   : 	}

	jmp	SHORT $LN2@Q_strnupr
$LN3@Q_strnupr:

; 30   : 	*out = '\0';

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Q_strnupr:

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Q_strnupr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 551  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4

; 553  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 528  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  :             return _localtime64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___localtime64
	add	esp, 4

; 530  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1411 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __BufferCount$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1413 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1391 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1392 :         int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1397 :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
