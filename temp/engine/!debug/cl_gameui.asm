; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_gameui.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_pfnPIC_Set
PUBLIC	_pfnPIC_Draw
PUBLIC	_pfnPIC_DrawTrans
PUBLIC	_pfnPIC_DrawHoles
PUBLIC	_pfnPIC_DrawAdditive
PUBLIC	_pfnCheckGameDll
EXTRN	_Sys_ShellExecute:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Args:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddGameUICommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableValue:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_COM_FreeFile:PROC
EXTRN	_COM_CompareFileTime:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_Host_WriteServerConfig:PROC
EXTRN	_Host_Error:PROC
EXTRN	_CL_Active:PROC
EXTRN	_pfnCvar_RegisterGameUIVariable:PROC
EXTRN	_COM_SaveFile:PROC
EXTRN	_COM_LoadFileForMe:PROC
EXTRN	_pfnGetGameDir:PROC
EXTRN	_pfnIsMapValid:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_Key_IsDown:PROC
EXTRN	_Key_GetBinding:PROC
EXTRN	_Key_SetBinding:PROC
EXTRN	_Key_ClearStates:PROC
EXTRN	_Key_KeynumToString:PROC
EXTRN	_Key_SetKeyDest:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_CL_GetDemoComment:PROC
EXTRN	_SV_GetSaveComment:PROC
EXTRN	_UI_NPrintf:PROC
EXTRN	_UI_NXPrintf:PROC
EXTRN	_Cmd_CheckMapsList:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_COM_RandomFloat:PROC
EXTRN	_GL_FreeImage:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DefaultColor:PROC
EXTRN	_GL_ProcessTexture:PROC
EXTRN	_VID_GetModeString:PROC
EXTRN	_IN_SetCursor:PROC
_DATA	SEGMENT
COMM	_gameui:BYTE:01b9cH
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_Host_Credits
PUBLIC	_UI_CreditsActive
PUBLIC	_UI_SetActiveMenu
PUBLIC	_UI_UnloadProgs
PUBLIC	_UI_LoadProgs
PUBLIC	_UI_UpdateMenu
PUBLIC	_UI_KeyEvent
PUBLIC	_UI_MouseMove
PUBLIC	_UI_AddServerToList
PUBLIC	_UI_GetCursorPos
PUBLIC	_UI_SetCursorPos
PUBLIC	_UI_ShowCursor
PUBLIC	_UI_CharEvent
PUBLIC	_UI_MouseInRect
PUBLIC	_UI_IsVisible
PUBLIC	_pfnPIC_DrawAdditiveAlt
PUBLIC	??_C@_08BKEEFKLC@media?1?$CFs@			; `string'
PUBLIC	??_C@_04CAPFMNON@?4avi@				; `string'
PUBLIC	??_C@_0DO@PHIAIOED@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?5fro@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name@				; `string'
PUBLIC	??_C@_05NCCFOPHA@model@				; `string'
PUBLIC	??_C@_08OLGKFJAO@topcolor@			; `string'
PUBLIC	??_C@_0M@IIFIMDEK@bottomcolor@			; `string'
PUBLIC	??_C@_02BEIEFPIG@?$CFg@				; `string'
PUBLIC	??_C@_0CE@GIBAHPJD@?$FO1Error?3?$FO7?5CL_LoadImage?3?5bad?5na@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0M@LNGHCJI@connect?5?$CFs?6@		; `string'
PUBLIC	?__LINE__Var@?0??pfnGetFilesList@@9@9		; `pfnGetFilesList'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?__LINE__Var@?0??UI_UnloadProgs@@9@9		; `UI_UnloadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0BC@CFEOCCMF@host_gameuiloaded@		; `string'
PUBLIC	?__LINE__Var@?0??UI_LoadProgs@@9@9		; `UI_LoadProgs'::`1'::__LINE__Var
PUBLIC	??_C@_0M@CKFPHNOP@?$CFs?1menu?4dll@		; `string'
PUBLIC	??_C@_08OOIHGPGJ@menu?4dll@			; `string'
PUBLIC	??_C@_0L@PHPPEPNN@GetMenuAPI@			; `string'
PUBLIC	??_C@_0CD@GPJEPCGB@UI_LoadProgs?3?5can?8t?5init?5menu?5A@ ; `string'
PUBLIC	??_C@_09MMMNBHGJ@Menu?5Pool@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	__real@3b000000
PUBLIC	__real@3d700000
PUBLIC	__real@3d800000
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_GetClipboardData:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Unlink:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Unlink:PROC
EXTRN	_NET_AdrToString:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_Search:PROC
EXTRN	_Image_SetForceFlags:PROC
EXTRN	_Image_ClearForceFlags:PROC
EXTRN	_Host_NewInstance:PROC
EXTRN	_Host_EndGame:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_AVI_GetVideoFrameNumber:PROC
EXTRN	_AVI_GetVideoFrame:PROC
EXTRN	_AVI_GetVideoInfo:PROC
EXTRN	_AVI_OpenVideo:PROC
EXTRN	_AVI_CloseVideo:PROC
EXTRN	_AVI_IsActive:PROC
EXTRN	_AVI_GetState:PROC
EXTRN	_SV_Initialized:PROC
EXTRN	_Info_ValueForKey:PROC
EXTRN	_Mod_ForName:PROC
EXTRN	_PicAdjustSize:PROC
EXTRN	_PicAdjustScale:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	_S_StartLocalSound:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_R_Set2DMode:PROC
EXTRN	_GL_LoadTexture:PROC
EXTRN	_R_ClearScene:PROC
EXTRN	_R_PushScene:PROC
EXTRN	_R_PopScene:PROC
EXTRN	_R_RenderFrame:PROC
EXTRN	_R_GetTextureParms:PROC
EXTRN	_R_DrawStretchRaw:PROC
EXTRN	_R_DrawStretchPic:PROC
EXTRN	_R_DrawStretchPicRotate:PROC
EXTRN	_R_DrawStretchPicCircleRotate:PROC
EXTRN	_R_AddEntity:PROC
EXTRN	_COM_LoadLibrary:PROC
EXTRN	_COM_GetProcAddress:PROC
EXTRN	_COM_FreeLibrary:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_tr:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_GetMenuAPI DD	01H DUP (?)
?cin_time@?1??UI_DrawLogo@@9@9 DD 01H DUP (?)		; `UI_DrawLogo'::`2'::cin_time
?t@?1??pfnGetFilesList@@9@9 DD 01H DUP (?)		; `pfnGetFilesList'::`2'::t
?gpEngfuncs@?1??UI_LoadProgs@@9@9 DB 0150H DUP (?)	; `UI_LoadProgs'::`2'::gpEngfuncs
?gpGlobals@?1??UI_LoadProgs@@9@9 DB 0a0H DUP (?)	; `UI_LoadProgs'::`2'::gpGlobals
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@3d700000
CONST	SEGMENT
__real@3d700000 DD 03d700000r			; 0.0585938
CONST	ENDS
;	COMDAT __real@3b000000
CONST	SEGMENT
__real@3b000000 DD 03b000000r			; 0.00195312
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMMNBHGJ@Menu?5Pool@
CONST	SEGMENT
??_C@_09MMMNBHGJ@Menu?5Pool@ DB 'Menu Pool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GPJEPCGB@UI_LoadProgs?3?5can?8t?5init?5menu?5A@
CONST	SEGMENT
??_C@_0CD@GPJEPCGB@UI_LoadProgs?3?5can?8t?5init?5menu?5A@ DB 'UI_LoadProg'
	DB	's: can''t init menu API', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHPPEPNN@GetMenuAPI@
CONST	SEGMENT
??_C@_0L@PHPPEPNN@GetMenuAPI@ DB 'GetMenuAPI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOIHGPGJ@menu?4dll@
CONST	SEGMENT
??_C@_08OOIHGPGJ@menu?4dll@ DB 'menu.dll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CKFPHNOP@?$CFs?1menu?4dll@
CONST	SEGMENT
??_C@_0M@CKFPHNOP@?$CFs?1menu?4dll@ DB '%s/menu.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??UI_LoadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??UI_LoadProgs@@9@9 DD 0455H		; `UI_LoadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@CFEOCCMF@host_gameuiloaded@
CONST	SEGMENT
??_C@_0BC@CFEOCCMF@host_gameuiloaded@ DB 'host_gameuiloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??UI_UnloadProgs@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??UI_UnloadProgs@@9@9 DD 0444H		; `UI_UnloadProgs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_gameui.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??pfnGetFilesList@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??pfnGetFilesList@@9@9 DD 0395H		; `pfnGetFilesList'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@LNGHCJI@connect?5?$CFs?6@
CONST	SEGMENT
??_C@_0M@LNGHCJI@connect?5?$CFs?6@ DB 'connect %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GIBAHPJD@?$FO1Error?3?$FO7?5CL_LoadImage?3?5bad?5na@
CONST	SEGMENT
??_C@_0CE@GIBAHPJD@?$FO1Error?3?$FO7?5CL_LoadImage?3?5bad?5na@ DB '^1Erro'
	DB	'r:^7 CL_LoadImage: bad name!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BEIEFPIG@?$CFg@
CONST	SEGMENT
??_C@_02BEIEFPIG@?$CFg@ DB '%g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIFIMDEK@bottomcolor@
CONST	SEGMENT
??_C@_0M@IIFIMDEK@bottomcolor@ DB 'bottomcolor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OLGKFJAO@topcolor@
CONST	SEGMENT
??_C@_08OLGKFJAO@topcolor@ DB 'topcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCCFOPHA@model@
CONST	SEGMENT
??_C@_05NCCFOPHA@model@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name@ DB 'name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PHIAIOED@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?5fro@
CONST	SEGMENT
??_C@_0DO@PHIAIOED@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?5fro@ DB '^1'
	DB	'Error:^7 Couldn''t load %s from packfile. Please extract it', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAPFMNON@?4avi@
CONST	SEGMENT
??_C@_04CAPFMNON@?4avi@ DB '.avi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BKEEFKLC@media?1?$CFs@
CONST	SEGMENT
??_C@_08BKEEFKLC@media?1?$CFs@ DB 'media/%s', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?last_frame@?1??UI_DrawLogo@@9@9 DD 0ffffffffH		; `UI_DrawLogo'::`2'::last_frame
	ORG $+4
_gEngfuncs DD	FLAT:_pfnPIC_Load
	DD	FLAT:_GL_FreeImage
	DD	FLAT:_pfnPIC_Width
	DD	FLAT:_pfnPIC_Height
	DD	FLAT:_pfnPIC_Set
	DD	FLAT:_pfnPIC_Draw
	DD	FLAT:_pfnPIC_DrawHoles
	DD	FLAT:_pfnPIC_DrawTrans
	DD	FLAT:_pfnPIC_DrawAdditive
	DD	FLAT:_pfnPIC_EnableScissor
	DD	FLAT:_pfnPIC_DisableScissor
	DD	FLAT:_pfnFillRGBA
	DD	FLAT:_pfnFillRGBACircle
	DD	FLAT:_pfnCvar_RegisterGameUIVariable
	DD	FLAT:_Cvar_VariableValue
	DD	FLAT:_Cvar_VariableString
	DD	FLAT:_Cvar_Set
	DD	FLAT:_Cvar_SetValue
	DD	FLAT:_Cmd_AddGameUICommand
	DD	FLAT:_pfnClientCmd
	DD	FLAT:_Cmd_RemoveCommand
	DD	FLAT:_Cmd_Argc
	DD	FLAT:_Cmd_Argv
	DD	FLAT:_Cmd_Args
	DD	FLAT:_Con_Printf
	DD	FLAT:_Con_DPrintf
	DD	FLAT:_UI_NPrintf
	DD	FLAT:_UI_NXPrintf
	DD	FLAT:_pfnPlaySound
	DD	FLAT:_UI_DrawLogo
	DD	FLAT:_UI_GetLogoWidth
	DD	FLAT:_UI_GetLogoHeight
	DD	FLAT:_UI_GetLogoLength
	DD	FLAT:_pfnDrawCharacter
	DD	FLAT:_UI_DrawConsoleString
	DD	FLAT:_UI_DrawSetTextColor
	DD	FLAT:_Con_DrawStringLen
	DD	FLAT:_Con_DefaultColor
	DD	FLAT:_pfnGetPlayerModel
	DD	FLAT:_pfnSetPlayerModel
	DD	FLAT:_pfnClearScene
	DD	FLAT:_pfnRenderScene
	DD	FLAT:_pfnAddEntity
	DD	FLAT:_Host_Error
	DD	FLAT:_FS_FileExists
	DD	FLAT:_pfnGetGameDir
	DD	FLAT:_Cmd_CheckMapsList
	DD	FLAT:_CL_Active
	DD	FLAT:_pfnClientJoin
	DD	FLAT:_COM_LoadFileForMe
	DD	FLAT:_COM_ParseFile
	DD	FLAT:_COM_FreeFile
	DD	FLAT:_Key_ClearStates
	DD	FLAT:_Key_SetKeyDest
	DD	FLAT:_Key_KeynumToString
	DD	FLAT:_Key_GetBinding
	DD	FLAT:_Key_SetBinding
	DD	FLAT:_Key_IsDown
	DD	FLAT:_pfnKeyGetOverstrikeMode
	DD	FLAT:_pfnKeySetOverstrikeMode
	DD	FLAT:_pfnKeyGetState
	DD	FLAT:_pfnMemAlloc
	DD	FLAT:_pfnMemFree
	DD	FLAT:_pfnGetGameInfo
	DD	FLAT:_pfnGetGamesList
	DD	FLAT:_pfnGetFilesList
	DD	FLAT:_SV_GetSaveComment
	DD	FLAT:_CL_GetDemoComment
	DD	FLAT:_pfnCheckGameDll
	DD	FLAT:_pfnGetClipboardData
	DD	FLAT:_Sys_ShellExecute
	DD	FLAT:_Host_WriteServerConfig
	DD	FLAT:_pfnChangeInstance
	DD	FLAT:_pfnStartBackgroundTrack
	DD	FLAT:_pfnHostEndGame
	DD	FLAT:_COM_RandomFloat
	DD	FLAT:_COM_RandomLong
	DD	FLAT:_IN_SetCursor
	DD	FLAT:_pfnIsMapValid
	DD	FLAT:_GL_ProcessTexture
	DD	FLAT:_COM_CompareFileTime
	DD	FLAT:_VID_GetModeString
	DD	FLAT:_COM_SaveFile
	DD	FLAT:_FS_Delete
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	023cH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnStartBackgroundTrack
_TEXT	SEGMENT
_introTrack$ = 8					; size = 4
_mainTrack$ = 12					; size = 4
_position$ = 16						; size = 4
_loopCount$ = 20					; size = 4
_onLoop$ = 24						; size = 4
_restored$ = 28						; size = 4
_pfnStartBackgroundTrack PROC				; COMDAT

; 998  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 999  : 	S_StartBackgroundTrack( introTrack, mainTrack, position, loopCount, onLoop, restored, true );

	push	1
	mov	eax, DWORD PTR _restored$[ebp]
	push	eax
	mov	ecx, DWORD PTR _onLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loopCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mainTrack$[ebp]
	push	ecx
	mov	edx, DWORD PTR _introTrack$[ebp]
	push	edx
	call	_S_StartBackgroundTrack
	add	esp, 28					; 0000001cH

; 1000 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnStartBackgroundTrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnHostEndGame
_TEXT	SEGMENT
_szFinalMessage$ = 8					; size = 4
_pfnHostEndGame PROC					; COMDAT

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 987  : 	if( !szFinalMessage ) szFinalMessage = "";

	cmp	DWORD PTR _szFinalMessage$[ebp], 0
	jne	SHORT $LN2@pfnHostEnd
	mov	DWORD PTR _szFinalMessage$[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN2@pfnHostEnd:

; 988  : 	Host_EndGame( true, szFinalMessage );

	mov	eax, DWORD PTR _szFinalMessage$[ebp]
	push	eax
	push	1
	call	_Host_EndGame
	add	esp, 8

; 989  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnHostEndGame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnChangeInstance
_TEXT	SEGMENT
_newInstance$ = 8					; size = 4
_szFinalMessage$ = 12					; size = 4
_pfnChangeInstance PROC					; COMDAT

; 972  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 973  : 	if( !szFinalMessage ) szFinalMessage = "";

	cmp	DWORD PTR _szFinalMessage$[ebp], 0
	jne	SHORT $LN2@pfnChangeI
	mov	DWORD PTR _szFinalMessage$[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN2@pfnChangeI:

; 974  : 	if( !newInstance || !*newInstance ) return;

	cmp	DWORD PTR _newInstance$[ebp], 0
	je	SHORT $LN4@pfnChangeI
	mov	eax, DWORD PTR _newInstance$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@pfnChangeI
$LN4@pfnChangeI:
	jmp	SHORT $LN1@pfnChangeI
$LN3@pfnChangeI:

; 975  : 
; 976  : 	Host_NewInstance( newInstance, szFinalMessage );

	mov	eax, DWORD PTR _szFinalMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newInstance$[ebp]
	push	ecx
	call	_Host_NewInstance
	add	esp, 8
$LN1@pfnChangeI:

; 977  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnChangeInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnCheckGameDll
_TEXT	SEGMENT
_hInst$ = -4						; size = 4
_pfnCheckGameDll PROC					; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 953  : 	void	*hInst;
; 954  : 
; 955  : 	if( SV_Initialized( )) return true;

	call	_SV_Initialized
	test	eax, eax
	je	SHORT $LN2@pfnCheckGa
	mov	eax, 1
	jmp	SHORT $LN1@pfnCheckGa
$LN2@pfnCheckGa:

; 956  : 
; 957  : 	if(( hInst = COM_LoadLibrary( GI->game_dll, true, false )) != NULL )

	push	0
	push	1
	mov	eax, DWORD PTR _SI+768
	add	eax, 516				; 00000204H
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hInst$[ebp], eax
	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $LN3@pfnCheckGa

; 958  : 	{
; 959  : 		COM_FreeLibrary( hInst );

	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 960  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@pfnCheckGa
$LN3@pfnCheckGa:

; 961  : 	}
; 962  : 	return false;

	xor	eax, eax
$LN1@pfnCheckGa:

; 963  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnCheckGameDll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnGetClipboardData
_TEXT	SEGMENT
_pfnGetClipboardData PROC				; COMDAT

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 942  : 	return Sys_GetClipboardData();

	call	_Sys_GetClipboardData

; 943  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetClipboardData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnGetFilesList
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_numFiles$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_pfnGetFilesList PROC					; COMDAT

; 917  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 918  : 	static search_t	*t = NULL;
; 919  : 
; 920  : 	if( t ) Mem_Free( t ); // release prev search

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	je	SHORT $LN2@pfnGetFile
	mov	eax, DWORD PTR ?__LINE__Var@?0??pfnGetFilesList@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN2@pfnGetFile:

; 921  : 
; 922  : 	t = FS_Search( pattern, true, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_FS_Search
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, eax

; 923  : 	if( !t )

	cmp	DWORD PTR ?t@?1??pfnGetFilesList@@9@9, 0
	jne	SHORT $LN3@pfnGetFile

; 924  : 	{
; 925  : 		if( numFiles ) *numFiles = 0;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN4@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	DWORD PTR [eax], 0
$LN4@pfnGetFile:

; 926  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@pfnGetFile
$LN3@pfnGetFile:

; 927  : 	}
; 928  : 
; 929  : 	if( numFiles ) *numFiles = t->numfilenames;

	cmp	DWORD PTR _numFiles$[ebp], 0
	je	SHORT $LN5@pfnGetFile
	mov	eax, DWORD PTR _numFiles$[ebp]
	mov	ecx, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@pfnGetFile:

; 930  : 	return t->filenames;

	mov	eax, DWORD PTR ?t@?1??pfnGetFilesList@@9@9
	mov	eax, DWORD PTR [eax+4]
$LN1@pfnGetFile:

; 931  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetFilesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnGetGamesList
_TEXT	SEGMENT
_numGames$ = 8						; size = 4
_pfnGetGamesList PROC					; COMDAT

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 905  : 	if( numGames ) *numGames = SI.numgames;

	cmp	DWORD PTR _numGames$[ebp], 0
	je	SHORT $LN2@pfnGetGame
	mov	eax, DWORD PTR _numGames$[ebp]
	mov	ecx, DWORD PTR _SI+2820
	mov	DWORD PTR [eax], ecx
$LN2@pfnGetGame:

; 906  : 	return gameui.modsInfo;

	mov	eax, OFFSET _gameui+5000

; 907  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetGamesList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnGetGameInfo
_TEXT	SEGMENT
_pgameinfo$ = 8						; size = 4
_pfnGetGameInfo PROC					; COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 891  : 	if( !pgameinfo ) return 0;

	cmp	DWORD PTR _pgameinfo$[ebp], 0
	jne	SHORT $LN2@pfnGetGame
	xor	eax, eax
	jmp	SHORT $LN1@pfnGetGame
$LN2@pfnGetGame:

; 892  : 
; 893  : 	*pgameinfo = gameui.gameInfo;

	mov	ecx, 245				; 000000f5H
	mov	esi, OFFSET _gameui+4020
	mov	edi, DWORD PTR _pgameinfo$[ebp]
	rep movsd

; 894  : 	return 1;

	mov	eax, 1
$LN1@pfnGetGame:

; 895  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnMemFree
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_pfnMemFree PROC					; COMDAT

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 880  : 	_Mem_Free( mem, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMemFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnMemAlloc
_TEXT	SEGMENT
_cb$ = 8						; size = 4
_filename$ = 12						; size = 4
_fileline$ = 16						; size = 4
_pfnMemAlloc PROC					; COMDAT

; 868  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 869  : 	return _Mem_Alloc( gameui.mempool, cb, true, filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _cb$[ebp]
	push	edx
	mov	eax, DWORD PTR _gameui+68
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H

; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnMemAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnKeyGetState
_TEXT	SEGMENT
_name$ = 8						; size = 4
_pfnKeyGetState PROC					; COMDAT

; 855  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 856  : 	if( clgame.dllFuncs.KB_Find )

	cmp	DWORD PTR _clgame+72, 0
	je	SHORT $LN2@pfnKeyGetS

; 857  : 		return clgame.dllFuncs.KB_Find( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _clgame+72
	add	esp, 4
	jmp	SHORT $LN1@pfnKeyGetS
$LN2@pfnKeyGetS:

; 858  : 	return NULL;

	xor	eax, eax
$LN1@pfnKeyGetS:

; 859  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnKeyGetState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnKeySetOverstrikeMode
_TEXT	SEGMENT
_fActive$ = 8						; size = 4
_pfnKeySetOverstrikeMode PROC				; COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 844  : 	host.key_overstrike = fActive;

	mov	eax, DWORD PTR _fActive$[ebp]
	mov	DWORD PTR _host+34344, eax

; 845  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnKeySetOverstrikeMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnKeyGetOverstrikeMode
_TEXT	SEGMENT
_pfnKeyGetOverstrikeMode PROC				; COMDAT

; 831  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 832  : 	return host.key_overstrike;

	mov	eax, DWORD PTR _host+34344

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnKeyGetOverstrikeMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnClientJoin
_TEXT	SEGMENT
_adr$ = 8						; size = 20
_pfnClientJoin PROC					; COMDAT

; 819  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 820  : 	Cbuf_AddText( va( "connect %s\n", NET_AdrToString( adr )));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	call	_NET_AdrToString
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0M@LNGHCJI@connect?5?$CFs?6@
	call	_va
	add	esp, 8
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 821  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientJoin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnAddEntity
_TEXT	SEGMENT
_entityType$ = 8					; size = 4
_ent$ = 12						; size = 4
_pfnAddEntity PROC					; COMDAT

; 805  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 806  : 	if( !R_AddEntity( ent, entityType ))

	mov	eax, DWORD PTR _entityType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_R_AddEntity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@pfnAddEnti

; 807  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@pfnAddEnti
$LN2@pfnAddEnti:

; 808  : 	return true;

	mov	eax, 1
$LN1@pfnAddEnti:

; 809  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnAddEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnRenderScene
_TEXT	SEGMENT
_rvp$ = 8						; size = 4
_pfnRenderScene PROC					; COMDAT

; 783  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 784  : 	// to avoid division by zero
; 785  : 	if( !rvp || rvp->fov_x <= 0.0f || rvp->fov_y <= 0.0f )

	cmp	DWORD PTR _rvp$[ebp], 0
	je	SHORT $LN3@pfnRenderS
	mov	eax, DWORD PTR _rvp$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+44]
	jae	SHORT $LN3@pfnRenderS
	mov	eax, DWORD PTR _rvp$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+48]
	jb	SHORT $LN2@pfnRenderS
$LN3@pfnRenderS:

; 786  : 		return;

	jmp	SHORT $LN1@pfnRenderS
$LN2@pfnRenderS:

; 787  : 
; 788  : 	// don't allow special modes from menu
; 789  : 	((ref_viewpass_t *)&rvp)->flags = 0;

	mov	DWORD PTR _rvp$[ebp+52], 0

; 790  : 
; 791  : 	R_Set2DMode( false );

	push	0
	call	_R_Set2DMode
	add	esp, 4

; 792  : 	R_RenderFrame( rvp );

	mov	eax, DWORD PTR _rvp$[ebp]
	push	eax
	call	_R_RenderFrame
	add	esp, 4

; 793  : 	R_Set2DMode( true );

	push	1
	call	_R_Set2DMode
	add	esp, 4

; 794  : 	R_PopScene();

	call	_R_PopScene
$LN1@pfnRenderS:

; 795  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnRenderScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnClearScene
_TEXT	SEGMENT
_pfnClearScene PROC					; COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 771  : 	R_PushScene();

	call	_R_PushScene

; 772  : 	R_ClearScene();

	call	_R_ClearScene

; 773  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClearScene ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnSetPlayerModel
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_path$ = 12						; size = 4
_pfnSetPlayerModel PROC					; COMDAT

; 757  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 758  : 	ent->model = Mod_ForName( path, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Mod_ForName
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx+3300], eax

; 759  : 	ent->curstate.modelindex = MAX_MODELS; // unreachable index

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+952], 1024		; 00000400H

; 760  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnSetPlayerModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnGetPlayerModel
_TEXT	SEGMENT
_pfnGetPlayerModel PROC					; COMDAT

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 746  : 	return &gameui.playermodel;

	mov	eax, OFFSET _gameui+72

; 747  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnGetPlayerModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_DrawSetTextColor
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_alpha$ = 20						; size = 4
_UI_DrawSetTextColor PROC				; COMDAT

; 729  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 730  : 	// bound color and convert to byte
; 731  : 	gameui.ds.textColor[0] = r;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _r$[ebp]
	mov	BYTE PTR _gameui[ecx+4016], dl

; 732  : 	gameui.ds.textColor[1] = g;

	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR _g$[ebp]
	mov	BYTE PTR _gameui[eax+4016], cl

; 733  : 	gameui.ds.textColor[2] = b;

	mov	eax, 1
	shl	eax, 1
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR _gameui[eax+4016], cl

; 734  : 	gameui.ds.textColor[3] = alpha;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	dl, BYTE PTR _alpha$[ebp]
	mov	BYTE PTR _gameui[ecx+4016], dl

; 735  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_DrawSetTextColor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_DrawConsoleString
_TEXT	SEGMENT
_drawLen$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_UI_DrawConsoleString PROC				; COMDAT

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 712  : 	int	drawLen;
; 713  : 
; 714  : 	if( !string || !*string ) return 0; // silent ignore

	cmp	DWORD PTR _string$[ebp], 0
	je	SHORT $LN3@UI_DrawCon
	mov	eax, DWORD PTR _string$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@UI_DrawCon
$LN3@UI_DrawCon:
	xor	eax, eax
	jmp	SHORT $LN1@UI_DrawCon
$LN2@UI_DrawCon:

; 715  : 	drawLen = Con_DrawString( x, y, string, gameui.ds.textColor );

	push	OFFSET _gameui+4016
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	_Con_DrawString
	add	esp, 16					; 00000010H
	mov	DWORD PTR _drawLen$[ebp], eax

; 716  : 	MakeRGBA( gameui.ds.textColor, 255, 255, 255, 255 );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _gameui[ecx+4016], 255		; 000000ffH
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _gameui[edx+4016], 255		; 000000ffH
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _gameui[eax+4016], 255		; 000000ffH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _gameui[edx+4016], 255		; 000000ffH

; 717  : 
; 718  : 	return (x + drawLen); // exclude color prexfixes

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _drawLen$[ebp]
$LN1@UI_DrawCon:

; 719  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_DrawConsoleString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnDrawCharacter
_TEXT	SEGMENT
_height$ = -48						; size = 4
_width$ = -44						; size = 4
_y$ = -40						; size = 4
_x$ = -36						; size = 4
_t2$ = -32						; size = 4
_s2$ = -28						; size = 4
_t1$ = -24						; size = 4
_s1$ = -20						; size = 4
_size$ = -16						; size = 4
_col$ = -12						; size = 4
_row$ = -8						; size = 4
_color$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_iwidth$ = 16						; size = 4
_iheight$ = 20						; size = 4
_ch$ = 24						; size = 4
_ulRGBA$ = 28						; size = 4
_hFont$ = 32						; size = 4
_pfnDrawCharacter PROC					; COMDAT

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 667  : 	rgba_t	color;
; 668  : 	float	row, col, size;
; 669  : 	float	s1, t1, s2, t2;
; 670  : 	float	x = ix, y = iy;

	cvtsi2ss xmm0, DWORD PTR _ix$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0
	cvtsi2ss xmm0, DWORD PTR _iy$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 671  : 	float	width = iwidth;

	cvtsi2ss xmm0, DWORD PTR _iwidth$[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 672  : 	float	height = iheight;

	cvtsi2ss xmm0, DWORD PTR _iheight$[ebp]
	movss	DWORD PTR _height$[ebp], xmm0

; 673  : 
; 674  : 	ch &= 255;

	mov	eax, DWORD PTR _ch$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _ch$[ebp], eax

; 675  : 
; 676  : 	if( ch == ' ' ) return;

	cmp	DWORD PTR _ch$[ebp], 32			; 00000020H
	jne	SHORT $LN2@pfnDrawCha
	jmp	$LN1@pfnDrawCha
$LN2@pfnDrawCha:

; 677  : 	if( y < -height ) return;

	movss	xmm0, DWORD PTR _height$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	comiss	xmm0, DWORD PTR _y$[ebp]
	jbe	SHORT $LN3@pfnDrawCha
	jmp	$LN1@pfnDrawCha
$LN3@pfnDrawCha:

; 678  : 
; 679  : 	color[3] = (ulRGBA & 0xFF000000) >> 24;

	mov	eax, DWORD PTR _ulRGBA$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _color$[ebp+edx], al

; 680  : 	color[0] = (ulRGBA & 0xFF0000) >> 16;

	mov	eax, DWORD PTR _ulRGBA$[ebp]
	and	eax, 16711680				; 00ff0000H
	sar	eax, 16					; 00000010H
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _color$[ebp+edx], al

; 681  : 	color[1] = (ulRGBA & 0xFF00) >> 8;

	mov	eax, DWORD PTR _ulRGBA$[ebp]
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR _color$[ebp+ecx], al

; 682  : 	color[2] = (ulRGBA & 0xFF) >> 0;

	mov	eax, DWORD PTR _ulRGBA$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _color$[ebp+ecx], al

; 683  : 	pglColor4ubv( color );

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	call	DWORD PTR _pglColor4ubv

; 684  : 
; 685  : 	col = (ch & 15) * 0.0625f + (0.5f / 256.0f);

	mov	eax, DWORD PTR _ch$[ebp]
	and	eax, 15					; 0000000fH
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	addss	xmm0, DWORD PTR __real@3b000000
	movss	DWORD PTR _col$[ebp], xmm0

; 686  : 	row = (ch >> 4) * 0.0625f + (0.5f / 256.0f);

	mov	eax, DWORD PTR _ch$[ebp]
	sar	eax, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d800000
	addss	xmm0, DWORD PTR __real@3b000000
	movss	DWORD PTR _row$[ebp], xmm0

; 687  : 	size = 0.0625f - (1.0f / 256.0f);

	movss	xmm0, DWORD PTR __real@3d700000
	movss	DWORD PTR _size$[ebp], xmm0

; 688  : 
; 689  : 	s1 = col;

	movss	xmm0, DWORD PTR _col$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 690  : 	t1 = row;

	movss	xmm0, DWORD PTR _row$[ebp]
	movss	DWORD PTR _t1$[ebp], xmm0

; 691  : 	s2 = s1 + size;

	movss	xmm0, DWORD PTR _s1$[ebp]
	addss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0

; 692  : 	t2 = t1 + size;

	movss	xmm0, DWORD PTR _t1$[ebp]
	addss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR _t2$[ebp], xmm0

; 693  : 
; 694  : 	// pass scissor test if supposed
; 695  : 	if( gameui.ds.scissor_test && !PIC_Scissor( &x, &y, &width, &height, &s1, &t1, &s2, &t2 ))

	cmp	DWORD PTR _gameui+4012, 0
	je	SHORT $LN4@pfnDrawCha
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_PIC_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN4@pfnDrawCha

; 696  : 		return;

	jmp	$LN1@pfnDrawCha
$LN4@pfnDrawCha:

; 697  : 
; 698  : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 699  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, hFont );

	mov	eax, DWORD PTR _hFont$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 700  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@pfnDrawCha:

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnDrawCharacter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPlaySound
_TEXT	SEGMENT
_szSound$ = 8						; size = 4
_pfnPlaySound PROC					; COMDAT

; 653  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 654  : 	if( !COM_CheckString( szSound )) return;

	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@pfnPlaySou
	jmp	SHORT $LN1@pfnPlaySou
$LN2@pfnPlaySou:

; 655  : 	S_StartLocalSound( szSound, VOL_NORM, false );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _szSound$[ebp]
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@pfnPlaySou:

; 656  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPlaySound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnClientCmd
_TEXT	SEGMENT
_exec_now$ = 8						; size = 4
_szCmdString$ = 12					; size = 4
_pfnClientCmd PROC					; COMDAT

; 635  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 636  : 	if( !szCmdString || !szCmdString[0] )

	cmp	DWORD PTR _szCmdString$[ebp], 0
	je	SHORT $LN3@pfnClientC
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szCmdString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@pfnClientC
$LN3@pfnClientC:

; 637  : 		return;

	jmp	SHORT $LN1@pfnClientC
$LN2@pfnClientC:

; 638  : 
; 639  : 	Cbuf_AddText( szCmdString );

	mov	eax, DWORD PTR _szCmdString$[ebp]
	push	eax
	call	_Cbuf_AddText
	add	esp, 4

; 640  : 	Cbuf_AddText( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Cbuf_AddText
	add	esp, 4

; 641  : 
; 642  : 	// client command executes immediately
; 643  : 	if( exec_now ) Cbuf_Execute();

	cmp	DWORD PTR _exec_now$[ebp], 0
	je	SHORT $LN1@pfnClientC
	call	_Cbuf_Execute
$LN1@pfnClientC:

; 644  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnClientCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnFillRGBACircle
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv78 = -68						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_numshapes$ = 24					; size = 4
_type$ = 28						; size = 4
_thickness$ = 32					; size = 4
_angle_start$ = 36					; size = 4
_angle_end$ = 40					; size = 4
_r$ = 44						; size = 4
_g$ = 48						; size = 4
_b$ = 52						; size = 4
_a$ = 56						; size = 4
_xscale$ = 60						; size = 4
_yscale$ = 64						; size = 4
_selfangle$ = 68					; size = 4
_angle$ = 72						; size = 4
_xpivot$ = 76						; size = 4
_ypivot$ = 80						; size = 4
_pfnFillRGBACircle PROC					; COMDAT

; 616  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 617  : 	r = bound(0, r, 255);

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@pfnFillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@pfnFillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@pfnFillRGB
$LN3@pfnFillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@pfnFillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@pfnFillRGB
$LN5@pfnFillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN6@pfnFillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 618  : 	g = bound(0, g, 255);

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@pfnFillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@pfnFillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@pfnFillRGB
$LN7@pfnFillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@pfnFillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@pfnFillRGB
$LN9@pfnFillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN10@pfnFillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 619  : 	b = bound(0, b, 255);

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@pfnFillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@pfnFillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@pfnFillRGB
$LN11@pfnFillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@pfnFillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@pfnFillRGB
$LN13@pfnFillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN14@pfnFillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 620  : 	a = bound(0, a, 255);

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@pfnFillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@pfnFillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@pfnFillRGB
$LN15@pfnFillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@pfnFillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@pfnFillRGB
$LN17@pfnFillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN18@pfnFillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 621  : 	pglColor4ub(r, g, b, a);

	movzx	eax, BYTE PTR _a$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	call	DWORD PTR _pglColor4ub

; 622  : 	GL_SetRenderMode(kRenderTransTexture);

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 623  : 
; 624  : 	R_DrawStretchPicCircleRotate(x, y, width, height, numshapes, type, thickness, angle_start, angle_end, tr.whiteTexture, xscale, yscale, selfangle, angle, xpivot, ypivot);

	cvtss2sd xmm0, DWORD PTR _ypivot$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _xpivot$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _angle$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _tr+8
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvttss2si eax, DWORD PTR _thickness$[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _type$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _numshapes$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _height$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPicCircleRotate
	add	esp, 76					; 0000004cH

; 625  : 	pglColor4ub(255, 255, 255, 255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 626  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFillRGBACircle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnFillRGBA
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv78 = -68						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_type$ = 24						; size = 4
_thickness$ = 28					; size = 4
_r$ = 32						; size = 4
_g$ = 36						; size = 4
_b$ = 40						; size = 4
_a$ = 44						; size = 4
_xscale$ = 48						; size = 4
_yscale$ = 52						; size = 4
_selfangle$ = 56					; size = 4
_angle$ = 60						; size = 4
_xpivot$ = 64						; size = 4
_ypivot$ = 68						; size = 4
_pfnFillRGBA PROC					; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 598  : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@pfnFillRGB
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@pfnFillRGB
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@pfnFillRGB
$LN3@pfnFillRGB:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@pfnFillRGB:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@pfnFillRGB
$LN5@pfnFillRGB:
	mov	DWORD PTR tv67[ebp], 0
$LN6@pfnFillRGB:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 599  : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@pfnFillRGB
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@pfnFillRGB
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@pfnFillRGB
$LN7@pfnFillRGB:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@pfnFillRGB:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@pfnFillRGB
$LN9@pfnFillRGB:
	mov	DWORD PTR tv71[ebp], 0
$LN10@pfnFillRGB:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 600  : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@pfnFillRGB
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@pfnFillRGB
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@pfnFillRGB
$LN11@pfnFillRGB:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@pfnFillRGB:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@pfnFillRGB
$LN13@pfnFillRGB:
	mov	DWORD PTR tv75[ebp], 0
$LN14@pfnFillRGB:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 601  : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@pfnFillRGB
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@pfnFillRGB
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@pfnFillRGB
$LN15@pfnFillRGB:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@pfnFillRGB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@pfnFillRGB
$LN17@pfnFillRGB:
	mov	DWORD PTR tv79[ebp], 0
$LN18@pfnFillRGB:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 602  : 
; 603  : 	pglColor4ub( r, g, b, a );

	movzx	eax, BYTE PTR _a$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	call	DWORD PTR _pglColor4ub

; 604  : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 605  : 	R_DrawStretchPicRotate(x, y, width, height, 0, 0, 1, 1, tr.whiteTexture, xscale, yscale, selfangle, angle, xpivot, ypivot, -1, -1);

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _tr+8
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPicRotate
	add	esp, 68					; 00000044H

; 606  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub

; 607  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnFillRGBA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_DisableScissor
_TEXT	SEGMENT
_pfnPIC_DisableScissor PROC				; COMDAT

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 583  : 	gameui.ds.scissor_x = 0;

	mov	DWORD PTR _gameui+3996, 0

; 584  : 	gameui.ds.scissor_width = 0;

	mov	DWORD PTR _gameui+4004, 0

; 585  : 	gameui.ds.scissor_y = 0;

	mov	DWORD PTR _gameui+4000, 0

; 586  : 	gameui.ds.scissor_height = 0;

	mov	DWORD PTR _gameui+4008, 0

; 587  : 	gameui.ds.scissor_test = false;

	mov	DWORD PTR _gameui+4012, 0

; 588  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_DisableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_EnableScissor
_TEXT	SEGMENT
tv91 = -72						; size = 4
tv83 = -72						; size = 4
tv75 = -72						; size = 4
tv69 = -72						; size = 4
tv90 = -68						; size = 4
tv82 = -68						; size = 4
tv74 = -68						; size = 4
tv68 = -68						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_pfnPIC_EnableScissor PROC				; COMDAT

; 561  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 562  : 	// check bounds
; 563  : 	x = bound( 0, x, gameui.globals->scrWidth );

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN5@pfnPIC_Ena
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN3@pfnPIC_Ena
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN4@pfnPIC_Ena
$LN3@pfnPIC_Ena:
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv68[ebp], ecx
$LN4@pfnPIC_Ena:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN6@pfnPIC_Ena
$LN5@pfnPIC_Ena:
	mov	DWORD PTR tv69[ebp], 0
$LN6@pfnPIC_Ena:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 564  : 	y = bound( 0, y, gameui.globals->scrHeight );

	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN9@pfnPIC_Ena
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _y$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN7@pfnPIC_Ena
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@pfnPIC_Ena
$LN7@pfnPIC_Ena:
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv74[ebp], ecx
$LN8@pfnPIC_Ena:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], edx
	jmp	SHORT $LN10@pfnPIC_Ena
$LN9@pfnPIC_Ena:
	mov	DWORD PTR tv75[ebp], 0
$LN10@pfnPIC_Ena:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 565  : 	width = bound( 0, width, gameui.globals->scrWidth - x );

	cmp	DWORD PTR _width$[ebp], 0
	jl	SHORT $LN13@pfnPIC_Ena
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _x$[ebp]
	cmp	DWORD PTR _width$[ebp], ecx
	jge	SHORT $LN11@pfnPIC_Ena
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN12@pfnPIC_Ena
$LN11@pfnPIC_Ena:
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
$LN12@pfnPIC_Ena:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@pfnPIC_Ena
$LN13@pfnPIC_Ena:
	mov	DWORD PTR tv83[ebp], 0
$LN14@pfnPIC_Ena:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 566  : 	height = bound( 0, height, gameui.globals->scrHeight - y );

	cmp	DWORD PTR _height$[ebp], 0
	jl	SHORT $LN17@pfnPIC_Ena
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _y$[ebp]
	cmp	DWORD PTR _height$[ebp], ecx
	jge	SHORT $LN15@pfnPIC_Ena
	mov	edx, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN16@pfnPIC_Ena
$LN15@pfnPIC_Ena:
	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR tv90[ebp], ecx
$LN16@pfnPIC_Ena:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN18@pfnPIC_Ena
$LN17@pfnPIC_Ena:
	mov	DWORD PTR tv91[ebp], 0
$LN18@pfnPIC_Ena:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 567  : 
; 568  : 	gameui.ds.scissor_x = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _gameui+3996, eax

; 569  : 	gameui.ds.scissor_width = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _gameui+4004, eax

; 570  : 	gameui.ds.scissor_y = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _gameui+4000, eax

; 571  : 	gameui.ds.scissor_height = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _gameui+4008, eax

; 572  : 	gameui.ds.scissor_test = true;

	mov	DWORD PTR _gameui+4012, 1

; 573  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_EnableScissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_Height
_TEXT	SEGMENT
_picHeight$ = -4					; size = 4
_hPic$ = 8						; size = 4
_pfnPIC_Height PROC					; COMDAT

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 471  : 	int	picHeight;
; 472  : 
; 473  : 	R_GetTextureParms( NULL, &picHeight, hPic );

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _picHeight$[ebp]
	push	ecx
	push	0
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 474  : 
; 475  : 	return picHeight;

	mov	eax, DWORD PTR _picHeight$[ebp]

; 476  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_Height ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_Width
_TEXT	SEGMENT
_picWidth$ = -4						; size = 4
_hPic$ = 8						; size = 4
_pfnPIC_Width PROC					; COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 456  : 	int	picWidth;
; 457  : 
; 458  : 	R_GetTextureParms( &picWidth, NULL, hPic );

	mov	eax, DWORD PTR _hPic$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _picWidth$[ebp]
	push	ecx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 459  : 
; 460  : 	return picWidth;

	mov	eax, DWORD PTR _picWidth$[ebp]

; 461  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_Width ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_Load
_TEXT	SEGMENT
_tx$ = -4						; size = 4
_szPicName$ = 8						; size = 4
_image_buf$ = 12					; size = 4
_image_size$ = 16					; size = 4
_flags$ = 20						; size = 4
_pfnPIC_Load PROC					; COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 430  : 	HIMAGE	tx;
; 431  : 
; 432  : 	if( !szPicName || !*szPicName )

	cmp	DWORD PTR _szPicName$[ebp], 0
	je	SHORT $LN3@pfnPIC_Loa
	mov	eax, DWORD PTR _szPicName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@pfnPIC_Loa
$LN3@pfnPIC_Loa:

; 433  : 	{
; 434  : 		Con_Reportf( S_ERROR "CL_LoadImage: bad name!\n" );

	push	OFFSET ??_C@_0CE@GIBAHPJD@?$FO1Error?3?$FO7?5CL_LoadImage?3?5bad?5na@
	call	_Con_Reportf
	add	esp, 4

; 435  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@pfnPIC_Loa
$LN2@pfnPIC_Loa:

; 436  : 	}
; 437  : 
; 438  : 	// add default parms to image
; 439  : 	SetBits( flags, TF_IMAGE );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 6144				; 00001800H
	mov	DWORD PTR _flags$[ebp], eax

; 440  : 
; 441  : 	Image_SetForceFlags( IL_LOAD_DECAL ); // allow decal images for menu

	push	32					; 00000020H
	call	_Image_SetForceFlags
	add	esp, 4

; 442  : 	tx = GL_LoadTexture( szPicName, image_buf, image_size, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _image_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _szPicName$[ebp]
	push	eax
	call	_GL_LoadTexture
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tx$[ebp], eax

; 443  : 	Image_ClearForceFlags();

	call	_Image_ClearForceFlags

; 444  : 
; 445  : 	return tx;

	mov	eax, DWORD PTR _tx$[ebp]
$LN1@pfnPIC_Loa:

; 446  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_Load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _PIC_DrawGenericScale
_TEXT	SEGMENT
_h$ = -24						; size = 4
_w$ = -20						; size = 4
_t2$ = -16						; size = 4
_t1$ = -12						; size = 4
_s2$ = -8						; size = 4
_s1$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_xscale$ = 28						; size = 4
_yscale$ = 32						; size = 4
_selfangle$ = 36					; size = 4
_angle$ = 40						; size = 4
_xpivot$ = 44						; size = 4
_ypivot$ = 48						; size = 4
_selfxpivot$ = 52					; size = 4
_selfypivot$ = 56					; size = 4
_PIC_DrawGenericScale PROC				; COMDAT

; 373  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 374  : 	float	s1, s2, t1, t2;
; 375  : 	int	w, h;
; 376  : 
; 377  : 	// assume we get sizes from image
; 378  : 	R_GetTextureParms(&w, &h, gameui.ds.gl_texturenum);

	mov	eax, DWORD PTR _gameui+3992
	push	eax
	lea	ecx, DWORD PTR _h$[ebp]
	push	ecx
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 379  : 
; 380  : 	if (prc)

	cmp	DWORD PTR _prc$[ebp], 0
	je	$LN2@PIC_DrawGe

; 381  : 	{
; 382  : 		// calc user-defined rectangle
; 383  : 		s1 = (float)prc->left / (float)w;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	cvtsi2ss xmm1, DWORD PTR _w$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s1$[ebp], xmm0

; 384  : 		t1 = (float)prc->top / (float)h;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+8]
	cvtsi2ss xmm1, DWORD PTR _h$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 385  : 		s2 = (float)prc->right / (float)w;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	cvtsi2ss xmm1, DWORD PTR _w$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 386  : 		t2 = (float)prc->bottom / (float)h;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+12]
	cvtsi2ss xmm1, DWORD PTR _h$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 387  : 
; 388  : 		if (width == -1 && height == -1)

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@PIC_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@PIC_DrawGe

; 389  : 		{
; 390  : 			width = prc->right - prc->left;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR _prc$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _width$[ebp], xmm0

; 391  : 			height = prc->bottom - prc->top;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR _prc$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _height$[ebp], xmm0
$LN4@PIC_DrawGe:

; 392  : 		}
; 393  : 	}

	jmp	SHORT $LN3@PIC_DrawGe
$LN2@PIC_DrawGe:

; 394  : 	else
; 395  : 	{
; 396  : 		s1 = t1 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _t1$[ebp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 397  : 		s2 = t2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t2$[ebp], xmm0
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0
$LN3@PIC_DrawGe:

; 398  : 	}
; 399  : 
; 400  : 	if (width == -1 && height == -1)

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PIC_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PIC_DrawGe

; 401  : 	{
; 402  : 		width = w;

	cvtsi2ss xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 403  : 		height = h;

	cvtsi2ss xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR _height$[ebp], xmm0
$LN5@PIC_DrawGe:

; 404  : 	}
; 405  : 
; 406  : 	// pass scissor test if supposed
; 407  : 	if (gameui.ds.scissor_test && !PIC_Scissor(&x, &y, &width, &height, &s1, &t1, &s2, &t2))

	cmp	DWORD PTR _gameui+4012, 0
	je	SHORT $LN6@PIC_DrawGe
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_PIC_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN6@PIC_DrawGe

; 408  : 		return;

	jmp	$LN1@PIC_DrawGe
$LN6@PIC_DrawGe:

; 409  : 
; 410  : 	PicAdjustScale(&width, &height, xscale, yscale);

	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_PicAdjustScale
	add	esp, 16					; 00000010H

; 411  : 	PicAdjustSize(&x, &y, &width, &height);

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_PicAdjustSize
	add	esp, 16					; 00000010H

; 412  : 	R_DrawStretchPicRotate(x, y, width, height, s1, t1, s2, t2, gameui.ds.gl_texturenum, xscale, yscale, selfangle, angle, xpivot, ypivot, selfxpivot, selfypivot);

	cvtsi2ss xmm0, DWORD PTR _selfypivot$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _selfxpivot$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _ypivot$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _xpivot$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _gameui+3992
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPicRotate
	add	esp, 68					; 00000044H

; 413  : 	pglColor4ub(255, 255, 255, 255);

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@PIC_DrawGe:

; 414  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PIC_DrawGenericScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _PIC_DrawGeneric
_TEXT	SEGMENT
_h$ = -24						; size = 4
_w$ = -20						; size = 4
_t2$ = -16						; size = 4
_t1$ = -12						; size = 4
_s2$ = -8						; size = 4
_s1$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_PIC_DrawGeneric PROC					; COMDAT

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 324  : 	float	s1, s2, t1, t2;
; 325  : 	int	w, h;
; 326  : 
; 327  : 	// assume we get sizes from image
; 328  : 	R_GetTextureParms( &w, &h, gameui.ds.gl_texturenum );

	mov	eax, DWORD PTR _gameui+3992
	push	eax
	lea	ecx, DWORD PTR _h$[ebp]
	push	ecx
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	call	_R_GetTextureParms
	add	esp, 12					; 0000000cH

; 329  : 
; 330  : 	if( prc )

	cmp	DWORD PTR _prc$[ebp], 0
	je	$LN2@PIC_DrawGe

; 331  : 	{
; 332  : 		// calc user-defined rectangle
; 333  : 		s1 = (float)prc->left / (float)w;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	cvtsi2ss xmm1, DWORD PTR _w$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s1$[ebp], xmm0

; 334  : 		t1 = (float)prc->top / (float)h;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+8]
	cvtsi2ss xmm1, DWORD PTR _h$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t1$[ebp], xmm0

; 335  : 		s2 = (float)prc->right / (float)w;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	cvtsi2ss xmm1, DWORD PTR _w$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _s2$[ebp], xmm0

; 336  : 		t2 = (float)prc->bottom / (float)h;

	mov	eax, DWORD PTR _prc$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+12]
	cvtsi2ss xmm1, DWORD PTR _h$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _t2$[ebp], xmm0

; 337  : 
; 338  : 		if( width == -1 && height == -1 )

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@PIC_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@PIC_DrawGe

; 339  : 		{
; 340  : 			width = prc->right - prc->left;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR _prc$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _width$[ebp], xmm0

; 341  : 			height = prc->bottom - prc->top;

	mov	eax, DWORD PTR _prc$[ebp]
	mov	ecx, DWORD PTR _prc$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+8]
	cvtsi2ss xmm0, edx
	movss	DWORD PTR _height$[ebp], xmm0
$LN4@PIC_DrawGe:

; 342  : 		}
; 343  : 	}

	jmp	SHORT $LN3@PIC_DrawGe
$LN2@PIC_DrawGe:

; 344  : 	else
; 345  : 	{
; 346  : 		s1 = t1 = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _t1$[ebp], xmm0
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR _s1$[ebp], xmm0

; 347  : 		s2 = t2 = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _t2$[ebp], xmm0
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR _s2$[ebp], xmm0
$LN3@PIC_DrawGe:

; 348  : 	}
; 349  : 
; 350  : 	if( width == -1 && height == -1 )

	movss	xmm0, DWORD PTR _width$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PIC_DrawGe
	movss	xmm0, DWORD PTR _height$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PIC_DrawGe

; 351  : 	{
; 352  : 		width = w;

	cvtsi2ss xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR _width$[ebp], xmm0

; 353  : 		height = h;

	cvtsi2ss xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR _height$[ebp], xmm0
$LN5@PIC_DrawGe:

; 354  : 	}
; 355  : 
; 356  : 	// pass scissor test if supposed
; 357  : 	if( gameui.ds.scissor_test && !PIC_Scissor( &x, &y, &width, &height, &s1, &t1, &s2, &t2 ))

	cmp	DWORD PTR _gameui+4012, 0
	je	SHORT $LN6@PIC_DrawGe
	lea	eax, DWORD PTR _t2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _t1$[ebp]
	push	edx
	lea	eax, DWORD PTR _s1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _height$[ebp]
	push	ecx
	lea	edx, DWORD PTR _width$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	_PIC_Scissor
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN6@PIC_DrawGe

; 358  : 		return;

	jmp	$LN1@PIC_DrawGe
$LN6@PIC_DrawGe:

; 359  : 
; 360  : 	PicAdjustSize( &x, &y, &width, &height );

	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_PicAdjustSize
	add	esp, 16					; 00000010H

; 361  : 	R_DrawStretchPic( x, y, width, height, s1, t1, s2, t2, gameui.ds.gl_texturenum );

	mov	eax, DWORD PTR _gameui+3992
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchPic
	add	esp, 36					; 00000024H

; 362  : 	pglColor4ub( 255, 255, 255, 255 );

	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	push	255					; 000000ffH
	call	DWORD PTR _pglColor4ub
$LN1@PIC_DrawGe:

; 363  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PIC_DrawGeneric ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _PIC_Scissor
_TEXT	SEGMENT
_dvdy$ = -8						; size = 4
_dudx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_u0$ = 24						; size = 4
_v0$ = 28						; size = 4
_u1$ = 32						; size = 4
_v1$ = 36						; size = 4
_PIC_Scissor PROC					; COMDAT

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 269  : 	float	dudx, dvdy;
; 270  : 
; 271  : 	// clip sub rect to sprite
; 272  : 	if(( width == 0 ) || ( height == 0 ))

	cmp	DWORD PTR _width$[ebp], 0
	je	SHORT $LN3@PIC_Scisso
	cmp	DWORD PTR _height$[ebp], 0
	jne	SHORT $LN2@PIC_Scisso
$LN3@PIC_Scisso:

; 273  : 		return false;

	xor	eax, eax
	jmp	$LN1@PIC_Scisso
$LN2@PIC_Scisso:

; 274  : 
; 275  : 	if( *x + *width <= gameui.ds.scissor_x )

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _gameui+3996
	comiss	xmm1, xmm0
	jb	SHORT $LN4@PIC_Scisso

; 276  : 		return false;

	xor	eax, eax
	jmp	$LN1@PIC_Scisso
$LN4@PIC_Scisso:

; 277  : 	if( *x >= gameui.ds.scissor_x + gameui.ds.scissor_width )

	mov	eax, DWORD PTR _gameui+3996
	add	eax, DWORD PTR _gameui+4004
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jb	SHORT $LN5@PIC_Scisso

; 278  : 		return false;

	xor	eax, eax
	jmp	$LN1@PIC_Scisso
$LN5@PIC_Scisso:

; 279  : 	if( *y + *height <= gameui.ds.scissor_y )

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	cvtsi2ss xmm1, DWORD PTR _gameui+4000
	comiss	xmm1, xmm0
	jb	SHORT $LN6@PIC_Scisso

; 280  : 		return false;

	xor	eax, eax
	jmp	$LN1@PIC_Scisso
$LN6@PIC_Scisso:

; 281  : 	if( *y >= gameui.ds.scissor_y + gameui.ds.scissor_height )

	mov	eax, DWORD PTR _gameui+4000
	add	eax, DWORD PTR _gameui+4008
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	comiss	xmm1, xmm0
	jb	SHORT $LN7@PIC_Scisso

; 282  : 		return false;

	xor	eax, eax
	jmp	$LN1@PIC_Scisso
$LN7@PIC_Scisso:

; 283  : 
; 284  : 	dudx = (*u1 - *u0) / *width;

	mov	eax, DWORD PTR _u1$[ebp]
	mov	ecx, DWORD PTR _u0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _width$[ebp]
	divss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _dudx$[ebp], xmm0

; 285  : 	dvdy = (*v1 - *v0) / *height;

	mov	eax, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _v0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _height$[ebp]
	divss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR _dvdy$[ebp], xmm0

; 286  : 
; 287  : 	if( *x < gameui.ds.scissor_x )

	cvtsi2ss xmm0, DWORD PTR _gameui+3996
	mov	eax, DWORD PTR _x$[ebp]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN8@PIC_Scisso

; 288  : 	{
; 289  : 		*u0 += (gameui.ds.scissor_x - *x) * dudx;

	cvtsi2ss xmm0, DWORD PTR _gameui+3996
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	ecx, DWORD PTR _u0$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _u0$[ebp]
	movss	DWORD PTR [edx], xmm0

; 290  : 		*width -= gameui.ds.scissor_x - *x;

	cvtsi2ss xmm0, DWORD PTR _gameui+3996
	mov	eax, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm1

; 291  : 		*x = gameui.ds.scissor_x;

	cvtsi2ss xmm0, DWORD PTR _gameui+3996
	mov	eax, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN8@PIC_Scisso:

; 292  : 	}
; 293  : 
; 294  : 	if( *x + *width > gameui.ds.scissor_x + gameui.ds.scissor_width )

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _gameui+3996
	add	edx, DWORD PTR _gameui+4004
	cvtsi2ss xmm1, edx
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@PIC_Scisso

; 295  : 	{
; 296  : 		*u1 -= (*x + *width - (gameui.ds.scissor_x + gameui.ds.scissor_width)) * dudx;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _gameui+3996
	add	edx, DWORD PTR _gameui+4004
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dudx$[ebp]
	mov	eax, DWORD PTR _u1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _u1$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 297  : 		*width = gameui.ds.scissor_x + gameui.ds.scissor_width - *x;

	mov	eax, DWORD PTR _gameui+3996
	add	eax, DWORD PTR _gameui+4004
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _width$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN9@PIC_Scisso:

; 298  : 	}
; 299  : 
; 300  : 	if( *y < gameui.ds.scissor_y )

	cvtsi2ss xmm0, DWORD PTR _gameui+4000
	mov	eax, DWORD PTR _y$[ebp]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN10@PIC_Scisso

; 301  : 	{
; 302  : 		*v0 += (gameui.ds.scissor_y - *y) * dvdy;

	cvtsi2ss xmm0, DWORD PTR _gameui+4000
	mov	eax, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	ecx, DWORD PTR _v0$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _v0$[ebp]
	movss	DWORD PTR [edx], xmm0

; 303  : 		*height -= gameui.ds.scissor_y - *y;

	cvtsi2ss xmm0, DWORD PTR _gameui+4000
	mov	eax, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _height$[ebp]
	movss	DWORD PTR [edx], xmm1

; 304  : 		*y = gameui.ds.scissor_y;

	cvtsi2ss xmm0, DWORD PTR _gameui+4000
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0
$LN10@PIC_Scisso:

; 305  : 	}
; 306  : 
; 307  : 	if( *y + *height > gameui.ds.scissor_y + gameui.ds.scissor_height )

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _gameui+4000
	add	edx, DWORD PTR _gameui+4008
	cvtsi2ss xmm1, edx
	comiss	xmm0, xmm1
	jbe	SHORT $LN11@PIC_Scisso

; 308  : 	{
; 309  : 		*v1 -= (*y + *height - (gameui.ds.scissor_y + gameui.ds.scissor_height)) * dvdy;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _gameui+4000
	add	edx, DWORD PTR _gameui+4008
	cvtsi2ss xmm1, edx
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _dvdy$[ebp]
	mov	eax, DWORD PTR _v1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _v1$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 310  : 		*height = gameui.ds.scissor_y + gameui.ds.scissor_height - *y;

	mov	eax, DWORD PTR _gameui+4000
	add	eax, DWORD PTR _gameui+4008
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _height$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN11@PIC_Scisso:

; 311  : 	}
; 312  : 	return true;

	mov	eax, 1
$LN1@PIC_Scisso:

; 313  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_PIC_Scissor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_ConvertGameInfo
_TEXT	SEGMENT
tv189 = -76						; size = 8
tv185 = -68						; size = 4
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_UI_ConvertGameInfo PROC				; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 247  : 	Q_strncpy( out->gamefolder, in->gamefolder, sizeof( out->gamefolder ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 248  : 	Q_strncpy( out->startmap, in->startmap, sizeof( out->startmap ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 249  : 	Q_strncpy( out->trainmap, in->trainmap, sizeof( out->trainmap ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 250  : 	Q_strncpy( out->title, in->title, sizeof( out->title ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 192				; 000000c0H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 251  : 	Q_strncpy( out->version, va( "%g", in->version ), sizeof( out->version ));

	push	14					; 0000000eH
	mov	eax, DWORD PTR _in$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+448]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02BEIEFPIG@?$CFg@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 256				; 00000100H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 252  : 
; 253  : 	Q_strncpy( out->game_url, in->game_url, sizeof( out->game_url ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 644				; 00000284H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 254  : 	Q_strncpy( out->update_url, in->update_url, sizeof( out->update_url ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 528				; 00000210H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 255  : 	Q_strncpy( out->size, Q_pretifymem( in->size, 0 ), sizeof( out->size ));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _in$[ebp]
	mov	ecx, DWORD PTR [eax+1284]
	mov	DWORD PTR tv185[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv185[ebp]
	mov	edx, DWORD PTR tv185[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv189[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv189[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 912				; 00000390H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 256  : 	Q_strncpy( out->type, in->type, sizeof( out->type ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 784				; 00000310H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 257  : 	Q_strncpy( out->date, in->date, sizeof( out->date ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 1220				; 000004c4H
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 848				; 00000350H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 258  : 
; 259  : 	out->gamemode = in->gamemode;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	mov	edx, DWORD PTR [ecx+1288]
	mov	DWORD PTR [eax+976], edx

; 260  : 
; 261  : 	if( in->nomodels )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+1296], 0
	je	SHORT $LN2@UI_Convert

; 262  : 		out->flags |= GFL_NOMODELS;

	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, WORD PTR [eax+270]
	or	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx+270], cx
$LN2@UI_Convert:

; 263  : 	if( in->noskills )

	mov	eax, DWORD PTR _in$[ebp]
	cmp	DWORD PTR [eax+1300], 0
	je	SHORT $LN3@UI_Convert

; 264  : 		out->flags |= GFL_NOSKILLS;

	mov	eax, DWORD PTR _out$[ebp]
	movsx	ecx, WORD PTR [eax+270]
	or	ecx, 2
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx+270], cx
$LN3@UI_Convert:

; 265  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_ConvertGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_GetLogoLength
_TEXT	SEGMENT
_UI_GetLogoLength PROC					; COMDAT

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 219  : 	return gameui.logo_length;

	fld	DWORD PTR _gameui+7064

; 220  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_GetLogoLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_GetLogoHeight
_TEXT	SEGMENT
_UI_GetLogoHeight PROC					; COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 214  : 	return gameui.logo_yres;

	mov	eax, DWORD PTR _gameui+7060

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_GetLogoHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_GetLogoWidth
_TEXT	SEGMENT
_UI_GetLogoWidth PROC					; COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 209  : 	return gameui.logo_xres;

	mov	eax, DWORD PTR _gameui+7056

; 210  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_GetLogoWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_DrawLogo
_TEXT	SEGMENT
_fullpath$1 = -280					; size = 4
_path$2 = -276						; size = 256
_redraw$ = -20						; size = 4
_cin_frame$ = -16					; size = 4
_cin_state$ = -12					; size = 4
_cin_data$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_UI_DrawLogo PROC					; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 140  : 	static float	cin_time;
; 141  : 	static int	last_frame = -1;
; 142  : 	byte		*cin_data = NULL;

	mov	DWORD PTR _cin_data$[ebp], 0

; 143  : 	movie_state_t	*cin_state;
; 144  : 	int		cin_frame;
; 145  : 	qboolean		redraw = false;

	mov	DWORD PTR _redraw$[ebp], 0

; 146  : 
; 147  : 	if( !gameui.drawLogo ) return;

	cmp	DWORD PTR _gameui+7052, 0
	jne	SHORT $LN2@UI_DrawLog
	jmp	$LN1@UI_DrawLog
$LN2@UI_DrawLog:

; 148  : 	cin_state = AVI_GetState( CIN_LOGO );

	push	1
	call	_AVI_GetState
	add	esp, 4
	mov	DWORD PTR _cin_state$[ebp], eax

; 149  : 
; 150  : 	if( !AVI_IsActive( cin_state ))

	mov	eax, DWORD PTR _cin_state$[ebp]
	push	eax
	call	_AVI_IsActive
	add	esp, 4
	test	eax, eax
	jne	$LN3@UI_DrawLog

; 151  : 	{
; 152  : 		string		path;
; 153  : 		const char	*fullpath;
; 154  : 	
; 155  : 		// run cinematic if not
; 156  : 		Q_snprintf( path, sizeof( path ), "media/%s", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_08BKEEFKLC@media?1?$CFs@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _path$2[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 157  : 		COM_DefaultExtension( path, ".avi" );

	push	OFFSET ??_C@_04CAPFMNON@?4avi@
	lea	eax, DWORD PTR _path$2[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 158  : 		fullpath = FS_GetDiskPath( path, false );

	push	0
	lea	eax, DWORD PTR _path$2[ebp]
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	mov	DWORD PTR _fullpath$1[ebp], eax

; 159  : 
; 160  : 		if( FS_FileExists( path, false ) && !fullpath )

	push	0
	lea	eax, DWORD PTR _path$2[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@UI_DrawLog
	cmp	DWORD PTR _fullpath$1[ebp], 0
	jne	SHORT $LN4@UI_DrawLog

; 161  : 		{
; 162  : 			Con_Printf( S_ERROR "Couldn't load %s from packfile. Please extract it\n", path );

	lea	eax, DWORD PTR _path$2[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@PHIAIOED@?$FO1Error?3?$FO7?5Couldn?8t?5load?5?$CFs?5fro@
	call	_Con_Printf
	add	esp, 8

; 163  : 			gameui.drawLogo = false;

	mov	DWORD PTR _gameui+7052, 0

; 164  : 			return;

	jmp	$LN1@UI_DrawLog
$LN4@UI_DrawLog:

; 165  : 		}
; 166  : 
; 167  : 		AVI_OpenVideo( cin_state, fullpath, false, true );

	push	1
	push	0
	mov	eax, DWORD PTR _fullpath$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _cin_state$[ebp]
	push	ecx
	call	_AVI_OpenVideo
	add	esp, 16					; 00000010H

; 168  : 		if( !( AVI_GetVideoInfo( cin_state, &gameui.logo_xres, &gameui.logo_yres, &gameui.logo_length )))

	push	OFFSET _gameui+7064
	push	OFFSET _gameui+7060
	push	OFFSET _gameui+7056
	mov	eax, DWORD PTR _cin_state$[ebp]
	push	eax
	call	_AVI_GetVideoInfo
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN5@UI_DrawLog

; 169  : 		{
; 170  : 			AVI_CloseVideo( cin_state );

	mov	eax, DWORD PTR _cin_state$[ebp]
	push	eax
	call	_AVI_CloseVideo
	add	esp, 4

; 171  : 			gameui.drawLogo = false;

	mov	DWORD PTR _gameui+7052, 0

; 172  : 			return;

	jmp	$LN1@UI_DrawLog
$LN5@UI_DrawLog:

; 173  : 		}
; 174  : 
; 175  : 		cin_time = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9, xmm0

; 176  : 		last_frame = -1;

	mov	DWORD PTR ?last_frame@?1??UI_DrawLogo@@9@9, -1
$LN3@UI_DrawLog:

; 177  : 	}
; 178  : 
; 179  : 	if( width <= 0 || height <= 0 )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _width$[ebp]
	jae	SHORT $LN7@UI_DrawLog
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _height$[ebp]
	jb	SHORT $LN6@UI_DrawLog
$LN7@UI_DrawLog:

; 180  : 	{
; 181  : 		// precache call, don't draw
; 182  : 		cin_time = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9, xmm0

; 183  : 		last_frame = -1;

	mov	DWORD PTR ?last_frame@?1??UI_DrawLogo@@9@9, -1

; 184  : 		return;

	jmp	$LN1@UI_DrawLog
$LN6@UI_DrawLog:

; 185  : 	}
; 186  : 
; 187  : 	// advances cinematic time (ignores maxfps and host_framerate settings)
; 188  : 	cin_time += host.realframetime;

	cvtss2sd xmm0, DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9
	addsd	xmm0, QWORD PTR _host+1456
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9, xmm0

; 189  : 
; 190  : 	// restarts the cinematic
; 191  : 	if( cin_time > gameui.logo_length )

	movss	xmm0, DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9
	comiss	xmm0, DWORD PTR _gameui+7064
	jbe	SHORT $LN8@UI_DrawLog

; 192  : 		cin_time = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9, xmm0
$LN8@UI_DrawLog:

; 193  : 
; 194  : 	// read the next frame
; 195  : 	cin_frame = AVI_GetVideoFrameNumber( cin_state, cin_time );

	push	ecx
	movss	xmm0, DWORD PTR ?cin_time@?1??UI_DrawLogo@@9@9
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cin_state$[ebp]
	push	eax
	call	_AVI_GetVideoFrameNumber
	add	esp, 8
	mov	DWORD PTR _cin_frame$[ebp], eax

; 196  : 
; 197  : 	if( cin_frame != last_frame )

	mov	eax, DWORD PTR _cin_frame$[ebp]
	cmp	eax, DWORD PTR ?last_frame@?1??UI_DrawLogo@@9@9
	je	SHORT $LN9@UI_DrawLog

; 198  : 	{
; 199  : 		cin_data = AVI_GetVideoFrame( cin_state, cin_frame );

	mov	eax, DWORD PTR _cin_frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cin_state$[ebp]
	push	ecx
	call	_AVI_GetVideoFrame
	add	esp, 8
	mov	DWORD PTR _cin_data$[ebp], eax

; 200  : 		last_frame = cin_frame;

	mov	eax, DWORD PTR _cin_frame$[ebp]
	mov	DWORD PTR ?last_frame@?1??UI_DrawLogo@@9@9, eax

; 201  : 		redraw = true;

	mov	DWORD PTR _redraw$[ebp], 1
$LN9@UI_DrawLog:

; 202  : 	}
; 203  : 
; 204  : 	R_DrawStretchRaw( x, y, width, height, gameui.logo_xres, gameui.logo_yres, cin_data, redraw );

	mov	eax, DWORD PTR _redraw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cin_data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gameui+7060
	push	edx
	mov	eax, DWORD PTR _gameui+7056
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_R_DrawStretchRaw
	add	esp, 32					; 00000020H
$LN1@UI_DrawLog:

; 205  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_DrawLogo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_UpdateUserinfo
_TEXT	SEGMENT
_player$ = -4						; size = 4
_UI_UpdateUserinfo PROC					; COMDAT

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 224  : 	player_info_t	*player;
; 225  : 
; 226  : 	if( !host.userinfo_changed )

	cmp	DWORD PTR _host+34412, 0
	jne	SHORT $LN2@UI_UpdateU

; 227  : 		return;

	jmp	$LN1@UI_UpdateU
$LN2@UI_UpdateU:

; 228  : 
; 229  : 	player = &gameui.playerinfo;

	mov	DWORD PTR _player$[ebp], OFFSET _gameui+3408

; 230  : 
; 231  : 	Q_strncpy( player->userinfo, cls.userinfo, sizeof( player->userinfo ));

	push	256					; 00000100H
	push	OFFSET _cls+9880
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 232  : 	Q_strncpy( player->name, Info_ValueForKey( player->userinfo, "name" ), sizeof( player->name ));

	push	32					; 00000020H
	push	OFFSET ??_C@_04MEMAJGDJ@name@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 233  : 	Q_strncpy( player->model, Info_ValueForKey( player->userinfo, "model" ), sizeof( player->model ));

	push	64					; 00000040H
	push	OFFSET ??_C@_05NCCFOPHA@model@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	add	ecx, 304				; 00000130H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 234  : 	player->topcolor = Q_atoi( Info_ValueForKey( player->userinfo, "topcolor" ));

	push	OFFSET ??_C@_08OLGKFJAO@topcolor@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+368], eax

; 235  : 	player->bottomcolor = Q_atoi( Info_ValueForKey( player->userinfo, "bottomcolor" ));

	push	OFFSET ??_C@_0M@IIFIMDEK@bottomcolor@
	mov	eax, DWORD PTR _player$[ebp]
	add	eax, 4
	push	eax
	call	_Info_ValueForKey
	add	esp, 8
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 236  : 	host.userinfo_changed = false; // we got it

	mov	DWORD PTR _host+34412, 0
$LN1@UI_UpdateU:

; 237  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_UpdateUserinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_DrawAdditiveAlt
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_xscale$ = 28						; size = 4
_yscale$ = 32						; size = 4
_selfangle$ = 36					; size = 4
_angle$ = 40						; size = 4
_xpivot$ = 44						; size = 4
_ypivot$ = 48						; size = 4
_selfxpivot$ = 52					; size = 4
_selfypivot$ = 56					; size = 4
_pfnPIC_DrawAdditiveAlt PROC				; COMDAT

; 549  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 550  : 	GL_SetRenderMode(kRenderTransAdd);

	push	5
	call	_GL_SetRenderMode
	add	esp, 4

; 551  : 	PIC_DrawGenericScale(x, y, width, height, prc, xscale, yscale, selfangle, angle, xpivot, ypivot, selfxpivot, selfypivot);

	mov	eax, DWORD PTR _selfypivot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _selfxpivot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ypivot$[ebp]
	push	edx
	mov	eax, DWORD PTR _xpivot$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _prc$[ebp]
	push	ecx
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_PIC_DrawGenericScale
	add	esp, 52					; 00000034H

; 552  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_DrawAdditiveAlt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_DrawAdditive
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_pfnPIC_DrawAdditive PROC				; COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 538  : 	GL_SetRenderMode( kRenderTransAdd );

	push	5
	call	_GL_SetRenderMode
	add	esp, 4

; 539  : 	PIC_DrawGeneric( x, y, width, height, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_PIC_DrawGeneric
	add	esp, 20					; 00000014H

; 540  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_DrawAdditive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_DrawHoles
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_pfnPIC_DrawHoles PROC					; COMDAT

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 526  : 	GL_SetRenderMode( kRenderTransAlpha );

	push	4
	call	_GL_SetRenderMode
	add	esp, 4

; 527  : 	PIC_DrawGeneric( x, y, width, height, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_PIC_DrawGeneric
	add	esp, 20					; 00000014H

; 528  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_DrawHoles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_DrawTrans
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_pfnPIC_DrawTrans PROC					; COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 514  : 	GL_SetRenderMode( kRenderTransTexture );

	push	2
	call	_GL_SetRenderMode
	add	esp, 4

; 515  : 	PIC_DrawGeneric( x, y, width, height, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_PIC_DrawGeneric
	add	esp, 20					; 00000014H

; 516  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_DrawTrans ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_Draw
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_prc$ = 24						; size = 4
_pfnPIC_Draw PROC					; COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 502  : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 503  : 	PIC_DrawGeneric( x, y, width, height, prc );

	mov	eax, DWORD PTR _prc$[ebp]
	push	eax
	cvtsi2ss xmm0, DWORD PTR _height$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _width$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_PIC_DrawGeneric
	add	esp, 20					; 00000014H

; 504  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_Draw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _pfnPIC_Set
_TEXT	SEGMENT
tv79 = -72						; size = 4
tv75 = -72						; size = 4
tv71 = -72						; size = 4
tv67 = -72						; size = 4
tv78 = -68						; size = 4
tv74 = -68						; size = 4
tv70 = -68						; size = 4
tv66 = -68						; size = 4
_hPic$ = 8						; size = 4
_r$ = 12						; size = 4
_g$ = 16						; size = 4
_b$ = 20						; size = 4
_a$ = 24						; size = 4
_pfnPIC_Set PROC					; COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 486  : 	gameui.ds.gl_texturenum = hPic;

	mov	eax, DWORD PTR _hPic$[ebp]
	mov	DWORD PTR _gameui+3992, eax

; 487  : 	r = bound( 0, r, 255 );

	cmp	DWORD PTR _r$[ebp], 0
	jl	SHORT $LN5@pfnPIC_Set
	cmp	DWORD PTR _r$[ebp], 255			; 000000ffH
	jge	SHORT $LN3@pfnPIC_Set
	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@pfnPIC_Set
$LN3@pfnPIC_Set:
	mov	DWORD PTR tv66[ebp], 255		; 000000ffH
$LN4@pfnPIC_Set:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@pfnPIC_Set
$LN5@pfnPIC_Set:
	mov	DWORD PTR tv67[ebp], 0
$LN6@pfnPIC_Set:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 488  : 	g = bound( 0, g, 255 );

	cmp	DWORD PTR _g$[ebp], 0
	jl	SHORT $LN9@pfnPIC_Set
	cmp	DWORD PTR _g$[ebp], 255			; 000000ffH
	jge	SHORT $LN7@pfnPIC_Set
	mov	eax, DWORD PTR _g$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN8@pfnPIC_Set
$LN7@pfnPIC_Set:
	mov	DWORD PTR tv70[ebp], 255		; 000000ffH
$LN8@pfnPIC_Set:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN10@pfnPIC_Set
$LN9@pfnPIC_Set:
	mov	DWORD PTR tv71[ebp], 0
$LN10@pfnPIC_Set:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 489  : 	b = bound( 0, b, 255 );

	cmp	DWORD PTR _b$[ebp], 0
	jl	SHORT $LN13@pfnPIC_Set
	cmp	DWORD PTR _b$[ebp], 255			; 000000ffH
	jge	SHORT $LN11@pfnPIC_Set
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN12@pfnPIC_Set
$LN11@pfnPIC_Set:
	mov	DWORD PTR tv74[ebp], 255		; 000000ffH
$LN12@pfnPIC_Set:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN14@pfnPIC_Set
$LN13@pfnPIC_Set:
	mov	DWORD PTR tv75[ebp], 0
$LN14@pfnPIC_Set:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 490  : 	a = bound( 0, a, 255 );

	cmp	DWORD PTR _a$[ebp], 0
	jl	SHORT $LN17@pfnPIC_Set
	cmp	DWORD PTR _a$[ebp], 255			; 000000ffH
	jge	SHORT $LN15@pfnPIC_Set
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN16@pfnPIC_Set
$LN15@pfnPIC_Set:
	mov	DWORD PTR tv78[ebp], 255		; 000000ffH
$LN16@pfnPIC_Set:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN18@pfnPIC_Set
$LN17@pfnPIC_Set:
	mov	DWORD PTR tv79[ebp], 0
$LN18@pfnPIC_Set:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _a$[ebp], edx

; 491  : 	pglColor4ub( r, g, b, a );

	movzx	eax, BYTE PTR _a$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _g$[ebp]
	push	edx
	movzx	eax, BYTE PTR _r$[ebp]
	push	eax
	call	DWORD PTR _pglColor4ub

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_pfnPIC_Set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_IsVisible
_TEXT	SEGMENT
_UI_IsVisible PROC					; COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 134  : 	if( !gameui.hInstance ) return 0;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_IsVisib
	xor	eax, eax
	jmp	SHORT $LN1@UI_IsVisib
$LN2@UI_IsVisib:

; 135  : 	return gameui.dllFuncs.pfnIsVisible();

	call	DWORD PTR _gameui+56
$LN1@UI_IsVisib:

; 136  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_IsVisible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_MouseInRect
_TEXT	SEGMENT
_UI_MouseInRect PROC					; COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 128  : 	if( !gameui.hInstance ) return 1;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_MouseIn
	mov	eax, 1
	jmp	SHORT $LN1@UI_MouseIn
$LN2@UI_MouseIn:

; 129  : 	return gameui.dllFuncs.pfnMouseInRect();

	call	DWORD PTR _gameui+52
$LN1@UI_MouseIn:

; 130  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_MouseInRect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_CharEvent
_TEXT	SEGMENT
_key$ = 8						; size = 4
_UI_CharEvent PROC					; COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 122  : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_CharEve
	jmp	SHORT $LN1@UI_CharEve
$LN2@UI_CharEve:

; 123  : 	gameui.dllFuncs.pfnCharEvent( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR _gameui+48
	add	esp, 4
$LN1@UI_CharEve:

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_CharEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_ShowCursor
_TEXT	SEGMENT
_show$ = 8						; size = 4
_UI_ShowCursor PROC					; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 110  : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_ShowCur
	jmp	SHORT $LN1@UI_ShowCur
$LN2@UI_ShowCur:

; 111  : 	gameui.dllFuncs.pfnShowCursor( show );

	mov	eax, DWORD PTR _show$[ebp]
	push	eax
	call	DWORD PTR _gameui+44
	add	esp, 4
$LN1@UI_ShowCur:

; 112  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_ShowCursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_SetCursorPos
_TEXT	SEGMENT
_pos_x$ = 8						; size = 4
_pos_y$ = 12						; size = 4
_UI_SetCursorPos PROC					; COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 104  : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_SetCurs
	jmp	SHORT $LN1@UI_SetCurs
$LN2@UI_SetCurs:

; 105  : 	gameui.dllFuncs.pfnSetCursorPos( pos_x, pos_y );

	mov	eax, DWORD PTR _pos_y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos_x$[ebp]
	push	ecx
	call	DWORD PTR _gameui+40
	add	esp, 8
$LN1@UI_SetCurs:

; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_SetCursorPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_GetCursorPos
_TEXT	SEGMENT
_pos_x$ = 8						; size = 4
_pos_y$ = 12						; size = 4
_UI_GetCursorPos PROC					; COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 98   : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_GetCurs
	jmp	SHORT $LN1@UI_GetCurs
$LN2@UI_GetCurs:

; 99   : 	gameui.dllFuncs.pfnGetCursorPos( pos_x, pos_y );

	mov	eax, DWORD PTR _pos_y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos_x$[ebp]
	push	ecx
	call	DWORD PTR _gameui+36
	add	esp, 8
$LN1@UI_GetCurs:

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_GetCursorPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_AddServerToList
_TEXT	SEGMENT
_adr$ = 8						; size = 20
_info$ = 28						; size = 4
_UI_AddServerToList PROC				; COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 92   : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_AddServ
	jmp	SHORT $LN1@UI_AddServ
$LN2@UI_AddServ:

; 93   : 	gameui.dllFuncs.pfnAddServerToList( adr, info );

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _adr$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _adr$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _adr$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _adr$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _adr$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	call	DWORD PTR _gameui+32
	add	esp, 24					; 00000018H
$LN1@UI_AddServ:

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_AddServerToList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_MouseMove
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_UI_MouseMove PROC					; COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 64   : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_MouseMo
	jmp	SHORT $LN1@UI_MouseMo
$LN2@UI_MouseMo:

; 65   : 	gameui.dllFuncs.pfnMouseMove( x, y );

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	DWORD PTR _gameui+24
	add	esp, 8
$LN1@UI_MouseMo:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_MouseMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_KeyEvent
_TEXT	SEGMENT
_key$ = 8						; size = 4
_down$ = 12						; size = 4
_UI_KeyEvent PROC					; COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 58   : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_KeyEven
	jmp	SHORT $LN1@UI_KeyEven
$LN2@UI_KeyEven:

; 59   : 	gameui.dllFuncs.pfnKeyEvent( key, down );

	mov	eax, DWORD PTR _down$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	DWORD PTR _gameui+20
	add	esp, 8
$LN1@UI_KeyEven:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_KeyEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_UpdateMenu
_TEXT	SEGMENT
_realtime$ = 8						; size = 4
_UI_UpdateMenu PROC					; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 30   : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_UpdateM
	jmp	$LN1@UI_UpdateM
$LN2@UI_UpdateM:

; 31   : 
; 32   : 	// if some deferred cmds is waiting
; 33   : 	if( UI_IsVisible() && COM_CheckString( host.deferred_cmd ))

	call	_UI_IsVisible
	test	eax, eax
	je	SHORT $LN3@UI_UpdateM
	push	OFFSET _host+756
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@UI_UpdateM

; 34   : 	{
; 35   : 		Cbuf_AddText( host.deferred_cmd );

	push	OFFSET _host+756
	call	_Cbuf_AddText
	add	esp, 4

; 36   : 		host.deferred_cmd[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _host[ecx+756], 0

; 37   : 		Cbuf_Execute();

	call	_Cbuf_Execute

; 38   : 		return;

	jmp	SHORT $LN1@UI_UpdateM
$LN3@UI_UpdateM:

; 39   : 	}
; 40   : 
; 41   : 	// don't show menu while level is loaded
; 42   : 	if( GameState->nextstate != STATE_RUNFRAME && !GameState->loadGame )

	cmp	DWORD PTR _host+20, 0
	je	SHORT $LN4@UI_UpdateM
	cmp	DWORD PTR _host+156, 0
	jne	SHORT $LN4@UI_UpdateM

; 43   : 		return;

	jmp	SHORT $LN1@UI_UpdateM
$LN4@UI_UpdateM:

; 44   : 
; 45   : 	// menu time (not paused, not clamped)
; 46   : 	gameui.globals->time = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	mov	eax, DWORD PTR _gameui+7048
	movss	DWORD PTR [eax], xmm0

; 47   : 	gameui.globals->frametime = host.realframetime;

	cvtsd2ss xmm0, QWORD PTR _host+1456
	mov	eax, DWORD PTR _gameui+7048
	movss	DWORD PTR [eax+4], xmm0

; 48   : 	gameui.globals->demoplayback = cls.demoplayback;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _cls+300828
	mov	DWORD PTR [eax+24], ecx

; 49   : 	gameui.globals->demorecording = cls.demorecording;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _cls+300824
	mov	DWORD PTR [eax+28], ecx

; 50   : 	gameui.globals->allow_console = host.allow_console;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _host+34336
	mov	DWORD PTR [eax+20], ecx

; 51   : 
; 52   : 	gameui.dllFuncs.pfnRedraw( realtime );

	push	ecx
	movss	xmm0, DWORD PTR _realtime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _gameui+16
	add	esp, 4

; 53   : 	UI_UpdateUserinfo();

	call	_UI_UpdateUserinfo
$LN1@UI_UpdateM:

; 54   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_UpdateMenu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_LoadProgs
_TEXT	SEGMENT
_i$ = -4						; size = 4
_UI_LoadProgs PROC					; COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1110 : 	static ui_enginefuncs_t	gpEngfuncs;
; 1111 : 	static ui_globalvars_t	gpGlobals;
; 1112 : 	int			i;
; 1113 : 
; 1114 : 	if( gameui.hInstance ) UI_UnloadProgs();

	cmp	DWORD PTR _gameui, 0
	je	SHORT $LN5@UI_LoadPro
	call	_UI_UnloadProgs
$LN5@UI_LoadPro:

; 1115 : 
; 1116 : 	// setup globals
; 1117 : 	gameui.globals = &gpGlobals;

	mov	DWORD PTR _gameui+7048, OFFSET ?gpGlobals@?1??UI_LoadProgs@@9@9

; 1118 : 
; 1119 : 	if(( gameui.hInstance = COM_LoadLibrary( va( "%s/menu.dll", GI->dll_path ), false, false )) == NULL )

	push	0
	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 452				; 000001c4H
	push	eax
	push	OFFSET ??_C@_0M@CKFPHNOP@?$CFs?1menu?4dll@
	call	_va
	add	esp, 8
	push	eax
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _gameui, eax
	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN6@UI_LoadPro

; 1120 : 	{
; 1121 : 		if(( gameui.hInstance = COM_LoadLibrary( "menu.dll", false, true )) == NULL )

	push	1
	push	0
	push	OFFSET ??_C@_08OOIHGPGJ@menu?4dll@
	call	_COM_LoadLibrary
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _gameui, eax
	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN6@UI_LoadPro

; 1122 : 			return false;

	xor	eax, eax
	jmp	$LN1@UI_LoadPro
$LN6@UI_LoadPro:

; 1123 : 	}
; 1124 : 
; 1125 : 	if(( GetMenuAPI = (MENUAPI)COM_GetProcAddress( gameui.hInstance, "GetMenuAPI" )) == NULL )

	push	OFFSET ??_C@_0L@PHPPEPNN@GetMenuAPI@
	mov	eax, DWORD PTR _gameui
	push	eax
	call	_COM_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _GetMenuAPI, eax
	cmp	DWORD PTR _GetMenuAPI, 0
	jne	SHORT $LN8@UI_LoadPro

; 1126 : 	{
; 1127 : 		COM_FreeLibrary( gameui.hInstance );

	mov	eax, DWORD PTR _gameui
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 1128 : 		Con_Reportf( "UI_LoadProgs: can't init menu API\n" );

	push	OFFSET ??_C@_0CD@GPJEPCGB@UI_LoadProgs?3?5can?8t?5init?5menu?5A@
	call	_Con_Reportf
	add	esp, 4

; 1129 : 		gameui.hInstance = NULL;

	mov	DWORD PTR _gameui, 0

; 1130 : 		return false;

	xor	eax, eax
	jmp	$LN1@UI_LoadPro
$LN8@UI_LoadPro:

; 1131 : 	}
; 1132 : 
; 1133 : 	// make local copy of engfuncs to prevent overwrite it with user dll
; 1134 : 	memcpy( &gpEngfuncs, &gEngfuncs, sizeof( gpEngfuncs ));

	push	336					; 00000150H
	push	OFFSET _gEngfuncs
	push	OFFSET ?gpEngfuncs@?1??UI_LoadProgs@@9@9
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1135 : 
; 1136 : 	gameui.mempool = Mem_AllocPool( "Menu Pool" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??UI_LoadProgs@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_09MMMNBHGJ@Menu?5Pool@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _gameui+68, eax

; 1137 : 
; 1138 : 	if( !GetMenuAPI( &gameui.dllFuncs, &gpEngfuncs, gameui.globals ))

	mov	eax, DWORD PTR _gameui+7048
	push	eax
	push	OFFSET ?gpEngfuncs@?1??UI_LoadProgs@@9@9
	push	OFFSET _gameui+4
	call	DWORD PTR _GetMenuAPI
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@UI_LoadPro

; 1139 : 	{
; 1140 : 		COM_FreeLibrary( gameui.hInstance );

	mov	eax, DWORD PTR _gameui
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 1141 : 		Con_Reportf( "UI_LoadProgs: can't init menu API\n" );

	push	OFFSET ??_C@_0CD@GPJEPCGB@UI_LoadProgs?3?5can?8t?5init?5menu?5A@
	call	_Con_Reportf
	add	esp, 4

; 1142 : 		Mem_FreePool( &gameui.mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??UI_LoadProgs@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _gameui+68
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 1143 : 		gameui.hInstance = NULL;

	mov	DWORD PTR _gameui, 0

; 1144 : 		return false;

	xor	eax, eax
	jmp	$LN1@UI_LoadPro
$LN9@UI_LoadPro:

; 1145 : 	}
; 1146 : 
; 1147 : 	Cvar_FullSet( "host_gameuiloaded", "1", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BC@CFEOCCMF@host_gameuiloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1148 : 
; 1149 : 	// setup gameinfo
; 1150 : 	for( i = 0; i < SI.numgames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@UI_LoadPro
$LN2@UI_LoadPro:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@UI_LoadPro:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SI+2820
	jge	SHORT $LN3@UI_LoadPro

; 1151 : 	{
; 1152 : 		gameui.modsInfo[i] = Mem_Calloc( gameui.mempool, sizeof( GAMEINFO ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??UI_LoadProgs@@9@9
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	980					; 000003d4H
	mov	ecx, DWORD PTR _gameui+68
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _gameui[edx*4+5000], eax

; 1153 : 		UI_ConvertGameInfo( gameui.modsInfo[i], SI.games[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SI[eax*4+772]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _gameui[edx*4+5000]
	push	eax
	call	_UI_ConvertGameInfo
	add	esp, 8

; 1154 : 	}

	jmp	SHORT $LN2@UI_LoadPro
$LN3@UI_LoadPro:

; 1155 : 
; 1156 : 	UI_ConvertGameInfo( &gameui.gameInfo, SI.GameInfo ); // current gameinfo

	mov	eax, DWORD PTR _SI+768
	push	eax
	push	OFFSET _gameui+4020
	call	_UI_ConvertGameInfo
	add	esp, 8

; 1157 : 
; 1158 : 	// setup globals
; 1159 : 	gameui.globals->allow_console = host.allow_console;

	mov	eax, DWORD PTR _gameui+7048
	mov	ecx, DWORD PTR _host+34336
	mov	DWORD PTR [eax+20], ecx

; 1160 : 
; 1161 : 	// initialize game
; 1162 : 	gameui.dllFuncs.pfnInit();

	call	DWORD PTR _gameui+8

; 1163 : 
; 1164 : 	return true;

	mov	eax, 1
$LN1@UI_LoadPro:

; 1165 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_LoadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_UnloadProgs
_TEXT	SEGMENT
_UI_UnloadProgs PROC					; COMDAT

; 1092 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1093 : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_UnloadP
	jmp	SHORT $LN1@UI_UnloadP
$LN2@UI_UnloadP:

; 1094 : 
; 1095 : 	// deinitialize game
; 1096 : 	gameui.dllFuncs.pfnShutdown();

	call	DWORD PTR _gameui+12

; 1097 : 
; 1098 : 	Cvar_FullSet( "host_gameuiloaded", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BC@CFEOCCMF@host_gameuiloaded@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1099 : 
; 1100 : 	COM_FreeLibrary( gameui.hInstance );

	mov	eax, DWORD PTR _gameui
	push	eax
	call	_COM_FreeLibrary
	add	esp, 4

; 1101 : 	Mem_FreePool( &gameui.mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??UI_UnloadProgs@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DG@DEECGLBH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _gameui+68
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 1102 : 	memset( &gameui, 0, sizeof( gameui ));

	push	7068					; 00001b9cH
	push	0
	push	OFFSET _gameui
	call	_memset
	add	esp, 12					; 0000000cH

; 1103 : 
; 1104 : 	Cvar_Unlink( FCVAR_GAMEUIDLL );

	push	16384					; 00004000H
	call	_Cvar_Unlink
	add	esp, 4

; 1105 : 	Cmd_Unlink( CMD_GAMEUIDLL );

	push	4
	call	_Cmd_Unlink
	add	esp, 4
$LN1@UI_UnloadP:

; 1106 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_UnloadProgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_SetActiveMenu
_TEXT	SEGMENT
_cin_state$ = -4					; size = 4
_fActive$ = 8						; size = 4
_UI_SetActiveMenu PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 70   : 	movie_state_t	*cin_state;
; 71   : 
; 72   : 	if( !gameui.hInstance )

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_SetActi

; 73   : 	{
; 74   : 		if( !fActive )

	cmp	DWORD PTR _fActive$[ebp], 0
	jne	SHORT $LN3@UI_SetActi

; 75   : 			Key_SetKeyDest( key_game );

	push	1
	call	_Key_SetKeyDest
	add	esp, 4
$LN3@UI_SetActi:

; 76   : 		return;

	jmp	SHORT $LN1@UI_SetActi
$LN2@UI_SetActi:

; 77   : 	}
; 78   : 
; 79   : 	gameui.drawLogo = fActive;

	mov	eax, DWORD PTR _fActive$[ebp]
	mov	DWORD PTR _gameui+7052, eax

; 80   : 	gameui.dllFuncs.pfnSetActiveMenu( fActive );

	mov	eax, DWORD PTR _fActive$[ebp]
	push	eax
	call	DWORD PTR _gameui+28
	add	esp, 4

; 81   : 
; 82   : 	if( !fActive )

	cmp	DWORD PTR _fActive$[ebp], 0
	jne	SHORT $LN1@UI_SetActi

; 83   : 	{
; 84   : 		// close logo when menu is shutdown
; 85   : 		cin_state = AVI_GetState( CIN_LOGO );

	push	1
	call	_AVI_GetState
	add	esp, 4
	mov	DWORD PTR _cin_state$[ebp], eax

; 86   : 		AVI_CloseVideo( cin_state );

	mov	eax, DWORD PTR _cin_state$[ebp]
	push	eax
	call	_AVI_CloseVideo
	add	esp, 4
$LN1@UI_SetActi:

; 87   : 	}
; 88   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_SetActiveMenu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _UI_CreditsActive
_TEXT	SEGMENT
_UI_CreditsActive PROC					; COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 116  : 	if( !gameui.hInstance ) return 0;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@UI_Credits
	xor	eax, eax
	jmp	SHORT $LN1@UI_Credits
$LN2@UI_Credits:

; 117  : 	return gameui.dllFuncs.pfnCreditsActive();

	call	DWORD PTR _gameui+60
$LN1@UI_Credits:

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_UI_CreditsActive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_gameui.c
;	COMDAT _Host_Credits
_TEXT	SEGMENT
_Host_Credits PROC					; COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 241  : 	if( !gameui.hInstance ) return;

	cmp	DWORD PTR _gameui, 0
	jne	SHORT $LN2@Host_Credi
	jmp	SHORT $LN1@Host_Credi
$LN2@Host_Credi:

; 242  : 	gameui.dllFuncs.pfnFinalCredits();

	call	DWORD PTR _gameui+64
$LN1@Host_Credi:

; 243  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Host_Credits ENDP
_TEXT	ENDS
END
