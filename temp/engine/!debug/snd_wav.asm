; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\snd_wav.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Sound_LoadWAV
PUBLIC	_Stream_OpenWAV
PUBLIC	_Stream_ReadWAV
PUBLIC	_Stream_SetPosWAV
PUBLIC	_Stream_GetPosWAV
PUBLIC	_Stream_FreeWAV
PUBLIC	_StreamFindNextChunk
PUBLIC	?__LINE__Var@?0??Sound_LoadWAV@@9@9		; `Sound_LoadWAV'::`1'::__LINE__Var
PUBLIC	??_C@_04EPCGJKAP@RIFF@				; `string'
PUBLIC	??_C@_04HFHJMNCD@WAVE@				; `string'
PUBLIC	??_C@_0DJ@ILBOFMAC@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ ; `string'
PUBLIC	??_C@_04CAJPEBPP@fmt?5@				; `string'
PUBLIC	??_C@_0DD@FLIOKOOA@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ ; `string'
PUBLIC	??_C@_0DJ@HDOEAFLO@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5no@ ; `string'
PUBLIC	??_C@_0EJ@HAOAAPPF@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@ ; `string'
PUBLIC	??_C@_0EG@BIGPOIJL@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@ ; `string'
PUBLIC	??_C@_04GADGHILI@cue?5@				; `string'
PUBLIC	??_C@_04PCOPKCKE@LIST@				; `string'
PUBLIC	??_C@_04KJJCFCK@mark@				; `string'
PUBLIC	??_C@_04PJOLNDGD@data@				; `string'
PUBLIC	??_C@_0DD@EPKADKLE@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ ; `string'
PUBLIC	??_C@_0DE@JPLKKNIH@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5ha@ ; `string'
PUBLIC	??_C@_0DF@FJCGEHOM@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5file?5@ ; `string'
PUBLIC	??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??Stream_OpenWAV@@9@9		; `Stream_OpenWAV'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0DC@MGPCCEGN@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ ; `string'
PUBLIC	??_C@_0DC@PKLBAPBF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ ; `string'
PUBLIC	??_C@_0DE@HBJPLNEM@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ ; `string'
PUBLIC	??_C@_0DK@OHAFMKLF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5n@ ; `string'
PUBLIC	??_C@_0DE@GFLBCJBI@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ ; `string'
PUBLIC	?__LINE__Var@?0??Stream_FreeWAV@@9@9		; `Stream_FreeWAV'::`1'::__LINE__Var
EXTRN	_memcpy:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Eof:PROC
EXTRN	_FS_Close:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Sound_LoadMPG:PROC
EXTRN	_host:BYTE
EXTRN	_sound:BYTE
_BSS	SEGMENT
_iff_data DD	01H DUP (?)
_iff_dataPtr DD	01H DUP (?)
_iff_end DD	01H DUP (?)
_iff_lastChunk DD 01H DUP (?)
_iff_chunkLen DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?0??Stream_FreeWAV@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Stream_FreeWAV@@9@9 DD 01cdH		; `Stream_FreeWAV'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DE@GFLBCJBI@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
CONST	SEGMENT
??_C@_0DE@GFLBCJBI@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ DB '^1E'
	DB	'rror:^7 Stream_OpenWAV: %s missing ''data'' chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OHAFMKLF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5n@
CONST	SEGMENT
??_C@_0DK@OHAFMKLF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5n@ DB '^1E'
	DB	'rror:^7 Stream_OpenWAV: %s not a microsoft PCM format', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HBJPLNEM@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
CONST	SEGMENT
??_C@_0DE@HBJPLNEM@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ DB '^1E'
	DB	'rror:^7 Stream_OpenWAV: %s missing ''fmt '' chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PKLBAPBF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
CONST	SEGMENT
??_C@_0DC@PKLBAPBF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ DB '^1E'
	DB	'rror:^7 Stream_OpenWAV: %s missing WAVE chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MGPCCEGN@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
CONST	SEGMENT
??_C@_0DC@MGPCCEGN@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@ DB '^1E'
	DB	'rror:^7 Stream_OpenWAV: %s missing RIFF chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Stream_OpenWAV@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Stream_OpenWAV@@9@9 DD 0137H		; `Stream_OpenWAV'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\soundlib\snd_wav.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FJCGEHOM@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5file?5@
CONST	SEGMENT
??_C@_0DF@FJCGEHOM@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5file?5@ DB '^1Erro'
	DB	'r:^7 Sound_LoadWAV: file with %i samples (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JPLKKNIH@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5ha@
CONST	SEGMENT
??_C@_0DE@JPLKKNIH@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5ha@ DB '^1E'
	DB	'rror:^7 Sound_LoadWAV: %s has a bad loop length', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EPKADKLE@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
CONST	SEGMENT
??_C@_0DD@EPKADKLE@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ DB '^1E'
	DB	'rror:^7 Sound_LoadWAV: %s missing ''data'' chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data@
CONST	SEGMENT
??_C@_04PJOLNDGD@data@ DB 'data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJJCFCK@mark@
CONST	SEGMENT
??_C@_04KJJCFCK@mark@ DB 'mark', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCOPKCKE@LIST@
CONST	SEGMENT
??_C@_04PCOPKCKE@LIST@ DB 'LIST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GADGHILI@cue?5@
CONST	SEGMENT
??_C@_04GADGHILI@cue?5@ DB 'cue ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BIGPOIJL@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@
CONST	SEGMENT
??_C@_0EG@BIGPOIJL@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@ DB '^1Erro'
	DB	'r:^7 Sound_LoadWAV: only 8 and 16 bit WAV files supported (%s'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@HAOAAPPF@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@
CONST	SEGMENT
??_C@_0EJ@HAOAAPPF@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@ DB '^1Erro'
	DB	'r:^7 Sound_LoadWAV: only mono and stereo WAV files supported '
	DB	'(%s)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HDOEAFLO@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5no@
CONST	SEGMENT
??_C@_0DJ@HDOEAFLO@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5no@ DB '^1E'
	DB	'rror:^7 Sound_LoadWAV: %s not a microsoft PCM format', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FLIOKOOA@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
CONST	SEGMENT
??_C@_0DD@FLIOKOOA@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ DB '^1E'
	DB	'rror:^7 Sound_LoadWAV: %s missing ''fmt '' chunk', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAJPEBPP@fmt?5@
CONST	SEGMENT
??_C@_04CAJPEBPP@fmt?5@ DB 'fmt ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@ILBOFMAC@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
CONST	SEGMENT
??_C@_0DJ@ILBOFMAC@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@ DB '^1E'
	DB	'rror:^7 Sound_LoadWAV: %s missing ''RIFF/WAVE'' chunks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HFHJMNCD@WAVE@
CONST	SEGMENT
??_C@_04HFHJMNCD@WAVE@ DB 'WAVE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EPCGJKAP@RIFF@
CONST	SEGMENT
??_C@_04EPCGJKAP@RIFF@ DB 'RIFF', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Sound_LoadWAV@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Sound_LoadWAV@@9@9 DD 08fH		; `Sound_LoadWAV'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _StreamFindNextChunk
_TEXT	SEGMENT
_iff_chunk_len$ = -8					; size = 4
_chunkName$ = -4					; size = 4
_file$ = 8						; size = 4
_name$ = 12						; size = 4
_last_chunk$ = 16					; size = 4
_StreamFindNextChunk PROC				; COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
$LN2@StreamFind:

; 111  : 	char	chunkName[4];
; 112  : 	int	iff_chunk_len;
; 113  : 
; 114  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@StreamFind

; 115  : 	{
; 116  : 		FS_Seek( file, *last_chunk, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _last_chunk$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 117  : 
; 118  : 		if( FS_Eof( file ))

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Eof
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@StreamFind

; 119  : 			return false;	// didn't find the chunk

	xor	eax, eax
	jmp	$LN1@StreamFind
$LN4@StreamFind:

; 120  : 
; 121  : 		FS_Seek( file, 4, SEEK_CUR );

	push	1
	push	4
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 122  : 		FS_Read( file, &iff_chunk_len, sizeof( iff_chunk_len ));

	push	4
	lea	eax, DWORD PTR _iff_chunk_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 123  : 		if( iff_chunk_len < 0 )

	cmp	DWORD PTR _iff_chunk_len$[ebp], 0
	jge	SHORT $LN5@StreamFind

; 124  : 			return false;	// didn't find the chunk

	xor	eax, eax
	jmp	SHORT $LN1@StreamFind
$LN5@StreamFind:

; 125  : 
; 126  : 		FS_Seek( file, -8, SEEK_CUR );

	push	1
	push	-8					; fffffff8H
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 127  : 		*last_chunk = FS_Tell( file ) + 8 + (( iff_chunk_len + 1 ) & ~1 );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _iff_chunk_len$[ebp]
	add	ecx, 1
	and	ecx, -2					; fffffffeH
	lea	edx, DWORD PTR [eax+ecx+8]
	mov	eax, DWORD PTR _last_chunk$[ebp]
	mov	DWORD PTR [eax], edx

; 128  : 		FS_Read( file, chunkName, 4 );

	push	4
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 129  : 
; 130  : 		if( !Q_strncmp( chunkName, name, 4 ))

	push	4
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chunkName$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@StreamFind

; 131  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@StreamFind
$LN6@StreamFind:

; 132  : 	}

	jmp	$LN2@StreamFind
$LN3@StreamFind:

; 133  : 
; 134  : 	return false;

	xor	eax, eax
$LN1@StreamFind:

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_StreamFindNextChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _FindChunk
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FindChunk PROC						; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 100  : 	iff_lastChunk = iff_data;

	mov	eax, DWORD PTR _iff_data
	mov	DWORD PTR _iff_lastChunk, eax

; 101  : 	FindNextChunk( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FindNextChunk
	add	esp, 4

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FindChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _FindNextChunk
_TEXT	SEGMENT
_name$ = 8						; size = 4
_FindNextChunk PROC					; COMDAT

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN2@FindNextCh:

; 65   : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN1@FindNextCh

; 66   : 	{
; 67   : 		iff_dataPtr = iff_lastChunk;

	mov	eax, DWORD PTR _iff_lastChunk
	mov	DWORD PTR _iff_dataPtr, eax

; 68   : 
; 69   : 		if( iff_dataPtr >= iff_end )

	mov	eax, DWORD PTR _iff_dataPtr
	cmp	eax, DWORD PTR _iff_end
	jb	SHORT $LN4@FindNextCh

; 70   : 		{
; 71   : 			// didn't find the chunk
; 72   : 			iff_dataPtr = NULL;

	mov	DWORD PTR _iff_dataPtr, 0

; 73   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN4@FindNextCh:

; 74   : 		}
; 75   : 		
; 76   : 		iff_dataPtr += 4;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 4
	mov	DWORD PTR _iff_dataPtr, eax

; 77   : 		iff_chunkLen = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _iff_chunkLen, eax

; 78   : 
; 79   : 		if( iff_chunkLen < 0 )

	cmp	DWORD PTR _iff_chunkLen, 0
	jge	SHORT $LN5@FindNextCh

; 80   : 		{
; 81   : 			iff_dataPtr = NULL;

	mov	DWORD PTR _iff_dataPtr, 0

; 82   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN5@FindNextCh:

; 83   : 		}
; 84   : 
; 85   : 		iff_dataPtr -= 8;

	mov	eax, DWORD PTR _iff_dataPtr
	sub	eax, 8
	mov	DWORD PTR _iff_dataPtr, eax

; 86   : 		iff_lastChunk = iff_dataPtr + 8 + ((iff_chunkLen + 1) & ~1);

	mov	eax, DWORD PTR _iff_chunkLen
	add	eax, 1
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _iff_dataPtr
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _iff_lastChunk, edx

; 87   : 
; 88   : 		if( !Q_strncmp( iff_dataPtr, name, 4 ))

	push	4
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iff_dataPtr
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FindNextCh

; 89   : 			return;

	jmp	SHORT $LN1@FindNextCh
$LN6@FindNextCh:

; 90   : 	}

	jmp	$LN2@FindNextCh
$LN1@FindNextCh:

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FindNextChunk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _GetLittleLong
_TEXT	SEGMENT
_val$ = -4						; size = 4
_GetLittleLong PROC					; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 47   : 	int	val = 0;

	mov	DWORD PTR _val$[ebp], 0

; 48   : 
; 49   : 	val += (*(iff_dataPtr+0) << 0);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 50   : 	val += (*(iff_dataPtr+1) << 8);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 8
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 51   : 	val += (*(iff_dataPtr+2) <<16);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax+2]
	shl	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 52   : 	val += (*(iff_dataPtr+3) <<24);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax+3]
	shl	ecx, 24					; 00000018H
	add	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], ecx

; 53   : 	iff_dataPtr += 4;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 4
	mov	DWORD PTR _iff_dataPtr, eax

; 54   : 
; 55   : 	return val;

	mov	eax, DWORD PTR _val$[ebp]

; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetLittleLong ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _GetLittleShort
_TEXT	SEGMENT
_val$ = -4						; size = 2
_GetLittleShort PROC					; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 31   : 	short	val = 0;

	xor	eax, eax
	mov	WORD PTR _val$[ebp], ax

; 32   : 
; 33   : 	val += (*(iff_dataPtr+0) << 0);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax]
	movsx	edx, WORD PTR _val$[ebp]
	add	edx, ecx
	mov	WORD PTR _val$[ebp], dx

; 34   : 	val += (*(iff_dataPtr+1) << 8);

	mov	eax, DWORD PTR _iff_dataPtr
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 8
	movsx	edx, WORD PTR _val$[ebp]
	add	edx, ecx
	mov	WORD PTR _val$[ebp], dx

; 35   : 	iff_dataPtr += 2;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 2
	mov	DWORD PTR _iff_dataPtr, eax

; 36   : 
; 37   : 	return val;

	movzx	eax, WORD PTR _val$[ebp]

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetLittleShort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Stream_FreeWAV
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_FreeWAV PROC					; COMDAT

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 462  : 	if( stream->file )

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Stream_Fre

; 463  : 		FS_Close( stream->file );

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN2@Stream_Fre:

; 464  : 	Mem_Free( stream );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_FreeWAV@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 465  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_FreeWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Stream_GetPosWAV
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_Stream_GetPosWAV PROC					; COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 450  : 	return stream->pos;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [eax+8224]

; 451  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_GetPosWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Stream_SetPosWAV
_TEXT	SEGMENT
_stream$ = 8						; size = 4
_newpos$ = 12						; size = 4
_Stream_SetPosWAV PROC					; COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 431  : 	// NOTE: stream->pos it's real file position without header size
; 432  : 	if( FS_Seek( stream->file, stream->buffsize + newpos, SEEK_SET ) != -1 )

	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8228]
	add	ecx, DWORD PTR _newpos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	je	SHORT $LN2@Stream_Set

; 433  : 	{
; 434  : 		stream->pos = newpos;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _newpos$[ebp]
	mov	DWORD PTR [eax+8224], ecx

; 435  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@Stream_Set
$LN2@Stream_Set:

; 436  : 	}
; 437  : 
; 438  : 	return false;

	xor	eax, eax
$LN1@Stream_Set:

; 439  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_SetPosWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Stream_ReadWAV
_TEXT	SEGMENT
_remaining$ = -4					; size = 4
_stream$ = 8						; size = 4
_bytes$ = 12						; size = 4
_buffer$ = 16						; size = 4
_Stream_ReadWAV PROC					; COMDAT

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 408  : 	int	remaining;
; 409  : 
; 410  : 	if( !stream->file ) return 0;	// invalid file

	mov	eax, DWORD PTR _stream$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@Stream_Rea
	xor	eax, eax
	jmp	SHORT $LN1@Stream_Rea
$LN2@Stream_Rea:

; 411  : 
; 412  : 	remaining = stream->size - stream->pos;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [eax+24]
	sub	edx, DWORD PTR [ecx+8224]
	mov	DWORD PTR _remaining$[ebp], edx

; 413  : 	if( remaining <= 0 ) return 0;

	cmp	DWORD PTR _remaining$[ebp], 0
	jg	SHORT $LN3@Stream_Rea
	xor	eax, eax
	jmp	SHORT $LN1@Stream_Rea
$LN3@Stream_Rea:

; 414  : 	if( bytes > remaining ) bytes = remaining;

	mov	eax, DWORD PTR _bytes$[ebp]
	cmp	eax, DWORD PTR _remaining$[ebp]
	jle	SHORT $LN4@Stream_Rea
	mov	eax, DWORD PTR _remaining$[ebp]
	mov	DWORD PTR _bytes$[ebp], eax
$LN4@Stream_Rea:

; 415  : 
; 416  : 	stream->pos += bytes;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax+8224]
	add	ecx, DWORD PTR _bytes$[ebp]
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx+8224], ecx

; 417  : 	FS_Read( stream->file, buffer, bytes );

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 418  : 
; 419  : 	return bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
$LN1@Stream_Rea:

; 420  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_ReadWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Stream_OpenWAV
_TEXT	SEGMENT
_t$ = -24						; size = 2
_file$ = -20						; size = 4
_iff_data$ = -16					; size = 4
_chunkName$ = -12					; size = 4
_last_chunk$ = -8					; size = 4
_stream$ = -4						; size = 4
_filename$ = 8						; size = 4
_Stream_OpenWAV PROC					; COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 312  : 	stream_t	*stream;
; 313  : 	int 	last_chunk = 0;

	mov	DWORD PTR _last_chunk$[ebp], 0

; 314  : 	char	chunkName[4];
; 315  : 	int	iff_data;
; 316  : 	file_t	*file;
; 317  : 	short	t;
; 318  : 
; 319  : 	if( !filename || !*filename )

	cmp	DWORD PTR _filename$[ebp], 0
	je	SHORT $LN3@Stream_Ope
	mov	eax, DWORD PTR _filename$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Stream_Ope
$LN3@Stream_Ope:

; 320  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN2@Stream_Ope:

; 321  : 
; 322  : 	// open
; 323  : 	file = FS_Open( filename, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 324  : 	if( !file ) return NULL;	

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN4@Stream_Ope
	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN4@Stream_Ope:

; 325  : 
; 326  : 	// find "RIFF" chunk
; 327  : 	if( !StreamFindNextChunk( file, "RIFF", &last_chunk ))

	lea	eax, DWORD PTR _last_chunk$[ebp]
	push	eax
	push	OFFSET ??_C@_04EPCGJKAP@RIFF@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Stream_Ope

; 328  : 	{
; 329  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing RIFF chunk\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@MGPCCEGN@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
	call	_Con_DPrintf
	add	esp, 8

; 330  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 331  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN5@Stream_Ope:

; 332  : 	}
; 333  : 
; 334  : 	FS_Read( file, chunkName, 4 );

	push	4
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 335  : 	if( !Q_strncmp( chunkName, "WAVE", 4 ))

	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE@
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@Stream_Ope

; 336  : 	{
; 337  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing WAVE chunk\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@PKLBAPBF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
	call	_Con_DPrintf
	add	esp, 8

; 338  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 339  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN6@Stream_Ope:

; 340  : 	}
; 341  : 
; 342  : 	// get "fmt " chunk
; 343  : 	iff_data = FS_Tell( file ) + 4;

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR _iff_data$[ebp], eax

; 344  : 	last_chunk = iff_data;

	mov	eax, DWORD PTR _iff_data$[ebp]
	mov	DWORD PTR _last_chunk$[ebp], eax

; 345  : 	if( !StreamFindNextChunk( file, "fmt ", &last_chunk ))

	lea	eax, DWORD PTR _last_chunk$[ebp]
	push	eax
	push	OFFSET ??_C@_04CAJPEBPP@fmt?5@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@Stream_Ope

; 346  : 	{
; 347  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing 'fmt ' chunk\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@HBJPLNEM@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
	call	_Con_DPrintf
	add	esp, 8

; 348  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 349  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN7@Stream_Ope:

; 350  : 	}
; 351  : 
; 352  : 	FS_Read( file, chunkName, 4 );

	push	4
	lea	eax, DWORD PTR _chunkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 353  : 
; 354  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 355  : 	if( t != 1 )

	movsx	eax, WORD PTR _t$[ebp]
	cmp	eax, 1
	je	SHORT $LN8@Stream_Ope

; 356  : 	{
; 357  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s not a microsoft PCM format\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@OHAFMKLF@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5n@
	call	_Con_DPrintf
	add	esp, 8

; 358  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 359  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN8@Stream_Ope:

; 360  : 	}
; 361  : 
; 362  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 363  : 	sound.channels = t;

	movsx	eax, WORD PTR _t$[ebp]
	mov	DWORD PTR _sound+20, eax

; 364  : 
; 365  : 	FS_Read( file, &sound.rate, sizeof( int ));

	push	4
	push	OFFSET _sound+12
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 366  : 
; 367  : 	FS_Seek( file, 6, SEEK_CUR );

	push	1
	push	6
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 368  : 
; 369  : 	FS_Read( file, &t, sizeof( t ));

	push	2
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 370  : 	sound.width = t / 8;

	movsx	eax, WORD PTR _t$[ebp]
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _sound+16, eax

; 371  : 
; 372  : 	sound.loopstart = 0;

	mov	DWORD PTR _sound+24, 0

; 373  : 
; 374  : 	// find data chunk
; 375  : 	last_chunk = iff_data;

	mov	eax, DWORD PTR _iff_data$[ebp]
	mov	DWORD PTR _last_chunk$[ebp], eax

; 376  : 	if( !StreamFindNextChunk( file, "data", &last_chunk ))

	lea	eax, DWORD PTR _last_chunk$[ebp]
	push	eax
	push	OFFSET ??_C@_04PJOLNDGD@data@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_StreamFindNextChunk
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Stream_Ope

; 377  : 	{
; 378  : 		Con_DPrintf( S_ERROR "Stream_OpenWAV: %s missing 'data' chunk\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@GFLBCJBI@?$FO1Error?3?$FO7?5Stream_OpenWAV?3?5?$CFs?5m@
	call	_Con_DPrintf
	add	esp, 8

; 379  : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 380  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@Stream_Ope
$LN9@Stream_Ope:

; 381  : 	}
; 382  : 
; 383  : 	FS_Read( file, &sound.samples, sizeof( int ));

	push	4
	push	OFFSET _sound+28
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 384  : 	sound.samples = ( sound.samples / sound.width ) / sound.channels;

	mov	eax, DWORD PTR _sound+28
	xor	edx, edx
	div	DWORD PTR _sound+16
	xor	edx, edx
	div	DWORD PTR _sound+20
	mov	DWORD PTR _sound+28, eax

; 385  : 
; 386  : 	// at this point we have valid stream
; 387  : 	stream = Mem_Calloc( host.soundpool, sizeof( stream_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Stream_OpenWAV@@9@9
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET ??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	8232					; 00002028H
	mov	ecx, DWORD PTR _host+34748
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _stream$[ebp], eax

; 388  : 	stream->file = file;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 389  : 	stream->size = sound.samples * sound.width * sound.channels;

	mov	eax, DWORD PTR _sound+28
	imul	eax, DWORD PTR _sound+16
	imul	eax, DWORD PTR _sound+20
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 390  : 	stream->buffsize = FS_Tell( file ); // header length

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx+8228], eax

; 391  : 	stream->channels = sound.channels;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sound+20
	mov	DWORD PTR [eax+16], ecx

; 392  : 	stream->width = sound.width;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sound+16
	mov	DWORD PTR [eax+8], ecx

; 393  : 	stream->rate = sound.rate;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR _sound+12
	mov	DWORD PTR [eax+12], ecx

; 394  : 	stream->type = WF_PCMDATA;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [eax+20], 1

; 395  : 	
; 396  : 	return stream;

	mov	eax, DWORD PTR _stream$[ebp]
$LN1@Stream_Ope:

; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Stream_OpenWAV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\soundlib\snd_wav.c
;	COMDAT _Sound_LoadWAV
_TEXT	SEGMENT
_pData$1 = -28						; size = 4
_j$2 = -24						; size = 4
_i$3 = -20						; size = 4
_hdr_size$4 = -16					; size = 4
_mpeg_stream$ = -12					; size = 4
_fmt$ = -8						; size = 4
_samples$ = -4						; size = 4
_name$ = 8						; size = 4
_buffer$ = 12						; size = 4
_filesize$ = 16						; size = 4
_Sound_LoadWAV PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 144  : 	int	samples, fmt;
; 145  : 	qboolean	mpeg_stream = false;

	mov	DWORD PTR _mpeg_stream$[ebp], 0

; 146  : 
; 147  : 	if( !buffer || filesize <= 0 )

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN9@Sound_Load
	cmp	DWORD PTR _filesize$[ebp], 0
	ja	SHORT $LN8@Sound_Load
$LN9@Sound_Load:

; 148  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN8@Sound_Load:

; 149  : 
; 150  : 	iff_data = buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _iff_data, eax

; 151  : 	iff_end = buffer + filesize;

	mov	eax, DWORD PTR _buffer$[ebp]
	add	eax, DWORD PTR _filesize$[ebp]
	mov	DWORD PTR _iff_end, eax

; 152  : 
; 153  : 	// find "RIFF" chunk
; 154  : 	FindChunk( "RIFF" );

	push	OFFSET ??_C@_04EPCGJKAP@RIFF@
	call	_FindChunk
	add	esp, 4

; 155  : 
; 156  : 	if( !( iff_dataPtr && !Q_strncmp( iff_dataPtr + 8, "WAVE", 4 )))

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN11@Sound_Load
	push	4
	push	OFFSET ??_C@_04HFHJMNCD@WAVE@
	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 8
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN10@Sound_Load
$LN11@Sound_Load:

; 157  : 	{
; 158  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'RIFF/WAVE' chunks\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@ILBOFMAC@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
	call	_Con_DPrintf
	add	esp, 8

; 159  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN10@Sound_Load:

; 160  : 	}
; 161  : 
; 162  : 	// get "fmt " chunk
; 163  : 	iff_data = iff_dataPtr + 12;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _iff_data, eax

; 164  : 	FindChunk( "fmt " );

	push	OFFSET ??_C@_04CAJPEBPP@fmt?5@
	call	_FindChunk
	add	esp, 4

; 165  : 
; 166  : 	if( !iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	jne	SHORT $LN12@Sound_Load

; 167  : 	{
; 168  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'fmt ' chunk\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@FLIOKOOA@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
	call	_Con_DPrintf
	add	esp, 8

; 169  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN12@Sound_Load:

; 170  : 	}
; 171  : 
; 172  : 	iff_dataPtr += 8;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 8
	mov	DWORD PTR _iff_dataPtr, eax

; 173  : 	fmt = GetLittleShort();

	call	_GetLittleShort
	cwde
	mov	DWORD PTR _fmt$[ebp], eax

; 174  : 
; 175  : 	if( fmt != 1 )

	cmp	DWORD PTR _fmt$[ebp], 1
	je	SHORT $LN13@Sound_Load

; 176  : 	{
; 177  : 		if( fmt != 85 )

	cmp	DWORD PTR _fmt$[ebp], 85		; 00000055H
	je	SHORT $LN14@Sound_Load

; 178  : 		{
; 179  : 			Con_DPrintf( S_ERROR "Sound_LoadWAV: %s not a microsoft PCM format\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@HDOEAFLO@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5no@
	call	_Con_DPrintf
	add	esp, 8

; 180  : 			return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load

; 181  : 		}

	jmp	SHORT $LN13@Sound_Load
$LN14@Sound_Load:

; 182  : 		else
; 183  : 		{
; 184  : 			// mpeg stream in wav container
; 185  : 			mpeg_stream = true;

	mov	DWORD PTR _mpeg_stream$[ebp], 1
$LN13@Sound_Load:

; 186  : 		}
; 187  : 	}
; 188  : 
; 189  : 	sound.channels = GetLittleShort();

	call	_GetLittleShort
	cwde
	mov	DWORD PTR _sound+20, eax

; 190  : 	if( sound.channels != 1 && sound.channels != 2 )

	cmp	DWORD PTR _sound+20, 1
	je	SHORT $LN16@Sound_Load
	cmp	DWORD PTR _sound+20, 2
	je	SHORT $LN16@Sound_Load

; 191  : 	{
; 192  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: only mono and stereo WAV files supported (%s)\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EJ@HAOAAPPF@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@
	call	_Con_DPrintf
	add	esp, 8

; 193  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN16@Sound_Load:

; 194  : 	}
; 195  : 
; 196  : 	sound.rate = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _sound+12, eax

; 197  : 	iff_dataPtr += 6;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 6
	mov	DWORD PTR _iff_dataPtr, eax

; 198  : 
; 199  : 	sound.width = GetLittleShort() / 8;

	call	_GetLittleShort
	cwde
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _sound+16, eax

; 200  : 	if( mpeg_stream ) sound.width = 2; // mp3 always 16bit

	cmp	DWORD PTR _mpeg_stream$[ebp], 0
	je	SHORT $LN17@Sound_Load
	mov	DWORD PTR _sound+16, 2
$LN17@Sound_Load:

; 201  : 
; 202  : 	if( sound.width != 1 && sound.width != 2 )

	cmp	DWORD PTR _sound+16, 1
	je	SHORT $LN18@Sound_Load
	cmp	DWORD PTR _sound+16, 2
	je	SHORT $LN18@Sound_Load

; 203  : 	{
; 204  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: only 8 and 16 bit WAV files supported (%s)\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0EG@BIGPOIJL@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5only?5@
	call	_Con_DPrintf
	add	esp, 8

; 205  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN18@Sound_Load:

; 206  : 	}
; 207  : 
; 208  : 	// get cue chunk
; 209  : 	FindChunk( "cue " );

	push	OFFSET ??_C@_04GADGHILI@cue?5@
	call	_FindChunk
	add	esp, 4

; 210  : 
; 211  : 	if( iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN19@Sound_Load

; 212  : 	{
; 213  : 		iff_dataPtr += 32;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 32					; 00000020H
	mov	DWORD PTR _iff_dataPtr, eax

; 214  : 		sound.loopstart = GetLittleLong();

	call	_GetLittleLong
	mov	DWORD PTR _sound+24, eax

; 215  : 		FindNextChunk( "LIST" ); // if the next chunk is a LIST chunk, look for a cue length marker

	push	OFFSET ??_C@_04PCOPKCKE@LIST@
	call	_FindNextChunk
	add	esp, 4

; 216  : 
; 217  : 		if( iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	je	SHORT $LN21@Sound_Load

; 218  : 		{
; 219  : 			if( !Q_strncmp( iff_dataPtr + 28, "mark", 4 ))

	push	4
	push	OFFSET ??_C@_04KJJCFCK@mark@
	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 28					; 0000001cH
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@Sound_Load

; 220  : 			{	
; 221  : 				// this is not a proper parse, but it works with CoolEdit...
; 222  : 				iff_dataPtr += 24;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 24					; 00000018H
	mov	DWORD PTR _iff_dataPtr, eax

; 223  : 				sound.samples = sound.loopstart + GetLittleLong(); // samples in loop

	call	_GetLittleLong
	add	eax, DWORD PTR _sound+24
	mov	DWORD PTR _sound+28, eax
$LN21@Sound_Load:

; 224  : 			}
; 225  : 		}
; 226  : 	}

	jmp	SHORT $LN20@Sound_Load
$LN19@Sound_Load:

; 227  : 	else 
; 228  : 	{
; 229  : 		sound.loopstart = -1;

	mov	DWORD PTR _sound+24, -1

; 230  : 		sound.samples = 0;

	mov	DWORD PTR _sound+28, 0
$LN20@Sound_Load:

; 231  : 	}
; 232  : 
; 233  : 	// find data chunk
; 234  : 	FindChunk( "data" );

	push	OFFSET ??_C@_04PJOLNDGD@data@
	call	_FindChunk
	add	esp, 4

; 235  : 
; 236  : 	if( !iff_dataPtr )

	cmp	DWORD PTR _iff_dataPtr, 0
	jne	SHORT $LN23@Sound_Load

; 237  : 	{
; 238  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: %s missing 'data' chunk\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@EPKADKLE@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5mi@
	call	_Con_DPrintf
	add	esp, 8

; 239  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN23@Sound_Load:

; 240  : 	}
; 241  : 
; 242  : 	iff_dataPtr += 4;

	mov	eax, DWORD PTR _iff_dataPtr
	add	eax, 4
	mov	DWORD PTR _iff_dataPtr, eax

; 243  : 	samples = GetLittleLong() / sound.width;

	call	_GetLittleLong
	cdq
	idiv	DWORD PTR _sound+16
	mov	DWORD PTR _samples$[ebp], eax

; 244  : 
; 245  : 	if( sound.samples )

	cmp	DWORD PTR _sound+28, 0
	je	SHORT $LN24@Sound_Load

; 246  : 	{
; 247  : 		if( samples < sound.samples )

	mov	eax, DWORD PTR _samples$[ebp]
	cmp	eax, DWORD PTR _sound+28
	jae	SHORT $LN26@Sound_Load

; 248  : 		{
; 249  : 			Con_DPrintf( S_ERROR "Sound_LoadWAV: %s has a bad loop length\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@JPLKKNIH@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5?$CFs?5ha@
	call	_Con_DPrintf
	add	esp, 8

; 250  : 			return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN26@Sound_Load:

; 251  : 		}
; 252  : 	}

	jmp	SHORT $LN25@Sound_Load
$LN24@Sound_Load:

; 253  : 	else sound.samples = samples;

	mov	eax, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _sound+28, eax
$LN25@Sound_Load:

; 254  : 
; 255  : 	if( sound.samples <= 0 )

	cmp	DWORD PTR _sound+28, 0
	ja	SHORT $LN27@Sound_Load

; 256  : 	{
; 257  : 		Con_DPrintf( S_ERROR "Sound_LoadWAV: file with %i samples (%s)\n", sound.samples, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sound+28
	push	ecx
	push	OFFSET ??_C@_0DF@FJCGEHOM@?$FO1Error?3?$FO7?5Sound_LoadWAV?3?5file?5@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 258  : 		return false;

	xor	eax, eax
	jmp	$LN1@Sound_Load
$LN27@Sound_Load:

; 259  : 	}
; 260  : 
; 261  : 	sound.type = WF_PCMDATA;

	mov	DWORD PTR _sound+8, 1

; 262  : 	sound.samples /= sound.channels;

	mov	eax, DWORD PTR _sound+28
	xor	edx, edx
	div	DWORD PTR _sound+20
	mov	DWORD PTR _sound+28, eax

; 263  : 
; 264  : 	// g-cont. get support for mp3 streams packed in wav container
; 265  : 	// e.g. CAd menu sounds
; 266  : 	if( mpeg_stream )

	cmp	DWORD PTR _mpeg_stream$[ebp], 0
	je	$LN28@Sound_Load

; 267  : 	{
; 268  : 		int	hdr_size = (iff_dataPtr - buffer);

	mov	eax, DWORD PTR _iff_dataPtr
	sub	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _hdr_size$4[ebp], eax

; 269  : 
; 270  : 		if(( filesize - hdr_size ) < FRAME_SIZE )

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _hdr_size$4[ebp]
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN29@Sound_Load

; 271  : 		{
; 272  : 			sound.tempbuffer = (byte *)Mem_Realloc( host.soundpool, sound.tempbuffer, FRAME_SIZE );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Sound_LoadWAV@@9@9
	add	eax, 129				; 00000081H
	push	eax
	push	OFFSET ??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	32768					; 00008000H
	mov	ecx, DWORD PTR _sound+44
	push	ecx
	mov	edx, DWORD PTR _host+34748
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR _sound+44, eax

; 273  : 			memcpy( sound.tempbuffer, buffer + (iff_dataPtr - buffer), filesize - hdr_size );

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _hdr_size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _iff_dataPtr
	push	ecx
	mov	edx, DWORD PTR _sound+44
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 274  : 			return Sound_LoadMPG( name, sound.tempbuffer, FRAME_SIZE );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _sound+44
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Sound_LoadMPG
	add	esp, 12					; 0000000cH
	jmp	$LN1@Sound_Load
$LN29@Sound_Load:

; 275  : 		}
; 276  : 
; 277  : 		return Sound_LoadMPG( name, buffer + hdr_size, filesize - hdr_size );

	mov	eax, DWORD PTR _filesize$[ebp]
	sub	eax, DWORD PTR _hdr_size$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _hdr_size$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Sound_LoadMPG
	add	esp, 12					; 0000000cH
	jmp	$LN1@Sound_Load
$LN28@Sound_Load:

; 278  : 	}
; 279  : 
; 280  : 	// Load the data
; 281  : 	sound.size = sound.samples * sound.width * sound.channels;

	mov	eax, DWORD PTR _sound+28
	imul	eax, DWORD PTR _sound+16
	imul	eax, DWORD PTR _sound+20
	mov	DWORD PTR _sound+36, eax

; 282  : 	sound.wav = Mem_Malloc( host.soundpool, sound.size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Sound_LoadWAV@@9@9
	add	eax, 139				; 0000008bH
	push	eax
	push	OFFSET ??_C@_0DN@MNJMDOMP@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _sound+36
	push	ecx
	mov	edx, DWORD PTR _host+34748
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _sound+40, eax

; 283  : 
; 284  : 	memcpy( sound.wav, buffer + (iff_dataPtr - buffer), sound.size );

	mov	eax, DWORD PTR _sound+36
	push	eax
	mov	ecx, DWORD PTR _iff_dataPtr
	push	ecx
	mov	edx, DWORD PTR _sound+40
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 285  : 
; 286  : 	// now convert 8-bit sounds to signed
; 287  : 	if( sound.width == 1 )

	cmp	DWORD PTR _sound+16, 1
	jne	SHORT $LN30@Sound_Load

; 288  : 	{
; 289  : 		int	i, j;
; 290  : 		char	*pData = sound.wav;

	mov	eax, DWORD PTR _sound+40
	mov	DWORD PTR _pData$1[ebp], eax

; 291  : 
; 292  : 		for( i = 0; i < sound.samples; i++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@Sound_Load
$LN2@Sound_Load:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@Sound_Load:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _sound+28
	jae	SHORT $LN30@Sound_Load

; 293  : 		{
; 294  : 			for( j = 0; j < sound.channels; j++ )

	mov	DWORD PTR _j$2[ebp], 0
	jmp	SHORT $LN7@Sound_Load
$LN5@Sound_Load:
	mov	eax, DWORD PTR _j$2[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
$LN7@Sound_Load:
	mov	eax, DWORD PTR _j$2[ebp]
	cmp	eax, DWORD PTR _sound+20
	jge	SHORT $LN6@Sound_Load

; 295  : 			{
; 296  : 				*pData = (byte)((int)((byte)*pData) - 128 );

	mov	eax, DWORD PTR _pData$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _pData$1[ebp]
	mov	BYTE PTR [edx], cl

; 297  : 				pData++;

	mov	eax, DWORD PTR _pData$1[ebp]
	add	eax, 1
	mov	DWORD PTR _pData$1[ebp], eax

; 298  : 			}

	jmp	SHORT $LN5@Sound_Load
$LN6@Sound_Load:

; 299  : 		}

	jmp	SHORT $LN2@Sound_Load
$LN30@Sound_Load:

; 300  : 	}
; 301  : 
; 302  : 	return true;

	mov	eax, 1
$LN1@Sound_Load:

; 303  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Sound_LoadWAV ENDP
_TEXT	ENDS
END
