; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_frame.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_CL_ExtraUpdate
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_CL_EDICT_NUM
PUBLIC	_CL_ParsePacketEntities
PUBLIC	_CL_AddVisibleEntity
PUBLIC	_CL_ResetLatchedVars
PUBLIC	_CL_GetEntitySpatialization
PUBLIC	_CL_GetMovieSpatialization
PUBLIC	_CL_ProcessPlayerState
PUBLIC	_CL_ComputePlayerOrigin
PUBLIC	_CL_ProcessPacket
PUBLIC	_CL_MoveThirdpersonCamera
PUBLIC	_CL_IsPlayerIndex
PUBLIC	_CL_EmitEntities
PUBLIC	_CL_UpdatePositions
PUBLIC	_CL_ResetPositions
PUBLIC	_CL_EntityTeleported
PUBLIC	_CL_CompareTimestamps
PUBLIC	_CL_EntityIgnoreLerp
PUBLIC	_CL_EntityCustomLerp
PUBLIC	_CL_ParametricMove
PUBLIC	_CL_UpdateLatchedVars
PUBLIC	_CL_ProcessEntityUpdate
PUBLIC	_CL_FindInterpolationUpdates
PUBLIC	_CL_PureOrigin
PUBLIC	_CL_InterpolateModel
PUBLIC	_CL_ResetLatchedState
PUBLIC	_CL_FlushEntityPacket
PUBLIC	_CL_DeltaEntity
PUBLIC	_CL_LinkCustomEntity
PUBLIC	_CL_LinkPlayers
PUBLIC	_CL_LinkPacketEntities
PUBLIC	??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0CA@LBBNMMJJ@CL_FlushEntityPacket?3?5overflow?6@ ; `string'
PUBLIC	??_C@_0CP@CPJNJAH@?$FO1Error?3?$FO7?5CL_DeltaEntity?3?5inva@ ; `string'
PUBLIC	??_C@_0CA@KFJDBNOP@?$FO3Warning?3?$FO1?5update?5too?5old?6?$FO7?6@ ; `string'
PUBLIC	??_C@_0CH@BFLDNJMA@?$FO3Warning?3?$FO1?5delta?5frame?5is?5too@ ; `string'
PUBLIC	??_C@_0CC@PGNDCAEK@CL_ParsePacketEntities?3?5overflo@ ; `string'
PUBLIC	??_C@_05NFMIDMMK@Delta@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0DK@CEPLGCJC@?$FO3Warning?3?$FO7?5CL_Parse?$CFsPacketEn@ ; `string'
PUBLIC	??_C@_0CH@FBOBLHAE@?$FO3Warning?3?$FO7?5bad?5model?5on?5beam?5@ ; `string'
PUBLIC	??_C@_0CP@BJKOOCDE@?$FO1Error?3?$FO7?5CL_LinkPacketEntity?3@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40400000
PUBLIC	__real@447a0000
PUBLIC	__real@c0400000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_NET_IsLocalAddress:PROC
EXTRN	_COM_NormalizeAngles:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_CL_IsThirdPerson:PROC
EXTRN	_CL_GetEntityByIndex:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_NPrintf:PROC
EXTRN	_sqrt:PROC
EXTRN	_VectorAngles:PROC
EXTRN	_RadiusFromBounds:PROC
EXTRN	_AngleQuaternion:PROC
EXTRN	_QuaternionAngle:PROC
EXTRN	_QuaternionSlerp:PROC
EXTRN	_MSG_CheckOverflow:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadByte:PROC
EXTRN	_CL_RunLightStyles:PROC
EXTRN	_CL_DecayLights:PROC
EXTRN	_CL_UpdateFrameLerp:PROC
EXTRN	_CL_SignonReply:PROC
EXTRN	_CL_WriteDemoJumpTime:PROC
EXTRN	_CL_FireEvents:PROC
EXTRN	_CL_ModelHandle:PROC
EXTRN	_CL_GetLocalPlayer:PROC
EXTRN	_CL_SetSolidEntities:PROC
EXTRN	_CL_CheckPredictionError:PROC
EXTRN	_CL_MoveSpectatorCamera:PROC
EXTRN	_CL_SetIdealPitch:PROC
EXTRN	_CL_TestLights:PROC
EXTRN	_CL_TempEntUpdate:PROC
EXTRN	_CL_AddCustomBeam:PROC
EXTRN	_CL_KillDeadBeams:PROC
EXTRN	_S_ExtraUpdate:PROC
EXTRN	_MSG_ReadDeltaEntity:PROC
EXTRN	_R_ClearScene:PROC
EXTRN	_R_StudioLerpMovement:PROC
EXTRN	_CL_GetStudioEstimatedFrame:PROC
EXTRN	_R_AddEntity:PROC
EXTRN	_CL_AddEntityEffects:PROC
EXTRN	_CL_AddModelEffects:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_host:BYTE
EXTRN	_world:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_interp:DWORD
EXTRN	_cl_bmodelinterp:DWORD
EXTRN	_RI:BYTE
EXTRN	_gl_allow_mirrors:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CP@BJKOOCDE@?$FO1Error?3?$FO7?5CL_LinkPacketEntity?3@
CONST	SEGMENT
??_C@_0CP@BJKOOCDE@?$FO1Error?3?$FO7?5CL_LinkPacketEntity?3@ DB '^1Error:'
	DB	'^7 CL_LinkPacketEntity: bad entity %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FBOBLHAE@?$FO3Warning?3?$FO7?5bad?5model?5on?5beam?5@
CONST	SEGMENT
??_C@_0CH@FBOBLHAE@?$FO3Warning?3?$FO7?5bad?5model?5on?5beam?5@ DB '^3War'
	DB	'ning:^7 bad model on beam ( %s )', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CEPLGCJC@?$FO3Warning?3?$FO7?5CL_Parse?$CFsPacketEn@
CONST	SEGMENT
??_C@_0DK@CEPLGCJC@?$FO3Warning?3?$FO7?5CL_Parse?$CFsPacketEn@ DB '^3Warn'
	DB	'ing:^7 CL_Parse%sPacketEntities: (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFMIDMMK@Delta@
CONST	SEGMENT
??_C@_05NFMIDMMK@Delta@ DB 'Delta', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PGNDCAEK@CL_ParsePacketEntities?3?5overflo@
CONST	SEGMENT
??_C@_0CC@PGNDCAEK@CL_ParsePacketEntities?3?5overflo@ DB 'CL_ParsePacketE'
	DB	'ntities: overflow', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BFLDNJMA@?$FO3Warning?3?$FO1?5delta?5frame?5is?5too@
CONST	SEGMENT
??_C@_0CH@BFLDNJMA@?$FO3Warning?3?$FO1?5delta?5frame?5is?5too@ DB '^3Warn'
	DB	'ing:^1 delta frame is too old^7', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KFJDBNOP@?$FO3Warning?3?$FO1?5update?5too?5old?6?$FO7?6@
CONST	SEGMENT
??_C@_0CA@KFJDBNOP@?$FO3Warning?3?$FO1?5update?5too?5old?6?$FO7?6@ DB '^3'
	DB	'Warning:^1 update too old', 0aH, '^7', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CPJNJAH@?$FO1Error?3?$FO7?5CL_DeltaEntity?3?5inva@
CONST	SEGMENT
??_C@_0CP@CPJNJAH@?$FO1Error?3?$FO7?5CL_DeltaEntity?3?5inva@ DB '^1Error:'
	DB	'^7 CL_DeltaEntity: invalid newnum: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBBNMMJJ@CL_FlushEntityPacket?3?5overflow?6@
CONST	SEGMENT
??_C@_0CA@LBBNMMJJ@CL_FlushEntityPacket?3?5overflow?6@ DB 'CL_FlushEntity'
	DB	'Packet: overflow', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
CONST	SEGMENT
??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@ DB 'CL_EDICT_NUM'
	DB	': bad number %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0fcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	07edH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0424H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0167H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0a6H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02b5H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_LinkPacketEntities
_TEXT	SEGMENT
tv140 = -88						; size = 4
_i$ = -20						; size = 4
_interpolate$ = -16					; size = 4
_parametric$ = -12					; size = 4
_state$ = -8						; size = 4
_ent$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_LinkPacketEntities PROC				; COMDAT

; 1088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1089 : 	cl_entity_t	*ent;
; 1090 : 	entity_state_t	*state;
; 1091 : 	qboolean		parametric;
; 1092 : 	qboolean		interpolate;
; 1093 : 	int		i;
; 1094 : 
; 1095 : 	for( i = 0; i < frame->num_entities; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_LinkPac
$LN2@CL_LinkPac:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_LinkPac:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jge	$LN3@CL_LinkPac

; 1096 : 	{
; 1097 : 		state = &cls.packet_entities[(frame->first_entity + i) % cls.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], ecx

; 1098 : 
; 1099 : 		// clients are should be done in CL_LinkPlayers
; 1100 : 		if( state->number >= 1 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jl	SHORT $LN5@CL_LinkPac
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _cl+2213004
	jg	SHORT $LN5@CL_LinkPac

; 1101 : 			continue;

	jmp	SHORT $LN2@CL_LinkPac
$LN5@CL_LinkPac:

; 1102 : 
; 1103 : 		// if set to invisible, skip
; 1104 : 		if( !state->modelindex || FBitSet( state->effects, EF_NODRAW ))

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN7@CL_LinkPac
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 128				; 00000080H
	je	SHORT $LN6@CL_LinkPac
$LN7@CL_LinkPac:

; 1105 : 			continue;

	jmp	SHORT $LN2@CL_LinkPac
$LN6@CL_LinkPac:

; 1106 : 
; 1107 : 		ent = CL_GetEntityByIndex( state->number );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1108 : 
; 1109 : 		if( !ent )

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN8@CL_LinkPac

; 1110 : 		{
; 1111 : 			Con_Reportf( S_ERROR "CL_LinkPacketEntity: bad entity %i\n", state->number );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0CP@BJKOOCDE@?$FO1Error?3?$FO7?5CL_LinkPacketEntity?3@
	call	_Con_Reportf
	add	esp, 8

; 1112 : 			continue;

	jmp	$LN2@CL_LinkPac
$LN8@CL_LinkPac:

; 1113 : 		}
; 1114 : 
; 1115 : 		// animtime must keep an actual
; 1116 : 		ent->curstate.animtime = state->animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+1004], edx

; 1117 : 		ent->curstate.frame = state->frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+960], edx

; 1118 : 		interpolate = false;

	mov	DWORD PTR _interpolate$[ebp], 0

; 1119 : 
; 1120 : 		if( !ent->model ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN9@CL_LinkPac
	jmp	$LN2@CL_LinkPac
$LN9@CL_LinkPac:

; 1121 : 
; 1122 : 		if( ent->curstate.rendermode == kRenderNormal )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN11@CL_LinkPac

; 1123 : 		{
; 1124 : 			// auto 'solid' faces
; 1125 : 			if( FBitSet( ent->model->flags, MODEL_TRANSPARENT ) && CL_IsQuakeCompatible( ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN11@CL_LinkPac
	call	_CL_IsQuakeCompatible
	test	eax, eax
	je	SHORT $LN11@CL_LinkPac

; 1126 : 			{
; 1127 : 				ent->curstate.rendermode = kRenderTransAlpha;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+984], 4

; 1128 : 				ent->curstate.renderamt = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN11@CL_LinkPac:

; 1129 : 			}
; 1130 : 		}
; 1131 : 
; 1132 : 		parametric = ( ent->curstate.impacttime != 0.0f && ent->curstate.starttime != 0.0f );

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1276]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@CL_LinkPac
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+1280]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@CL_LinkPac
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN42@CL_LinkPac
$LN41@CL_LinkPac:
	mov	DWORD PTR tv140[ebp], 0
$LN42@CL_LinkPac:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR _parametric$[ebp], edx

; 1133 : 
; 1134 : 		if( !parametric && ent->curstate.movetype != MOVETYPE_COMPOUND )

	cmp	DWORD PTR _parametric$[ebp], 0
	jne	$LN20@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1000], 14		; 0000000eH
	je	$LN20@CL_LinkPac

; 1135 : 		{
; 1136 : 			if( ent->curstate.animtime == ent->prevstate.animtime && !VectorCompare( ent->curstate.origin, ent->prevstate.origin ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	ucomiss	xmm0, DWORD PTR [ecx+552]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@CL_LinkPac
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+928]
	ucomiss	xmm0, DWORD PTR [esi+eax+476]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_LinkPac
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+928]
	ucomiss	xmm0, DWORD PTR [esi+ecx+476]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_LinkPac
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+928]
	ucomiss	xmm0, DWORD PTR [esi+ecx+476]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@CL_LinkPac
$LN14@CL_LinkPac:

; 1137 : 				ent->lastmove = cl.time + 0.2;

	movsd	xmm0, QWORD PTR _cl+2167640
	addsd	xmm0, QWORD PTR __real@3fc999999999999a
	cvtsd2ss xmm0, xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3220], xmm0
$LN13@CL_LinkPac:

; 1138 : 
; 1139 : 			if( FBitSet( ent->curstate.eflags, EFLAG_SLERP ))

	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+980]
	and	ecx, 1
	je	$LN20@CL_LinkPac

; 1140 : 			{
; 1141 : 				if( ent->curstate.animtime != 0.0f && ( ent->model->type == mod_alias || ent->model->type == mod_studio ))

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN20@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	je	SHORT $LN17@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	$LN20@CL_LinkPac
$LN17@CL_LinkPac:

; 1142 : 				{
; 1143 : #ifdef STUDIO_INTERPOLATION_FIX
; 1144 : 					if( ent->lastmove >= cl.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3220]
	comisd	xmm0, QWORD PTR _cl+2167640
	jb	SHORT $LN18@CL_LinkPac

; 1145 : 						VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3180], eax
$LN18@CL_LinkPac:

; 1146 : 					if( FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	je	SHORT $LN19@CL_LinkPac

; 1147 : 						interpolate = true;

	mov	DWORD PTR _interpolate$[ebp], 1
	jmp	SHORT $LN20@CL_LinkPac
$LN19@CL_LinkPac:

; 1148 : 					else ent->curstate.movetype = MOVETYPE_STEP;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+1000], 4
$LN20@CL_LinkPac:

; 1149 : #else
; 1150 : 					if( ent->lastmove >= cl.time )
; 1151 : 					{
; 1152 : 						CL_ResetLatchedVars( ent, true );
; 1153 : 						VectorCopy( ent->curstate.origin, ent->latched.prevorigin );
; 1154 : 						VectorCopy( ent->curstate.angles, ent->latched.prevangles );
; 1155 : 
; 1156 : 						// disable step interpolation in client.dll
; 1157 : 						ent->curstate.movetype = MOVETYPE_NONE;
; 1158 : 					}
; 1159 : 					else
; 1160 : 					{
; 1161 : 						// restore step interpolation in client.dll
; 1162 : 						ent->curstate.movetype = MOVETYPE_STEP;
; 1163 : 					}
; 1164 : #endif
; 1165 : 				}
; 1166 : 			}
; 1167 : 		}
; 1168 : 
; 1169 : 		if( ent->model->type == mod_brush )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN21@CL_LinkPac

; 1170 : 		{
; 1171 : 			CL_InterpolateModel( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_InterpolateModel
	add	esp, 4

; 1172 : 		}

	jmp	$LN32@CL_LinkPac
$LN21@CL_LinkPac:

; 1173 : 		else
; 1174 : 		{
; 1175 : 			if( parametric )

	cmp	DWORD PTR _parametric$[ebp], 0
	je	$LN23@CL_LinkPac

; 1176 : 			{
; 1177 : 				CL_ParametricMove( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ParametricMove
	add	esp, 4

; 1178 : 
; 1179 : 				VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 1180 : 				VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 1181 : 			}

	jmp	$LN29@CL_LinkPac
$LN23@CL_LinkPac:

; 1182 : 			else if( CL_EntityCustomLerp( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityCustomLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@CL_LinkPac

; 1183 : 			{
; 1184 : 				if ( !CL_InterpolateModel( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_InterpolateModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN27@CL_LinkPac

; 1185 : 					continue;

	jmp	$LN2@CL_LinkPac
$LN27@CL_LinkPac:

; 1186 : 			}

	jmp	$LN29@CL_LinkPac
$LN25@CL_LinkPac:

; 1187 : 			else if( ent->curstate.movetype == MOVETYPE_STEP && !NET_IsLocalAddress( cls.netchan.remote_address ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1000], 4
	jne	SHORT $LN28@CL_LinkPac
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _cls+26804
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _cls+26808
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _cls+26812
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _cls+26816
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _cls+26820
	mov	DWORD PTR [eax+16], ecx
	call	_NET_IsLocalAddress
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN28@CL_LinkPac

; 1188 : 			{
; 1189 : 				if( !CL_InterpolateModel( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_InterpolateModel
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN30@CL_LinkPac

; 1190 : 					continue;

	jmp	$LN2@CL_LinkPac
$LN30@CL_LinkPac:

; 1191 : 			}

	jmp	$LN29@CL_LinkPac
$LN28@CL_LinkPac:

; 1192 : 			else
; 1193 : 			{
; 1194 : 				// no interpolation right now
; 1195 : 				VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 1196 : 				VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax
$LN29@CL_LinkPac:

; 1197 : 			}
; 1198 : 
; 1199 : 			if( ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN32@CL_LinkPac

; 1200 : 			{
; 1201 : 				if( interpolate && FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP )) 

	cmp	DWORD PTR _interpolate$[ebp], 0
	je	SHORT $LN32@CL_LinkPac
	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	je	SHORT $LN32@CL_LinkPac

; 1202 : 					R_StudioLerpMovement( ent, cl.time, ent->origin, ent->angles );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3236				; 00000ca4H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3224				; 00000c98H
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_R_StudioLerpMovement
	add	esp, 20					; 00000014H
$LN32@CL_LinkPac:

; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 : 		if( !FBitSet( state->entityType, ENTITY_NORMAL ))

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $LN33@CL_LinkPac

; 1207 : 		{
; 1208 : 			CL_LinkCustomEntity( ent, state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_CL_LinkCustomEntity
	add	esp, 8

; 1209 : 			continue;

	jmp	$LN2@CL_LinkPac
$LN33@CL_LinkPac:

; 1210 : 		}
; 1211 : 
; 1212 : 		if( ent->model->type != mod_brush )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN35@CL_LinkPac

; 1213 : 		{
; 1214 : 			// NOTE: never pass sprites with rendercolor '0 0 0' it's a stupid Valve Hammer Editor bug
; 1215 : 			if( !ent->curstate.rendercolor.r && !ent->curstate.rendercolor.g && !ent->curstate.rendercolor.b )

	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+992]
	test	ecx, ecx
	jne	SHORT $LN35@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+993]
	test	ecx, ecx
	jne	SHORT $LN35@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	movzx	ecx, BYTE PTR [eax+994]
	test	ecx, ecx
	jne	SHORT $LN35@CL_LinkPac

; 1216 : 				ent->curstate.rendercolor.r = ent->curstate.rendercolor.g = ent->curstate.rendercolor.b = 255;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [eax+994], 255			; 000000ffH
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [ecx+993], 255			; 000000ffH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	BYTE PTR [edx+992], 255			; 000000ffH
$LN35@CL_LinkPac:

; 1217 : 		}
; 1218 : 
; 1219 : 		// XASH SPECIFIC
; 1220 : 		if( ent->curstate.rendermode == kRenderNormal && ent->curstate.renderfx == kRenderFxNone )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+984], 0
	jne	SHORT $LN36@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+996], 0
	jne	SHORT $LN36@CL_LinkPac

; 1221 : 			ent->curstate.renderamt = 255.0f;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+988], 255		; 000000ffH
$LN36@CL_LinkPac:

; 1222 : 
; 1223 : 		if( ent->curstate.aiment != 0 && ent->curstate.movetype != MOVETYPE_COMPOUND )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1100], 0
	je	SHORT $LN37@CL_LinkPac
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+1000], 14		; 0000000eH
	je	SHORT $LN37@CL_LinkPac

; 1224 : 			ent->curstate.movetype = MOVETYPE_FOLLOW;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+1000], 12		; 0000000cH
$LN37@CL_LinkPac:

; 1225 : 
; 1226 : 		if( FBitSet( ent->curstate.effects, EF_NOINTERP ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 32					; 00000020H
	je	SHORT $LN38@CL_LinkPac

; 1227 : 			CL_ResetLatchedVars( ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8
$LN38@CL_LinkPac:

; 1228 : 
; 1229 : 		if( CL_EntityTeleported( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityTeleported
	add	esp, 4
	test	eax, eax
	je	$LN39@CL_LinkPac

; 1230 : 		{
; 1231 : 			VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3180], eax

; 1232 : 			VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3192], eax

; 1233 : 			CL_ResetPositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetPositions
	add	esp, 4
$LN39@CL_LinkPac:

; 1234 : 		}
; 1235 : 
; 1236 : 		VectorCopy( ent->origin, ent->attachment[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 1237 : 		VectorCopy( ent->origin, ent->attachment[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 1238 : 		VectorCopy( ent->origin, ent->attachment[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 1239 : 		VectorCopy( ent->origin, ent->attachment[3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 1240 : 
; 1241 : 		CL_AddVisibleEntity( ent, ET_NORMAL );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8

; 1242 : 	}

	jmp	$LN2@CL_LinkPac
$LN3@CL_LinkPac:

; 1243 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkPacketEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_LinkPlayers
_TEXT	SEGMENT
tv293 = -80						; size = 4
_i$ = -12						; size = 4
_ent$ = -8						; size = 4
_state$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_LinkPlayers PROC					; COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1001 : 	entity_state_t	*state;
; 1002 : 	cl_entity_t	*ent;
; 1003 : 	int		i;
; 1004 : 
; 1005 : 	ent = CL_GetLocalPlayer();

	call	_CL_GetLocalPlayer
	mov	DWORD PTR _ent$[ebp], eax

; 1006 : 
; 1007 : 	// apply muzzleflash to weaponmodel
; 1008 : 	if( ent && FBitSet( ent->curstate.effects, EF_MUZZLEFLASH ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_LinkPla
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 2
	je	SHORT $LN5@CL_LinkPla

; 1009 : 		SetBits( clgame.viewent.curstate.effects, EF_MUZZLEFLASH );

	mov	eax, DWORD PTR _clgame+261404
	or	eax, 2
	mov	DWORD PTR _clgame+261404, eax
$LN5@CL_LinkPla:

; 1010 : 	cl.local.apply_effects = true;

	mov	DWORD PTR _cl+2212640, 1

; 1011 : 
; 1012 : 	// check all the clients but add only visible
; 1013 : 	for( i = 0, state = frame->playerstate; i < MAX_CLIENTS; i++, state++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 2648				; 00000a58H
	mov	DWORD PTR _state$[ebp], eax
	jmp	SHORT $LN4@CL_LinkPla
$LN2@CL_LinkPla:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 452				; 000001c4H
	mov	DWORD PTR _state$[ebp], ecx
$LN4@CL_LinkPla:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$LN3@CL_LinkPla

; 1014 : 	{
; 1015 : 		if( state->messagenum != cl.parsecount )

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _cl+8
	je	SHORT $LN6@CL_LinkPla

; 1016 : 			continue;	// not present this frame

	jmp	SHORT $LN2@CL_LinkPla
$LN6@CL_LinkPla:

; 1017 : 
; 1018 : 		// FarEast: Restored mirror support
; 1019 : 		if (!CL_IsThirdPerson() && (i == cl.viewentity - 1))

	call	_CL_IsThirdPerson
	test	eax, eax
	jne	SHORT $LN8@CL_LinkPla
	mov	eax, DWORD PTR _cl+2212780
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN8@CL_LinkPla

; 1020 : 		{
; 1021 : 			if (!gl_allow_mirrors->value || !world.has_mirrors)

	mov	eax, DWORD PTR _gl_allow_mirrors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@CL_LinkPla
	cmp	DWORD PTR _world+4, 0
	jne	SHORT $LN8@CL_LinkPla
$LN9@CL_LinkPla:

; 1022 : 				continue;

	jmp	SHORT $LN2@CL_LinkPla
$LN8@CL_LinkPla:

; 1023 : 		}
; 1024 : 
; 1025 : 		if( !state->modelindex || FBitSet( state->effects, EF_NODRAW ))

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN11@CL_LinkPla
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	and	ecx, 128				; 00000080H
	je	SHORT $LN10@CL_LinkPla
$LN11@CL_LinkPla:

; 1026 : 			continue;

	jmp	SHORT $LN2@CL_LinkPla
$LN10@CL_LinkPla:

; 1027 : 
; 1028 : 		ent = &clgame.entities[i + 1];

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	imul	ecx, eax, 3336
	add	ecx, DWORD PTR _clgame+996
	mov	DWORD PTR _ent$[ebp], ecx

; 1029 : 
; 1030 : 		// fixup the player indexes...
; 1031 : 		if( ent->index != ( i + 1 )) ent->index = (i + 1);

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN12@CL_LinkPla
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@CL_LinkPla:

; 1032 : 
; 1033 : 		if( i == cl.playernum )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	jne	$LN13@CL_LinkPla

; 1034 : 		{
; 1035 : 			if( cls.demoplayback != DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	je	$LN14@CL_LinkPla

; 1036 : 			{
; 1037 : 				VectorCopy( state->origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+3224], eax

; 1038 : 				VectorCopy( state->origin, ent->prevstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+476], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+476], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+476], eax

; 1039 : 				VectorCopy( state->origin, ent->curstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+928], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+928], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+928], eax
$LN14@CL_LinkPla:

; 1040 : 			}
; 1041 : 			VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax
$LN13@CL_LinkPla:

; 1042 : 		}
; 1043 : 
; 1044 : 		if( FBitSet( ent->curstate.effects, EF_NOINTERP ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 32					; 00000020H
	je	SHORT $LN15@CL_LinkPla

; 1045 : 			CL_ResetLatchedVars( ent, false );

	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8
$LN15@CL_LinkPla:

; 1046 : 
; 1047 : 		if( CL_EntityTeleported( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityTeleported
	add	esp, 4
	test	eax, eax
	je	$LN16@CL_LinkPla

; 1048 : 		{
; 1049 : 			VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3180], eax

; 1050 : 			VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3192], eax

; 1051 : 			CL_ResetPositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetPositions
	add	esp, 4
$LN16@CL_LinkPla:

; 1052 : 		}
; 1053 : 
; 1054 : 		if ( i == cl.playernum )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cl+2213000
	jne	$LN17@CL_LinkPla

; 1055 : 		{
; 1056 : 			if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	$LN19@CL_LinkPla

; 1057 : 				VectorLerp( ent->prevstate.origin, cl.lerpFrac, ent->curstate.origin, cl.simorg );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+edx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+476]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _cl[edx+2212976], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+928]
	subss	xmm0, DWORD PTR [edi+edx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	ecx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+476]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _cl[edx+2212976], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx+928]
	subss	xmm0, DWORD PTR [edi+edx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+eax+476]
	addss	xmm1, xmm0
	movss	DWORD PTR tv293[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv293[ebp]
	movss	DWORD PTR _cl[edx+2212976], xmm0
$LN19@CL_LinkPla:

; 1058 : 			VectorCopy( cl.simorg, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _cl[ecx+2212976]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _cl[edx+2212976]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _cl[eax+2212976]
	mov	DWORD PTR [edx+ecx+3224], eax

; 1059 : 		}

	jmp	$LN18@CL_LinkPla
$LN17@CL_LinkPla:

; 1060 : 		else
; 1061 : 		{
; 1062 : 			VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 1063 : 			VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 1064 : 
; 1065 : 			// interpolate non-local clients
; 1066 : 			CL_ComputePlayerOrigin( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ComputePlayerOrigin
	add	esp, 4
$LN18@CL_LinkPla:

; 1067 : 		}
; 1068 : 
; 1069 : 		VectorCopy( ent->origin, ent->attachment[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 1070 : 		VectorCopy( ent->origin, ent->attachment[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 1071 : 		VectorCopy( ent->origin, ent->attachment[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 1072 : 		VectorCopy( ent->origin, ent->attachment[3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 1073 : 
; 1074 : 		CL_AddVisibleEntity( ent, ET_PLAYER );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8

; 1075 : 	}

	jmp	$LN2@CL_LinkPla
$LN3@CL_LinkPla:

; 1076 : 
; 1077 : 	// apply local player effects if entity is not added
; 1078 : 	if( cl.local.apply_effects ) CL_AddEntityEffects( CL_GetLocalPlayer( ));

	cmp	DWORD PTR _cl+2212640, 0
	je	SHORT $LN20@CL_LinkPla
	call	_CL_GetLocalPlayer
	push	eax
	call	_CL_AddEntityEffects
	add	esp, 4
$LN20@CL_LinkPla:

; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkPlayers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_LinkCustomEntity
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_state$ = 12						; size = 4
_CL_LinkCustomEntity PROC				; COMDAT

; 977  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 978  : 	ent->curstate.movetype = state->modelindex; // !!!

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+1000], edx

; 979  : 
; 980  : 	if( ent->model->type != mod_sprite )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 1
	je	SHORT $LN2@CL_LinkCus

; 981  : 		Con_Reportf( S_WARN "bad model on beam ( %s )\n", ent->model->name );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	push	OFFSET ??_C@_0CH@FBOBLHAE@?$FO3Warning?3?$FO7?5bad?5model?5on?5beam?5@
	call	_Con_Reportf
	add	esp, 8
$LN2@CL_LinkCus:

; 982  : 
; 983  : 	ent->latched.prevsequence = ent->curstate.sequence;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR [eax+3204], edx

; 984  : 	VectorCopy( ent->origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx+3180], eax

; 985  : 	VectorCopy( ent->angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3236]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3236]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3236]
	mov	DWORD PTR [edx+ecx+3192], eax

; 986  : 	ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 912				; 00000390H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 460				; 000001ccH
	mov	ecx, 113				; 00000071H
	rep movsd

; 987  : 
; 988  : 	CL_AddVisibleEntity( ent, ET_BEAM );

	push	3
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddVisibleEntity
	add	esp, 8

; 989  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_LinkCustomEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_DeltaEntity
_TEXT	SEGMENT
tv156 = -96						; size = 4
tv153 = -92						; size = 4
tv65 = -92						; size = 4
_alive$ = -24						; size = 4
_delta_type$ = -20					; size = 4
_pack$ = -16						; size = 4
_newent$ = -12						; size = 4
_state$ = -8						; size = 4
_ent$ = -4						; size = 4
_msg$ = 8						; size = 4
_frame$ = 12						; size = 4
_newnum$ = 16						; size = 4
_old$ = 20						; size = 4
_has_update$ = 24					; size = 4
_CL_DeltaEntity PROC					; COMDAT

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 661  : 	cl_entity_t	*ent;
; 662  : 	entity_state_t	*state;
; 663  : 	qboolean		newent = (old) ? false : true;

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN12@CL_DeltaEn
	mov	DWORD PTR tv65[ebp], 0
	jmp	SHORT $LN13@CL_DeltaEn
$LN12@CL_DeltaEn:
	mov	DWORD PTR tv65[ebp], 1
$LN13@CL_DeltaEn:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _newent$[ebp], eax

; 664  : 	int		pack = frame->num_entities;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24044]
	mov	DWORD PTR _pack$[ebp], ecx

; 665  : 	int		delta_type = DELTA_ENTITY;

	mov	DWORD PTR _delta_type$[ebp], 0

; 666  : 	qboolean		alive = true;

	mov	DWORD PTR _alive$[ebp], 1

; 667  : 
; 668  : 	// alloc next slot to store update
; 669  : 	state = &cls.packet_entities[cls.next_client_entities % cls.num_client_entities];

	mov	eax, DWORD PTR _cls+295008
	cdq
	idiv	DWORD PTR _cls+295004
	imul	eax, edx, 452
	add	eax, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], eax

; 670  : 	if( CL_IsPlayerIndex( newnum )) delta_type = DELTA_PLAYER;

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_DeltaEn
	mov	DWORD PTR _delta_type$[ebp], 1
$LN2@CL_DeltaEn:

; 671  : 
; 672  : 	if(( newnum < 0 ) || ( newnum >= clgame.maxEntities ))

	cmp	DWORD PTR _newnum$[ebp], 0
	jl	SHORT $LN4@CL_DeltaEn
	mov	eax, DWORD PTR _newnum$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jl	SHORT $LN3@CL_DeltaEn
$LN4@CL_DeltaEn:

; 673  : 	{
; 674  : 		Con_DPrintf( S_ERROR "CL_DeltaEntity: invalid newnum: %d\n", newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@CPJNJAH@?$FO1Error?3?$FO7?5CL_DeltaEntity?3?5inva@
	call	_Con_DPrintf
	add	esp, 8

; 675  : 		if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN5@CL_DeltaEn

; 676  : 			MSG_ReadDeltaEntity( msg, old, state, newnum, delta_type, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _delta_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _old$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H
$LN5@CL_DeltaEn:

; 677  : 		return;

	jmp	$LN1@CL_DeltaEn
$LN3@CL_DeltaEn:

; 678  : 	}
; 679  : 
; 680  : 	ent = CL_EDICT_NUM( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_EDICT_NUM
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 681  : 	ent->index = newnum; // enumerate entity index

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _newnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 682  : 	if( newent ) old = &ent->baseline;

	cmp	DWORD PTR _newent$[ebp], 0
	je	SHORT $LN6@CL_DeltaEn
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 8
	mov	DWORD PTR _old$[ebp], eax
$LN6@CL_DeltaEn:

; 683  : 
; 684  : 	if( has_update )

	cmp	DWORD PTR _has_update$[ebp], 0
	je	SHORT $LN7@CL_DeltaEn

; 685  : 		alive = MSG_ReadDeltaEntity( msg, old, state, newnum, delta_type, cl.mtime[0] );

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _delta_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	mov	edx, DWORD PTR _old$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H
	mov	DWORD PTR _alive$[ebp], eax
	jmp	SHORT $LN8@CL_DeltaEn
$LN7@CL_DeltaEn:

; 686  : 	else memcpy( state, old, sizeof( entity_state_t ));

	push	452					; 000001c4H
	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@CL_DeltaEn:

; 687  : 
; 688  : 	if( !alive )

	cmp	DWORD PTR _alive$[ebp], 0
	jne	SHORT $LN9@CL_DeltaEn

; 689  : 	{
; 690  : 		CL_KillDeadBeams( ent ); // release dead beams

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_KillDeadBeams
	add	esp, 4

; 691  : #if 0
; 692  : 		// this is for reference
; 693  : 		if( state->number == -1 )
; 694  : 			Con_DPrintf( "Entity %i was removed from server\n", newnum );
; 695  : 		else Con_Dprintf( "Entity %i was removed from delta-message\n", newnum );
; 696  : #endif
; 697  : 		return;

	jmp	$LN1@CL_DeltaEn
$LN9@CL_DeltaEn:

; 698  : 	}
; 699  : 
; 700  : 	if( newent )

	cmp	DWORD PTR _newent$[ebp], 0
	je	SHORT $LN10@CL_DeltaEn

; 701  : 	{
; 702  : 		// interpolation must be reset
; 703  : 		SETVISBIT( frame->flags, pack );

	cmp	DWORD PTR _pack$[ebp], 0
	jl	SHORT $LN14@CL_DeltaEn
	mov	eax, DWORD PTR _pack$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _pack$[ebp]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+23786]
	or	eax, edx
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR _pack$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR _frame$[ebp]
	mov	al, BYTE PTR tv153[ebp]
	mov	BYTE PTR [edx+ecx+23786], al
	movzx	ecx, BYTE PTR tv153[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	jmp	SHORT $LN15@CL_DeltaEn
$LN14@CL_DeltaEn:
	mov	DWORD PTR tv156[ebp], 0
$LN15@CL_DeltaEn:

; 704  : 
; 705  : 		// release beams from previous entity
; 706  : 		CL_KillDeadBeams( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_KillDeadBeams
	add	esp, 4
$LN10@CL_DeltaEn:

; 707  : 	}
; 708  : 
; 709  : 	// add entity to packet
; 710  : 	cls.next_client_entities++;

	mov	eax, DWORD PTR _cls+295008
	add	eax, 1
	mov	DWORD PTR _cls+295008, eax

; 711  : 	frame->num_entities++;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax+24044]
	add	ecx, 1
	mov	edx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [edx+24044], ecx
$LN1@CL_DeltaEn:

; 712  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DeltaEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_FlushEntityPacket
_TEXT	SEGMENT
tv87 = -1044						; size = 4
_to$ = -912						; size = 452
_from$ = -460						; size = 452
_newnum$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_FlushEntityPacket PROC				; COMDAT

; 630  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1044				; 00000414H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 631  : 	int		newnum;
; 632  : 	entity_state_t	from, to;
; 633  : 
; 634  : 	memset( &from, 0, sizeof( from ));

	push	452					; 000001c4H
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 635  : 
; 636  : 	cl.frames[cl.parsecountmod].valid = false;

	imul	eax, DWORD PTR _cl+12, 24056
	mov	DWORD PTR _cl[eax+112], 0

; 637  : 	cl.validsequence = 0; // can't render a frame

	mov	DWORD PTR _cl+4, 0
$LN2@CL_FlushEn:

; 638  : 
; 639  : 	// read it all, but ignore it
; 640  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@CL_FlushEn

; 641  : 	{
; 642  : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 643  : 		if( newnum == LAST_EDICT ) break; // done

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN4@CL_FlushEn
	jmp	$LN3@CL_FlushEn
$LN4@CL_FlushEn:

; 644  : 
; 645  : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@CL_FlushEn

; 646  : 			Host_Error( "CL_FlushEntityPacket: overflow\n" );

	push	OFFSET ??_C@_0CA@LBBNMMJJ@CL_FlushEntityPacket?3?5overflow?6@
	call	_Host_Error
	add	esp, 4
$LN5@CL_FlushEn:

; 647  : 
; 648  : 		MSG_ReadDeltaEntity( msg, &from, &to, newnum, CL_IsPlayerIndex( newnum ) ? DELTA_PLAYER : DELTA_ENTITY, cl.mtime[0] );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@CL_FlushEn
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN8@CL_FlushEn
$LN7@CL_FlushEn:
	mov	DWORD PTR tv87[ebp], 0
$LN8@CL_FlushEn:
	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsd2ss xmm0, QWORD PTR _cl[edx+32]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR tv87[ebp]
	push	eax
	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	lea	edx, DWORD PTR _to$[ebp]
	push	edx
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_ReadDeltaEntity
	add	esp, 24					; 00000018H

; 649  : 	}

	jmp	$LN2@CL_FlushEn
$LN3@CL_FlushEn:

; 650  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FlushEntityPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ResetLatchedState
_TEXT	SEGMENT
tv75 = -68						; size = 4
_pnum$ = 8						; size = 4
_frame$ = 12						; size = 4
_ent$ = 16						; size = 4
_CL_ResetLatchedState PROC				; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 559  : 	if( CHECKVISBIT( frame->flags, pnum ))

	cmp	DWORD PTR _pnum$[ebp], 0
	jl	SHORT $LN5@CL_ResetLa
	mov	eax, DWORD PTR _pnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _frame$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+23786]
	mov	ecx, DWORD PTR _pnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	movzx	ecx, dl
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN6@CL_ResetLa
$LN5@CL_ResetLa:
	mov	DWORD PTR tv75[ebp], 0
$LN6@CL_ResetLa:
	cmp	DWORD PTR tv75[ebp], 0
	je	$LN3@CL_ResetLa

; 560  : 	{
; 561  : 		VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3180], eax

; 562  : 		VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3192], eax

; 563  : 
; 564  : 		CL_ResetLatchedVars( ent, true );

	push	1
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetLatchedVars
	add	esp, 8

; 565  : 		CL_ResetPositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ResetPositions
	add	esp, 4

; 566  : 
; 567  : 		// parametric interpolation will starts at this point
; 568  : 		if( ent->curstate.starttime != 0.0f && ent->curstate.impacttime != 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1280]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_ResetLa
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1276]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_ResetLa

; 569  : 			ent->lastmove = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+3220], xmm0
$LN3@CL_ResetLa:

; 570  : 	}
; 571  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetLatchedState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_InterpolateModel
_TEXT	SEGMENT
tv356 = -180						; size = 4
tv322 = -180						; size = 4
tv183 = -180						; size = 4
_q2$ = -112						; size = 16
_q1$ = -96						; size = 16
_q$ = -80						; size = 16
_frac$ = -64						; size = 4
_t2$ = -60						; size = 4
_t1$ = -56						; size = 4
_t$ = -52						; size = 4
_delta$ = -48						; size = 12
_angles$ = -36						; size = 12
_origin$ = -24						; size = 12
_ph1$ = -12						; size = 4
_ph0$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_CL_InterpolateModel PROC				; COMDAT

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 416  : 	position_history_t  *ph0 = NULL, *ph1 = NULL;

	mov	DWORD PTR _ph0$[ebp], 0
	mov	DWORD PTR _ph1$[ebp], 0

; 417  : 	vec3_t		origin, angles, delta;
; 418  : 	float		t, t1, t2, frac;
; 419  : 	vec4_t		q, q1, q2;
; 420  : 
; 421  : 	VectorCopy( e->curstate.origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 422  : 	VectorCopy( e->curstate.angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 423  : 
; 424  : 	if( cls.timedemo || !e->model )

	cmp	DWORD PTR _cls+300836, 0
	jne	SHORT $LN3@CL_Interpo
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN2@CL_Interpo
$LN3@CL_Interpo:

; 425  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN2@CL_Interpo:

; 426  : 
; 427  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	$LN4@CL_Interpo

; 428  : 	{
; 429  : 		// quake lerping is easy
; 430  : 		VectorLerp( e->prevstate.origin, cl.lerpFrac, e->curstate.origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+edx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+476]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	movss	DWORD PTR [eax+edx+3224], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+928]
	subss	xmm0, DWORD PTR [edi+eax+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	edx, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+476]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [ecx+eax+3224], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+ecx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+476]
	addss	xmm1, xmm0
	movss	DWORD PTR tv183[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR tv183[ebp]
	movss	DWORD PTR [edx+ecx+3224], xmm0

; 431  : 		AngleQuaternion( e->prevstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 488				; 000001e8H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 432  : 		AngleQuaternion( e->curstate.angles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 433  : 		QuaternionSlerp( q1, q2, cl.lerpFrac, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 434  : 		QuaternionAngle( q, e->angles );

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3236				; 00000ca4H
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 435  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN4@CL_Interpo:

; 436  : 	}
; 437  : 
; 438  : 	if( cl.maxclients <= 1 )

	cmp	DWORD PTR _cl+2213004, 1
	jg	SHORT $LN5@CL_Interpo

; 439  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN5@CL_Interpo:

; 440  : 
; 441  : 	if( e->model->type == mod_brush && !cl_bmodelinterp->value )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN6@CL_Interpo
	mov	eax, DWORD PTR _cl_bmodelinterp
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@CL_Interpo

; 442  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN6@CL_Interpo:

; 443  : 
; 444  : 	if( cl.local.moving && cl.local.onground == e->index )

	cmp	DWORD PTR _cl+2212744, 0
	je	SHORT $LN7@CL_Interpo
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _cl+2212728
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN7@CL_Interpo

; 445  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN7@CL_Interpo:

; 446  : 
; 447  : 	t = cl.time - cl_interp->value;

	mov	eax, DWORD PTR _cl_interp
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 448  : 	CL_FindInterpolationUpdates( e, t, &ph0, &ph1 );

	lea	eax, DWORD PTR _ph1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ph0$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_CL_FindInterpolationUpdates
	add	esp, 16					; 00000010H

; 449  : 
; 450  : 	if( ph0 == NULL || ph1 == NULL )

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN9@CL_Interpo
	cmp	DWORD PTR _ph1$[ebp], 0
	jne	SHORT $LN8@CL_Interpo
$LN9@CL_Interpo:

; 451  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN8@CL_Interpo:

; 452  : 
; 453  : 	t1 = ph1->animtime;

	mov	eax, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t1$[ebp], xmm0

; 454  : 	t2 = ph0->animtime;

	mov	eax, DWORD PTR _ph0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t2$[ebp], xmm0

; 455  : 
; 456  : 	if( t - t1 < 0.0f )

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@CL_Interpo

; 457  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN10@CL_Interpo:

; 458  : 
; 459  : 	if( t1 == 0.0f )

	movss	xmm0, DWORD PTR _t1$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN11@CL_Interpo

; 460  : 	{
; 461  : 		VectorCopy( ph0->origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+3224], eax

; 462  : 		VectorCopy( ph0->angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+3236], eax

; 463  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN11@CL_Interpo:

; 464  : 	}
; 465  : 
; 466  : 	if( t2 == t1 )

	movss	xmm0, DWORD PTR _t2$[ebp]
	ucomiss	xmm0, DWORD PTR _t1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@CL_Interpo

; 467  : 	{
; 468  : 		VectorCopy( ph0->origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+3224], eax

; 469  : 		VectorCopy( ph0->angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _ph0$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx+3236], eax

; 470  : 		return 1;

	mov	eax, 1
	jmp	$LN1@CL_Interpo
$LN12@CL_Interpo:

; 471  : 	}
; 472  : 
; 473  : 	VectorSubtract( ph0->origin, ph1->origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+4]
	subss	xmm0, DWORD PTR [esi+ecx+4]
	movss	DWORD PTR tv322[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv322[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 474  : 	frac = (t - t1) / (t2 - t1);

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	movss	xmm1, DWORD PTR _t2$[ebp]
	subss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0

; 475  : 
; 476  : 	if( frac < 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN13@CL_Interpo

; 477  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CL_Interpo
$LN13@CL_Interpo:

; 478  : 
; 479  : 	if( frac > 1.0f )

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN14@CL_Interpo

; 480  : 		frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN14@CL_Interpo:

; 481  : 
; 482  : 	VectorMA( ph1->origin, frac, delta, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _origin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [ecx+edx+4]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _ph1$[ebp]
	movss	xmm1, DWORD PTR [edx+eax+4]
	addss	xmm1, xmm0
	movss	DWORD PTR tv356[ebp], xmm1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv356[ebp]
	movss	DWORD PTR _origin$[ebp+eax], xmm0

; 483  : 
; 484  : 	AngleQuaternion( ph0->angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ph0$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 485  : 	AngleQuaternion( ph1->angles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ph1$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 486  : 	QuaternionSlerp( q2, q1, frac, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 487  : 	QuaternionAngle( q, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 488  : 
; 489  : 	VectorCopy( origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3224], eax

; 490  : 	VectorCopy( angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3236], eax

; 491  : 
; 492  : 	return 1;

	mov	eax, 1
$LN1@CL_Interpo:

; 493  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_InterpolateModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_PureOrigin
_TEXT	SEGMENT
tv142 = -160						; size = 4
tv169 = -156						; size = 4
tv141 = -156						; size = 4
tv132 = -156						; size = 4
_q2$1 = -88						; size = 16
_q1$2 = -72						; size = 16
_q$3 = -56						; size = 16
_delta$ = -40						; size = 12
_ph1$ = -28						; size = 4
_ph0$ = -24						; size = 4
_frac$ = -20						; size = 4
_t0$ = -16						; size = 4
_t1$ = -12						; size = 4
_extrapolate$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_t$ = 12						; size = 4
_outorigin$ = 16					; size = 4
_outangles$ = 20					; size = 4
_CL_PureOrigin PROC					; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 366  : 	qboolean		extrapolate;
; 367  : 	float		t1, t0, frac;
; 368  : 	position_history_t	*ph0, *ph1;
; 369  : 	vec3_t		delta;
; 370  : 
; 371  : 	// NOTE: ph0 is next, ph1 is a prev
; 372  : 	extrapolate = CL_FindInterpolationUpdates( ent, t, &ph0, &ph1 );

	lea	eax, DWORD PTR _ph1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ph0$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_FindInterpolationUpdates
	add	esp, 16					; 00000010H
	mov	DWORD PTR _extrapolate$[ebp], eax

; 373  : 
; 374  : 	if ( !ph0 || !ph1 )

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN3@CL_PureOri
	cmp	DWORD PTR _ph1$[ebp], 0
	jne	SHORT $LN2@CL_PureOri
$LN3@CL_PureOri:

; 375  : 		return;

	jmp	$LN5@CL_PureOri
$LN2@CL_PureOri:

; 376  : 
; 377  : 	t0 = ph0->animtime;

	mov	eax, DWORD PTR _ph0$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t0$[ebp], xmm0

; 378  : 	t1 = ph1->animtime;

	mov	eax, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR _t1$[ebp], xmm0

; 379  : 
; 380  : 	if( t0 != 0.0f )

	movss	xmm0, DWORD PTR _t0$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_PureOri

; 381  : 	{
; 382  : 		vec4_t	q, q1, q2;
; 383  : 
; 384  : 		VectorSubtract( ph0->origin, ph1->origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+4]
	subss	xmm0, DWORD PTR [esi+eax+4]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ph0$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+4]
	subss	xmm0, DWORD PTR [esi+ecx+4]
	movss	DWORD PTR tv132[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv132[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 385  : 
; 386  : 		if( t0 != t1 )

	movss	xmm0, DWORD PTR _t0$[ebp]
	ucomiss	xmm0, DWORD PTR _t1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_PureOri

; 387  : 			frac = ( t - t1 ) / ( t0 - t1 );

	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR _t1$[ebp]
	movss	xmm1, DWORD PTR _t0$[ebp]
	subss	xmm1, DWORD PTR _t1$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _frac$[ebp], xmm0
	jmp	SHORT $LN7@CL_PureOri
$LN6@CL_PureOri:

; 388  : 		else frac = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _frac$[ebp], xmm0
$LN7@CL_PureOri:

; 389  : 
; 390  : 		frac = bound( 0.0f, frac, 1.2f );

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN11@CL_PureOri
	movss	xmm0, DWORD PTR __real@3f99999a
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN9@CL_PureOri
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR tv141[ebp], xmm0
	jmp	SHORT $LN10@CL_PureOri
$LN9@CL_PureOri:
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR tv141[ebp], xmm0
$LN10@CL_PureOri:
	movss	xmm0, DWORD PTR tv141[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN12@CL_PureOri
$LN11@CL_PureOri:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv142[ebp], xmm0
$LN12@CL_PureOri:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 391  : 
; 392  : 		VectorMA( ph1->origin, frac, delta, outorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+4]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _outorigin$[ebp]
	movss	DWORD PTR [edx+ecx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _ph1$[ebp]
	addss	xmm0, DWORD PTR [edx+eax+4]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _outorigin$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _ph1$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+4]
	addss	xmm1, xmm0
	movss	DWORD PTR tv169[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _outorigin$[ebp]
	movss	xmm0, DWORD PTR tv169[ebp]
	movss	DWORD PTR [eax+edx], xmm0

; 393  : 
; 394  : 		AngleQuaternion( ph0->angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _ph0$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 395  : 		AngleQuaternion( ph1->angles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ph1$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 396  : 		QuaternionSlerp( q2, q1, frac, q );

	lea	eax, DWORD PTR _q$3[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$1[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 397  : 		QuaternionAngle( q, outangles );

	mov	eax, DWORD PTR _outangles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$3[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 398  : 	}

	jmp	$LN5@CL_PureOri
$LN4@CL_PureOri:

; 399  : 	else
; 400  : 	{
; 401  : 		// no backup found
; 402  : 		VectorCopy( ph1->origin, outorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _outorigin$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx], eax

; 403  : 		VectorCopy( ph1->angles, outangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+16]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	edx, DWORD PTR [esi+edx+16]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _outangles$[ebp]
	mov	esi, DWORD PTR _ph1$[ebp]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx], eax
$LN5@CL_PureOri:

; 404  : 	}
; 405  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PureOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_FindInterpolationUpdates
_TEXT	SEGMENT
_at$ = -24						; size = 4
_imod$ = -20						; size = 4
_i1$ = -16						; size = 4
_i0$ = -12						; size = 4
_i$ = -8						; size = 4
_extrapolate$ = -4					; size = 4
_ent$ = 8						; size = 4
_targettime$ = 12					; size = 4
_ph0$ = 16						; size = 4
_ph1$ = 20						; size = 4
_CL_FindInterpolationUpdates PROC			; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 328  : 	qboolean	extrapolate = true;

	mov	DWORD PTR _extrapolate$[ebp], 1

; 329  : 	int	i, i0, i1, imod;
; 330  : 	float	at;
; 331  : 
; 332  : 	imod = ent->current_position;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1364]
	mov	DWORD PTR _imod$[ebp], ecx

; 333  : 	i0 = (imod - 0) & HISTORY_MASK;	// curpos (lerp end)

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i0$[ebp], eax

; 334  : 	i1 = (imod - 1) & HISTORY_MASK;	// oldpos (lerp start)

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, 1
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i1$[ebp], eax

; 335  : 
; 336  : 	for( i = 1; i < HISTORY_MAX - 1; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_FindInt
$LN2@CL_FindInt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FindInt:
	cmp	DWORD PTR _i$[ebp], 63			; 0000003fH
	jge	SHORT $LN3@CL_FindInt

; 337  : 	{
; 338  : 		at = ent->ph[( imod - i ) & HISTORY_MASK].animtime;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	and	eax, 63					; 0000003fH
	imul	ecx, eax, 28
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1368]
	movss	DWORD PTR _at$[ebp], xmm0

; 339  : 		if( at == 0.0 ) break;

	cvtss2sd xmm0, DWORD PTR _at$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@CL_FindInt
	jmp	SHORT $LN3@CL_FindInt
$LN5@CL_FindInt:

; 340  : 
; 341  : 		if( targettime > at )

	movss	xmm0, DWORD PTR _targettime$[ebp]
	comiss	xmm0, DWORD PTR _at$[ebp]
	jbe	SHORT $LN6@CL_FindInt

; 342  : 		{
; 343  : 			// found it
; 344  : 			i0 = (( imod - i ) + 1 ) & HISTORY_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i0$[ebp], eax

; 345  : 			i1 = (( imod - i ) + 0 ) & HISTORY_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, DWORD PTR _i$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _i1$[ebp], eax

; 346  : 			extrapolate = false;

	mov	DWORD PTR _extrapolate$[ebp], 0

; 347  : 			break;

	jmp	SHORT $LN3@CL_FindInt
$LN6@CL_FindInt:

; 348  : 		}
; 349  : 	}

	jmp	SHORT $LN2@CL_FindInt
$LN3@CL_FindInt:

; 350  : 
; 351  : 	if( ph0 != NULL ) *ph0 = &ent->ph[i0];

	cmp	DWORD PTR _ph0$[ebp], 0
	je	SHORT $LN7@CL_FindInt
	imul	eax, DWORD PTR _i0$[ebp], 28
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1368]
	mov	eax, DWORD PTR _ph0$[ebp]
	mov	DWORD PTR [eax], edx
$LN7@CL_FindInt:

; 352  : 	if( ph1 != NULL ) *ph1 = &ent->ph[i1];

	cmp	DWORD PTR _ph1$[ebp], 0
	je	SHORT $LN8@CL_FindInt
	imul	eax, DWORD PTR _i1$[ebp], 28
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1368]
	mov	eax, DWORD PTR _ph1$[ebp]
	mov	DWORD PTR [eax], edx
$LN8@CL_FindInt:

; 353  : 
; 354  : 	return extrapolate;

	mov	eax, DWORD PTR _extrapolate$[ebp]

; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindInterpolationUpdates ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ProcessEntityUpdate
_TEXT	SEGMENT
_parametric$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ProcessEntityUpdate PROC				; COMDAT

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 268  : 	qboolean	parametric;
; 269  : 
; 270  : 	ent->model = CL_ModelHandle( ent->curstate.modelindex );

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+952]
	push	ecx
	call	_CL_ModelHandle
	add	esp, 4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+3300], eax

; 271  : 	ent->index = ent->curstate.number;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+916]
	mov	DWORD PTR [eax], edx

; 272  : 
; 273  : 	if( FBitSet( ent->curstate.entityType, ENTITY_NORMAL ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	and	ecx, 1
	je	SHORT $LN2@CL_Process

; 274  : 		COM_NormalizeAngles( ent->curstate.angles );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 940				; 000003acH
	push	eax
	call	_COM_NormalizeAngles
	add	esp, 4
$LN2@CL_Process:

; 275  : 
; 276  : 	parametric = CL_ParametricMove( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ParametricMove
	add	esp, 4
	mov	DWORD PTR _parametric$[ebp], eax

; 277  : 
; 278  : 	// allow interpolation on bmodels too
; 279  : 	if( ent->model && ent->model->type == mod_brush )

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN3@CL_Process
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 0
	jne	SHORT $LN3@CL_Process

; 280  : 		ent->curstate.animtime = ent->curstate.msg_time;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	mov	DWORD PTR [eax+1004], edx
$LN3@CL_Process:

; 281  : 
; 282  : 	if( CL_EntityCustomLerp( ent ) && !parametric )

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityCustomLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@CL_Process
	cmp	DWORD PTR _parametric$[ebp], 0
	jne	SHORT $LN4@CL_Process

; 283  : 		ent->curstate.animtime = ent->curstate.msg_time;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	mov	DWORD PTR [eax+1004], edx
$LN4@CL_Process:

; 284  : 
; 285  : 	if( !CL_CompareTimestamps( ent->curstate.animtime, ent->prevstate.animtime ) || CL_EntityIgnoreLerp( ent ))

	mov	eax, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+552]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1004]
	movss	DWORD PTR [esp], xmm0
	call	_CL_CompareTimestamps
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@CL_Process
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_EntityIgnoreLerp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@CL_Process
$LN6@CL_Process:

; 286  : 	{
; 287  : 		CL_UpdateLatchedVars( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_UpdateLatchedVars
	add	esp, 4

; 288  : 		CL_UpdatePositions( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_UpdatePositions
	add	esp, 4
$LN5@CL_Process:

; 289  : 	}
; 290  : 
; 291  : 	// g-cont. it should be done for all the players?
; 292  : 	//if( ent->player && !FBitSet( host.features, ENGINE_COMPUTE_STUDIO_LERP )) 
; 293  : 	//	ent->curstate.angles[PITCH] /= -3.0f;
; 294  : 
; 295  : 	// FarEast: Mirror implementation from previous versions
; 296  : 	if (!FBitSet(host.features, ENGINE_COMPUTE_STUDIO_LERP))

	mov	eax, DWORD PTR _host+34752
	and	eax, 128				; 00000080H
	jne	$LN10@CL_Process

; 297  : 	{
; 298  : 		// g-cont. it should be done for all the players?
; 299  : 		// FIXME: probably this cause problems with flahslight and mirror reflection
; 300  : 		// but it's used to reduce player body pitch...
; 301  : 		if (ent->player)

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN10@CL_Process

; 302  : 		{
; 303  : 			if (world.has_mirrors && gl_allow_mirrors->value && RP_LOCALCLIENT(ent) && !cl.local.thirdperson)

	cmp	DWORD PTR _world+4, 0
	je	SHORT $LN9@CL_Process
	mov	eax, DWORD PTR _gl_allow_mirrors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@CL_Process
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN9@CL_Process
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN9@CL_Process
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN9@CL_Process
	cmp	DWORD PTR _cl+2212636, 0
	jne	SHORT $LN9@CL_Process

; 304  : 				ent->curstate.angles[PITCH] /= 3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+940]
	divss	xmm0, DWORD PTR __real@40400000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+940], xmm0
	jmp	SHORT $LN10@CL_Process
$LN9@CL_Process:

; 305  : 			else ent->curstate.angles[PITCH] /= -3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+940]
	divss	xmm0, DWORD PTR __real@c0400000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+940], xmm0
$LN10@CL_Process:

; 306  : 		}
; 307  : 	}
; 308  : 
; 309  : 	VectorCopy( ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3224], eax

; 310  : 	VectorCopy( ent->curstate.angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax

; 311  : 
; 312  : 	// initialize attachments for now
; 313  : 	VectorCopy( ent->origin, ent->attachment[0] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 314  : 	VectorCopy( ent->origin, ent->attachment[1] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 315  : 	VectorCopy( ent->origin, ent->attachment[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [eax+edx+3248]
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [ecx+eax+3248]
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [eax+ecx], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3248]
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [ecx+edx], eax

; 316  : 	VectorCopy( ent->origin, ent->attachment[3] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+eax+3248]
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+3224]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+3248]
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+3224]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ent$[ebp]
	lea	edx, DWORD PTR [ecx+edx+3248]
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+3224]
	mov	DWORD PTR [edx+ecx], eax

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessEntityUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_UpdateLatchedVars
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_CL_UpdateLatchedVars PROC				; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 208  : 	if( !ent->model || ( ent->model->type != mod_alias && ent->model->type != mod_studio ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN3@CL_UpdateL
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	je	SHORT $LN2@CL_UpdateL
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN2@CL_UpdateL
$LN3@CL_UpdateL:

; 209  : 		return; // below fields used only for alias and studio interpolation

	jmp	$LN1@CL_UpdateL
$LN2@CL_UpdateL:

; 210  : 
; 211  : 	VectorCopy( ent->prevstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+476]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+476]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+476]
	mov	DWORD PTR [edx+ecx+3180], eax

; 212  : 	VectorCopy( ent->prevstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+488]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+488]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+488]
	mov	DWORD PTR [edx+ecx+3192], eax

; 213  : 
; 214  : 	if( ent->model->type == mod_alias )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	jne	SHORT $LN4@CL_UpdateL

; 215  : 		ent->latched.prevframe = ent->prevstate.frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+508]
	mov	DWORD PTR [eax+3208], edx
$LN4@CL_UpdateL:

; 216  : 	ent->latched.prevanimtime = ent->prevstate.animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+552]
	mov	DWORD PTR [eax+3168], edx

; 217  : 
; 218  : 	if( ent->curstate.sequence != ent->prevstate.sequence )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [eax+956]
	cmp	edx, DWORD PTR [ecx+504]
	je	SHORT $LN5@CL_UpdateL

; 219  : 	{
; 220  : 		memcpy( ent->prevstate.blending, ent->latched.prevseqblending, sizeof( ent->prevstate.blending ));

	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3176				; 00000c68H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 564				; 00000234H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 221  : 		ent->latched.prevsequence = ent->prevstate.sequence;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR [eax+3204], edx

; 222  : 		ent->latched.sequencetime = ent->curstate.animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+1004]
	mov	DWORD PTR [eax+3172], edx
$LN5@CL_UpdateL:

; 223  : 	}
; 224  : 
; 225  : 	memcpy( ent->latched.prevcontroller, ent->prevstate.controller, sizeof( ent->latched.prevcontroller ));

	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 560				; 00000230H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3212				; 00000c8cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 226  : 	memcpy( ent->latched.prevblending, ent->prevstate.blending, sizeof( ent->latched.prevblending ));

	push	2
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3216				; 00000c90H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@CL_UpdateL:

; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdateLatchedVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ParametricMove
_TEXT	SEGMENT
tv358 = -104						; size = 8
tv143 = -104						; size = 4
tv173 = -100						; size = 4
tv142 = -100						; size = 4
tv94 = -100						; size = 4
_ilength$1 = -32					; size = 4
_delta$ = -28						; size = 12
_t$ = -16						; size = 4
_dt$ = -12						; size = 4
_frac$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ParametricMove PROC					; COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 171  : 	float	frac, dt, t;
; 172  : 	vec3_t	delta;
; 173  : 
; 174  : 	if( ent->curstate.starttime == 0.0f || ent->curstate.impacttime == 0.0f )

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1280]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_Paramet
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1276]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_Paramet
$LN3@CL_Paramet:

; 175  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_Paramet
$LN2@CL_Paramet:

; 176  : 
; 177  : 	VectorSubtract( ent->curstate.endpos, ent->curstate.startpos, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1264]
	subss	xmm0, DWORD PTR [esi+eax+1252]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1264]
	subss	xmm0, DWORD PTR [esi+eax+1252]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1264]
	subss	xmm0, DWORD PTR [esi+ecx+1252]
	movss	DWORD PTR tv94[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv94[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 178  : 	dt = ent->curstate.impacttime - ent->curstate.starttime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+1276]
	subss	xmm0, DWORD PTR [ecx+1280]
	movss	DWORD PTR _dt$[ebp], xmm0

; 179  : 
; 180  : 	if( dt != 0.0f )

	movss	xmm0, DWORD PTR _dt$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN4@CL_Paramet

; 181  : 	{
; 182  : 		if( ent->lastmove > cl.time )

	mov	eax, DWORD PTR _ent$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+3220]
	comisd	xmm0, QWORD PTR _cl+2167640
	jbe	SHORT $LN5@CL_Paramet

; 183  : 			t = ent->lastmove;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [eax+3220]
	movss	DWORD PTR _t$[ebp], xmm0
	jmp	SHORT $LN6@CL_Paramet
$LN5@CL_Paramet:

; 184  : 		else t = cl.time;

	cvtsd2ss xmm0, QWORD PTR _cl+2167640
	movss	DWORD PTR _t$[ebp], xmm0
$LN6@CL_Paramet:

; 185  : 
; 186  : 		frac = ( t - ent->curstate.starttime ) / dt;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR [eax+1280]
	divss	xmm0, DWORD PTR _dt$[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 187  : 		frac = bound( 0.0f, frac, 1.0f );

	movss	xmm0, DWORD PTR _frac$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@CL_Paramet
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _frac$[ebp]
	jbe	SHORT $LN10@CL_Paramet
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN11@CL_Paramet
$LN10@CL_Paramet:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv142[ebp], xmm0
$LN11@CL_Paramet:
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	DWORD PTR tv143[ebp], xmm0
	jmp	SHORT $LN13@CL_Paramet
$LN12@CL_Paramet:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv143[ebp], xmm0
$LN13@CL_Paramet:
	movss	xmm0, DWORD PTR tv143[ebp]
	movss	DWORD PTR _frac$[ebp], xmm0

; 188  : 		VectorMA( ent->curstate.startpos, frac, delta, ent->curstate.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+1252]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [edx+ecx+928], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+eax+1252]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+928], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _frac$[ebp]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [ecx+edx+1252]
	addss	xmm1, xmm0
	movss	DWORD PTR tv173[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv173[ebp]
	movss	DWORD PTR [eax+edx+928], xmm0

; 189  : 
; 190  : 		ent->lastmove = t;

	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+3220], xmm0
$LN4@CL_Paramet:

; 191  : 	}
; 192  : 
; 193  : 	VectorNormalize( delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@CL_Paramet
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN7@CL_Paramet:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _delta$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _delta$[ebp+ecx], xmm0

; 194  : 	if( VectorLength( delta ) > 0.0f )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv358[ebp]
	movsd	xmm0, QWORD PTR tv358[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN8@CL_Paramet

; 195  : 		VectorAngles( delta, ent->curstate.angles ); // re-aim projectile

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 940				; 000003acH
	push	eax
	lea	ecx, DWORD PTR _delta$[ebp]
	push	ecx
	call	_VectorAngles
	add	esp, 8
$LN8@CL_Paramet:

; 196  : 
; 197  : 	return true;

	mov	eax, 1
$LN1@CL_Paramet:

; 198  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParametricMove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_EntityCustomLerp
_TEXT	SEGMENT
tv65 = -68						; size = 4
_e$ = 8							; size = 4
_CL_EntityCustomLerp PROC				; COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 149  : 	switch( e->curstate.movetype )

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+1000]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 14			; 0000000eH
	ja	SHORT $LN2@CL_EntityC
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN10@CL_EntityC[edx]
	jmp	DWORD PTR $LN11@CL_EntityC[eax*4]
$LN8@CL_EntityC:

; 150  : 	{
; 151  : 	case MOVETYPE_NONE:
; 152  : 	case MOVETYPE_STEP:
; 153  : 	case MOVETYPE_WALK:
; 154  : 	case MOVETYPE_FLY:
; 155  : 	case MOVETYPE_COMPOUND:
; 156  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_EntityC
$LN2@CL_EntityC:

; 157  : 	}
; 158  : 
; 159  : 	return true;

	mov	eax, 1
$LN1@CL_EntityC:

; 160  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@CL_EntityC:
	DD	$LN8@CL_EntityC
	DD	$LN2@CL_EntityC
$LN10@CL_EntityC:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_CL_EntityCustomLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_EntityIgnoreLerp
_TEXT	SEGMENT
tv71 = -68						; size = 4
_e$ = 8							; size = 4
_CL_EntityIgnoreLerp PROC				; COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 135  : 	if( e->model && e->model->type == mod_alias )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN2@CL_EntityI
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	jne	SHORT $LN2@CL_EntityI

; 136  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_EntityI
$LN2@CL_EntityI:

; 137  : 
; 138  : 	return (e->curstate.movetype == MOVETYPE_NONE) ? true : false;

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1000], 0
	jne	SHORT $LN4@CL_EntityI
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@CL_EntityI
$LN4@CL_EntityI:
	mov	DWORD PTR tv71[ebp], 0
$LN5@CL_EntityI:
	mov	eax, DWORD PTR tv71[ebp]
$LN1@CL_EntityI:

; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EntityIgnoreLerp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_CompareTimestamps
_TEXT	SEGMENT
tv70 = -76						; size = 4
_iTime2$ = -8						; size = 4
_iTime1$ = -4						; size = 4
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_CL_CompareTimestamps PROC				; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 120  : 	int	iTime1 = t1 * 1000;

	movss	xmm0, DWORD PTR _t1$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _iTime1$[ebp], eax

; 121  : 	int	iTime2 = t2 * 1000;

	movss	xmm0, DWORD PTR _t2$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	mov	DWORD PTR _iTime2$[ebp], eax

; 122  : 
; 123  : 	return (( iTime1 - iTime2 ) <= 1 );

	mov	eax, DWORD PTR _iTime1$[ebp]
	sub	eax, DWORD PTR _iTime2$[ebp]
	cmp	eax, 1
	jg	SHORT $LN3@CL_Compare
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_Compare
$LN3@CL_Compare:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_Compare:
	mov	eax, DWORD PTR tv70[ebp]

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CompareTimestamps ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_EntityTeleported
_TEXT	SEGMENT
tv151 = -92						; size = 4
tv90 = -92						; size = 4
_delta$ = -24						; size = 12
_maxlen$ = -12						; size = 4
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_EntityTeleported PROC				; COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 99   : 	float	len, maxlen;
; 100  : 	vec3_t	delta;
; 101  : 
; 102  : 	VectorSubtract( ent->curstate.origin, ent->prevstate.origin, delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+928]
	subss	xmm0, DWORD PTR [esi+eax+476]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+928]
	subss	xmm0, DWORD PTR [esi+eax+476]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _delta$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+928]
	subss	xmm0, DWORD PTR [esi+ecx+476]
	movss	DWORD PTR tv90[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR _delta$[ebp+eax], xmm0

; 103  : 
; 104  : 	// compute potential max movement in units per frame and compare with entity movement
; 105  : 	maxlen = ( clgame.movevars.maxvelocity * ( 1.0 / GAME_FPS ));

	cvtss2sd xmm0, DWORD PTR _clgame+1076
	mulsd	xmm0, QWORD PTR __real@3fa999999999999a
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _maxlen$[ebp], xmm0

; 106  : 	len = VectorLength( delta );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm0, DWORD PTR _delta$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _delta$[ebp+ecx]
	mulss	xmm1, DWORD PTR _delta$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _delta$[ebp+eax]
	mulss	xmm1, DWORD PTR _delta$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _len$[ebp]

; 107  : 
; 108  : 	return (len > maxlen);

	movss	xmm0, DWORD PTR _len$[ebp]
	comiss	xmm0, DWORD PTR _maxlen$[ebp]
	jbe	SHORT $LN3@CL_EntityT
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN4@CL_EntityT
$LN3@CL_EntityT:
	mov	DWORD PTR tv151[ebp], 0
$LN4@CL_EntityT:
	mov	eax, DWORD PTR tv151[ebp]

; 109  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EntityTeleported ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ResetPositions
_TEXT	SEGMENT
_store$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ResetPositions PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 77   : 	position_history_t	store;
; 78   : 
; 79   : 	if( !ent ) return;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN2@CL_ResetPo
	jmp	$LN1@CL_ResetPo
$LN2@CL_ResetPo:

; 80   : 
; 81   : 	store = ent->ph[ent->current_position];

	mov	eax, DWORD PTR _ent$[ebp]
	imul	ecx, DWORD PTR [eax+1364], 28
	mov	edx, DWORD PTR _ent$[ebp]
	lea	esi, DWORD PTR [edx+ecx+1368]
	mov	ecx, 7
	lea	edi, DWORD PTR _store$[ebp]
	rep movsd

; 82   : 	ent->current_position = 1;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+1364], 1

; 83   : 
; 84   : 	memset( ent->ph, 0, sizeof( position_history_t ) * HISTORY_MAX );

	push	1792					; 00000700H
	push	0
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 1368				; 00000558H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 85   : 	memcpy( &ent->ph[1], &store, sizeof( position_history_t ));

	push	28					; 0000001cH
	lea	eax, DWORD PTR _store$[ebp]
	push	eax
	mov	ecx, 28					; 0000001cH
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1368]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 86   : 	memcpy( &ent->ph[0], &store, sizeof( position_history_t ));

	push	28					; 0000001cH
	lea	eax, DWORD PTR _store$[ebp]
	push	eax
	mov	ecx, 28					; 0000001cH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1368]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@CL_ResetPo:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetPositions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_UpdatePositions
_TEXT	SEGMENT
_ph$ = -4						; size = 4
_ent$ = 8						; size = 4
_CL_UpdatePositions PROC				; COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 58   : 	position_history_t	*ph;
; 59   : 
; 60   : 	ent->current_position = (ent->current_position + 1) & HISTORY_MASK;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+1364]
	add	ecx, 1
	and	ecx, 63					; 0000003fH
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+1364], ecx

; 61   : 	ph = &ent->ph[ent->current_position];

	mov	eax, DWORD PTR _ent$[ebp]
	imul	ecx, DWORD PTR [eax+1364], 28
	mov	edx, DWORD PTR _ent$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1368]
	mov	DWORD PTR _ph$[ebp], eax

; 62   : 
; 63   : 	VectorCopy( ent->curstate.origin, ph->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+4], eax

; 64   : 	VectorCopy( ent->curstate.angles, ph->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+16], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+16], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ph$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+16], eax

; 65   : 	ph->animtime = ent->curstate.animtime;	// !!!

	mov	eax, DWORD PTR _ph$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+1004]
	mov	DWORD PTR [eax], edx

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_UpdatePositions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_EmitEntities
_TEXT	SEGMENT
_CL_EmitEntities PROC					; COMDAT

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1271 : 	if( cl.paused ) return; // don't waste time

	cmp	DWORD PTR _cl+24, 0
	je	SHORT $LN2@CL_EmitEnt
	jmp	$LN1@CL_EmitEnt
$LN2@CL_EmitEnt:

; 1272 : 
; 1273 : 	R_ClearScene ();

	call	_R_ClearScene

; 1274 : 
; 1275 : 	// not in server yet, no entities to redraw
; 1276 : 	if( cls.state != ca_active || !cl.validsequence )

	cmp	DWORD PTR _cls, 4
	jne	SHORT $LN4@CL_EmitEnt
	cmp	DWORD PTR _cl+4, 0
	jne	SHORT $LN3@CL_EmitEnt
$LN4@CL_EmitEnt:

; 1277 : 		return;

	jmp	$LN1@CL_EmitEnt
$LN3@CL_EmitEnt:

; 1278 : 
; 1279 : 	// make sure we have at least one valid update
; 1280 : 	if( !cl.frames[cl.parsecountmod].valid )

	imul	eax, DWORD PTR _cl+12, 24056
	cmp	DWORD PTR _cl[eax+112], 0
	jne	SHORT $LN5@CL_EmitEnt

; 1281 : 		return;

	jmp	SHORT $LN1@CL_EmitEnt
$LN5@CL_EmitEnt:

; 1282 : 
; 1283 : 	// animate lightestyles
; 1284 : 	CL_RunLightStyles ();

	call	_CL_RunLightStyles

; 1285 : 
; 1286 : 	// decay dynamic lights
; 1287 : 	CL_DecayLights ();

	call	_CL_DecayLights

; 1288 : 
; 1289 : 	// compute last interpolation amount
; 1290 : 	CL_UpdateFrameLerp ();

	call	_CL_UpdateFrameLerp

; 1291 : 
; 1292 : 	// set client ideal pitch when mlook is disabled
; 1293 : 	CL_SetIdealPitch ();

	call	_CL_SetIdealPitch

; 1294 : 
; 1295 : 	// clear the scene befor start new frame
; 1296 : 	if( clgame.drawFuncs.R_ClearScene != NULL )

	cmp	DWORD PTR _clgame+220, 0
	je	SHORT $LN6@CL_EmitEnt

; 1297 : 		clgame.drawFuncs.R_ClearScene();

	call	DWORD PTR _clgame+220
$LN6@CL_EmitEnt:

; 1298 : 
; 1299 : 	// link all the visible clients first
; 1300 : 	CL_LinkPlayers ( &cl.frames[cl.parsecountmod] );

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_LinkPlayers
	add	esp, 4

; 1301 : 
; 1302 : 	// link all the entities that actually have update
; 1303 : 	CL_LinkPacketEntities ( &cl.frames[cl.parsecountmod] );

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	push	eax
	call	_CL_LinkPacketEntities
	add	esp, 4

; 1304 : 
; 1305 : 	// link custom user temp entities
; 1306 : 	clgame.dllFuncs.pfnCreateEntities();

	call	DWORD PTR _clgame+88

; 1307 : 
; 1308 : 	// evaluate temp entities
; 1309 : 	CL_TempEntUpdate ();

	call	_CL_TempEntUpdate

; 1310 : 
; 1311 : 	// fire events (client and server)
; 1312 : 	CL_FireEvents ();

	call	_CL_FireEvents

; 1313 : 
; 1314 : 	// handle spectator camera movement
; 1315 : 	CL_MoveSpectatorCamera();

	call	_CL_MoveSpectatorCamera

; 1316 : 
; 1317 : 	// perfomance test
; 1318 : 	CL_TestLights();

	call	_CL_TestLights
$LN1@CL_EmitEnt:

; 1319 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EmitEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_IsPlayerIndex
_TEXT	SEGMENT
tv66 = -68						; size = 4
_idx$ = 8						; size = 4
_CL_IsPlayerIndex PROC					; COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 39   : 	return ( idx >= 1 && idx <= cl.maxclients );

	cmp	DWORD PTR _idx$[ebp], 1
	jl	SHORT $LN3@CL_IsPlaye
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jg	SHORT $LN3@CL_IsPlaye
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@CL_IsPlaye
$LN3@CL_IsPlaye:
	mov	DWORD PTR tv66[ebp], 0
$LN4@CL_IsPlaye:
	mov	eax, DWORD PTR tv66[ebp]

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_IsPlayerIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_MoveThirdpersonCamera
_TEXT	SEGMENT
_CL_MoveThirdpersonCamera PROC				; COMDAT

; 1253 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1254 : 	if( cls.state == ca_disconnected || cls.state == ca_cinematic )

	cmp	DWORD PTR _cls, 0
	je	SHORT $LN3@CL_MoveThi
	cmp	DWORD PTR _cls, 5
	jne	SHORT $LN2@CL_MoveThi
$LN3@CL_MoveThi:

; 1255 : 		return;

	jmp	SHORT $LN1@CL_MoveThi
$LN2@CL_MoveThi:

; 1256 : 
; 1257 : 	// think thirdperson camera
; 1258 : 	clgame.dllFuncs.CAM_Think ();

	call	DWORD PTR _clgame+76
$LN1@CL_MoveThi:

; 1259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_MoveThirdpersonCamera ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ProcessPacket
_TEXT	SEGMENT
_pnum$ = -12						; size = 4
_ent$ = -8						; size = 4
_state$ = -4						; size = 4
_frame$ = 8						; size = 4
_CL_ProcessPacket PROC					; COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 582  : 	entity_state_t	*state;
; 583  : 	cl_entity_t	*ent;
; 584  : 	int		pnum;
; 585  : 
; 586  : 	for( pnum = 0; pnum < frame->num_entities; pnum++ )

	mov	DWORD PTR _pnum$[ebp], 0
	jmp	SHORT $LN4@CL_Process
$LN2@CL_Process:
	mov	eax, DWORD PTR _pnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _pnum$[ebp], eax
$LN4@CL_Process:
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _pnum$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jge	$LN3@CL_Process

; 587  : 	{
; 588  : 		// request the entity state from circular buffer
; 589  : 		state = &cls.packet_entities[(frame->first_entity+pnum) % cls.num_client_entities];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _pnum$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], ecx

; 590  : 		state->messagenum = cl.parsecount;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _cl+8
	mov	DWORD PTR [eax+12], ecx

; 591  : 		state->msg_time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	mov	edx, DWORD PTR _state$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 592  : 
; 593  : 		// mark all the players
; 594  : 		ent = &clgame.entities[state->number];

	mov	eax, DWORD PTR _state$[ebp]
	imul	ecx, DWORD PTR [eax+4], 3336
	add	ecx, DWORD PTR _clgame+996
	mov	DWORD PTR _ent$[ebp], ecx

; 595  : 		ent->player = CL_IsPlayerIndex( state->number );

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	edx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 596  : 
; 597  : 		if( state->number == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN5@CL_Process

; 598  : 			clgame.dllFuncs.pfnTxferLocalOverrides( state, &frame->clientdata );

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	DWORD PTR _clgame+112
	add	esp, 8
$LN5@CL_Process:

; 599  : 
; 600  : 		// shuffle states
; 601  : 		ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 912				; 00000390H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 460				; 000001ccH
	mov	ecx, 113				; 00000071H
	rep movsd

; 602  : 		ent->curstate = *state;

	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 912				; 00000390H
	mov	ecx, 113				; 00000071H
	mov	esi, DWORD PTR _state$[ebp]
	rep movsd

; 603  : 
; 604  : 		CL_ProcessEntityUpdate( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_ProcessEntityUpdate
	add	esp, 4

; 605  : 		CL_ResetLatchedState( pnum, frame, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pnum$[ebp]
	push	edx
	call	_CL_ResetLatchedState
	add	esp, 12					; 0000000cH

; 606  : 		if( !ent->player ) continue;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@CL_Process
	jmp	$LN2@CL_Process
$LN6@CL_Process:

; 607  : 
; 608  : 		CL_ProcessPlayerState(( state->number - 1 ), state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	push	edx
	call	_CL_ProcessPlayerState
	add	esp, 8

; 609  : 
; 610  : 		if( state->number == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN7@CL_Process

; 611  : 			CL_CheckPredictionError();

	call	_CL_CheckPredictionError
$LN7@CL_Process:

; 612  : 	}

	jmp	$LN2@CL_Process
$LN3@CL_Process:

; 613  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessPacket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ComputePlayerOrigin
_TEXT	SEGMENT
tv149 = -148						; size = 4
_angles$ = -80						; size = 12
_origin$ = -68						; size = 12
_q2$ = -56						; size = 16
_q1$ = -40						; size = 16
_q$ = -24						; size = 16
_targettime$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_CL_ComputePlayerOrigin PROC				; COMDAT

; 503  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 504  : 	float	targettime;
; 505  : 	vec4_t	q, q1, q2;
; 506  : 	vec3_t	origin;
; 507  : 	vec3_t	angles;
; 508  : 
; 509  : 	if( !ent->player || ent->index == ( cl.playernum + 1 ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@CL_Compute
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN2@CL_Compute
$LN3@CL_Compute:

; 510  : 		return;

	jmp	$LN1@CL_Compute
$LN2@CL_Compute:

; 511  : 
; 512  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	$LN4@CL_Compute

; 513  : 	{
; 514  : 		// quake lerping is easy
; 515  : 		VectorLerp( ent->prevstate.origin, cl.lerpFrac, ent->curstate.origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+edx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+476]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [eax+edx+3224], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+928]
	subss	xmm0, DWORD PTR [edi+eax+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	edx, DWORD PTR _ent$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+476]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	movss	DWORD PTR [ecx+eax+3224], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+ecx+476]
	mulss	xmm0, DWORD PTR _cl+48
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+476]
	addss	xmm1, xmm0
	movss	DWORD PTR tv149[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	DWORD PTR [edx+ecx+3224], xmm0

; 516  : 		AngleQuaternion( ent->prevstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 488				; 000001e8H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 517  : 		AngleQuaternion( ent->curstate.angles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 518  : 		QuaternionSlerp( q1, q2, cl.lerpFrac, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _q1$[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 519  : 		QuaternionAngle( q, ent->angles );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3236				; 00000ca4H
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 520  : 		return;

	jmp	$LN1@CL_Compute
$LN4@CL_Compute:

; 521  : 	}
; 522  : 
; 523  : 	targettime = cl.time - cl_interp->value;

	mov	eax, DWORD PTR _cl_interp
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	xmm1, QWORD PTR _cl+2167640
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _targettime$[ebp], xmm0

; 524  : 	CL_PureOrigin( ent, targettime, origin, angles );

	lea	eax, DWORD PTR _angles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _targettime$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_CL_PureOrigin
	add	esp, 16					; 00000010H

; 525  : 
; 526  : 	VectorCopy( angles, ent->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3236], eax

; 527  : 	VectorCopy( origin, ent->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _origin$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3224], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR _origin$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3224], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR _origin$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3224], eax
$LN1@CL_Compute:

; 528  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ComputePlayerOrigin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ProcessPlayerState
_TEXT	SEGMENT
_ps$ = -4						; size = 4
_playerindex$ = 8					; size = 4
_state$ = 12						; size = 4
_CL_ProcessPlayerState PROC				; COMDAT

; 538  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 539  : 	entity_state_t	*ps;
; 540  : 
; 541  : 	ps = &cl.frames[cl.parsecountmod].playerstate[playerindex];

	imul	eax, DWORD PTR _cl+12, 24056
	imul	ecx, DWORD PTR _playerindex$[ebp], 452
	lea	edx, DWORD PTR _cl[eax+ecx+2736]
	mov	DWORD PTR _ps$[ebp], edx

; 542  : 	ps->number = state->number;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 543  : 	ps->messagenum = cl.parsecount;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _cl+8
	mov	DWORD PTR [eax+12], ecx

; 544  : 	ps->msg_time = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	mov	edx, DWORD PTR _ps$[ebp]
	movss	DWORD PTR [edx+8], xmm0

; 545  : 
; 546  : 	clgame.dllFuncs.pfnProcessPlayerState( ps, state );

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	push	ecx
	call	DWORD PTR _clgame+116
	add	esp, 8

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ProcessPlayerState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_GetMovieSpatialization
_TEXT	SEGMENT
tv188 = -76						; size = 4
tv158 = -76						; size = 4
tv76 = -76						; size = 4
_valid_origin$ = -8					; size = 4
_ent$ = -4						; size = 4
_ch$ = 8						; size = 4
_CL_GetMovieSpatialization PROC				; COMDAT

; 1375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1376 : 	cl_entity_t	*ent;
; 1377 : 	qboolean		valid_origin;
; 1378 : 
; 1379 : 	valid_origin = VectorIsNull( ch->origin ) ? false : true;          

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_GetMovi
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN8@CL_GetMovi
$LN7@CL_GetMovi:
	mov	DWORD PTR tv76[ebp], 1
$LN8@CL_GetMovi:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _valid_origin$[ebp], ecx

; 1380 : 	ent = CL_GetEntityByIndex( ch->entnum );

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1381 : 
; 1382 : 	// entity is not present on the client but has valid origin
; 1383 : 	if( !ent || !ent->index || ent->curstate.messagenum == 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN3@CL_GetMovi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@CL_GetMovi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+924], 0
	jne	SHORT $LN2@CL_GetMovi
$LN3@CL_GetMovi:

; 1384 : 		return valid_origin;

	mov	eax, DWORD PTR _valid_origin$[ebp]
	jmp	$LN1@CL_GetMovi
$LN2@CL_GetMovi:

; 1385 : 
; 1386 : 	// setup origin
; 1387 : 	VectorAverage( ent->curstate.mins, ent->curstate.maxs, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1076]
	addss	xmm0, DWORD PTR [esi+eax+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1076]
	addss	xmm0, DWORD PTR [esi+ecx+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1076]
	addss	xmm0, DWORD PTR [esi+eax+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv158[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv158[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 1388 : 	VectorAdd( ch->origin, ent->curstate.origin, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	addss	xmm0, DWORD PTR [esi+eax+928]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+20], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	addss	xmm0, DWORD PTR [esi+ecx+928]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+20], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	addss	xmm0, DWORD PTR [esi+eax+928]
	movss	DWORD PTR tv188[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR [eax+edx+20], xmm0

; 1389 : 
; 1390 : 	// setup radius
; 1391 : 	if( ent->model != NULL && ent->model->radius ) ch->radius = ent->model->radius;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN4@CL_GetMovi
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	movss	xmm0, DWORD PTR [ecx+108]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@CL_GetMovi
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	mov	DWORD PTR [edx+32], eax
	jmp	SHORT $LN5@CL_GetMovi
$LN4@CL_GetMovi:

; 1392 : 	else ch->radius = RadiusFromBounds( ent->curstate.mins, ent->curstate.maxs );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 1088				; 00000440H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 1076				; 00000434H
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [edx+32]
$LN5@CL_GetMovi:

; 1393 : 
; 1394 : 	return true;

	mov	eax, 1
$LN1@CL_GetMovi:

; 1395 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetMovieSpatialization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_GetEntitySpatialization
_TEXT	SEGMENT
tv271 = -76						; size = 4
tv241 = -76						; size = 4
tv211 = -76						; size = 4
tv181 = -76						; size = 4
tv129 = -76						; size = 4
_valid_origin$ = -8					; size = 4
_ent$ = -4						; size = 4
_ch$ = 8						; size = 4
_CL_GetEntitySpatialization PROC			; COMDAT

; 1329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1330 : 	cl_entity_t	*ent;
; 1331 : 	qboolean		valid_origin;
; 1332 : 
; 1333 : 	if( ch->entnum == 0 )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN2@CL_GetEnti

; 1334 : 	{
; 1335 : 		ch->staticsound = true;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+72], 1

; 1336 : 		return true; // static sound

	mov	eax, 1
	jmp	$LN1@CL_GetEnti
$LN2@CL_GetEnti:

; 1337 : 	}
; 1338 : 
; 1339 : 	if(( ch->entnum - 1 ) == cl.playernum )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, 1
	cmp	ecx, DWORD PTR _cl+2213000
	jne	SHORT $LN3@CL_GetEnti

; 1340 : 	{
; 1341 : 		VectorCopy( RI.vieworg, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _RI[ecx+200]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR _RI[edx+200]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _RI[eax+200]
	mov	DWORD PTR [edx+ecx+36], eax

; 1342 : 		return true;

	mov	eax, 1
	jmp	$LN1@CL_GetEnti
$LN3@CL_GetEnti:

; 1343 : 	}
; 1344 : 
; 1345 : 	valid_origin = VectorIsNull( ch->origin ) ? false : true;          

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+36]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_GetEnti
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN10@CL_GetEnti
$LN9@CL_GetEnti:
	mov	DWORD PTR tv129[ebp], 1
$LN10@CL_GetEnti:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _valid_origin$[ebp], ecx

; 1346 : 	ent = CL_GetEntityByIndex( ch->entnum );

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_CL_GetEntityByIndex
	add	esp, 4
	mov	DWORD PTR _ent$[ebp], eax

; 1347 : 
; 1348 : 	// entity is not present on the client but has valid origin
; 1349 : 	if( !ent || !ent->index || ent->curstate.messagenum == 0 )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+924], 0
	jne	SHORT $LN4@CL_GetEnti
$LN5@CL_GetEnti:

; 1350 : 		return valid_origin;

	mov	eax, DWORD PTR _valid_origin$[ebp]
	jmp	$LN1@CL_GetEnti
$LN4@CL_GetEnti:

; 1351 : 
; 1352 : #if 0
; 1353 : 	// uncomment this if you want enable additional check by PVS
; 1354 : 	if( ent->curstate.messagenum != cl.parsecount )
; 1355 : 		return valid_origin;
; 1356 : #endif
; 1357 : 	ch->movetype = ent->curstate.movetype;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+1000]
	mov	DWORD PTR [eax+160], edx

; 1358 : 
; 1359 : 	// setup origin
; 1360 : 	VectorAverage( ent->curstate.mins, ent->curstate.maxs, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1076]
	addss	xmm0, DWORD PTR [esi+eax+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	imul	ecx, eax, 0
	cvtsd2ss xmm0, xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+36], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1076]
	addss	xmm0, DWORD PTR [esi+ecx+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+36], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1076]
	addss	xmm0, DWORD PTR [esi+eax+1088]
	cvtss2sd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv181[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv181[ebp]
	movss	DWORD PTR [eax+edx+36], xmm0

; 1361 : 	VectorAdd( ch->origin, ent->curstate.origin, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+36]
	addss	xmm0, DWORD PTR [esi+eax+928]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+36], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+36]
	addss	xmm0, DWORD PTR [esi+ecx+928]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+36], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+36]
	addss	xmm0, DWORD PTR [esi+eax+928]
	movss	DWORD PTR tv211[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv211[ebp]
	movss	DWORD PTR [eax+edx+36], xmm0

; 1362 : 
; 1363 : 	// setup mins\maxs
; 1364 : 	VectorAdd( ent->curstate.mins, ent->curstate.origin, ch->absmin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1076]
	addss	xmm0, DWORD PTR [esi+eax+928]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+136], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1076]
	addss	xmm0, DWORD PTR [esi+ecx+928]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+136], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1076]
	addss	xmm0, DWORD PTR [esi+eax+928]
	movss	DWORD PTR tv241[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	movss	DWORD PTR [eax+edx+136], xmm0

; 1365 : 	VectorAdd( ent->curstate.maxs, ent->curstate.origin, ch->absmax );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+1088]
	addss	xmm0, DWORD PTR [esi+eax+928]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [edx+ecx+148], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+1088]
	addss	xmm0, DWORD PTR [esi+ecx+928]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [ecx+eax+148], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+1088]
	addss	xmm0, DWORD PTR [esi+eax+928]
	movss	DWORD PTR tv271[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR tv271[ebp]
	movss	DWORD PTR [eax+edx+148], xmm0

; 1366 : 
; 1367 : 	// setup radius
; 1368 : 	if( ent->model != NULL && ent->model->radius ) ch->radius = ent->model->radius;

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN6@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	movss	xmm0, DWORD PTR [ecx+108]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_GetEnti
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	mov	DWORD PTR [edx+132], eax
	jmp	SHORT $LN7@CL_GetEnti
$LN6@CL_GetEnti:

; 1369 : 	else ch->radius = RadiusFromBounds( ent->curstate.mins, ent->curstate.maxs );

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 1088				; 00000440H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 1076				; 00000434H
	push	ecx
	call	_RadiusFromBounds
	add	esp, 8
	mov	edx, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [edx+132]
$LN7@CL_GetEnti:

; 1370 : 
; 1371 : 	return true;

	mov	eax, 1
$LN1@CL_GetEnti:

; 1372 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetEntitySpatialization ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ResetLatchedVars
_TEXT	SEGMENT
tv135 = -68						; size = 4
_ent$ = 8						; size = 4
_full_reset$ = 12					; size = 4
_CL_ResetLatchedVars PROC				; COMDAT

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 237  : 	if( !ent->model || ( ent->model->type != mod_alias && ent->model->type != mod_studio ))

	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	je	SHORT $LN3@CL_ResetLa
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	je	SHORT $LN2@CL_ResetLa
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	je	SHORT $LN2@CL_ResetLa
$LN3@CL_ResetLa:

; 238  : 		return; // below fields used only for alias and studio interpolation

	jmp	$LN1@CL_ResetLa
$LN2@CL_ResetLa:

; 239  : 
; 240  : 	if( full_reset )

	cmp	DWORD PTR _full_reset$[ebp], 0
	je	$LN4@CL_ResetLa

; 241  : 	{
; 242  : 		// don't modify for sprites to avoid broke sprite interp
; 243  : 		memcpy( ent->latched.prevblending, ent->curstate.blending, sizeof( ent->latched.prevblending ));

	push	2
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 1016				; 000003f8H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3216				; 00000c90H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 244  : 		ent->latched.sequencetime = ent->curstate.animtime;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+1004]
	mov	DWORD PTR [eax+3172], edx

; 245  : 		memcpy( ent->latched.prevcontroller, ent->curstate.controller, sizeof( ent->latched.prevcontroller ));

	push	4
	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 1012				; 000003f4H
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	add	ecx, 3212				; 00000c8cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 246  : 		if( ent->model->type == mod_studio )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 3
	jne	SHORT $LN5@CL_ResetLa

; 247  : 			ent->latched.prevframe = CL_GetStudioEstimatedFrame( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_GetStudioEstimatedFrame
	add	esp, 4
	mov	ecx, DWORD PTR _ent$[ebp]
	fstp	DWORD PTR [ecx+3208]
	jmp	SHORT $LN7@CL_ResetLa
$LN5@CL_ResetLa:

; 248  : 		else if( ent->model->type == mod_alias )

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	cmp	DWORD PTR [ecx+68], 2
	jne	SHORT $LN7@CL_ResetLa

; 249  : 			ent->latched.prevframe = ent->curstate.frame;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+960]
	mov	DWORD PTR [eax+3208], edx
$LN7@CL_ResetLa:

; 250  : 		ent->prevstate = ent->curstate;

	mov	esi, DWORD PTR _ent$[ebp]
	add	esi, 912				; 00000390H
	mov	edi, DWORD PTR _ent$[ebp]
	add	edi, 460				; 000001ccH
	mov	ecx, 113				; 00000071H
	rep movsd
$LN4@CL_ResetLa:

; 251  : 	}
; 252  : 
; 253  : 	ent->latched.prevanimtime = ent->curstate.animtime = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR tv135[ebp], xmm0
	mov	edx, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR [edx+1004], xmm0
	mov	eax, DWORD PTR _ent$[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR [eax+3168], xmm0

; 254  : 	VectorCopy( ent->curstate.origin, ent->latched.prevorigin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+928]
	mov	DWORD PTR [edx+eax+3180], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+928]
	mov	DWORD PTR [ecx+eax+3180], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+928]
	mov	DWORD PTR [edx+ecx+3180], eax

; 255  : 	VectorCopy( ent->curstate.angles, ent->latched.prevangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3192], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3192], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	esi, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3192], eax

; 256  : 	ent->latched.prevsequence = ent->curstate.sequence;

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR [eax+3204], edx
$LN1@CL_ResetLa:

; 257  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetLatchedVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_AddVisibleEntity
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_entityType$ = 12					; size = 4
_CL_AddVisibleEntity PROC				; COMDAT

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 925  : 	if( !ent || !ent->model )

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN3@CL_AddVisi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+3300], 0
	jne	SHORT $LN2@CL_AddVisi
$LN3@CL_AddVisi:

; 926  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_AddVisi
$LN2@CL_AddVisi:

; 927  : 
; 928  : 	// check for adding this entity
; 929  : 	if( !clgame.dllFuncs.pfnAddEntity( entityType, ent, ent->model->name ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityType$[ebp]
	push	eax
	call	DWORD PTR _clgame+84
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@CL_AddVisi

; 930  : 	{
; 931  : 		// local player was reject by game code, so ignore any effects
; 932  : 		if( RP_LOCALCLIENT( ent ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN5@CL_AddVisi
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN5@CL_AddVisi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@CL_AddVisi

; 933  : 			cl.local.apply_effects = false;

	mov	DWORD PTR _cl+2212640, 0
$LN5@CL_AddVisi:

; 934  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_AddVisi
$LN4@CL_AddVisi:

; 935  : 	}
; 936  : 
; 937  : 	// don't add the player in firstperson mode unless they are mirrors
; 938  : 	//if( RP_LOCALCLIENT( ent ) && !CL_IsThirdPerson( ) && ( ent->index == cl.viewentity ))
; 939  : 	//	return false;
; 940  : 
; 941  : 	if( entityType == ET_BEAM )

	cmp	DWORD PTR _entityType$[ebp], 3
	jne	SHORT $LN6@CL_AddVisi

; 942  : 	{
; 943  : 		CL_AddCustomBeam( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddCustomBeam
	add	esp, 4

; 944  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_AddVisi

; 945  : 	}

	jmp	SHORT $LN7@CL_AddVisi
$LN6@CL_AddVisi:

; 946  : 	else if( !R_AddEntity( ent, entityType ))

	mov	eax, DWORD PTR _entityType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_R_AddEntity
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@CL_AddVisi

; 947  : 	{
; 948  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_AddVisi
$LN7@CL_AddVisi:

; 949  : 	}
; 950  : 
; 951  : 	// because pTemp->entity.curstate.effects
; 952  : 	// is already occupied by FTENT_FLICKER
; 953  : 	if( entityType != ET_TEMPENTITY )

	cmp	DWORD PTR _entityType$[ebp], 2
	je	SHORT $LN9@CL_AddVisi

; 954  : 	{
; 955  : 		// no reason to do it twice
; 956  : 		if( RP_LOCALCLIENT( ent ))

	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $LN10@CL_AddVisi
	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	ecx, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN10@CL_AddVisi
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN10@CL_AddVisi

; 957  : 			cl.local.apply_effects = false;

	mov	DWORD PTR _cl+2212640, 0
$LN10@CL_AddVisi:

; 958  : 
; 959  : 		// apply client-side effects
; 960  : 		CL_AddEntityEffects( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddEntityEffects
	add	esp, 4

; 961  : 
; 962  : 		// alias & studiomodel efefcts
; 963  : 		CL_AddModelEffects( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_CL_AddModelEffects
	add	esp, 4
$LN9@CL_AddVisi:

; 964  : 	}
; 965  : 
; 966  : 	return true;

	mov	eax, 1
$LN1@CL_AddVisi:

; 967  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_AddVisibleEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ParsePacketEntities
_TEXT	SEGMENT
tv230 = -116						; size = 4
_subtracted$1 = -48					; size = 4
_count$ = -44						; size = 4
_player$ = -40						; size = 4
_oldent$ = -36						; size = 4
_bufStart$ = -32					; size = 4
_oldpacket$ = -28					; size = 4
_playerbytes$ = -24					; size = 4
_oldnum$ = -20						; size = 4
_newnum$ = -16						; size = 4
_oldindex$ = -12					; size = 4
_oldframe$ = -8						; size = 4
_newframe$ = -4						; size = 4
_msg$ = 8						; size = 4
_delta$ = 12						; size = 4
_CL_ParsePacketEntities PROC				; COMDAT

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 724  : 	frame_t		*newframe, *oldframe;
; 725  : 	int		oldindex, newnum, oldnum;
; 726  : 	int		playerbytes = 0;

	mov	DWORD PTR _playerbytes$[ebp], 0

; 727  : 	int		oldpacket;
; 728  : 	int		bufStart;
; 729  : 	entity_state_t	*oldent;
; 730  : 	qboolean		player;
; 731  : 	int		count;
; 732  : 
; 733  : 	// save first uncompressed packet as timestamp
; 734  : 	if( cls.changelevel && !delta && cls.demorecording )

	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN8@CL_ParsePa
	cmp	DWORD PTR _delta$[ebp], 0
	jne	SHORT $LN8@CL_ParsePa
	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN8@CL_ParsePa

; 735  : 		CL_WriteDemoJumpTime();

	call	_CL_WriteDemoJumpTime
$LN8@CL_ParsePa:

; 736  : 
; 737  : 	// sentinel count. save it for debug checking
; 738  : 	count = ( MSG_ReadUBitLong( msg, MAX_VISIBLE_PACKET_BITS ) + 1 );

	push	11					; 0000000bH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 739  : 	newframe = &cl.frames[cl.parsecountmod];

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _newframe$[ebp], eax

; 740  : 
; 741  : 	// allocate parse entities
; 742  : 	memset( newframe->flags, 0, sizeof( newframe->flags ));

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _newframe$[ebp]
	add	eax, 23786				; 00005ceaH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 743  : 	newframe->first_entity = cls.next_client_entities;

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	ecx, DWORD PTR _cls+295008
	mov	DWORD PTR [eax+24048], ecx

; 744  : 	newframe->num_entities = 0;

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	DWORD PTR [eax+24044], 0

; 745  : 	newframe->valid = true; // assume valid

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	DWORD PTR [eax+24], 1

; 746  : 
; 747  : 	if( delta )

	cmp	DWORD PTR _delta$[ebp], 0
	je	$LN9@CL_ParsePa

; 748  : 	{
; 749  : 		int	subtracted;
; 750  : 
; 751  : 		oldpacket = MSG_ReadByte( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadByte
	add	esp, 4
	mov	DWORD PTR _oldpacket$[ebp], eax

; 752  : 		subtracted = ( cls.netchan.incoming_sequence - oldpacket ) & 0xFF;

	mov	eax, DWORD PTR _cls+26864
	sub	eax, DWORD PTR _oldpacket$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _subtracted$1[ebp], eax

; 753  : 
; 754  : 		if( subtracted == 0 )

	jne	SHORT $LN11@CL_ParsePa

; 755  : 		{
; 756  : 			Con_NPrintf( 2, "^3Warning:^1 update too old\n^7\n" );

	push	OFFSET ??_C@_0CA@KFJDBNOP@?$FO3Warning?3?$FO1?5update?5too?5old?6?$FO7?6@
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 757  : 			CL_FlushEntityPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_FlushEntityPacket
	add	esp, 4

; 758  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN11@CL_ParsePa:

; 759  : 		}
; 760  : 
; 761  : 		if( subtracted >= CL_UPDATE_MASK )

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	cmp	DWORD PTR _subtracted$1[ebp], eax
	jl	SHORT $LN12@CL_ParsePa

; 762  : 		{	
; 763  : 			// we can't use this, it is too old
; 764  : 			Con_NPrintf( 2, "^3Warning:^1 delta frame is too old^7\n" );

	push	OFFSET ??_C@_0CH@BFLDNJMA@?$FO3Warning?3?$FO1?5delta?5frame?5is?5too@
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 765  : 			CL_FlushEntityPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_FlushEntityPacket
	add	esp, 4

; 766  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN12@CL_ParsePa:

; 767  : 		}
; 768  : 
; 769  : 		oldframe = &cl.frames[oldpacket & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _oldpacket$[ebp]
	imul	ecx, eax, 24056
	add	ecx, OFFSET _cl+88
	mov	DWORD PTR _oldframe$[ebp], ecx

; 770  : 
; 771  : 		if(( cls.next_client_entities - oldframe->first_entity ) > ( cls.num_client_entities - NUM_PACKET_ENTITIES ))

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _cls+295008
	sub	ecx, DWORD PTR [eax+24048]
	mov	edx, DWORD PTR _cls+295004
	sub	edx, 256				; 00000100H
	cmp	ecx, edx
	jle	SHORT $LN13@CL_ParsePa

; 772  : 		{
; 773  : 			Con_NPrintf( 2, "^3Warning:^1 delta frame is too old^7\n" );

	push	OFFSET ??_C@_0CH@BFLDNJMA@?$FO3Warning?3?$FO1?5delta?5frame?5is?5too@
	push	2
	call	_Con_NPrintf
	add	esp, 8

; 774  : 			CL_FlushEntityPacket( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_FlushEntityPacket
	add	esp, 4

; 775  : 			return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	$LN1@CL_ParsePa
$LN13@CL_ParsePa:

; 776  : 		}
; 777  : 	}

	jmp	SHORT $LN10@CL_ParsePa
$LN9@CL_ParsePa:

; 778  : 	else
; 779  : 	{
; 780  : 		// this is a full update that we can start delta compressing from now
; 781  : 		oldframe = NULL;

	mov	DWORD PTR _oldframe$[ebp], 0

; 782  : 		oldpacket = -1;		// delta too old or is initial message

	mov	DWORD PTR _oldpacket$[ebp], -1

; 783  : 		cl.send_reply = true;	// send reply

	mov	DWORD PTR _cl+60, 1

; 784  : 		cls.demowaiting = false;	// we can start recording now

	mov	DWORD PTR _cls+300832, 0
$LN10@CL_ParsePa:

; 785  : 	}
; 786  : 
; 787  : 	// mark current delta state
; 788  : 	cl.validsequence = cls.netchan.incoming_sequence;

	mov	eax, DWORD PTR _cls+26864
	mov	DWORD PTR _cl+4, eax

; 789  : 
; 790  : 	oldent = NULL;

	mov	DWORD PTR _oldent$[ebp], 0

; 791  : 	oldindex = 0;

	mov	DWORD PTR _oldindex$[ebp], 0

; 792  : 
; 793  : 	if( !oldframe )

	cmp	DWORD PTR _oldframe$[ebp], 0
	jne	SHORT $LN14@CL_ParsePa

; 794  : 	{
; 795  : 		oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 796  : 	}

	jmp	SHORT $LN2@CL_ParsePa
$LN14@CL_ParsePa:

; 797  : 	else
; 798  : 	{
; 799  : 		if( oldindex >= oldframe->num_entities )

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _oldindex$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jl	SHORT $LN16@CL_ParsePa

; 800  : 		{
; 801  : 			oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 802  : 		}

	jmp	SHORT $LN2@CL_ParsePa
$LN16@CL_ParsePa:

; 803  : 		else
; 804  : 		{
; 805  : 			oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _oldent$[ebp], ecx

; 806  : 			oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN2@CL_ParsePa:

; 807  : 		}
; 808  : 	}
; 809  : 
; 810  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN6@CL_ParsePa

; 811  : 	{
; 812  : 		newnum = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _newnum$[ebp], eax

; 813  : 		if( newnum == LAST_EDICT ) break; // end of packet entities

	cmp	DWORD PTR _newnum$[ebp], 8191		; 00001fffH
	jne	SHORT $LN18@CL_ParsePa
	jmp	$LN6@CL_ParsePa
$LN18@CL_ParsePa:

; 814  : 
; 815  : 		if( MSG_CheckOverflow( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_CheckOverflow
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@CL_ParsePa

; 816  : 			Host_Error( "CL_ParsePacketEntities: overflow\n" );

	push	OFFSET ??_C@_0CC@PGNDCAEK@CL_ParsePacketEntities?3?5overflo@
	call	_Host_Error
	add	esp, 4
$LN19@CL_ParsePa:

; 817  : 		player = CL_IsPlayerIndex( newnum );

	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	call	_CL_IsPlayerIndex
	add	esp, 4
	mov	DWORD PTR _player$[ebp], eax
$LN4@CL_ParsePa:

; 818  : 
; 819  : 		while( oldnum < newnum )

	mov	eax, DWORD PTR _oldnum$[ebp]
	cmp	eax, DWORD PTR _newnum$[ebp]
	jge	SHORT $LN5@CL_ParsePa

; 820  : 		{	
; 821  : 			// one or more entities from the old packet are unchanged
; 822  : 			CL_DeltaEntity( msg, newframe, oldnum, oldent, false );

	push	0
	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 823  : 			oldindex++;

	mov	eax, DWORD PTR _oldindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _oldindex$[ebp], eax

; 824  : 
; 825  : 			if( oldindex >= oldframe->num_entities )

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _oldindex$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jl	SHORT $LN20@CL_ParsePa

; 826  : 			{
; 827  : 				oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 828  : 			}

	jmp	SHORT $LN21@CL_ParsePa
$LN20@CL_ParsePa:

; 829  : 			else
; 830  : 			{
; 831  : 				oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _oldent$[ebp], ecx

; 832  : 				oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN21@CL_ParsePa:

; 833  : 			}
; 834  : 		}

	jmp	SHORT $LN4@CL_ParsePa
$LN5@CL_ParsePa:

; 835  : 
; 836  : 		if( oldnum == newnum )

	mov	eax, DWORD PTR _oldnum$[ebp]
	cmp	eax, DWORD PTR _newnum$[ebp]
	jne	$LN22@CL_ParsePa

; 837  : 		{	
; 838  : 			// delta from previous state
; 839  : 			bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 840  : 			CL_DeltaEntity( msg, newframe, newnum, oldent, true );

	push	1
	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 841  : 			if( player ) playerbytes += MSG_GetNumBytesRead( msg ) - bufStart;

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN23@CL_ParsePa
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	add	eax, DWORD PTR _playerbytes$[ebp]
	mov	DWORD PTR _playerbytes$[ebp], eax
$LN23@CL_ParsePa:

; 842  : 			oldindex++;

	mov	eax, DWORD PTR _oldindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _oldindex$[ebp], eax

; 843  : 
; 844  : 			if( oldindex >= oldframe->num_entities )

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _oldindex$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jl	SHORT $LN24@CL_ParsePa

; 845  : 			{
; 846  : 				oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 847  : 			}

	jmp	SHORT $LN25@CL_ParsePa
$LN24@CL_ParsePa:

; 848  : 			else
; 849  : 			{
; 850  : 				oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _oldent$[ebp], ecx

; 851  : 				oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN25@CL_ParsePa:

; 852  : 			}
; 853  : 			continue;

	jmp	$LN2@CL_ParsePa
$LN22@CL_ParsePa:

; 854  : 		}
; 855  : 
; 856  : 		if( oldnum > newnum )

	mov	eax, DWORD PTR _oldnum$[ebp]
	cmp	eax, DWORD PTR _newnum$[ebp]
	jle	SHORT $LN26@CL_ParsePa

; 857  : 		{	
; 858  : 			// delta from baseline ?
; 859  : 			bufStart = MSG_GetNumBytesRead( msg );

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	DWORD PTR _bufStart$[ebp], eax

; 860  : 			CL_DeltaEntity( msg, newframe, newnum, NULL, true );

	push	1
	push	0
	mov	eax, DWORD PTR _newnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newframe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 861  : 			if( player ) playerbytes += MSG_GetNumBytesRead( msg ) - bufStart;

	cmp	DWORD PTR _player$[ebp], 0
	je	SHORT $LN27@CL_ParsePa
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _bufStart$[ebp]
	add	eax, DWORD PTR _playerbytes$[ebp]
	mov	DWORD PTR _playerbytes$[ebp], eax
$LN27@CL_ParsePa:

; 862  : 			continue;

	jmp	$LN2@CL_ParsePa
$LN26@CL_ParsePa:

; 863  : 		}
; 864  : 	}

	jmp	$LN2@CL_ParsePa
$LN6@CL_ParsePa:

; 865  : 
; 866  : 	// any remaining entities in the old frame are copied over
; 867  : 	while( oldnum != MAX_ENTNUMBER )

	cmp	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH
	je	SHORT $LN7@CL_ParsePa

; 868  : 	{	
; 869  : 		// one or more entities from the old packet are unchanged
; 870  : 		CL_DeltaEntity( msg, newframe, oldnum, oldent, false );

	push	0
	mov	eax, DWORD PTR _oldent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_CL_DeltaEntity
	add	esp, 20					; 00000014H

; 871  : 		oldindex++;

	mov	eax, DWORD PTR _oldindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _oldindex$[ebp], eax

; 872  : 
; 873  : 		if( oldindex >= oldframe->num_entities )

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	ecx, DWORD PTR _oldindex$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jl	SHORT $LN28@CL_ParsePa

; 874  : 		{
; 875  : 			oldnum = MAX_ENTNUMBER;

	mov	DWORD PTR _oldnum$[ebp], 99999		; 0001869fH

; 876  : 		}

	jmp	SHORT $LN29@CL_ParsePa
$LN28@CL_ParsePa:

; 877  : 		else
; 878  : 		{
; 879  : 			oldent = &cls.packet_entities[(oldframe->first_entity+oldindex) % cls.num_client_entities];

	mov	eax, DWORD PTR _oldframe$[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _oldindex$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _oldent$[ebp], ecx

; 880  : 			oldnum = oldent->number;

	mov	eax, DWORD PTR _oldent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _oldnum$[ebp], ecx
$LN29@CL_ParsePa:

; 881  : 		}
; 882  : 	}

	jmp	SHORT $LN6@CL_ParsePa
$LN7@CL_ParsePa:

; 883  : 
; 884  : 	if( newframe->num_entities != count && newframe->num_entities != 0 )

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	ecx, DWORD PTR [eax+24044]
	cmp	ecx, DWORD PTR _count$[ebp]
	je	SHORT $LN30@CL_ParsePa
	mov	eax, DWORD PTR _newframe$[ebp]
	cmp	DWORD PTR [eax+24044], 0
	je	SHORT $LN30@CL_ParsePa

; 885  : 		Con_Reportf( S_WARN "CL_Parse%sPacketEntities: (%i should be %i)\n", delta ? "Delta" : "", newframe->num_entities, count );

	cmp	DWORD PTR _delta$[ebp], 0
	je	SHORT $LN34@CL_ParsePa
	mov	DWORD PTR tv230[ebp], OFFSET ??_C@_05NFMIDMMK@Delta@
	jmp	SHORT $LN35@CL_ParsePa
$LN34@CL_ParsePa:
	mov	DWORD PTR tv230[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN35@CL_ParsePa:
	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newframe$[ebp]
	mov	edx, DWORD PTR [ecx+24044]
	push	edx
	mov	eax, DWORD PTR tv230[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@CEPLGCJC@?$FO3Warning?3?$FO7?5CL_Parse?$CFsPacketEn@
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN30@CL_ParsePa:

; 886  : 
; 887  : 	if( !newframe->valid )

	mov	eax, DWORD PTR _newframe$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN31@CL_ParsePa

; 888  : 		return playerbytes; // frame is not valid but message was parsed

	mov	eax, DWORD PTR _playerbytes$[ebp]
	jmp	SHORT $LN1@CL_ParsePa
$LN31@CL_ParsePa:

; 889  : 
; 890  : 	// now process packet.
; 891  : 	CL_ProcessPacket( newframe );

	mov	eax, DWORD PTR _newframe$[ebp]
	push	eax
	call	_CL_ProcessPacket
	add	esp, 4

; 892  : 
; 893  : 	// add new entities into physic lists
; 894  : 	CL_SetSolidEntities();

	call	_CL_SetSolidEntities

; 895  : 
; 896  : 	// first update is the final signon stage where we actually receive an entity (i.e., the world at least)
; 897  : 	if( cls.signon == ( SIGNONS - 1 ))

	cmp	DWORD PTR _cls+64, 1
	jne	SHORT $LN32@CL_ParsePa

; 898  : 	{	
; 899  : 		// we are done with signon sequence.
; 900  : 		cls.signon = SIGNONS;

	mov	DWORD PTR _cls+64, 2

; 901  : 		
; 902  : 		// Clear loading plaque.
; 903  : 		CL_SignonReply ();

	call	_CL_SignonReply
$LN32@CL_ParsePa:

; 904  : 	}
; 905  : 
; 906  : 	return playerbytes;

	mov	eax, DWORD PTR _playerbytes$[ebp]
$LN1@CL_ParsePa:

; 907  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParsePacketEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\client.h
;	COMDAT _CL_EDICT_NUM
_TEXT	SEGMENT
_n$ = 8							; size = 4
_CL_EDICT_NUM PROC					; COMDAT

; 875  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 876  : 	if(( n >= 0 ) && ( n < clgame.maxEntities ))

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN2@CL_EDICT_N
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _clgame+1008
	jge	SHORT $LN2@CL_EDICT_N

; 877  : 		return clgame.entities + n;

	imul	eax, DWORD PTR _n$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	jmp	SHORT $LN1@CL_EDICT_N
$LN2@CL_EDICT_N:

; 878  : 
; 879  : 	Host_Error( "CL_EDICT_NUM: bad number %i\n", n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@EDBDOOKA@CL_EDICT_NUM?3?5bad?5number?5?$CFi?6@
	call	_Host_Error
	add	esp, 8

; 880  : 	return NULL;	

	xor	eax, eax
$LN1@CL_EDICT_N:

; 881  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EDICT_NUM ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_frame.c
;	COMDAT _CL_ExtraUpdate
_TEXT	SEGMENT
_CL_ExtraUpdate PROC					; COMDAT

; 1398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1399 : 	clgame.dllFuncs.IN_Accumulate();

	call	DWORD PTR _clgame+56

; 1400 : 	S_ExtraUpdate();

	call	_S_ExtraUpdate

; 1401 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ExtraUpdate ENDP
_TEXT	ENDS
END
