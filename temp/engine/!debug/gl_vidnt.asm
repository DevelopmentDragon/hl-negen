; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_vidnt.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vidmode
PUBLIC	??_C@_09OMPCNDEM@640?5x?5480@			; `string'
PUBLIC	??_C@_09LMNCLMA@800?5x?5600@			; `string'
PUBLIC	??_C@_09CMCNIKHP@960?5x?5720@			; `string'
PUBLIC	??_C@_0L@KHKHJBNB@1024?5x?5768@			; `string'
PUBLIC	??_C@_0L@BOLNMBPL@1152?5x?5864@			; `string'
PUBLIC	??_C@_0L@CGABCDGE@1280?5x?5800@			; `string'
PUBLIC	??_C@_0L@JKDADILD@1280?5x?5960@			; `string'
PUBLIC	??_C@_0M@PPEHOBIK@1280?5x?51024@		; `string'
PUBLIC	??_C@_0M@JBKIALBN@1600?5x?51200@		; `string'
PUBLIC	??_C@_0M@HFHLDAKK@2048?5x?51536@		; `string'
PUBLIC	??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@	; `string'
PUBLIC	??_C@_0N@OGLMDNKC@glClearColor@			; `string'
PUBLIC	??_C@_07IBAPPAHJ@glClear@			; `string'
PUBLIC	??_C@_0M@BJGLMKCC@glAlphaFunc@			; `string'
PUBLIC	??_C@_0M@PFBKOKOH@glBlendFunc@			; `string'
PUBLIC	??_C@_0L@BAPBLHME@glCullFace@			; `string'
PUBLIC	??_C@_0N@EKCLGPL@glDrawBuffer@			; `string'
PUBLIC	??_C@_0N@HFKHBECK@glReadBuffer@			; `string'
PUBLIC	??_C@_07LNIJJMEN@glAccum@			; `string'
PUBLIC	??_C@_08OOEHEKOP@glEnable@			; `string'
PUBLIC	??_C@_09MHGMIMKN@glDisable@			; `string'
PUBLIC	??_C@_0BE@KECPKGNE@glEnableClientState@		; `string'
PUBLIC	??_C@_0BF@LJDHBNBP@glDisableClientState@	; `string'
PUBLIC	??_C@_0O@NLMELLCJ@glGetBooleanv@		; `string'
PUBLIC	??_C@_0N@OFBMMCDH@glGetDoublev@			; `string'
PUBLIC	??_C@_0M@CKCOBONE@glGetFloatv@			; `string'
PUBLIC	??_C@_0O@DHHDCCLF@glGetIntegerv@		; `string'
PUBLIC	??_C@_0L@FPKAMKHB@glGetError@			; `string'
PUBLIC	??_C@_0M@OPOBFDCB@glGetString@			; `string'
PUBLIC	??_C@_08DFCPOKBK@glFinish@			; `string'
PUBLIC	??_C@_07COFELLJA@glFlush@			; `string'
PUBLIC	??_C@_0N@LJIELNG@glClearDepth@			; `string'
PUBLIC	??_C@_0M@NEJABAEP@glDepthFunc@			; `string'
PUBLIC	??_C@_0M@KABMFLLN@glDepthMask@			; `string'
PUBLIC	??_C@_0N@PEBDIKOA@glDepthRange@			; `string'
PUBLIC	??_C@_0M@ILBMDJDA@glFrontFace@			; `string'
PUBLIC	??_C@_0P@MENFIFGE@glDrawElements@		; `string'
PUBLIC	??_C@_0N@CMNPPOHA@glDrawArrays@			; `string'
PUBLIC	??_C@_0M@DLGOAHPH@glColorMask@			; `string'
PUBLIC	??_C@_0P@KGJBLKPD@glIndexPointer@		; `string'
PUBLIC	??_C@_0BA@HAHECJNK@glVertexPointer@		; `string'
PUBLIC	??_C@_0BA@DCLMCEOP@glNormalPointer@		; `string'
PUBLIC	??_C@_0P@DPKEGLKI@glColorPointer@		; `string'
PUBLIC	??_C@_0BC@DAOMILMO@glTexCoordPointer@		; `string'
PUBLIC	??_C@_0P@CKCIJELG@glArrayElement@		; `string'
PUBLIC	??_C@_09PPBNNDHA@glColor3f@			; `string'
PUBLIC	??_C@_0L@CJJPLCJP@glColor3fv@			; `string'
PUBLIC	??_C@_09PKFCMFPF@glColor4f@			; `string'
PUBLIC	??_C@_0L@LEEIIKCG@glColor4fv@			; `string'
PUBLIC	??_C@_0L@BJFBHIOD@glColor3ub@			; `string'
PUBLIC	??_C@_0L@IEIGEAFK@glColor4ub@			; `string'
PUBLIC	??_C@_0M@PCFPOANK@glColor4ubv@			; `string'
PUBLIC	??_C@_0N@BIJHJAFN@glTexCoord1f@			; `string'
PUBLIC	??_C@_0N@BKNBCOAE@glTexCoord2f@			; `string'
PUBLIC	??_C@_0N@BLBDEEDD@glTexCoord3f@			; `string'
PUBLIC	??_C@_0N@BOFMFCLG@glTexCoord4f@			; `string'
PUBLIC	??_C@_0O@GMKHGEKJ@glTexCoord1fv@		; `string'
PUBLIC	??_C@_0O@HOBCMLEH@glTexCoord2fv@		; `string'
PUBLIC	??_C@_0O@MGKOKMCC@glTexCoord3fv@		; `string'
PUBLIC	??_C@_0O@FLHJJEJL@glTexCoord4fv@		; `string'
PUBLIC	??_C@_09ONEPECIB@glTexGenf@			; `string'
PUBLIC	??_C@_0L@ODDHCCIE@glTexGenfv@			; `string'
PUBLIC	??_C@_09GKNHFOEO@glTexGeni@			; `string'
PUBLIC	??_C@_0L@LPFKLMDB@glVertex2f@			; `string'
PUBLIC	??_C@_0L@LOJINGAG@glVertex3f@			; `string'
PUBLIC	??_C@_0M@JALIODJD@glVertex3fv@			; `string'
PUBLIC	??_C@_0L@DGGCBPPM@glNormal3f@			; `string'
PUBLIC	??_C@_0M@MNFIACFI@glNormal3fv@			; `string'
PUBLIC	??_C@_07FCOIFMD@glBegin@			; `string'
PUBLIC	??_C@_05OIBMBLHE@glEnd@				; `string'
PUBLIC	??_C@_0M@CFLGNFPG@glLineWidth@			; `string'
PUBLIC	??_C@_0M@EEAPMMNM@glPointSize@			; `string'
PUBLIC	??_C@_0N@KDLNHKEJ@glMatrixMode@			; `string'
PUBLIC	??_C@_07DBAFHOII@glOrtho@			; `string'
PUBLIC	??_C@_0O@DLOEJEEG@glRasterPos2f@		; `string'
PUBLIC	??_C@_09ICLFHOKP@glFrustum@			; `string'
PUBLIC	??_C@_0L@KBLIPDFH@glViewport@			; `string'
PUBLIC	??_C@_0N@IHFNHGBL@glPushMatrix@			; `string'
PUBLIC	??_C@_0M@JPEAAEEK@glPopMatrix@			; `string'
PUBLIC	??_C@_0N@KDMLHFJM@glPushAttrib@			; `string'
PUBLIC	??_C@_0M@LLNGAHMN@glPopAttrib@			; `string'
PUBLIC	??_C@_0P@EJAFHEPO@glLoadIdentity@		; `string'
PUBLIC	??_C@_0O@LFHKEMK@glLoadMatrixd@			; `string'
PUBLIC	??_C@_0O@DJGBMGEI@glLoadMatrixf@		; `string'
PUBLIC	??_C@_0O@IFJFLNCL@glMultMatrixd@		; `string'
PUBLIC	??_C@_0O@LHKDNPKJ@glMultMatrixf@		; `string'
PUBLIC	??_C@_09GANFLDAO@glRotated@			; `string'
PUBLIC	??_C@_09FCODNBIM@glRotatef@			; `string'
PUBLIC	??_C@_08KAMCINDI@glScaled@			; `string'
PUBLIC	??_C@_08JCPEOPLK@glScalef@			; `string'
PUBLIC	??_C@_0N@LHMFFDFG@glTranslated@			; `string'
PUBLIC	??_C@_0N@IFPDDBNE@glTranslatef@			; `string'
PUBLIC	??_C@_0N@CKFNNHOO@glReadPixels@			; `string'
PUBLIC	??_C@_0N@FLFIHFDP@glDrawPixels@			; `string'
PUBLIC	??_C@_0O@ENNLLOLN@glStencilFunc@		; `string'
PUBLIC	??_C@_0O@DJFHPFEP@glStencilMask@		; `string'
PUBLIC	??_C@_0M@BILBNGF@glStencilOp@			; `string'
PUBLIC	??_C@_0P@KBLPBBFP@glClearStencil@		; `string'
PUBLIC	??_C@_0M@INHMIHKC@glIsEnabled@			; `string'
PUBLIC	??_C@_08DMFMJKDH@glIsList@			; `string'
PUBLIC	??_C@_0M@NJHAEPDN@glIsTexture@			; `string'
PUBLIC	??_C@_09FCLLGECI@glTexEnvf@			; `string'
PUBLIC	??_C@_0L@EMICMNOO@glTexEnvfv@			; `string'
PUBLIC	??_C@_09NFCDHIOH@glTexEnvi@			; `string'
PUBLIC	??_C@_0BA@INKFIMGP@glTexParameterf@		; `string'
PUBLIC	??_C@_0BB@KEOFAHDF@glTexParameterfv@		; `string'
PUBLIC	??_C@_0BA@KDNJAKA@glTexParameteri@		; `string'
PUBLIC	??_C@_06HEADGMBC@glHint@			; `string'
PUBLIC	??_C@_0O@BFLAHHCK@glPixelStoref@		; `string'
PUBLIC	??_C@_0O@JCCIGLOF@glPixelStorei@		; `string'
PUBLIC	??_C@_0O@LLMANLNK@glGenTextures@		; `string'
PUBLIC	??_C@_0BB@KMPLFJIC@glDeleteTextures@		; `string'
PUBLIC	??_C@_0O@JKKCIBGC@glBindTexture@		; `string'
PUBLIC	??_C@_0N@JDMMMFHL@glTexImage1D@			; `string'
PUBLIC	??_C@_0N@JBIKHLCC@glTexImage2D@			; `string'
PUBLIC	??_C@_0BA@NFOOCKJD@glTexSubImage1D@		; `string'
PUBLIC	??_C@_0BA@NHKIJEMK@glTexSubImage2D@		; `string'
PUBLIC	??_C@_0BB@MEEDBHPL@glCopyTexImage1D@		; `string'
PUBLIC	??_C@_0BB@MGAFKJKC@glCopyTexImage2D@		; `string'
PUBLIC	??_C@_0BE@PKNCAIGI@glCopyTexSubImage1D@		; `string'
PUBLIC	??_C@_0BE@PIJELGDB@glCopyTexSubImage2D@		; `string'
PUBLIC	??_C@_09ECGPAEPL@glScissor@			; `string'
PUBLIC	??_C@_0O@DOIIJLAD@glGetTexImage@		; `string'
PUBLIC	??_C@_0O@KIFFCCBG@glGetTexEnviv@		; `string'
PUBLIC	??_C@_0BA@FFBJGNC@glPolygonOffset@		; `string'
PUBLIC	??_C@_0O@DKMNBFMB@glPolygonMode@		; `string'
PUBLIC	??_C@_0BB@GIADEJGP@glPolygonStipple@		; `string'
PUBLIC	??_C@_0M@OHCNGGFF@glClipPlane@			; `string'
PUBLIC	??_C@_0P@MMMNLMC@glGetClipPlane@		; `string'
PUBLIC	??_C@_0N@NALMFHKN@glShadeModel@			; `string'
PUBLIC	??_C@_0BJ@GLJHCPGI@glGetTexLevelParameteriv@	; `string'
PUBLIC	??_C@_0BJ@GAMLGIFF@glGetTexLevelParameterfv@	; `string'
PUBLIC	??_C@_07FNEIAABA@glFogfv@			; `string'
PUBLIC	??_C@_06JJHNMGPD@glFogf@			; `string'
PUBLIC	??_C@_06BOOFNKDM@glFogi@			; `string'
PUBLIC	??_C@_0BJ@IAEPICEJ@glDebugMessageControlARB@	; `string'
PUBLIC	??_C@_0BI@IFLDELCL@glDebugMessageInsertARB@	; `string'
PUBLIC	??_C@_0BK@IEHNBEGE@glDebugMessageCallbackARB@	; `string'
PUBLIC	??_C@_0BI@JOLPFNOB@glGetDebugMessageLogARB@	; `string'
PUBLIC	??_C@_0BF@ODPGPGFO@glMultiTexCoord1fARB@	; `string'
PUBLIC	??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB@	; `string'
PUBLIC	??_C@_0BF@KODOFHFF@glMultiTexCoord3fARB@	; `string'
PUBLIC	??_C@_0BF@LDDLGHON@glMultiTexCoord4fARB@	; `string'
PUBLIC	??_C@_0BD@IKCKKKNH@glActiveTextureARB@		; `string'
PUBLIC	??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB@	; `string'
PUBLIC	??_C@_0BA@CBIBMEOO@glTexImage3DEXT@		; `string'
PUBLIC	??_C@_0BD@IKPGOLHH@glTexSubImage3DEXT@		; `string'
PUBLIC	??_C@_0BH@LLLKENMO@glCopyTexSubImage3DEXT@	; `string'
PUBLIC	??_C@_0BK@CIBKLOLF@glCompressedTexImage3DARB@	; `string'
PUBLIC	??_C@_0BK@ODEGGNBA@glCompressedTexImage2DARB@	; `string'
PUBLIC	??_C@_0BK@GFNCBPLO@glCompressedTexImage1DARB@	; `string'
PUBLIC	??_C@_0BN@HMALDDJO@glCompressedTexSubImage3DARB@ ; `string'
PUBLIC	??_C@_0BN@LHFHOADL@glCompressedTexSubImage2DARB@ ; `string'
PUBLIC	??_C@_0BN@DBMDJCJF@glCompressedTexSubImage1DARB@ ; `string'
PUBLIC	??_C@_0BL@CKKCLKDF@glGetCompressedTexImageARB@	; `string'
PUBLIC	??_C@_0P@NIPKMJHJ@wglSwapBuffers@		; `string'
PUBLIC	??_C@_0BB@GHMBNOIP@wglCreateContext@		; `string'
PUBLIC	??_C@_0BB@OGAIJNNO@wglDeleteContext@		; `string'
PUBLIC	??_C@_0P@BBBFNDGG@wglMakeCurrent@		; `string'
PUBLIC	??_C@_0BF@HABDPBMA@wglGetCurrentContext@	; `string'
PUBLIC	??_C@_0BC@FFKMKEGM@wglGetProcAddress@		; `string'
PUBLIC	??_C@_0BD@IINOPBDD@wglSwapIntervalEXT@		; `string'
PUBLIC	??_C@_0BK@HGDBIG@wglGetExtensionsStringEXT@	; `string'
PUBLIC	_opengl_dll
PUBLIC	??_C@_0N@DOKAJOHF@opengl32?4dll@		; `string'
_DATA	SEGMENT
COMM	_gl_vsync:DWORD
COMM	_vid_displayfrequency:DWORD
COMM	_gl_showtextures:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_r_temppool:DWORD
COMM	_tr:BYTE:015638H
COMM	_glConfig:BYTE:084H
COMM	_glState:BYTE:0240H
COMM	_glw_state:BYTE:01cH
COMM	_gl_texture_anisotropy:DWORD
COMM	_gl_extensions:DWORD
COMM	_gl_check_errors:DWORD
COMM	_gl_texture_lodbias:DWORD
COMM	_gl_texture_nearest:DWORD
COMM	_gl_lightmap_nearest:DWORD
COMM	_gl_keeptjunctions:DWORD
COMM	_gl_emboss_scale:DWORD
COMM	_gl_round_down:DWORD
COMM	_gl_detailscale:DWORD
COMM	_gl_wireframe:DWORD
COMM	_gl_allow_mirrors:DWORD
COMM	_gl_polyoffset:DWORD
COMM	_gl_finish:DWORD
COMM	_gl_nosort:DWORD
COMM	_gl_clear:DWORD
COMM	_gl_test:DWORD
COMM	_gl_msaa:DWORD
COMM	_r_speeds:DWORD
COMM	_r_fullbright:DWORD
COMM	_r_norefresh:DWORD
COMM	_r_showtree:DWORD
COMM	_r_lighting_extended:DWORD
COMM	_r_lighting_modulate:DWORD
COMM	_r_lighting_ambient:DWORD
COMM	_r_detailtextures:DWORD
COMM	_r_drawentities:DWORD
COMM	_r_adjust_fov:DWORD
COMM	_r_decals:DWORD
COMM	_r_novis:DWORD
COMM	_r_nocull:DWORD
COMM	_r_lockpvs:DWORD
COMM	_r_lockfrustum:DWORD
COMM	_r_traceglow:DWORD
COMM	_r_dynamic:DWORD
COMM	_r_lightmap:DWORD
COMM	_vid_fullscreen:DWORD
COMM	_vid_brightness:DWORD
COMM	_vid_gamma:DWORD
COMM	_vid_mode:DWORD
COMM	_r_downsample:DWORD
COMM	_gl_wgl_msaa_samples:DWORD
COMM	_window_xpos:DWORD
COMM	_window_ypos:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0N@DOKAJOHF@opengl32?4dll@
CONST	SEGMENT
??_C@_0N@DOKAJOHF@opengl32?4dll@ DB 'opengl32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HGDBIG@wglGetExtensionsStringEXT@
CONST	SEGMENT
??_C@_0BK@HGDBIG@wglGetExtensionsStringEXT@ DB 'wglGetExtensionsStringEXT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IINOPBDD@wglSwapIntervalEXT@
CONST	SEGMENT
??_C@_0BD@IINOPBDD@wglSwapIntervalEXT@ DB 'wglSwapIntervalEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FFKMKEGM@wglGetProcAddress@
CONST	SEGMENT
??_C@_0BC@FFKMKEGM@wglGetProcAddress@ DB 'wglGetProcAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HABDPBMA@wglGetCurrentContext@
CONST	SEGMENT
??_C@_0BF@HABDPBMA@wglGetCurrentContext@ DB 'wglGetCurrentContext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BBBFNDGG@wglMakeCurrent@
CONST	SEGMENT
??_C@_0P@BBBFNDGG@wglMakeCurrent@ DB 'wglMakeCurrent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGAIJNNO@wglDeleteContext@
CONST	SEGMENT
??_C@_0BB@OGAIJNNO@wglDeleteContext@ DB 'wglDeleteContext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHMBNOIP@wglCreateContext@
CONST	SEGMENT
??_C@_0BB@GHMBNOIP@wglCreateContext@ DB 'wglCreateContext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NIPKMJHJ@wglSwapBuffers@
CONST	SEGMENT
??_C@_0P@NIPKMJHJ@wglSwapBuffers@ DB 'wglSwapBuffers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CKKCLKDF@glGetCompressedTexImageARB@
CONST	SEGMENT
??_C@_0BL@CKKCLKDF@glGetCompressedTexImageARB@ DB 'glGetCompressedTexImag'
	DB	'eARB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBMDJCJF@glCompressedTexSubImage1DARB@
CONST	SEGMENT
??_C@_0BN@DBMDJCJF@glCompressedTexSubImage1DARB@ DB 'glCompressedTexSubIm'
	DB	'age1DARB', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHFHOADL@glCompressedTexSubImage2DARB@
CONST	SEGMENT
??_C@_0BN@LHFHOADL@glCompressedTexSubImage2DARB@ DB 'glCompressedTexSubIm'
	DB	'age2DARB', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HMALDDJO@glCompressedTexSubImage3DARB@
CONST	SEGMENT
??_C@_0BN@HMALDDJO@glCompressedTexSubImage3DARB@ DB 'glCompressedTexSubIm'
	DB	'age3DARB', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GFNCBPLO@glCompressedTexImage1DARB@
CONST	SEGMENT
??_C@_0BK@GFNCBPLO@glCompressedTexImage1DARB@ DB 'glCompressedTexImage1DA'
	DB	'RB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ODEGGNBA@glCompressedTexImage2DARB@
CONST	SEGMENT
??_C@_0BK@ODEGGNBA@glCompressedTexImage2DARB@ DB 'glCompressedTexImage2DA'
	DB	'RB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CIBKLOLF@glCompressedTexImage3DARB@
CONST	SEGMENT
??_C@_0BK@CIBKLOLF@glCompressedTexImage3DARB@ DB 'glCompressedTexImage3DA'
	DB	'RB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LLLKENMO@glCopyTexSubImage3DEXT@
CONST	SEGMENT
??_C@_0BH@LLLKENMO@glCopyTexSubImage3DEXT@ DB 'glCopyTexSubImage3DEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKPGOLHH@glTexSubImage3DEXT@
CONST	SEGMENT
??_C@_0BD@IKPGOLHH@glTexSubImage3DEXT@ DB 'glTexSubImage3DEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CBIBMEOO@glTexImage3DEXT@
CONST	SEGMENT
??_C@_0BA@CBIBMEOO@glTexImage3DEXT@ DB 'glTexImage3DEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB@
CONST	SEGMENT
??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB@ DB 'glClientActiveTextureARB'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IKCKKKNH@glActiveTextureARB@
CONST	SEGMENT
??_C@_0BD@IKCKKKNH@glActiveTextureARB@ DB 'glActiveTextureARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LDDLGHON@glMultiTexCoord4fARB@
CONST	SEGMENT
??_C@_0BF@LDDLGHON@glMultiTexCoord4fARB@ DB 'glMultiTexCoord4fARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KODOFHFF@glMultiTexCoord3fARB@
CONST	SEGMENT
??_C@_0BF@KODOFHFF@glMultiTexCoord3fARB@ DB 'glMultiTexCoord3fARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB@
CONST	SEGMENT
??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB@ DB 'glMultiTexCoord2fARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ODPGPGFO@glMultiTexCoord1fARB@
CONST	SEGMENT
??_C@_0BF@ODPGPGFO@glMultiTexCoord1fARB@ DB 'glMultiTexCoord1fARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JOLPFNOB@glGetDebugMessageLogARB@
CONST	SEGMENT
??_C@_0BI@JOLPFNOB@glGetDebugMessageLogARB@ DB 'glGetDebugMessageLogARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IEHNBEGE@glDebugMessageCallbackARB@
CONST	SEGMENT
??_C@_0BK@IEHNBEGE@glDebugMessageCallbackARB@ DB 'glDebugMessageCallbackA'
	DB	'RB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IFLDELCL@glDebugMessageInsertARB@
CONST	SEGMENT
??_C@_0BI@IFLDELCL@glDebugMessageInsertARB@ DB 'glDebugMessageInsertARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IAEPICEJ@glDebugMessageControlARB@
CONST	SEGMENT
??_C@_0BJ@IAEPICEJ@glDebugMessageControlARB@ DB 'glDebugMessageControlARB'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06BOOFNKDM@glFogi@
CONST	SEGMENT
??_C@_06BOOFNKDM@glFogi@ DB 'glFogi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJHNMGPD@glFogf@
CONST	SEGMENT
??_C@_06JJHNMGPD@glFogf@ DB 'glFogf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FNEIAABA@glFogfv@
CONST	SEGMENT
??_C@_07FNEIAABA@glFogfv@ DB 'glFogfv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GAMLGIFF@glGetTexLevelParameterfv@
CONST	SEGMENT
??_C@_0BJ@GAMLGIFF@glGetTexLevelParameterfv@ DB 'glGetTexLevelParameterfv'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GLJHCPGI@glGetTexLevelParameteriv@
CONST	SEGMENT
??_C@_0BJ@GLJHCPGI@glGetTexLevelParameteriv@ DB 'glGetTexLevelParameteriv'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NALMFHKN@glShadeModel@
CONST	SEGMENT
??_C@_0N@NALMFHKN@glShadeModel@ DB 'glShadeModel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MMMNLMC@glGetClipPlane@
CONST	SEGMENT
??_C@_0P@MMMNLMC@glGetClipPlane@ DB 'glGetClipPlane', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHCNGGFF@glClipPlane@
CONST	SEGMENT
??_C@_0M@OHCNGGFF@glClipPlane@ DB 'glClipPlane', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GIADEJGP@glPolygonStipple@
CONST	SEGMENT
??_C@_0BB@GIADEJGP@glPolygonStipple@ DB 'glPolygonStipple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKMNBFMB@glPolygonMode@
CONST	SEGMENT
??_C@_0O@DKMNBFMB@glPolygonMode@ DB 'glPolygonMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FFBJGNC@glPolygonOffset@
CONST	SEGMENT
??_C@_0BA@FFBJGNC@glPolygonOffset@ DB 'glPolygonOffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KIFFCCBG@glGetTexEnviv@
CONST	SEGMENT
??_C@_0O@KIFFCCBG@glGetTexEnviv@ DB 'glGetTexEnviv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DOIIJLAD@glGetTexImage@
CONST	SEGMENT
??_C@_0O@DOIIJLAD@glGetTexImage@ DB 'glGetTexImage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ECGPAEPL@glScissor@
CONST	SEGMENT
??_C@_09ECGPAEPL@glScissor@ DB 'glScissor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PIJELGDB@glCopyTexSubImage2D@
CONST	SEGMENT
??_C@_0BE@PIJELGDB@glCopyTexSubImage2D@ DB 'glCopyTexSubImage2D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PKNCAIGI@glCopyTexSubImage1D@
CONST	SEGMENT
??_C@_0BE@PKNCAIGI@glCopyTexSubImage1D@ DB 'glCopyTexSubImage1D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGAFKJKC@glCopyTexImage2D@
CONST	SEGMENT
??_C@_0BB@MGAFKJKC@glCopyTexImage2D@ DB 'glCopyTexImage2D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MEEDBHPL@glCopyTexImage1D@
CONST	SEGMENT
??_C@_0BB@MEEDBHPL@glCopyTexImage1D@ DB 'glCopyTexImage1D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHKIJEMK@glTexSubImage2D@
CONST	SEGMENT
??_C@_0BA@NHKIJEMK@glTexSubImage2D@ DB 'glTexSubImage2D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NFOOCKJD@glTexSubImage1D@
CONST	SEGMENT
??_C@_0BA@NFOOCKJD@glTexSubImage1D@ DB 'glTexSubImage1D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBIKHLCC@glTexImage2D@
CONST	SEGMENT
??_C@_0N@JBIKHLCC@glTexImage2D@ DB 'glTexImage2D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDMMMFHL@glTexImage1D@
CONST	SEGMENT
??_C@_0N@JDMMMFHL@glTexImage1D@ DB 'glTexImage1D', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JKKCIBGC@glBindTexture@
CONST	SEGMENT
??_C@_0O@JKKCIBGC@glBindTexture@ DB 'glBindTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KMPLFJIC@glDeleteTextures@
CONST	SEGMENT
??_C@_0BB@KMPLFJIC@glDeleteTextures@ DB 'glDeleteTextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLMANLNK@glGenTextures@
CONST	SEGMENT
??_C@_0O@LLMANLNK@glGenTextures@ DB 'glGenTextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JCCIGLOF@glPixelStorei@
CONST	SEGMENT
??_C@_0O@JCCIGLOF@glPixelStorei@ DB 'glPixelStorei', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFLAHHCK@glPixelStoref@
CONST	SEGMENT
??_C@_0O@BFLAHHCK@glPixelStoref@ DB 'glPixelStoref', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEADGMBC@glHint@
CONST	SEGMENT
??_C@_06HEADGMBC@glHint@ DB 'glHint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDNJAKA@glTexParameteri@
CONST	SEGMENT
??_C@_0BA@KDNJAKA@glTexParameteri@ DB 'glTexParameteri', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEOFAHDF@glTexParameterfv@
CONST	SEGMENT
??_C@_0BB@KEOFAHDF@glTexParameterfv@ DB 'glTexParameterfv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@INKFIMGP@glTexParameterf@
CONST	SEGMENT
??_C@_0BA@INKFIMGP@glTexParameterf@ DB 'glTexParameterf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFCDHIOH@glTexEnvi@
CONST	SEGMENT
??_C@_09NFCDHIOH@glTexEnvi@ DB 'glTexEnvi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMICMNOO@glTexEnvfv@
CONST	SEGMENT
??_C@_0L@EMICMNOO@glTexEnvfv@ DB 'glTexEnvfv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCLLGECI@glTexEnvf@
CONST	SEGMENT
??_C@_09FCLLGECI@glTexEnvf@ DB 'glTexEnvf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJHAEPDN@glIsTexture@
CONST	SEGMENT
??_C@_0M@NJHAEPDN@glIsTexture@ DB 'glIsTexture', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMFMJKDH@glIsList@
CONST	SEGMENT
??_C@_08DMFMJKDH@glIsList@ DB 'glIsList', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@INHMIHKC@glIsEnabled@
CONST	SEGMENT
??_C@_0M@INHMIHKC@glIsEnabled@ DB 'glIsEnabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBLPBBFP@glClearStencil@
CONST	SEGMENT
??_C@_0P@KBLPBBFP@glClearStencil@ DB 'glClearStencil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BILBNGF@glStencilOp@
CONST	SEGMENT
??_C@_0M@BILBNGF@glStencilOp@ DB 'glStencilOp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJFHPFEP@glStencilMask@
CONST	SEGMENT
??_C@_0O@DJFHPFEP@glStencilMask@ DB 'glStencilMask', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ENNLLOLN@glStencilFunc@
CONST	SEGMENT
??_C@_0O@ENNLLOLN@glStencilFunc@ DB 'glStencilFunc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FLFIHFDP@glDrawPixels@
CONST	SEGMENT
??_C@_0N@FLFIHFDP@glDrawPixels@ DB 'glDrawPixels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKFNNHOO@glReadPixels@
CONST	SEGMENT
??_C@_0N@CKFNNHOO@glReadPixels@ DB 'glReadPixels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFPDDBNE@glTranslatef@
CONST	SEGMENT
??_C@_0N@IFPDDBNE@glTranslatef@ DB 'glTranslatef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHMFFDFG@glTranslated@
CONST	SEGMENT
??_C@_0N@LHMFFDFG@glTranslated@ DB 'glTranslated', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCPEOPLK@glScalef@
CONST	SEGMENT
??_C@_08JCPEOPLK@glScalef@ DB 'glScalef', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KAMCINDI@glScaled@
CONST	SEGMENT
??_C@_08KAMCINDI@glScaled@ DB 'glScaled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCODNBIM@glRotatef@
CONST	SEGMENT
??_C@_09FCODNBIM@glRotatef@ DB 'glRotatef', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GANFLDAO@glRotated@
CONST	SEGMENT
??_C@_09GANFLDAO@glRotated@ DB 'glRotated', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LHKDNPKJ@glMultMatrixf@
CONST	SEGMENT
??_C@_0O@LHKDNPKJ@glMultMatrixf@ DB 'glMultMatrixf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFJFLNCL@glMultMatrixd@
CONST	SEGMENT
??_C@_0O@IFJFLNCL@glMultMatrixd@ DB 'glMultMatrixd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJGBMGEI@glLoadMatrixf@
CONST	SEGMENT
??_C@_0O@DJGBMGEI@glLoadMatrixf@ DB 'glLoadMatrixf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LFHKEMK@glLoadMatrixd@
CONST	SEGMENT
??_C@_0O@LFHKEMK@glLoadMatrixd@ DB 'glLoadMatrixd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJAFHEPO@glLoadIdentity@
CONST	SEGMENT
??_C@_0P@EJAFHEPO@glLoadIdentity@ DB 'glLoadIdentity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLNGAHMN@glPopAttrib@
CONST	SEGMENT
??_C@_0M@LLNGAHMN@glPopAttrib@ DB 'glPopAttrib', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDMLHFJM@glPushAttrib@
CONST	SEGMENT
??_C@_0N@KDMLHFJM@glPushAttrib@ DB 'glPushAttrib', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JPEAAEEK@glPopMatrix@
CONST	SEGMENT
??_C@_0M@JPEAAEEK@glPopMatrix@ DB 'glPopMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IHFNHGBL@glPushMatrix@
CONST	SEGMENT
??_C@_0N@IHFNHGBL@glPushMatrix@ DB 'glPushMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBLIPDFH@glViewport@
CONST	SEGMENT
??_C@_0L@KBLIPDFH@glViewport@ DB 'glViewport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICLFHOKP@glFrustum@
CONST	SEGMENT
??_C@_09ICLFHOKP@glFrustum@ DB 'glFrustum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DLOEJEEG@glRasterPos2f@
CONST	SEGMENT
??_C@_0O@DLOEJEEG@glRasterPos2f@ DB 'glRasterPos2f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBAFHOII@glOrtho@
CONST	SEGMENT
??_C@_07DBAFHOII@glOrtho@ DB 'glOrtho', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDLNHKEJ@glMatrixMode@
CONST	SEGMENT
??_C@_0N@KDLNHKEJ@glMatrixMode@ DB 'glMatrixMode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEAPMMNM@glPointSize@
CONST	SEGMENT
??_C@_0M@EEAPMMNM@glPointSize@ DB 'glPointSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFLGNFPG@glLineWidth@
CONST	SEGMENT
??_C@_0M@CFLGNFPG@glLineWidth@ DB 'glLineWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OIBMBLHE@glEnd@
CONST	SEGMENT
??_C@_05OIBMBLHE@glEnd@ DB 'glEnd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCOIFMD@glBegin@
CONST	SEGMENT
??_C@_07FCOIFMD@glBegin@ DB 'glBegin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNFIACFI@glNormal3fv@
CONST	SEGMENT
??_C@_0M@MNFIACFI@glNormal3fv@ DB 'glNormal3fv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DGGCBPPM@glNormal3f@
CONST	SEGMENT
??_C@_0L@DGGCBPPM@glNormal3f@ DB 'glNormal3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JALIODJD@glVertex3fv@
CONST	SEGMENT
??_C@_0M@JALIODJD@glVertex3fv@ DB 'glVertex3fv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOJINGAG@glVertex3f@
CONST	SEGMENT
??_C@_0L@LOJINGAG@glVertex3f@ DB 'glVertex3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPFKLMDB@glVertex2f@
CONST	SEGMENT
??_C@_0L@LPFKLMDB@glVertex2f@ DB 'glVertex2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GKNHFOEO@glTexGeni@
CONST	SEGMENT
??_C@_09GKNHFOEO@glTexGeni@ DB 'glTexGeni', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODDHCCIE@glTexGenfv@
CONST	SEGMENT
??_C@_0L@ODDHCCIE@glTexGenfv@ DB 'glTexGenfv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ONEPECIB@glTexGenf@
CONST	SEGMENT
??_C@_09ONEPECIB@glTexGenf@ DB 'glTexGenf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLHJJEJL@glTexCoord4fv@
CONST	SEGMENT
??_C@_0O@FLHJJEJL@glTexCoord4fv@ DB 'glTexCoord4fv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGKOKMCC@glTexCoord3fv@
CONST	SEGMENT
??_C@_0O@MGKOKMCC@glTexCoord3fv@ DB 'glTexCoord3fv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOBCMLEH@glTexCoord2fv@
CONST	SEGMENT
??_C@_0O@HOBCMLEH@glTexCoord2fv@ DB 'glTexCoord2fv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GMKHGEKJ@glTexCoord1fv@
CONST	SEGMENT
??_C@_0O@GMKHGEKJ@glTexCoord1fv@ DB 'glTexCoord1fv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOFMFCLG@glTexCoord4f@
CONST	SEGMENT
??_C@_0N@BOFMFCLG@glTexCoord4f@ DB 'glTexCoord4f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLBDEEDD@glTexCoord3f@
CONST	SEGMENT
??_C@_0N@BLBDEEDD@glTexCoord3f@ DB 'glTexCoord3f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BKNBCOAE@glTexCoord2f@
CONST	SEGMENT
??_C@_0N@BKNBCOAE@glTexCoord2f@ DB 'glTexCoord2f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIJHJAFN@glTexCoord1f@
CONST	SEGMENT
??_C@_0N@BIJHJAFN@glTexCoord1f@ DB 'glTexCoord1f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCFPOANK@glColor4ubv@
CONST	SEGMENT
??_C@_0M@PCFPOANK@glColor4ubv@ DB 'glColor4ubv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEIGEAFK@glColor4ub@
CONST	SEGMENT
??_C@_0L@IEIGEAFK@glColor4ub@ DB 'glColor4ub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFBHIOD@glColor3ub@
CONST	SEGMENT
??_C@_0L@BJFBHIOD@glColor3ub@ DB 'glColor3ub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LEEIIKCG@glColor4fv@
CONST	SEGMENT
??_C@_0L@LEEIIKCG@glColor4fv@ DB 'glColor4fv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFCMFPF@glColor4f@
CONST	SEGMENT
??_C@_09PKFCMFPF@glColor4f@ DB 'glColor4f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJJPLCJP@glColor3fv@
CONST	SEGMENT
??_C@_0L@CJJPLCJP@glColor3fv@ DB 'glColor3fv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PPBNNDHA@glColor3f@
CONST	SEGMENT
??_C@_09PPBNNDHA@glColor3f@ DB 'glColor3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKCIJELG@glArrayElement@
CONST	SEGMENT
??_C@_0P@CKCIJELG@glArrayElement@ DB 'glArrayElement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DAOMILMO@glTexCoordPointer@
CONST	SEGMENT
??_C@_0BC@DAOMILMO@glTexCoordPointer@ DB 'glTexCoordPointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DPKEGLKI@glColorPointer@
CONST	SEGMENT
??_C@_0P@DPKEGLKI@glColorPointer@ DB 'glColorPointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DCLMCEOP@glNormalPointer@
CONST	SEGMENT
??_C@_0BA@DCLMCEOP@glNormalPointer@ DB 'glNormalPointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAHECJNK@glVertexPointer@
CONST	SEGMENT
??_C@_0BA@HAHECJNK@glVertexPointer@ DB 'glVertexPointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KGJBLKPD@glIndexPointer@
CONST	SEGMENT
??_C@_0P@KGJBLKPD@glIndexPointer@ DB 'glIndexPointer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DLGOAHPH@glColorMask@
CONST	SEGMENT
??_C@_0M@DLGOAHPH@glColorMask@ DB 'glColorMask', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CMNPPOHA@glDrawArrays@
CONST	SEGMENT
??_C@_0N@CMNPPOHA@glDrawArrays@ DB 'glDrawArrays', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MENFIFGE@glDrawElements@
CONST	SEGMENT
??_C@_0P@MENFIFGE@glDrawElements@ DB 'glDrawElements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILBMDJDA@glFrontFace@
CONST	SEGMENT
??_C@_0M@ILBMDJDA@glFrontFace@ DB 'glFrontFace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEBDIKOA@glDepthRange@
CONST	SEGMENT
??_C@_0N@PEBDIKOA@glDepthRange@ DB 'glDepthRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KABMFLLN@glDepthMask@
CONST	SEGMENT
??_C@_0M@KABMFLLN@glDepthMask@ DB 'glDepthMask', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEJABAEP@glDepthFunc@
CONST	SEGMENT
??_C@_0M@NEJABAEP@glDepthFunc@ DB 'glDepthFunc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LJIELNG@glClearDepth@
CONST	SEGMENT
??_C@_0N@LJIELNG@glClearDepth@ DB 'glClearDepth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07COFELLJA@glFlush@
CONST	SEGMENT
??_C@_07COFELLJA@glFlush@ DB 'glFlush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DFCPOKBK@glFinish@
CONST	SEGMENT
??_C@_08DFCPOKBK@glFinish@ DB 'glFinish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPOBFDCB@glGetString@
CONST	SEGMENT
??_C@_0M@OPOBFDCB@glGetString@ DB 'glGetString', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FPKAMKHB@glGetError@
CONST	SEGMENT
??_C@_0L@FPKAMKHB@glGetError@ DB 'glGetError', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DHHDCCLF@glGetIntegerv@
CONST	SEGMENT
??_C@_0O@DHHDCCLF@glGetIntegerv@ DB 'glGetIntegerv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CKCOBONE@glGetFloatv@
CONST	SEGMENT
??_C@_0M@CKCOBONE@glGetFloatv@ DB 'glGetFloatv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OFBMMCDH@glGetDoublev@
CONST	SEGMENT
??_C@_0N@OFBMMCDH@glGetDoublev@ DB 'glGetDoublev', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLMELLCJ@glGetBooleanv@
CONST	SEGMENT
??_C@_0O@NLMELLCJ@glGetBooleanv@ DB 'glGetBooleanv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LJDHBNBP@glDisableClientState@
CONST	SEGMENT
??_C@_0BF@LJDHBNBP@glDisableClientState@ DB 'glDisableClientState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KECPKGNE@glEnableClientState@
CONST	SEGMENT
??_C@_0BE@KECPKGNE@glEnableClientState@ DB 'glEnableClientState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHGMIMKN@glDisable@
CONST	SEGMENT
??_C@_09MHGMIMKN@glDisable@ DB 'glDisable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOEHEKOP@glEnable@
CONST	SEGMENT
??_C@_08OOEHEKOP@glEnable@ DB 'glEnable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LNIJJMEN@glAccum@
CONST	SEGMENT
??_C@_07LNIJJMEN@glAccum@ DB 'glAccum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HFKHBECK@glReadBuffer@
CONST	SEGMENT
??_C@_0N@HFKHBECK@glReadBuffer@ DB 'glReadBuffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKCLGPL@glDrawBuffer@
CONST	SEGMENT
??_C@_0N@EKCLGPL@glDrawBuffer@ DB 'glDrawBuffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BAPBLHME@glCullFace@
CONST	SEGMENT
??_C@_0L@BAPBLHME@glCullFace@ DB 'glCullFace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PFBKOKOH@glBlendFunc@
CONST	SEGMENT
??_C@_0M@PFBKOKOH@glBlendFunc@ DB 'glBlendFunc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BJGLMKCC@glAlphaFunc@
CONST	SEGMENT
??_C@_0M@BJGLMKCC@glAlphaFunc@ DB 'glAlphaFunc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IBAPPAHJ@glClear@
CONST	SEGMENT
??_C@_07IBAPPAHJ@glClear@ DB 'glClear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGLMDNKC@glClearColor@
CONST	SEGMENT
??_C@_0N@OGLMDNKC@glClearColor@ DB 'glClearColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@ DB '3840 x 2160 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@ DB '1600 x 900 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@ DB '2560 x 1600 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@ DB '2560 x 1440 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@ DB '1920 x 1200 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@ DB '1920 x 1080 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@ DB '1680 x 1050 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@ DB '1440 x 900 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@ DB '1366 x 768 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@ DB '1360 x 768 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@ DB '1280 x 720 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@ DB '1024 x 600 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@ DB '1024 x 576 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@ DB '960 x 540 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@ DB '856 x 480 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@
CONST	SEGMENT
??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@ DB '800 x 480 (wide)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HFHLDAKK@2048?5x?51536@
CONST	SEGMENT
??_C@_0M@HFHLDAKK@2048?5x?51536@ DB '2048 x 1536', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBKIALBN@1600?5x?51200@
CONST	SEGMENT
??_C@_0M@JBKIALBN@1600?5x?51200@ DB '1600 x 1200', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PPEHOBIK@1280?5x?51024@
CONST	SEGMENT
??_C@_0M@PPEHOBIK@1280?5x?51024@ DB '1280 x 1024', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKDADILD@1280?5x?5960@
CONST	SEGMENT
??_C@_0L@JKDADILD@1280?5x?5960@ DB '1280 x 960', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CGABCDGE@1280?5x?5800@
CONST	SEGMENT
??_C@_0L@CGABCDGE@1280?5x?5800@ DB '1280 x 800', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOLNMBPL@1152?5x?5864@
CONST	SEGMENT
??_C@_0L@BOLNMBPL@1152?5x?5864@ DB '1152 x 864', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHKHJBNB@1024?5x?5768@
CONST	SEGMENT
??_C@_0L@KHKHJBNB@1024?5x?5768@ DB '1024 x 768', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CMCNIKHP@960?5x?5720@
CONST	SEGMENT
??_C@_09CMCNIKHP@960?5x?5720@ DB '960 x 720', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMNCLMA@800?5x?5600@
CONST	SEGMENT
??_C@_09LMNCLMA@800?5x?5600@ DB '800 x 600', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMPCNDEM@640?5x?5480@
CONST	SEGMENT
??_C@_09OMPCNDEM@640?5x?5480@ DB '640 x 480', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_vidmode DD	FLAT:??_C@_09OMPCNDEM@640?5x?5480@
	DD	0280H
	DD	01e0H
	DD	00H
	DD	FLAT:??_C@_09LMNCLMA@800?5x?5600@
	DD	0320H
	DD	0258H
	DD	00H
	DD	FLAT:??_C@_09CMCNIKHP@960?5x?5720@
	DD	03c0H
	DD	02d0H
	DD	00H
	DD	FLAT:??_C@_0L@KHKHJBNB@1024?5x?5768@
	DD	0400H
	DD	0300H
	DD	00H
	DD	FLAT:??_C@_0L@BOLNMBPL@1152?5x?5864@
	DD	0480H
	DD	0360H
	DD	00H
	DD	FLAT:??_C@_0L@CGABCDGE@1280?5x?5800@
	DD	0500H
	DD	0320H
	DD	00H
	DD	FLAT:??_C@_0L@JKDADILD@1280?5x?5960@
	DD	0500H
	DD	03c0H
	DD	00H
	DD	FLAT:??_C@_0M@PPEHOBIK@1280?5x?51024@
	DD	0500H
	DD	0400H
	DD	00H
	DD	FLAT:??_C@_0M@JBKIALBN@1600?5x?51200@
	DD	0640H
	DD	04b0H
	DD	00H
	DD	FLAT:??_C@_0M@HFHLDAKK@2048?5x?51536@
	DD	0800H
	DD	0600H
	DD	00H
	DD	FLAT:??_C@_0BB@BFHGPDLM@800?5x?5480?5?$CIwide?$CJ@
	DD	0320H
	DD	01e0H
	DD	01H
	DD	FLAT:??_C@_0BB@ENNFPKFI@856?5x?5480?5?$CIwide?$CJ@
	DD	0358H
	DD	01e0H
	DD	01H
	DD	FLAT:??_C@_0BB@BKPDGOFF@960?5x?5540?5?$CIwide?$CJ@
	DD	03c0H
	DD	021cH
	DD	01H
	DD	FLAT:??_C@_0BC@IPGGGNNM@1024?5x?5576?5?$CIwide?$CJ@
	DD	0400H
	DD	0240H
	DD	01H
	DD	FLAT:??_C@_0BC@IHECGJCO@1024?5x?5600?5?$CIwide?$CJ@
	DD	0400H
	DD	0258H
	DD	01H
	DD	FLAT:??_C@_0BC@OIMKCJFL@1280?5x?5720?5?$CIwide?$CJ@
	DD	0500H
	DD	02d0H
	DD	01H
	DD	FLAT:??_C@_0BC@PNNNBGNB@1360?5x?5768?5?$CIwide?$CJ@
	DD	0550H
	DD	0300H
	DD	01H
	DD	FLAT:??_C@_0BC@NPCHMCCD@1366?5x?5768?5?$CIwide?$CJ@
	DD	0556H
	DD	0300H
	DD	01H
	DD	FLAT:??_C@_0BC@LOFPLGKA@1440?5x?5900?5?$CIwide?$CJ@
	DD	05a0H
	DD	0384H
	DD	01H
	DD	FLAT:??_C@_0BD@EIAPKJNM@1680?5x?51050?5?$CIwide?$CJ@
	DD	0690H
	DD	041aH
	DD	01H
	DD	FLAT:??_C@_0BD@HJKCFJFN@1920?5x?51080?5?$CIwide?$CJ@
	DD	0780H
	DD	0438H
	DD	01H
	DD	FLAT:??_C@_0BD@DCBJKAGI@1920?5x?51200?5?$CIwide?$CJ@
	DD	0780H
	DD	04b0H
	DD	01H
	DD	FLAT:??_C@_0BD@BPOABCDN@2560?5x?51440?5?$CIwide?$CJ@
	DD	0a00H
	DD	05a0H
	DD	01H
	DD	FLAT:??_C@_0BD@EOGHALIG@2560?5x?51600?5?$CIwide?$CJ@
	DD	0a00H
	DD	0640H
	DD	01H
	DD	FLAT:??_C@_0BC@LOFCGKOA@1600?5x?5900?5?$CIwide?$CJ@
	DD	0640H
	DD	0384H
	DD	01H
	DD	FLAT:??_C@_0BD@ONKJGDMG@3840?5x?52160?5?$CIwide?$CJ@
	DD	0f00H
	DD	0870H
	DD	01H
_wgl_funcs DD	FLAT:??_C@_0P@NIPKMJHJ@wglSwapBuffers@
	DD	FLAT:_pwglSwapBuffers
	DD	FLAT:??_C@_0BB@GHMBNOIP@wglCreateContext@
	DD	FLAT:_pwglCreateContext
	DD	FLAT:??_C@_0BB@OGAIJNNO@wglDeleteContext@
	DD	FLAT:_pwglDeleteContext
	DD	FLAT:??_C@_0P@BBBFNDGG@wglMakeCurrent@
	DD	FLAT:_pwglMakeCurrent
	DD	FLAT:??_C@_0BF@HABDPBMA@wglGetCurrentContext@
	DD	FLAT:_pwglGetCurrentContext
	DD	00H
	DD	00H
_opengl_dll DD	FLAT:??_C@_0N@DOKAJOHF@opengl32?4dll@
	DD	FLAT:_wgl_funcs
	DD	01H
	ORG $+4
_DATA	ENDS
PUBLIC	_VID_InitDefaultResolution
PUBLIC	_GL_CheckForErrors_
PUBLIC	_VID_GetModeString
PUBLIC	_GL_GetProcAddress
PUBLIC	_GL_ErrorString
PUBLIC	_GL_UpdateSwapInterval
PUBLIC	_GL_DeleteContext
PUBLIC	_GL_Support
PUBLIC	_VID_CheckChanges
PUBLIC	_GL_MaxTextureUnits
PUBLIC	_R_Init
PUBLIC	_R_Shutdown
PUBLIC	_GL_SetExtension
PUBLIC	_GL_CheckExtension
PUBLIC	_GL_CreateContext
PUBLIC	_GL_UpdateContext
PUBLIC	_VID_StartupGamma
PUBLIC	_VID_DestroyFakeWindow
PUBLIC	_VID_CreateFakeWindow
PUBLIC	_GL_SetPixelformat
PUBLIC	_R_SaveVideoMode
PUBLIC	_R_DescribeVIDMode
PUBLIC	_VID_CreateWindow
PUBLIC	_VID_DestroyWindow
PUBLIC	_R_ChangeDisplaySettings
PUBLIC	_VID_SetMode
PUBLIC	_R_Init_OpenGL
PUBLIC	_R_Free_OpenGL
PUBLIC	_R_RenderInfo_f
PUBLIC	_GL_InitCommands
PUBLIC	_GL_RemoveCommands
PUBLIC	_GL_InitExtensions
PUBLIC	??_C@_0BG@HNJCPLKA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@EFLPNAON@?$FO2OpenGL?5Note?3?$FO7?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0DC@DFBHKDFL@?$FO1Error?3?$FO7?5GL_SetExtension?3?5inv@ ; `string'
PUBLIC	??_C@_0CN@IPEPFJPO@?$FO1Error?3?$FO7?5GL_Support?3?5invalid?5@ ; `string'
PUBLIC	??_C@_0BH@HNGPIHKB@GL_CheckExtension?3?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@	; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0M@DMNJGNM@?9?5disabled?6@		; `string'
PUBLIC	??_C@_0M@OLAKKIMP@?9?5?$FO1failed?6@		; `string'
PUBLIC	??_C@_0N@EEFGEEA@?9?5?$FO2enabled?6@		; `string'
PUBLIC	??_C@_08NHGONMLE@?9gldebug@			; `string'
PUBLIC	??_C@_03GJAMENNA@2?40@				; `string'
PUBLIC	??_C@_0DF@KEPFMKAK@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5c@ ; `string'
PUBLIC	??_C@_06CJLEMFPD@compat@			; `string'
PUBLIC	??_C@_0CN@NLIAMNMI@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5p@ ; `string'
PUBLIC	??_C@_0ED@EKEJBCOE@?$FO1Error?3?$FO7?5wglCreateContextAttr@ ; `string'
PUBLIC	??_C@_0DO@JHBJBKGE@?$FO1Error?3?$FO7?5wglCreateContextAttr@ ; `string'
PUBLIC	??_C@_0EE@JKMNHAKF@?$FO1Error?3?$FO7?5wglCreateContextAttr@ ; `string'
PUBLIC	??_C@_0ED@INJOCFND@?$FO1Error?3?$FO7?5wglCreateContextAttr@ ; `string'
PUBLIC	??_C@_0DL@OJIHOIAO@?$FO1Error?3?$FO7?5Unknown?5error?5creati@ ; `string'
PUBLIC	??_C@_0BL@PDDHMPGF@wglCreateContextAttribsARB@	; `string'
PUBLIC	??_C@_0CK@GLCIJGDL@GL_CreateContext?3?5using?5extende@ ; `string'
PUBLIC	??_C@_0CC@JALKLIBM@?$FO3Warning?3?$FO7?5MSAA?5is?5not?5allowe@ ; `string'
PUBLIC	??_C@_0CK@KPMKNLJO@VID_StartupGamma?3?5gamma?5?$CFg?5brig@ ; `string'
PUBLIC	??_C@_0L@PCNPAMAE@TestWindow@			; `string'
PUBLIC	??_C@_06EDNJMPJF@Xash3D@			; `string'
PUBLIC	??_C@_0BN@GDKHKIAN@wglGetPixelFormatAttribivARB@ ; `string'
PUBLIC	??_C@_0BI@JPMGGILH@wglChoosePixelFormatARB@	; `string'
PUBLIC	??_C@_0EJ@NLKFPFAK@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@ ; `string'
PUBLIC	??_C@_0CG@BOCCJDEP@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@ ; `string'
PUBLIC	??_C@_0CP@KMOPKOFH@VID_ChoosePFD?3?5using?5Generic?5MC@ ; `string'
PUBLIC	??_C@_0DO@DKAPEENC@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5n@ ; `string'
PUBLIC	??_C@_0CM@NFLBAACE@VID_ChoosePFD?3?5using?5hardware?5a@ ; `string'
PUBLIC	??_C@_0DP@HDFHNDFK@PixelFormat?3?5color?3?5?$CFd?9bit?0?5Z?9B@ ; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi@				; `string'
PUBLIC	??_C@_05IGKADHGO@width@				; `string'
PUBLIC	??_C@_06LNLHEAAG@height@			; `string'
PUBLIC	??_C@_08ICHJJAPN@vid_mode@			; `string'
PUBLIC	??_C@_0BB@HIMCMJIL@Set?3?5?$CFs?5?$FL?$CFdx?$CFd?$FN?6@ ; `string'
PUBLIC	??_C@_0O@NBEGDOKI@Xash3D?5Window@		; `string'
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	??_C@_0CM@PBKBDAIE@Extract?5?$CFs?5from?5pak?5if?5you?5want@ ; `string'
PUBLIC	??_C@_0EN@BICFBIKB@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@ ; `string'
PUBLIC	??_C@_0DC@EBFFCONK@?$FO3Warning?3?$FO7?5VID_CreateWindow?3?5@ ; `string'
PUBLIC	??_C@_0DD@OAMDGGDJ@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@ ; `string'
PUBLIC	??_C@_0CI@MKGEEDEG@?$FO1Error?3?$FO7?5OpenGL?5driver?5not?5in@ ; `string'
PUBLIC	??_C@_0BF@FJFOCBHB@vid_displayfrequency@	; `string'
PUBLIC	??_C@_0EC@MCKMDEPJ@?$FO1Error?3?$FO7?5VID_SetMode?3?5display@ ; `string'
PUBLIC	??_C@_0CF@JIIPBDNP@found?5specified?5vid?5mode?5?$CFi?5?$FL?$CFi@ ; `string'
PUBLIC	??_C@_0L@GIACNHMO@fullscreen@			; `string'
PUBLIC	??_C@_0CK@BDDCKCLM@failed?5to?5set?5specified?5vid?5mod@ ; `string'
PUBLIC	??_C@_0DN@NDNLGOKO@?$FO1Error?3?$FO7?5VID_SetMode?3?5fullscr@ ; `string'
PUBLIC	??_C@_0CG@IONHNGJE@?$FO1Error?3?$FO7?5VID_SetMode?3?5invalid@ ; `string'
PUBLIC	??_C@_0DH@OLPHDNFE@?$FO1Error?3?$FO7?5VID_SetMode?3?5could?5n@ ; `string'
PUBLIC	??_C@_0CF@IGHGDPNJ@Can?8t?5re?9initialize?5video?5subsy@ ; `string'
PUBLIC	??_C@_0BM@KNOAIAMH@OpenGL?5Internal?5ProcAddress@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0P@FAFHGBCB@GL_VENDOR?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_0BB@GPBJMNCI@GL_RENDERER?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BA@IECAGHEM@GL_VERSION?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BD@KJCGIEGA@GL_EXTENSIONS?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BF@MHGGCNCP@?6WGL_EXTENSIONS?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0BJ@DGHGDBBB@GL_MAX_TEXTURE_SIZE?3?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0BO@NJACCPAH@GL_MAX_TEXTURE_UNITS_ARB?3?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0CG@HNKECKCC@GL_MAX_CUBE_MAP_TEXTURE_SIZE_AR@ ; `string'
PUBLIC	??_C@_0CJ@EBIJAOFI@GL_MAX_TEXTURE_MAX_ANISOTROPY_E@ ; `string'
PUBLIC	??_C@_0CD@IPHBONJO@GL_MAX_RECTANGLE_TEXTURE_SIZE?3?5@ ; `string'
PUBLIC	??_C@_0CF@CAGCLDMN@GL_MAX_ARRAY_TEXTURE_LAYERS_EXT@ ; `string'
PUBLIC	??_C@_0BP@LMEKKNLC@GL_MAX_TEXTURE_COORDS_ARB?3?5?$CFi?6@ ; `string'
PUBLIC	??_C@_0CE@NIGBDIDN@GL_MAX_TEXTURE_IMAGE_UNITS_ARB?3@ ; `string'
PUBLIC	??_C@_0CK@BHOGBMDO@GL_MAX_VERTEX_UNIFORM_COMPONENT@ ; `string'
PUBLIC	??_C@_0BP@OJBBMJOE@GL_MAX_VERTEX_ATTRIBS_ARB?3?5?$CFi?6@ ; `string'
PUBLIC	??_C@_09JCGKCLMG@MODE?3?5?$CFs?6@		; `string'
PUBLIC	??_C@_07MHHIKOPA@enabled@			; `string'
PUBLIC	??_C@_08BEHKFNNO@disabled@			; `string'
PUBLIC	??_C@_0BD@PCFIIPCG@VERTICAL?5SYNC?3?5?$CFs?6@	; `string'
PUBLIC	??_C@_0DO@LBGEEHIA@Color?5?$CFd?5bits?0?5Alpha?5?$CFd?5bits?0?5D@ ; `string'
PUBLIC	??_C@_0BG@MJBAGIAO@shows?5renderer?5speeds@	; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_08ILOBJANK@r_speeds@			; `string'
PUBLIC	??_C@_0CP@LHCMIKFN@disable?5lightmaps?0?5get?5fullbrig@ ; `string'
PUBLIC	??_C@_0N@JEFJGNMG@r_fullbright@			; `string'
PUBLIC	??_C@_0CI@BOKLFLAG@disable?53D?5rendering?5?$CIuse?5with?5@ ; `string'
PUBLIC	??_C@_0M@HGMGOPHP@r_norefresh@			; `string'
PUBLIC	??_C@_0CH@GHBECDAJ@allow?5to?5get?5lighting?5from?5bmod@ ; `string'
PUBLIC	??_C@_0BE@DGDPLBLK@r_lighting_extended@		; `string'
PUBLIC	??_C@_0BL@BOCCKKNK@lightstyles?5modulate?5scale@ ; `string'
PUBLIC	??_C@_03JFFPCCNN@0?46@				; `string'
PUBLIC	??_C@_0BE@NGHAOOJB@r_lighting_modulate@		; `string'
PUBLIC	??_C@_0BL@PDHNOOLN@map?5ambient?5lighting?5scale@ ; `string'
PUBLIC	??_C@_03OICINGJI@0?43@				; `string'
PUBLIC	??_C@_0BD@FOLIHJDI@r_lighting_ambient@		; `string'
PUBLIC	??_C@_0CH@DJAJLKIF@making?5FOV?5adjustment?5for?5wide?9@ ; `string'
PUBLIC	??_C@_0N@NDLEOLDK@r_adjust_fov@			; `string'
PUBLIC	??_C@_0CJ@CJFDAHBF@ignore?5vis?5information?5?$CIperfoma@ ; `string'
PUBLIC	??_C@_07IFOJIEEJ@r_novis@			; `string'
PUBLIC	??_C@_0CK@IBIJJLKA@ignore?5frustrum?5culling?5?$CIperfom@ ; `string'
PUBLIC	??_C@_08GDHICAID@r_nocull@			; `string'
PUBLIC	??_C@_0EE@OIMDMFDP@enable?5detail?5textures?5support?0@ ; `string'
PUBLIC	??_C@_0BB@OJJFINJB@r_detailtextures@		; `string'
PUBLIC	??_C@_0CJ@ENDDEIKK@lockpvs?5area?5at?5current?5point?5?$CI@ ; `string'
PUBLIC	??_C@_09OGELGAJA@r_lockpvs@			; `string'
PUBLIC	??_C@_0DA@KNEJFKGN@lock?5frustrum?5area?5at?5current?5p@ ; `string'
PUBLIC	??_C@_0O@OPPHBGCA@r_lockfrustum@		; `string'
PUBLIC	??_C@_0CO@DPCKELLF@allow?5dynamic?5lighting?5?$CIdlights@ ; `string'
PUBLIC	??_C@_09DIEFKAPA@r_dynamic@			; `string'
PUBLIC	??_C@_0BK@JCMABPHA@cull?5flares?5behind?5models@ ; `string'
PUBLIC	??_C@_0M@BNLCJNG@r_traceglow@			; `string'
PUBLIC	??_C@_0BI@KFPFIPCN@lightmap?5debugging?5tool@	; `string'
PUBLIC	??_C@_0L@GFIPPKI@r_lightmap@			; `string'
PUBLIC	??_C@_0BA@OOOEBJD@render?5entities@		; `string'
PUBLIC	??_C@_0P@JAKGJBEE@r_drawentities@		; `string'
PUBLIC	??_C@_0CC@MFGJAJHH@sets?5the?5maximum?5number?5of?5deca@ ; `string'
PUBLIC	??_C@_04DPPBKBGP@4096@				; `string'
PUBLIC	??_C@_08HELCJCPN@r_decals@			; `string'
PUBLIC	??_C@_0CE@KKAJCFEF@build?5the?5graph?5of?5visible?5BSP?5@ ; `string'
PUBLIC	??_C@_0L@EACCIFLO@r_showtree@			; `string'
PUBLIC	??_C@_0BO@PBCKFEIH@window?5position?5by?5horizontal@ ; `string'
PUBLIC	??_C@_03GPEHNCBN@130@				; `string'
PUBLIC	??_C@_0N@FDEDDELO@_window_xpos@			; `string'
PUBLIC	??_C@_0BM@PGDAOPNK@window?5position?5by?5vertical@ ; `string'
PUBLIC	??_C@_02DEEDNHFK@48@				; `string'
PUBLIC	??_C@_0N@GOCDBNAO@_window_ypos@			; `string'
PUBLIC	??_C@_0BE@PAOPLDIB@allow?5gl_extensions@	; `string'
PUBLIC	??_C@_0BE@PPOOCPHN@gl_allow_extensions@		; `string'
PUBLIC	??_C@_0CB@COLHHNBP@enable?5multisample?5anti?9aliasin@ ; `string'
PUBLIC	??_C@_01FAMBOPH@4@				; `string'
PUBLIC	??_C@_0BE@EAHDGDAI@gl_wgl_msaa_samples@		; `string'
PUBLIC	??_C@_0BH@PGOBJMGE@disable?5texture?5filter@	; `string'
PUBLIC	??_C@_0BD@GHLMGJGC@gl_texture_nearest@		; `string'
PUBLIC	??_C@_0BI@KMEDCODF@disable?5lightmap?5filter@	; `string'
PUBLIC	??_C@_0BE@PIADLNDF@gl_lightmap_nearest@		; `string'
PUBLIC	??_C@_0BL@OLDCADMD@ignore?5video?5engine?5errors@ ; `string'
PUBLIC	??_C@_0BA@FJPIIIDB@gl_check_errors@		; `string'
PUBLIC	??_C@_0BP@DNJDEMIO@enable?5vertical?5syncronization@ ; `string'
PUBLIC	??_C@_08KIKGOAN@gl_vsync@			; `string'
PUBLIC	??_C@_0EC@OFKHNLNH@default?5scale?5applies?5while?5aut@ ; `string'
PUBLIC	??_C@_03EMGHBCAM@4?40@				; `string'
PUBLIC	??_C@_0P@MNOHEFJK@gl_detailscale@		; `string'
PUBLIC	??_C@_0BM@HAFCFNHJ@textures?5anisotropic?5filter@ ; `string'
PUBLIC	??_C@_01KJLJFBPL@8@				; `string'
PUBLIC	??_C@_0O@DGIPFEHA@gl_anisotropy@		; `string'
PUBLIC	??_C@_0DF@GBALLODP@LOD?5bias?5for?5mipmapped?5textures@ ; `string'
PUBLIC	??_C@_03MDAFIFFL@0?40@				; `string'
PUBLIC	??_C@_0BD@KLPBGJAB@gl_texture_lodbias@		; `string'
PUBLIC	??_C@_0CH@DEBJPNFI@removing?5tjuncs?5causes?5blinking@ ; `string'
PUBLIC	??_C@_0BC@PBNHCOGF@gl_keeptjunctions@		; `string'
PUBLIC	??_C@_0BO@GEMEBLEE@allow?5to?5draw?5mirror?5surfaces@ ; `string'
PUBLIC	??_C@_0BB@FDJONAEL@gl_allow_mirrors@		; `string'
PUBLIC	??_C@_0BH@HOMNMNHH@fake?5bumpmapping?5scale@	; `string'
PUBLIC	??_C@_0BA@JLEIJJJE@gl_emboss_scale@		; `string'
PUBLIC	??_C@_0BL@GPBANEGN@show?5all?5uploaded?5textures@ ; `string'
PUBLIC	??_C@_0P@MJMKNHCG@r_showtextures@		; `string'
PUBLIC	??_C@_0CA@PIHPBMHO@use?5glFinish?5instead?5of?5glFlush@ ; `string'
PUBLIC	??_C@_09EFDNHKBE@gl_finish@			; `string'
PUBLIC	??_C@_0CI@OGENCDBH@disable?5sorting?5of?5translucent?5@ ; `string'
PUBLIC	??_C@_09PKCFOMOL@gl_nosort@			; `string'
PUBLIC	??_C@_0CB@FNKBCEHJ@clearing?5screen?5after?5each?5fram@ ; `string'
PUBLIC	??_C@_08PJGLHBHM@gl_clear@			; `string'
PUBLIC	??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@ ; `string'
PUBLIC	??_C@_07OMHDDOEC@gl_test@			; `string'
PUBLIC	??_C@_0BH@JKFOEAPP@show?5wireframe?5overlay@	; `string'
PUBLIC	??_C@_0N@BABLDJLO@gl_wireframe@			; `string'
PUBLIC	??_C@_0CJ@PAOICFAB@round?5texture?5sizes?5to?5nearest?5@ ; `string'
PUBLIC	??_C@_01FDFGLJHB@2@				; `string'
PUBLIC	??_C@_0O@MDBDFJCF@gl_round_down@		; `string'
PUBLIC	??_C@_0CC@FILLBFN@enable?5multi?5sample?5anti?9aliasi@ ; `string'
PUBLIC	??_C@_07NMOGFCPI@gl_msaa@			; `string'
PUBLIC	??_C@_0BK@OMODEDDI@polygon?5offset?5for?5decals@ ; `string'
PUBLIC	??_C@_0O@DJABIOB@gl_polyoffset@			; `string'
PUBLIC	??_C@_0N@OKPJFHGN@gamma?5amount@		; `string'
PUBLIC	??_C@_03BEHLLJJF@2?45@				; `string'
PUBLIC	??_C@_05KDLBCAI@gamma@				; `string'
PUBLIC	??_C@_0BC@NIINGILH@brighntess?5factor@		; `string'
PUBLIC	??_C@_0L@BECHNFGG@brightness@			; `string'
PUBLIC	??_C@_0BI@GPDAEHPE@display?5resolution?5mode@	; `string'
PUBLIC	??_C@_02PGHGPEOM@?91@				; `string'
PUBLIC	??_C@_0BH@CFIPMPJA@enable?5fullscreen?5mode@	; `string'
PUBLIC	??_C@_0BI@HILNBDHA@fullscreen?5refresh?5rate@	; `string'
PUBLIC	??_C@_0CM@JCNBFDFE@downscale?5the?5view?51?5?9?51?12?0?52?5?9@ ; `string'
PUBLIC	??_C@_07CIMMGABH@r_scale@			; `string'
PUBLIC	??_C@_0BG@NIDHMICD@display?5renderer?5info@	; `string'
PUBLIC	??_C@_06FFIAOFH@r_info@				; `string'
PUBLIC	??_C@_0BB@PEOIMMGJ@exec?5opengl?4cfg?6@		; `string'
PUBLIC	??_C@_0BA@KPOOHPGG@exec?5video?4cfg?6@		; `string'
PUBLIC	??_C@_0N@LPDIHFOO@OpenGL?51?41?40@		; `string'
PUBLIC	??_C@_0P@FABBBPDP@?$FO3Video?3?$FO7?5?$CFs?6@	; `string'
PUBLIC	??_C@_07MPJPGECB@geforce@			; `string'
PUBLIC	??_C@_09IKHEJAGC@quadro?5fx@			; `string'
PUBLIC	??_C@_05ONNLOCAH@rv770@				; `string'
PUBLIC	??_C@_09BADJHFGO@radeon?5hd@			; `string'
PUBLIC	??_C@_07FHGIJLKP@eah4850@			; `string'
PUBLIC	??_C@_07FEOMEPMB@eah4870@			; `string'
PUBLIC	??_C@_06CHDCBPE@radeon@				; `string'
PUBLIC	??_C@_05CEMNNDEJ@intel@				; `string'
PUBLIC	??_C@_0BG@EMFJFGJF@WGL?5Extensions?5String@	; `string'
PUBLIC	??_C@_0BF@NPDKPIKE@WGL_EXT_swap_control@	; `string'
PUBLIC	??_C@_0BE@EJOPKNEG@gl_arb_multitexture@		; `string'
PUBLIC	??_C@_0BE@MEMOPMEA@GL_ARB_multitexture@		; `string'
PUBLIC	??_C@_0O@BKBMFEAO@gl_texture_3d@		; `string'
PUBLIC	??_C@_0BB@LCNIEGEB@GL_EXT_texture3D@		; `string'
PUBLIC	??_C@_0EN@PIMEDHIH@?$FO1Error?3?$FO7?5GL_EXT_texture3D?5rep@ ; `string'
PUBLIC	??_C@_0BE@IGFCPAI@gl_texture_2d_array@		; `string'
PUBLIC	??_C@_0BF@NFIKFJJJ@GL_EXT_texture_array@	; `string'
PUBLIC	??_C@_0BD@HBEJEDLE@gl_texture_cubemap@		; `string'
PUBLIC	??_C@_0BI@GGDPEJMJ@GL_ARB_texture_cube_map@	; `string'
PUBLIC	??_C@_0BM@CBHJAMMP@gl_texture_cubemap_seamless@	; `string'
PUBLIC	??_C@_0BJ@HMEOFOCO@GL_ARB_seamless_cube_map@	; `string'
PUBLIC	??_C@_0BA@OFKFFJCC@gl_texture_npot@		; `string'
PUBLIC	??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two@ ; `string'
PUBLIC	??_C@_0BL@KELAADP@gl_texture_dxt_compression@	; `string'
PUBLIC	??_C@_0BL@PEFPCGDJ@GL_ARB_texture_compression@	; `string'
PUBLIC	??_C@_0BK@BAOPHLFB@GL_EXT_texture_edge_clamp@	; `string'
PUBLIC	??_C@_0BL@JOCOPCOL@GL_SGIS_texture_edge_clamp@	; `string'
PUBLIC	??_C@_0BO@EJMKODIC@gl_texture_anisotropic_filter@ ; `string'
PUBLIC	??_C@_0CC@BCHFGKCK@GL_EXT_texture_filter_anisotrop@ ; `string'
PUBLIC	??_C@_0BK@OICKEAFL@gl_texture_mipmap_biasing@	; `string'
PUBLIC	??_C@_0BI@KEEAJGDF@GL_EXT_texture_lod_bias@	; `string'
PUBLIC	??_C@_0BM@CBHOGGCB@GL_ARB_texture_border_clamp@	; `string'
PUBLIC	??_C@_0BF@OKLDDGBF@GL_ARB_depth_texture@	; `string'
PUBLIC	??_C@_0BB@MNHIMBDK@gl_texture_float@		; `string'
PUBLIC	??_C@_0BF@IMLAOOOI@GL_ARB_texture_float@	; `string'
PUBLIC	??_C@_0BK@JKFHPKJF@GL_ARB_depth_buffer_float@	; `string'
PUBLIC	??_C@_0BD@MHBCPECK@GL_EXT_gpu_shader4@		; `string'
PUBLIC	??_C@_0BM@IABMMANC@GL_ARB_shading_language_100@	; `string'
PUBLIC	??_C@_0BA@CLNKMFGC@gl_debug_output@		; `string'
PUBLIC	??_C@_0BE@OHIPHHMJ@GL_ARB_debug_output@		; `string'
PUBLIC	??_C@_0BF@GHMIKALG@gl_texture_rectangle@	; `string'
PUBLIC	??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle@	; `string'
PUBLIC	??_C@_0BI@KIIANDGF@opengl?5texture?5max?5dims@	; `string'
PUBLIC	??_C@_0M@OALDNHGH@gl_max_size@			; `string'
PUBLIC	??_C@_03IDKLFMEL@gdi@				; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	?__LINE__Var@?0??R_Init@@9@9			; `R_Init'::`1'::__LINE__Var
PUBLIC	??_C@_0ED@FOEGDGGO@Can?8t?5initialize?5video?5subsyste@ ; `string'
PUBLIC	??_C@_0DF@BDEPHKGK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0M@BEDNAAAO@Render?5Zone@			; `string'
PUBLIC	?__LINE__Var@?0??R_Shutdown@@9@9		; `R_Shutdown'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@DLCDMCHH@GL_STACK_OVERFLOW@		; `string'
PUBLIC	??_C@_0BD@KAJAFKFC@GL_STACK_UNDERFLOW@		; `string'
PUBLIC	??_C@_0BA@LLPLHEDK@GL_INVALID_ENUM@		; `string'
PUBLIC	??_C@_0BB@HDIPJELP@GL_INVALID_VALUE@		; `string'
PUBLIC	??_C@_0BF@NFNGKHIL@GL_INVALID_OPERATION@	; `string'
PUBLIC	??_C@_0BB@JMBJBKGI@GL_OUT_OF_MEMORY@		; `string'
PUBLIC	??_C@_0O@KGJDDGD@UNKNOWN?5ERROR@		; `string'
PUBLIC	??_C@_0CI@CEFKNKJA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5?$CIcalled?5at@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
EXTRN	_memset:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ChoosePixelFormat@8:PROC
EXTRN	__imp__DescribePixelFormat@16:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__SetPixelFormat@12:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__LoadImageA@24:PROC
EXTRN	__imp__ChangeDisplaySettingsA@8:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Sys_LoadLibrary:PROC
EXTRN	_Sys_GetProcAddress:PROC
EXTRN	_Sys_FreeLibrary:PROC
EXTRN	_Cbuf_AddText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_stristr:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_FS_GetDiskPath:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_Image_AddCmdFlags:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_SCR_Init:PROC
EXTRN	_BuildGammaTable:PROC
EXTRN	_SCR_VidInit:PROC
EXTRN	_SCR_RegisterTextures:PROC
EXTRN	_GL_CleanupAllTextureUnits:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_ClearDecals:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_InitImages:PROC
EXTRN	_R_ShutdownImages:PROC
EXTRN	_R_ClearScene:PROC
EXTRN	_GL_InitRandomTable:PROC
EXTRN	_R_SpriteInit:PROC
EXTRN	_R_StudioInit:PROC
EXTRN	_R_AliasInit:PROC
EXTRN	_Mod_UnloadSpriteModel:PROC
EXTRN	_IN_WndProc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol3:PROC
EXTRN	_cl_allow_levelshots:DWORD
EXTRN	_host_developer:BYTE
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_hWndFake DD	01H DUP (?)
_hDCFake DD	01H DUP (?)
_hGLRCFake DD	01H DUP (?)
_context_flags DD 01H DUP (?)
?wndname@?1??VID_CreateWindow@@9@9 DB 0100H DUP (?)	; `VID_CreateWindow'::`2'::wndname
_BSS	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CI@CEFKNKJA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5?$CIcalled?5at@
CONST	SEGMENT
??_C@_0CI@CEFKNKJA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5?$CIcalled?5at@ DB '^'
	DB	'3OpenGL Error:^7 %s (called at %s:%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGJDDGD@UNKNOWN?5ERROR@
CONST	SEGMENT
??_C@_0O@KGJDDGD@UNKNOWN?5ERROR@ DB 'UNKNOWN ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JMBJBKGI@GL_OUT_OF_MEMORY@
CONST	SEGMENT
??_C@_0BB@JMBJBKGI@GL_OUT_OF_MEMORY@ DB 'GL_OUT_OF_MEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NFNGKHIL@GL_INVALID_OPERATION@
CONST	SEGMENT
??_C@_0BF@NFNGKHIL@GL_INVALID_OPERATION@ DB 'GL_INVALID_OPERATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HDIPJELP@GL_INVALID_VALUE@
CONST	SEGMENT
??_C@_0BB@HDIPJELP@GL_INVALID_VALUE@ DB 'GL_INVALID_VALUE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLPLHEDK@GL_INVALID_ENUM@
CONST	SEGMENT
??_C@_0BA@LLPLHEDK@GL_INVALID_ENUM@ DB 'GL_INVALID_ENUM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KAJAFKFC@GL_STACK_UNDERFLOW@
CONST	SEGMENT
??_C@_0BD@KAJAFKFC@GL_STACK_UNDERFLOW@ DB 'GL_STACK_UNDERFLOW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DLCDMCHH@GL_STACK_OVERFLOW@
CONST	SEGMENT
??_C@_0BC@DLCDMCHH@GL_STACK_OVERFLOW@ DB 'GL_STACK_OVERFLOW', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_Shutdown@@9@9 DD 0765H		; `R_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@BEDNAAAO@Render?5Zone@
CONST	SEGMENT
??_C@_0M@BEDNAAAO@Render?5Zone@ DB 'Render Zone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BDEPHKGK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@BDEPHKGK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_vidnt.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FOEGDGGO@Can?8t?5initialize?5video?5subsyste@
CONST	SEGMENT
??_C@_0ED@FOEGDGGO@Can?8t?5initialize?5video?5subsyste@ DB 'Can''t initia'
	DB	'lize video subsystem', 0aH, 'Probably driver was not installe'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_Init@@9@9 DD 073bH			; `R_Init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDKLFMEL@gdi@
CONST	SEGMENT
??_C@_03IDKLFMEL@gdi@ DB 'gdi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OALDNHGH@gl_max_size@
CONST	SEGMENT
??_C@_0M@OALDNHGH@gl_max_size@ DB 'gl_max_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KIIANDGF@opengl?5texture?5max?5dims@
CONST	SEGMENT
??_C@_0BI@KIIANDGF@opengl?5texture?5max?5dims@ DB 'opengl texture max dim'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle@
CONST	SEGMENT
??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle@ DB 'GL_ARB_texture_rectangle'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GHMIKALG@gl_texture_rectangle@
CONST	SEGMENT
??_C@_0BF@GHMIKALG@gl_texture_rectangle@ DB 'gl_texture_rectangle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHIPHHMJ@GL_ARB_debug_output@
CONST	SEGMENT
??_C@_0BE@OHIPHHMJ@GL_ARB_debug_output@ DB 'GL_ARB_debug_output', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLNKMFGC@gl_debug_output@
CONST	SEGMENT
??_C@_0BA@CLNKMFGC@gl_debug_output@ DB 'gl_debug_output', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IABMMANC@GL_ARB_shading_language_100@
CONST	SEGMENT
??_C@_0BM@IABMMANC@GL_ARB_shading_language_100@ DB 'GL_ARB_shading_langua'
	DB	'ge_100', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHBCPECK@GL_EXT_gpu_shader4@
CONST	SEGMENT
??_C@_0BD@MHBCPECK@GL_EXT_gpu_shader4@ DB 'GL_EXT_gpu_shader4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JKFHPKJF@GL_ARB_depth_buffer_float@
CONST	SEGMENT
??_C@_0BK@JKFHPKJF@GL_ARB_depth_buffer_float@ DB 'GL_ARB_depth_buffer_flo'
	DB	'at', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IMLAOOOI@GL_ARB_texture_float@
CONST	SEGMENT
??_C@_0BF@IMLAOOOI@GL_ARB_texture_float@ DB 'GL_ARB_texture_float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNHIMBDK@gl_texture_float@
CONST	SEGMENT
??_C@_0BB@MNHIMBDK@gl_texture_float@ DB 'gl_texture_float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OKLDDGBF@GL_ARB_depth_texture@
CONST	SEGMENT
??_C@_0BF@OKLDDGBF@GL_ARB_depth_texture@ DB 'GL_ARB_depth_texture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CBHOGGCB@GL_ARB_texture_border_clamp@
CONST	SEGMENT
??_C@_0BM@CBHOGGCB@GL_ARB_texture_border_clamp@ DB 'GL_ARB_texture_border'
	DB	'_clamp', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KEEAJGDF@GL_EXT_texture_lod_bias@
CONST	SEGMENT
??_C@_0BI@KEEAJGDF@GL_EXT_texture_lod_bias@ DB 'GL_EXT_texture_lod_bias', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OICKEAFL@gl_texture_mipmap_biasing@
CONST	SEGMENT
??_C@_0BK@OICKEAFL@gl_texture_mipmap_biasing@ DB 'gl_texture_mipmap_biasi'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BCHFGKCK@GL_EXT_texture_filter_anisotrop@
CONST	SEGMENT
??_C@_0CC@BCHFGKCK@GL_EXT_texture_filter_anisotrop@ DB 'GL_EXT_texture_fi'
	DB	'lter_anisotropic', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EJMKODIC@gl_texture_anisotropic_filter@
CONST	SEGMENT
??_C@_0BO@EJMKODIC@gl_texture_anisotropic_filter@ DB 'gl_texture_anisotro'
	DB	'pic_filter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JOCOPCOL@GL_SGIS_texture_edge_clamp@
CONST	SEGMENT
??_C@_0BL@JOCOPCOL@GL_SGIS_texture_edge_clamp@ DB 'GL_SGIS_texture_edge_c'
	DB	'lamp', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BAOPHLFB@GL_EXT_texture_edge_clamp@
CONST	SEGMENT
??_C@_0BK@BAOPHLFB@GL_EXT_texture_edge_clamp@ DB 'GL_EXT_texture_edge_cla'
	DB	'mp', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PEFPCGDJ@GL_ARB_texture_compression@
CONST	SEGMENT
??_C@_0BL@PEFPCGDJ@GL_ARB_texture_compression@ DB 'GL_ARB_texture_compres'
	DB	'sion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KELAADP@gl_texture_dxt_compression@
CONST	SEGMENT
??_C@_0BL@KELAADP@gl_texture_dxt_compression@ DB 'gl_texture_dxt_compress'
	DB	'ion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two@
CONST	SEGMENT
??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two@ DB 'GL_ARB_texture_no'
	DB	'n_power_of_two', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OFKFFJCC@gl_texture_npot@
CONST	SEGMENT
??_C@_0BA@OFKFFJCC@gl_texture_npot@ DB 'gl_texture_npot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMEOFOCO@GL_ARB_seamless_cube_map@
CONST	SEGMENT
??_C@_0BJ@HMEOFOCO@GL_ARB_seamless_cube_map@ DB 'GL_ARB_seamless_cube_map'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CBHJAMMP@gl_texture_cubemap_seamless@
CONST	SEGMENT
??_C@_0BM@CBHJAMMP@gl_texture_cubemap_seamless@ DB 'gl_texture_cubemap_se'
	DB	'amless', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GGDPEJMJ@GL_ARB_texture_cube_map@
CONST	SEGMENT
??_C@_0BI@GGDPEJMJ@GL_ARB_texture_cube_map@ DB 'GL_ARB_texture_cube_map', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HBEJEDLE@gl_texture_cubemap@
CONST	SEGMENT
??_C@_0BD@HBEJEDLE@gl_texture_cubemap@ DB 'gl_texture_cubemap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NFIKFJJJ@GL_EXT_texture_array@
CONST	SEGMENT
??_C@_0BF@NFIKFJJJ@GL_EXT_texture_array@ DB 'GL_EXT_texture_array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGFCPAI@gl_texture_2d_array@
CONST	SEGMENT
??_C@_0BE@IGFCPAI@gl_texture_2d_array@ DB 'gl_texture_2d_array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PIMEDHIH@?$FO1Error?3?$FO7?5GL_EXT_texture3D?5rep@
CONST	SEGMENT
??_C@_0EN@PIMEDHIH@?$FO1Error?3?$FO7?5GL_EXT_texture3D?5rep@ DB '^1Error:'
	DB	'^7 GL_EXT_texture3D reported bogus GL_MAX_3D_TEXTURE_SIZE, di'
	DB	'sabled', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCNIEGEB@GL_EXT_texture3D@
CONST	SEGMENT
??_C@_0BB@LCNIEGEB@GL_EXT_texture3D@ DB 'GL_EXT_texture3D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKBMFEAO@gl_texture_3d@
CONST	SEGMENT
??_C@_0O@BKBMFEAO@gl_texture_3d@ DB 'gl_texture_3d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MEMOPMEA@GL_ARB_multitexture@
CONST	SEGMENT
??_C@_0BE@MEMOPMEA@GL_ARB_multitexture@ DB 'GL_ARB_multitexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJOPKNEG@gl_arb_multitexture@
CONST	SEGMENT
??_C@_0BE@EJOPKNEG@gl_arb_multitexture@ DB 'gl_arb_multitexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPDKPIKE@WGL_EXT_swap_control@
CONST	SEGMENT
??_C@_0BF@NPDKPIKE@WGL_EXT_swap_control@ DB 'WGL_EXT_swap_control', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMFJFGJF@WGL?5Extensions?5String@
CONST	SEGMENT
??_C@_0BG@EMFJFGJF@WGL?5Extensions?5String@ DB 'WGL Extensions String', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CEMNNDEJ@intel@
CONST	SEGMENT
??_C@_05CEMNNDEJ@intel@ DB 'intel', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHDCBPE@radeon@
CONST	SEGMENT
??_C@_06CHDCBPE@radeon@ DB 'radeon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FEOMEPMB@eah4870@
CONST	SEGMENT
??_C@_07FEOMEPMB@eah4870@ DB 'eah4870', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FHGIJLKP@eah4850@
CONST	SEGMENT
??_C@_07FHGIJLKP@eah4850@ DB 'eah4850', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BADJHFGO@radeon?5hd@
CONST	SEGMENT
??_C@_09BADJHFGO@radeon?5hd@ DB 'radeon hd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONNLOCAH@rv770@
CONST	SEGMENT
??_C@_05ONNLOCAH@rv770@ DB 'rv770', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKHEJAGC@quadro?5fx@
CONST	SEGMENT
??_C@_09IKHEJAGC@quadro?5fx@ DB 'quadro fx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPJPGECB@geforce@
CONST	SEGMENT
??_C@_07MPJPGECB@geforce@ DB 'geforce', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FABBBPDP@?$FO3Video?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@FABBBPDP@?$FO3Video?3?$FO7?5?$CFs?6@ DB '^3Video:^7 %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPDIHFOO@OpenGL?51?41?40@
CONST	SEGMENT
??_C@_0N@LPDIHFOO@OpenGL?51?41?40@ DB 'OpenGL 1.1.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPOOHPGG@exec?5video?4cfg?6@
CONST	SEGMENT
??_C@_0BA@KPOOHPGG@exec?5video?4cfg?6@ DB 'exec video.cfg', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PEOIMMGJ@exec?5opengl?4cfg?6@
CONST	SEGMENT
??_C@_0BB@PEOIMMGJ@exec?5opengl?4cfg?6@ DB 'exec opengl.cfg', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFIAOFH@r_info@
CONST	SEGMENT
??_C@_06FFIAOFH@r_info@ DB 'r_info', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NIDHMICD@display?5renderer?5info@
CONST	SEGMENT
??_C@_0BG@NIDHMICD@display?5renderer?5info@ DB 'display renderer info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIMMGABH@r_scale@
CONST	SEGMENT
??_C@_07CIMMGABH@r_scale@ DB 'r_scale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JCNBFDFE@downscale?5the?5view?51?5?9?51?12?0?52?5?9@
CONST	SEGMENT
??_C@_0CM@JCNBFDFE@downscale?5the?5view?51?5?9?51?12?0?52?5?9@ DB 'downsc'
	DB	'ale the view 1 - 1/2, 2 - 1/4, etc...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HILNBDHA@fullscreen?5refresh?5rate@
CONST	SEGMENT
??_C@_0BI@HILNBDHA@fullscreen?5refresh?5rate@ DB 'fullscreen refresh rate'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIPMPJA@enable?5fullscreen?5mode@
CONST	SEGMENT
??_C@_0BH@CFIPMPJA@enable?5fullscreen?5mode@ DB 'enable fullscreen mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PGHGPEOM@?91@
CONST	SEGMENT
??_C@_02PGHGPEOM@?91@ DB '-1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPDAEHPE@display?5resolution?5mode@
CONST	SEGMENT
??_C@_0BI@GPDAEHPE@display?5resolution?5mode@ DB 'display resolution mode'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BECHNFGG@brightness@
CONST	SEGMENT
??_C@_0L@BECHNFGG@brightness@ DB 'brightness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIINGILH@brighntess?5factor@
CONST	SEGMENT
??_C@_0BC@NIINGILH@brighntess?5factor@ DB 'brighntess factor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDLBCAI@gamma@
CONST	SEGMENT
??_C@_05KDLBCAI@gamma@ DB 'gamma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BEHLLJJF@2?45@
CONST	SEGMENT
??_C@_03BEHLLJJF@2?45@ DB '2.5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OKPJFHGN@gamma?5amount@
CONST	SEGMENT
??_C@_0N@OKPJFHGN@gamma?5amount@ DB 'gamma amount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJABIOB@gl_polyoffset@
CONST	SEGMENT
??_C@_0O@DJABIOB@gl_polyoffset@ DB 'gl_polyoffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OMODEDDI@polygon?5offset?5for?5decals@
CONST	SEGMENT
??_C@_0BK@OMODEDDI@polygon?5offset?5for?5decals@ DB 'polygon offset for d'
	DB	'ecals', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07NMOGFCPI@gl_msaa@
CONST	SEGMENT
??_C@_07NMOGFCPI@gl_msaa@ DB 'gl_msaa', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FILLBFN@enable?5multi?5sample?5anti?9aliasi@
CONST	SEGMENT
??_C@_0CC@FILLBFN@enable?5multi?5sample?5anti?9aliasi@ DB 'enable multi s'
	DB	'ample anti-aliasing', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MDBDFJCF@gl_round_down@
CONST	SEGMENT
??_C@_0O@MDBDFJCF@gl_round_down@ DB 'gl_round_down', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2@
CONST	SEGMENT
??_C@_01FDFGLJHB@2@ DB '2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PAOICFAB@round?5texture?5sizes?5to?5nearest?5@
CONST	SEGMENT
??_C@_0CJ@PAOICFAB@round?5texture?5sizes?5to?5nearest?5@ DB 'round textur'
	DB	'e sizes to nearest POT value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BABLDJLO@gl_wireframe@
CONST	SEGMENT
??_C@_0N@BABLDJLO@gl_wireframe@ DB 'gl_wireframe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JKFOEAPP@show?5wireframe?5overlay@
CONST	SEGMENT
??_C@_0BH@JKFOEAPP@show?5wireframe?5overlay@ DB 'show wireframe overlay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OMHDDOEC@gl_test@
CONST	SEGMENT
??_C@_07OMHDDOEC@gl_test@ DB 'gl_test', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@
CONST	SEGMENT
??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@ DB 'engine develo'
	DB	'per cvar for quick testing new features', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJGLHBHM@gl_clear@
CONST	SEGMENT
??_C@_08PJGLHBHM@gl_clear@ DB 'gl_clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FNKBCEHJ@clearing?5screen?5after?5each?5fram@
CONST	SEGMENT
??_C@_0CB@FNKBCEHJ@clearing?5screen?5after?5each?5fram@ DB 'clearing scre'
	DB	'en after each frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKCFOMOL@gl_nosort@
CONST	SEGMENT
??_C@_09PKCFOMOL@gl_nosort@ DB 'gl_nosort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OGENCDBH@disable?5sorting?5of?5translucent?5@
CONST	SEGMENT
??_C@_0CI@OGENCDBH@disable?5sorting?5of?5translucent?5@ DB 'disable sorti'
	DB	'ng of translucent surfaces', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFDNHKBE@gl_finish@
CONST	SEGMENT
??_C@_09EFDNHKBE@gl_finish@ DB 'gl_finish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PIHPBMHO@use?5glFinish?5instead?5of?5glFlush@
CONST	SEGMENT
??_C@_0CA@PIHPBMHO@use?5glFinish?5instead?5of?5glFlush@ DB 'use glFinish '
	DB	'instead of glFlush', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJMKNHCG@r_showtextures@
CONST	SEGMENT
??_C@_0P@MJMKNHCG@r_showtextures@ DB 'r_showtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPBANEGN@show?5all?5uploaded?5textures@
CONST	SEGMENT
??_C@_0BL@GPBANEGN@show?5all?5uploaded?5textures@ DB 'show all uploaded t'
	DB	'extures', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JLEIJJJE@gl_emboss_scale@
CONST	SEGMENT
??_C@_0BA@JLEIJJJE@gl_emboss_scale@ DB 'gl_emboss_scale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HOMNMNHH@fake?5bumpmapping?5scale@
CONST	SEGMENT
??_C@_0BH@HOMNMNHH@fake?5bumpmapping?5scale@ DB 'fake bumpmapping scale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FDJONAEL@gl_allow_mirrors@
CONST	SEGMENT
??_C@_0BB@FDJONAEL@gl_allow_mirrors@ DB 'gl_allow_mirrors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEMEBLEE@allow?5to?5draw?5mirror?5surfaces@
CONST	SEGMENT
??_C@_0BO@GEMEBLEE@allow?5to?5draw?5mirror?5surfaces@ DB 'allow to draw m'
	DB	'irror surfaces', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PBNHCOGF@gl_keeptjunctions@
CONST	SEGMENT
??_C@_0BC@PBNHCOGF@gl_keeptjunctions@ DB 'gl_keeptjunctions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEBJPNFI@removing?5tjuncs?5causes?5blinking@
CONST	SEGMENT
??_C@_0CH@DEBJPNFI@removing?5tjuncs?5causes?5blinking@ DB 'removing tjunc'
	DB	's causes blinking pixels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLPBGJAB@gl_texture_lodbias@
CONST	SEGMENT
??_C@_0BD@KLPBGJAB@gl_texture_lodbias@ DB 'gl_texture_lodbias', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDAFIFFL@0?40@
CONST	SEGMENT
??_C@_03MDAFIFFL@0?40@ DB '0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GBALLODP@LOD?5bias?5for?5mipmapped?5textures@
CONST	SEGMENT
??_C@_0DF@GBALLODP@LOD?5bias?5for?5mipmapped?5textures@ DB 'LOD bias for '
	DB	'mipmapped textures (perfomance|quality)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DGIPFEHA@gl_anisotropy@
CONST	SEGMENT
??_C@_0O@DGIPFEHA@gl_anisotropy@ DB 'gl_anisotropy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8@
CONST	SEGMENT
??_C@_01KJLJFBPL@8@ DB '8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HAFCFNHJ@textures?5anisotropic?5filter@
CONST	SEGMENT
??_C@_0BM@HAFCFNHJ@textures?5anisotropic?5filter@ DB 'textures anisotropi'
	DB	'c filter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MNOHEFJK@gl_detailscale@
CONST	SEGMENT
??_C@_0P@MNOHEFJK@gl_detailscale@ DB 'gl_detailscale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHBCAM@4?40@
CONST	SEGMENT
??_C@_03EMGHBCAM@4?40@ DB '4.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@OFKHNLNH@default?5scale?5applies?5while?5aut@
CONST	SEGMENT
??_C@_0EC@OFKHNLNH@default?5scale?5applies?5while?5aut@ DB 'default scale'
	DB	' applies while auto-generate list of detail textures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KIKGOAN@gl_vsync@
CONST	SEGMENT
??_C@_08KIKGOAN@gl_vsync@ DB 'gl_vsync', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DNJDEMIO@enable?5vertical?5syncronization@
CONST	SEGMENT
??_C@_0BP@DNJDEMIO@enable?5vertical?5syncronization@ DB 'enable vertical '
	DB	'syncronization', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJPIIIDB@gl_check_errors@
CONST	SEGMENT
??_C@_0BA@FJPIIIDB@gl_check_errors@ DB 'gl_check_errors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OLDCADMD@ignore?5video?5engine?5errors@
CONST	SEGMENT
??_C@_0BL@OLDCADMD@ignore?5video?5engine?5errors@ DB 'ignore video engine'
	DB	' errors', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PIADLNDF@gl_lightmap_nearest@
CONST	SEGMENT
??_C@_0BE@PIADLNDF@gl_lightmap_nearest@ DB 'gl_lightmap_nearest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KMEDCODF@disable?5lightmap?5filter@
CONST	SEGMENT
??_C@_0BI@KMEDCODF@disable?5lightmap?5filter@ DB 'disable lightmap filter'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GHLMGJGC@gl_texture_nearest@
CONST	SEGMENT
??_C@_0BD@GHLMGJGC@gl_texture_nearest@ DB 'gl_texture_nearest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGOBJMGE@disable?5texture?5filter@
CONST	SEGMENT
??_C@_0BH@PGOBJMGE@disable?5texture?5filter@ DB 'disable texture filter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAHDGDAI@gl_wgl_msaa_samples@
CONST	SEGMENT
??_C@_0BE@EAHDGDAI@gl_wgl_msaa_samples@ DB 'gl_wgl_msaa_samples', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4@
CONST	SEGMENT
??_C@_01FAMBOPH@4@ DB '4', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@COLHHNBP@enable?5multisample?5anti?9aliasin@
CONST	SEGMENT
??_C@_0CB@COLHHNBP@enable?5multisample?5anti?9aliasin@ DB 'enable multisa'
	DB	'mple anti-aliasing', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PPOOCPHN@gl_allow_extensions@
CONST	SEGMENT
??_C@_0BE@PPOOCPHN@gl_allow_extensions@ DB 'gl_allow_extensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PAOPLDIB@allow?5gl_extensions@
CONST	SEGMENT
??_C@_0BE@PAOPLDIB@allow?5gl_extensions@ DB 'allow gl_extensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOCDBNAO@_window_ypos@
CONST	SEGMENT
??_C@_0N@GOCDBNAO@_window_ypos@ DB '_window_ypos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEEDNHFK@48@
CONST	SEGMENT
??_C@_02DEEDNHFK@48@ DB '48', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PGDAOPNK@window?5position?5by?5vertical@
CONST	SEGMENT
??_C@_0BM@PGDAOPNK@window?5position?5by?5vertical@ DB 'window position by'
	DB	' vertical', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDEDDELO@_window_xpos@
CONST	SEGMENT
??_C@_0N@FDEDDELO@_window_xpos@ DB '_window_xpos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GPEHNCBN@130@
CONST	SEGMENT
??_C@_03GPEHNCBN@130@ DB '130', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PBCKFEIH@window?5position?5by?5horizontal@
CONST	SEGMENT
??_C@_0BO@PBCKFEIH@window?5position?5by?5horizontal@ DB 'window position '
	DB	'by horizontal', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EACCIFLO@r_showtree@
CONST	SEGMENT
??_C@_0L@EACCIFLO@r_showtree@ DB 'r_showtree', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KKAJCFEF@build?5the?5graph?5of?5visible?5BSP?5@
CONST	SEGMENT
??_C@_0CE@KKAJCFEF@build?5the?5graph?5of?5visible?5BSP?5@ DB 'build the g'
	DB	'raph of visible BSP tree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HELCJCPN@r_decals@
CONST	SEGMENT
??_C@_08HELCJCPN@r_decals@ DB 'r_decals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DPPBKBGP@4096@
CONST	SEGMENT
??_C@_04DPPBKBGP@4096@ DB '4096', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MFGJAJHH@sets?5the?5maximum?5number?5of?5deca@
CONST	SEGMENT
??_C@_0CC@MFGJAJHH@sets?5the?5maximum?5number?5of?5deca@ DB 'sets the max'
	DB	'imum number of decals', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JAKGJBEE@r_drawentities@
CONST	SEGMENT
??_C@_0P@JAKGJBEE@r_drawentities@ DB 'r_drawentities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OOOEBJD@render?5entities@
CONST	SEGMENT
??_C@_0BA@OOOEBJD@render?5entities@ DB 'render entities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFIPPKI@r_lightmap@
CONST	SEGMENT
??_C@_0L@GFIPPKI@r_lightmap@ DB 'r_lightmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KFPFIPCN@lightmap?5debugging?5tool@
CONST	SEGMENT
??_C@_0BI@KFPFIPCN@lightmap?5debugging?5tool@ DB 'lightmap debugging tool'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNLCJNG@r_traceglow@
CONST	SEGMENT
??_C@_0M@BNLCJNG@r_traceglow@ DB 'r_traceglow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JCMABPHA@cull?5flares?5behind?5models@
CONST	SEGMENT
??_C@_0BK@JCMABPHA@cull?5flares?5behind?5models@ DB 'cull flares behind m'
	DB	'odels', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09DIEFKAPA@r_dynamic@
CONST	SEGMENT
??_C@_09DIEFKAPA@r_dynamic@ DB 'r_dynamic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DPCKELLF@allow?5dynamic?5lighting?5?$CIdlights@
CONST	SEGMENT
??_C@_0CO@DPCKELLF@allow?5dynamic?5lighting?5?$CIdlights@ DB 'allow dynam'
	DB	'ic lighting (dlights, lightstyles)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPPHBGCA@r_lockfrustum@
CONST	SEGMENT
??_C@_0O@OPPHBGCA@r_lockfrustum@ DB 'r_lockfrustum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KNEJFKGN@lock?5frustrum?5area?5at?5current?5p@
CONST	SEGMENT
??_C@_0DA@KNEJFKGN@lock?5frustrum?5area?5at?5current?5p@ DB 'lock frustru'
	DB	'm area at current point (cull test)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGELGAJA@r_lockpvs@
CONST	SEGMENT
??_C@_09OGELGAJA@r_lockpvs@ DB 'r_lockpvs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ENDDEIKK@lockpvs?5area?5at?5current?5point?5?$CI@
CONST	SEGMENT
??_C@_0CJ@ENDDEIKK@lockpvs?5area?5at?5current?5point?5?$CI@ DB 'lockpvs a'
	DB	'rea at current point (pvs test)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OJJFINJB@r_detailtextures@
CONST	SEGMENT
??_C@_0BB@OJJFINJB@r_detailtextures@ DB 'r_detailtextures', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@OIMDMFDP@enable?5detail?5textures?5support?0@
CONST	SEGMENT
??_C@_0EE@OIMDMFDP@enable?5detail?5textures?5support?0@ DB 'enable detail'
	DB	' textures support, use ''2'' for autogenerate detail.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDHICAID@r_nocull@
CONST	SEGMENT
??_C@_08GDHICAID@r_nocull@ DB 'r_nocull', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBIJJLKA@ignore?5frustrum?5culling?5?$CIperfom@
CONST	SEGMENT
??_C@_0CK@IBIJJLKA@ignore?5frustrum?5culling?5?$CIperfom@ DB 'ignore frus'
	DB	'trum culling (perfomance test)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IFOJIEEJ@r_novis@
CONST	SEGMENT
??_C@_07IFOJIEEJ@r_novis@ DB 'r_novis', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CJFDAHBF@ignore?5vis?5information?5?$CIperfoma@
CONST	SEGMENT
??_C@_0CJ@CJFDAHBF@ignore?5vis?5information?5?$CIperfoma@ DB 'ignore vis '
	DB	'information (perfomance test)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDLEOLDK@r_adjust_fov@
CONST	SEGMENT
??_C@_0N@NDLEOLDK@r_adjust_fov@ DB 'r_adjust_fov', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DJAJLKIF@making?5FOV?5adjustment?5for?5wide?9@
CONST	SEGMENT
??_C@_0CH@DJAJLKIF@making?5FOV?5adjustment?5for?5wide?9@ DB 'making FOV a'
	DB	'djustment for wide-screens', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FOLIHJDI@r_lighting_ambient@
CONST	SEGMENT
??_C@_0BD@FOLIHJDI@r_lighting_ambient@ DB 'r_lighting_ambient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OICINGJI@0?43@
CONST	SEGMENT
??_C@_03OICINGJI@0?43@ DB '0.3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PDHNOOLN@map?5ambient?5lighting?5scale@
CONST	SEGMENT
??_C@_0BL@PDHNOOLN@map?5ambient?5lighting?5scale@ DB 'map ambient lightin'
	DB	'g scale', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGHAOOJB@r_lighting_modulate@
CONST	SEGMENT
??_C@_0BE@NGHAOOJB@r_lighting_modulate@ DB 'r_lighting_modulate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFFPCCNN@0?46@
CONST	SEGMENT
??_C@_03JFFPCCNN@0?46@ DB '0.6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BOCCKKNK@lightstyles?5modulate?5scale@
CONST	SEGMENT
??_C@_0BL@BOCCKKNK@lightstyles?5modulate?5scale@ DB 'lightstyles modulate'
	DB	' scale', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DGDPLBLK@r_lighting_extended@
CONST	SEGMENT
??_C@_0BE@DGDPLBLK@r_lighting_extended@ DB 'r_lighting_extended', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GHBECDAJ@allow?5to?5get?5lighting?5from?5bmod@
CONST	SEGMENT
??_C@_0CH@GHBECDAJ@allow?5to?5get?5lighting?5from?5bmod@ DB 'allow to get'
	DB	' lighting from bmodels too', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HGMGOPHP@r_norefresh@
CONST	SEGMENT
??_C@_0M@HGMGOPHP@r_norefresh@ DB 'r_norefresh', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BOKLFLAG@disable?53D?5rendering?5?$CIuse?5with?5@
CONST	SEGMENT
??_C@_0CI@BOKLFLAG@disable?53D?5rendering?5?$CIuse?5with?5@ DB 'disable 3'
	DB	'D rendering (use with caution)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JEFJGNMG@r_fullbright@
CONST	SEGMENT
??_C@_0N@JEFJGNMG@r_fullbright@ DB 'r_fullbright', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LHCMIKFN@disable?5lightmaps?0?5get?5fullbrig@
CONST	SEGMENT
??_C@_0CP@LHCMIKFN@disable?5lightmaps?0?5get?5fullbrig@ DB 'disable light'
	DB	'maps, get fullbright for entities', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILOBJANK@r_speeds@
CONST	SEGMENT
??_C@_08ILOBJANK@r_speeds@ DB 'r_speeds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MJBAGIAO@shows?5renderer?5speeds@
CONST	SEGMENT
??_C@_0BG@MJBAGIAO@shows?5renderer?5speeds@ DB 'shows renderer speeds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LBGEEHIA@Color?5?$CFd?5bits?0?5Alpha?5?$CFd?5bits?0?5D@
CONST	SEGMENT
??_C@_0DO@LBGEEHIA@Color?5?$CFd?5bits?0?5Alpha?5?$CFd?5bits?0?5D@ DB 'Col'
	DB	'or %d bits, Alpha %d bits, Depth %d bits, Stencil %d bits', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCFIIPCG@VERTICAL?5SYNC?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@PCFIIPCG@VERTICAL?5SYNC?3?5?$CFs?6@ DB 'VERTICAL SYNC: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEHKFNNO@disabled@
CONST	SEGMENT
??_C@_08BEHKFNNO@disabled@ DB 'disabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHHIKOPA@enabled@
CONST	SEGMENT
??_C@_07MHHIKOPA@enabled@ DB 'enabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCGKCLMG@MODE?3?5?$CFs?6@
CONST	SEGMENT
??_C@_09JCGKCLMG@MODE?3?5?$CFs?6@ DB 'MODE: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OJBBMJOE@GL_MAX_VERTEX_ATTRIBS_ARB?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BP@OJBBMJOE@GL_MAX_VERTEX_ATTRIBS_ARB?3?5?$CFi?6@ DB 'GL_MAX_VERTE'
	DB	'X_ATTRIBS_ARB: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BHOGBMDO@GL_MAX_VERTEX_UNIFORM_COMPONENT@
CONST	SEGMENT
??_C@_0CK@BHOGBMDO@GL_MAX_VERTEX_UNIFORM_COMPONENT@ DB 'GL_MAX_VERTEX_UNI'
	DB	'FORM_COMPONENTS_ARB: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NIGBDIDN@GL_MAX_TEXTURE_IMAGE_UNITS_ARB?3@
CONST	SEGMENT
??_C@_0CE@NIGBDIDN@GL_MAX_TEXTURE_IMAGE_UNITS_ARB?3@ DB 'GL_MAX_TEXTURE_I'
	DB	'MAGE_UNITS_ARB: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LMEKKNLC@GL_MAX_TEXTURE_COORDS_ARB?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BP@LMEKKNLC@GL_MAX_TEXTURE_COORDS_ARB?3?5?$CFi?6@ DB 'GL_MAX_TEXTU'
	DB	'RE_COORDS_ARB: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CAGCLDMN@GL_MAX_ARRAY_TEXTURE_LAYERS_EXT@
CONST	SEGMENT
??_C@_0CF@CAGCLDMN@GL_MAX_ARRAY_TEXTURE_LAYERS_EXT@ DB 'GL_MAX_ARRAY_TEXT'
	DB	'URE_LAYERS_EXT: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IPHBONJO@GL_MAX_RECTANGLE_TEXTURE_SIZE?3?5@
CONST	SEGMENT
??_C@_0CD@IPHBONJO@GL_MAX_RECTANGLE_TEXTURE_SIZE?3?5@ DB 'GL_MAX_RECTANGL'
	DB	'E_TEXTURE_SIZE: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EBIJAOFI@GL_MAX_TEXTURE_MAX_ANISOTROPY_E@
CONST	SEGMENT
??_C@_0CJ@EBIJAOFI@GL_MAX_TEXTURE_MAX_ANISOTROPY_E@ DB 'GL_MAX_TEXTURE_MA'
	DB	'X_ANISOTROPY_EXT: %.1f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HNKECKCC@GL_MAX_CUBE_MAP_TEXTURE_SIZE_AR@
CONST	SEGMENT
??_C@_0CG@HNKECKCC@GL_MAX_CUBE_MAP_TEXTURE_SIZE_AR@ DB 'GL_MAX_CUBE_MAP_T'
	DB	'EXTURE_SIZE_ARB: %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NJACCPAH@GL_MAX_TEXTURE_UNITS_ARB?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BO@NJACCPAH@GL_MAX_TEXTURE_UNITS_ARB?3?5?$CFi?6@ DB 'GL_MAX_TEXTUR'
	DB	'E_UNITS_ARB: %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DGHGDBBB@GL_MAX_TEXTURE_SIZE?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0BJ@DGHGDBBB@GL_MAX_TEXTURE_SIZE?3?5?$CFi?6@ DB 'GL_MAX_TEXTURE_SIZ'
	DB	'E: %i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MHGGCNCP@?6WGL_EXTENSIONS?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@MHGGCNCP@?6WGL_EXTENSIONS?3?5?$CFs?6@ DB 0aH, 'WGL_EXTENSIONS: '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJCGIEGA@GL_EXTENSIONS?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@KJCGIEGA@GL_EXTENSIONS?3?5?$CFs?6@ DB 'GL_EXTENSIONS: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IECAGHEM@GL_VERSION?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BA@IECAGHEM@GL_VERSION?3?5?$CFs?6@ DB 'GL_VERSION: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GPBJMNCI@GL_RENDERER?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BB@GPBJMNCI@GL_RENDERER?3?5?$CFs?6@ DB 'GL_RENDERER: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FAFHGBCB@GL_VENDOR?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@FAFHGBCB@GL_VENDOR?3?5?$CFs?6@ DB 'GL_VENDOR: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KNOAIAMH@OpenGL?5Internal?5ProcAddress@
CONST	SEGMENT
??_C@_0BM@KNOAIAMH@OpenGL?5Internal?5ProcAddress@ DB 'OpenGL Internal Pro'
	DB	'cAddress', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IGHGDPNJ@Can?8t?5re?9initialize?5video?5subsy@
CONST	SEGMENT
??_C@_0CF@IGHGDPNJ@Can?8t?5re?9initialize?5video?5subsy@ DB 'Can''t re-in'
	DB	'itialize video subsystem', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OLPHDNFE@?$FO1Error?3?$FO7?5VID_SetMode?3?5could?5n@
CONST	SEGMENT
??_C@_0DH@OLPHDNFE@?$FO1Error?3?$FO7?5VID_SetMode?3?5could?5n@ DB '^1Erro'
	DB	'r:^7 VID_SetMode: could not revert to safe mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IONHNGJE@?$FO1Error?3?$FO7?5VID_SetMode?3?5invalid@
CONST	SEGMENT
??_C@_0CG@IONHNGJE@?$FO1Error?3?$FO7?5VID_SetMode?3?5invalid@ DB '^1Error'
	DB	':^7 VID_SetMode: invalid mode', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NDNLGOKO@?$FO1Error?3?$FO7?5VID_SetMode?3?5fullscr@
CONST	SEGMENT
??_C@_0DN@NDNLGOKO@?$FO1Error?3?$FO7?5VID_SetMode?3?5fullscr@ DB '^1Error'
	DB	':^7 VID_SetMode: fullscreen unavailable in this mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BDDCKCLM@failed?5to?5set?5specified?5vid?5mod@
CONST	SEGMENT
??_C@_0CK@BDDCKCLM@failed?5to?5set?5specified?5vid?5mod@ DB 'failed to se'
	DB	't specified vid mode [%ix%i]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GIACNHMO@fullscreen@
CONST	SEGMENT
??_C@_0L@GIACNHMO@fullscreen@ DB 'fullscreen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JIIPBDNP@found?5specified?5vid?5mode?5?$CFi?5?$FL?$CFi@
CONST	SEGMENT
??_C@_0CF@JIIPBDNP@found?5specified?5vid?5mode?5?$CFi?5?$FL?$CFi@ DB 'fou'
	DB	'nd specified vid mode %i [%ix%i]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MCKMDEPJ@?$FO1Error?3?$FO7?5VID_SetMode?3?5display@
CONST	SEGMENT
??_C@_0EC@MCKMDEPJ@?$FO1Error?3?$FO7?5VID_SetMode?3?5display@ DB '^1Error'
	DB	':^7 VID_SetMode: display frequency %i Hz is not supported', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJFOCBHB@vid_displayfrequency@
CONST	SEGMENT
??_C@_0BF@FJFOCBHB@vid_displayfrequency@ DB 'vid_displayfrequency', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MKGEEDEG@?$FO1Error?3?$FO7?5OpenGL?5driver?5not?5in@
CONST	SEGMENT
??_C@_0CI@MKGEEDEG@?$FO1Error?3?$FO7?5OpenGL?5driver?5not?5in@ DB '^1Erro'
	DB	'r:^7 OpenGL driver not installed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OAMDGGDJ@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@
CONST	SEGMENT
??_C@_0DD@OAMDGGDJ@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@ DB '^1Error'
	DB	':^7 VID_CreateWindow: couldn''t create ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EBFFCONK@?$FO3Warning?3?$FO7?5VID_CreateWindow?3?5@
CONST	SEGMENT
??_C@_0DC@EBFFCONK@?$FO3Warning?3?$FO7?5VID_CreateWindow?3?5@ DB '^3Warni'
	DB	'ng:^7 VID_CreateWindow: bad hWnd for ''%s''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@BICFBIKB@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@
CONST	SEGMENT
??_C@_0EN@BICFBIKB@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@ DB '^1Error'
	DB	':^7 VID_CreateWindow: couldn''t register window class %s', 0aH
	DB	'Xash3D Window', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PBKBDAIE@Extract?5?$CFs?5from?5pak?5if?5you?5want@
CONST	SEGMENT
??_C@_0CM@PBKBDAIE@Extract?5?$CFs?5from?5pak?5if?5you?5want@ DB 'Extract '
	DB	'%s from pak if you want to see it.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBEGDOKI@Xash3D?5Window@
CONST	SEGMENT
??_C@_0O@NBEGDOKI@Xash3D?5Window@ DB 'Xash3D Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HIMCMJIL@Set?3?5?$CFs?5?$FL?$CFdx?$CFd?$FN?6@
CONST	SEGMENT
??_C@_0BB@HIMCMJIL@Set?3?5?$CFs?5?$FL?$CFdx?$CFd?$FN?6@ DB 'Set: %s [%dx%'
	DB	'd]', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ICHJJAPN@vid_mode@
CONST	SEGMENT
??_C@_08ICHJJAPN@vid_mode@ DB 'vid_mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNLHEAAG@height@
CONST	SEGMENT
??_C@_06LNLHEAAG@height@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGKADHGO@width@
CONST	SEGMENT
??_C@_05IGKADHGO@width@ DB 'width', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@HDFHNDFK@PixelFormat?3?5color?3?5?$CFd?9bit?0?5Z?9B@
CONST	SEGMENT
??_C@_0DP@HDFHNDFK@PixelFormat?3?5color?3?5?$CFd?9bit?0?5Z?9B@ DB 'PixelF'
	DB	'ormat: color: %d-bit, Z-Buffer: %d-bit, stencil: %d-bit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NFLBAACE@VID_ChoosePFD?3?5using?5hardware?5a@
CONST	SEGMENT
??_C@_0CM@NFLBAACE@VID_ChoosePFD?3?5using?5hardware?5a@ DB 'VID_ChoosePFD'
	DB	': using hardware acceleration', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@DKAPEENC@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5n@
CONST	SEGMENT
??_C@_0DO@DKAPEENC@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5n@ DB '^1Error'
	DB	':^7 GL_SetPixelformat: no hardware acceleration found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KMOPKOFH@VID_ChoosePFD?3?5using?5Generic?5MC@
CONST	SEGMENT
??_C@_0CP@KMOPKOFH@VID_ChoosePFD?3?5using?5Generic?5MC@ DB 'VID_ChoosePFD'
	DB	': using Generic MCD acceleration', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BOCCJDEP@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@
CONST	SEGMENT
??_C@_0CG@BOCCJDEP@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@ DB '^1Error'
	DB	':^7 GL_SetPixelformat: failed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NLKFPFAK@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@
CONST	SEGMENT
??_C@_0EJ@NLKFPFAK@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@ DB '^1Error'
	DB	':^7 GL_SetPixelformat: failed to find an appropriate PIXELFOR'
	DB	'MAT', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPMGGILH@wglChoosePixelFormatARB@
CONST	SEGMENT
??_C@_0BI@JPMGGILH@wglChoosePixelFormatARB@ DB 'wglChoosePixelFormatARB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GDKHKIAN@wglGetPixelFormatAttribivARB@
CONST	SEGMENT
??_C@_0BN@GDKHKIAN@wglGetPixelFormatAttribivARB@ DB 'wglGetPixelFormatAtt'
	DB	'ribivARB', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDNJMPJF@Xash3D@
CONST	SEGMENT
??_C@_06EDNJMPJF@Xash3D@ DB 'Xash3D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCNPAMAE@TestWindow@
CONST	SEGMENT
??_C@_0L@PCNPAMAE@TestWindow@ DB 'TestWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KPMKNLJO@VID_StartupGamma?3?5gamma?5?$CFg?5brig@
CONST	SEGMENT
??_C@_0CK@KPMKNLJO@VID_StartupGamma?3?5gamma?5?$CFg?5brig@ DB 'VID_Startu'
	DB	'pGamma: gamma %g brightness %g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JALKLIBM@?$FO3Warning?3?$FO7?5MSAA?5is?5not?5allowe@
CONST	SEGMENT
??_C@_0CC@JALKLIBM@?$FO3Warning?3?$FO7?5MSAA?5is?5not?5allowe@ DB '^3Warn'
	DB	'ing:^7 MSAA is not allowed', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GLCIJGDL@GL_CreateContext?3?5using?5extende@
CONST	SEGMENT
??_C@_0CK@GLCIJGDL@GL_CreateContext?3?5using?5extende@ DB 'GL_CreateConte'
	DB	'xt: using extended context', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PDDHMPGF@wglCreateContextAttribsARB@
CONST	SEGMENT
??_C@_0BL@PDDHMPGF@wglCreateContextAttribsARB@ DB 'wglCreateContextAttrib'
	DB	'sARB', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OJIHOIAO@?$FO1Error?3?$FO7?5Unknown?5error?5creati@
CONST	SEGMENT
??_C@_0DL@OJIHOIAO@?$FO1Error?3?$FO7?5Unknown?5error?5creati@ DB '^1Error'
	DB	':^7 Unknown error creating an OpenGL (%s) Context.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@INJOCFND@?$FO1Error?3?$FO7?5wglCreateContextAttr@
CONST	SEGMENT
??_C@_0ED@INJOCFND@?$FO1Error?3?$FO7?5wglCreateContextAttr@ DB '^1Error:^'
	DB	'7 wglCreateContextAttribsARB reported invalid parameter.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JKMNHAKF@?$FO1Error?3?$FO7?5wglCreateContextAttr@
CONST	SEGMENT
??_C@_0EE@JKMNHAKF@?$FO1Error?3?$FO7?5wglCreateContextAttr@ DB '^1Error:^'
	DB	'7 wglCreateContextAttribsARB ran out of system resources.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JHBJBKGE@?$FO1Error?3?$FO7?5wglCreateContextAttr@
CONST	SEGMENT
??_C@_0DO@JHBJBKGE@?$FO1Error?3?$FO7?5wglCreateContextAttr@ DB '^1Error:^'
	DB	'7 wglCreateContextAttribsARB returned dc not found.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@EKEJBCOE@?$FO1Error?3?$FO7?5wglCreateContextAttr@
CONST	SEGMENT
??_C@_0ED@EKEJBCOE@?$FO1Error?3?$FO7?5wglCreateContextAttr@ DB '^1Error:^'
	DB	'7 wglCreateContextAttribsARB returned invalid operation.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NLIAMNMI@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5p@
CONST	SEGMENT
??_C@_0CN@NLIAMNMI@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5p@ DB '^1Error'
	DB	':^7 Unsupported OpenGL profile (%s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CJLEMFPD@compat@
CONST	SEGMENT
??_C@_06CJLEMFPD@compat@ DB 'compat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KEPFMKAK@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5c@
CONST	SEGMENT
??_C@_0DF@KEPFMKAK@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5c@ DB '^1Error'
	DB	':^7 Unsupported OpenGL context version (%s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJAMENNA@2?40@
CONST	SEGMENT
??_C@_03GJAMENNA@2?40@ DB '2.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NHGONMLE@?9gldebug@
CONST	SEGMENT
??_C@_08NHGONMLE@?9gldebug@ DB '-gldebug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEFGEEA@?9?5?$FO2enabled?6@
CONST	SEGMENT
??_C@_0N@EEFGEEA@?9?5?$FO2enabled?6@ DB '- ^2enabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OLAKKIMP@?9?5?$FO1failed?6@
CONST	SEGMENT
??_C@_0M@OLAKKIMP@?9?5?$FO1failed?6@ DB '- ^1failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMNJGNM@?9?5disabled?6@
CONST	SEGMENT
??_C@_0M@DMNJGNM@?9?5disabled?6@ DB '- disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@
CONST	SEGMENT
??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@ DB 'enable or disable %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNGPIHKB@GL_CheckExtension?3?5?$CFs?5@
CONST	SEGMENT
??_C@_0BH@HNGPIHKB@GL_CheckExtension?3?5?$CFs?5@ DB 'GL_CheckExtension: %'
	DB	's ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IPEPFJPO@?$FO1Error?3?$FO7?5GL_Support?3?5invalid?5@
CONST	SEGMENT
??_C@_0CN@IPEPFJPO@?$FO1Error?3?$FO7?5GL_Support?3?5invalid?5@ DB '^1Erro'
	DB	'r:^7 GL_Support: invalid extension %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DFBHKDFL@?$FO1Error?3?$FO7?5GL_SetExtension?3?5inv@
CONST	SEGMENT
??_C@_0DC@DFBHKDFL@?$FO1Error?3?$FO7?5GL_SetExtension?3?5inv@ DB '^1Error'
	DB	':^7 GL_SetExtension: invalid extension %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EFLPNAON@?$FO2OpenGL?5Note?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0BF@EFLPNAON@?$FO2OpenGL?5Note?3?$FO7?5?$CFs?6@ DB '^2OpenGL Note:^'
	DB	'7 %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@ DB '^3OpenGL War'
	DB	'ning:^7 %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HNJCPLKA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?6@
CONST	SEGMENT
??_C@_0BG@HNJCPLKA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?6@ DB '^3OpenGL Error'
	DB	':^7 %s', 0aH, 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_opengl_110funcs DD FLAT:??_C@_0N@OGLMDNKC@glClearColor@
	DD	FLAT:_pglClearColor
	DD	FLAT:??_C@_07IBAPPAHJ@glClear@
	DD	FLAT:_pglClear
	DD	FLAT:??_C@_0M@BJGLMKCC@glAlphaFunc@
	DD	FLAT:_pglAlphaFunc
	DD	FLAT:??_C@_0M@PFBKOKOH@glBlendFunc@
	DD	FLAT:_pglBlendFunc
	DD	FLAT:??_C@_0L@BAPBLHME@glCullFace@
	DD	FLAT:_pglCullFace
	DD	FLAT:??_C@_0N@EKCLGPL@glDrawBuffer@
	DD	FLAT:_pglDrawBuffer
	DD	FLAT:??_C@_0N@HFKHBECK@glReadBuffer@
	DD	FLAT:_pglReadBuffer
	DD	FLAT:??_C@_07LNIJJMEN@glAccum@
	DD	FLAT:_pglAccum
	DD	FLAT:??_C@_08OOEHEKOP@glEnable@
	DD	FLAT:_pglEnable
	DD	FLAT:??_C@_09MHGMIMKN@glDisable@
	DD	FLAT:_pglDisable
	DD	FLAT:??_C@_0BE@KECPKGNE@glEnableClientState@
	DD	FLAT:_pglEnableClientState
	DD	FLAT:??_C@_0BF@LJDHBNBP@glDisableClientState@
	DD	FLAT:_pglDisableClientState
	DD	FLAT:??_C@_0O@NLMELLCJ@glGetBooleanv@
	DD	FLAT:_pglGetBooleanv
	DD	FLAT:??_C@_0N@OFBMMCDH@glGetDoublev@
	DD	FLAT:_pglGetDoublev
	DD	FLAT:??_C@_0M@CKCOBONE@glGetFloatv@
	DD	FLAT:_pglGetFloatv
	DD	FLAT:??_C@_0O@DHHDCCLF@glGetIntegerv@
	DD	FLAT:_pglGetIntegerv
	DD	FLAT:??_C@_0L@FPKAMKHB@glGetError@
	DD	FLAT:_pglGetError
	DD	FLAT:??_C@_0M@OPOBFDCB@glGetString@
	DD	FLAT:_pglGetString
	DD	FLAT:??_C@_08DFCPOKBK@glFinish@
	DD	FLAT:_pglFinish
	DD	FLAT:??_C@_07COFELLJA@glFlush@
	DD	FLAT:_pglFlush
	DD	FLAT:??_C@_0N@LJIELNG@glClearDepth@
	DD	FLAT:_pglClearDepth
	DD	FLAT:??_C@_0M@NEJABAEP@glDepthFunc@
	DD	FLAT:_pglDepthFunc
	DD	FLAT:??_C@_0M@KABMFLLN@glDepthMask@
	DD	FLAT:_pglDepthMask
	DD	FLAT:??_C@_0N@PEBDIKOA@glDepthRange@
	DD	FLAT:_pglDepthRange
	DD	FLAT:??_C@_0M@ILBMDJDA@glFrontFace@
	DD	FLAT:_pglFrontFace
	DD	FLAT:??_C@_0P@MENFIFGE@glDrawElements@
	DD	FLAT:_pglDrawElements
	DD	FLAT:??_C@_0N@CMNPPOHA@glDrawArrays@
	DD	FLAT:_pglDrawArrays
	DD	FLAT:??_C@_0M@DLGOAHPH@glColorMask@
	DD	FLAT:_pglColorMask
	DD	FLAT:??_C@_0P@KGJBLKPD@glIndexPointer@
	DD	FLAT:_pglIndexPointer
	DD	FLAT:??_C@_0BA@HAHECJNK@glVertexPointer@
	DD	FLAT:_pglVertexPointer
	DD	FLAT:??_C@_0BA@DCLMCEOP@glNormalPointer@
	DD	FLAT:_pglNormalPointer
	DD	FLAT:??_C@_0P@DPKEGLKI@glColorPointer@
	DD	FLAT:_pglColorPointer
	DD	FLAT:??_C@_0BC@DAOMILMO@glTexCoordPointer@
	DD	FLAT:_pglTexCoordPointer
	DD	FLAT:??_C@_0P@CKCIJELG@glArrayElement@
	DD	FLAT:_pglArrayElement
	DD	FLAT:??_C@_09PPBNNDHA@glColor3f@
	DD	FLAT:_pglColor3f
	DD	FLAT:??_C@_0L@CJJPLCJP@glColor3fv@
	DD	FLAT:_pglColor3fv
	DD	FLAT:??_C@_09PKFCMFPF@glColor4f@
	DD	FLAT:_pglColor4f
	DD	FLAT:??_C@_0L@LEEIIKCG@glColor4fv@
	DD	FLAT:_pglColor4fv
	DD	FLAT:??_C@_0L@BJFBHIOD@glColor3ub@
	DD	FLAT:_pglColor3ub
	DD	FLAT:??_C@_0L@IEIGEAFK@glColor4ub@
	DD	FLAT:_pglColor4ub
	DD	FLAT:??_C@_0M@PCFPOANK@glColor4ubv@
	DD	FLAT:_pglColor4ubv
	DD	FLAT:??_C@_0N@BIJHJAFN@glTexCoord1f@
	DD	FLAT:_pglTexCoord1f
	DD	FLAT:??_C@_0N@BKNBCOAE@glTexCoord2f@
	DD	FLAT:_pglTexCoord2f
	DD	FLAT:??_C@_0N@BLBDEEDD@glTexCoord3f@
	DD	FLAT:_pglTexCoord3f
	DD	FLAT:??_C@_0N@BOFMFCLG@glTexCoord4f@
	DD	FLAT:_pglTexCoord4f
	DD	FLAT:??_C@_0O@GMKHGEKJ@glTexCoord1fv@
	DD	FLAT:_pglTexCoord1fv
	DD	FLAT:??_C@_0O@HOBCMLEH@glTexCoord2fv@
	DD	FLAT:_pglTexCoord2fv
	DD	FLAT:??_C@_0O@MGKOKMCC@glTexCoord3fv@
	DD	FLAT:_pglTexCoord3fv
	DD	FLAT:??_C@_0O@FLHJJEJL@glTexCoord4fv@
	DD	FLAT:_pglTexCoord4fv
	DD	FLAT:??_C@_09ONEPECIB@glTexGenf@
	DD	FLAT:_pglTexGenf
	DD	FLAT:??_C@_0L@ODDHCCIE@glTexGenfv@
	DD	FLAT:_pglTexGenfv
	DD	FLAT:??_C@_09GKNHFOEO@glTexGeni@
	DD	FLAT:_pglTexGeni
	DD	FLAT:??_C@_0L@LPFKLMDB@glVertex2f@
	DD	FLAT:_pglVertex2f
	DD	FLAT:??_C@_0L@LOJINGAG@glVertex3f@
	DD	FLAT:_pglVertex3f
	DD	FLAT:??_C@_0M@JALIODJD@glVertex3fv@
	DD	FLAT:_pglVertex3fv
	DD	FLAT:??_C@_0L@DGGCBPPM@glNormal3f@
	DD	FLAT:_pglNormal3f
	DD	FLAT:??_C@_0M@MNFIACFI@glNormal3fv@
	DD	FLAT:_pglNormal3fv
	DD	FLAT:??_C@_07FCOIFMD@glBegin@
	DD	FLAT:_pglBegin
	DD	FLAT:??_C@_05OIBMBLHE@glEnd@
	DD	FLAT:_pglEnd
	DD	FLAT:??_C@_0M@CFLGNFPG@glLineWidth@
	DD	FLAT:_pglLineWidth
	DD	FLAT:??_C@_0M@EEAPMMNM@glPointSize@
	DD	FLAT:_pglPointSize
	DD	FLAT:??_C@_0N@KDLNHKEJ@glMatrixMode@
	DD	FLAT:_pglMatrixMode
	DD	FLAT:??_C@_07DBAFHOII@glOrtho@
	DD	FLAT:_pglOrtho
	DD	FLAT:??_C@_0O@DLOEJEEG@glRasterPos2f@
	DD	FLAT:_pglRasterPos2f
	DD	FLAT:??_C@_09ICLFHOKP@glFrustum@
	DD	FLAT:_pglFrustum
	DD	FLAT:??_C@_0L@KBLIPDFH@glViewport@
	DD	FLAT:_pglViewport
	DD	FLAT:??_C@_0N@IHFNHGBL@glPushMatrix@
	DD	FLAT:_pglPushMatrix
	DD	FLAT:??_C@_0M@JPEAAEEK@glPopMatrix@
	DD	FLAT:_pglPopMatrix
	DD	FLAT:??_C@_0N@KDMLHFJM@glPushAttrib@
	DD	FLAT:_pglPushAttrib
	DD	FLAT:??_C@_0M@LLNGAHMN@glPopAttrib@
	DD	FLAT:_pglPopAttrib
	DD	FLAT:??_C@_0P@EJAFHEPO@glLoadIdentity@
	DD	FLAT:_pglLoadIdentity
	DD	FLAT:??_C@_0O@LFHKEMK@glLoadMatrixd@
	DD	FLAT:_pglLoadMatrixd
	DD	FLAT:??_C@_0O@DJGBMGEI@glLoadMatrixf@
	DD	FLAT:_pglLoadMatrixf
	DD	FLAT:??_C@_0O@IFJFLNCL@glMultMatrixd@
	DD	FLAT:_pglMultMatrixd
	DD	FLAT:??_C@_0O@LHKDNPKJ@glMultMatrixf@
	DD	FLAT:_pglMultMatrixf
	DD	FLAT:??_C@_09GANFLDAO@glRotated@
	DD	FLAT:_pglRotated
	DD	FLAT:??_C@_09FCODNBIM@glRotatef@
	DD	FLAT:_pglRotatef
	DD	FLAT:??_C@_08KAMCINDI@glScaled@
	DD	FLAT:_pglScaled
	DD	FLAT:??_C@_08JCPEOPLK@glScalef@
	DD	FLAT:_pglScalef
	DD	FLAT:??_C@_0N@LHMFFDFG@glTranslated@
	DD	FLAT:_pglTranslated
	DD	FLAT:??_C@_0N@IFPDDBNE@glTranslatef@
	DD	FLAT:_pglTranslatef
	DD	FLAT:??_C@_0N@CKFNNHOO@glReadPixels@
	DD	FLAT:_pglReadPixels
	DD	FLAT:??_C@_0N@FLFIHFDP@glDrawPixels@
	DD	FLAT:_pglDrawPixels
	DD	FLAT:??_C@_0O@ENNLLOLN@glStencilFunc@
	DD	FLAT:_pglStencilFunc
	DD	FLAT:??_C@_0O@DJFHPFEP@glStencilMask@
	DD	FLAT:_pglStencilMask
	DD	FLAT:??_C@_0M@BILBNGF@glStencilOp@
	DD	FLAT:_pglStencilOp
	DD	FLAT:??_C@_0P@KBLPBBFP@glClearStencil@
	DD	FLAT:_pglClearStencil
	DD	FLAT:??_C@_0M@INHMIHKC@glIsEnabled@
	DD	FLAT:_pglIsEnabled
	DD	FLAT:??_C@_08DMFMJKDH@glIsList@
	DD	FLAT:_pglIsList
	DD	FLAT:??_C@_0M@NJHAEPDN@glIsTexture@
	DD	FLAT:_pglIsTexture
	DD	FLAT:??_C@_09FCLLGECI@glTexEnvf@
	DD	FLAT:_pglTexEnvf
	DD	FLAT:??_C@_0L@EMICMNOO@glTexEnvfv@
	DD	FLAT:_pglTexEnvfv
	DD	FLAT:??_C@_09NFCDHIOH@glTexEnvi@
	DD	FLAT:_pglTexEnvi
	DD	FLAT:??_C@_0BA@INKFIMGP@glTexParameterf@
	DD	FLAT:_pglTexParameterf
	DD	FLAT:??_C@_0BB@KEOFAHDF@glTexParameterfv@
	DD	FLAT:_pglTexParameterfv
	DD	FLAT:??_C@_0BA@KDNJAKA@glTexParameteri@
	DD	FLAT:_pglTexParameteri
	DD	FLAT:??_C@_06HEADGMBC@glHint@
	DD	FLAT:_pglHint
	DD	FLAT:??_C@_0O@BFLAHHCK@glPixelStoref@
	DD	FLAT:_pglPixelStoref
	DD	FLAT:??_C@_0O@JCCIGLOF@glPixelStorei@
	DD	FLAT:_pglPixelStorei
	DD	FLAT:??_C@_0O@LLMANLNK@glGenTextures@
	DD	FLAT:_pglGenTextures
	DD	FLAT:??_C@_0BB@KMPLFJIC@glDeleteTextures@
	DD	FLAT:_pglDeleteTextures
	DD	FLAT:??_C@_0O@JKKCIBGC@glBindTexture@
	DD	FLAT:_pglBindTexture
	DD	FLAT:??_C@_0N@JDMMMFHL@glTexImage1D@
	DD	FLAT:_pglTexImage1D
	DD	FLAT:??_C@_0N@JBIKHLCC@glTexImage2D@
	DD	FLAT:_pglTexImage2D
	DD	FLAT:??_C@_0BA@NFOOCKJD@glTexSubImage1D@
	DD	FLAT:_pglTexSubImage1D
	DD	FLAT:??_C@_0BA@NHKIJEMK@glTexSubImage2D@
	DD	FLAT:_pglTexSubImage2D
	DD	FLAT:??_C@_0BB@MEEDBHPL@glCopyTexImage1D@
	DD	FLAT:_pglCopyTexImage1D
	DD	FLAT:??_C@_0BB@MGAFKJKC@glCopyTexImage2D@
	DD	FLAT:_pglCopyTexImage2D
	DD	FLAT:??_C@_0BE@PKNCAIGI@glCopyTexSubImage1D@
	DD	FLAT:_pglCopyTexSubImage1D
	DD	FLAT:??_C@_0BE@PIJELGDB@glCopyTexSubImage2D@
	DD	FLAT:_pglCopyTexSubImage2D
	DD	FLAT:??_C@_09ECGPAEPL@glScissor@
	DD	FLAT:_pglScissor
	DD	FLAT:??_C@_0O@DOIIJLAD@glGetTexImage@
	DD	FLAT:_pglGetTexImage
	DD	FLAT:??_C@_0O@KIFFCCBG@glGetTexEnviv@
	DD	FLAT:_pglGetTexEnviv
	DD	FLAT:??_C@_0BA@FFBJGNC@glPolygonOffset@
	DD	FLAT:_pglPolygonOffset
	DD	FLAT:??_C@_0O@DKMNBFMB@glPolygonMode@
	DD	FLAT:_pglPolygonMode
	DD	FLAT:??_C@_0BB@GIADEJGP@glPolygonStipple@
	DD	FLAT:_pglPolygonStipple
	DD	FLAT:??_C@_0M@OHCNGGFF@glClipPlane@
	DD	FLAT:_pglClipPlane
	DD	FLAT:??_C@_0P@MMMNLMC@glGetClipPlane@
	DD	FLAT:_pglGetClipPlane
	DD	FLAT:??_C@_0N@NALMFHKN@glShadeModel@
	DD	FLAT:_pglShadeModel
	DD	FLAT:??_C@_0BJ@GLJHCPGI@glGetTexLevelParameteriv@
	DD	FLAT:_pglGetTexLevelParameteriv
	DD	FLAT:??_C@_0BJ@GAMLGIFF@glGetTexLevelParameterfv@
	DD	FLAT:_pglGetTexLevelParameterfv
	DD	FLAT:??_C@_07FNEIAABA@glFogfv@
	DD	FLAT:_pglFogfv
	DD	FLAT:??_C@_06JJHNMGPD@glFogf@
	DD	FLAT:_pglFogf
	DD	FLAT:??_C@_06BOOFNKDM@glFogi@
	DD	FLAT:_pglFogi
	DD	00H
	DD	00H
_debugoutputfuncs DD FLAT:??_C@_0BJ@IAEPICEJ@glDebugMessageControlARB@
	DD	FLAT:_pglDebugMessageControlARB
	DD	FLAT:??_C@_0BI@IFLDELCL@glDebugMessageInsertARB@
	DD	FLAT:_pglDebugMessageInsertARB
	DD	FLAT:??_C@_0BK@IEHNBEGE@glDebugMessageCallbackARB@
	DD	FLAT:_pglDebugMessageCallbackARB
	DD	FLAT:??_C@_0BI@JOLPFNOB@glGetDebugMessageLogARB@
	DD	FLAT:_pglGetDebugMessageLogARB
	DD	00H
	DD	00H
_multitexturefuncs DD FLAT:??_C@_0BF@ODPGPGFO@glMultiTexCoord1fARB@
	DD	FLAT:_pglMultiTexCoord1f
	DD	FLAT:??_C@_0BF@GFGCIEPA@glMultiTexCoord2fARB@
	DD	FLAT:_pglMultiTexCoord2f
	DD	FLAT:??_C@_0BF@KODOFHFF@glMultiTexCoord3fARB@
	DD	FLAT:_pglMultiTexCoord3f
	DD	FLAT:??_C@_0BF@LDDLGHON@glMultiTexCoord4fARB@
	DD	FLAT:_pglMultiTexCoord4f
	DD	FLAT:??_C@_0BD@IKCKKKNH@glActiveTextureARB@
	DD	FLAT:_pglActiveTexture
	DD	FLAT:??_C@_0BD@IKCKKKNH@glActiveTextureARB@
	DD	FLAT:_pglActiveTextureARB
	DD	FLAT:??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB@
	DD	FLAT:_pglClientActiveTexture
	DD	FLAT:??_C@_0BJ@PBJNGLJH@glClientActiveTextureARB@
	DD	FLAT:_pglClientActiveTextureARB
	DD	00H
	DD	00H
_texture3dextfuncs DD FLAT:??_C@_0BA@CBIBMEOO@glTexImage3DEXT@
	DD	FLAT:_pglTexImage3D
	DD	FLAT:??_C@_0BD@IKPGOLHH@glTexSubImage3DEXT@
	DD	FLAT:_pglTexSubImage3D
	DD	FLAT:??_C@_0BH@LLLKENMO@glCopyTexSubImage3DEXT@
	DD	FLAT:_pglCopyTexSubImage3D
	DD	00H
	DD	00H
_texturecompressionfuncs DD FLAT:??_C@_0BK@CIBKLOLF@glCompressedTexImage3DARB@
	DD	FLAT:_pglCompressedTexImage3DARB
	DD	FLAT:??_C@_0BK@ODEGGNBA@glCompressedTexImage2DARB@
	DD	FLAT:_pglCompressedTexImage2DARB
	DD	FLAT:??_C@_0BK@GFNCBPLO@glCompressedTexImage1DARB@
	DD	FLAT:_pglCompressedTexImage1DARB
	DD	FLAT:??_C@_0BN@HMALDDJO@glCompressedTexSubImage3DARB@
	DD	FLAT:_pglCompressedTexSubImage3DARB
	DD	FLAT:??_C@_0BN@LHFHOADL@glCompressedTexSubImage2DARB@
	DD	FLAT:_pglCompressedTexSubImage2DARB
	DD	FLAT:??_C@_0BN@DBMDJCJF@glCompressedTexSubImage1DARB@
	DD	FLAT:_pglCompressedTexSubImage1DARB
	DD	FLAT:??_C@_0BL@CKKCLKDF@glGetCompressedTexImageARB@
	DD	FLAT:_pglGetCompressedTexImage
	DD	00H
	DD	00H
_wglproc_funcs DD FLAT:??_C@_0BC@FFKMKEGM@wglGetProcAddress@
	DD	FLAT:_pwglGetProcAddress
	DD	00H
	DD	00H
_wglswapintervalfuncs DD FLAT:??_C@_0BD@IINOPBDD@wglSwapIntervalEXT@
	DD	FLAT:_pwglSwapIntervalEXT
	DD	00H
	DD	00H
_wglgetextensionsstring DD FLAT:??_C@_0BK@HGDBIG@wglGetExtensionsStringEXT@
	DD	FLAT:_pwglGetExtensionsStringEXT
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	038cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	036bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01beH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0218H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0350H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0199H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_InitExtensions
_TEXT	SEGMENT
tv421 = -72						; size = 4
tv420 = -68						; size = 4
tv146 = -68						; size = 4
_GL_InitExtensions PROC					; COMDAT

; 1673 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1674 : 	// initialize gl extensions
; 1675 : 	GL_CheckExtension( "OpenGL 1.1.0", opengl_110funcs, NULL, GL_OPENGL_110 );

	push	0
	push	0
	push	OFFSET _opengl_110funcs
	push	OFFSET ??_C@_0N@LPDIHFOO@OpenGL?51?41?40@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1676 : 
; 1677 : 	// get our various GL strings
; 1678 : 	glConfig.vendor_string = pglGetString( GL_VENDOR );

	push	7936					; 00001f00H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+4, eax

; 1679 : 	glConfig.renderer_string = pglGetString( GL_RENDERER );

	push	7937					; 00001f01H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig, eax

; 1680 : 	glConfig.version_string = pglGetString( GL_VERSION );

	push	7938					; 00001f02H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+8, eax

; 1681 : 	glConfig.extensions_string = pglGetString( GL_EXTENSIONS );

	push	7939					; 00001f03H
	call	DWORD PTR _pglGetString
	mov	DWORD PTR _glConfig+16, eax

; 1682 : 	Con_Printf( "^3Video:^7 %s\n", glConfig.renderer_string );

	mov	eax, DWORD PTR _glConfig
	push	eax
	push	OFFSET ??_C@_0P@FABBBPDP@?$FO3Video?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1683 : 
; 1684 : 	// intialize wrapper type
; 1685 : 	glConfig.context = CONTEXT_TYPE_GL;

	mov	DWORD PTR _glConfig+116, 0

; 1686 : 	glConfig.wrapper = GLES_WRAPPER_NONE;

	mov	DWORD PTR _glConfig+120, 0

; 1687 : 
; 1688 : 	if( Q_stristr( glConfig.renderer_string, "geforce" ))

	push	OFFSET ??_C@_07MPJPGECB@geforce@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@GL_InitExt

; 1689 : 		glConfig.hardware_type = GLHW_NVIDIA;

	mov	DWORD PTR _glConfig+12, 2
	jmp	$LN16@GL_InitExt
$LN2@GL_InitExt:

; 1690 : 	else if( Q_stristr( glConfig.renderer_string, "quadro fx" ))

	push	OFFSET ??_C@_09IKHEJAGC@quadro?5fx@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@GL_InitExt

; 1691 : 		glConfig.hardware_type = GLHW_NVIDIA;

	mov	DWORD PTR _glConfig+12, 2
	jmp	$LN16@GL_InitExt
$LN4@GL_InitExt:

; 1692 : 	else if( Q_stristr(glConfig.renderer_string, "rv770" ))

	push	OFFSET ??_C@_05ONNLOCAH@rv770@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@GL_InitExt

; 1693 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	$LN16@GL_InitExt
$LN6@GL_InitExt:

; 1694 : 	else if( Q_stristr(glConfig.renderer_string, "radeon hd" ))

	push	OFFSET ??_C@_09BADJHFGO@radeon?5hd@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@GL_InitExt

; 1695 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	$LN16@GL_InitExt
$LN8@GL_InitExt:

; 1696 : 	else if( Q_stristr( glConfig.renderer_string, "eah4850" ) || Q_stristr( glConfig.renderer_string, "eah4870" ))

	push	OFFSET ??_C@_07FHGIJLKP@eah4850@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@GL_InitExt
	push	OFFSET ??_C@_07FEOMEPMB@eah4870@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@GL_InitExt
$LN12@GL_InitExt:

; 1697 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	SHORT $LN16@GL_InitExt
$LN10@GL_InitExt:

; 1698 : 	else if( Q_stristr( glConfig.renderer_string, "radeon" ))

	push	OFFSET ??_C@_06CHDCBPE@radeon@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@GL_InitExt

; 1699 : 		glConfig.hardware_type = GLHW_RADEON;

	mov	DWORD PTR _glConfig+12, 1
	jmp	SHORT $LN16@GL_InitExt
$LN13@GL_InitExt:

; 1700 : 	else if( Q_stristr( glConfig.renderer_string, "intel" ))

	push	OFFSET ??_C@_05CEMNNDEJ@intel@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@GL_InitExt

; 1701 : 		glConfig.hardware_type = GLHW_INTEL;

	mov	DWORD PTR _glConfig+12, 3
	jmp	SHORT $LN16@GL_InitExt
$LN15@GL_InitExt:

; 1702 : 	else glConfig.hardware_type = GLHW_GENERIC;

	mov	DWORD PTR _glConfig+12, 0
$LN16@GL_InitExt:

; 1703 : 
; 1704 : 	// initalize until base opengl functions loaded (old-context)
; 1705 : 	if( !context_flags && !CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN17@GL_InitExt
	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN40@GL_InitExt
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN40@GL_InitExt
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN41@GL_InitExt
$LN40@GL_InitExt:
	mov	DWORD PTR tv146[ebp], 0
$LN41@GL_InitExt:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN17@GL_InitExt

; 1706 : 		GL_CheckExtension( "OpenGL Internal ProcAddress", wglproc_funcs, NULL, GL_WGL_PROCADDRESS );

	push	3
	push	0
	push	OFFSET _wglproc_funcs
	push	OFFSET ??_C@_0BM@KNOAIAMH@OpenGL?5Internal?5ProcAddress@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN17@GL_InitExt:

; 1707 : 
; 1708 : 	// windows-specific extensions
; 1709 : 	GL_CheckExtension( "WGL Extensions String", wglgetextensionsstring, NULL, GL_WGL_EXTENSIONS );

	push	1
	push	0
	push	OFFSET _wglgetextensionsstring
	push	OFFSET ??_C@_0BG@EMFJFGJF@WGL?5Extensions?5String@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1710 : 
; 1711 : 	if( pwglGetExtensionsStringEXT != NULL )

	cmp	DWORD PTR _pwglGetExtensionsStringEXT, 0
	je	SHORT $LN18@GL_InitExt

; 1712 : 		glConfig.wgl_extensions_string = pwglGetExtensionsStringEXT();

	call	DWORD PTR _pwglGetExtensionsStringEXT
	mov	DWORD PTR _glConfig+20, eax
	jmp	SHORT $LN19@GL_InitExt
$LN18@GL_InitExt:

; 1713 : 	else glConfig.wgl_extensions_string = NULL;

	mov	DWORD PTR _glConfig+20, 0
$LN19@GL_InitExt:

; 1714 : 
; 1715 : 	// initalize until base opengl functions loaded
; 1716 : 	GL_CheckExtension( "WGL_EXT_swap_control", wglswapintervalfuncs, NULL, GL_WGL_SWAPCONTROL );

	push	2
	push	0
	push	OFFSET _wglswapintervalfuncs
	push	OFFSET ??_C@_0BF@NPDKPIKE@WGL_EXT_swap_control@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1717 : 
; 1718 : 	// multitexture
; 1719 : 	glConfig.max_texture_units = glConfig.max_texture_coords = glConfig.max_teximage_units = 1;

	mov	DWORD PTR _glConfig+56, 1
	mov	eax, DWORD PTR _glConfig+56
	mov	DWORD PTR _glConfig+52, eax
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR _glConfig+48, ecx

; 1720 : 	GL_CheckExtension( "GL_ARB_multitexture", multitexturefuncs, "gl_arb_multitexture", GL_ARB_MULTITEXTURE );

	push	4
	push	OFFSET ??_C@_0BE@EJOPKNEG@gl_arb_multitexture@
	push	OFFSET _multitexturefuncs
	push	OFFSET ??_C@_0BE@MEMOPMEA@GL_ARB_multitexture@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1721 : 
; 1722 : 	if( GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@GL_InitExt

; 1723 : 		pglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glConfig.max_texture_units );

	push	OFFSET _glConfig+48
	push	34018					; 000084e2H
	call	DWORD PTR _pglGetIntegerv
$LN20@GL_InitExt:

; 1724 : 
; 1725 : 	if( glConfig.max_texture_units == 1 )

	cmp	DWORD PTR _glConfig+48, 1
	jne	SHORT $LN21@GL_InitExt

; 1726 : 		GL_SetExtension( GL_ARB_MULTITEXTURE, false );

	push	0
	push	4
	call	_GL_SetExtension
	add	esp, 8
$LN21@GL_InitExt:

; 1727 : 
; 1728 : 	// 3d texture support
; 1729 : 	GL_CheckExtension( "GL_EXT_texture3D", texture3dextfuncs, "gl_texture_3d", GL_TEXTURE_3D_EXT );

	push	12					; 0000000cH
	push	OFFSET ??_C@_0O@BKBMFEAO@gl_texture_3d@
	push	OFFSET _texture3dextfuncs
	push	OFFSET ??_C@_0BB@LCNIEGEB@GL_EXT_texture3D@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1730 : 
; 1731 : 	if( GL_Support( GL_TEXTURE_3D_EXT ))

	push	12					; 0000000cH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@GL_InitExt

; 1732 : 	{
; 1733 : 		pglGetIntegerv( GL_MAX_3D_TEXTURE_SIZE, &glConfig.max_3d_texture_size );

	push	OFFSET _glConfig+72
	push	32883					; 00008073H
	call	DWORD PTR _pglGetIntegerv

; 1734 : 
; 1735 : 		if( glConfig.max_3d_texture_size < 32 )

	cmp	DWORD PTR _glConfig+72, 32		; 00000020H
	jge	SHORT $LN23@GL_InitExt

; 1736 : 		{
; 1737 : 			GL_SetExtension( GL_TEXTURE_3D_EXT, false );

	push	0
	push	12					; 0000000cH
	call	_GL_SetExtension
	add	esp, 8

; 1738 : 			Con_Printf( S_ERROR "GL_EXT_texture3D reported bogus GL_MAX_3D_TEXTURE_SIZE, disabled\n" );

	push	OFFSET ??_C@_0EN@PIMEDHIH@?$FO1Error?3?$FO7?5GL_EXT_texture3D?5rep@
	call	_Con_Printf
	add	esp, 4
$LN23@GL_InitExt:

; 1739 : 		}
; 1740 : 	}
; 1741 : 
; 1742 : 	// 2d texture array support
; 1743 : 	GL_CheckExtension( "GL_EXT_texture_array", texture3dextfuncs, "gl_texture_2d_array", GL_TEXTURE_ARRAY_EXT );

	push	11					; 0000000bH
	push	OFFSET ??_C@_0BE@IGFCPAI@gl_texture_2d_array@
	push	OFFSET _texture3dextfuncs
	push	OFFSET ??_C@_0BF@NFIKFJJJ@GL_EXT_texture_array@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1744 : 
; 1745 : 	if( GL_Support( GL_TEXTURE_ARRAY_EXT ))

	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN24@GL_InitExt

; 1746 : 		pglGetIntegerv( GL_MAX_ARRAY_TEXTURE_LAYERS_EXT, &glConfig.max_2d_texture_layers );

	push	OFFSET _glConfig+68
	push	35071					; 000088ffH
	call	DWORD PTR _pglGetIntegerv
$LN24@GL_InitExt:

; 1747 : 
; 1748 : 	// cubemaps support
; 1749 : 	GL_CheckExtension( "GL_ARB_texture_cube_map", NULL, "gl_texture_cubemap", GL_TEXTURE_CUBEMAP_EXT );

	push	5
	push	OFFSET ??_C@_0BD@HBEJEDLE@gl_texture_cubemap@
	push	0
	push	OFFSET ??_C@_0BI@GGDPEJMJ@GL_ARB_texture_cube_map@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1750 : 
; 1751 : 	if( GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@GL_InitExt

; 1752 : 	{
; 1753 : 		pglGetIntegerv( GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB, &glConfig.max_cubemap_size );

	push	OFFSET _glConfig+76
	push	34076					; 0000851cH
	call	DWORD PTR _pglGetIntegerv

; 1754 : 
; 1755 : 		// check for seamless cubemaps too
; 1756 : 		GL_CheckExtension( "GL_ARB_seamless_cube_map", NULL, "gl_texture_cubemap_seamless", GL_ARB_SEAMLESS_CUBEMAP );

	push	18					; 00000012H
	push	OFFSET ??_C@_0BM@CBHJAMMP@gl_texture_cubemap_seamless@
	push	0
	push	OFFSET ??_C@_0BJ@HMEOFOCO@GL_ARB_seamless_cube_map@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN25@GL_InitExt:

; 1757 : 	}
; 1758 : 
; 1759 : 	GL_CheckExtension( "GL_ARB_texture_non_power_of_two", NULL, "gl_texture_npot", GL_ARB_TEXTURE_NPOT_EXT );

	push	14					; 0000000eH
	push	OFFSET ??_C@_0BA@OFKFFJCC@gl_texture_npot@
	push	0
	push	OFFSET ??_C@_0CA@IICOLDCN@GL_ARB_texture_non_power_of_two@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1760 : 	GL_CheckExtension( "GL_ARB_texture_compression", texturecompressionfuncs, "gl_texture_dxt_compression", GL_TEXTURE_COMPRESSION_EXT );

	push	8
	push	OFFSET ??_C@_0BL@KELAADP@gl_texture_dxt_compression@
	push	OFFSET _texturecompressionfuncs
	push	OFFSET ??_C@_0BL@PEFPCGDJ@GL_ARB_texture_compression@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1761 : 	GL_CheckExtension( "GL_EXT_texture_edge_clamp", NULL, NULL, GL_CLAMPTOEDGE_EXT );

	push	13					; 0000000dH
	push	0
	push	0
	push	OFFSET ??_C@_0BK@BAOPHLFB@GL_EXT_texture_edge_clamp@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1762 : 
; 1763 : 	if( !GL_Support( GL_CLAMPTOEDGE_EXT ))

	push	13					; 0000000dH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@GL_InitExt

; 1764 : 		GL_CheckExtension( "GL_SGIS_texture_edge_clamp", NULL, NULL, GL_CLAMPTOEDGE_EXT );

	push	13					; 0000000dH
	push	0
	push	0
	push	OFFSET ??_C@_0BL@JOCOPCOL@GL_SGIS_texture_edge_clamp@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN26@GL_InitExt:

; 1765 : 
; 1766 : 	glConfig.max_texture_anisotropy = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _glConfig+80, xmm0

; 1767 : 	GL_CheckExtension( "GL_EXT_texture_filter_anisotropic", NULL, "gl_texture_anisotropic_filter", GL_ANISOTROPY_EXT );

	push	6
	push	OFFSET ??_C@_0BO@EJMKODIC@gl_texture_anisotropic_filter@
	push	0
	push	OFFSET ??_C@_0CC@BCHFGKCK@GL_EXT_texture_filter_anisotrop@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1768 : 
; 1769 : 	if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@GL_InitExt

; 1770 : 		pglGetFloatv( GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &glConfig.max_texture_anisotropy );

	push	OFFSET _glConfig+80
	push	34047					; 000084ffH
	call	DWORD PTR _pglGetFloatv
$LN27@GL_InitExt:

; 1771 : 
; 1772 : 	// g-cont. because lodbias it too glitchy on Intel's cards
; 1773 : 	if( glConfig.hardware_type != GLHW_INTEL )

	cmp	DWORD PTR _glConfig+12, 3
	je	SHORT $LN28@GL_InitExt

; 1774 : 		GL_CheckExtension( "GL_EXT_texture_lod_bias", NULL, "gl_texture_mipmap_biasing", GL_TEXTURE_LOD_BIAS );

	push	7
	push	OFFSET ??_C@_0BK@OICKEAFL@gl_texture_mipmap_biasing@
	push	0
	push	OFFSET ??_C@_0BI@KEEAJGDF@GL_EXT_texture_lod_bias@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN28@GL_InitExt:

; 1775 : 
; 1776 : 	if( GL_Support( GL_TEXTURE_LOD_BIAS ))

	push	7
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@GL_InitExt

; 1777 : 		pglGetFloatv( GL_MAX_TEXTURE_LOD_BIAS_EXT, &glConfig.max_texture_lod_bias );

	push	OFFSET _glConfig+84
	push	34045					; 000084fdH
	call	DWORD PTR _pglGetFloatv
$LN29@GL_InitExt:

; 1778 : 
; 1779 : 	GL_CheckExtension( "GL_ARB_texture_border_clamp", NULL, NULL, GL_CLAMP_TEXBORDER_EXT );

	push	15					; 0000000fH
	push	0
	push	0
	push	OFFSET ??_C@_0BM@CBHOGGCB@GL_ARB_texture_border_clamp@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1780 : 
; 1781 : 	GL_CheckExtension( "GL_ARB_depth_texture", NULL, NULL, GL_DEPTH_TEXTURE );

	push	20					; 00000014H
	push	0
	push	0
	push	OFFSET ??_C@_0BF@OKLDDGBF@GL_ARB_depth_texture@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1782 : 	GL_CheckExtension( "GL_ARB_texture_float", NULL, "gl_texture_float", GL_ARB_TEXTURE_FLOAT_EXT );

	push	16					; 00000010H
	push	OFFSET ??_C@_0BB@MNHIMBDK@gl_texture_float@
	push	0
	push	OFFSET ??_C@_0BF@IMLAOOOI@GL_ARB_texture_float@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1783 : 	GL_CheckExtension( "GL_ARB_depth_buffer_float", NULL, "gl_texture_float", GL_ARB_DEPTH_FLOAT_EXT );

	push	17					; 00000011H
	push	OFFSET ??_C@_0BB@MNHIMBDK@gl_texture_float@
	push	0
	push	OFFSET ??_C@_0BK@JKFHPKJF@GL_ARB_depth_buffer_float@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1784 : 	GL_CheckExtension( "GL_EXT_gpu_shader4", NULL, NULL, GL_EXT_GPU_SHADER4 ); // don't confuse users

	push	19					; 00000013H
	push	0
	push	0
	push	OFFSET ??_C@_0BD@MHBCPECK@GL_EXT_gpu_shader4@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1785 : 	GL_CheckExtension( "GL_ARB_shading_language_100", NULL, NULL, GL_SHADER_GLSL100_EXT );

	push	9
	push	0
	push	0
	push	OFFSET ??_C@_0BM@IABMMANC@GL_ARB_shading_language_100@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1786 : 
; 1787 : 	// this won't work without extended context
; 1788 : 	if( glw_state.extended )

	cmp	DWORD PTR _glw_state+24, 0
	je	SHORT $LN30@GL_InitExt

; 1789 : 		GL_CheckExtension( "GL_ARB_debug_output", debugoutputfuncs, "gl_debug_output", GL_DEBUG_OUTPUT );

	push	21					; 00000015H
	push	OFFSET ??_C@_0BA@CLNKMFGC@gl_debug_output@
	push	OFFSET _debugoutputfuncs
	push	OFFSET ??_C@_0BE@OHIPHHMJ@GL_ARB_debug_output@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN30@GL_InitExt:

; 1790 : 
; 1791 : 	// rectangle textures support
; 1792 : 	GL_CheckExtension( "GL_ARB_texture_rectangle", NULL, "gl_texture_rectangle", GL_TEXTURE_2D_RECT_EXT );

	push	10					; 0000000aH
	push	OFFSET ??_C@_0BF@GHMIKALG@gl_texture_rectangle@
	push	0
	push	OFFSET ??_C@_0BJ@NKHMPMDJ@GL_ARB_texture_rectangle@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H

; 1793 : 
; 1794 : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN31@GL_InitExt

; 1795 : 	{
; 1796 : 		pglGetIntegerv( GL_MAX_TEXTURE_COORDS_ARB, &glConfig.max_texture_coords );

	push	OFFSET _glConfig+52
	push	34929					; 00008871H
	call	DWORD PTR _pglGetIntegerv

; 1797 : 		pglGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &glConfig.max_teximage_units );

	push	OFFSET _glConfig+56
	push	34930					; 00008872H
	call	DWORD PTR _pglGetIntegerv

; 1798 : 
; 1799 : 		// check for hardware skinning
; 1800 : 		pglGetIntegerv( GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB, &glConfig.max_vertex_uniforms );

	push	OFFSET _glConfig+88
	push	35658					; 00008b4aH
	call	DWORD PTR _pglGetIntegerv

; 1801 : 		pglGetIntegerv( GL_MAX_VERTEX_ATTRIBS_ARB, &glConfig.max_vertex_attribs );

	push	OFFSET _glConfig+92
	push	34921					; 00008869H
	call	DWORD PTR _pglGetIntegerv

; 1802 : 
; 1803 : 		if( glConfig.hardware_type == GLHW_RADEON && glConfig.max_vertex_uniforms > 512 )

	cmp	DWORD PTR _glConfig+12, 1
	jne	SHORT $LN33@GL_InitExt
	cmp	DWORD PTR _glConfig+88, 512		; 00000200H
	jle	SHORT $LN33@GL_InitExt

; 1804 : 			glConfig.max_vertex_uniforms /= 4; // radeon returns not correct info

	mov	eax, DWORD PTR _glConfig+88
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _glConfig+88, eax
$LN33@GL_InitExt:

; 1805 : 	}

	jmp	SHORT $LN32@GL_InitExt
$LN31@GL_InitExt:

; 1806 : 	else
; 1807 : 	{
; 1808 : 		// just get from multitexturing
; 1809 : 		glConfig.max_texture_coords = glConfig.max_teximage_units = glConfig.max_texture_units;

	mov	eax, DWORD PTR _glConfig+48
	mov	DWORD PTR _glConfig+56, eax
	mov	ecx, DWORD PTR _glConfig+56
	mov	DWORD PTR _glConfig+52, ecx
$LN32@GL_InitExt:

; 1810 : 	}
; 1811 : 
; 1812 : 	pglGetIntegerv( GL_MAX_TEXTURE_SIZE, &glConfig.max_2d_texture_size );

	push	OFFSET _glConfig+60
	push	3379					; 00000d33H
	call	DWORD PTR _pglGetIntegerv

; 1813 : 	if( glConfig.max_2d_texture_size <= 0 ) glConfig.max_2d_texture_size = 256;

	cmp	DWORD PTR _glConfig+60, 0
	jg	SHORT $LN34@GL_InitExt
	mov	DWORD PTR _glConfig+60, 256		; 00000100H
$LN34@GL_InitExt:

; 1814 : 
; 1815 : 	if( GL_Support( GL_TEXTURE_2D_RECT_EXT ))

	push	10					; 0000000aH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN35@GL_InitExt

; 1816 : 		pglGetIntegerv( GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT, &glConfig.max_2d_rectangle_size );

	push	OFFSET _glConfig+64
	push	34040					; 000084f8H
	call	DWORD PTR _pglGetIntegerv
$LN35@GL_InitExt:

; 1817 : 
; 1818 : 	Cvar_Get( "gl_max_size", va( "%i", glConfig.max_2d_texture_size ), 0, "opengl texture max dims" );

	push	OFFSET ??_C@_0BI@KIIANDGF@opengl?5texture?5max?5dims@
	push	0
	mov	eax, DWORD PTR _glConfig+60
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0M@OALDNHGH@gl_max_size@
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 1819 : 
; 1820 : 	// MCD has buffering issues
; 1821 : 	if( Q_stristr( glConfig.renderer_string, "gdi" ))

	push	OFFSET ??_C@_03IDKLFMEL@gdi@
	mov	eax, DWORD PTR _glConfig
	push	eax
	call	_Q_stristr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN36@GL_InitExt

; 1822 : 		Cvar_SetValue( "gl_finish", 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09EFDNHKBE@gl_finish@
	call	_Cvar_SetValue
	add	esp, 8
$LN36@GL_InitExt:

; 1823 : 
; 1824 : 	Cvar_Set( "gl_anisotropy", va( "%f", bound( 0, gl_texture_anisotropy->value, glConfig.max_texture_anisotropy )));

	mov	eax, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN44@GL_InitExt
	mov	ecx, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR _glConfig+80
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN42@GL_InitExt
	mov	edx, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR tv420[ebp], xmm0
	jmp	SHORT $LN43@GL_InitExt
$LN42@GL_InitExt:
	movss	xmm0, DWORD PTR _glConfig+80
	movss	DWORD PTR tv420[ebp], xmm0
$LN43@GL_InitExt:
	movss	xmm0, DWORD PTR tv420[ebp]
	movss	DWORD PTR tv421[ebp], xmm0
	jmp	SHORT $LN45@GL_InitExt
$LN44@GL_InitExt:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv421[ebp], xmm0
$LN45@GL_InitExt:
	cvtss2sd xmm0, DWORD PTR tv421[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0O@DGIPFEHA@gl_anisotropy@
	call	_Cvar_Set
	add	esp, 8

; 1825 : 
; 1826 : 	if( GL_Support( GL_TEXTURE_COMPRESSION_EXT ))

	push	8
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN37@GL_InitExt

; 1827 : 		Image_AddCmdFlags( IL_DDS_HARDWARE );

	push	16					; 00000010H
	call	_Image_AddCmdFlags
	add	esp, 4
$LN37@GL_InitExt:

; 1828 : 
; 1829 : 	// enable gldebug if allowed
; 1830 : 	if( GL_Support( GL_DEBUG_OUTPUT ))

	push	21					; 00000015H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN38@GL_InitExt

; 1831 : 	{
; 1832 : 		pglDebugMessageCallbackARB( GL_DebugOutput, NULL );

	push	0
	push	OFFSET _GL_DebugOutput@28
	call	DWORD PTR _pglDebugMessageCallbackARB

; 1833 : 
; 1834 : 		// force everything to happen in the main thread instead of in a separate driver thread
; 1835 : 		pglEnable( GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB );

	push	33346					; 00008242H
	call	DWORD PTR _pglEnable

; 1836 : 
; 1837 : 		// enable all the low priority messages
; 1838 : 		pglDebugMessageControlARB( GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_LOW_ARB, 0, NULL, true );

	push	1
	push	0
	push	0
	push	37192					; 00009148H
	push	4352					; 00001100H
	push	4352					; 00001100H
	call	DWORD PTR _pglDebugMessageControlARB
$LN38@GL_InitExt:

; 1839 : 	}
; 1840 : 
; 1841 : 	tr.framecount = tr.visframecount = 1;

	mov	DWORD PTR _tr+83188, 1
	mov	eax, DWORD PTR _tr+83188
	mov	DWORD PTR _tr+83200, eax

; 1842 : 	glw_state.initialized = true;

	mov	DWORD PTR _glw_state+20, 1

; 1843 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_InitExtensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_RemoveCommands
_TEXT	SEGMENT
_GL_RemoveCommands PROC					; COMDAT

; 1663 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1664 : 	Cmd_RemoveCommand( "r_info");

	push	OFFSET ??_C@_06FFIAOFH@r_info@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 1665 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_RemoveCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_InitCommands
_TEXT	SEGMENT
_GL_InitCommands PROC					; COMDAT

; 1585 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1586 : 	// system screen width and height (don't suppose for change from console at all)
; 1587 : 	r_speeds = Cvar_Get( "r_speeds", "0", FCVAR_ARCHIVE, "shows renderer speeds" );

	push	OFFSET ??_C@_0BG@MJBAGIAO@shows?5renderer?5speeds@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08ILOBJANK@r_speeds@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_speeds, eax

; 1588 : 	r_fullbright = Cvar_Get( "r_fullbright", "0", FCVAR_CHEAT, "disable lightmaps, get fullbright for entities" );

	push	OFFSET ??_C@_0CP@LHCMIKFN@disable?5lightmaps?0?5get?5fullbrig@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0N@JEFJGNMG@r_fullbright@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_fullbright, eax

; 1589 : 	r_norefresh = Cvar_Get( "r_norefresh", "0", 0, "disable 3D rendering (use with caution)" );

	push	OFFSET ??_C@_0CI@BOKLFLAG@disable?53D?5rendering?5?$CIuse?5with?5@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0M@HGMGOPHP@r_norefresh@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_norefresh, eax

; 1590 : 	r_lighting_extended = Cvar_Get( "r_lighting_extended", "1", FCVAR_ARCHIVE, "allow to get lighting from bmodels too" );

	push	OFFSET ??_C@_0CH@GHBECDAJ@allow?5to?5get?5lighting?5from?5bmod@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BE@DGDPLBLK@r_lighting_extended@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_extended, eax

; 1591 : 	r_lighting_modulate = Cvar_Get( "r_lighting_modulate", "0.6", FCVAR_ARCHIVE, "lightstyles modulate scale" );

	push	OFFSET ??_C@_0BL@BOCCKKNK@lightstyles?5modulate?5scale@
	push	1
	push	OFFSET ??_C@_03JFFPCCNN@0?46@
	push	OFFSET ??_C@_0BE@NGHAOOJB@r_lighting_modulate@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_modulate, eax

; 1592 : 	r_lighting_ambient = Cvar_Get( "r_lighting_ambient", "0.3", FCVAR_ARCHIVE, "map ambient lighting scale" );

	push	OFFSET ??_C@_0BL@PDHNOOLN@map?5ambient?5lighting?5scale@
	push	1
	push	OFFSET ??_C@_03OICINGJI@0?43@
	push	OFFSET ??_C@_0BD@FOLIHJDI@r_lighting_ambient@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lighting_ambient, eax

; 1593 : 	r_adjust_fov = Cvar_Get( "r_adjust_fov", "1", FCVAR_ARCHIVE, "making FOV adjustment for wide-screens" );

	push	OFFSET ??_C@_0CH@DJAJLKIF@making?5FOV?5adjustment?5for?5wide?9@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0N@NDLEOLDK@r_adjust_fov@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_adjust_fov, eax

; 1594 : 	r_novis = Cvar_Get( "r_novis", "0", 0, "ignore vis information (perfomance test)" );

	push	OFFSET ??_C@_0CJ@CJFDAHBF@ignore?5vis?5information?5?$CIperfoma@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_07IFOJIEEJ@r_novis@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_novis, eax

; 1595 : 	r_nocull = Cvar_Get( "r_nocull", "0", 0, "ignore frustrum culling (perfomance test)" );

	push	OFFSET ??_C@_0CK@IBIJJLKA@ignore?5frustrum?5culling?5?$CIperfom@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08GDHICAID@r_nocull@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_nocull, eax

; 1596 : 	r_detailtextures = Cvar_Get( "r_detailtextures", "1", FCVAR_ARCHIVE, "enable detail textures support, use '2' for autogenerate detail.txt" );

	push	OFFSET ??_C@_0EE@OIMDMFDP@enable?5detail?5textures?5support?0@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BB@OJJFINJB@r_detailtextures@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_detailtextures, eax

; 1597 : 	r_lockpvs = Cvar_Get( "r_lockpvs", "0", FCVAR_CHEAT, "lockpvs area at current point (pvs test)" );

	push	OFFSET ??_C@_0CJ@ENDDEIKK@lockpvs?5area?5at?5current?5point?5?$CI@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_09OGELGAJA@r_lockpvs@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lockpvs, eax

; 1598 : 	r_lockfrustum = Cvar_Get( "r_lockfrustum", "0", FCVAR_CHEAT, "lock frustrum area at current point (cull test)" );

	push	OFFSET ??_C@_0DA@KNEJFKGN@lock?5frustrum?5area?5at?5current?5p@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@OPPHBGCA@r_lockfrustum@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lockfrustum, eax

; 1599 : 	r_dynamic = Cvar_Get( "r_dynamic", "1", FCVAR_ARCHIVE, "allow dynamic lighting (dlights, lightstyles)" );

	push	OFFSET ??_C@_0CO@DPCKELLF@allow?5dynamic?5lighting?5?$CIdlights@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_09DIEFKAPA@r_dynamic@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_dynamic, eax

; 1600 : 	r_traceglow = Cvar_Get( "r_traceglow", "1", FCVAR_ARCHIVE, "cull flares behind models" );

	push	OFFSET ??_C@_0BK@JCMABPHA@cull?5flares?5behind?5models@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0M@BNLCJNG@r_traceglow@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_traceglow, eax

; 1601 : 	r_lightmap = Cvar_Get( "r_lightmap", "0", FCVAR_CHEAT, "lightmap debugging tool" );

	push	OFFSET ??_C@_0BI@KFPFIPCN@lightmap?5debugging?5tool@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0L@GFIPPKI@r_lightmap@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_lightmap, eax

; 1602 : 	r_drawentities = Cvar_Get( "r_drawentities", "1", FCVAR_CHEAT|FCVAR_ARCHIVE, "render entities" );

	push	OFFSET ??_C@_0BA@OOOEBJD@render?5entities@
	push	32769					; 00008001H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0P@JAKGJBEE@r_drawentities@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_drawentities, eax

; 1603 : 	r_decals = Cvar_Get( "r_decals", "4096", FCVAR_ARCHIVE, "sets the maximum number of decals" );

	push	OFFSET ??_C@_0CC@MFGJAJHH@sets?5the?5maximum?5number?5of?5deca@
	push	1
	push	OFFSET ??_C@_04DPPBKBGP@4096@
	push	OFFSET ??_C@_08HELCJCPN@r_decals@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_decals, eax

; 1604 : 	r_showtree = Cvar_Get( "r_showtree", "0", FCVAR_ARCHIVE, "build the graph of visible BSP tree" );

	push	OFFSET ??_C@_0CE@KKAJCFEF@build?5the?5graph?5of?5visible?5BSP?5@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0L@EACCIFLO@r_showtree@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_showtree, eax

; 1605 : 	window_xpos = Cvar_Get( "_window_xpos", "130", FCVAR_RENDERINFO, "window position by horizontal" );

	push	OFFSET ??_C@_0BO@PBCKFEIH@window?5position?5by?5horizontal@
	push	65536					; 00010000H
	push	OFFSET ??_C@_03GPEHNCBN@130@
	push	OFFSET ??_C@_0N@FDEDDELO@_window_xpos@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _window_xpos, eax

; 1606 : 	window_ypos = Cvar_Get( "_window_ypos", "48", FCVAR_RENDERINFO, "window position by vertical" );

	push	OFFSET ??_C@_0BM@PGDAOPNK@window?5position?5by?5vertical@
	push	65536					; 00010000H
	push	OFFSET ??_C@_02DEEDNHFK@48@
	push	OFFSET ??_C@_0N@GOCDBNAO@_window_ypos@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _window_ypos, eax

; 1607 : 
; 1608 : 	gl_extensions = Cvar_Get( "gl_allow_extensions", "1", FCVAR_GLCONFIG, "allow gl_extensions" );			

	push	OFFSET ??_C@_0BE@PAOPLDIB@allow?5gl_extensions@
	push	4096					; 00001000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BE@PPOOCPHN@gl_allow_extensions@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_extensions, eax

; 1609 : 	gl_wgl_msaa_samples = Cvar_Get( "gl_wgl_msaa_samples", "4", FCVAR_GLCONFIG, "enable multisample anti-aliasing" );

	push	OFFSET ??_C@_0CB@COLHHNBP@enable?5multisample?5anti?9aliasin@
	push	4096					; 00001000H
	push	OFFSET ??_C@_01FAMBOPH@4@
	push	OFFSET ??_C@_0BE@EAHDGDAI@gl_wgl_msaa_samples@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_wgl_msaa_samples, eax

; 1610 : 	gl_texture_nearest = Cvar_Get( "gl_texture_nearest", "0", FCVAR_ARCHIVE, "disable texture filter" );

	push	OFFSET ??_C@_0BH@PGOBJMGE@disable?5texture?5filter@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BD@GHLMGJGC@gl_texture_nearest@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_nearest, eax

; 1611 : 	gl_lightmap_nearest = Cvar_Get( "gl_lightmap_nearest", "0", FCVAR_ARCHIVE, "disable lightmap filter" );

	push	OFFSET ??_C@_0BI@KMEDCODF@disable?5lightmap?5filter@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BE@PIADLNDF@gl_lightmap_nearest@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_lightmap_nearest, eax

; 1612 : 	gl_check_errors = Cvar_Get( "gl_check_errors", "1", FCVAR_ARCHIVE, "ignore video engine errors" );

	push	OFFSET ??_C@_0BL@OLDCADMD@ignore?5video?5engine?5errors@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BA@FJPIIIDB@gl_check_errors@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_check_errors, eax

; 1613 : 	gl_vsync = Cvar_Get( "gl_vsync", "0", FCVAR_ARCHIVE,  "enable vertical syncronization" );

	push	OFFSET ??_C@_0BP@DNJDEMIO@enable?5vertical?5syncronization@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08KIKGOAN@gl_vsync@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_vsync, eax

; 1614 : 	gl_detailscale = Cvar_Get( "gl_detailscale", "4.0", FCVAR_ARCHIVE, "default scale applies while auto-generate list of detail textures" );

	push	OFFSET ??_C@_0EC@OFKHNLNH@default?5scale?5applies?5while?5aut@
	push	1
	push	OFFSET ??_C@_03EMGHBCAM@4?40@
	push	OFFSET ??_C@_0P@MNOHEFJK@gl_detailscale@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_detailscale, eax

; 1615 : 	gl_texture_anisotropy = Cvar_Get( "gl_anisotropy", "8", FCVAR_ARCHIVE, "textures anisotropic filter" );

	push	OFFSET ??_C@_0BM@HAFCFNHJ@textures?5anisotropic?5filter@
	push	1
	push	OFFSET ??_C@_01KJLJFBPL@8@
	push	OFFSET ??_C@_0O@DGIPFEHA@gl_anisotropy@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_anisotropy, eax

; 1616 : 	gl_texture_lodbias =  Cvar_Get( "gl_texture_lodbias", "0.0", FCVAR_ARCHIVE, "LOD bias for mipmapped textures (perfomance|quality)" );

	push	OFFSET ??_C@_0DF@GBALLODP@LOD?5bias?5for?5mipmapped?5textures@
	push	1
	push	OFFSET ??_C@_03MDAFIFFL@0?40@
	push	OFFSET ??_C@_0BD@KLPBGJAB@gl_texture_lodbias@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_texture_lodbias, eax

; 1617 : 	gl_keeptjunctions = Cvar_Get( "gl_keeptjunctions", "1", FCVAR_ARCHIVE, "removing tjuncs causes blinking pixels" ); 

	push	OFFSET ??_C@_0CH@DEBJPNFI@removing?5tjuncs?5causes?5blinking@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BC@PBNHCOGF@gl_keeptjunctions@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_keeptjunctions, eax

; 1618 : 	gl_allow_mirrors = Cvar_Get("gl_allow_mirrors", "1", FCVAR_ARCHIVE, "allow to draw mirror surfaces");

	push	OFFSET ??_C@_0BO@GEMEBLEE@allow?5to?5draw?5mirror?5surfaces@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0BB@FDJONAEL@gl_allow_mirrors@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_allow_mirrors, eax

; 1619 : 	gl_emboss_scale = Cvar_Get( "gl_emboss_scale", "0", FCVAR_ARCHIVE|FCVAR_LATCH, "fake bumpmapping scale" ); 

	push	OFFSET ??_C@_0BH@HOMNMNHH@fake?5bumpmapping?5scale@
	push	2049					; 00000801H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BA@JLEIJJJE@gl_emboss_scale@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_emboss_scale, eax

; 1620 : 	gl_showtextures = Cvar_Get( "r_showtextures", "0", FCVAR_CHEAT, "show all uploaded textures" );

	push	OFFSET ??_C@_0BL@GPBANEGN@show?5all?5uploaded?5textures@
	push	32768					; 00008000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0P@MJMKNHCG@r_showtextures@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_showtextures, eax

; 1621 : 	gl_finish = Cvar_Get( "gl_finish", "0", FCVAR_ARCHIVE, "use glFinish instead of glFlush" );

	push	OFFSET ??_C@_0CA@PIHPBMHO@use?5glFinish?5instead?5of?5glFlush@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_09EFDNHKBE@gl_finish@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_finish, eax

; 1622 : 	gl_nosort = Cvar_Get( "gl_nosort", "0", FCVAR_ARCHIVE, "disable sorting of translucent surfaces" );

	push	OFFSET ??_C@_0CI@OGENCDBH@disable?5sorting?5of?5translucent?5@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_09PKCFOMOL@gl_nosort@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_nosort, eax

; 1623 : 	gl_clear = Cvar_Get( "gl_clear", "0", FCVAR_ARCHIVE, "clearing screen after each frame" );

	push	OFFSET ??_C@_0CB@FNKBCEHJ@clearing?5screen?5after?5each?5fram@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_08PJGLHBHM@gl_clear@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_clear, eax

; 1624 : 	gl_test = Cvar_Get( "gl_test", "0", 0, "engine developer cvar for quick testing new features" );

	push	OFFSET ??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_07OMHDDOEC@gl_test@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_test, eax

; 1625 : 	gl_wireframe = Cvar_Get( "gl_wireframe", "0", FCVAR_ARCHIVE|FCVAR_SPONLY, "show wireframe overlay" );

	push	OFFSET ??_C@_0BH@JKFOEAPP@show?5wireframe?5overlay@
	push	65					; 00000041H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0N@BABLDJLO@gl_wireframe@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_wireframe, eax

; 1626 : 	gl_round_down = Cvar_Get( "gl_round_down", "2", FCVAR_RENDERINFO, "round texture sizes to nearest POT value" );

	push	OFFSET ??_C@_0CJ@PAOICFAB@round?5texture?5sizes?5to?5nearest?5@
	push	65536					; 00010000H
	push	OFFSET ??_C@_01FDFGLJHB@2@
	push	OFFSET ??_C@_0O@MDBDFJCF@gl_round_down@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_round_down, eax

; 1627 : 	gl_msaa = Cvar_Get( "gl_msaa", "1", FCVAR_ARCHIVE, "enable multi sample anti-aliasing" );

	push	OFFSET ??_C@_0CC@FILLBFN@enable?5multi?5sample?5anti?9aliasi@
	push	1
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_07NMOGFCPI@gl_msaa@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_msaa, eax

; 1628 : 
; 1629 : 	// these cvar not used by engine but some mods requires this
; 1630 : 	gl_polyoffset = Cvar_Get( "gl_polyoffset", "2.0", FCVAR_ARCHIVE, "polygon offset for decals" );

	push	OFFSET ??_C@_0BK@OMODEDDI@polygon?5offset?5for?5decals@
	push	1
	push	OFFSET ??_C@_03GJAMENNA@2?40@
	push	OFFSET ??_C@_0O@DJABIOB@gl_polyoffset@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _gl_polyoffset, eax

; 1631 :  
; 1632 : 	// make sure gl_vsync is checked after vid_restart
; 1633 : 	SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 1634 : 
; 1635 : 	vid_gamma = Cvar_Get( "gamma", "2.5", FCVAR_ARCHIVE, "gamma amount" );

	push	OFFSET ??_C@_0N@OKPJFHGN@gamma?5amount@
	push	1
	push	OFFSET ??_C@_03BEHLLJJF@2?45@
	push	OFFSET ??_C@_05KDLBCAI@gamma@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_gamma, eax

; 1636 : 	vid_brightness = Cvar_Get( "brightness", "0.0", FCVAR_ARCHIVE, "brighntess factor" );

	push	OFFSET ??_C@_0BC@NIINGILH@brighntess?5factor@
	push	1
	push	OFFSET ??_C@_03MDAFIFFL@0?40@
	push	OFFSET ??_C@_0L@BECHNFGG@brightness@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_brightness, eax

; 1637 : 	vid_mode = Cvar_Get( "vid_mode", VID_AUTOMODE, FCVAR_RENDERINFO|FCVAR_VIDRESTART, "display resolution mode" );

	push	OFFSET ??_C@_0BI@GPDAEHPE@display?5resolution?5mode@
	push	1114112					; 00110000H
	push	OFFSET ??_C@_02PGHGPEOM@?91@
	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_mode, eax

; 1638 : 	vid_fullscreen = Cvar_Get( "fullscreen", "0", FCVAR_RENDERINFO|FCVAR_VIDRESTART, "enable fullscreen mode" );

	push	OFFSET ??_C@_0BH@CFIPMPJA@enable?5fullscreen?5mode@
	push	1114112					; 00110000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_fullscreen, eax

; 1639 : 	vid_displayfrequency = Cvar_Get ( "vid_displayfrequency", "0", FCVAR_RENDERINFO|FCVAR_VIDRESTART, "fullscreen refresh rate" );

	push	OFFSET ??_C@_0BI@HILNBDHA@fullscreen?5refresh?5rate@
	push	1114112					; 00110000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BF@FJFOCBHB@vid_displayfrequency@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vid_displayfrequency, eax

; 1640 : 
; 1641 : 	// FarEast: Downsampling implementation, thanks to Magic Nipples
; 1642 : 	r_downsample = Cvar_Get("r_scale", "0", FCVAR_ARCHIVE, "downscale the view 1 - 1/2, 2 - 1/4, etc...");

	push	OFFSET ??_C@_0CM@JCNBFDFE@downscale?5the?5view?51?5?9?51?12?0?52?5?9@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_07CIMMGABH@r_scale@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r_downsample, eax

; 1643 : 
; 1644 : 	Cmd_AddCommand( "r_info", R_RenderInfo_f, "display renderer info" );

	push	OFFSET ??_C@_0BG@NIDHMICD@display?5renderer?5info@
	push	OFFSET _R_RenderInfo_f
	push	OFFSET ??_C@_06FFIAOFH@r_info@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1645 : 
; 1646 : 	// give initial OpenGL configuration
; 1647 : 	host.apply_opengl_config = true;

	mov	DWORD PTR _host+34392, 1

; 1648 : 	Cbuf_AddText( "exec opengl.cfg\n" );

	push	OFFSET ??_C@_0BB@PEOIMMGJ@exec?5opengl?4cfg?6@
	call	_Cbuf_AddText
	add	esp, 4

; 1649 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 1650 : 	host.apply_opengl_config = false;

	mov	DWORD PTR _host+34392, 0

; 1651 : 
; 1652 : 	// apply actual video mode to window
; 1653 : 	Cbuf_AddText( "exec video.cfg\n" );

	push	OFFSET ??_C@_0BA@KPOOHPGG@exec?5video?4cfg?6@
	call	_Cbuf_AddText
	add	esp, 4

; 1654 : 	Cbuf_Execute();

	call	_Cbuf_Execute

; 1655 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_InitCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_RenderInfo_f
_TEXT	SEGMENT
tv159 = -68						; size = 4
_R_RenderInfo_f PROC					; COMDAT

; 1534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1535 : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 1536 : 	Con_Printf( "GL_VENDOR: %s\n", glConfig.vendor_string );

	mov	eax, DWORD PTR _glConfig+4
	push	eax
	push	OFFSET ??_C@_0P@FAFHGBCB@GL_VENDOR?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1537 : 	Con_Printf( "GL_RENDERER: %s\n", glConfig.renderer_string );

	mov	eax, DWORD PTR _glConfig
	push	eax
	push	OFFSET ??_C@_0BB@GPBJMNCI@GL_RENDERER?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1538 : 	Con_Printf( "GL_VERSION: %s\n", glConfig.version_string );

	mov	eax, DWORD PTR _glConfig+8
	push	eax
	push	OFFSET ??_C@_0BA@IECAGHEM@GL_VERSION?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1539 : 
; 1540 : 	// don't spam about extensions
; 1541 : 	if( host_developer.value >= DEV_EXTENDED )

	movss	xmm0, DWORD PTR _host_developer+12
	comiss	xmm0, DWORD PTR __real@40000000
	jb	SHORT $LN3@R_RenderIn

; 1542 : 	{
; 1543 : 		Con_Printf( "GL_EXTENSIONS: %s\n", glConfig.extensions_string );

	mov	eax, DWORD PTR _glConfig+16
	push	eax
	push	OFFSET ??_C@_0BD@KJCGIEGA@GL_EXTENSIONS?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1544 : 
; 1545 : 		if( glConfig.wgl_extensions_string != NULL )

	cmp	DWORD PTR _glConfig+20, 0
	je	SHORT $LN3@R_RenderIn

; 1546 : 			Con_Printf( "\nWGL_EXTENSIONS: %s\n", glConfig.wgl_extensions_string );

	mov	eax, DWORD PTR _glConfig+20
	push	eax
	push	OFFSET ??_C@_0BF@MHGGCNCP@?6WGL_EXTENSIONS?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN3@R_RenderIn:

; 1547 : 	}
; 1548 : 
; 1549 : 	Con_Printf( "GL_MAX_TEXTURE_SIZE: %i\n", glConfig.max_2d_texture_size );

	mov	eax, DWORD PTR _glConfig+60
	push	eax
	push	OFFSET ??_C@_0BJ@DGHGDBBB@GL_MAX_TEXTURE_SIZE?3?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8

; 1550 : 	
; 1551 : 	if( GL_Support( GL_ARB_MULTITEXTURE ))

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@R_RenderIn

; 1552 : 		Con_Printf( "GL_MAX_TEXTURE_UNITS_ARB: %i\n", glConfig.max_texture_units );

	mov	eax, DWORD PTR _glConfig+48
	push	eax
	push	OFFSET ??_C@_0BO@NJACCPAH@GL_MAX_TEXTURE_UNITS_ARB?3?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8
$LN4@R_RenderIn:

; 1553 : 	if( GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@R_RenderIn

; 1554 : 		Con_Printf( "GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB: %i\n", glConfig.max_cubemap_size );

	mov	eax, DWORD PTR _glConfig+76
	push	eax
	push	OFFSET ??_C@_0CG@HNKECKCC@GL_MAX_CUBE_MAP_TEXTURE_SIZE_AR@
	call	_Con_Printf
	add	esp, 8
$LN5@R_RenderIn:

; 1555 : 	if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@R_RenderIn

; 1556 : 		Con_Printf( "GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT: %.1f\n", glConfig.max_texture_anisotropy );

	cvtss2sd xmm0, DWORD PTR _glConfig+80
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CJ@EBIJAOFI@GL_MAX_TEXTURE_MAX_ANISOTROPY_E@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN6@R_RenderIn:

; 1557 : 	if( GL_Support( GL_TEXTURE_2D_RECT_EXT ))

	push	10					; 0000000aH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@R_RenderIn

; 1558 : 		Con_Printf( "GL_MAX_RECTANGLE_TEXTURE_SIZE: %i\n", glConfig.max_2d_rectangle_size );

	mov	eax, DWORD PTR _glConfig+64
	push	eax
	push	OFFSET ??_C@_0CD@IPHBONJO@GL_MAX_RECTANGLE_TEXTURE_SIZE?3?5@
	call	_Con_Printf
	add	esp, 8
$LN7@R_RenderIn:

; 1559 : 	if( GL_Support( GL_TEXTURE_ARRAY_EXT ))

	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_RenderIn

; 1560 : 		Con_Printf( "GL_MAX_ARRAY_TEXTURE_LAYERS_EXT: %i\n", glConfig.max_2d_texture_layers );

	mov	eax, DWORD PTR _glConfig+68
	push	eax
	push	OFFSET ??_C@_0CF@CAGCLDMN@GL_MAX_ARRAY_TEXTURE_LAYERS_EXT@
	call	_Con_Printf
	add	esp, 8
$LN8@R_RenderIn:

; 1561 : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@R_RenderIn

; 1562 : 	{
; 1563 : 		Con_Printf( "GL_MAX_TEXTURE_COORDS_ARB: %i\n", glConfig.max_texture_coords );

	mov	eax, DWORD PTR _glConfig+52
	push	eax
	push	OFFSET ??_C@_0BP@LMEKKNLC@GL_MAX_TEXTURE_COORDS_ARB?3?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8

; 1564 : 		Con_Printf( "GL_MAX_TEXTURE_IMAGE_UNITS_ARB: %i\n", glConfig.max_teximage_units );

	mov	eax, DWORD PTR _glConfig+56
	push	eax
	push	OFFSET ??_C@_0CE@NIGBDIDN@GL_MAX_TEXTURE_IMAGE_UNITS_ARB?3@
	call	_Con_Printf
	add	esp, 8

; 1565 : 		Con_Printf( "GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB: %i\n", glConfig.max_vertex_uniforms );

	mov	eax, DWORD PTR _glConfig+88
	push	eax
	push	OFFSET ??_C@_0CK@BHOGBMDO@GL_MAX_VERTEX_UNIFORM_COMPONENT@
	call	_Con_Printf
	add	esp, 8

; 1566 : 		Con_Printf( "GL_MAX_VERTEX_ATTRIBS_ARB: %i\n", glConfig.max_vertex_attribs );

	mov	eax, DWORD PTR _glConfig+92
	push	eax
	push	OFFSET ??_C@_0BP@OJBBMJOE@GL_MAX_VERTEX_ATTRIBS_ARB?3?5?$CFi?6@
	call	_Con_Printf
	add	esp, 8
$LN9@R_RenderIn:

; 1567 : 	}
; 1568 : 
; 1569 : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 1570 : 	Con_Printf( "MODE: %s\n", vidmode[(int)vid_mode->value].desc );

	mov	eax, DWORD PTR _vid_mode
	cvttss2si ecx, DWORD PTR [eax+12]
	shl	ecx, 4
	mov	edx, DWORD PTR _vidmode[ecx]
	push	edx
	push	OFFSET ??_C@_09JCGKCLMG@MODE?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1571 : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 1572 : 	Con_Printf( "VERTICAL SYNC: %s\n", gl_vsync->value ? "enabled" : "disabled" );

	mov	eax, DWORD PTR _gl_vsync
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@R_RenderIn
	mov	DWORD PTR tv159[ebp], OFFSET ??_C@_07MHHIKOPA@enabled@
	jmp	SHORT $LN12@R_RenderIn
$LN11@R_RenderIn:
	mov	DWORD PTR tv159[ebp], OFFSET ??_C@_08BEHKFNNO@disabled@
$LN12@R_RenderIn:
	mov	ecx, DWORD PTR tv159[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@PCFIIPCG@VERTICAL?5SYNC?3?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1573 : 	Con_Printf( "Color %d bits, Alpha %d bits, Depth %d bits, Stencil %d bits\n", glConfig.color_bits,

	mov	eax, DWORD PTR _glConfig+112
	push	eax
	mov	ecx, DWORD PTR _glConfig+108
	push	ecx
	mov	edx, DWORD PTR _glConfig+104
	push	edx
	mov	eax, DWORD PTR _glConfig+100
	push	eax
	push	OFFSET ??_C@_0DO@LBGEEHIA@Color?5?$CFd?5bits?0?5Alpha?5?$CFd?5bits?0?5D@
	call	_Con_Printf
	add	esp, 20					; 00000014H

; 1574 : 		glConfig.alpha_bits, glConfig.depth_bits, glConfig.stencil_bits );
; 1575 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_RenderInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_SetDefaults
_TEXT	SEGMENT
_GL_SetDefaults PROC					; COMDAT

; 1490 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1491 : 	pglFinish();

	call	DWORD PTR _pglFinish

; 1492 : 
; 1493 : 	pglClearColor( 0.5f, 0.5f, 0.5f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglClearColor

; 1494 : 
; 1495 : 	pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 1496 : 	pglDisable( GL_CULL_FACE );

	push	2884					; 00000b44H
	call	DWORD PTR _pglDisable

; 1497 : 	pglDisable( GL_SCISSOR_TEST );

	push	3089					; 00000c11H
	call	DWORD PTR _pglDisable

; 1498 : 	pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 1499 : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1500 : 
; 1501 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN2@GL_SetDefa

; 1502 : 	{
; 1503 : 		pglDisable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglDisable

; 1504 : 		pglStencilMask( ( GLuint ) ~0 );

	push	-1
	call	DWORD PTR _pglStencilMask

; 1505 : 		pglStencilFunc( GL_EQUAL, 0, ~0 );

	push	-1
	push	0
	push	514					; 00000202H
	call	DWORD PTR _pglStencilFunc

; 1506 : 		pglStencilOp( GL_KEEP, GL_INCR, GL_INCR );

	push	7682					; 00001e02H
	push	7682					; 00001e02H
	push	7680					; 00001e00H
	call	DWORD PTR _pglStencilOp
$LN2@GL_SetDefa:

; 1507 : 	}
; 1508 : 
; 1509 : 	pglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );

	push	6914					; 00001b02H
	push	1032					; 00000408H
	call	DWORD PTR _pglPolygonMode

; 1510 : 	pglPolygonOffset( -1.0f, -2.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@c0000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPolygonOffset

; 1511 : 
; 1512 : 	GL_CleanupAllTextureUnits();

	call	_GL_CleanupAllTextureUnits

; 1513 : 
; 1514 : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1515 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1516 : 	pglDisable( GL_POLYGON_OFFSET_FILL );

	push	32823					; 00008037H
	call	DWORD PTR _pglDisable

; 1517 : 	pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1518 : 	pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1519 : 	pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR _pglShadeModel

; 1520 : 	pglFrontFace( GL_CCW );

	push	2305					; 00000901H
	call	DWORD PTR _pglFrontFace

; 1521 : 
; 1522 : 	pglPointSize( 1.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 1523 : 	pglLineWidth( 1.2f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f99999a
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 1524 : 
; 1525 : 	GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4

; 1526 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetDefaults ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_Free_OpenGL
_TEXT	SEGMENT
_R_Free_OpenGL PROC					; COMDAT

; 1472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1473 : 	GL_DeleteContext ();

	call	_GL_DeleteContext

; 1474 : 
; 1475 : 	VID_DestroyWindow ();

	call	_VID_DestroyWindow

; 1476 : 
; 1477 : 	Sys_FreeLibrary( &opengl_dll );

	push	OFFSET _opengl_dll
	call	_Sys_FreeLibrary
	add	esp, 4

; 1478 : 
; 1479 : 	// now all extensions are disabled
; 1480 : 	memset( glConfig.extension, 0, sizeof( glConfig.extension ));

	push	22					; 00000016H
	push	0
	push	OFFSET _glConfig+24
	call	_memset
	add	esp, 12					; 0000000cH

; 1481 : 	glw_state.initialized = false;

	mov	DWORD PTR _glw_state+20, 0

; 1482 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Free_OpenGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_Init_OpenGL
_TEXT	SEGMENT
tv70 = -68						; size = 4
_R_Init_OpenGL PROC					; COMDAT

; 1454 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1455 : 	Sys_LoadLibrary( &opengl_dll );	// load opengl32.dll

	push	OFFSET _opengl_dll
	call	_Sys_LoadLibrary
	add	esp, 4

; 1456 : 
; 1457 : 	if( !opengl_dll.link )

	cmp	DWORD PTR _opengl_dll+12, 0
	jne	SHORT $LN2@R_Init_Ope

; 1458 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_Init_Ope
$LN2@R_Init_Ope:

; 1459 : 
; 1460 : 	if( context_flags || CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN4@R_Init_Ope
	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN6@R_Init_Ope
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@R_Init_Ope
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN7@R_Init_Ope
$LN6@R_Init_Ope:
	mov	DWORD PTR tv70[ebp], 0
$LN7@R_Init_Ope:
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@R_Init_Ope
$LN4@R_Init_Ope:

; 1461 : 		GL_CheckExtension( "OpenGL Internal ProcAddress", wglproc_funcs, NULL, GL_WGL_PROCADDRESS );

	push	3
	push	0
	push	OFFSET _wglproc_funcs
	push	OFFSET ??_C@_0BM@KNOAIAMH@OpenGL?5Internal?5ProcAddress@
	call	_GL_CheckExtension
	add	esp, 16					; 00000010H
$LN3@R_Init_Ope:

; 1462 : 
; 1463 : 	return VID_SetMode();

	call	_VID_SetMode
$LN1@R_Init_Ope:

; 1464 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Init_OpenGL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_SetMode
_TEXT	SEGMENT
_iScreenHeight$1 = -20					; size = 4
_iScreenWidth$2 = -16					; size = 4
_hDCScreen$3 = -12					; size = 4
_err$ = -8						; size = 4
_fullscreen$ = -4					; size = 4
_VID_SetMode PROC					; COMDAT

; 1361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1362 : 	qboolean	fullscreen;
; 1363 : 	rserr_t	err;
; 1364 : 
; 1365 : 	if( vid_mode->value == -1 )	// trying to get resolution automatically by default

	mov	eax, DWORD PTR _vid_mode
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN4@VID_SetMod

; 1366 : 	{
; 1367 : 		HDC	hDCScreen = GetDC( NULL );

	push	0
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDCScreen$3[ebp], eax

; 1368 : 		int	iScreenWidth = GetDeviceCaps( hDCScreen, HORZRES );

	push	8
	mov	eax, DWORD PTR _hDCScreen$3[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _iScreenWidth$2[ebp], eax

; 1369 : 		int	iScreenHeight = GetDeviceCaps( hDCScreen, VERTRES );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _hDCScreen$3[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _iScreenHeight$1[ebp], eax

; 1370 : 
; 1371 : 		ReleaseDC( NULL, hDCScreen );

	mov	eax, DWORD PTR _hDCScreen$3[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__ReleaseDC@8

; 1372 : 
; 1373 : 		if( R_DescribeVIDMode( iScreenWidth, iScreenHeight ))

	mov	eax, DWORD PTR _iScreenHeight$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _iScreenWidth$2[ebp]
	push	ecx
	call	_R_DescribeVIDMode
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@VID_SetMod

; 1374 : 		{
; 1375 : 			Con_Reportf( "found specified vid mode %i [%ix%i]\n", (int)vid_mode->value, iScreenWidth, iScreenHeight );

	mov	eax, DWORD PTR _iScreenHeight$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _iScreenWidth$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _vid_mode
	cvttss2si eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_0CF@JIIPBDNP@found?5specified?5vid?5mode?5?$CFi?5?$FL?$CFi@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1376 : 			Cvar_SetValue( "fullscreen", 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_SetValue
	add	esp, 8

; 1377 : 		}

	jmp	SHORT $LN4@VID_SetMod
$LN3@VID_SetMod:

; 1378 : 		else
; 1379 : 		{
; 1380 : 			Con_Reportf( "failed to set specified vid mode [%ix%i]\n", iScreenWidth, iScreenHeight );

	mov	eax, DWORD PTR _iScreenHeight$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _iScreenWidth$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0CK@BDDCKCLM@failed?5to?5set?5specified?5vid?5mod@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 1381 : 			Cvar_SetValue( "vid_mode", VID_DEFAULTMODE );

	push	ecx
	movss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_SetValue
	add	esp, 8
$LN4@VID_SetMod:

; 1382 : 		}
; 1383 : 	}
; 1384 : 
; 1385 : 	fullscreen = vid_fullscreen->value;

	mov	eax, DWORD PTR _vid_fullscreen
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _fullscreen$[ebp], ecx

; 1386 : 	SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 1387 : 
; 1388 : 	if(( err = R_ChangeDisplaySettings( vid_mode->value, fullscreen )) == rserr_ok )

	mov	eax, DWORD PTR _fullscreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vid_mode
	cvttss2si edx, DWORD PTR [ecx+12]
	push	edx
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN5@VID_SetMod

; 1389 : 	{
; 1390 : 		glConfig.prev_mode = vid_mode->value;

	mov	eax, DWORD PTR _vid_mode
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _glConfig+128, ecx

; 1391 : 	}

	jmp	$LN11@VID_SetMod
$LN5@VID_SetMod:

; 1392 : 	else
; 1393 : 	{
; 1394 : 		if( err == rserr_invalid_fullscreen )

	cmp	DWORD PTR _err$[ebp], 1
	jne	SHORT $LN7@VID_SetMod

; 1395 : 		{
; 1396 : 			Cvar_SetValue( "fullscreen", 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen@
	call	_Cvar_SetValue
	add	esp, 8

; 1397 : 			Con_Printf( S_ERROR "VID_SetMode: fullscreen unavailable in this mode\n" );

	push	OFFSET ??_C@_0DN@NDNLGOKO@?$FO1Error?3?$FO7?5VID_SetMode?3?5fullscr@
	call	_Con_Printf
	add	esp, 4

; 1398 : 			if(( err = R_ChangeDisplaySettings( vid_mode->value, false )) == rserr_ok )

	push	0
	mov	eax, DWORD PTR _vid_mode
	cvttss2si ecx, DWORD PTR [eax+12]
	push	ecx
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN9@VID_SetMod

; 1399 : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@VID_SetMod
$LN9@VID_SetMod:

; 1400 : 		}

	jmp	SHORT $LN10@VID_SetMod
$LN7@VID_SetMod:

; 1401 : 		else if( err == rserr_invalid_mode )

	cmp	DWORD PTR _err$[ebp], 2
	jne	SHORT $LN10@VID_SetMod

; 1402 : 		{
; 1403 : 			Con_Printf( S_ERROR "VID_SetMode: invalid mode\n" );

	push	OFFSET ??_C@_0CG@IONHNGJE@?$FO1Error?3?$FO7?5VID_SetMode?3?5invalid@
	call	_Con_Printf
	add	esp, 4

; 1404 : 			Cvar_SetValue( "vid_mode", glConfig.prev_mode );

	cvtsi2ss xmm0, DWORD PTR _glConfig+128
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_SetValue
	add	esp, 8
$LN10@VID_SetMod:

; 1405 : 		}
; 1406 : 
; 1407 : 		// try setting it back to something safe
; 1408 : 		if(( err = R_ChangeDisplaySettings( glConfig.prev_mode, false )) != rserr_ok )

	push	0
	mov	eax, DWORD PTR _glConfig+128
	push	eax
	call	_R_ChangeDisplaySettings
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN11@VID_SetMod

; 1409 : 		{
; 1410 : 			Con_Printf( S_ERROR "VID_SetMode: could not revert to safe mode\n" );

	push	OFFSET ??_C@_0DH@OLPHDNFE@?$FO1Error?3?$FO7?5VID_SetMode?3?5could?5n@
	call	_Con_Printf
	add	esp, 4

; 1411 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_SetMod
$LN11@VID_SetMod:

; 1412 : 		}
; 1413 : 	}
; 1414 : 
; 1415 : 	return true;

	mov	eax, 1
$LN1@VID_SetMod:

; 1416 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_SetMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_ChangeDisplaySettings
_TEXT	SEGMENT
_freq_specified$1 = -180				; size = 4
_dm$2 = -176						; size = 156
_hDC$ = -20						; size = 4
_cds_result$ = -16					; size = 4
_height$ = -12						; size = 4
_width$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_vid_mode$ = 8						; size = 4
_fullscreen$ = 12					; size = 4
_R_ChangeDisplaySettings PROC				; COMDAT

; 1235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1236 : 	int	width, height;
; 1237 : 	int	cds_result;
; 1238 : 	HDC	hDC;
; 1239 : 	
; 1240 : 	R_SaveVideoMode( vid_mode );

	mov	eax, DWORD PTR _vid_mode$[ebp]
	push	eax
	call	_R_SaveVideoMode
	add	esp, 4

; 1241 : 
; 1242 : 	width = glState.width;

	mov	eax, DWORD PTR _glState
	mov	DWORD PTR _width$[ebp], eax

; 1243 : 	height = glState.height;

	mov	eax, DWORD PTR _glState+4
	mov	DWORD PTR _height$[ebp], eax

; 1244 : 
; 1245 : 	// check our desktop attributes
; 1246 : 	hDC = GetDC( GetDesktopWindow( ));

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDC$[ebp], eax

; 1247 : 	glw_state.desktopBitsPixel = GetDeviceCaps( hDC, BITSPIXEL );

	push	12					; 0000000cH
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+8, eax

; 1248 : 	glw_state.desktopWidth = GetDeviceCaps( hDC, HORZRES );

	push	8
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+12, eax

; 1249 : 	glw_state.desktopHeight = GetDeviceCaps( hDC, VERTRES );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDeviceCaps@8
	mov	DWORD PTR _glw_state+16, eax

; 1250 : 	ReleaseDC( GetDesktopWindow(), hDC );

	mov	eax, DWORD PTR _hDC$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__ReleaseDC@8

; 1251 : 
; 1252 : 	// destroy the existing window
; 1253 : 	if( host.hWnd ) VID_DestroyWindow();

	cmp	DWORD PTR _host+34332, 0
	je	SHORT $LN2@R_ChangeDi
	call	_VID_DestroyWindow
$LN2@R_ChangeDi:

; 1254 : 
; 1255 : 	// do a CDS if needed
; 1256 : 	if( fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	je	$LN3@R_ChangeDi

; 1257 : 	{
; 1258 : 		DEVMODE	dm;
; 1259 : 
; 1260 : 		memset( &dm, 0, sizeof( dm ));

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1261 : 		dm.dmSize = sizeof( dm );

	mov	eax, 156				; 0000009cH
	mov	WORD PTR _dm$2[ebp+36], ax

; 1262 : 		dm.dmPelsWidth = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _dm$2[ebp+108], eax

; 1263 : 		dm.dmPelsHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _dm$2[ebp+112], eax

; 1264 : 		dm.dmFields = DM_PELSWIDTH|DM_PELSHEIGHT;

	mov	DWORD PTR _dm$2[ebp+40], 1572864	; 00180000H

; 1265 : 
; 1266 : 		if( vid_displayfrequency->value > 0 )

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@R_ChangeDi

; 1267 : 		{
; 1268 : 			if( vid_displayfrequency->value < 60 ) Cvar_SetValue( "vid_displayfrequency", 60 );

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN6@R_ChangeDi
	push	ecx
	movss	xmm0, DWORD PTR __real@42700000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BF@FJFOCBHB@vid_displayfrequency@
	call	_Cvar_SetValue
	add	esp, 8
$LN6@R_ChangeDi:

; 1269 : 			if( vid_displayfrequency->value > 100 ) Cvar_SetValue( "vid_displayfrequency", 100 );

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@42c80000
	jbe	SHORT $LN7@R_ChangeDi
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BF@FJFOCBHB@vid_displayfrequency@
	call	_Cvar_SetValue
	add	esp, 8
$LN7@R_ChangeDi:

; 1270 : 
; 1271 : 			dm.dmFields |= DM_DISPLAYFREQUENCY;

	mov	eax, DWORD PTR _dm$2[ebp+40]
	or	eax, 4194304				; 00400000H
	mov	DWORD PTR _dm$2[ebp+40], eax

; 1272 : 			dm.dmDisplayFrequency = vid_displayfrequency->value;

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [eax+12]
	call	__ftol3
	mov	DWORD PTR _dm$2[ebp+120], eax
$LN5@R_ChangeDi:

; 1273 : 		}
; 1274 : 
; 1275 : 		cds_result = ChangeDisplaySettings( &dm, CDS_FULLSCREEN );

	push	4
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	mov	DWORD PTR _cds_result$[ebp], eax

; 1276 : 
; 1277 : 		if( cds_result == DISP_CHANGE_SUCCESSFUL )

	cmp	DWORD PTR _cds_result$[ebp], 0
	jne	SHORT $LN8@R_ChangeDi

; 1278 : 		{
; 1279 : 			glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1280 : 
; 1281 : 			if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@R_ChangeDi

; 1282 : 				return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN10@R_ChangeDi:

; 1283 : 			return rserr_ok;

	xor	eax, eax
	jmp	$LN1@R_ChangeDi

; 1284 : 		}

	jmp	$LN19@R_ChangeDi
$LN8@R_ChangeDi:

; 1285 : 		else if( cds_result == DISP_CHANGE_BADDUALVIEW )

	cmp	DWORD PTR _cds_result$[ebp], -6		; fffffffaH
	jne	$LN11@R_ChangeDi

; 1286 : 		{
; 1287 : 			dm.dmPelsWidth = width * 2;

	mov	eax, DWORD PTR _width$[ebp]
	shl	eax, 1
	mov	DWORD PTR _dm$2[ebp+108], eax

; 1288 : 			dm.dmPelsHeight = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _dm$2[ebp+112], eax

; 1289 : 			dm.dmFields = DM_PELSWIDTH|DM_PELSHEIGHT;

	mov	DWORD PTR _dm$2[ebp+40], 1572864	; 00180000H

; 1290 : 
; 1291 : 			// our first CDS failed, so maybe we're running on some weird dual monitor system 
; 1292 : 			if( ChangeDisplaySettings( &dm, CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL )

	push	4
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	test	eax, eax
	je	SHORT $LN13@R_ChangeDi

; 1293 : 			{
; 1294 : 				ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1295 : 				glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1296 : 				if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@R_ChangeDi

; 1297 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN15@R_ChangeDi:

; 1298 : 				return rserr_invalid_fullscreen;

	mov	eax, 1
	jmp	$LN1@R_ChangeDi

; 1299 : 			}

	jmp	SHORT $LN14@R_ChangeDi
$LN13@R_ChangeDi:

; 1300 : 			else
; 1301 : 			{
; 1302 : 				if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@R_ChangeDi

; 1303 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN16@R_ChangeDi:

; 1304 : 				glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1305 : 				return rserr_ok;

	xor	eax, eax
	jmp	$LN1@R_ChangeDi
$LN14@R_ChangeDi:

; 1306 : 			}
; 1307 : 		}

	jmp	$LN19@R_ChangeDi
$LN11@R_ChangeDi:

; 1308 : 		else
; 1309 : 		{
; 1310 : 			int	freq_specified = 0;

	mov	DWORD PTR _freq_specified$1[ebp], 0

; 1311 : 
; 1312 : 			if( vid_displayfrequency->value > 0 )

	mov	eax, DWORD PTR _vid_displayfrequency
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN17@R_ChangeDi

; 1313 : 			{
; 1314 : 				// clear out custom frequency
; 1315 : 				freq_specified = vid_displayfrequency->value;

	mov	eax, DWORD PTR _vid_displayfrequency
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _freq_specified$1[ebp], ecx

; 1316 : 				Cvar_SetValue( "vid_displayfrequency", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BF@FJFOCBHB@vid_displayfrequency@
	call	_Cvar_SetValue
	add	esp, 8

; 1317 : 				dm.dmFields &= ~DM_DISPLAYFREQUENCY;

	mov	eax, DWORD PTR _dm$2[ebp+40]
	and	eax, -4194305				; ffbfffffH
	mov	DWORD PTR _dm$2[ebp+40], eax

; 1318 : 				dm.dmDisplayFrequency = 0;

	mov	DWORD PTR _dm$2[ebp+120], 0
$LN17@R_ChangeDi:

; 1319 : 			}
; 1320 : 
; 1321 : 			// our first CDS failed, so maybe we're running with too high displayfrequency
; 1322 : 			if( ChangeDisplaySettings( &dm, CDS_FULLSCREEN ) != DISP_CHANGE_SUCCESSFUL )

	push	4
	lea	eax, DWORD PTR _dm$2[ebp]
	push	eax
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8
	test	eax, eax
	je	SHORT $LN18@R_ChangeDi

; 1323 : 			{
; 1324 : 				ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1325 : 				glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1326 : 				if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@R_ChangeDi

; 1327 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	$LN1@R_ChangeDi
$LN20@R_ChangeDi:

; 1328 : 				return rserr_invalid_fullscreen;

	mov	eax, 1
	jmp	SHORT $LN1@R_ChangeDi

; 1329 : 			}

	jmp	SHORT $LN19@R_ChangeDi
$LN18@R_ChangeDi:

; 1330 : 			else
; 1331 : 			{
; 1332 : 				if( !VID_CreateWindow( width, height, true ))

	push	1
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@R_ChangeDi

; 1333 : 					return rserr_invalid_mode;

	mov	eax, 2
	jmp	SHORT $LN1@R_ChangeDi
$LN21@R_ChangeDi:

; 1334 : 
; 1335 : 				if( freq_specified )

	cmp	DWORD PTR _freq_specified$1[ebp], 0
	je	SHORT $LN22@R_ChangeDi

; 1336 : 					Con_Printf( S_ERROR "VID_SetMode: display frequency %i Hz is not supported\n", freq_specified );

	mov	eax, DWORD PTR _freq_specified$1[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@MCKMDEPJ@?$FO1Error?3?$FO7?5VID_SetMode?3?5display@
	call	_Con_Printf
	add	esp, 8
$LN22@R_ChangeDi:

; 1337 : 				glState.fullScreen = true;

	mov	DWORD PTR _glState+8, 1

; 1338 : 				return rserr_ok;

	xor	eax, eax
	jmp	SHORT $LN1@R_ChangeDi
$LN19@R_ChangeDi:

; 1339 : 			}
; 1340 : 		}
; 1341 : 	}

	jmp	SHORT $LN23@R_ChangeDi
$LN3@R_ChangeDi:

; 1342 : 	else
; 1343 : 	{
; 1344 : 		ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1345 : 		glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0

; 1346 : 		if( !VID_CreateWindow( width, height, false ))

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	_VID_CreateWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@R_ChangeDi

; 1347 : 			return rserr_invalid_mode;

	mov	eax, 2
	jmp	SHORT $LN1@R_ChangeDi
$LN23@R_ChangeDi:

; 1348 : 	}
; 1349 : 
; 1350 : 	return rserr_ok;

	xor	eax, eax
$LN1@R_ChangeDi:

; 1351 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ChangeDisplaySettings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_DestroyWindow
_TEXT	SEGMENT
_VID_DestroyWindow PROC					; COMDAT

; 1204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1205 : 	if( pwglMakeCurrent )

	cmp	DWORD PTR _pwglMakeCurrent, 0
	je	SHORT $LN2@VID_Destro

; 1206 : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent
$LN2@VID_Destro:

; 1207 : 
; 1208 : 	if( glw_state.hDC )

	cmp	DWORD PTR _glw_state, 0
	je	SHORT $LN3@VID_Destro

; 1209 : 	{
; 1210 : 		ReleaseDC( host.hWnd, glw_state.hDC );

	mov	eax, DWORD PTR _glw_state
	push	eax
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8

; 1211 : 		glw_state.hDC = NULL;

	mov	DWORD PTR _glw_state, 0
$LN3@VID_Destro:

; 1212 : 	}
; 1213 : 
; 1214 : 	if( host.hWnd )

	cmp	DWORD PTR _host+34332, 0
	je	SHORT $LN4@VID_Destro

; 1215 : 	{
; 1216 : 		DestroyWindow ( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 1217 : 		host.hWnd = NULL;

	mov	DWORD PTR _host+34332, 0
$LN4@VID_Destro:

; 1218 : 	}
; 1219 : 
; 1220 : 	UnregisterClass( WINDOW_NAME, host.hInst );

	mov	eax, DWORD PTR _host
	push	eax
	push	OFFSET ??_C@_0O@NBEGDOKI@Xash3D?5Window@
	call	DWORD PTR __imp__UnregisterClassA@8

; 1221 : 
; 1222 : 	if( glState.fullScreen )

	cmp	DWORD PTR _glState+8, 0
	je	SHORT $LN1@VID_Destro

; 1223 : 	{
; 1224 : 		ChangeDisplaySettings( 0, 0 );

	push	0
	push	0
	call	DWORD PTR __imp__ChangeDisplaySettingsA@8

; 1225 : 		glState.fullScreen = false;

	mov	DWORD PTR _glState+8, 0
$LN1@VID_Destro:

; 1226 : 	}
; 1227 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_DestroyWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_CreateWindow
_TEXT	SEGMENT
_localPath$1 = -344					; size = 256
_wc$ = -88						; size = 40
_rect$ = -48						; size = 16
_window$ = -32						; size = 4
_exstyle$ = -28						; size = 4
_stylebits$ = -24					; size = 4
_h$ = -20						; size = 4
_w$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_fullscreen$ = 16					; size = 4
_VID_CreateWindow PROC					; COMDAT

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1060 : 	int		x = 0, y = 0, w, h;

	mov	DWORD PTR _x$[ebp], 0
	mov	DWORD PTR _y$[ebp], 0

; 1061 : 	int		stylebits = WINDOW_STYLE;

	mov	DWORD PTR _stylebits$[ebp], 281542656	; 10c80000H

; 1062 : 	int		exstyle = WINDOW_EX_STYLE;

	mov	DWORD PTR _exstyle$[ebp], 0

; 1063 : 	static string	wndname;
; 1064 : 	HWND		window;
; 1065 : 	RECT		rect;	
; 1066 : 	WNDCLASS		wc;
; 1067 : 
; 1068 : 	Q_strncpy( wndname, GI->title, sizeof( wndname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _SI+768
	add	eax, 384				; 00000180H
	push	eax
	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1069 : 
; 1070 : 	// register the frame class
; 1071 : 	wc.style         = CS_OWNDC|CS_NOCLOSE;

	mov	DWORD PTR _wc$[ebp], 544		; 00000220H

; 1072 : 	wc.lpfnWndProc   = (WNDPROC)IN_WndProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET _IN_WndProc

; 1073 : 	wc.cbClsExtra    = 0;

	mov	DWORD PTR _wc$[ebp+8], 0

; 1074 : 	wc.cbWndExtra    = 0;

	mov	DWORD PTR _wc$[ebp+12], 0

; 1075 : 	wc.hInstance     = host.hInst;

	mov	eax, DWORD PTR _host
	mov	DWORD PTR _wc$[ebp+16], eax

; 1076 : 	wc.hCursor       = LoadCursor( NULL, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 1077 : 	wc.hbrBackground = (void *)COLOR_3DSHADOW;

	mov	DWORD PTR _wc$[ebp+28], 16		; 00000010H

; 1078 : 	wc.lpszClassName = WINDOW_NAME;

	mov	DWORD PTR _wc$[ebp+36], OFFSET ??_C@_0O@NBEGDOKI@Xash3D?5Window@

; 1079 : 	wc.lpszMenuName  = 0;

	mov	DWORD PTR _wc$[ebp+32], 0

; 1080 : 	wc.hIcon         = 0;

	mov	DWORD PTR _wc$[ebp+20], 0

; 1081 : 
; 1082 : 	// find the icon file in the filesystem
; 1083 : 	if( FS_FileExists( GI->iconpath, true ))

	push	1
	mov	eax, DWORD PTR _SI+768
	add	eax, 580				; 00000244H
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@VID_Create

; 1084 : 	{
; 1085 : 		if( FS_GetDiskPath( GI->iconpath, true ))

	push	1
	mov	eax, DWORD PTR _SI+768
	add	eax, 580				; 00000244H
	push	eax
	call	_FS_GetDiskPath
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@VID_Create

; 1086 : 		{
; 1087 : 			string	localPath;
; 1088 : 			Q_snprintf( localPath, sizeof( localPath ), "%s/%s", GI->gamedir, GI->iconpath );

	mov	eax, DWORD PTR _SI+768
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 128				; 00000080H
	push	ecx
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	push	256					; 00000100H
	lea	edx, DWORD PTR _localPath$1[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1089 : 			wc.hIcon = LoadImage( NULL, localPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE|LR_DEFAULTSIZE );

	push	80					; 00000050H
	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _localPath$1[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__LoadImageA@24
	mov	DWORD PTR _wc$[ebp+20], eax

; 1090 : 		}

	jmp	SHORT $LN4@VID_Create
$LN3@VID_Create:

; 1091 : 		else Con_Printf( "Extract %s from pak if you want to see it.\n", GI->iconpath );

	mov	eax, DWORD PTR _SI+768
	add	eax, 580				; 00000244H
	push	eax
	push	OFFSET ??_C@_0CM@PBKBDAIE@Extract?5?$CFs?5from?5pak?5if?5you?5want@
	call	_Con_Printf
	add	esp, 8
$LN4@VID_Create:

; 1092 : 	}
; 1093 : 
; 1094 : 	// couldn't loaded for some reasons? use default
; 1095 : 	if( !wc.hIcon ) wc.hIcon = LoadIcon( host.hInst, MAKEINTRESOURCE( 101 ));

	cmp	DWORD PTR _wc$[ebp+20], 0
	jne	SHORT $LN5@VID_Create
	push	101					; 00000065H
	mov	eax, DWORD PTR _host
	push	eax
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax
$LN5@VID_Create:

; 1096 : 
; 1097 : 	if( !RegisterClass( &wc ))

	lea	eax, DWORD PTR _wc$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN6@VID_Create

; 1098 : 	{ 
; 1099 : 		Con_Printf( S_ERROR "VID_CreateWindow: couldn't register window class %s\n" WINDOW_NAME );

	push	OFFSET ??_C@_0EN@BICFBIKB@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@
	call	_Con_Printf
	add	esp, 4

; 1100 : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Create
$LN6@VID_Create:

; 1101 : 	}
; 1102 : 
; 1103 : 	if( fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	je	SHORT $LN7@VID_Create

; 1104 : 	{
; 1105 : 		stylebits = WS_POPUP|WS_VISIBLE;

	mov	DWORD PTR _stylebits$[ebp], -1879048192	; 90000000H

; 1106 : 		exstyle = WS_EX_TOPMOST;

	mov	DWORD PTR _exstyle$[ebp], 8
$LN7@VID_Create:

; 1107 : 	}
; 1108 : 
; 1109 : 	rect.left = 0;

	mov	DWORD PTR _rect$[ebp], 0

; 1110 : 	rect.top = 0;

	mov	DWORD PTR _rect$[ebp+4], 0

; 1111 : 	rect.right  = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _rect$[ebp+8], eax

; 1112 : 	rect.bottom = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rect$[ebp+12], eax

; 1113 : 
; 1114 : 	AdjustWindowRect( &rect, stylebits, FALSE );

	push	0
	mov	eax, DWORD PTR _stylebits$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRect@12

; 1115 : 	w = rect.right - rect.left;

	mov	eax, DWORD PTR _rect$[ebp+8]
	sub	eax, DWORD PTR _rect$[ebp]
	mov	DWORD PTR _w$[ebp], eax

; 1116 : 	h = rect.bottom - rect.top;

	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	mov	DWORD PTR _h$[ebp], eax

; 1117 : 
; 1118 : #if 0
; 1119 : 	RECT WindowRect;
; 1120 : 	unsigned WindowHeight;
; 1121 : 	HWND WindowHandle;
; 1122 : 
; 1123 : 	WindowHandle = FindWindow("Shell_TrayWnd", NULL);
; 1124 : 	GetWindowRect(WindowHandle, &WindowRect);
; 1125 : 	WindowHeight = WindowRect.bottom - WindowRect.top;
; 1126 : #endif
; 1127 : 	if( !fullscreen )

	cmp	DWORD PTR _fullscreen$[ebp], 0
	jne	SHORT $LN13@VID_Create

; 1128 : 	{
; 1129 : 		x = window_xpos->value;

	mov	eax, DWORD PTR _window_xpos
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _x$[ebp], ecx

; 1130 : 		y = window_ypos->value;

	mov	eax, DWORD PTR _window_ypos
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _y$[ebp], ecx

; 1131 : 
; 1132 : 		// adjust window coordinates if necessary 
; 1133 : 		// so that the window is completely on screen
; 1134 : 		if( x < 0 ) x = 0;

	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN9@VID_Create
	mov	DWORD PTR _x$[ebp], 0
$LN9@VID_Create:

; 1135 : 		if( y < 0 ) y = 0;

	cmp	DWORD PTR _y$[ebp], 0
	jge	SHORT $LN10@VID_Create
	mov	DWORD PTR _y$[ebp], 0
$LN10@VID_Create:

; 1136 : 
; 1137 : 		if( Cvar_VariableInteger( "vid_mode" ) != glConfig.prev_mode )

	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_VariableInteger
	add	esp, 4
	cmp	eax, DWORD PTR _glConfig+128
	je	SHORT $LN13@VID_Create

; 1138 : 		{
; 1139 : 			// adjust window in the screen size
; 1140 : 			if( x + w > glw_state.desktopWidth )

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cmp	eax, DWORD PTR _glw_state+12
	jle	SHORT $LN12@VID_Create

; 1141 : 				x = ( glw_state.desktopWidth - w );

	mov	eax, DWORD PTR _glw_state+12
	sub	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR _x$[ebp], eax
$LN12@VID_Create:

; 1142 : 
; 1143 : 			if( y + h > glw_state.desktopHeight )

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cmp	eax, DWORD PTR _glw_state+16
	jle	SHORT $LN13@VID_Create

; 1144 : 				y = ( glw_state.desktopHeight - h );

	mov	eax, DWORD PTR _glw_state+16
	sub	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _y$[ebp], eax
$LN13@VID_Create:

; 1145 : 		}
; 1146 : 	}
; 1147 : 
; 1148 : 	window = CreateWindowEx( exstyle, WINDOW_NAME, wndname, stylebits, x, y, w, h, NULL, NULL, host.hInst, NULL );

	push	0
	mov	eax, DWORD PTR _host
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stylebits$[ebp]
	push	edx
	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET ??_C@_0O@NBEGDOKI@Xash3D?5Window@
	mov	eax, DWORD PTR _exstyle$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _window$[ebp], eax

; 1149 : 
; 1150 : 	if( host.hWnd != window )

	mov	eax, DWORD PTR _host+34332
	cmp	eax, DWORD PTR _window$[ebp]
	je	SHORT $LN14@VID_Create

; 1151 : 	{
; 1152 : 		// make sure what CreateWindowEx call the IN_WndProc
; 1153 : 		Con_Printf( S_WARN "VID_CreateWindow: bad hWnd for '%s'\n", wndname );

	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET ??_C@_0DC@EBFFCONK@?$FO3Warning?3?$FO7?5VID_CreateWindow?3?5@
	call	_Con_Printf
	add	esp, 8
$LN14@VID_Create:

; 1154 : 	}
; 1155 : 
; 1156 : 	if( !host.hWnd ) 

	cmp	DWORD PTR _host+34332, 0
	jne	SHORT $LN15@VID_Create

; 1157 : 	{
; 1158 : 		// host.hWnd must be filled in IN_WndProc
; 1159 : 		Con_Printf( S_ERROR "VID_CreateWindow: couldn't create '%s'\n", wndname );

	push	OFFSET ?wndname@?1??VID_CreateWindow@@9@9
	push	OFFSET ??_C@_0DD@OAMDGGDJ@?$FO1Error?3?$FO7?5VID_CreateWindow?3?5co@
	call	_Con_Printf
	add	esp, 8

; 1160 : 		return false;

	xor	eax, eax
	jmp	$LN1@VID_Create
$LN15@VID_Create:

; 1161 : 	}
; 1162 : 
; 1163 : 	ShowWindow( host.hWnd, SW_SHOW );

	push	5
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1164 : 	UpdateWindow( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__UpdateWindow@4

; 1165 : 
; 1166 : 	// init all the gl stuff for the window
; 1167 : 	if( !GL_SetPixelformat( ))

	call	_GL_SetPixelformat
	test	eax, eax
	jne	SHORT $LN16@VID_Create

; 1168 : 	{
; 1169 : 		ShowWindow( host.hWnd, SW_HIDE );

	push	0
	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1170 : 		DestroyWindow( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 1171 : 		host.hWnd = NULL;

	mov	DWORD PTR _host+34332, 0

; 1172 : 
; 1173 : 		UnregisterClass( WINDOW_NAME, host.hInst );

	mov	eax, DWORD PTR _host
	push	eax
	push	OFFSET ??_C@_0O@NBEGDOKI@Xash3D?5Window@
	call	DWORD PTR __imp__UnregisterClassA@8

; 1174 : 		Con_Printf( S_ERROR "OpenGL driver not installed\n" );

	push	OFFSET ??_C@_0CI@MKGEEDEG@?$FO1Error?3?$FO7?5OpenGL?5driver?5not?5in@
	call	_Con_Printf
	add	esp, 4

; 1175 : 
; 1176 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN16@VID_Create:

; 1177 : 	}
; 1178 : 
; 1179 : 	if( !glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN17@VID_Create

; 1180 : 	{
; 1181 : 		if( !GL_CreateContext( ))

	call	_GL_CreateContext
	test	eax, eax
	jne	SHORT $LN19@VID_Create

; 1182 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN19@VID_Create:

; 1183 : 
; 1184 : 		VID_StartupGamma();

	call	_VID_StartupGamma

; 1185 : 	}

	jmp	SHORT $LN20@VID_Create
$LN17@VID_Create:

; 1186 : 	else
; 1187 : 	{
; 1188 : 		if( !GL_UpdateContext( ))

	call	_GL_UpdateContext
	test	eax, eax
	jne	SHORT $LN20@VID_Create

; 1189 : 			return false;		

	xor	eax, eax
	jmp	SHORT $LN1@VID_Create
$LN20@VID_Create:

; 1190 : 	}
; 1191 : 
; 1192 : 	SetForegroundWindow( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 1193 : 	SetFocus( host.hWnd );

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__SetFocus@4

; 1194 : 
; 1195 : 	return true;

	mov	eax, 1
$LN1@VID_Create:

; 1196 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CreateWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_DescribeVIDMode
_TEXT	SEGMENT
_i$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_R_DescribeVIDMode PROC					; COMDAT

; 1037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1038 : 	int	i;
; 1039 : 
; 1040 : 	for( i = 0; i < sizeof( vidmode ) / sizeof( vidmode[0] ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_Describe
$LN2@R_Describe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_Describe:
	cmp	DWORD PTR _i$[ebp], 26			; 0000001aH
	jae	SHORT $LN3@R_Describe

; 1041 : 	{
; 1042 : 		if( vidmode[i].width == width && vidmode[i].height == height )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+4]
	cmp	ecx, DWORD PTR _width$[ebp]
	jne	SHORT $LN5@R_Describe
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+8]
	cmp	ecx, DWORD PTR _height$[ebp]
	jne	SHORT $LN5@R_Describe

; 1043 : 		{
; 1044 : 			// found specified mode
; 1045 : 			Cvar_SetValue( "vid_mode", i );

	cvtsi2ss xmm0, DWORD PTR _i$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_SetValue
	add	esp, 8

; 1046 : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@R_Describe
$LN5@R_Describe:

; 1047 : 		}
; 1048 : 	}

	jmp	SHORT $LN2@R_Describe
$LN3@R_Describe:

; 1049 : 
; 1050 : 	return false;

	xor	eax, eax
$LN1@R_Describe:

; 1051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DescribeVIDMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_SaveVideoMode
_TEXT	SEGMENT
tv67 = -76						; size = 4
tv66 = -72						; size = 4
_mode$ = -4						; size = 4
_vid_mode$ = 8						; size = 4
_R_SaveVideoMode PROC					; COMDAT

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1019 : 	int	mode = bound( 0, vid_mode, num_vidmodes ); // check range

	cmp	DWORD PTR _vid_mode$[ebp], 0
	jl	SHORT $LN5@R_SaveVide
	cmp	DWORD PTR _vid_mode$[ebp], 26		; 0000001aH
	jae	SHORT $LN3@R_SaveVide
	mov	eax, DWORD PTR _vid_mode$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@R_SaveVide
$LN3@R_SaveVide:
	mov	DWORD PTR tv66[ebp], 26			; 0000001aH
$LN4@R_SaveVide:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@R_SaveVide
$LN5@R_SaveVide:
	mov	DWORD PTR tv67[ebp], 0
$LN6@R_SaveVide:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _mode$[ebp], edx

; 1020 : 
; 1021 : 	glState.width = vidmode[mode].width;

	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+4]
	mov	DWORD PTR _glState, ecx

; 1022 : 	glState.height = vidmode[mode].height;

	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+8]
	mov	DWORD PTR _glState+4, ecx

; 1023 : 	glState.wideScreen = vidmode[mode].wideScreen;

	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+12]
	mov	DWORD PTR _glState+12, ecx

; 1024 : 	Cvar_FullSet( "width", va( "%i", glState.width ), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _glState
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_05IGKADHGO@width@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1025 : 	Cvar_FullSet( "height", va( "%i", glState.height ), FCVAR_READ_ONLY );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _glState+4
	push	eax
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi@
	call	_va
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_06LNLHEAAG@height@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1026 : 	Cvar_SetValue( "vid_mode", mode ); // merge if it out of bounds

	cvtsi2ss xmm0, DWORD PTR _mode$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_08ICHJJAPN@vid_mode@
	call	_Cvar_SetValue
	add	esp, 8

; 1027 : 
; 1028 : 	Con_Reportf( "Set: %s [%dx%d]\n", vidmode[mode].desc, vidmode[mode].width, vidmode[mode].height );

	mov	eax, DWORD PTR _mode$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _vidmode[eax+8]
	push	ecx
	mov	edx, DWORD PTR _mode$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _vidmode[edx+4]
	push	eax
	mov	ecx, DWORD PTR _mode$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _vidmode[ecx]
	push	edx
	push	OFFSET ??_C@_0BB@HIMCMJIL@Set?3?5?$CFs?5?$FL?$CFdx?$CFd?$FN?6@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1029 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SaveVideoMode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_SetPixelformat
_TEXT	SEGMENT
_depthBits$ = -64					; size = 4
_pixelFormat$ = -60					; size = 4
_stencilBits$ = -56					; size = 4
_alphaBits$ = -52					; size = 4
_colorBits$ = -48					; size = 4
_PFD$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_GL_SetPixelformat PROC					; COMDAT

; 933  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 934  : 	PIXELFORMATDESCRIPTOR	PFD;
; 935  : 	int			colorBits = 32;

	mov	DWORD PTR _colorBits$[ebp], 32		; 00000020H

; 936  : 	int			alphaBits = 8;

	mov	DWORD PTR _alphaBits$[ebp], 8

; 937  : 	int			stencilBits = 8;

	mov	DWORD PTR _stencilBits$[ebp], 8

; 938  : 	int			pixelFormat = 0;

	mov	DWORD PTR _pixelFormat$[ebp], 0

; 939  : 	int			depthBits = 24;

	mov	DWORD PTR _depthBits$[ebp], 24		; 00000018H

; 940  : 
; 941  : 	if(( glw_state.hDC = GetDC( host.hWnd )) == NULL )

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _glw_state, eax
	cmp	DWORD PTR _glw_state, 0
	jne	SHORT $LN2@GL_SetPixe

; 942  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN2@GL_SetPixe:

; 943  : 
; 944  : 	if( glw_state.desktopBitsPixel < 32 )

	cmp	DWORD PTR _glw_state+8, 32		; 00000020H
	jge	SHORT $LN3@GL_SetPixe

; 945  : 	{
; 946  : 		// clear alphabits in case we in 16-bit mode
; 947  : 		colorBits = glw_state.desktopBitsPixel;

	mov	eax, DWORD PTR _glw_state+8
	mov	DWORD PTR _colorBits$[ebp], eax

; 948  : 		alphaBits = 0;

	mov	DWORD PTR _alphaBits$[ebp], 0

; 949  : 	}

	jmp	SHORT $LN4@GL_SetPixe
$LN3@GL_SetPixe:

; 950  : 	else
; 951  : 	{
; 952  : 		// no reason to trying enable MSAA on a highcolor
; 953  : 		VID_CreateFakeWindow();

	call	_VID_CreateFakeWindow
$LN4@GL_SetPixe:

; 954  : 	}
; 955  : 
; 956  : 	// choose a pixel format
; 957  : 	pixelFormat = VID_ChoosePFD( &PFD, colorBits, alphaBits, depthBits, stencilBits );

	mov	eax, DWORD PTR _stencilBits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depthBits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alphaBits$[ebp]
	push	edx
	mov	eax, DWORD PTR _colorBits$[ebp]
	push	eax
	lea	ecx, DWORD PTR _PFD$[ebp]
	push	ecx
	call	_VID_ChoosePFD
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pixelFormat$[ebp], eax

; 958  : 
; 959  : 	if( !pixelFormat )

	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN5@GL_SetPixe

; 960  : 	{
; 961  : 		// try again with default color/depth/stencil
; 962  : 		pixelFormat = VID_ChoosePFD( &PFD, colorBits, 0, depthBits, 0 );

	push	0
	mov	eax, DWORD PTR _depthBits$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _colorBits$[ebp]
	push	ecx
	lea	edx, DWORD PTR _PFD$[ebp]
	push	edx
	call	_VID_ChoosePFD
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pixelFormat$[ebp], eax

; 963  : 
; 964  : 		if( !pixelFormat )

	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN5@GL_SetPixe

; 965  : 		{
; 966  : 			Con_Printf( S_ERROR "GL_SetPixelformat: failed to find an appropriate PIXELFORMAT\n" );

	push	OFFSET ??_C@_0EJ@NLKFPFAK@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@
	call	_Con_Printf
	add	esp, 4

; 967  : 			return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN5@GL_SetPixe:

; 968  : 		}
; 969  : 	}
; 970  : 
; 971  : 	// set the pixel format
; 972  : 	if( !SetPixelFormat( glw_state.hDC, pixelFormat, &PFD ))

	lea	eax, DWORD PTR _PFD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR __imp__SetPixelFormat@12
	test	eax, eax
	jne	SHORT $LN7@GL_SetPixe

; 973  : 	{
; 974  : 		Con_Printf( S_ERROR "GL_SetPixelformat: failed\n" );

	push	OFFSET ??_C@_0CG@BOCCJDEP@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5f@
	call	_Con_Printf
	add	esp, 4

; 975  : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_SetPixe
$LN7@GL_SetPixe:

; 976  : 	}
; 977  : 
; 978  : 	DescribePixelFormat( glw_state.hDC, pixelFormat, sizeof( PIXELFORMATDESCRIPTOR ), &PFD );

	lea	eax, DWORD PTR _PFD$[ebp]
	push	eax
	push	40					; 00000028H
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR __imp__DescribePixelFormat@16

; 979  : 
; 980  : 	if( PFD.dwFlags & PFD_GENERIC_FORMAT )

	mov	eax, DWORD PTR _PFD$[ebp+4]
	and	eax, 64					; 00000040H
	je	SHORT $LN8@GL_SetPixe

; 981  : 	{
; 982  : 		if( PFD.dwFlags & PFD_GENERIC_ACCELERATED )

	mov	eax, DWORD PTR _PFD$[ebp+4]
	and	eax, 4096				; 00001000H
	je	SHORT $LN10@GL_SetPixe

; 983  : 		{
; 984  : 			Con_Reportf( "VID_ChoosePFD: using Generic MCD acceleration\n" );

	push	OFFSET ??_C@_0CP@KMOPKOFH@VID_ChoosePFD?3?5using?5Generic?5MC@
	call	_Con_Reportf
	add	esp, 4

; 985  : 		}

	jmp	SHORT $LN11@GL_SetPixe
$LN10@GL_SetPixe:

; 986  : 		else
; 987  : 		{
; 988  : 			Con_Printf( S_ERROR "GL_SetPixelformat: no hardware acceleration found\n" );

	push	OFFSET ??_C@_0DO@DKAPEENC@?$FO1Error?3?$FO7?5GL_SetPixelformat?3?5n@
	call	_Con_Printf
	add	esp, 4

; 989  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@GL_SetPixe
$LN11@GL_SetPixe:

; 990  : 		}
; 991  : 	}

	jmp	SHORT $LN9@GL_SetPixe
$LN8@GL_SetPixe:

; 992  : 	else
; 993  : 	{
; 994  : 		Con_Reportf( "VID_ChoosePFD: using hardware acceleration\n" );

	push	OFFSET ??_C@_0CM@NFLBAACE@VID_ChoosePFD?3?5using?5hardware?5a@
	call	_Con_Reportf
	add	esp, 4
$LN9@GL_SetPixe:

; 995  : 	}
; 996  : 
; 997  : 	glConfig.color_bits = PFD.cColorBits;

	movzx	eax, BYTE PTR _PFD$[ebp+9]
	mov	DWORD PTR _glConfig+100, eax

; 998  : 	glConfig.alpha_bits = PFD.cAlphaBits;

	movzx	eax, BYTE PTR _PFD$[ebp+16]
	mov	DWORD PTR _glConfig+104, eax

; 999  : 	glConfig.depth_bits = PFD.cDepthBits;

	movzx	eax, BYTE PTR _PFD$[ebp+23]
	mov	DWORD PTR _glConfig+108, eax

; 1000 : 	glConfig.stencil_bits = PFD.cStencilBits;

	movzx	eax, BYTE PTR _PFD$[ebp+24]
	mov	DWORD PTR _glConfig+112, eax

; 1001 : 
; 1002 : 	if( PFD.cStencilBits != 0 )

	movzx	eax, BYTE PTR _PFD$[ebp+24]
	test	eax, eax
	je	SHORT $LN12@GL_SetPixe

; 1003 : 		glState.stencilEnabled = true;

	mov	DWORD PTR _glState+568, 1
	jmp	SHORT $LN13@GL_SetPixe
$LN12@GL_SetPixe:

; 1004 : 	else glState.stencilEnabled = false;

	mov	DWORD PTR _glState+568, 0
$LN13@GL_SetPixe:

; 1005 : 
; 1006 : 	// print out PFD specifics 
; 1007 : 	Con_Reportf( "PixelFormat: color: %d-bit, Z-Buffer: %d-bit, stencil: %d-bit\n", PFD.cColorBits, PFD.cDepthBits, PFD.cStencilBits );

	movzx	eax, BYTE PTR _PFD$[ebp+24]
	push	eax
	movzx	ecx, BYTE PTR _PFD$[ebp+23]
	push	ecx
	movzx	edx, BYTE PTR _PFD$[ebp+9]
	push	edx
	push	OFFSET ??_C@_0DP@HDFHNDFK@PixelFormat?3?5color?3?5?$CFd?9bit?0?5Z?9B@
	call	_Con_Reportf
	add	esp, 16					; 00000010H

; 1008 : 
; 1009 : 	return true;

	mov	eax, 1
$LN1@GL_SetPixe:

; 1010 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetPixelformat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_CreateFakeWindow
_TEXT	SEGMENT
tv67 = -164						; size = 4
_pixelFormat$ = -96					; size = 4
_pfd$ = -92						; size = 40
_wndClass$ = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_VID_CreateFakeWindow PROC				; COMDAT

; 842  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 843  : 	WNDCLASSEX		wndClass;
; 844  : 	PIXELFORMATDESCRIPTOR	pfd;
; 845  : 	int			pixelFormat;
; 846  : 
; 847  : 	// MSAA disabled
; 848  : 	if( !CVAR_TO_BOOL( gl_wgl_msaa_samples ))

	cmp	DWORD PTR _gl_wgl_msaa_samples, 0
	je	SHORT $LN11@VID_Create
	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@VID_Create
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN12@VID_Create
$LN11@VID_Create:
	mov	DWORD PTR tv67[ebp], 0
$LN12@VID_Create:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN2@VID_Create

; 849  : 		return;

	jmp	$LN1@VID_Create
$LN2@VID_Create:

; 850  : 
; 851  : 	memset( &wndClass, 0, sizeof( WNDCLASSEX ));

	push	48					; 00000030H
	push	0
	lea	eax, DWORD PTR _wndClass$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 852  : 	hGLRCFake = NULL;

	mov	DWORD PTR _hGLRCFake, 0

; 853  : 	hWndFake = NULL;

	mov	DWORD PTR _hWndFake, 0

; 854  : 	hDCFake = NULL;

	mov	DWORD PTR _hDCFake, 0

; 855  : 
; 856  : 	// register the window class
; 857  : 	wndClass.cbSize = sizeof( WNDCLASSEX );

	mov	DWORD PTR _wndClass$[ebp], 48		; 00000030H

; 858  : 	wndClass.lpfnWndProc = DefWindowProc;

	mov	eax, DWORD PTR __imp__DefWindowProcA@16
	mov	DWORD PTR _wndClass$[ebp+8], eax

; 859  : 	wndClass.hInstance = host.hInst;

	mov	eax, DWORD PTR _host
	mov	DWORD PTR _wndClass$[ebp+20], eax

; 860  : 	wndClass.lpszClassName = "TestWindow";

	mov	DWORD PTR _wndClass$[ebp+40], OFFSET ??_C@_0L@PCNPAMAE@TestWindow@

; 861  : 
; 862  : 	if( !RegisterClassEx( &wndClass ))

	lea	eax, DWORD PTR _wndClass$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExA@4
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN3@VID_Create

; 863  : 		return;

	jmp	$LN1@VID_Create
$LN3@VID_Create:

; 864  : 
; 865  : 	// Create the fake window
; 866  : 	if(( hWndFake = CreateWindowEx( 0, "TestWindow", "Xash3D", 0, 0, 0, 100, 100, NULL, NULL, wndClass.hInstance, NULL )) == NULL )

	push	0
	mov	eax, DWORD PTR _wndClass$[ebp+20]
	push	eax
	push	0
	push	0
	push	100					; 00000064H
	push	100					; 00000064H
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06EDNJMPJF@Xash3D@
	push	OFFSET ??_C@_0L@PCNPAMAE@TestWindow@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hWndFake, eax
	cmp	DWORD PTR _hWndFake, 0
	jne	SHORT $LN4@VID_Create

; 867  : 	{
; 868  : 		UnregisterClass( "TestWindow", wndClass.hInstance );

	mov	eax, DWORD PTR _wndClass$[ebp+20]
	push	eax
	push	OFFSET ??_C@_0L@PCNPAMAE@TestWindow@
	call	DWORD PTR __imp__UnregisterClassA@8

; 869  : 		return;

	jmp	$LN1@VID_Create
$LN4@VID_Create:

; 870  : 	}
; 871  : 
; 872  : 	// Get a DC for the fake window
; 873  : 	if(( hDCFake = GetDC( hWndFake )) == NULL )

	mov	eax, DWORD PTR _hWndFake
	push	eax
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDCFake, eax
	cmp	DWORD PTR _hDCFake, 0
	jne	SHORT $LN5@VID_Create

; 874  : 	{
; 875  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 876  : 		return;

	jmp	$LN1@VID_Create
$LN5@VID_Create:

; 877  : 	}
; 878  : 
; 879  : 	// Choose a pixel format
; 880  : 	memset( &pfd, 0, sizeof( PIXELFORMATDESCRIPTOR ));

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _pfd$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 881  : 
; 882  : 	pfd.nSize = sizeof( PIXELFORMATDESCRIPTOR );

	mov	eax, 40					; 00000028H
	mov	WORD PTR _pfd$[ebp], ax

; 883  : 	pfd.nVersion = 1;

	mov	eax, 1
	mov	WORD PTR _pfd$[ebp+2], ax

; 884  : 	pfd.dwFlags = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER;

	mov	DWORD PTR _pfd$[ebp+4], 37		; 00000025H

; 885  : 	pfd.iPixelType = PFD_TYPE_RGBA;

	mov	BYTE PTR _pfd$[ebp+8], 0

; 886  : 	pfd.iLayerType = PFD_MAIN_PLANE;

	mov	BYTE PTR _pfd$[ebp+26], 0

; 887  : 	pfd.cColorBits = 32;

	mov	BYTE PTR _pfd$[ebp+9], 32		; 00000020H

; 888  : 	pfd.cAlphaBits = 8;

	mov	BYTE PTR _pfd$[ebp+16], 8

; 889  : 	pfd.cDepthBits = 24;

	mov	BYTE PTR _pfd$[ebp+23], 24		; 00000018H

; 890  : 	pfd.cStencilBits = 8;

	mov	BYTE PTR _pfd$[ebp+24], 8

; 891  : 
; 892  : 	if(( pixelFormat = ChoosePixelFormat( hDCFake, &pfd )) == 0 )

	lea	eax, DWORD PTR _pfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	call	DWORD PTR __imp__ChoosePixelFormat@8
	mov	DWORD PTR _pixelFormat$[ebp], eax
	cmp	DWORD PTR _pixelFormat$[ebp], 0
	jne	SHORT $LN6@VID_Create

; 893  : 	{
; 894  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 895  : 		return;

	jmp	$LN1@VID_Create
$LN6@VID_Create:

; 896  : 	}
; 897  : 
; 898  : 	// Set the pixel format
; 899  : 	if( !SetPixelFormat( hDCFake, pixelFormat, &pfd ))

	lea	eax, DWORD PTR _pfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hDCFake
	push	edx
	call	DWORD PTR __imp__SetPixelFormat@12
	test	eax, eax
	jne	SHORT $LN7@VID_Create

; 900  : 	{
; 901  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 902  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN7@VID_Create:

; 903  : 	}
; 904  : 
; 905  : 	// Create the fake GL context
; 906  : 	if(( hGLRCFake = pwglCreateContext( hDCFake )) == NULL )

	mov	eax, DWORD PTR _hDCFake
	push	eax
	call	DWORD PTR _pwglCreateContext
	mov	DWORD PTR _hGLRCFake, eax
	cmp	DWORD PTR _hGLRCFake, 0
	jne	SHORT $LN8@VID_Create

; 907  : 	{
; 908  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 909  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN8@VID_Create:

; 910  : 	}
; 911  : 
; 912  : 	// Make the fake GL context current
; 913  : 	if( !pwglMakeCurrent( hDCFake, hGLRCFake ))

	mov	eax, DWORD PTR _hGLRCFake
	push	eax
	mov	ecx, DWORD PTR _hDCFake
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN9@VID_Create

; 914  : 	{
; 915  : 		VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow

; 916  : 		return;

	jmp	SHORT $LN1@VID_Create
$LN9@VID_Create:

; 917  : 	}
; 918  : 
; 919  : 	// We only need these function pointers if available
; 920  : 	pwglGetPixelFormatAttribiv = GL_GetProcAddress( "wglGetPixelFormatAttribivARB" );

	push	OFFSET ??_C@_0BN@GDKHKIAN@wglGetPixelFormatAttribivARB@
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglGetPixelFormatAttribiv, eax

; 921  : 	pwglChoosePixelFormat = GL_GetProcAddress( "wglChoosePixelFormatARB" );

	push	OFFSET ??_C@_0BI@JPMGGILH@wglChoosePixelFormatARB@
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglChoosePixelFormat, eax

; 922  : 
; 923  : 	// destroy now it's no longer needed
; 924  : 	VID_DestroyFakeWindow();

	call	_VID_DestroyFakeWindow
$LN1@VID_Create:

; 925  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CreateFakeWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_DestroyFakeWindow
_TEXT	SEGMENT
_VID_DestroyFakeWindow PROC				; COMDAT

; 814  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 815  : 	if( hGLRCFake )

	cmp	DWORD PTR _hGLRCFake, 0
	je	SHORT $LN2@VID_Destro

; 816  : 	{
; 817  : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent

; 818  : 		pwglDeleteContext( hGLRCFake );

	mov	eax, DWORD PTR _hGLRCFake
	push	eax
	call	DWORD PTR _pwglDeleteContext

; 819  : 		hGLRCFake = NULL;

	mov	DWORD PTR _hGLRCFake, 0
$LN2@VID_Destro:

; 820  : 	}
; 821  : 
; 822  : 	if( hDCFake )

	cmp	DWORD PTR _hDCFake, 0
	je	SHORT $LN3@VID_Destro

; 823  : 	{
; 824  : 		ReleaseDC( hWndFake, hDCFake );

	mov	eax, DWORD PTR _hDCFake
	push	eax
	mov	ecx, DWORD PTR _hWndFake
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8

; 825  : 		hDCFake = NULL;

	mov	DWORD PTR _hDCFake, 0
$LN3@VID_Destro:

; 826  : 	}
; 827  : 
; 828  : 	if( hWndFake )

	cmp	DWORD PTR _hWndFake, 0
	je	SHORT $LN1@VID_Destro

; 829  : 	{
; 830  : 		DestroyWindow( hWndFake );

	mov	eax, DWORD PTR _hWndFake
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 831  : 		UnregisterClass( "TestWindow", host.hInst );

	mov	eax, DWORD PTR _host
	push	eax
	push	OFFSET ??_C@_0L@PCNPAMAE@TestWindow@
	call	DWORD PTR __imp__UnregisterClassA@8

; 832  : 		hWndFake = NULL;

	mov	DWORD PTR _hWndFake, 0
$LN1@VID_Destro:

; 833  : 	}
; 834  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_DestroyFakeWindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_StartupGamma
_TEXT	SEGMENT
_VID_StartupGamma PROC					; COMDAT

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 777  : 	BuildGammaTable( vid_gamma->value, vid_brightness->value );

	mov	eax, DWORD PTR _vid_brightness
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vid_gamma
	push	ecx
	movss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp], xmm0
	call	_BuildGammaTable
	add	esp, 8

; 778  : 	Con_Reportf( "VID_StartupGamma: gamma %g brightness %g\n", vid_gamma->value, vid_brightness->value );

	mov	eax, DWORD PTR _vid_brightness
	cvtss2sd xmm0, DWORD PTR [eax+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vid_gamma
	cvtss2sd xmm0, DWORD PTR [ecx+12]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CK@KPMKNLJO@VID_StartupGamma?3?5gamma?5?$CFg?5brig@
	call	_Con_Reportf
	add	esp, 20					; 00000014H

; 779  : 	ClearBits( vid_brightness->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_brightness
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_brightness
	mov	DWORD PTR [edx+8], ecx

; 780  : 	ClearBits( vid_gamma->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _vid_gamma
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _vid_gamma
	mov	DWORD PTR [edx+8], ecx

; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_StartupGamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_ChoosePFD
_TEXT	SEGMENT
tv150 = -180						; size = 4
tv149 = -176						; size = 4
_attribs$1 = -108					; size = 96
_pixelFormat$2 = -12					; size = 4
_numPixelFormats$3 = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pfd$ = 8						; size = 4
_colorBits$ = 12					; size = 4
_alphaBits$ = 16					; size = 4
_depthBits$ = 20					; size = 4
_stencilBits$ = 24					; size = 4
_VID_ChoosePFD PROC					; COMDAT

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 689  : 	if( pwglChoosePixelFormat != NULL )

	cmp	DWORD PTR _pwglChoosePixelFormat, 0
	je	$LN3@VID_Choose

; 690  : 	{
; 691  : 		UINT	numPixelFormats;
; 692  : 		int	pixelFormat = 0;

	mov	DWORD PTR _pixelFormat$2[ebp], 0

; 693  : 		int	attribs[24];
; 694  : 
; 695  : 		attribs[0] = WGL_ACCELERATION_ARB;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _attribs$1[ebp+ecx], 8195	; 00002003H

; 696  : 		attribs[1] = WGL_FULL_ACCELERATION_ARB;

	mov	eax, 4
	shl	eax, 0
	mov	DWORD PTR _attribs$1[ebp+eax], 8231	; 00002027H

; 697  : 		attribs[2] = WGL_DRAW_TO_WINDOW_ARB;

	mov	eax, 4
	shl	eax, 1
	mov	DWORD PTR _attribs$1[ebp+eax], 8193	; 00002001H

; 698  : 		attribs[3] = TRUE;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	DWORD PTR _attribs$1[ebp+ecx], 1

; 699  : 		attribs[4] = WGL_SUPPORT_OPENGL_ARB;

	mov	eax, 4
	shl	eax, 2
	mov	DWORD PTR _attribs$1[ebp+eax], 8208	; 00002010H

; 700  : 		attribs[5] = TRUE;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	DWORD PTR _attribs$1[ebp+ecx], 1

; 701  : 		attribs[6] = WGL_DOUBLE_BUFFER_ARB;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	DWORD PTR _attribs$1[ebp+ecx], 8209	; 00002011H

; 702  : 		attribs[7] = TRUE;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	DWORD PTR _attribs$1[ebp+ecx], 1

; 703  : 		attribs[8] = WGL_PIXEL_TYPE_ARB;

	mov	eax, 4
	shl	eax, 3
	mov	DWORD PTR _attribs$1[ebp+eax], 8211	; 00002013H

; 704  : 		attribs[9] = WGL_TYPE_RGBA_ARB;

	mov	eax, 4
	imul	ecx, eax, 9
	mov	DWORD PTR _attribs$1[ebp+ecx], 8235	; 0000202bH

; 705  : 		attribs[10] = WGL_COLOR_BITS_ARB;

	mov	eax, 4
	imul	ecx, eax, 10
	mov	DWORD PTR _attribs$1[ebp+ecx], 8212	; 00002014H

; 706  : 		attribs[11] = colorBits;

	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _colorBits$[ebp]
	mov	DWORD PTR _attribs$1[ebp+ecx], edx

; 707  : 		attribs[12] = WGL_ALPHA_BITS_ARB;

	mov	eax, 4
	imul	ecx, eax, 12
	mov	DWORD PTR _attribs$1[ebp+ecx], 8219	; 0000201bH

; 708  : 		attribs[13] = alphaBits;

	mov	eax, 4
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _alphaBits$[ebp]
	mov	DWORD PTR _attribs$1[ebp+ecx], edx

; 709  : 		attribs[14] = WGL_DEPTH_BITS_ARB;

	mov	eax, 4
	imul	ecx, eax, 14
	mov	DWORD PTR _attribs$1[ebp+ecx], 8226	; 00002022H

; 710  : 		attribs[15] = depthBits;

	mov	eax, 4
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _depthBits$[ebp]
	mov	DWORD PTR _attribs$1[ebp+ecx], edx

; 711  : 		attribs[16] = WGL_STENCIL_BITS_ARB;

	mov	eax, 4
	shl	eax, 4
	mov	DWORD PTR _attribs$1[ebp+eax], 8227	; 00002023H

; 712  : 		attribs[17] = stencilBits;

	mov	eax, 4
	imul	ecx, eax, 17
	mov	edx, DWORD PTR _stencilBits$[ebp]
	mov	DWORD PTR _attribs$1[ebp+ecx], edx

; 713  : 		attribs[18] = WGL_SAMPLE_BUFFERS_ARB;

	mov	eax, 4
	imul	ecx, eax, 18
	mov	DWORD PTR _attribs$1[ebp+ecx], 8257	; 00002041H

; 714  : 		attribs[19] = TRUE;

	mov	eax, 4
	imul	ecx, eax, 19
	mov	DWORD PTR _attribs$1[ebp+ecx], 1

; 715  : 		attribs[20] = WGL_SAMPLES_ARB;

	mov	eax, 4
	imul	ecx, eax, 20
	mov	DWORD PTR _attribs$1[ebp+ecx], 8258	; 00002042H

; 716  : 		attribs[21] = bound( 1, (int)gl_wgl_msaa_samples->value, 16 );

	mov	eax, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si ecx, DWORD PTR [eax+12]
	cmp	ecx, 1
	jl	SHORT $LN8@VID_Choose
	mov	edx, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si eax, DWORD PTR [edx+12]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN6@VID_Choose
	mov	ecx, DWORD PTR _gl_wgl_msaa_samples
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN7@VID_Choose
$LN6@VID_Choose:
	mov	DWORD PTR tv149[ebp], 16		; 00000010H
$LN7@VID_Choose:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN9@VID_Choose
$LN8@VID_Choose:
	mov	DWORD PTR tv150[ebp], 1
$LN9@VID_Choose:
	mov	ecx, 4
	imul	edx, ecx, 21
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR _attribs$1[ebp+edx], eax

; 717  : 		attribs[22] = 0;

	mov	eax, 4
	imul	ecx, eax, 22
	mov	DWORD PTR _attribs$1[ebp+ecx], 0

; 718  : 		attribs[23] = 0;

	mov	eax, 4
	imul	ecx, eax, 23
	mov	DWORD PTR _attribs$1[ebp+ecx], 0

; 719  : 
; 720  : 		pwglChoosePixelFormat( glw_state.hDC, attribs, NULL, 1, &pixelFormat, &numPixelFormats );

	lea	eax, DWORD PTR _numPixelFormats$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _pixelFormat$2[ebp]
	push	ecx
	push	1
	push	0
	lea	edx, DWORD PTR _attribs$1[ebp]
	push	edx
	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglChoosePixelFormat

; 721  : 
; 722  : 		if( pixelFormat )

	cmp	DWORD PTR _pixelFormat$2[ebp], 0
	je	SHORT $LN3@VID_Choose

; 723  : 		{
; 724  : 			attribs[0] = WGL_SAMPLES_ARB;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _attribs$1[ebp+ecx], 8258	; 00002042H

; 725  : 			pwglGetPixelFormatAttribiv( glw_state.hDC, pixelFormat, 0, 1, attribs, &glConfig.max_multisamples );

	push	OFFSET _glConfig+96
	lea	eax, DWORD PTR _attribs$1[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _pixelFormat$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _glw_state
	push	edx
	call	DWORD PTR _pwglGetPixelFormatAttribiv

; 726  : 			if( glConfig.max_multisamples <= 1 ) Con_DPrintf( S_WARN "MSAA is not allowed\n" );

	cmp	DWORD PTR _glConfig+96, 1
	jg	SHORT $LN4@VID_Choose
	push	OFFSET ??_C@_0CC@JALKLIBM@?$FO3Warning?3?$FO7?5MSAA?5is?5not?5allowe@
	call	_Con_DPrintf
	add	esp, 4
$LN4@VID_Choose:

; 727  : 
; 728  : 			return pixelFormat;

	mov	eax, DWORD PTR _pixelFormat$2[ebp]
	jmp	$LN1@VID_Choose
$LN3@VID_Choose:

; 729  : 		}
; 730  : 	}
; 731  : 
; 732  : 	// fallback: fill out the PFD
; 733  : 	pfd->nSize = sizeof (PIXELFORMATDESCRIPTOR);

	mov	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	WORD PTR [ecx], ax

; 734  : 	pfd->nVersion = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _pfd$[ebp]
	mov	WORD PTR [ecx+2], ax

; 735  : 	pfd->dwFlags = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [eax+4], 37			; 00000025H

; 736  : 	pfd->iPixelType = PFD_TYPE_RGBA;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+8], 0

; 737  : 
; 738  : 	pfd->cColorBits = colorBits;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	cl, BYTE PTR _colorBits$[ebp]
	mov	BYTE PTR [eax+9], cl

; 739  : 	pfd->cRedBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+10], 0

; 740  : 	pfd->cRedShift = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+11], 0

; 741  : 	pfd->cGreenBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+12], 0

; 742  : 	pfd->cGreenShift = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+13], 0

; 743  : 	pfd->cBlueBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+14], 0

; 744  : 	pfd->cBlueShift = 0;	// wow! Blue Shift %)

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+15], 0

; 745  : 
; 746  : 	pfd->cAlphaBits = alphaBits;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	cl, BYTE PTR _alphaBits$[ebp]
	mov	BYTE PTR [eax+16], cl

; 747  : 	pfd->cAlphaShift = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+17], 0

; 748  : 
; 749  : 	pfd->cAccumBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+18], 0

; 750  : 	pfd->cAccumRedBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+19], 0

; 751  : 	pfd->cAccumGreenBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+20], 0

; 752  : 	pfd->cAccumBlueBits = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+21], 0

; 753  : 	pfd->cAccumAlphaBits= 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+22], 0

; 754  : 
; 755  : 	pfd->cDepthBits = depthBits;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	cl, BYTE PTR _depthBits$[ebp]
	mov	BYTE PTR [eax+23], cl

; 756  : 	pfd->cStencilBits = stencilBits;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	cl, BYTE PTR _stencilBits$[ebp]
	mov	BYTE PTR [eax+24], cl

; 757  : 
; 758  : 	pfd->cAuxBuffers = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+25], 0

; 759  : 	pfd->iLayerType = PFD_MAIN_PLANE;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+26], 0

; 760  : 	pfd->bReserved = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	BYTE PTR [eax+27], 0

; 761  : 
; 762  : 	pfd->dwLayerMask = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [eax+28], 0

; 763  : 	pfd->dwVisibleMask = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [eax+32], 0

; 764  : 	pfd->dwDamageMask = 0;

	mov	eax, DWORD PTR _pfd$[ebp]
	mov	DWORD PTR [eax+36], 0

; 765  : 
; 766  : 	// count PFDs
; 767  : 	return ChoosePixelFormat( glw_state.hDC, pfd );

	mov	eax, DWORD PTR _pfd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR __imp__ChoosePixelFormat@8
$LN1@VID_Choose:

; 768  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_ChoosePFD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_UpdateContext
_TEXT	SEGMENT
_GL_UpdateContext PROC					; COMDAT

; 647  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 648  : 	if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN2@GL_UpdateC

; 649  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	SHORT $LN1@GL_UpdateC
$LN2@GL_UpdateC:

; 650  : 
; 651  : 	return true;

	mov	eax, 1
$LN1@GL_UpdateC:

; 652  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UpdateContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_CreateContext
_TEXT	SEGMENT
_attribs$1 = -52					; size = 36
_arb_flags$ = -16					; size = 4
_profile_mask$ = -12					; size = 4
_hBaseRC$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_GL_CreateContext PROC					; COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 581  : 	HGLRC	hBaseRC;
; 582  : 	int	profile_mask;
; 583  : 	int	arb_flags;
; 584  : 
; 585  : 	glw_state.extended = false;

	mov	DWORD PTR _glw_state+24, 0

; 586  : 
; 587  : 	if(!( glw_state.hGLRC = pwglCreateContext( glw_state.hDC )))

	mov	eax, DWORD PTR _glw_state
	push	eax
	call	DWORD PTR _pwglCreateContext
	mov	DWORD PTR _glw_state+4, eax
	cmp	DWORD PTR _glw_state+4, 0
	jne	SHORT $LN2@GL_CreateC

; 588  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	$LN1@GL_CreateC
$LN2@GL_CreateC:

; 589  : 
; 590  : 	if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN3@GL_CreateC

; 591  : 		return GL_DeleteContext();

	call	_GL_DeleteContext
	jmp	$LN1@GL_CreateC
$LN3@GL_CreateC:

; 592  : 
; 593  : 	if( !context_flags ) // debug bit kill the perfomance

	cmp	DWORD PTR _context_flags, 0
	jne	SHORT $LN4@GL_CreateC

; 594  : 		return true;

	mov	eax, 1
	jmp	$LN1@GL_CreateC
$LN4@GL_CreateC:

; 595  : 
; 596  : 	pwglCreateContextAttribsARB = GL_GetProcAddress( "wglCreateContextAttribsARB" );

	push	OFFSET ??_C@_0BL@PDDHMPGF@wglCreateContextAttribsARB@
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR _pwglCreateContextAttribsARB, eax

; 597  : 
; 598  : 	profile_mask = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;

	mov	DWORD PTR _profile_mask$[ebp], 2

; 599  : 
; 600  : 	if( FBitSet( context_flags, FCONTEXT_DEBUG_ARB ))

	mov	eax, DWORD PTR _context_flags
	and	eax, 1
	je	SHORT $LN5@GL_CreateC

; 601  : 		arb_flags = WGL_CONTEXT_DEBUG_BIT_ARB;

	mov	DWORD PTR _arb_flags$[ebp], 1
	jmp	SHORT $LN6@GL_CreateC
$LN5@GL_CreateC:

; 602  : 	else arb_flags = 0;

	mov	DWORD PTR _arb_flags$[ebp], 0
$LN6@GL_CreateC:

; 603  : 
; 604  : 	if( pwglCreateContextAttribsARB != NULL )

	cmp	DWORD PTR _pwglCreateContextAttribsARB, 0
	je	$LN7@GL_CreateC

; 605  : 	{
; 606  : 		int attribs[] =

	mov	DWORD PTR _attribs$1[ebp], 8337		; 00002091H
	mov	DWORD PTR _attribs$1[ebp+4], 2
	mov	DWORD PTR _attribs$1[ebp+8], 8338	; 00002092H
	mov	DWORD PTR _attribs$1[ebp+12], 0
	mov	DWORD PTR _attribs$1[ebp+16], 8340	; 00002094H
	mov	eax, DWORD PTR _arb_flags$[ebp]
	mov	DWORD PTR _attribs$1[ebp+20], eax
	mov	DWORD PTR _attribs$1[ebp+24], 37158	; 00009126H
	mov	eax, DWORD PTR _profile_mask$[ebp]
	mov	DWORD PTR _attribs$1[ebp+28], eax
	mov	DWORD PTR _attribs$1[ebp+32], 0

; 607  : 		{
; 608  : 		WGL_CONTEXT_MAJOR_VERSION_ARB, 2,
; 609  : 		WGL_CONTEXT_MINOR_VERSION_ARB, 0,
; 610  : 		WGL_CONTEXT_FLAGS_ARB, arb_flags,         
; 611  : 		WGL_CONTEXT_PROFILE_MASK_ARB, profile_mask,
; 612  : 		0
; 613  : 		};
; 614  : 
; 615  : 		hBaseRC = glw_state.hGLRC; // backup

	mov	eax, DWORD PTR _glw_state+4
	mov	DWORD PTR _hBaseRC$[ebp], eax

; 616  : 		glw_state.hGLRC = NULL;

	mov	DWORD PTR _glw_state+4, 0

; 617  : 
; 618  : 		if( !( glw_state.hGLRC = pwglCreateContextAttribsARB( glw_state.hDC, NULL, attribs )))

	lea	eax, DWORD PTR _attribs$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglCreateContextAttribsARB
	mov	DWORD PTR _glw_state+4, eax
	cmp	DWORD PTR _glw_state+4, 0
	jne	SHORT $LN8@GL_CreateC

; 619  : 		{
; 620  : 			glw_state.hGLRC = hBaseRC;

	mov	eax, DWORD PTR _hBaseRC$[ebp]
	mov	DWORD PTR _glw_state+4, eax

; 621  : 			GL_ContextError();

	call	_GL_ContextError

; 622  : 			return true; // just use old context

	mov	eax, 1
	jmp	SHORT $LN1@GL_CreateC
$LN8@GL_CreateC:

; 623  : 		}
; 624  : 
; 625  : 		if(!( pwglMakeCurrent( glw_state.hDC, glw_state.hGLRC )))

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	mov	ecx, DWORD PTR _glw_state
	push	ecx
	call	DWORD PTR _pwglMakeCurrent
	test	eax, eax
	jne	SHORT $LN9@GL_CreateC

; 626  : 		{
; 627  : 			pwglDeleteContext( glw_state.hGLRC );

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	call	DWORD PTR _pwglDeleteContext

; 628  : 			glw_state.hGLRC = hBaseRC;

	mov	eax, DWORD PTR _hBaseRC$[ebp]
	mov	DWORD PTR _glw_state+4, eax

; 629  : 			GL_ContextError();

	call	_GL_ContextError

; 630  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@GL_CreateC
$LN9@GL_CreateC:

; 631  : 		}
; 632  : 
; 633  : 		Con_Reportf( "GL_CreateContext: using extended context\n" );

	push	OFFSET ??_C@_0CK@GLCIJGDL@GL_CreateContext?3?5using?5extende@
	call	_Con_Reportf
	add	esp, 4

; 634  : 		pwglDeleteContext( hBaseRC );	// release first context

	mov	eax, DWORD PTR _hBaseRC$[ebp]
	push	eax
	call	DWORD PTR _pwglDeleteContext

; 635  : 		glw_state.extended = true;

	mov	DWORD PTR _glw_state+24, 1
$LN7@GL_CreateC:

; 636  : 	}
; 637  : 
; 638  : 	return true;

	mov	eax, 1
$LN1@GL_CreateC:

; 639  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_ContextError
_TEXT	SEGMENT
_error$ = -4						; size = 4
_GL_ContextError PROC					; COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 555  : 	DWORD error = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _error$[ebp], eax

; 556  : 
; 557  : 	if( error == ( 0xc0070000|ERROR_INVALID_VERSION_ARB ))

	cmp	DWORD PTR _error$[ebp], -1073274731	; c0072095H
	jne	SHORT $LN2@GL_Context

; 558  : 		Con_Printf( S_ERROR "Unsupported OpenGL context version (%s).\n", "2.0" );

	push	OFFSET ??_C@_03GJAMENNA@2?40@
	push	OFFSET ??_C@_0DF@KEPFMKAK@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5c@
	call	_Con_Printf
	add	esp, 8
	jmp	$LN1@GL_Context
$LN2@GL_Context:

; 559  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PROFILE_ARB ))

	cmp	DWORD PTR _error$[ebp], -1073274730	; c0072096H
	jne	SHORT $LN4@GL_Context

; 560  : 		Con_Printf( S_ERROR "Unsupported OpenGL profile (%s).\n", "compat" );

	push	OFFSET ??_C@_06CJLEMFPD@compat@
	push	OFFSET ??_C@_0CN@NLIAMNMI@?$FO1Error?3?$FO7?5Unsupported?5OpenGL?5p@
	call	_Con_Printf
	add	esp, 8
	jmp	$LN1@GL_Context
$LN4@GL_Context:

; 561  : 	else if( error == ( 0xc0070000|ERROR_INVALID_OPERATION ))

	cmp	DWORD PTR _error$[ebp], -1073278755	; c00710ddH
	jne	SHORT $LN6@GL_Context

; 562  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned invalid operation.\n" );

	push	OFFSET ??_C@_0ED@EKEJBCOE@?$FO1Error?3?$FO7?5wglCreateContextAttr@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN6@GL_Context:

; 563  : 	else if( error == ( 0xc0070000|ERROR_DC_NOT_FOUND ))

	cmp	DWORD PTR _error$[ebp], -1073281647	; c0070591H
	jne	SHORT $LN8@GL_Context

; 564  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned dc not found.\n" );

	push	OFFSET ??_C@_0DO@JHBJBKGE@?$FO1Error?3?$FO7?5wglCreateContextAttr@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN8@GL_Context:

; 565  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PIXEL_FORMAT ))

	cmp	DWORD PTR _error$[ebp], -1073281072	; c00707d0H
	jne	SHORT $LN10@GL_Context

; 566  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB returned dc not found.\n" );

	push	OFFSET ??_C@_0DO@JHBJBKGE@?$FO1Error?3?$FO7?5wglCreateContextAttr@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN10@GL_Context:

; 567  : 	else if( error == ( 0xc0070000|ERROR_NO_SYSTEM_RESOURCES ))

	cmp	DWORD PTR _error$[ebp], -1073281622	; c00705aaH
	jne	SHORT $LN12@GL_Context

; 568  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB ran out of system resources.\n" );

	push	OFFSET ??_C@_0EE@JKMNHAKF@?$FO1Error?3?$FO7?5wglCreateContextAttr@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN12@GL_Context:

; 569  : 	else if( error == ( 0xc0070000|ERROR_INVALID_PARAMETER ))

	cmp	DWORD PTR _error$[ebp], -1073282985	; c0070057H
	jne	SHORT $LN14@GL_Context

; 570  : 		Con_Printf( S_ERROR "wglCreateContextAttribsARB reported invalid parameter.\n" );

	push	OFFSET ??_C@_0ED@INJOCFND@?$FO1Error?3?$FO7?5wglCreateContextAttr@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN1@GL_Context
$LN14@GL_Context:

; 571  : 	else Con_Printf( S_ERROR "Unknown error creating an OpenGL (%s) Context.\n", "2.0" );

	push	OFFSET ??_C@_03GJAMENNA@2?40@
	push	OFFSET ??_C@_0DL@OJIHOIAO@?$FO1Error?3?$FO7?5Unknown?5error?5creati@
	call	_Con_Printf
	add	esp, 8
$LN1@GL_Context:

; 572  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ContextError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_SetDefaultState
_TEXT	SEGMENT
_GL_SetDefaultState PROC				; COMDAT

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 537  : 	memset( &glState, 0, sizeof( glState ));

	push	576					; 00000240H
	push	0
	push	OFFSET _glState
	call	_memset
	add	esp, 12					; 0000000cH

; 538  : 	GL_SetDefaultTexState ();

	call	_GL_SetDefaultTexState

; 539  : 
; 540  : 	if( Sys_CheckParm( "-gldebug" ))

	push	OFFSET ??_C@_08NHGONMLE@?9gldebug@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@GL_SetDefa

; 541  : 		SetBits( context_flags, FCONTEXT_DEBUG_ARB );

	mov	eax, DWORD PTR _context_flags
	or	eax, 1
	mov	DWORD PTR _context_flags, eax
$LN2@GL_SetDefa:

; 542  : 
; 543  : 	// init draw stack
; 544  : 	tr.draw_list = &tr.draw_stack[0];

	mov	eax, 24588				; 0000600cH
	imul	ecx, eax, 0
	add	ecx, OFFSET _tr+17612
	mov	DWORD PTR _tr+66792, ecx

; 545  : 	tr.draw_stack_pos = 0;

	mov	DWORD PTR _tr+66788, 0

; 546  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetDefaultState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_SetDefaultTexState
_TEXT	SEGMENT
_i$ = -4						; size = 4
_GL_SetDefaultTexState PROC				; COMDAT

; 516  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 517  : 	int	i;
; 518  : 
; 519  : 	memset( glState.currentTextures, -1, MAX_TEXTURE_UNITS * sizeof( *glState.currentTextures ));

	push	128					; 00000080H
	push	-1
	push	OFFSET _glState+20
	call	_memset
	add	esp, 12					; 0000000cH

; 520  : 	memset( glState.texCoordArrayMode, 0, MAX_TEXTURE_UNITS * sizeof( *glState.texCoordArrayMode ));

	push	128					; 00000080H
	push	0
	push	OFFSET _glState+436
	call	_memset
	add	esp, 12					; 0000000cH

; 521  : 	memset( glState.genSTEnabled, 0, MAX_TEXTURE_UNITS * sizeof( *glState.genSTEnabled ));

	push	128					; 00000080H
	push	0
	push	OFFSET _glState+308
	call	_memset
	add	esp, 12					; 0000000cH

; 522  : 
; 523  : 	for( i = 0; i < MAX_TEXTURE_UNITS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_SetDefa
$LN2@GL_SetDefa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_SetDefa:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN1@GL_SetDefa

; 524  : 	{
; 525  : 		glState.currentTextureTargets[i] = GL_NONE;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _glState[eax*4+148], 0

; 526  : 		glState.texIdentityMatrix[i] = true;

	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _glState[eax+276], 1

; 527  : 	}

	jmp	SHORT $LN2@GL_SetDefa
$LN1@GL_SetDefa:

; 528  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetDefaultTexState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_CheckExtension
_TEXT	SEGMENT
tv163 = -80						; size = 4
tv86 = -80						; size = 4
tv81 = -80						; size = 4
_extensions_string$ = -12				; size = 4
_parm$ = -8						; size = 4
_func$ = -4						; size = 4
_name$ = 8						; size = 4
_funcs$ = 12						; size = 4
_cvarname$ = 16						; size = 4
_r_ext$ = 20						; size = 4
_GL_CheckExtension PROC					; COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 439  : 	const dllfunc_t	*func;
; 440  : 	convar_t		*parm = NULL;

	mov	DWORD PTR _parm$[ebp], 0

; 441  : 	const char	*extensions_string;
; 442  : 
; 443  : 	Con_Reportf( "GL_CheckExtension: %s ", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@HNGPIHKB@GL_CheckExtension?3?5?$CFs?5@
	call	_Con_Reportf
	add	esp, 8

; 444  : 	GL_SetExtension( r_ext, true );

	push	1
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8

; 445  : 
; 446  : 	if( cvarname )

	cmp	DWORD PTR _cvarname$[ebp], 0
	je	SHORT $LN8@GL_CheckEx

; 447  : 	{
; 448  : 		// system config disable extensions
; 449  : 		parm = Cvar_Get( cvarname, "1", FCVAR_GLCONFIG, va( CVAR_GLCONFIG_DESCRIPTION, name ));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@LNHHFBOI@enable?5or?5disable?5?$CFs@
	call	_va
	add	esp, 8
	push	eax
	push	4096					; 00001000H
	push	OFFSET ??_C@_01HIHLOKLC@1@
	mov	ecx, DWORD PTR _cvarname$[ebp]
	push	ecx
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _parm$[ebp], eax
$LN8@GL_CheckEx:

; 450  :           }
; 451  : 
; 452  : 	if(( parm && !CVAR_TO_BOOL( parm )) || ( !CVAR_TO_BOOL( gl_extensions ) && r_ext != GL_OPENGL_110 ))

	cmp	DWORD PTR _parm$[ebp], 0
	je	SHORT $LN11@GL_CheckEx
	cmp	DWORD PTR _parm$[ebp], 0
	je	SHORT $LN19@GL_CheckEx
	mov	eax, DWORD PTR _parm$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@GL_CheckEx
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN20@GL_CheckEx
$LN19@GL_CheckEx:
	mov	DWORD PTR tv81[ebp], 0
$LN20@GL_CheckEx:
	cmp	DWORD PTR tv81[ebp], 0
	je	SHORT $LN10@GL_CheckEx
$LN11@GL_CheckEx:
	cmp	DWORD PTR _gl_extensions, 0
	je	SHORT $LN21@GL_CheckEx
	mov	eax, DWORD PTR _gl_extensions
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@GL_CheckEx
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN22@GL_CheckEx
$LN21@GL_CheckEx:
	mov	DWORD PTR tv86[ebp], 0
$LN22@GL_CheckEx:
	cmp	DWORD PTR tv86[ebp], 0
	jne	SHORT $LN9@GL_CheckEx
	cmp	DWORD PTR _r_ext$[ebp], 0
	je	SHORT $LN9@GL_CheckEx
$LN10@GL_CheckEx:

; 453  : 	{
; 454  : 		Con_Reportf( "- disabled\n" );

	push	OFFSET ??_C@_0M@DMNJGNM@?9?5disabled?6@
	call	_Con_Reportf
	add	esp, 4

; 455  : 		GL_SetExtension( r_ext, false );

	push	0
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8

; 456  : 		return; // nothing to process at

	jmp	$LN17@GL_CheckEx
$LN9@GL_CheckEx:

; 457  : 	}
; 458  : 
; 459  : 	extensions_string = glConfig.extensions_string; 

	mov	eax, DWORD PTR _glConfig+16
	mov	DWORD PTR _extensions_string$[ebp], eax

; 460  : 
; 461  : 	if( name[0] == 'W' && name[1] == 'G' && name[2] == 'L' && glConfig.wgl_extensions_string != NULL )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 87					; 00000057H
	jne	SHORT $LN12@GL_CheckEx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 71					; 00000047H
	jne	SHORT $LN12@GL_CheckEx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN12@GL_CheckEx
	cmp	DWORD PTR _glConfig+20, 0
	je	SHORT $LN12@GL_CheckEx

; 462  : 		extensions_string = glConfig.wgl_extensions_string;

	mov	eax, DWORD PTR _glConfig+20
	mov	DWORD PTR _extensions_string$[ebp], eax
$LN12@GL_CheckEx:

; 463  : 
; 464  : 	if(( name[2] == '_' || name[3] == '_' ) && !Q_strstr( extensions_string, name ))

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _name$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 95					; 0000005fH
	je	SHORT $LN14@GL_CheckEx
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _name$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 95					; 0000005fH
	jne	SHORT $LN13@GL_CheckEx
$LN14@GL_CheckEx:
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _extensions_string$[ebp]
	push	ecx
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@GL_CheckEx

; 465  : 	{
; 466  : 		GL_SetExtension( r_ext, false );	// update render info

	push	0
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8

; 467  : 		Con_Reportf( "- ^1failed\n" );

	push	OFFSET ??_C@_0M@OLAKKIMP@?9?5?$FO1failed?6@
	call	_Con_Reportf
	add	esp, 4

; 468  : 		return;

	jmp	$LN17@GL_CheckEx
$LN13@GL_CheckEx:

; 469  : 	}
; 470  : 
; 471  : 	// clear exports
; 472  : 	for( func = funcs; func && func->name; func++ )

	mov	eax, DWORD PTR _funcs$[ebp]
	mov	DWORD PTR _func$[ebp], eax
	jmp	SHORT $LN4@GL_CheckEx
$LN2@GL_CheckEx:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN4@GL_CheckEx:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN3@GL_CheckEx
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@GL_CheckEx

; 473  : 		*func->func = NULL;

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@GL_CheckEx
$LN3@GL_CheckEx:

; 474  : 
; 475  : 	for( func = funcs; func && func->name != NULL; func++ )

	mov	eax, DWORD PTR _funcs$[ebp]
	mov	DWORD PTR _func$[ebp], eax
	jmp	SHORT $LN7@GL_CheckEx
$LN5@GL_CheckEx:
	mov	eax, DWORD PTR _func$[ebp]
	add	eax, 8
	mov	DWORD PTR _func$[ebp], eax
$LN7@GL_CheckEx:
	cmp	DWORD PTR _func$[ebp], 0
	je	SHORT $LN6@GL_CheckEx
	mov	eax, DWORD PTR _func$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@GL_CheckEx

; 476  : 	{
; 477  : 		// functions are cleared before all the extensions are evaluated
; 478  : 		if((*func->func = (void *)GL_GetProcAddress( func->name )) == NULL )

	mov	eax, DWORD PTR _func$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_GL_GetProcAddress
	add	esp, 4
	mov	DWORD PTR tv163[ebp], eax
	mov	edx, DWORD PTR _func$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR tv163[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR tv163[ebp], 0
	jne	SHORT $LN15@GL_CheckEx

; 479  : 			GL_SetExtension( r_ext, false ); // one or more functions are invalid, extension will be disabled

	push	0
	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_SetExtension
	add	esp, 8
$LN15@GL_CheckEx:

; 480  : 	}

	jmp	SHORT $LN5@GL_CheckEx
$LN6@GL_CheckEx:

; 481  : 
; 482  : 	if( GL_Support( r_ext ))

	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@GL_CheckEx

; 483  : 		Con_Reportf( "- ^2enabled\n" );

	push	OFFSET ??_C@_0N@EEFGEEA@?9?5?$FO2enabled?6@
	call	_Con_Reportf
	add	esp, 4
	jmp	SHORT $LN17@GL_CheckEx
$LN16@GL_CheckEx:

; 484  : 	else Con_Reportf( "- ^1failed\n" );

	push	OFFSET ??_C@_0M@OLAKKIMP@?9?5?$FO1failed?6@
	call	_Con_Reportf
	add	esp, 4
$LN17@GL_CheckEx:

; 485  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_SetExtension
_TEXT	SEGMENT
tv69 = -68						; size = 4
_r_ext$ = 8						; size = 4
_enable$ = 12						; size = 4
_GL_SetExtension PROC					; COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 385  : 	if( r_ext >= 0 && r_ext < GL_EXTCOUNT )

	cmp	DWORD PTR _r_ext$[ebp], 0
	jl	SHORT $LN2@GL_SetExte
	cmp	DWORD PTR _r_ext$[ebp], 22		; 00000016H
	jge	SHORT $LN2@GL_SetExte

; 386  : 		glConfig.extension[r_ext] = enable ? GL_TRUE : GL_FALSE;

	cmp	DWORD PTR _enable$[ebp], 0
	je	SHORT $LN5@GL_SetExte
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@GL_SetExte
$LN5@GL_SetExte:
	mov	DWORD PTR tv69[ebp], 0
$LN6@GL_SetExte:
	mov	eax, DWORD PTR _r_ext$[ebp]
	mov	cl, BYTE PTR tv69[ebp]
	mov	BYTE PTR _glConfig[eax+24], cl
	jmp	SHORT $LN1@GL_SetExte
$LN2@GL_SetExte:

; 387  : 	else Con_Printf( S_ERROR "GL_SetExtension: invalid extension %d\n", r_ext );

	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@DFBHKDFL@?$FO1Error?3?$FO7?5GL_SetExtension?3?5inv@
	call	_Con_Printf
	add	esp, 8
$LN1@GL_SetExte:

; 388  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetExtension ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_DebugOutput@28
_TEXT	SEGMENT
tv64 = -68						; size = 4
_source$ = 8						; size = 4
_type$ = 12						; size = 4
_id$ = 16						; size = 4
_severity$ = 20						; size = 4
_length$ = 24						; size = 4
_message$ = 28						; size = 4
_userParam$ = 32					; size = 4
_GL_DebugOutput@28 PROC					; COMDAT

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 350  : 	switch( type )

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 33356				; 0000824cH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN10@GL_DebugOu
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@GL_DebugOu[edx*4]
$LN4@GL_DebugOu:

; 351  : 	{
; 352  : 	case GL_DEBUG_TYPE_ERROR_ARB:
; 353  : 		Con_Printf( S_OPENGL_ERROR "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@HNJCPLKA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 354  : 		break;

	jmp	$LN2@GL_DebugOu
$LN5@GL_DebugOu:

; 355  : 	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB:
; 356  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 357  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN6@GL_DebugOu:

; 358  : 	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB:
; 359  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 360  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN7@GL_DebugOu:

; 361  : 	case GL_DEBUG_TYPE_PORTABILITY_ARB:
; 362  : 		if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN8@GL_DebugOu

; 363  : 			return;

	jmp	SHORT $LN2@GL_DebugOu
$LN8@GL_DebugOu:

; 364  : 		Con_Printf( S_OPENGL_WARN "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@BELGKLBK@?$FO3OpenGL?5Warning?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 365  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN9@GL_DebugOu:

; 366  : 	case GL_DEBUG_TYPE_PERFORMANCE_ARB:
; 367  : 		Con_Printf( S_OPENGL_NOTE "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@EFLPNAON@?$FO2OpenGL?5Note?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 368  : 		break;

	jmp	SHORT $LN2@GL_DebugOu
$LN10@GL_DebugOu:

; 369  : 	case GL_DEBUG_TYPE_OTHER_ARB:
; 370  : 	default:
; 371  : 		if( host_developer.value < DEV_EXTENDED )

	movss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _host_developer+12
	jbe	SHORT $LN12@GL_DebugOu

; 372  : 			return;

	jmp	SHORT $LN2@GL_DebugOu
$LN12@GL_DebugOu:

; 373  : 		Con_Printf( S_OPENGL_NOTE "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@EFLPNAON@?$FO2OpenGL?5Note?3?$FO7?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8
$LN2@GL_DebugOu:

; 374  : 		break;
; 375  : 	}
; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	3
$LN14@GL_DebugOu:
	DD	$LN4@GL_DebugOu
	DD	$LN5@GL_DebugOu
	DD	$LN6@GL_DebugOu
	DD	$LN7@GL_DebugOu
	DD	$LN9@GL_DebugOu
	DD	$LN10@GL_DebugOu
_GL_DebugOutput@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_Shutdown
_TEXT	SEGMENT
_i$ = -8						; size = 4
_mod$ = -4						; size = 4
_R_Shutdown PROC					; COMDAT

; 1893 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1894 : 	model_t	*mod;
; 1895 : 	int	i;
; 1896 : 
; 1897 : 	if( !glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN5@R_Shutdown

; 1898 : 		return;

	jmp	$LN1@R_Shutdown
$LN5@R_Shutdown:

; 1899 : 
; 1900 : 	// release SpriteTextures
; 1901 : 	for( i = 1, mod = clgame.sprites; i < MAX_CLIENT_SPRITES; i++, mod++ )

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _mod$[ebp], OFFSET _clgame+14124
	jmp	SHORT $LN4@R_Shutdown
$LN2@R_Shutdown:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 392				; 00000188H
	mov	DWORD PTR _mod$[ebp], ecx
$LN4@R_Shutdown:
	cmp	DWORD PTR _i$[ebp], 512			; 00000200H
	jge	SHORT $LN3@R_Shutdown

; 1902 : 	{
; 1903 : 		if( !mod->name[0] ) continue;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mod$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN6@R_Shutdown
	jmp	SHORT $LN2@R_Shutdown
$LN6@R_Shutdown:

; 1904 : 		Mod_UnloadSpriteModel( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_UnloadSpriteModel
	add	esp, 4

; 1905 : 	}

	jmp	SHORT $LN2@R_Shutdown
$LN3@R_Shutdown:

; 1906 : 	memset( clgame.sprites, 0, sizeof( clgame.sprites ));

	push	200704					; 00031000H
	push	0
	push	OFFSET _clgame+14124
	call	_memset
	add	esp, 12					; 0000000cH

; 1907 : 
; 1908 : 	GL_RemoveCommands();

	call	_GL_RemoveCommands

; 1909 : 	R_ShutdownImages();

	call	_R_ShutdownImages

; 1910 : 
; 1911 : 	Mem_FreePool( &r_temppool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_Shutdown@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DF@BDEPHKGK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _r_temppool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 1912 : 
; 1913 : 	// shut down OS specific OpenGL stuff like contexts, etc.
; 1914 : 	R_Free_OpenGL();

	call	_R_Free_OpenGL
$LN1@R_Shutdown:

; 1915 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _R_Init
_TEXT	SEGMENT
_R_Init	PROC						; COMDAT

; 1851 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1852 : 	if( glw_state.initialized )

	cmp	DWORD PTR _glw_state+20, 0
	je	SHORT $LN2@R_Init

; 1853 : 		return true;

	mov	eax, 1
	jmp	$LN1@R_Init
$LN2@R_Init:

; 1854 : 
; 1855 : 	GL_InitCommands();

	call	_GL_InitCommands

; 1856 : 	GL_InitRandomTable();

	call	_GL_InitRandomTable

; 1857 : 	GL_SetDefaultState();

	call	_GL_SetDefaultState

; 1858 : 
; 1859 : 	// create the window and set up the context
; 1860 : 	if( !R_Init_OpenGL( ))

	call	_R_Init_OpenGL
	test	eax, eax
	jne	SHORT $LN3@R_Init

; 1861 : 	{
; 1862 : 		GL_RemoveCommands();

	call	_GL_RemoveCommands

; 1863 : 		R_Free_OpenGL();

	call	_R_Free_OpenGL

; 1864 : 
; 1865 : 		Sys_Error( "Can't initialize video subsystem\nProbably driver was not installed" );

	push	OFFSET ??_C@_0ED@FOEGDGGO@Can?8t?5initialize?5video?5subsyste@
	call	_Sys_Error
	add	esp, 4

; 1866 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@R_Init
$LN3@R_Init:

; 1867 : 	}
; 1868 : 
; 1869 : 	host.renderinfo_changed = false;

	mov	DWORD PTR _host+34420, 0

; 1870 : 	r_temppool = Mem_AllocPool( "Render Zone" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??R_Init@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DF@BDEPHKGK@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@BEDNAAAO@Render?5Zone@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r_temppool, eax

; 1871 : 
; 1872 : 	GL_InitExtensions();

	call	_GL_InitExtensions

; 1873 : 	GL_SetDefaults();

	call	_GL_SetDefaults

; 1874 : 	R_InitImages();

	call	_R_InitImages

; 1875 : 	R_SpriteInit();

	call	_R_SpriteInit

; 1876 : 	R_StudioInit();

	call	_R_StudioInit

; 1877 : 	R_AliasInit();

	call	_R_AliasInit

; 1878 : 	R_ClearDecals();

	call	_R_ClearDecals

; 1879 : 	R_ClearScene();

	call	_R_ClearScene

; 1880 : 
; 1881 : 	// initialize screen
; 1882 : 	SCR_Init();

	call	_SCR_Init

; 1883 : 
; 1884 : 	return true;

	mov	eax, 1
$LN1@R_Init:

; 1885 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_MaxTextureUnits
_TEXT	SEGMENT
tv72 = -76						; size = 4
tv71 = -72						; size = 4
tv68 = -68						; size = 4
_GL_MaxTextureUnits PROC				; COMDAT

; 410  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 411  : 	if( GL_Support( GL_SHADER_GLSL100_EXT ))

	push	9
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@GL_MaxText

; 412  : 		return Q_min( Q_max( glConfig.max_texture_coords, glConfig.max_teximage_units ), MAX_TEXTURE_UNITS );

	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glConfig+56
	jle	SHORT $LN4@GL_MaxText
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN5@GL_MaxText
$LN4@GL_MaxText:
	mov	edx, DWORD PTR _glConfig+56
	mov	DWORD PTR tv68[ebp], edx
$LN5@GL_MaxText:
	cmp	DWORD PTR tv68[ebp], 32			; 00000020H
	jge	SHORT $LN8@GL_MaxText
	mov	eax, DWORD PTR _glConfig+52
	cmp	eax, DWORD PTR _glConfig+56
	jle	SHORT $LN6@GL_MaxText
	mov	ecx, DWORD PTR _glConfig+52
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $LN7@GL_MaxText
$LN6@GL_MaxText:
	mov	edx, DWORD PTR _glConfig+56
	mov	DWORD PTR tv71[ebp], edx
$LN7@GL_MaxText:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN9@GL_MaxText
$LN8@GL_MaxText:
	mov	DWORD PTR tv72[ebp], 32			; 00000020H
$LN9@GL_MaxText:
	mov	eax, DWORD PTR tv72[ebp]
	jmp	SHORT $LN1@GL_MaxText
$LN2@GL_MaxText:

; 413  : 	return glConfig.max_texture_units;

	mov	eax, DWORD PTR _glConfig+48
$LN1@GL_MaxText:

; 414  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_MaxTextureUnits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_CheckChanges
_TEXT	SEGMENT
_VID_CheckChanges PROC					; COMDAT

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1427 : 	if( FBitSet( cl_allow_levelshots->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _cl_allow_levelshots
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN2@VID_CheckC

; 1428 :           {
; 1429 : 		GL_FreeTexture( cls.loadingBar );

	mov	eax, DWORD PTR _cls+290628
	push	eax
	call	_GL_FreeTexture
	add	esp, 4

; 1430 : 		SCR_RegisterTextures(); // reload 'lambda' image

	call	_SCR_RegisterTextures

; 1431 : 		ClearBits( cl_allow_levelshots->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _cl_allow_levelshots
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _cl_allow_levelshots
	mov	DWORD PTR [edx+8], ecx
$LN2@VID_CheckC:

; 1432 :           }
; 1433 :  
; 1434 : 	if( host.renderinfo_changed )

	cmp	DWORD PTR _host+34420, 0
	je	SHORT $LN1@VID_CheckC

; 1435 : 	{
; 1436 : 		if( !VID_SetMode( ))

	call	_VID_SetMode
	test	eax, eax
	jne	SHORT $LN4@VID_CheckC

; 1437 : 		{
; 1438 : 			Sys_Error( "Can't re-initialize video subsystem\n" );

	push	OFFSET ??_C@_0CF@IGHGDPNJ@Can?8t?5re?9initialize?5video?5subsy@
	call	_Sys_Error
	add	esp, 4

; 1439 : 		}

	jmp	SHORT $LN1@VID_CheckC
$LN4@VID_CheckC:

; 1440 : 		else
; 1441 : 		{
; 1442 : 			host.renderinfo_changed = false;

	mov	DWORD PTR _host+34420, 0

; 1443 : 			SCR_VidInit(); // tell the client.dll what vid_mode has changed

	call	_SCR_VidInit
$LN1@VID_CheckC:

; 1444 : 		}
; 1445 : 	}
; 1446 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_CheckChanges ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_Support
_TEXT	SEGMENT
tv70 = -68						; size = 4
_r_ext$ = 8						; size = 4
_GL_Support PROC					; COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 397  : 	if( r_ext >= 0 && r_ext < GL_EXTCOUNT )

	cmp	DWORD PTR _r_ext$[ebp], 0
	jl	SHORT $LN2@GL_Support
	cmp	DWORD PTR _r_ext$[ebp], 22		; 00000016H
	jge	SHORT $LN2@GL_Support

; 398  : 		return glConfig.extension[r_ext] ? true : false;

	mov	eax, DWORD PTR _r_ext$[ebp]
	movzx	ecx, BYTE PTR _glConfig[eax+24]
	test	ecx, ecx
	je	SHORT $LN4@GL_Support
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@GL_Support
$LN4@GL_Support:
	mov	DWORD PTR tv70[ebp], 0
$LN5@GL_Support:
	mov	eax, DWORD PTR tv70[ebp]
	jmp	SHORT $LN1@GL_Support
$LN2@GL_Support:

; 399  : 	Con_Printf( S_ERROR "GL_Support: invalid extension %d\n", r_ext );

	mov	eax, DWORD PTR _r_ext$[ebp]
	push	eax
	push	OFFSET ??_C@_0CN@IPEPFJPO@?$FO1Error?3?$FO7?5GL_Support?3?5invalid?5@
	call	_Con_Printf
	add	esp, 8

; 400  : 
; 401  : 	return false;		

	xor	eax, eax
$LN1@GL_Support:

; 402  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_Support ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_DeleteContext
_TEXT	SEGMENT
_GL_DeleteContext PROC					; COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 663  : 	if( pwglMakeCurrent )

	cmp	DWORD PTR _pwglMakeCurrent, 0
	je	SHORT $LN2@GL_DeleteC

; 664  : 		pwglMakeCurrent( NULL, NULL );

	push	0
	push	0
	call	DWORD PTR _pwglMakeCurrent
$LN2@GL_DeleteC:

; 665  : 
; 666  : 	if( glw_state.hGLRC )

	cmp	DWORD PTR _glw_state+4, 0
	je	SHORT $LN3@GL_DeleteC

; 667  : 	{
; 668  : 		if( pwglDeleteContext )

	cmp	DWORD PTR _pwglDeleteContext, 0
	je	SHORT $LN4@GL_DeleteC

; 669  : 			pwglDeleteContext( glw_state.hGLRC );

	mov	eax, DWORD PTR _glw_state+4
	push	eax
	call	DWORD PTR _pwglDeleteContext
$LN4@GL_DeleteC:

; 670  : 		glw_state.hGLRC = NULL;

	mov	DWORD PTR _glw_state+4, 0
$LN3@GL_DeleteC:

; 671  : 	}
; 672  : 
; 673  : 	if( glw_state.hDC )

	cmp	DWORD PTR _glw_state, 0
	je	SHORT $LN5@GL_DeleteC

; 674  : 	{
; 675  : 		ReleaseDC( host.hWnd, glw_state.hDC );

	mov	eax, DWORD PTR _glw_state
	push	eax
	mov	ecx, DWORD PTR _host+34332
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8

; 676  : 		glw_state.hDC = NULL;

	mov	DWORD PTR _glw_state, 0
$LN5@GL_DeleteC:

; 677  : 	}
; 678  : 
; 679  : 	return false;

	xor	eax, eax

; 680  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_DeleteContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_UpdateSwapInterval
_TEXT	SEGMENT
tv87 = -72						; size = 4
tv86 = -68						; size = 4
_GL_UpdateSwapInterval PROC				; COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 494  : 	// disable VSync while level is loading
; 495  : 	if( cls.state < ca_active )

	cmp	DWORD PTR _cls, 4
	jge	SHORT $LN2@GL_UpdateS

; 496  : 	{
; 497  : 		if( pwglSwapIntervalEXT != NULL )

	cmp	DWORD PTR _pwglSwapIntervalEXT, 0
	je	SHORT $LN4@GL_UpdateS

; 498  : 			pwglSwapIntervalEXT( 0 );

	push	0
	call	DWORD PTR _pwglSwapIntervalEXT
$LN4@GL_UpdateS:

; 499  : 		SetBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 500  : 	}

	jmp	SHORT $LN6@GL_UpdateS
$LN2@GL_UpdateS:

; 501  : 	else if( FBitSet( gl_vsync->flags, FCVAR_CHANGED ))

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN6@GL_UpdateS

; 502  : 	{
; 503  : 		ClearBits( gl_vsync->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_vsync
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_vsync
	mov	DWORD PTR [edx+8], ecx

; 504  : 
; 505  : 		if( pwglSwapIntervalEXT != NULL )

	cmp	DWORD PTR _pwglSwapIntervalEXT, 0
	je	SHORT $LN6@GL_UpdateS

; 506  : 			pwglSwapIntervalEXT( bound( -1, (int)gl_vsync->value, 1 ));

	mov	eax, DWORD PTR _gl_vsync
	cvttss2si ecx, DWORD PTR [eax+12]
	cmp	ecx, -1
	jl	SHORT $LN10@GL_UpdateS
	mov	edx, DWORD PTR _gl_vsync
	cvttss2si eax, DWORD PTR [edx+12]
	cmp	eax, 1
	jge	SHORT $LN8@GL_UpdateS
	mov	ecx, DWORD PTR _gl_vsync
	cvttss2si edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN9@GL_UpdateS
$LN8@GL_UpdateS:
	mov	DWORD PTR tv86[ebp], 1
$LN9@GL_UpdateS:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN11@GL_UpdateS
$LN10@GL_UpdateS:
	mov	DWORD PTR tv87[ebp], -1
$LN11@GL_UpdateS:
	mov	ecx, DWORD PTR tv87[ebp]
	push	ecx
	call	DWORD PTR _pwglSwapIntervalEXT
$LN6@GL_UpdateS:

; 507  : 	}
; 508  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UpdateSwapInterval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_ErrorString
_TEXT	SEGMENT
tv64 = -68						; size = 4
_err$ = 8						; size = 4
_GL_ErrorString PROC					; COMDAT

; 1926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1927 : 	switch( err )

	mov	eax, DWORD PTR _err$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1280				; 00000500H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN10@GL_ErrorSt
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@GL_ErrorSt[edx*4]
$LN4@GL_ErrorSt:

; 1928 : 	{
; 1929 : 	case GL_STACK_OVERFLOW:
; 1930 : 		return "GL_STACK_OVERFLOW";

	mov	eax, OFFSET ??_C@_0BC@DLCDMCHH@GL_STACK_OVERFLOW@
	jmp	SHORT $LN1@GL_ErrorSt
$LN5@GL_ErrorSt:

; 1931 : 	case GL_STACK_UNDERFLOW:
; 1932 : 		return "GL_STACK_UNDERFLOW";

	mov	eax, OFFSET ??_C@_0BD@KAJAFKFC@GL_STACK_UNDERFLOW@
	jmp	SHORT $LN1@GL_ErrorSt
$LN6@GL_ErrorSt:

; 1933 : 	case GL_INVALID_ENUM:
; 1934 : 		return "GL_INVALID_ENUM";

	mov	eax, OFFSET ??_C@_0BA@LLPLHEDK@GL_INVALID_ENUM@
	jmp	SHORT $LN1@GL_ErrorSt
$LN7@GL_ErrorSt:

; 1935 : 	case GL_INVALID_VALUE:
; 1936 : 		return "GL_INVALID_VALUE";

	mov	eax, OFFSET ??_C@_0BB@HDIPJELP@GL_INVALID_VALUE@
	jmp	SHORT $LN1@GL_ErrorSt
$LN8@GL_ErrorSt:

; 1937 : 	case GL_INVALID_OPERATION:
; 1938 : 		return "GL_INVALID_OPERATION";

	mov	eax, OFFSET ??_C@_0BF@NFNGKHIL@GL_INVALID_OPERATION@
	jmp	SHORT $LN1@GL_ErrorSt
$LN9@GL_ErrorSt:

; 1939 : 	case GL_OUT_OF_MEMORY:
; 1940 : 		return "GL_OUT_OF_MEMORY";

	mov	eax, OFFSET ??_C@_0BB@JMBJBKGI@GL_OUT_OF_MEMORY@
	jmp	SHORT $LN1@GL_ErrorSt
$LN10@GL_ErrorSt:

; 1941 : 	default:
; 1942 : 		return "UNKNOWN ERROR";

	mov	eax, OFFSET ??_C@_0O@KGJDDGD@UNKNOWN?5ERROR@
$LN1@GL_ErrorSt:

; 1943 : 	}
; 1944 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@GL_ErrorSt:
	DD	$LN6@GL_ErrorSt
	DD	$LN7@GL_ErrorSt
	DD	$LN8@GL_ErrorSt
	DD	$LN4@GL_ErrorSt
	DD	$LN5@GL_ErrorSt
	DD	$LN9@GL_ErrorSt
_GL_ErrorString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_GetProcAddress
_TEXT	SEGMENT
_p$ = -4						; size = 4
_name$ = 8						; size = 4
_GL_GetProcAddress PROC					; COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 423  : 	void	*p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 424  : 
; 425  : 	if( pwglGetProcAddress != NULL )

	cmp	DWORD PTR _pwglGetProcAddress, 0
	je	SHORT $LN2@GL_GetProc

; 426  : 		p = (void *)pwglGetProcAddress( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR _pwglGetProcAddress
	mov	DWORD PTR _p$[ebp], eax
$LN2@GL_GetProc:

; 427  : 	if( !p ) p = (void *)Sys_GetProcAddress( &opengl_dll, name );

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $LN3@GL_GetProc
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET _opengl_dll
	call	_Sys_GetProcAddress
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
$LN3@GL_GetProc:

; 428  : 
; 429  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_GetProcAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_GetModeString
_TEXT	SEGMENT
_vid_mode$ = 8						; size = 4
_VID_GetModeString PROC					; COMDAT

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 803  : 	if( vid_mode >= 0 && vid_mode < num_vidmodes )

	cmp	DWORD PTR _vid_mode$[ebp], 0
	jl	SHORT $LN2@VID_GetMod
	cmp	DWORD PTR _vid_mode$[ebp], 26		; 0000001aH
	jae	SHORT $LN2@VID_GetMod

; 804  : 		return vidmode[vid_mode].desc;

	mov	eax, DWORD PTR _vid_mode$[ebp]
	shl	eax, 4
	mov	eax, DWORD PTR _vidmode[eax]
	jmp	SHORT $LN1@VID_GetMod
$LN2@VID_GetMod:

; 805  : 	return NULL; // out of bounds

	xor	eax, eax
$LN1@VID_GetMod:

; 806  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_GetModeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _GL_CheckForErrors_
_TEXT	SEGMENT
tv67 = -72						; size = 4
_err$ = -4						; size = 4
_filename$ = 8						; size = 4
_fileline$ = 12						; size = 4
_GL_CheckForErrors_ PROC				; COMDAT

; 1954 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1955 : 	int	err;
; 1956 : 
; 1957 : 	if( !CVAR_TO_BOOL( gl_check_errors ))

	cmp	DWORD PTR _gl_check_errors, 0
	je	SHORT $LN5@GL_CheckFo
	mov	eax, DWORD PTR _gl_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@GL_CheckFo
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN6@GL_CheckFo
$LN5@GL_CheckFo:
	mov	DWORD PTR tv67[ebp], 0
$LN6@GL_CheckFo:
	cmp	DWORD PTR tv67[ebp], 0
	jne	SHORT $LN2@GL_CheckFo

; 1958 : 		return;

	jmp	SHORT $LN1@GL_CheckFo
$LN2@GL_CheckFo:

; 1959 : 
; 1960 : 	if(( err = pglGetError( )) == GL_NO_ERROR )

	call	DWORD PTR _pglGetError
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $LN3@GL_CheckFo

; 1961 : 		return;

	jmp	SHORT $LN1@GL_CheckFo
$LN3@GL_CheckFo:

; 1962 : 
; 1963 : 	Con_Printf( S_OPENGL_ERROR "%s (called at %s:%i)\n", GL_ErrorString( err ), filename, fileline );

	mov	eax, DWORD PTR _fileline$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _err$[ebp]
	push	edx
	call	_GL_ErrorString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CI@CEFKNKJA@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5?$CIcalled?5at@
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN1@GL_CheckFo:

; 1964 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckForErrors_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_vidnt.c
;	COMDAT _VID_InitDefaultResolution
_TEXT	SEGMENT
_VID_InitDefaultResolution PROC				; COMDAT

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 790  : 	// we need to have something valid here
; 791  : 	// until video subsystem initialized
; 792  : 	glState.width = 640;

	mov	DWORD PTR _glState, 640			; 00000280H

; 793  : 	glState.height = 480;

	mov	DWORD PTR _glState+4, 480		; 000001e0H

; 794  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VID_InitDefaultResolution ENDP
_TEXT	ENDS
END
