; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\s_main.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_snd_ambient
PUBLIC	_snd_fade_sequence
_DATA	SEGMENT
COMM	_sndpool:DWORD
COMM	_ambient_sfx:DWORD:04H
_DATA	ENDS
_BSS	SEGMENT
_snd_ambient DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_channels:BYTE:0c1c00H
COMM	_raw_channels:DWORD:010H
COMM	_total_channels:DWORD
COMM	_paintedtime:DWORD
COMM	_soundtime:DWORD
COMM	_s_listener:BYTE:0105cH
COMM	_dma:BYTE:010H
COMM	_s_volume:DWORD
COMM	_s_musicvolume:DWORD
COMM	_s_show:DWORD
COMM	_s_mixahead:DWORD
COMM	_s_lerping:DWORD
COMM	_s_test:DWORD
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
_BSS	SEGMENT
_snd_fade_sequence DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_s_ambient_level:DWORD
COMM	_s_ambient_fade:DWORD
COMM	_s_combine_sounds:DWORD
COMM	_snd_foliage_db_loss:DWORD
COMM	_snd_gain:DWORD
COMM	_snd_gain_max:DWORD
COMM	_snd_gain_min:DWORD
COMM	_s_refdist:DWORD
COMM	_s_refdb:DWORD
COMM	_s_cull:DWORD
COMM	_s_phs:DWORD
_DATA	ENDS
PUBLIC	_S_Init
PUBLIC	_S_Shutdown
PUBLIC	_S_StopSound
PUBLIC	_S_GetCurrentStaticSounds
PUBLIC	_S_StopAllSounds
PUBLIC	_S_GetMasterVolume
PUBLIC	_S_FreeChannel
PUBLIC	_S_SoundInfo_f
PUBLIC	_SND_PickDynamicChannel
PUBLIC	_SND_PickStaticChannel
PUBLIC	_S_GetCurrentDynamicSounds
PUBLIC	_S_FindRawChannel
PUBLIC	_S_RawSamples
PUBLIC	_S_UpdateFrame
PUBLIC	_S_GetRawSamplesLength
PUBLIC	_S_ClearRawChannel
PUBLIC	_S_StreamAviSamples
PUBLIC	_S_RestoreSound
PUBLIC	_S_StartSound
PUBLIC	_S_AmbientSound
PUBLIC	_S_FadeClientVolume
PUBLIC	_S_StartLocalSound
PUBLIC	_SND_UpdateSound
PUBLIC	_S_ExtraUpdate
PUBLIC	_dB_To_Gain
PUBLIC	_dB_To_Radius
PUBLIC	_S_IsClient
PUBLIC	_S_UpdateSoundFade
PUBLIC	_SND_ChannelOkToTrace
PUBLIC	_SND_ChannelTraceReset
PUBLIC	_SND_FStreamIsPlaying
PUBLIC	_S_AlterChannel
PUBLIC	_SND_FadeToNewGain
PUBLIC	_SND_GetGainObscured
PUBLIC	_SND_GetGain
PUBLIC	_SND_CheckPHS
PUBLIC	_S_SpatializeChannel
PUBLIC	_SND_Spatialize
PUBLIC	_S_InitAmbientChannels
PUBLIC	_S_UpdateAmbientSounds
PUBLIC	_S_ClearBuffer
PUBLIC	_S_UpdateChannels
PUBLIC	_S_Play_f
PUBLIC	_S_Play2_f
PUBLIC	_S_PlayVol_f
PUBLIC	_S_Say_f
PUBLIC	_S_SayReliable_f
PUBLIC	_S_Music_f
PUBLIC	_S_StopSound_f
PUBLIC	_S_SoundFade_f
PUBLIC	??_C@_0DC@GJNKBDLN@?$FO1Error?3?$FO7?5S_PickStaticChannel?3@ ; `string'
PUBLIC	??_C@_06PBLIODKG@sound?1@			; `string'
PUBLIC	??_C@_0CB@IFNNOFCP@?$FO1Error?3?$FO7?5dropped?5sound?5?$CC?$CFs?$CFs?$CC@ ; `string'
PUBLIC	??_C@_08KPIGECMN@?$CKdefault@			; `string'
PUBLIC	?__LINE__Var@?0??S_FindRawChannel@@9@9		; `S_FindRawChannel'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??S_FreeIdleRawChannels@@9@9	; `S_FreeIdleRawChannels'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??S_FreeRawChannels@@9@9		; `S_FreeRawChannels'::`1'::__LINE__Var
PUBLIC	??_C@_0DD@IALGGBFP@chan?5?$CFi?0?5pos?5?$CI?$CF?4f?5?$CF?4f?5?$CF?4f?$CJ?5ent?5@ ; `string'
PUBLIC	??_C@_0CI@EIBIENGJ@room_type?3?5?$CFi?5?9?9?9?9?$CI?$CFi?$CJ?9?9?9?9?5pain@ ; `string'
PUBLIC	??_C@_0BJ@BBKGLAEH@Usage?3?5play?5?$DMsoundfile?$DO?6@ ; `string'
PUBLIC	??_C@_0BK@PBONNAAC@Usage?3?5play2?5?$DMsoundfile?$DO?6@ ; `string'
PUBLIC	??_C@_0CD@CIGEOFAG@Usage?3?5playvol?5?$DMsoundfile?5volum@ ; `string'
PUBLIC	??_C@_0BK@HODGAGPK@Usage?3?5speak?5?$DMsoundfile?$DO?6@ ; `string'
PUBLIC	??_C@_0BI@PEDOOMJF@Usage?3?5spk?5?$DMsoundfile?$DO?6@ ; `string'
PUBLIC	??_C@_0FM@BFMIJHBO@Usage?3?5music?5?$DMmusicfile?$DO?5?$FLloopf@ ; `string'
PUBLIC	??_C@_04PEGFANN@stop@				; `string'
PUBLIC	??_C@_04GKOOIABA@loop@				; `string'
PUBLIC	??_C@_03PCBNCGFH@pos@				; `string'
PUBLIC	??_C@_06HOKAPKFF@onloop@			; `string'
PUBLIC	??_C@_08IHECAEFP@restored@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BE@GJHINAHM@Audio?3?5DirectSound?6@	; `string'
PUBLIC	??_C@_0BA@JOMDFKBJ@?$CF5d?5channel?$CIs?$CJ?6@	; `string'
PUBLIC	??_C@_0N@LFEODKMK@?$CF5d?5samples?6@		; `string'
PUBLIC	??_C@_0BB@DAEGPPBO@?$CF5d?5bits?1sample?6@	; `string'
PUBLIC	??_C@_0P@HEEOPNMB@?$CF5d?5bytes?1sec?6@		; `string'
PUBLIC	??_C@_0BE@FHKOKMBN@?$CF5d?5total_channels?6@	; `string'
PUBLIC	?__LINE__Var@?0??S_Init@@9@9			; `S_Init'::`1'::__LINE__Var
PUBLIC	??_C@_08FLDKIHPE@?9nosound@			; `string'
PUBLIC	??_C@_0BB@DKLPDJJH@Audio?3?5Disabled?6@		; `string'
PUBLIC	??_C@_0N@DLGNHHCP@sound?5volume@		; `string'
PUBLIC	??_C@_03IMEEBDJM@0?47@				; `string'
PUBLIC	??_C@_06EMCPHFGM@volume@			; `string'
PUBLIC	??_C@_0BI@NFGOLMDH@background?5music?5volume@	; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40@				; `string'
PUBLIC	??_C@_09OPCAGCAA@MP3Volume@			; `string'
PUBLIC	??_C@_0CE@MCODGGLH@how?5much?5sound?5to?5mix?5ahead?5of?5@ ; `string'
PUBLIC	??_C@_04BAMILDLP@0?412@				; `string'
PUBLIC	??_C@_0O@KCANMFKJ@_snd_mixahead@		; `string'
PUBLIC	??_C@_0BE@NKNFOPGI@show?5playing?5sounds@	; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_06CBNOHGMK@s_show@			; `string'
PUBLIC	??_C@_0CE@CMGAPAHP@apply?5interpolation?5to?5sound?5ou@ ; `string'
PUBLIC	??_C@_09GDMJBOMF@s_lerping@			; `string'
PUBLIC	??_C@_0CO@JCIHEOCN@volume?5of?5environment?5noises?5?$CIw@ ; `string'
PUBLIC	??_C@_03OICINGJI@0?43@				; `string'
PUBLIC	??_C@_0O@CALFHOGH@ambient_level@		; `string'
PUBLIC	??_C@_0CM@HCOPHGBE@rate?5of?5volume?5fading?5when?5clie@ ; `string'
PUBLIC	??_C@_04KOJKLCBG@1000@				; `string'
PUBLIC	??_C@_0N@EEIPABOO@ambient_fade@			; `string'
PUBLIC	??_C@_0CC@HMJNPNMG@combine?5channels?5with?5same?5soun@ ; `string'
PUBLIC	??_C@_0BD@OPAKHCCE@s_combine_channels@		; `string'
PUBLIC	??_C@_0BE@ODLIHDCK@foliage?5loss?5factor@	; `string'
PUBLIC	??_C@_01FAMBOPH@4@				; `string'
PUBLIC	??_C@_0BE@NECBKIEK@snd_foliage_db_loss@		; `string'
PUBLIC	??_C@_0BH@HDNKNAKN@gain?5maximal?5threshold@	; `string'
PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_0N@ELKLCACH@snd_gain_max@			; `string'
PUBLIC	??_C@_0BH@CAHMMIEJ@gain?5minimal?5threshold@	; `string'
PUBLIC	??_C@_04DKCHIKEL@0?401@				; `string'
PUBLIC	??_C@_0N@FJCAMEEI@snd_gain_min@			; `string'
PUBLIC	??_C@_0BO@JNLHGNDP@soundlevel?5reference?5distance@ ; `string'
PUBLIC	??_C@_02KPIPOMFB@36@				; `string'
PUBLIC	??_C@_09HCMODNKC@s_refdist@			; `string'
PUBLIC	??_C@_0BH@CCJCHMK@soundlevel?5refernce?5dB@	; `string'
PUBLIC	??_C@_02PPBOIJDM@60@				; `string'
PUBLIC	??_C@_07HMPPLJEK@s_refdb@			; `string'
PUBLIC	??_C@_0BD@KNNAKLIE@sound?5default?5gain@	; `string'
PUBLIC	??_C@_08IDGIPJKB@snd_gain@			; `string'
PUBLIC	??_C@_0BI@HNLDNAJD@cull?5sounds?5by?5geometry@	; `string'
PUBLIC	??_C@_06EIDNBLMJ@s_cull@			; `string'
PUBLIC	??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@ ; `string'
PUBLIC	??_C@_06FPIFHLNA@s_test@			; `string'
PUBLIC	??_C@_0BD@MKBJIML@cull?5sounds?5by?5PHS@	; `string'
PUBLIC	??_C@_05FACBGJBI@s_phs@				; `string'
PUBLIC	??_C@_0BP@GMHOHLLC@playing?5a?5specified?5sound?5file@ ; `string'
PUBLIC	??_C@_04GBHMDDO@play@				; `string'
PUBLIC	??_C@_0CJ@BIFCPPDC@playing?5a?5group?5of?5specified?5so@ ; `string'
PUBLIC	??_C@_05CMBHFOBJ@play2@				; `string'
PUBLIC	??_C@_0DF@GNICHBJN@playing?5a?5specified?5sound?5file?5@ ; `string'
PUBLIC	??_C@_07IJGGJOCA@playvol@			; `string'
PUBLIC	??_C@_0BA@INMDPMLC@stop?5all?5sounds@		; `string'
PUBLIC	??_C@_09MAAKNOCD@stopsound@			; `string'
PUBLIC	??_C@_0BM@MCNPGDMO@starting?5a?5background?5track@ ; `string'
PUBLIC	??_C@_05LLDJOKNO@music@				; `string'
PUBLIC	??_C@_0BG@JLOIOPFH@display?5loaded?5sounds@	; `string'
PUBLIC	??_C@_09CJIFEKFJ@soundlist@			; `string'
PUBLIC	??_C@_0BP@MBCFFBJN@print?5sound?5system?5information@ ; `string'
PUBLIC	??_C@_06KDCPAFOD@s_info@			; `string'
PUBLIC	??_C@_0BO@MAIPKJA@fade?5all?5sounds?5then?5stop?5all@ ; `string'
PUBLIC	??_C@_06IAHHLOIA@s_fade@			; `string'
PUBLIC	??_C@_0CI@JBEKFHJI@start?5voice?5recording?5?$CInon?9impl@ ; `string'
PUBLIC	??_C@_0N@LEINJAHL@?$CLvoicerecord@		; `string'
PUBLIC	??_C@_0CH@EIODAAJG@stop?5voice?5recording?5?$CInon?9imple@ ; `string'
PUBLIC	??_C@_0N@BEGIEPKG@?9voicerecord@		; `string'
PUBLIC	??_C@_0CE@CKJLHGOG@reliable?5play?5a?5specified?5sente@ ; `string'
PUBLIC	??_C@_03HFMJPFKN@spk@				; `string'
PUBLIC	??_C@_0BO@DILNDKOG@playing?5a?5specified?5sententce@ ; `string'
PUBLIC	??_C@_05PJLNNFLG@speak@				; `string'
PUBLIC	??_C@_0CK@INIMMNIC@Audio?3?5sound?5system?5can?8t?5be?5in@ ; `string'
PUBLIC	??_C@_0L@BJONLKOP@Sound?5Zone@			; `string'
PUBLIC	?__LINE__Var@?0??S_Shutdown@@9@9		; `S_Shutdown'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3cb9c278
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f19999a
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3f847ae140000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40d0000000000000
PUBLIC	__real@40e5888000000000
PUBLIC	__real@41200000
PUBLIC	__real@41400000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41c00000
PUBLIC	__real@42700000
PUBLIC	__real@42a00000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@430c0000
PUBLIC	__real@43580000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@472c4400
PUBLIC	__real@bf800000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c02ccccd
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memset:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__atol:PROC
EXTRN	_Sys_CheckParm:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_CL_Active:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_AVI_GetAudioInfo:PROC
EXTRN	_AVI_GetAudioChunk:PROC
EXTRN	_AVI_TimeToSoundPosition:PROC
EXTRN	_CL_IsInGame:PROC
EXTRN	_CL_IsInMenu:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_COM_RandomLong:PROC
EXTRN	_Cmd_Null_f:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_fabs:PROC
EXTRN	_log10:PROC
EXTRN	_pow:PROC
EXTRN	_sqrt:PROC
EXTRN	_SimpleSpline:PROC
EXTRN	_VectorNormalizeLength2:PROC
EXTRN	_VectorVectors:PROC
EXTRN	_AngleVectors:PROC
EXTRN	_RemapVal:PROC
EXTRN	_ApproachVal:PROC
EXTRN	_VOX_LoadWord:PROC
EXTRN	_VOX_FreeWord:PROC
EXTRN	_SNDDMA_Init:PROC
EXTRN	_SNDDMA_GetSoundtime:PROC
EXTRN	_SNDDMA_Shutdown:PROC
EXTRN	_SNDDMA_BeginPainting:PROC
EXTRN	_SNDDMA_Submit:PROC
EXTRN	_S_InitScaletable:PROC
EXTRN	_S_LoadSound:PROC
EXTRN	_MIX_ClearAllPaintBuffers:PROC
EXTRN	_MIX_InitAllPaintbuffers:PROC
EXTRN	_MIX_FreeAllPaintbuffers:PROC
EXTRN	_MIX_PaintChannels:PROC
EXTRN	_S_TestSoundChar:PROC
EXTRN	_S_SkipSoundChar:PROC
EXTRN	_S_FindName:PROC
EXTRN	_S_RegisterSound:PROC
EXTRN	_S_InitSounds:PROC
EXTRN	_SX_Init:PROC
EXTRN	_SX_Free:PROC
EXTRN	_DSP_ClearState:PROC
EXTRN	_S_SoundList_f:PROC
EXTRN	_S_GetSfxByHandle:PROC
EXTRN	_S_FreeSounds:PROC
EXTRN	_SND_InitMouth:PROC
EXTRN	_SND_CloseMouth:PROC
EXTRN	_S_StreamSoundTrack:PROC
EXTRN	_S_StreamBackgroundTrack:PROC
EXTRN	_S_PrintBackgroundTrackState:PROC
EXTRN	_S_FadeMusicVolume:PROC
EXTRN	_S_SetSampleStart:PROC
EXTRN	_VOX_Init:PROC
EXTRN	_VOX_Shutdown:PROC
EXTRN	_VOX_SetChanVol:PROC
EXTRN	_VOX_LoadSound:PROC
EXTRN	_Mod_FatPVS:PROC
EXTRN	_Mod_BoxVisible:PROC
EXTRN	_Mod_PointInLeaf:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_GetEntitySpatialization:PROC
EXTRN	_CL_GetMovieSpatialization:PROC
EXTRN	_S_StartBackgroundTrack:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtol3:PROC
EXTRN	__ftol3:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_idsp_room:DWORD
EXTRN	_world:BYTE
EXTRN	_cl:BYTE
EXTRN	_RI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_soundfade DB	018H DUP (?)
_trace_count DD	01H DUP (?)
_last_trace_chan DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c02ccccd
CONST	SEGMENT
__real@c02ccccd DD 0c02ccccdr			; -2.7
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@472c4400
CONST	SEGMENT
__real@472c4400 DD 0472c4400r			; 44100
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@43580000
CONST	SEGMENT
__real@43580000 DD 043580000r			; 216
CONST	ENDS
;	COMDAT __real@430c0000
CONST	SEGMENT
__real@430c0000 DD 0430c0000r			; 140
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e5888000000000
CONST	SEGMENT
__real@40e5888000000000 DQ 040e5888000000000r	; 44100
CONST	ENDS
;	COMDAT __real@40d0000000000000
CONST	SEGMENT
__real@40d0000000000000 DQ 040d0000000000000r	; 16384
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f847ae140000000
CONST	SEGMENT
__real@3f847ae140000000 DQ 03f847ae140000000r	; 0.01
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3cb9c278
CONST	SEGMENT
__real@3cb9c278 DD 03cb9c278r			; 0.0226757
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_Shutdown@@9@9 DD 095dH		; `S_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@BJONLKOP@Sound?5Zone@
CONST	SEGMENT
??_C@_0L@BJONLKOP@Sound?5Zone@ DB 'Sound Zone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@INIMMNIC@Audio?3?5sound?5system?5can?8t?5be?5in@
CONST	SEGMENT
??_C@_0CK@INIMMNIC@Audio?3?5sound?5system?5can?8t?5be?5in@ DB 'Audio: sou'
	DB	'nd system can''t be initialized', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PJLNNFLG@speak@
CONST	SEGMENT
??_C@_05PJLNNFLG@speak@ DB 'speak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DILNDKOG@playing?5a?5specified?5sententce@
CONST	SEGMENT
??_C@_0BO@DILNDKOG@playing?5a?5specified?5sententce@ DB 'playing a specif'
	DB	'ied sententce', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03HFMJPFKN@spk@
CONST	SEGMENT
??_C@_03HFMJPFKN@spk@ DB 'spk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CKJLHGOG@reliable?5play?5a?5specified?5sente@
CONST	SEGMENT
??_C@_0CE@CKJLHGOG@reliable?5play?5a?5specified?5sente@ DB 'reliable play'
	DB	' a specified sententce', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEGIEPKG@?9voicerecord@
CONST	SEGMENT
??_C@_0N@BEGIEPKG@?9voicerecord@ DB '-voicerecord', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EIODAAJG@stop?5voice?5recording?5?$CInon?9imple@
CONST	SEGMENT
??_C@_0CH@EIODAAJG@stop?5voice?5recording?5?$CInon?9imple@ DB 'stop voice'
	DB	' recording (non-implemented)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LEINJAHL@?$CLvoicerecord@
CONST	SEGMENT
??_C@_0N@LEINJAHL@?$CLvoicerecord@ DB '+voicerecord', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JBEKFHJI@start?5voice?5recording?5?$CInon?9impl@
CONST	SEGMENT
??_C@_0CI@JBEKFHJI@start?5voice?5recording?5?$CInon?9impl@ DB 'start voic'
	DB	'e recording (non-implemented)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IAHHLOIA@s_fade@
CONST	SEGMENT
??_C@_06IAHHLOIA@s_fade@ DB 's_fade', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MAIPKJA@fade?5all?5sounds?5then?5stop?5all@
CONST	SEGMENT
??_C@_0BO@MAIPKJA@fade?5all?5sounds?5then?5stop?5all@ DB 'fade all sounds'
	DB	' then stop all', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KDCPAFOD@s_info@
CONST	SEGMENT
??_C@_06KDCPAFOD@s_info@ DB 's_info', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MBCFFBJN@print?5sound?5system?5information@
CONST	SEGMENT
??_C@_0BP@MBCFFBJN@print?5sound?5system?5information@ DB 'print sound sys'
	DB	'tem information', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CJIFEKFJ@soundlist@
CONST	SEGMENT
??_C@_09CJIFEKFJ@soundlist@ DB 'soundlist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JLOIOPFH@display?5loaded?5sounds@
CONST	SEGMENT
??_C@_0BG@JLOIOPFH@display?5loaded?5sounds@ DB 'display loaded sounds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LLDJOKNO@music@
CONST	SEGMENT
??_C@_05LLDJOKNO@music@ DB 'music', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MCNPGDMO@starting?5a?5background?5track@
CONST	SEGMENT
??_C@_0BM@MCNPGDMO@starting?5a?5background?5track@ DB 'starting a backgro'
	DB	'und track', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09MAAKNOCD@stopsound@
CONST	SEGMENT
??_C@_09MAAKNOCD@stopsound@ DB 'stopsound', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@INMDPMLC@stop?5all?5sounds@
CONST	SEGMENT
??_C@_0BA@INMDPMLC@stop?5all?5sounds@ DB 'stop all sounds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJGGJOCA@playvol@
CONST	SEGMENT
??_C@_07IJGGJOCA@playvol@ DB 'playvol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GNICHBJN@playing?5a?5specified?5sound?5file?5@
CONST	SEGMENT
??_C@_0DF@GNICHBJN@playing?5a?5specified?5sound?5file?5@ DB 'playing a sp'
	DB	'ecified sound file with specified volume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMBHFOBJ@play2@
CONST	SEGMENT
??_C@_05CMBHFOBJ@play2@ DB 'play2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BIFCPPDC@playing?5a?5group?5of?5specified?5so@
CONST	SEGMENT
??_C@_0CJ@BIFCPPDC@playing?5a?5group?5of?5specified?5so@ DB 'playing a gr'
	DB	'oup of specified sound files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBHMDDO@play@
CONST	SEGMENT
??_C@_04GBHMDDO@play@ DB 'play', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GMHOHLLC@playing?5a?5specified?5sound?5file@
CONST	SEGMENT
??_C@_0BP@GMHOHLLC@playing?5a?5specified?5sound?5file@ DB 'playing a spec'
	DB	'ified sound file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FACBGJBI@s_phs@
CONST	SEGMENT
??_C@_05FACBGJBI@s_phs@ DB 's_phs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MKBJIML@cull?5sounds?5by?5PHS@
CONST	SEGMENT
??_C@_0BD@MKBJIML@cull?5sounds?5by?5PHS@ DB 'cull sounds by PHS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPIFHLNA@s_test@
CONST	SEGMENT
??_C@_06FPIFHLNA@s_test@ DB 's_test', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@
CONST	SEGMENT
??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@ DB 'engine develo'
	DB	'per cvar for quick testing new features', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EIDNBLMJ@s_cull@
CONST	SEGMENT
??_C@_06EIDNBLMJ@s_cull@ DB 's_cull', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNLDNAJD@cull?5sounds?5by?5geometry@
CONST	SEGMENT
??_C@_0BI@HNLDNAJD@cull?5sounds?5by?5geometry@ DB 'cull sounds by geometr'
	DB	'y', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGIPJKB@snd_gain@
CONST	SEGMENT
??_C@_08IDGIPJKB@snd_gain@ DB 'snd_gain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNNAKLIE@sound?5default?5gain@
CONST	SEGMENT
??_C@_0BD@KNNAKLIE@sound?5default?5gain@ DB 'sound default gain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HMPPLJEK@s_refdb@
CONST	SEGMENT
??_C@_07HMPPLJEK@s_refdb@ DB 's_refdb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PPBOIJDM@60@
CONST	SEGMENT
??_C@_02PPBOIJDM@60@ DB '60', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CCJCHMK@soundlevel?5refernce?5dB@
CONST	SEGMENT
??_C@_0BH@CCJCHMK@soundlevel?5refernce?5dB@ DB 'soundlevel refernce dB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCMODNKC@s_refdist@
CONST	SEGMENT
??_C@_09HCMODNKC@s_refdist@ DB 's_refdist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36@
CONST	SEGMENT
??_C@_02KPIPOMFB@36@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JNLHGNDP@soundlevel?5reference?5distance@
CONST	SEGMENT
??_C@_0BO@JNLHGNDP@soundlevel?5reference?5distance@ DB 'soundlevel refere'
	DB	'nce distance', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJCAMEEI@snd_gain_min@
CONST	SEGMENT
??_C@_0N@FJCAMEEI@snd_gain_min@ DB 'snd_gain_min', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKCHIKEL@0?401@
CONST	SEGMENT
??_C@_04DKCHIKEL@0?401@ DB '0.01', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CAHMMIEJ@gain?5minimal?5threshold@
CONST	SEGMENT
??_C@_0BH@CAHMMIEJ@gain?5minimal?5threshold@ DB 'gain minimal threshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ELKLCACH@snd_gain_max@
CONST	SEGMENT
??_C@_0N@ELKLCACH@snd_gain_max@ DB 'snd_gain_max', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HDNKNAKN@gain?5maximal?5threshold@
CONST	SEGMENT
??_C@_0BH@HDNKNAKN@gain?5maximal?5threshold@ DB 'gain maximal threshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NECBKIEK@snd_foliage_db_loss@
CONST	SEGMENT
??_C@_0BE@NECBKIEK@snd_foliage_db_loss@ DB 'snd_foliage_db_loss', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4@
CONST	SEGMENT
??_C@_01FAMBOPH@4@ DB '4', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ODLIHDCK@foliage?5loss?5factor@
CONST	SEGMENT
??_C@_0BE@ODLIHDCK@foliage?5loss?5factor@ DB 'foliage loss factor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OPAKHCCE@s_combine_channels@
CONST	SEGMENT
??_C@_0BD@OPAKHCCE@s_combine_channels@ DB 's_combine_channels', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HMJNPNMG@combine?5channels?5with?5same?5soun@
CONST	SEGMENT
??_C@_0CC@HMJNPNMG@combine?5channels?5with?5same?5soun@ DB 'combine chann'
	DB	'els with same sounds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEIPABOO@ambient_fade@
CONST	SEGMENT
??_C@_0N@EEIPABOO@ambient_fade@ DB 'ambient_fade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KOJKLCBG@1000@
CONST	SEGMENT
??_C@_04KOJKLCBG@1000@ DB '1000', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HCOPHGBE@rate?5of?5volume?5fading?5when?5clie@
CONST	SEGMENT
??_C@_0CM@HCOPHGBE@rate?5of?5volume?5fading?5when?5clie@ DB 'rate of volu'
	DB	'me fading when client is moving', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CALFHOGH@ambient_level@
CONST	SEGMENT
??_C@_0O@CALFHOGH@ambient_level@ DB 'ambient_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OICINGJI@0?43@
CONST	SEGMENT
??_C@_03OICINGJI@0?43@ DB '0.3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JCIHEOCN@volume?5of?5environment?5noises?5?$CIw@
CONST	SEGMENT
??_C@_0CO@JCIHEOCN@volume?5of?5environment?5noises?5?$CIw@ DB 'volume of '
	DB	'environment noises (water and wind)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDMJBOMF@s_lerping@
CONST	SEGMENT
??_C@_09GDMJBOMF@s_lerping@ DB 's_lerping', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CMGAPAHP@apply?5interpolation?5to?5sound?5ou@
CONST	SEGMENT
??_C@_0CE@CMGAPAHP@apply?5interpolation?5to?5sound?5ou@ DB 'apply interpo'
	DB	'lation to sound output', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBNOHGMK@s_show@
CONST	SEGMENT
??_C@_06CBNOHGMK@s_show@ DB 's_show', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NKNFOPGI@show?5playing?5sounds@
CONST	SEGMENT
??_C@_0BE@NKNFOPGI@show?5playing?5sounds@ DB 'show playing sounds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCANMFKJ@_snd_mixahead@
CONST	SEGMENT
??_C@_0O@KCANMFKJ@_snd_mixahead@ DB '_snd_mixahead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAMILDLP@0?412@
CONST	SEGMENT
??_C@_04BAMILDLP@0?412@ DB '0.12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MCODGGLH@how?5much?5sound?5to?5mix?5ahead?5of?5@
CONST	SEGMENT
??_C@_0CE@MCODGGLH@how?5much?5sound?5to?5mix?5ahead?5of?5@ DB 'how much s'
	DB	'ound to mix ahead of time', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OPCAGCAA@MP3Volume@
CONST	SEGMENT
??_C@_09OPCAGCAA@MP3Volume@ DB 'MP3Volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40@ DB '1.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NFGOLMDH@background?5music?5volume@
CONST	SEGMENT
??_C@_0BI@NFGOLMDH@background?5music?5volume@ DB 'background music volume'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06EMCPHFGM@volume@
CONST	SEGMENT
??_C@_06EMCPHFGM@volume@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IMEEBDJM@0?47@
CONST	SEGMENT
??_C@_03IMEEBDJM@0?47@ DB '0.7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLGNHHCP@sound?5volume@
CONST	SEGMENT
??_C@_0N@DLGNHHCP@sound?5volume@ DB 'sound volume', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DKLPDJJH@Audio?3?5Disabled?6@
CONST	SEGMENT
??_C@_0BB@DKLPDJJH@Audio?3?5Disabled?6@ DB 'Audio: Disabled', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLDKIHPE@?9nosound@
CONST	SEGMENT
??_C@_08FLDKIHPE@?9nosound@ DB '-nosound', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_Init@@9@9 DD 091cH			; `S_Init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@FHKOKMBN@?$CF5d?5total_channels?6@
CONST	SEGMENT
??_C@_0BE@FHKOKMBN@?$CF5d?5total_channels?6@ DB '%5d total_channels', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEEOPNMB@?$CF5d?5bytes?1sec?6@
CONST	SEGMENT
??_C@_0P@HEEOPNMB@?$CF5d?5bytes?1sec?6@ DB '%5d bytes/sec', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAEGPPBO@?$CF5d?5bits?1sample?6@
CONST	SEGMENT
??_C@_0BB@DAEGPPBO@?$CF5d?5bits?1sample?6@ DB '%5d bits/sample', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFEODKMK@?$CF5d?5samples?6@
CONST	SEGMENT
??_C@_0N@LFEODKMK@?$CF5d?5samples?6@ DB '%5d samples', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOMDFKBJ@?$CF5d?5channel?$CIs?$CJ?6@
CONST	SEGMENT
??_C@_0BA@JOMDFKBJ@?$CF5d?5channel?$CIs?$CJ?6@ DB '%5d channel(s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GJHINAHM@Audio?3?5DirectSound?6@
CONST	SEGMENT
??_C@_0BE@GJHINAHM@Audio?3?5DirectSound?6@ DB 'Audio: DirectSound', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IHECAEFP@restored@
CONST	SEGMENT
??_C@_08IHECAEFP@restored@ DB 'restored', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOKAPKFF@onloop@
CONST	SEGMENT
??_C@_06HOKAPKFF@onloop@ DB 'onloop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCBNCGFH@pos@
CONST	SEGMENT
??_C@_03PCBNCGFH@pos@ DB 'pos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GKOOIABA@loop@
CONST	SEGMENT
??_C@_04GKOOIABA@loop@ DB 'loop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PEGFANN@stop@
CONST	SEGMENT
??_C@_04PEGFANN@stop@ DB 'stop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@BFMIJHBO@Usage?3?5music?5?$DMmusicfile?$DO?5?$FLloopf@
CONST	SEGMENT
??_C@_0FM@BFMIJHBO@Usage?3?5music?5?$DMmusicfile?$DO?5?$FLloopf@ DB 'Usag'
	DB	'e: music <musicfile> [loopfile] [loop] [numLoops] [pos] [posi'
	DB	'tion] [onloop] [restored]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PEDOOMJF@Usage?3?5spk?5?$DMsoundfile?$DO?6@
CONST	SEGMENT
??_C@_0BI@PEDOOMJF@Usage?3?5spk?5?$DMsoundfile?$DO?6@ DB 'Usage: spk <sou'
	DB	'ndfile>', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HODGAGPK@Usage?3?5speak?5?$DMsoundfile?$DO?6@
CONST	SEGMENT
??_C@_0BK@HODGAGPK@Usage?3?5speak?5?$DMsoundfile?$DO?6@ DB 'Usage: speak '
	DB	'<soundfile>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CIGEOFAG@Usage?3?5playvol?5?$DMsoundfile?5volum@
CONST	SEGMENT
??_C@_0CD@CIGEOFAG@Usage?3?5playvol?5?$DMsoundfile?5volum@ DB 'Usage: pla'
	DB	'yvol <soundfile volume>', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PBONNAAC@Usage?3?5play2?5?$DMsoundfile?$DO?6@
CONST	SEGMENT
??_C@_0BK@PBONNAAC@Usage?3?5play2?5?$DMsoundfile?$DO?6@ DB 'Usage: play2 '
	DB	'<soundfile>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBKGLAEH@Usage?3?5play?5?$DMsoundfile?$DO?6@
CONST	SEGMENT
??_C@_0BJ@BBKGLAEH@Usage?3?5play?5?$DMsoundfile?$DO?6@ DB 'Usage: play <s'
	DB	'oundfile>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIBIENGJ@room_type?3?5?$CFi?5?9?9?9?9?$CI?$CFi?$CJ?9?9?9?9?5pain@
CONST	SEGMENT
??_C@_0CI@EIBIENGJ@room_type?3?5?$CFi?5?9?9?9?9?$CI?$CFi?$CJ?9?9?9?9?5pain@ DB 'r'
	DB	'oom_type: %i ----(%i)---- painted: %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IALGGBFP@chan?5?$CFi?0?5pos?5?$CI?$CF?4f?5?$CF?4f?5?$CF?4f?$CJ?5ent?5@
CONST	SEGMENT
??_C@_0DD@IALGGBFP@chan?5?$CFi?0?5pos?5?$CI?$CF?4f?5?$CF?4f?5?$CF?4f?$CJ?5ent?5@ DB 'c'
	DB	'han %i, pos (%.f %.f %.f) ent %i, lv%3i rv%3i %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_FreeRawChannels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_FreeRawChannels@@9@9 DD 071dH	; `S_FreeRawChannels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??S_FreeIdleRawChannels@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_FreeIdleRawChannels@@9@9 DD 06acH	; `S_FreeIdleRawChannels'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\s_main.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_FindRawChannel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_FindRawChannel@@9@9 DD 0598H		; `S_FindRawChannel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08KPIGECMN@?$CKdefault@
CONST	SEGMENT
??_C@_08KPIGECMN@?$CKdefault@ DB '*default', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IFNNOFCP@?$FO1Error?3?$FO7?5dropped?5sound?5?$CC?$CFs?$CFs?$CC@
CONST	SEGMENT
??_C@_0CB@IFNNOFCP@?$FO1Error?3?$FO7?5dropped?5sound?5?$CC?$CFs?$CFs?$CC@ DB '^'
	DB	'1Error:^7 dropped sound "%s%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBLIODKG@sound?1@
CONST	SEGMENT
??_C@_06PBLIODKG@sound?1@ DB 'sound/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GJNKBDLN@?$FO1Error?3?$FO7?5S_PickStaticChannel?3@
CONST	SEGMENT
??_C@_0DC@GJNKBDLN@?$FO1Error?3?$FO7?5S_PickStaticChannel?3@ DB '^1Error:'
	DB	'^7 S_PickStaticChannel: no free channels', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0377H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	047H
	DW	02e0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	039H
	DB	04fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	063H
	DB	079H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	03b4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0ff4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	05a0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	015cH
	DW	0173H
	DW	0205H
	DW	0223H
	DW	038fH
	DW	03abH
	DW	03baH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	025H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	03fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	085H
	DW	0132H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_SoundFade_f
_TEXT	SEGMENT
tv84 = -104						; size = 8
tv83 = -96						; size = 8
tv138 = -88						; size = 8
tv132 = -80						; size = 8
_fadeTime$ = -8						; size = 4
_c$ = -4						; size = 4
_S_SoundFade_f PROC					; COMDAT

; 2298 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 2299 : 	int	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 2300 : 	float	fadeTime = 5.0f;

	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _fadeTime$[ebp], xmm0

; 2301 : 
; 2302 : 	if( c == 2 )

	cmp	DWORD PTR _c$[ebp], 2
	jne	$LN2@S_SoundFad

; 2303 : 		fadeTime = bound( 1.0f, atof( Cmd_Argv( 1 )), 60.0f );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv132[ebp]
	movsd	xmm0, QWORD PTR tv132[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN6@S_SoundFad
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv138[ebp]
	movsd	xmm0, QWORD PTR __real@404e000000000000
	comisd	xmm0, QWORD PTR tv138[ebp]
	jbe	SHORT $LN4@S_SoundFad
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	fstp	QWORD PTR tv83[ebp]
	jmp	SHORT $LN5@S_SoundFad
$LN4@S_SoundFad:
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR tv83[ebp], xmm0
$LN5@S_SoundFad:
	movsd	xmm0, QWORD PTR tv83[ebp]
	movsd	QWORD PTR tv84[ebp], xmm0
	jmp	SHORT $LN7@S_SoundFad
$LN6@S_SoundFad:
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv84[ebp], xmm0
$LN7@S_SoundFad:
	cvtsd2ss xmm0, QWORD PTR tv84[ebp]
	movss	DWORD PTR _fadeTime$[ebp], xmm0
$LN2@S_SoundFad:

; 2304 : 
; 2305 : 	S_FadeClientVolume( 100.0f, fadeTime, 1.0f, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _fadeTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeClientVolume
	add	esp, 16					; 00000010H

; 2306 : 	snd_fade_sequence = true;

	mov	DWORD PTR _snd_fade_sequence, 1

; 2307 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SoundFade_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StopSound_f
_TEXT	SEGMENT
_S_StopSound_f PROC					; COMDAT

; 2288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2289 : 	S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2290 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopSound_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Music_f
_TEXT	SEGMENT
_i$1 = -556						; size = 4
_restored$2 = -552					; size = 4
_onLoop$3 = -548					; size = 4
_restoredPos$4 = -544					; size = 4
_onLoopPos$5 = -540					; size = 4
_posArgPos$6 = -536					; size = 4
_loopArgPos$7 = -532					; size = 4
_position$8 = -528					; size = 4
_numLoop$9 = -524					; size = 4
_main$10 = -520						; size = 256
_intro$11 = -264					; size = 256
_c$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_S_Music_f PROC						; COMDAT

; 2167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2168 : 	int	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 2169 : 	// run background track
; 2170 : 	if( c == 1 )

	cmp	DWORD PTR _c$[ebp], 1
	jne	SHORT $LN5@S_Music_f

; 2171 : 	{
; 2172 : 		// Instruct on usage of command instead of stopping track, adding "stop" command to this
; 2173 : 		Con_Printf(S_USAGE "music <musicfile> [loopfile] [loop] [numLoops] [pos] [position] [onloop] [restored]\n");

	push	OFFSET ??_C@_0FM@BFMIJHBO@Usage?3?5music?5?$DMmusicfile?$DO?5?$FLloopf@
	call	_Con_Printf
	add	esp, 4

; 2174 : 	}

	jmp	$LN1@S_Music_f
$LN5@S_Music_f:

; 2175 : 	else
; 2176 : 	{
; 2177 : 		// Having this stops the track, don't bother with anything else afterwards
; 2178 : 		if (!Q_strcmp(Cmd_Argv(1), "stop"))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04PEGFANN@stop@
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@S_Music_f

; 2179 : 		{
; 2180 : 			S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 2181 : 			return;

	jmp	$LN1@S_Music_f
$LN7@S_Music_f:

; 2182 : 		}
; 2183 : 
; 2184 : 		// Map of arguments (7)
; 2185 : 		// music: 0
; 2186 : 		// introTrack: 1
; 2187 : 		// mainTrack: 2
; 2188 : 		// loop: 3
; 2189 : 		// numLoops: 4
; 2190 : 		// pos: 5
; 2191 : 		// position: 6
; 2192 : 		// onloop: 7
; 2193 : 		// restored: 8
; 2194 : 
; 2195 : 		// Cancel in this case
; 2196 : 		if (c < 2)

	cmp	DWORD PTR _c$[ebp], 2
	jge	SHORT $LN8@S_Music_f

; 2197 : 			return;

	jmp	$LN1@S_Music_f
$LN8@S_Music_f:

; 2198 : 
; 2199 : 		// Loop is definied, check for it
; 2200 : 		string intro, main;
; 2201 : 		int numLoop = 0;

	mov	DWORD PTR _numLoop$9[ebp], 0

; 2202 : 		long position = 0;

	mov	DWORD PTR _position$8[ebp], 0

; 2203 : 		int loopArgPos = -1;

	mov	DWORD PTR _loopArgPos$7[ebp], -1

; 2204 : 		int posArgPos = -1;

	mov	DWORD PTR _posArgPos$6[ebp], -1

; 2205 : 		int onLoopPos = -1;

	mov	DWORD PTR _onLoopPos$5[ebp], -1

; 2206 : 		int restoredPos = -1;

	mov	DWORD PTR _restoredPos$4[ebp], -1

; 2207 : 		qboolean onLoop = false;

	mov	DWORD PTR _onLoop$3[ebp], 0

; 2208 : 		qboolean restored = false;

	mov	DWORD PTR _restored$2[ebp], 0

; 2209 : 
; 2210 : 		// Try to find loop argument
; 2211 : 		for (int i = 1; i < c; i++)

	mov	DWORD PTR _i$1[ebp], 1
	jmp	SHORT $LN4@S_Music_f
$LN2@S_Music_f:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@S_Music_f:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	$LN3@S_Music_f

; 2212 : 		{
; 2213 : 			if (loopArgPos == -1)

	cmp	DWORD PTR _loopArgPos$7[ebp], -1
	jne	SHORT $LN9@S_Music_f

; 2214 : 			{
; 2215 : 				if (!Q_strcmp(Cmd_Argv(i), "loop"))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04GKOOIABA@loop@
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@S_Music_f

; 2216 : 				{
; 2217 : 					loopArgPos = i;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _loopArgPos$7[ebp], eax

; 2218 : 					numLoop = -1;

	mov	DWORD PTR _numLoop$9[ebp], -1
$LN9@S_Music_f:

; 2219 : 				}
; 2220 : 			}
; 2221 : 
; 2222 : 			if (posArgPos == -1)

	cmp	DWORD PTR _posArgPos$6[ebp], -1
	jne	SHORT $LN11@S_Music_f

; 2223 : 			{
; 2224 : 				if (!Q_strcmp(Cmd_Argv(i), "pos"))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03PCBNCGFH@pos@
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@S_Music_f

; 2225 : 				{
; 2226 : 					posArgPos = i;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _posArgPos$6[ebp], eax

; 2227 : 					position = 0;

	mov	DWORD PTR _position$8[ebp], 0
$LN11@S_Music_f:

; 2228 : 				}
; 2229 : 			}
; 2230 : 
; 2231 : 			if (onLoopPos == -1)

	cmp	DWORD PTR _onLoopPos$5[ebp], -1
	jne	SHORT $LN13@S_Music_f

; 2232 : 			{
; 2233 : 				if (!Q_strcmp(Cmd_Argv(i), "onloop"))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06HOKAPKFF@onloop@
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@S_Music_f

; 2234 : 				{
; 2235 : 					onLoop = true;

	mov	DWORD PTR _onLoop$3[ebp], 1

; 2236 : 					onLoopPos = i;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _onLoopPos$5[ebp], eax
$LN13@S_Music_f:

; 2237 : 				}
; 2238 : 			}
; 2239 : 
; 2240 : 			if (restoredPos == -1)

	cmp	DWORD PTR _restoredPos$4[ebp], -1
	jne	SHORT $LN15@S_Music_f

; 2241 : 			{
; 2242 : 				if (!Q_strcmp(Cmd_Argv(i), "restored"))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08IHECAEFP@restored@
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@S_Music_f

; 2243 : 				{
; 2244 : 					restored = true;

	mov	DWORD PTR _restored$2[ebp], 1

; 2245 : 					restoredPos = i;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _restoredPos$4[ebp], eax
$LN15@S_Music_f:

; 2246 : 				}
; 2247 : 			}
; 2248 : 		}

	jmp	$LN2@S_Music_f
$LN3@S_Music_f:

; 2249 : 
; 2250 : 		// Try to find number of loops
; 2251 : 		if (loopArgPos != -1)

	cmp	DWORD PTR _loopArgPos$7[ebp], -1
	je	SHORT $LN17@S_Music_f

; 2252 : 		{
; 2253 : 			if (loopArgPos < (c - 1) && Q_isdigit(Cmd_Argv(loopArgPos + 1)))

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _loopArgPos$7[ebp], eax
	jge	SHORT $LN17@S_Music_f
	mov	eax, DWORD PTR _loopArgPos$7[ebp]
	add	eax, 1
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@S_Music_f

; 2254 : 				numLoop = Q_atoi(Cmd_Argv(loopArgPos + 1));

	mov	eax, DWORD PTR _loopArgPos$7[ebp]
	add	eax, 1
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _numLoop$9[ebp], eax
$LN17@S_Music_f:

; 2255 : 		}
; 2256 : 
; 2257 : 		// Try to find position
; 2258 : 		if (posArgPos != -1)

	cmp	DWORD PTR _posArgPos$6[ebp], -1
	je	SHORT $LN19@S_Music_f

; 2259 : 		{
; 2260 : 			if (posArgPos < (c - 1) && Q_isdigit(Cmd_Argv(posArgPos + 1)))

	mov	eax, DWORD PTR _c$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _posArgPos$6[ebp], eax
	jge	SHORT $LN19@S_Music_f
	mov	eax, DWORD PTR _posArgPos$6[ebp]
	add	eax, 1
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@S_Music_f

; 2261 : 				position = atol(Cmd_Argv(posArgPos + 1));

	mov	eax, DWORD PTR _posArgPos$6[ebp]
	add	eax, 1
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _position$8[ebp], eax
$LN19@S_Music_f:

; 2262 : 		}
; 2263 : 
; 2264 : 		//Con_Printf("loopArgPos: %d\n", loopArgPos);
; 2265 : 		//Con_Printf("posArgPos: %d\n", posArgPos);
; 2266 : 		//Con_Printf("argc: %d\n", c);
; 2267 : 		//Con_Printf("restored: %d\n", restored);
; 2268 : 
; 2269 : 		// If it's not loop on the third argument, then it's a second section of the song
; 2270 : 		Q_snprintf(intro, sizeof(intro), "%s", Cmd_Argv(1)); // if c is not equal to 1, it's either 2 or higher, always make 1 be the track name

	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	256					; 00000100H
	lea	eax, DWORD PTR _intro$11[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 2271 : 		if (loopArgPos != 2 && posArgPos != 2 && onLoopPos != 2 && restoredPos != 2 && c >= 3)

	cmp	DWORD PTR _loopArgPos$7[ebp], 2
	je	SHORT $LN21@S_Music_f
	cmp	DWORD PTR _posArgPos$6[ebp], 2
	je	SHORT $LN21@S_Music_f
	cmp	DWORD PTR _onLoopPos$5[ebp], 2
	je	SHORT $LN21@S_Music_f
	cmp	DWORD PTR _restoredPos$4[ebp], 2
	je	SHORT $LN21@S_Music_f
	cmp	DWORD PTR _c$[ebp], 3
	jl	SHORT $LN21@S_Music_f

; 2272 : 			Q_snprintf(main, sizeof(main), "%s", Cmd_Argv(2));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	256					; 00000100H
	lea	eax, DWORD PTR _main$10[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN22@S_Music_f
$LN21@S_Music_f:

; 2273 : 		else
; 2274 : 			Q_snprintf(main, sizeof(main), "%s", "");

	push	OFFSET ??_C@_00CNPNBAHC@@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	256					; 00000100H
	lea	eax, DWORD PTR _main$10[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H
$LN22@S_Music_f:

; 2275 : 
; 2276 : 		//Con_Printf("main: %s\n", main);
; 2277 : 
; 2278 : 		S_StartBackgroundTrack(intro, main, position, numLoop, onLoop, restored, true);

	push	1
	mov	eax, DWORD PTR _restored$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _onLoop$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _numLoop$9[ebp]
	push	edx
	mov	eax, DWORD PTR _position$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _main$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _intro$11[ebp]
	push	edx
	call	_S_StartBackgroundTrack
	add	esp, 28					; 0000001cH
$LN1@S_Music_f:

; 2279 : 	}
; 2280 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Music_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_SayReliable_f
_TEXT	SEGMENT
_S_SayReliable_f PROC					; COMDAT

; 2151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2152 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_SayRelia

; 2153 : 	{
; 2154 : 		Con_Printf( S_USAGE "spk <soundfile>\n" );

	push	OFFSET ??_C@_0BI@PEDOOMJF@Usage?3?5spk?5?$DMsoundfile?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 2155 : 		return;

	jmp	SHORT $LN1@S_SayRelia
$LN2@S_SayRelia:

; 2156 : 	}
; 2157 : 
; 2158 : 	S_StartLocalSound( Cmd_Argv( 1 ), 1.0f, true );

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_SayRelia:

; 2159 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SayReliable_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Say_f
_TEXT	SEGMENT
_S_Say_f PROC						; COMDAT

; 2140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2141 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_Say_f

; 2142 : 	{
; 2143 : 		Con_Printf( S_USAGE "speak <soundfile>\n" );

	push	OFFSET ??_C@_0BK@HODGAGPK@Usage?3?5speak?5?$DMsoundfile?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 2144 : 		return;

	jmp	SHORT $LN1@S_Say_f
$LN2@S_Say_f:

; 2145 : 	}
; 2146 : 
; 2147 : 	S_StartLocalSound( Cmd_Argv( 1 ), 1.0f, false );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_Say_f:

; 2148 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Say_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_PlayVol_f
_TEXT	SEGMENT
_S_PlayVol_f PROC					; COMDAT

; 2129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2130 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_PlayVol_

; 2131 : 	{
; 2132 : 		Con_Printf( S_USAGE "playvol <soundfile volume>\n" );

	push	OFFSET ??_C@_0CD@CIGEOFAG@Usage?3?5playvol?5?$DMsoundfile?5volum@
	call	_Con_Printf
	add	esp, 4

; 2133 : 		return;

	jmp	SHORT $LN1@S_PlayVol_
$LN2@S_PlayVol_:

; 2134 : 	}
; 2135 : 
; 2136 : 	S_StartLocalSound( Cmd_Argv( 1 ), Q_atof( Cmd_Argv( 2 )), false );

	push	0
	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atof
	fstp	DWORD PTR [esp]
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_PlayVol_:

; 2137 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PlayVol_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Play2_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_Play2_f PROC						; COMDAT

; 2112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2113 : 	int	i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 2114 : 
; 2115 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN4@S_Play2_f

; 2116 : 	{
; 2117 : 		Con_Printf( S_USAGE "play2 <soundfile>\n" );

	push	OFFSET ??_C@_0BK@PBONNAAC@Usage?3?5play2?5?$DMsoundfile?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 2118 : 		return;

	jmp	SHORT $LN3@S_Play2_f
$LN4@S_Play2_f:

; 2119 : 	}
; 2120 : 
; 2121 : 	while( i < Cmd_Argc( ))

	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@S_Play2_f

; 2122 : 	{
; 2123 : 		S_StartLocalSound( Cmd_Argv( i ), VOL_NORM, true );

	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH

; 2124 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 2125 : 	}

	jmp	SHORT $LN4@S_Play2_f
$LN3@S_Play2_f:

; 2126 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Play2_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Play_f
_TEXT	SEGMENT
_S_Play_f PROC						; COMDAT

; 2101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2102 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN2@S_Play_f

; 2103 : 	{
; 2104 : 		Con_Printf( S_USAGE "play <soundfile>\n" );

	push	OFFSET ??_C@_0BJ@BBKGLAEH@Usage?3?5play?5?$DMsoundfile?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 2105 : 		return;

	jmp	SHORT $LN1@S_Play_f
$LN2@S_Play_f:

; 2106 : 	}
; 2107 : 
; 2108 : 	S_StartLocalSound( Cmd_Argv( 1 ), VOL_NORM, false );

	push	0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_S_StartLocalSound
	add	esp, 12					; 0000000cH
$LN1@S_Play_f:

; 2109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Play_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_UpdateChannels
_TEXT	SEGMENT
_samps$ = -8						; size = 4
_endtime$ = -4						; size = 4
_S_UpdateChannels PROC					; COMDAT

; 1902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1903 : 	uint	endtime;
; 1904 : 	int	samps;
; 1905 : 
; 1906 : 	SNDDMA_BeginPainting();

	call	_SNDDMA_BeginPainting

; 1907 : 
; 1908 : 	if( !dma.buffer ) return;

	cmp	DWORD PTR _dma+8, 0
	jne	SHORT $LN2@S_UpdateCh
	jmp	$LN1@S_UpdateCh
$LN2@S_UpdateCh:

; 1909 : 
; 1910 : 	// updates DMA time
; 1911 : 	soundtime = SNDDMA_GetSoundtime();

	call	_SNDDMA_GetSoundtime
	mov	DWORD PTR _soundtime, eax

; 1912 : 
; 1913 : 	// soundtime - total samples that have been played out to hardware at dmaspeed
; 1914 : 	// paintedtime - total samples that have been mixed at speed
; 1915 : 	// endtime - target for samples in mixahead buffer at speed
; 1916 : 	endtime = soundtime + s_mixahead->value * SOUND_DMA_SPEED;

	cvtsi2ss xmm0, DWORD PTR _soundtime
	mov	eax, DWORD PTR _s_mixahead
	movss	xmm1, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR __real@472c4400
	addss	xmm0, xmm1
	call	__ftol3
	mov	DWORD PTR _endtime$[ebp], eax

; 1917 : 	samps = dma.samples >> 1;

	mov	eax, DWORD PTR _dma
	sar	eax, 1
	mov	DWORD PTR _samps$[ebp], eax

; 1918 : 
; 1919 : 	if((int)(endtime - soundtime) > samps )

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _soundtime
	cmp	eax, DWORD PTR _samps$[ebp]
	jle	SHORT $LN3@S_UpdateCh

; 1920 : 		endtime = soundtime + samps;

	mov	eax, DWORD PTR _soundtime
	add	eax, DWORD PTR _samps$[ebp]
	mov	DWORD PTR _endtime$[ebp], eax
$LN3@S_UpdateCh:

; 1921 : 	
; 1922 : 	if(( endtime - paintedtime ) & 0x3 )

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _paintedtime
	and	eax, 3
	je	SHORT $LN4@S_UpdateCh

; 1923 : 	{
; 1924 : 		// the difference between endtime and painted time should align on 
; 1925 : 		// boundaries of 4 samples. this is important when upsampling from 11khz -> 44khz.
; 1926 : 		endtime -= ( endtime - paintedtime ) & 0x3;

	mov	eax, DWORD PTR _endtime$[ebp]
	sub	eax, DWORD PTR _paintedtime
	and	eax, 3
	mov	ecx, DWORD PTR _endtime$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _endtime$[ebp], ecx
$LN4@S_UpdateCh:

; 1927 : 	}
; 1928 : 
; 1929 : 	MIX_PaintChannels( endtime );

	mov	eax, DWORD PTR _endtime$[ebp]
	push	eax
	call	_MIX_PaintChannels
	add	esp, 4

; 1930 : 
; 1931 : 	SNDDMA_Submit();

	call	_SNDDMA_Submit
$LN1@S_UpdateCh:

; 1932 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_ClearBuffer
_TEXT	SEGMENT
_S_ClearBuffer PROC					; COMDAT

; 1842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1843 : 	S_ClearRawChannels();

	call	_S_ClearRawChannels

; 1844 : 
; 1845 : 	SNDDMA_BeginPainting ();

	call	_SNDDMA_BeginPainting

; 1846 : 	if( dma.buffer ) memset( dma.buffer, 0, dma.samples * 2 );

	cmp	DWORD PTR _dma+8, 0
	je	SHORT $LN2@S_ClearBuf
	mov	eax, DWORD PTR _dma
	shl	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _dma+8
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@S_ClearBuf:

; 1847 : 	SNDDMA_Submit ();

	call	_SNDDMA_Submit

; 1848 : 
; 1849 : 	MIX_ClearAllPaintBuffers( PAINTBUFFER_SIZE, true );

	push	1
	push	1024					; 00000400H
	call	_MIX_ClearAllPaintBuffers
	add	esp, 8

; 1850 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_ClearBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_FreeRawChannels
_TEXT	SEGMENT
_i$ = -4						; size = 4
_S_FreeRawChannels PROC					; COMDAT

; 1821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1822 : 	int	i;
; 1823 : 
; 1824 : 	// free raw samples
; 1825 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FreeRawC
$LN2@S_FreeRawC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_FreeRawC:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_FreeRawC

; 1826 : 	{
; 1827 : 		if( raw_channels[i] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _raw_channels[eax*4], 0
	je	SHORT $LN5@S_FreeRawC

; 1828 : 			Mem_Free( raw_channels[i] );

	mov	eax, DWORD PTR ?__LINE__Var@?0??S_FreeRawChannels@@9@9
	add	eax, 7
	push	eax
	push	OFFSET ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _raw_channels[ecx*4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@S_FreeRawC:

; 1829 : 	}

	jmp	SHORT $LN2@S_FreeRawC
$LN3@S_FreeRawC:

; 1830 : 
; 1831 : 	memset( raw_channels, 0, sizeof( raw_channels ));

	push	64					; 00000040H
	push	0
	push	OFFSET _raw_channels
	call	_memset
	add	esp, 12					; 0000000cH

; 1832 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_SpatializeRawChannels
_TEXT	SEGMENT
tv145 = -108						; size = 4
_blend$1 = -40						; size = 4
_interval$2 = -36					; size = 4
_dot$3 = -32						; size = 4
_dist$4 = -28						; size = 4
_source_vec$5 = -24					; size = 12
_ch$6 = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_S_SpatializeRawChannels PROC				; COMDAT

; 1753 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1754 : 	int	i;
; 1755 : 	
; 1756 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_Spatiali
$LN2@S_Spatiali:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_Spatiali:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	$LN3@S_Spatiali

; 1757 : 	{
; 1758 : 		rawchan_t	*ch = raw_channels[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$6[ebp], ecx

; 1759 : 		vec3_t	source_vec;
; 1760 : 		float	dist, dot;
; 1761 : 
; 1762 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$6[ebp], 0
	jne	SHORT $LN5@S_Spatiali
	jmp	SHORT $LN2@S_Spatiali
$LN5@S_Spatiali:

; 1763 : 
; 1764 : 		if( ch->s_rawend < paintedtime )

	mov	eax, DWORD PTR _ch$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	jae	SHORT $LN6@S_Spatiali

; 1765 : 		{
; 1766 : 			ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$6[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _ch$6[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1767 : 			continue;

	jmp	SHORT $LN2@S_Spatiali
$LN6@S_Spatiali:

; 1768 : 		}
; 1769 : 
; 1770 : 		// spatialization
; 1771 : 		if( !S_IsClient( ch->entnum ) && ch->dist_mult && ch->entnum >= 0 && ch->entnum < GI->max_edicts )

	mov	eax, DWORD PTR _ch$6[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	jne	$LN7@S_Spatiali
	mov	eax, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@S_Spatiali
	mov	eax, DWORD PTR _ch$6[ebp]
	cmp	DWORD PTR [eax], 0
	jl	$LN7@S_Spatiali
	mov	eax, DWORD PTR _ch$6[ebp]
	mov	ecx, DWORD PTR _SI+768
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+1656]
	jge	$LN7@S_Spatiali

; 1772 : 		{
; 1773 : 			if( !CL_GetMovieSpatialization( ch ))

	mov	eax, DWORD PTR _ch$6[ebp]
	push	eax
	call	_CL_GetMovieSpatialization
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN9@S_Spatiali

; 1774 : 			{
; 1775 : 				// origin is null and entity not exist on client
; 1776 : 				ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$6[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _ch$6[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1777 : 			}

	jmp	$LN10@S_Spatiali
$LN9@S_Spatiali:

; 1778 : 			else
; 1779 : 			{
; 1780 : 				VectorSubtract( ch->origin, s_listener.origin, source_vec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+20]
	subss	xmm0, DWORD PTR _s_listener[eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _source_vec$5[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+20]
	subss	xmm0, DWORD PTR _s_listener[eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _source_vec$5[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [edx+eax+20]
	subss	xmm0, DWORD PTR _s_listener[ecx]
	movss	DWORD PTR tv145[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv145[ebp]
	movss	DWORD PTR _source_vec$5[ebp+eax], xmm0

; 1781 : 
; 1782 : 				// normalize source_vec and get distance from listener to source
; 1783 : 				dist = VectorNormalizeLength( source_vec );

	lea	eax, DWORD PTR _source_vec$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _source_vec$5[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$4[ebp]

; 1784 : 				dot = DotProduct( s_listener.right, source_vec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _s_listener[ecx+36]
	mulss	xmm0, DWORD PTR _source_vec$5[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _s_listener[ecx+36]
	mulss	xmm1, DWORD PTR _source_vec$5[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _s_listener[eax+36]
	mulss	xmm1, DWORD PTR _source_vec$5[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$3[ebp], xmm0

; 1785 : 
; 1786 : 				// for sounds with a radius, spatialize left/right evenly within the radius
; 1787 : 				if( ch->radius > 0 && dist < ch->radius )

	mov	eax, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN11@S_Spatiali
	mov	eax, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	comiss	xmm0, DWORD PTR _dist$4[ebp]
	jbe	SHORT $LN11@S_Spatiali

; 1788 : 				{
; 1789 : 					float	interval = ch->radius * 0.5f;

	mov	eax, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR [eax+32]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _interval$2[ebp], xmm0

; 1790 : 					float	blend = dist - interval;

	movss	xmm0, DWORD PTR _dist$4[ebp]
	subss	xmm0, DWORD PTR _interval$2[ebp]
	movss	DWORD PTR _blend$1[ebp], xmm0

; 1791 : 
; 1792 : 					if( blend < 0 ) blend = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _blend$1[ebp]
	jbe	SHORT $LN12@S_Spatiali
	xorps	xmm0, xmm0
	movss	DWORD PTR _blend$1[ebp], xmm0
$LN12@S_Spatiali:

; 1793 : 					blend /= interval;	

	movss	xmm0, DWORD PTR _blend$1[ebp]
	divss	xmm0, DWORD PTR _interval$2[ebp]
	movss	DWORD PTR _blend$1[ebp], xmm0

; 1794 : 
; 1795 : 					// blend is 0.0 - 1.0, from 50% radius -> 100% radius
; 1796 : 					// at radius * 0.5, dot is 0 (ie: sound centered left/right)
; 1797 : 					// at radius dot == dot
; 1798 : 					dot *= blend;

	movss	xmm0, DWORD PTR _dot$3[ebp]
	mulss	xmm0, DWORD PTR _blend$1[ebp]
	movss	DWORD PTR _dot$3[ebp], xmm0
$LN11@S_Spatiali:

; 1799 : 				}
; 1800 : 
; 1801 : 				// don't pan sounds with no attenuation
; 1802 : 				if( ch->dist_mult <= 0.0f ) dot = 0.0f;

	mov	eax, DWORD PTR _ch$6[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+16]
	jb	SHORT $LN13@S_Spatiali
	xorps	xmm0, xmm0
	movss	DWORD PTR _dot$3[ebp], xmm0
$LN13@S_Spatiali:

; 1803 : 
; 1804 : 				// fill out channel volumes for single location
; 1805 : 				S_SpatializeChannel( &ch->leftvol, &ch->rightvol, ch->master_vol, 1.0f, dot, dist * ch->dist_mult );

	mov	eax, DWORD PTR _ch$6[ebp]
	movss	xmm0, DWORD PTR _dist$4[ebp]
	mulss	xmm0, DWORD PTR [eax+16]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dot$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$6[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ch$6[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _ch$6[ebp]
	add	ecx, 8
	push	ecx
	call	_S_SpatializeChannel
	add	esp, 24					; 00000018H
$LN10@S_Spatiali:

; 1806 : 			}
; 1807 : 		}

	jmp	SHORT $LN8@S_Spatiali
$LN7@S_Spatiali:

; 1808 : 		else
; 1809 : 		{
; 1810 : 			ch->leftvol = ch->rightvol = ch->master_vol;

	mov	eax, DWORD PTR _ch$6[ebp]
	mov	ecx, DWORD PTR _ch$6[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _ch$6[ebp]
	mov	ecx, DWORD PTR _ch$6[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx
$LN8@S_Spatiali:

; 1811 : 		}
; 1812 : 	}

	jmp	$LN2@S_Spatiali
$LN3@S_Spatiali:

; 1813 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SpatializeRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_ClearRawChannels
_TEXT	SEGMENT
_ch$1 = -8						; size = 4
_i$ = -4						; size = 4
_S_ClearRawChannels PROC				; COMDAT

; 1734 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1735 : 	int	i;
; 1736 : 
; 1737 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_ClearRaw
$LN2@S_ClearRaw:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_ClearRaw:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_ClearRaw

; 1738 : 	{
; 1739 : 		rawchan_t	*ch = raw_channels[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$1[ebp], ecx

; 1740 : 
; 1741 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$1[ebp], 0
	jne	SHORT $LN5@S_ClearRaw
	jmp	SHORT $LN2@S_ClearRaw
$LN5@S_ClearRaw:

; 1742 : 		ch->s_rawend = 0;

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	DWORD PTR [eax+36], 0

; 1743 : 		ch->oldtime = -1;

	mov	eax, DWORD PTR _ch$1[ebp]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [eax+68], xmm0

; 1744 : 	}

	jmp	SHORT $LN2@S_ClearRaw
$LN3@S_ClearRaw:

; 1745 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_ClearRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_FreeIdleRawChannels
_TEXT	SEGMENT
_ch$1 = -8						; size = 4
_i$ = -4						; size = 4
_S_FreeIdleRawChannels PROC				; COMDAT

; 1708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1709 : 	int	i;
; 1710 : 
; 1711 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FreeIdle
$LN2@S_FreeIdle:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_FreeIdle:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN1@S_FreeIdle

; 1712 : 	{
; 1713 : 		rawchan_t	*ch = raw_channels[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$1[ebp], ecx

; 1714 : 
; 1715 : 		if( !ch ) continue;

	cmp	DWORD PTR _ch$1[ebp], 0
	jne	SHORT $LN5@S_FreeIdle
	jmp	SHORT $LN2@S_FreeIdle
$LN5@S_FreeIdle:

; 1716 : 
; 1717 : 		if( ch->s_rawend >= paintedtime )

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	jb	SHORT $LN6@S_FreeIdle

; 1718 : 			continue;

	jmp	SHORT $LN2@S_FreeIdle
$LN6@S_FreeIdle:

; 1719 : 
; 1720 : 		if(( paintedtime - ch->s_rawend ) / SOUND_DMA_SPEED >= S_RAW_SOUND_IDLE_SEC )

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR _paintedtime
	sub	ecx, DWORD PTR [eax+36]
	mov	eax, ecx
	xor	edx, edx
	mov	ecx, 44100				; 0000ac44H
	div	ecx
	cmp	eax, 10					; 0000000aH
	jb	SHORT $LN7@S_FreeIdle

; 1721 : 		{
; 1722 : 			raw_channels[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _raw_channels[eax*4], 0

; 1723 : 			Mem_Free( ch );

	mov	eax, DWORD PTR ?__LINE__Var@?0??S_FreeIdleRawChannels@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _ch$1[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN7@S_FreeIdle:

; 1724 : 		}
; 1725 : 	}

	jmp	SHORT $LN2@S_FreeIdle
$LN1@S_FreeIdle:

; 1726 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeIdleRawChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_RawEntSamples
_TEXT	SEGMENT
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_samples$ = 12						; size = 4
_rate$ = 16						; size = 4
_width$ = 20						; size = 2
_channels$ = 24						; size = 2
_data$ = 28						; size = 4
_snd_vol$ = 32						; size = 4
_S_RawEntSamples PROC					; COMDAT

; 1560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1561 : 	rawchan_t	*ch;
; 1562 : 
; 1563 : 	if( snd_vol < 0 )

	cmp	DWORD PTR _snd_vol$[ebp], 0
	jge	SHORT $LN2@S_RawEntSa

; 1564 : 		snd_vol = 0;

	mov	DWORD PTR _snd_vol$[ebp], 0
$LN2@S_RawEntSa:

; 1565 : 
; 1566 : 	if( !( ch = S_FindRawChannel( entnum, true )))

	push	1
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN3@S_RawEntSa

; 1567 : 		return;

	jmp	SHORT $LN1@S_RawEntSa
$LN3@S_RawEntSa:

; 1568 : 
; 1569 : 	ch->master_vol = snd_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1570 : 	ch->dist_mult = (ATTN_NONE / SND_CLIP_DISTANCE);

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+16], xmm0

; 1571 : 	ch->s_rawend = S_RawSamplesStereo( ch->rawsamples, ch->s_rawend, ch->max_samples, samples, rate, width, channels, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	movzx	ecx, WORD PTR _channels$[ebp]
	push	ecx
	movzx	edx, WORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _rate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _samples$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	call	_S_RawSamplesStereo
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1572 : 	ch->leftvol = ch->rightvol = snd_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _snd_vol$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@S_RawEntSa:

; 1573 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawEntSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_RawSamplesStereo
_TEXT	SEGMENT
tv196 = -92						; size = 4
_in$1 = -24						; size = 4
_in$2 = -20						; size = 4
_dst$ = -16						; size = 4
_src$ = -12						; size = 4
_samplefrac$ = -8					; size = 4
_fracstep$ = -4						; size = 4
_rawsamples$ = 8					; size = 4
_rawend$ = 12						; size = 4
_max_samples$ = 16					; size = 4
_samples$ = 20						; size = 4
_rate$ = 24						; size = 4
_width$ = 28						; size = 2
_channels$ = 32						; size = 2
_data$ = 36						; size = 4
_S_RawSamplesStereo PROC				; COMDAT

; 1494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1495 : 	uint	fracstep, samplefrac;
; 1496 : 	uint	src, dst;
; 1497 : 
; 1498 : 	if( rawend < paintedtime )

	mov	eax, DWORD PTR _rawend$[ebp]
	cmp	eax, DWORD PTR _paintedtime
	jae	SHORT $LN14@S_RawSampl

; 1499 : 		rawend = paintedtime;

	mov	eax, DWORD PTR _paintedtime
	mov	DWORD PTR _rawend$[ebp], eax
$LN14@S_RawSampl:

; 1500 : 
; 1501 : 	fracstep = ((double) rate / (double)SOUND_DMA_SPEED) * (double)(1 << S_RAW_SAMPLES_PRECISION_BITS);

	mov	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv196[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv196[ebp]
	mov	ecx, DWORD PTR tv196[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm0, QWORD PTR __real@40e5888000000000
	mulsd	xmm0, QWORD PTR __real@40d0000000000000
	call	__dtol3
	mov	DWORD PTR _fracstep$[ebp], eax

; 1502 : 	samplefrac = 0;

	mov	DWORD PTR _samplefrac$[ebp], 0

; 1503 : 
; 1504 : 	if( width == 2 )

	movzx	eax, WORD PTR _width$[ebp]
	cmp	eax, 2
	jne	$LN15@S_RawSampl

; 1505 : 	{
; 1506 : 		const short *in = (const short *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _in$2[ebp], eax

; 1507 : 
; 1508 : 		if( channels == 2 )

	movzx	eax, WORD PTR _channels$[ebp]
	cmp	eax, 2
	jne	SHORT $LN17@S_RawSampl

; 1509 : 		{
; 1510 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN4@S_RawSampl
$LN2@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN4@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN3@S_RawSampl

; 1511 : 			{
; 1512 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1513 : 				rawsamples[dst].left = in[src*2+0];

	mov	eax, DWORD PTR _src$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1514 : 				rawsamples[dst].right = in[src*2+1];

	mov	eax, DWORD PTR _src$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 1515 : 			}

	jmp	SHORT $LN2@S_RawSampl
$LN3@S_RawSampl:

; 1516 : 		}

	jmp	SHORT $LN6@S_RawSampl
$LN17@S_RawSampl:

; 1517 : 		else
; 1518 : 		{
; 1519 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN7@S_RawSampl
$LN5@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN7@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN6@S_RawSampl

; 1520 : 			{
; 1521 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1522 : 				rawsamples[dst].left = in[src];

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1523 : 				rawsamples[dst].right = in[src];

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _in$2[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 1524 : 			}

	jmp	SHORT $LN5@S_RawSampl
$LN6@S_RawSampl:

; 1525 : 		}
; 1526 : 	}

	jmp	$LN12@S_RawSampl
$LN15@S_RawSampl:

; 1527 : 	else
; 1528 : 	{
; 1529 : 		if( channels == 2 )

	movzx	eax, WORD PTR _channels$[ebp]
	cmp	eax, 2
	jne	SHORT $LN19@S_RawSampl

; 1530 : 		{
; 1531 : 			const char *in = (const char *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _in$1[ebp], eax

; 1532 : 
; 1533 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN10@S_RawSampl
$LN8@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN10@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN9@S_RawSampl

; 1534 : 			{
; 1535 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1536 : 				rawsamples[dst].left = in[src*2+0] << 8;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax*2]
	shl	edx, 8
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8], edx

; 1537 : 				rawsamples[dst].right = in[src*2+1] << 8;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _in$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax*2+1]
	shl	edx, 8
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx

; 1538 : 			}

	jmp	SHORT $LN8@S_RawSampl
$LN9@S_RawSampl:

; 1539 : 		}

	jmp	SHORT $LN12@S_RawSampl
$LN19@S_RawSampl:

; 1540 : 		else
; 1541 : 		{
; 1542 : 			for( src = 0; src < samples; samplefrac += fracstep, src = ( samplefrac >> S_RAW_SAMPLES_PRECISION_BITS ))

	mov	DWORD PTR _src$[ebp], 0
	jmp	SHORT $LN13@S_RawSampl
$LN11@S_RawSampl:
	mov	eax, DWORD PTR _samplefrac$[ebp]
	add	eax, DWORD PTR _fracstep$[ebp]
	mov	DWORD PTR _samplefrac$[ebp], eax
	mov	ecx, DWORD PTR _samplefrac$[ebp]
	shr	ecx, 14					; 0000000eH
	mov	DWORD PTR _src$[ebp], ecx
$LN13@S_RawSampl:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	eax, DWORD PTR _samples$[ebp]
	jae	SHORT $LN12@S_RawSampl

; 1543 : 			{
; 1544 : 				dst = rawend++ & ( max_samples - 1 );

	mov	eax, DWORD PTR _max_samples$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _rawend$[ebp]
	mov	DWORD PTR _dst$[ebp], eax
	mov	ecx, DWORD PTR _rawend$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rawend$[ebp], ecx

; 1545 : 				rawsamples[dst].left = ( data[src] - 128 ) << 8;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	shl	ecx, 8
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 1546 : 				rawsamples[dst].right = ( data[src] - 128 ) << 8;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _src$[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 128				; 00000080H
	shl	ecx, 8
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _rawsamples$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 1547 : 			}

	jmp	SHORT $LN11@S_RawSampl
$LN12@S_RawSampl:

; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return rawend;

	mov	eax, DWORD PTR _rawend$[ebp]

; 1552 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawSamplesStereo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_UpdateAmbientSounds
_TEXT	SEGMENT
_chan$ = -16						; size = 4
_ambient_channel$ = -12					; size = 4
_vol$ = -8						; size = 4
_leaf$ = -4						; size = 4
_S_UpdateAmbientSounds PROC				; COMDAT

; 1367 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1368 : 	mleaf_t	*leaf;
; 1369 : 	float	vol;
; 1370 : 	int	ambient_channel;
; 1371 : 	channel_t	*chan;
; 1372 : 
; 1373 : 	if( !snd_ambient ) return;

	cmp	DWORD PTR _snd_ambient, 0
	jne	SHORT $LN8@S_UpdateAm
	jmp	$LN6@S_UpdateAm
$LN8@S_UpdateAm:

; 1374 : 
; 1375 : 	// calc ambient sound levels
; 1376 : 	if( !cl.worldmodel ) return;

	cmp	DWORD PTR _cl+4579004, 0
	jne	SHORT $LN9@S_UpdateAm
	jmp	$LN6@S_UpdateAm
$LN9@S_UpdateAm:

; 1377 : 
; 1378 : 	leaf = Mod_PointInLeaf( s_listener.origin, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	push	OFFSET _s_listener
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 1379 : 
; 1380 : 	if( !leaf || !s_ambient_level->value )

	cmp	DWORD PTR _leaf$[ebp], 0
	je	SHORT $LN11@S_UpdateAm
	mov	eax, DWORD PTR _s_ambient_level
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@S_UpdateAm
$LN11@S_UpdateAm:

; 1381 : 	{
; 1382 : 		for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN4@S_UpdateAm
$LN2@S_UpdateAm:
	mov	eax, DWORD PTR _ambient_channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _ambient_channel$[ebp], eax
$LN4@S_UpdateAm:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	SHORT $LN3@S_UpdateAm

; 1383 : 			channels[ambient_channel].sfx = NULL;

	imul	eax, DWORD PTR _ambient_channel$[ebp], 2480
	mov	DWORD PTR _channels[eax+16], 0
	jmp	SHORT $LN2@S_UpdateAm
$LN3@S_UpdateAm:

; 1384 : 		return;

	jmp	$LN6@S_UpdateAm
$LN10@S_UpdateAm:

; 1385 : 	}
; 1386 : 
; 1387 : 	for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN7@S_UpdateAm
$LN5@S_UpdateAm:
	mov	eax, DWORD PTR _ambient_channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _ambient_channel$[ebp], eax
$LN7@S_UpdateAm:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	$LN6@S_UpdateAm

; 1388 : 	{
; 1389 : 		chan = &channels[ambient_channel];	

	imul	eax, DWORD PTR _ambient_channel$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _chan$[ebp], eax

; 1390 : 		chan->sfx = S_GetSfxByHandle( ambient_sfx[ambient_channel] );

	mov	eax, DWORD PTR _ambient_channel$[ebp]
	mov	ecx, DWORD PTR _ambient_sfx[eax*4]
	push	ecx
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	edx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1391 : 
; 1392 : 		// ambient is unused
; 1393 : 		if( !chan->sfx )

	mov	eax, DWORD PTR _chan$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN12@S_UpdateAm

; 1394 : 		{
; 1395 : 			chan->rightvol = 0;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1396 : 			chan->leftvol = 0;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1397 : 			continue;

	jmp	SHORT $LN5@S_UpdateAm
$LN12@S_UpdateAm:

; 1398 : 		}
; 1399 : 
; 1400 : 		vol = s_ambient_level->value * leaf->ambient_sound_level[ambient_channel];

	mov	eax, DWORD PTR _leaf$[ebp]
	add	eax, DWORD PTR _ambient_channel$[ebp]
	movzx	ecx, BYTE PTR [eax+56]
	cvtsi2ss xmm0, ecx
	mov	edx, DWORD PTR _s_ambient_level
	mulss	xmm0, DWORD PTR [edx+12]
	movss	DWORD PTR _vol$[ebp], xmm0

; 1401 : 		if( vol < 0 ) vol = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN13@S_UpdateAm
	xorps	xmm0, xmm0
	movss	DWORD PTR _vol$[ebp], xmm0
$LN13@S_UpdateAm:

; 1402 : 
; 1403 : 		// don't adjust volume too fast
; 1404 : 		if( chan->master_vol < vol )

	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+52]
	movss	xmm1, DWORD PTR _vol$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@S_UpdateAm

; 1405 : 		{
; 1406 : 			chan->master_vol += s_listener.frametime * s_ambient_fade->value;

	mov	eax, DWORD PTR _s_ambient_fade
	movss	xmm0, DWORD PTR _s_listener+68
	mulss	xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+52]
	addss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+52], edx

; 1407 : 			if( chan->master_vol > vol ) chan->master_vol = vol;

	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+52]
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN16@S_UpdateAm
	cvttss2si eax, DWORD PTR _vol$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN16@S_UpdateAm:

; 1408 : 		}

	jmp	SHORT $LN18@S_UpdateAm
$LN14@S_UpdateAm:

; 1409 : 		else if( chan->master_vol > vol )

	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+52]
	comiss	xmm0, DWORD PTR _vol$[ebp]
	jbe	SHORT $LN18@S_UpdateAm

; 1410 : 		{
; 1411 : 			chan->master_vol -= s_listener.frametime * s_ambient_fade->value;

	mov	eax, DWORD PTR _s_ambient_fade
	movss	xmm0, DWORD PTR _s_listener+68
	mulss	xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+52]
	subss	xmm1, xmm0
	cvttss2si edx, xmm1
	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+52], edx

; 1412 : 			if( chan->master_vol < vol ) chan->master_vol = vol;

	mov	eax, DWORD PTR _chan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+52]
	movss	xmm1, DWORD PTR _vol$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN18@S_UpdateAm
	cvttss2si eax, DWORD PTR _vol$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [ecx+52], eax
$LN18@S_UpdateAm:

; 1413 : 		}
; 1414 : 		
; 1415 : 		chan->leftvol = chan->rightvol = chan->master_vol;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+20], edx

; 1416 : 	}

	jmp	$LN5@S_UpdateAm
$LN6@S_UpdateAm:

; 1417 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateAmbientSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_InitAmbientChannels
_TEXT	SEGMENT
_chan$ = -8						; size = 4
_ambient_channel$ = -4					; size = 4
_S_InitAmbientChannels PROC				; COMDAT

; 1345 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1346 : 	int	ambient_channel;
; 1347 : 	channel_t	*chan;
; 1348 : 
; 1349 : 	for( ambient_channel = 0; ambient_channel < NUM_AMBIENTS; ambient_channel++ )

	mov	DWORD PTR _ambient_channel$[ebp], 0
	jmp	SHORT $LN4@S_InitAmbi
$LN2@S_InitAmbi:
	mov	eax, DWORD PTR _ambient_channel$[ebp]
	add	eax, 1
	mov	DWORD PTR _ambient_channel$[ebp], eax
$LN4@S_InitAmbi:
	cmp	DWORD PTR _ambient_channel$[ebp], 4
	jge	SHORT $LN3@S_InitAmbi

; 1350 : 	{
; 1351 : 		chan = &channels[ambient_channel];	

	imul	eax, DWORD PTR _ambient_channel$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _chan$[ebp], eax

; 1352 : 
; 1353 : 		chan->staticsound = true;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+72], 1

; 1354 : 		chan->use_loop = true;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+68], 1

; 1355 : 		chan->entchannel = CHAN_STATIC;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+32], 7

; 1356 : 		chan->dist_mult = (ATTN_NONE / SND_CLIP_DISTANCE);

	mov	eax, DWORD PTR _chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+48], xmm0

; 1357 : 		chan->basePitch = PITCH_NORM;

	mov	eax, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+60], 100			; 00000064H

; 1358 : 	}

	jmp	SHORT $LN2@S_InitAmbi
$LN3@S_InitAmbi:

; 1359 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_InitAmbientChannels ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_Spatialize
_TEXT	SEGMENT
tv163 = -116						; size = 4
tv139 = -116						; size = 4
_blend$1 = -48						; size = 4
_interval$2 = -44					; size = 4
_pSource$ = -40						; size = 4
_looping$ = -36						; size = 4
_fplayersound$ = -32					; size = 4
_gain$ = -28						; size = 4
_dot$ = -24						; size = 4
_dist$ = -20						; size = 4
_source_vec$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ch$ = 8						; size = 4
_SND_Spatialize PROC					; COMDAT

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 802  : 	vec3_t	source_vec;
; 803  : 	float	dist, dot, gain = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gain$[ebp], xmm0

; 804  : 	qboolean	fplayersound = false;

	mov	DWORD PTR _fplayersound$[ebp], 0

; 805  : 	qboolean	looping = false;

	mov	DWORD PTR _looping$[ebp], 0

; 806  : 	wavdata_t	*pSource;
; 807  : 
; 808  : 	// anything coming from the view entity will allways be full volume
; 809  : 	if( S_IsClient( ch->entnum ))

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SND_Spatia

; 810  : 	{
; 811  : 		if( !s_cull->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SND_Spatia

; 812  : 		{
; 813  : 			ch->leftvol = ch->master_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+20], edx

; 814  : 			ch->rightvol = ch->master_vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+24], edx

; 815  : 			return;

	jmp	$LN14@SND_Spatia
$LN3@SND_Spatia:

; 816  : 		}
; 817  : 
; 818  : 		// sounds coming from listener actually come from a short distance directly in front of listener
; 819  : 		fplayersound = true;

	mov	DWORD PTR _fplayersound$[ebp], 1
$LN2@SND_Spatia:

; 820  : 	}
; 821  : 
; 822  : 	pSource = ch->sfx->cache;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _pSource$[ebp], edx

; 823  : 
; 824  : 	if( ch->use_loop && pSource && pSource->loopStart != -1 )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN4@SND_Spatia
	cmp	DWORD PTR _pSource$[ebp], 0
	je	SHORT $LN4@SND_Spatia
	mov	eax, DWORD PTR _pSource$[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN4@SND_Spatia

; 825  : 		looping = true;

	mov	DWORD PTR _looping$[ebp], 1
$LN4@SND_Spatia:

; 826  : 
; 827  : 	if( !ch->staticsound )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+72], 0
	jne	SHORT $LN6@SND_Spatia

; 828  : 	{
; 829  : 		if( !CL_GetEntitySpatialization( ch ) || !SND_CheckPHS( ch ))

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_CL_GetEntitySpatialization
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@SND_Spatia
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_CheckPHS
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@SND_Spatia
$LN7@SND_Spatia:

; 830  : 		{
; 831  : 			// origin is null and entity not exist on client
; 832  : 			ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 833  : 			ch->bfirstpass = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+112], 0

; 834  : 			return;

	jmp	$LN14@SND_Spatia
$LN6@SND_Spatia:

; 835  : 		}
; 836  : 	}
; 837  : 
; 838  : 	// source_vec is vector from listener to sound source
; 839  : 	// player sounds come from 1' in front of player
; 840  : 	if( fplayersound ) VectorScale( s_listener.forward, 12.0f, source_vec );

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN8@SND_Spatia
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _s_listener[ecx+24]
	mulss	xmm0, DWORD PTR __real@41400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _source_vec$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _s_listener[ecx+24]
	mulss	xmm0, DWORD PTR __real@41400000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _source_vec$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _s_listener[eax+24]
	mulss	xmm0, DWORD PTR __real@41400000
	movss	DWORD PTR tv139[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv139[ebp]
	movss	DWORD PTR _source_vec$[ebp+ecx], xmm0
	jmp	$LN9@SND_Spatia
$LN8@SND_Spatia:

; 841  : 	else VectorSubtract( ch->origin, s_listener.origin, source_vec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+36]
	subss	xmm0, DWORD PTR _s_listener[eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _source_vec$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+36]
	subss	xmm0, DWORD PTR _s_listener[eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _source_vec$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+36]
	subss	xmm0, DWORD PTR _s_listener[ecx]
	movss	DWORD PTR tv163[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv163[ebp]
	movss	DWORD PTR _source_vec$[ebp+eax], xmm0
$LN9@SND_Spatia:

; 842  : 
; 843  : 	// normalize source_vec and get distance from listener to source
; 844  : 	dist = VectorNormalizeLength( source_vec );

	lea	eax, DWORD PTR _source_vec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _source_vec$[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR _dist$[ebp]

; 845  : 	dot = DotProduct( s_listener.right, source_vec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _s_listener[ecx+36]
	mulss	xmm0, DWORD PTR _source_vec$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _s_listener[ecx+36]
	mulss	xmm1, DWORD PTR _source_vec$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _s_listener[eax+36]
	mulss	xmm1, DWORD PTR _source_vec$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dot$[ebp], xmm0

; 846  : 
; 847  : 	// for sounds with a radius, spatialize left/right evenly within the radius
; 848  : 	if( ch->radius > 0 && dist < ch->radius )

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN10@SND_Spatia
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN10@SND_Spatia

; 849  : 	{
; 850  : 		float	interval = ch->radius * 0.5f;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _interval$2[ebp], xmm0

; 851  : 		float	blend = dist - interval;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _interval$2[ebp]
	movss	DWORD PTR _blend$1[ebp], xmm0

; 852  : 
; 853  : 		if( blend < 0 ) blend = 0;

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _blend$1[ebp]
	jbe	SHORT $LN11@SND_Spatia
	xorps	xmm0, xmm0
	movss	DWORD PTR _blend$1[ebp], xmm0
$LN11@SND_Spatia:

; 854  : 		blend /= interval;	

	movss	xmm0, DWORD PTR _blend$1[ebp]
	divss	xmm0, DWORD PTR _interval$2[ebp]
	movss	DWORD PTR _blend$1[ebp], xmm0

; 855  : 
; 856  : 		// blend is 0.0 - 1.0, from 50% radius -> 100% radius
; 857  : 		// at radius * 0.5, dot is 0 (ie: sound centered left/right)
; 858  : 		// at radius dot == dot
; 859  : 		dot *= blend;

	movss	xmm0, DWORD PTR _dot$[ebp]
	mulss	xmm0, DWORD PTR _blend$1[ebp]
	movss	DWORD PTR _dot$[ebp], xmm0
$LN10@SND_Spatia:

; 860  : 	}
; 861  : 
; 862  : 	if( s_cull->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@SND_Spatia

; 863  : 	{
; 864  : 		// calculate gain based on distance, atmospheric attenuation, interposed objects
; 865  : 		// perform compression as gain approaches 1.0
; 866  : 		gain = SND_GetGain( ch, fplayersound, looping, dist );

	push	ecx
	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _looping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fplayersound$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_GetGain
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _gain$[ebp]
$LN12@SND_Spatia:

; 867  : 	}
; 868  : 
; 869  : 	// don't pan sounds with no attenuation
; 870  : 	if( ch->dist_mult <= 0.0f ) dot = 0.0f;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [eax+48]
	jb	SHORT $LN13@SND_Spatia
	xorps	xmm0, xmm0
	movss	DWORD PTR _dot$[ebp], xmm0
$LN13@SND_Spatia:

; 871  : 
; 872  : 	// fill out channel volumes for single location
; 873  : 	S_SpatializeChannel( &ch->leftvol, &ch->rightvol, ch->master_vol, gain, dot, dist * ch->dist_mult );

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [eax+48]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_S_SpatializeChannel
	add	esp, 24					; 00000018H

; 874  : 
; 875  : 	// if playing a word, set volume
; 876  : 	VOX_SetChanVol( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_VOX_SetChanVol
	add	esp, 4

; 877  : 
; 878  : 	// end of first time spatializing sound
; 879  : 	if( CL_Active( )) ch->bfirstpass = false;

	call	_CL_Active
	test	eax, eax
	je	SHORT $LN14@SND_Spatia
	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+112], 0
$LN14@SND_Spatia:

; 880  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_Spatialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_SpatializeChannel
_TEXT	SEGMENT
tv95 = -84						; size = 4
tv91 = -84						; size = 4
tv94 = -80						; size = 4
tv90 = -80						; size = 4
_scale$ = -12						; size = 4
_rscale$ = -8						; size = 4
_lscale$ = -4						; size = 4
_left_vol$ = 8						; size = 4
_right_vol$ = 12					; size = 4
_master_vol$ = 16					; size = 4
_gain$ = 20						; size = 4
_dot$ = 24						; size = 4
_dist$ = 28						; size = 4
_S_SpatializeChannel PROC				; COMDAT

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 777  : 	float	lscale, rscale, scale;
; 778  : 
; 779  : 	rscale = 1.0f + dot;

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR _rscale$[ebp], xmm0

; 780  : 	lscale = 1.0f - dot;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dot$[ebp]
	movss	DWORD PTR _lscale$[ebp], xmm0

; 781  : 
; 782  : 	// add in distance effect
; 783  : 	if( s_cull->value ) scale = gain * rscale / 2;

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@S_Spatiali
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR _rscale$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _scale$[ebp], xmm0
	jmp	SHORT $LN3@S_Spatiali
$LN2@S_Spatiali:

; 784  : 	else scale = ( 1.0f - dist ) * rscale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _rscale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN3@S_Spatiali:

; 785  : 	*right_vol = (int)( master_vol * scale );

	cvtsi2ss xmm0, DWORD PTR _master_vol$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _right_vol$[ebp]
	mov	DWORD PTR [ecx], eax

; 786  : 
; 787  : 	if( s_cull->value ) scale = gain * lscale / 2;

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@S_Spatiali
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR _lscale$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _scale$[ebp], xmm0
	jmp	SHORT $LN5@S_Spatiali
$LN4@S_Spatiali:

; 788  : 	else scale = ( 1.0f - dist ) * lscale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _lscale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN5@S_Spatiali:

; 789  : 	*left_vol = (int)( master_vol * scale );

	cvtsi2ss xmm0, DWORD PTR _master_vol$[ebp]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _left_vol$[ebp]
	mov	DWORD PTR [ecx], eax

; 790  : 
; 791  : 	*right_vol = bound( 0, *right_vol, 255 );

	mov	eax, DWORD PTR _right_vol$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN9@S_Spatiali
	mov	ecx, DWORD PTR _right_vol$[ebp]
	cmp	DWORD PTR [ecx], 255			; 000000ffH
	jge	SHORT $LN7@S_Spatiali
	mov	edx, DWORD PTR _right_vol$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN8@S_Spatiali
$LN7@S_Spatiali:
	mov	DWORD PTR tv90[ebp], 255		; 000000ffH
$LN8@S_Spatiali:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], ecx
	jmp	SHORT $LN10@S_Spatiali
$LN9@S_Spatiali:
	mov	DWORD PTR tv91[ebp], 0
$LN10@S_Spatiali:
	mov	edx, DWORD PTR _right_vol$[ebp]
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR [edx], eax

; 792  : 	*left_vol = bound( 0, *left_vol, 255 );

	mov	eax, DWORD PTR _left_vol$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN13@S_Spatiali
	mov	ecx, DWORD PTR _left_vol$[ebp]
	cmp	DWORD PTR [ecx], 255			; 000000ffH
	jge	SHORT $LN11@S_Spatiali
	mov	edx, DWORD PTR _left_vol$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN12@S_Spatiali
$LN11@S_Spatiali:
	mov	DWORD PTR tv94[ebp], 255		; 000000ffH
$LN12@S_Spatiali:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	jmp	SHORT $LN14@S_Spatiali
$LN13@S_Spatiali:
	mov	DWORD PTR tv95[ebp], 0
$LN14@S_Spatiali:
	mov	edx, DWORD PTR _left_vol$[ebp]
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR [edx], eax

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SpatializeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_CheckPHS
_TEXT	SEGMENT
tv129 = -72						; size = 4
_leaf$ = -4						; size = 4
_ch$ = 8						; size = 4
_SND_CheckPHS PROC					; COMDAT

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 746  : 	mleaf_t	*leaf;
; 747  : 
; 748  : 	if( !s_phs->value )

	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SND_CheckP

; 749  : 		return true;

	mov	eax, 1
	jmp	$LN1@SND_CheckP
$LN2@SND_CheckP:

; 750  : 
; 751  : 	if( !ch->dist_mult && ch->entnum )

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@SND_CheckP
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN3@SND_CheckP

; 752  : 		return true; // no attenuation 

	mov	eax, 1
	jmp	$LN1@SND_CheckP
$LN3@SND_CheckP:

; 753  : 
; 754  : 	if( ch->movetype == MOVETYPE_PUSH )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+160], 7
	jne	SHORT $LN4@SND_CheckP

; 755  : 	{
; 756  : 		if( Mod_BoxVisible( ch->absmin, ch->absmax, s_listener.pasbytes ))

	push	OFFSET _s_listener+92
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	call	_Mod_BoxVisible
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@SND_CheckP

; 757  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_CheckP
$LN6@SND_CheckP:

; 758  : 	}

	jmp	SHORT $LN7@SND_CheckP
$LN4@SND_CheckP:

; 759  : 	else
; 760  : 	{
; 761  : 		leaf = Mod_PointInLeaf( ch->origin, cl.worldmodel->nodes );

	mov	eax, DWORD PTR _cl+4579004
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	call	_Mod_PointInLeaf
	add	esp, 8
	mov	DWORD PTR _leaf$[ebp], eax

; 762  : 
; 763  : 		if( CHECKVISBIT( s_listener.pasbytes, leaf->cluster ))

	mov	eax, DWORD PTR _leaf$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jl	SHORT $LN9@SND_CheckP
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	sar	edx, 3
	movzx	eax, BYTE PTR _s_listener[edx+92]
	mov	ecx, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	movzx	eax, al
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN10@SND_CheckP
$LN9@SND_CheckP:
	mov	DWORD PTR tv129[ebp], 0
$LN10@SND_CheckP:
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN7@SND_CheckP

; 764  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_CheckP
$LN7@SND_CheckP:

; 765  : 	}
; 766  : 
; 767  : 	return false;

	xor	eax, eax
$LN1@SND_CheckP:

; 768  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_CheckPHS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_GetGain
_TEXT	SEGMENT
tv136 = -116						; size = 8
tv265 = -108						; size = 8
tv238 = -108						; size = 8
tv297 = -100						; size = 8
tv258 = -100						; size = 8
tv230 = -100						; size = 8
tv293 = -96						; size = 4
tv285 = -96						; size = 4
_Y$1 = -28						; size = 4
_sndlvl$2 = -24						; size = 4
_snd_gain_comp_power$3 = -20				; size = 4
_relative_dist$4 = -16					; size = 4
_additional_dist_mult$5 = -12				; size = 4
_additional_dB_loss$6 = -8				; size = 4
_gain$ = -4						; size = 4
_ch$ = 8						; size = 4
_fplayersound$ = 12					; size = 4
_flooping$ = 16						; size = 4
_dist$ = 20						; size = 4
_SND_GetGain PROC					; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi

; 677  : 	float	gain = snd_gain->value;

	mov	eax, DWORD PTR _snd_gain
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _gain$[ebp], xmm0

; 678  : 
; 679  : 	if( ch->dist_mult )

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@SND_GetGai

; 680  : 	{
; 681  : 		// test additional attenuation
; 682  : 		// at 30c, 14.7psi, 60% humidity, 1000Hz == 0.22dB / 100ft.
; 683  : 		// dense foliage is roughly 2dB / 100ft
; 684  : 		float additional_dB_loss = snd_foliage_db_loss->value * (dist / 1200);

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR __real@44960000
	mov	eax, DWORD PTR _snd_foliage_db_loss
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _additional_dB_loss$6[ebp], xmm0

; 685  : 		float additional_dist_mult = pow( 10, additional_dB_loss / 20 );

	movss	xmm0, DWORD PTR _additional_dB_loss$6[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _additional_dist_mult$5[ebp]

; 686  : 		float relative_dist = dist * ch->dist_mult * additional_dist_mult;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _additional_dist_mult$5[ebp]
	movss	DWORD PTR _relative_dist$4[ebp], xmm0

; 687  : 
; 688  : 		// hard code clamp gain to 10x normal (assumes volume and external clipping)
; 689  : 		if( relative_dist > 0.1f )

	movss	xmm0, DWORD PTR _relative_dist$4[ebp]
	comiss	xmm0, DWORD PTR __real@3dcccccd
	jbe	SHORT $LN3@SND_GetGai

; 690  : 			gain *= ( 1.0f / relative_dist );

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _relative_dist$4[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
	jmp	SHORT $LN4@SND_GetGai
$LN3@SND_GetGai:

; 691  : 		else gain *= 10.0f;

	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _gain$[ebp], xmm0
$LN4@SND_GetGai:

; 692  : 
; 693  : 		// if gain passess threshold, compress gain curve such that gain smoothly approaches 1.0
; 694  : 		if( gain > SND_GAIN_COMP_THRESH )

	movss	xmm0, DWORD PTR _gain$[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	$LN5@SND_GetGai

; 695  : 		{
; 696  : 			float	snd_gain_comp_power = SND_GAIN_COMP_EXP_MAX;

	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR _snd_gain_comp_power$3[ebp], xmm0

; 697  : 			int	sndlvl = DIST_MULT_TO_SNDLVL( ch->dist_mult );

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@SND_GetGai
	mov	ecx, DWORD PTR _s_refdb
	movss	xmm0, DWORD PTR [ecx+12]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv230[ebp]
	movsd	xmm0, QWORD PTR tv230[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _s_refdist
	movss	xmm1, DWORD PTR [edx+48]
	mulss	xmm1, DWORD PTR [eax+12]
	cvtss2sd xmm1, xmm1
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv238[ebp]
	movsd	xmm0, QWORD PTR tv238[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv136[ebp], xmm0
	jmp	SHORT $LN13@SND_GetGai
$LN12@SND_GetGai:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv136[ebp], xmm0
$LN13@SND_GetGai:
	cvttsd2si ecx, QWORD PTR tv136[ebp]
	mov	DWORD PTR _sndlvl$2[ebp], ecx

; 698  : 			float	Y;
; 699  : 			
; 700  : 			// decrease compression curve fit for higher sndlvl values
; 701  : 			if( sndlvl > SND_DB_MED )

	cvtsi2ss xmm0, DWORD PTR _sndlvl$2[ebp]
	comiss	xmm0, DWORD PTR __real@42b40000
	jbe	SHORT $LN6@SND_GetGai

; 702  : 			{
; 703  : 				// snd_gain_power varies from max to min as sndlvl varies from 90 to 140
; 704  : 				snd_gain_comp_power = RemapVal((float)sndlvl, SND_DB_MED, SND_DB_MAX, SND_GAIN_COMP_EXP_MAX, SND_GAIN_COMP_EXP_MIN );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@40200000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@430c0000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _sndlvl$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_RemapVal
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _snd_gain_comp_power$3[ebp]
$LN6@SND_GetGai:

; 705  : 			}
; 706  : 
; 707  : 			// calculate crossover point
; 708  : 			Y = -1.0f / ( pow( SND_GAIN_COMP_THRESH, snd_gain_comp_power ) * ( SND_GAIN_COMP_THRESH - 1 ));

	cvtss2sd xmm0, DWORD PTR _snd_gain_comp_power$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv258[ebp]
	movsd	xmm0, QWORD PTR tv258[ebp]
	mulsd	xmm0, QWORD PTR __real@bfe0000000000000
	movsd	xmm1, QWORD PTR __real@bff0000000000000
	divsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _Y$1[ebp], xmm0

; 709  : 			
; 710  : 			// calculate compressed gain
; 711  : 			gain = 1.0f - 1.0f / (Y * pow( gain, snd_gain_comp_power ));

	cvtss2sd xmm0, DWORD PTR _Y$1[ebp]
	cvtss2sd xmm1, DWORD PTR _snd_gain_comp_power$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	cvtss2sd xmm1, DWORD PTR _gain$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv297[ebp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv265[ebp]
	movsd	xmm0, QWORD PTR tv297[ebp]
	mulsd	xmm0, QWORD PTR tv265[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _gain$[ebp], xmm0

; 712  : 			gain = gain * snd_gain_max->value;

	mov	eax, DWORD PTR _snd_gain_max
	movss	xmm0, DWORD PTR _gain$[ebp]
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN5@SND_GetGai:

; 713  : 		}
; 714  : 
; 715  : 		if( gain < snd_gain_min->value )

	mov	eax, DWORD PTR _snd_gain_min
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _gain$[ebp]
	jbe	SHORT $LN8@SND_GetGai

; 716  : 		{
; 717  : 			// sounds less than snd_gain_min fall off to 0 in distance it took them to fall to snd_gain_min
; 718  : 			gain = snd_gain_min->value * ( 2.0f - relative_dist * snd_gain_min->value );

	mov	eax, DWORD PTR _snd_gain_min
	movss	xmm0, DWORD PTR _relative_dist$4[ebp]
	mulss	xmm0, DWORD PTR [eax+12]
	movss	xmm1, DWORD PTR __real@40000000
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _snd_gain_min
	mulss	xmm1, DWORD PTR [ecx+12]
	movss	DWORD PTR _gain$[ebp], xmm1

; 719  : 			if( gain <= 0.0f ) gain = 0.001f; // don't propagate 0 gain

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _gain$[ebp]
	jb	SHORT $LN8@SND_GetGai
	movss	xmm0, DWORD PTR __real@3a83126f
	movss	DWORD PTR _gain$[ebp], xmm0
$LN8@SND_GetGai:

; 720  : 		}
; 721  : 	}
; 722  : 
; 723  : 	if( fplayersound )

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN10@SND_GetGai

; 724  : 	{
; 725  : 		// player weapon sounds get extra gain - this compensates
; 726  : 		// for npc distance effect weapons which mix louder as L+R into L, R
; 727  : 		if( ch->entchannel == CHAN_WEAPON )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+32], 1
	jne	SHORT $LN10@SND_GetGai

; 728  : 			gain = gain * dB_To_Gain( SND_GAIN_PLAYER_WEAPON_DB );

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Gain
	add	esp, 4
	fstp	DWORD PTR tv285[ebp]
	movss	xmm0, DWORD PTR tv285[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN10@SND_GetGai:

; 729  : 	}
; 730  : 
; 731  : 	// modify gain if sound source not visible to player
; 732  : 	gain = gain * SND_GetGainObscured( ch, fplayersound, flooping );

	mov	eax, DWORD PTR _flooping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fplayersound$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	push	edx
	call	_SND_GetGainObscured
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR tv293[ebp]
	movss	xmm0, DWORD PTR tv293[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0

; 733  : 
; 734  : 	return gain; 

	fld	DWORD PTR _gain$[ebp]

; 735  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_GetGain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_GetGainObscured
_TEXT	SEGMENT
tv161 = -472						; size = 8
tv728 = -464						; size = 8
tv720 = -456						; size = 8
tv1033 = -452						; size = 4
tv592 = -452						; size = 4
tv559 = -452						; size = 4
tv526 = -452						; size = 4
tv493 = -452						; size = 4
tv460 = -452						; size = 4
tv436 = -452						; size = 4
tv412 = -452						; size = 4
tv397 = -452						; size = 4
tv304 = -452						; size = 4
tv272 = -452						; size = 4
tv209 = -452						; size = 4
$T1 = -448						; size = 68
$T2 = -380						; size = 68
_ilength$3 = -248					; size = 4
_ilength$4 = -244					; size = 4
_ilength$5 = -240					; size = 4
_radius$6 = -236					; size = 4
_vsrc_up$7 = -232					; size = 12
_vsrc_right$8 = -220					; size = 12
_vsrc_forward$9 = -208					; size = 12
_vecr2$10 = -196					; size = 12
_vecl2$11 = -184					; size = 12
_vecr$12 = -172						; size = 12
_vecl$13 = -160						; size = 12
_sndlvl$14 = -148					; size = 4
_i$15 = -144						; size = 4
_endpoints$16 = -140					; size = 48
_tr$ = -92						; size = 68
_count$ = -24						; size = 4
_endpoint$ = -20					; size = 12
_gain$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ch$ = 8						; size = 4
_fplayersound$ = 12					; size = 4
_flooping$ = 16						; size = 4
_SND_GetGainObscured PROC				; COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 472				; 000001d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 559  : 	float	gain = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _gain$[ebp], xmm0

; 560  : 	vec3_t	endpoint;
; 561  : 	int	count = 1;

	mov	DWORD PTR _count$[ebp], 1

; 562  : 	pmtrace_t	tr;
; 563  : 
; 564  : 	if( fplayersound ) return gain; // unchanged

	cmp	DWORD PTR _fplayersound$[ebp], 0
	je	SHORT $LN8@SND_GetGai
	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN8@SND_GetGai:

; 565  : 
; 566  : 	// during signon just apply regular state machine since world hasn't been
; 567  : 	// created or settled yet...
; 568  : 	if( !CL_Active( ))

	call	_CL_Active
	test	eax, eax
	jne	SHORT $LN9@SND_GetGai

; 569  : 	{
; 570  : 		gain = SND_FadeToNewGain( ch, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 571  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN9@SND_GetGai:

; 572  : 	}
; 573  : 
; 574  : 	// don't do gain obscuring more than once on short one-shot sounds
; 575  : 	if( !ch->bfirstpass && !ch->isSentence && !flooping && ( ch->entchannel != CHAN_STREAM ))

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+112], 0
	jne	SHORT $LN10@SND_GetGai
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN10@SND_GetGai
	cmp	DWORD PTR _flooping$[ebp], 0
	jne	SHORT $LN10@SND_GetGai
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+32], 6
	je	SHORT $LN10@SND_GetGai

; 576  : 	{
; 577  : 		gain = SND_FadeToNewGain( ch, -1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 578  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN10@SND_GetGai:

; 579  : 	}
; 580  : 
; 581  : 	// if long or looping sound, process N channels per frame - set 'processed' flag, clear by
; 582  : 	// cycling through all channels - this maintains a cap on traces per frame
; 583  : 	if( !SND_ChannelOkToTrace( ch ))

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_ChannelOkToTrace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SND_GetGai

; 584  : 	{
; 585  : 		// just keep updating fade to existing target gain - no new trace checking
; 586  : 		gain = SND_FadeToNewGain( ch, -1.0 );

	push	ecx
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 587  : 		return gain;

	fld	DWORD PTR _gain$[ebp]
	jmp	$LN1@SND_GetGai
$LN11@SND_GetGai:

; 588  : 	}
; 589  : 
; 590  : 	// set up traceline from player eyes to sound emitting entity origin
; 591  : 	VectorCopy( ch->origin, endpoint );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+36]
	mov	DWORD PTR _endpoint$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR _endpoint$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _endpoint$[ebp+ecx], eax

; 592  : 
; 593  : 	tr = CL_TraceLine( s_listener.origin, endpoint, PM_STUDIO_IGNORE );

	push	1
	lea	eax, DWORD PTR _endpoint$[ebp]
	push	eax
	push	OFFSET _s_listener
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 594  : 
; 595  : 	if(( tr.fraction < 1.0f || tr.allsolid || tr.startsolid ) && tr.fraction < 0.99f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	ja	SHORT $LN13@SND_GetGai
	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN13@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	je	$LN6@SND_GetGai
$LN13@SND_GetGai:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	jbe	$LN6@SND_GetGai

; 596  : 	{
; 597  : 		// can't see center of sound source:
; 598  : 		// build extents based on dB sndlvl of source,
; 599  : 		// test to see how many extents are visible,
; 600  : 		// drop gain by g_snd_obscured_loss_db per extent hidden
; 601  : 		vec3_t	endpoints[4];
; 602  : 		int	i, sndlvl = DIST_MULT_TO_SNDLVL( ch->dist_mult );

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN24@SND_GetGai
	mov	ecx, DWORD PTR _s_refdb
	movss	xmm0, DWORD PTR [ecx+12]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv720[ebp]
	movsd	xmm0, QWORD PTR tv720[ebp]
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR _s_refdist
	movss	xmm1, DWORD PTR [edx+48]
	mulss	xmm1, DWORD PTR [eax+12]
	cvtss2sd xmm1, xmm1
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_log10
	add	esp, 8
	fstp	QWORD PTR tv728[ebp]
	movsd	xmm0, QWORD PTR tv728[ebp]
	mulsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv161[ebp], xmm0
	jmp	SHORT $LN25@SND_GetGai
$LN24@SND_GetGai:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv161[ebp], xmm0
$LN25@SND_GetGai:
	cvttsd2si ecx, QWORD PTR tv161[ebp]
	mov	DWORD PTR _sndlvl$14[ebp], ecx

; 603  : 		vec3_t	vecl, vecr, vecl2, vecr2;
; 604  : 		vec3_t	vsrc_forward;
; 605  : 		vec3_t	vsrc_right;
; 606  : 		vec3_t	vsrc_up;
; 607  : 		float	radius;
; 608  : 
; 609  : 		// get radius
; 610  : 		if( ch->radius > 0 ) radius = ch->radius;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN14@SND_GetGai
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+132]
	movss	DWORD PTR _radius$6[ebp], xmm0
	jmp	SHORT $LN15@SND_GetGai
$LN14@SND_GetGai:

; 611  : 		else radius = dB_To_Radius( sndlvl ); // approximate radius from soundlevel

	cvtsi2ss xmm0, DWORD PTR _sndlvl$14[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Radius
	add	esp, 4
	fstp	DWORD PTR _radius$6[ebp]
$LN15@SND_GetGai:

; 612  : 		
; 613  : 		// set up extent endpoints - on upward or downward diagonals, facing player
; 614  : 		for( i = 0; i < 4; i++ ) VectorCopy( endpoint, endpoints[i] );

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN4@SND_GetGai
$LN2@SND_GetGai:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN4@SND_GetGai:
	cmp	DWORD PTR _i$15[ebp], 4
	jge	SHORT $LN3@SND_GetGai
	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$15[ebp], 12
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	edx, 4
	imul	edx, edx, 0
	mov	ecx, DWORD PTR _endpoint$[ebp+ecx]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _i$15[ebp], 12
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	eax, 4
	shl	eax, 0
	mov	edx, DWORD PTR _endpoint$[ebp+edx]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$15[ebp], 12
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	ecx, 4
	shl	ecx, 1
	mov	eax, DWORD PTR _endpoint$[ebp+eax]
	mov	DWORD PTR [edx+ecx], eax
	jmp	$LN2@SND_GetGai
$LN3@SND_GetGai:

; 615  : 
; 616  : 		// vsrc_forward is normalized vector from sound source to listener
; 617  : 		VectorSubtract( s_listener.origin, endpoint, vsrc_forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _s_listener[ecx]
	subss	xmm0, DWORD PTR _endpoint$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vsrc_forward$9[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _s_listener[eax]
	subss	xmm0, DWORD PTR _endpoint$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vsrc_forward$9[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _s_listener[eax]
	subss	xmm0, DWORD PTR _endpoint$[ebp+ecx]
	movss	DWORD PTR tv209[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _vsrc_forward$9[ebp+edx], xmm0

; 618  : 		VectorNormalize( vsrc_forward );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vsrc_forward$9[ebp+ecx]
	mulss	xmm0, DWORD PTR _vsrc_forward$9[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vsrc_forward$9[ebp+ecx]
	mulss	xmm1, DWORD PTR _vsrc_forward$9[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vsrc_forward$9[ebp+eax]
	mulss	xmm1, DWORD PTR _vsrc_forward$9[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$5[ebp]
	movss	xmm0, DWORD PTR _ilength$5[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$5[ebp]
	movss	DWORD PTR _ilength$5[ebp], xmm0
$LN16@SND_GetGai:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vsrc_forward$9[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vsrc_forward$9[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vsrc_forward$9[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vsrc_forward$9[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vsrc_forward$9[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$5[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vsrc_forward$9[ebp+ecx], xmm0

; 619  : 		VectorVectors( vsrc_forward, vsrc_right, vsrc_up );

	lea	eax, DWORD PTR _vsrc_up$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _vsrc_right$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _vsrc_forward$9[ebp]
	push	edx
	call	_VectorVectors
	add	esp, 12					; 0000000cH

; 620  : 
; 621  : 		VectorAdd( vsrc_up, vsrc_right, vecl );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+ecx]
	addss	xmm0, DWORD PTR _vsrc_right$8[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecl$13[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+eax]
	addss	xmm0, DWORD PTR _vsrc_right$8[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecl$13[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+eax]
	addss	xmm0, DWORD PTR _vsrc_right$8[ebp+ecx]
	movss	DWORD PTR tv272[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv272[ebp]
	movss	DWORD PTR _vecl$13[ebp+edx], xmm0

; 622  : 		
; 623  : 		// if src above listener, force 'up' vector to point down - create diagonals up & down
; 624  : 		if( endpoint[2] > s_listener.origin[2] + ( 10 * 12 ))

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _s_listener[ecx]
	addss	xmm0, DWORD PTR __real@42f00000
	movss	xmm1, DWORD PTR _endpoint$[ebp+eax]
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@SND_GetGai

; 625  : 			vsrc_up[2] = -vsrc_up[2];

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+eax]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vsrc_up$7[ebp+ecx], xmm0
$LN17@SND_GetGai:

; 626  : 
; 627  : 		VectorSubtract( vsrc_up, vsrc_right, vecr );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+ecx]
	subss	xmm0, DWORD PTR _vsrc_right$8[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecr$12[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+eax]
	subss	xmm0, DWORD PTR _vsrc_right$8[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecr$12[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vsrc_up$7[ebp+eax]
	subss	xmm0, DWORD PTR _vsrc_right$8[ebp+ecx]
	movss	DWORD PTR tv304[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv304[ebp]
	movss	DWORD PTR _vecr$12[ebp+edx], xmm0

; 628  : 		VectorNormalize( vecl );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecl$13[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecl$13[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecl$13[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecl$13[ebp+eax]
	mulss	xmm1, DWORD PTR _vecl$13[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$4[ebp]
	movss	xmm0, DWORD PTR _ilength$4[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$4[ebp]
	movss	DWORD PTR _ilength$4[ebp], xmm0
$LN18@SND_GetGai:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecl$13[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecl$13[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecl$13[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecl$13[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$4[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vecl$13[ebp+ecx], xmm0

; 629  : 		VectorNormalize( vecr );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mulss	xmm0, DWORD PTR _vecr$12[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _vecr$12[ebp+ecx]
	mulss	xmm1, DWORD PTR _vecr$12[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _vecr$12[ebp+eax]
	mulss	xmm1, DWORD PTR _vecr$12[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$3[ebp]
	movss	xmm0, DWORD PTR _ilength$3[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN19@SND_GetGai
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$3[ebp]
	movss	DWORD PTR _ilength$3[ebp], xmm0
$LN19@SND_GetGai:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecr$12[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecr$12[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecr$12[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecr$12[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$3[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _vecr$12[ebp+ecx], xmm0

; 630  : 
; 631  : 		// get diagonal vectors from sound source 
; 632  : 		VectorScale( vecl, radius, vecl2 );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecl2$11[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecl2$11[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecl$13[ebp+eax]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	movss	DWORD PTR tv397[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv397[ebp]
	movss	DWORD PTR _vecl2$11[ebp+ecx], xmm0

; 633  : 		VectorScale( vecr, radius, vecr2 );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecr2$10[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecr2$10[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _vecr$12[ebp+eax]
	mulss	xmm0, DWORD PTR _radius$6[ebp]
	movss	DWORD PTR tv412[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv412[ebp]
	movss	DWORD PTR _vecr2$10[ebp+ecx], xmm0

; 634  : 		VectorScale( vecl, (radius / 2.0f), vecl );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecl$13[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecl$13[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vecl$13[ebp+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv436[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv436[ebp]
	movss	DWORD PTR _vecl$13[ebp+ecx], xmm0

; 635  : 		VectorScale( vecr, (radius / 2.0f), vecr );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecr$12[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecr$12[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _radius$6[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	movss	xmm1, DWORD PTR _vecr$12[ebp+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv460[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv460[ebp]
	movss	DWORD PTR _vecr$12[ebp+ecx], xmm0

; 636  : 
; 637  : 		// endpoints from diagonal vectors
; 638  : 		VectorAdd( endpoints[0], vecl, endpoints[0] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _vecl$13[ebp+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecl$13[ebp+ecx]
	movss	DWORD PTR tv493[ebp], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv493[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 639  : 		VectorAdd( endpoints[1], vecr, endpoints[1] );

	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _vecr$12[ebp+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 0
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecr$12[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 0
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecr$12[ebp+edx]
	movss	DWORD PTR tv526[ebp], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 0
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv526[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 640  : 		VectorAdd( endpoints[2], vecl2, endpoints[2] );

	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	movss	xmm0, DWORD PTR [ecx+eax]
	addss	xmm0, DWORD PTR _vecl2$11[ebp+edx]
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 12					; 0000000cH
	shl	ecx, 1
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecl2$11[ebp+ecx]
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR [eax+ecx], xmm0
	mov	edx, 12					; 0000000cH
	shl	edx, 1
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR _vecl2$11[ebp+edx]
	movss	DWORD PTR tv559[ebp], xmm0
	mov	eax, 12					; 0000000cH
	shl	eax, 1
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv559[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 641  : 		VectorAdd( endpoints[3], vecr2, endpoints[3] );

	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	movss	xmm0, DWORD PTR [edx+ecx]
	addss	xmm0, DWORD PTR _vecr2$10[ebp+eax]
	mov	ecx, 12					; 0000000cH
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _endpoints$16[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecr2$10[ebp+ecx]
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [ecx+edx], xmm0
	mov	eax, 12					; 0000000cH
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _endpoints$16[ebp+ecx]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR [edx+eax]
	addss	xmm0, DWORD PTR _vecr2$10[ebp+ecx]
	movss	DWORD PTR tv592[ebp], xmm0
	mov	edx, 12					; 0000000cH
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv592[ebp]
	movss	DWORD PTR [ecx+edx], xmm0

; 642  : 
; 643  : 		// drop gain for each point on radius diagonal that is obscured
; 644  : 		for( count = 0, i = 0; i < 4; i++ )

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN7@SND_GetGai
$LN5@SND_GetGai:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN7@SND_GetGai:
	cmp	DWORD PTR _i$15[ebp], 4
	jge	$LN6@SND_GetGai

; 645  : 		{
; 646  : 			// UNDONE: some endpoints are in walls - in this case, trace from the wall hit location
; 647  : 			tr = CL_TraceLine( s_listener.origin, endpoints[i], PM_STUDIO_IGNORE );

	push	1
	imul	eax, DWORD PTR _i$15[ebp], 12
	lea	ecx, DWORD PTR _endpoints$16[ebp+eax]
	push	ecx
	push	OFFSET _s_listener
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _tr$[ebp]
	rep movsd

; 648  : 
; 649  : 			if(( tr.fraction < 1.0f || tr.allsolid || tr.startsolid ) && tr.fraction < 0.99f && !tr.startsolid )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	ja	SHORT $LN21@SND_GetGai
	cmp	DWORD PTR _tr$[ebp], 0
	jne	SHORT $LN21@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	je	SHORT $LN22@SND_GetGai
$LN21@SND_GetGai:
	movss	xmm0, DWORD PTR __real@3f7d70a4
	comiss	xmm0, DWORD PTR _tr$[ebp+16]
	jbe	SHORT $LN22@SND_GetGai
	cmp	DWORD PTR _tr$[ebp+4], 0
	jne	SHORT $LN22@SND_GetGai

; 650  : 			{
; 651  : 				// skip first obscured point: at least 2 points + center should be obscured to hear db loss
; 652  : 				if( ++count > 1 ) gain = gain * dB_To_Gain( SND_OBSCURED_LOSS_DB );

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	cmp	DWORD PTR _count$[ebp], 1
	jle	SHORT $LN22@SND_GetGai
	push	ecx
	movss	xmm0, DWORD PTR __real@c02ccccd
	movss	DWORD PTR [esp], xmm0
	call	_dB_To_Gain
	add	esp, 4
	fstp	DWORD PTR tv1033[ebp]
	movss	xmm0, DWORD PTR tv1033[ebp]
	mulss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR _gain$[ebp], xmm0
$LN22@SND_GetGai:

; 653  : 			}
; 654  : 		}

	jmp	$LN5@SND_GetGai
$LN6@SND_GetGai:

; 655  : 	}
; 656  : 
; 657  : 	// crossfade to new gain
; 658  : 	gain = SND_FadeToNewGain( ch, gain );

	push	ecx
	movss	xmm0, DWORD PTR _gain$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_FadeToNewGain
	add	esp, 8
	fstp	DWORD PTR _gain$[ebp]

; 659  : 
; 660  : 	return gain;

	fld	DWORD PTR _gain$[ebp]
$LN1@SND_GetGai:

; 661  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_GetGainObscured ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_FadeToNewGain
_TEXT	SEGMENT
tv179 = -80						; size = 8
tv152 = -80						; size = 8
_frametime$ = -8					; size = 4
_speed$ = -4						; size = 4
_ch$ = 8						; size = 4
_gain_new$ = 12						; size = 4
_SND_FadeToNewGain PROC					; COMDAT

; 507  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 508  : 	float	speed, frametime;
; 509  : 
; 510  : 	if( gain_new == -1.0 )

	cvtss2sd xmm0, DWORD PTR _gain_new$[ebp]
	ucomisd	xmm0, QWORD PTR __real@bff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SND_FadeTo

; 511  : 	{
; 512  : 		// if -1 passed in, just keep fading to existing target
; 513  : 		gain_new = ch->ob_gain_target;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+120]
	movss	DWORD PTR _gain_new$[ebp], xmm0
$LN2@SND_FadeTo:

; 514  : 	}
; 515  : 
; 516  : 	// if first time updating, store new gain into gain & target, return
; 517  : 	// if gain_new is close to existing gain, store new gain into gain & target, return
; 518  : 	if( ch->bfirstpass || ( fabs( gain_new - ch->ob_gain ) < 0.01f ))

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+112], 0
	jne	SHORT $LN4@SND_FadeTo
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	subss	xmm0, DWORD PTR [eax+116]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv152[ebp]
	movsd	xmm0, QWORD PTR __real@3f847ae140000000
	comisd	xmm0, QWORD PTR tv152[ebp]
	jbe	SHORT $LN3@SND_FadeTo
$LN4@SND_FadeTo:

; 519  : 	{
; 520  : 		ch->ob_gain = gain_new;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [eax+116], xmm0

; 521  : 		ch->ob_gain_target = gain_new;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 522  : 		ch->ob_gain_inc = 0.0f;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+124], xmm0

; 523  : 		return gain_new;

	fld	DWORD PTR _gain_new$[ebp]
	jmp	$LN1@SND_FadeTo
$LN3@SND_FadeTo:

; 524  : 	}
; 525  : 
; 526  : 	// set up new increment to new target
; 527  : 	frametime = s_listener.frametime;

	movss	xmm0, DWORD PTR _s_listener+68
	movss	DWORD PTR _frametime$[ebp], xmm0

; 528  : 	speed = ( frametime / SND_GAIN_FADE_TIME ) * ( gain_new - ch->ob_gain );

	movss	xmm0, DWORD PTR _frametime$[ebp]
	divss	xmm0, DWORD PTR __real@3e800000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm1, DWORD PTR _gain_new$[ebp]
	subss	xmm1, DWORD PTR [eax+116]
	mulss	xmm0, xmm1
	movss	DWORD PTR _speed$[ebp], xmm0

; 529  : 
; 530  : 	ch->ob_gain_inc = fabs( speed );

	cvtss2sd xmm0, DWORD PTR _speed$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	mov	eax, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [eax+124]

; 531  : 
; 532  : 	// ch->ob_gain_inc = fabs( gain_new - ch->ob_gain ) / 10.0f;
; 533  : 	ch->ob_gain_target = gain_new;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _gain_new$[ebp]
	movss	DWORD PTR [eax+120], xmm0

; 534  : 
; 535  : 	// if not hit target, keep approaching
; 536  : 	if( fabs( ch->ob_gain - ch->ob_gain_target ) > 0.01f )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	subss	xmm0, DWORD PTR [ecx+120]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv179[ebp]
	movsd	xmm0, QWORD PTR tv179[ebp]
	comisd	xmm0, QWORD PTR __real@3f847ae140000000
	jbe	SHORT $LN5@SND_FadeTo

; 537  : 	{
; 538  : 		ch->ob_gain = ApproachVal( ch->ob_gain_target, ch->ob_gain, ch->ob_gain_inc );

	mov	eax, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+124]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+116]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+120]
	movss	DWORD PTR [esp], xmm0
	call	_ApproachVal
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _ch$[ebp]
	fstp	DWORD PTR [eax+116]

; 539  : 	}

	jmp	SHORT $LN6@SND_FadeTo
$LN5@SND_FadeTo:

; 540  : 	else
; 541  : 	{
; 542  : 		// close enough, set gain = target
; 543  : 		ch->ob_gain = ch->ob_gain_target;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR [eax+116], edx
$LN6@SND_FadeTo:

; 544  : 	}
; 545  : 
; 546  : 	return ch->ob_gain;

	mov	eax, DWORD PTR _ch$[ebp]
	fld	DWORD PTR [eax+116]
$LN1@SND_FadeTo:

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_FadeToNewGain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_AlterChannel
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_sfx$ = 16						; size = 4
_vol$ = 20						; size = 4
_pitch$ = 24						; size = 4
_flags$ = 28						; size = 4
_S_AlterChannel PROC					; COMDAT

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 447  : 	channel_t	*ch;
; 448  : 	int	i;	
; 449  : 
; 450  : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	$LN8@S_AlterCha

; 451  : 	{
; 452  : 		// This is a sentence name.
; 453  : 		// For sentences: assume that the entity is only playing one sentence
; 454  : 		// at a time, so we can just shut off
; 455  : 		// any channel that has ch->isSentence >= 0 and matches the entnum.
; 456  : 
; 457  : 		for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@S_AlterCha
$LN2@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN4@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN3@S_AlterCha

; 458  : 		{
; 459  : 			if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx && ch->isSentence )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	jne	SHORT $LN9@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN9@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN9@S_AlterCha

; 460  : 			{
; 461  : 				if( flags & SND_CHANGE_PITCH )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN10@S_AlterCha

; 462  : 					ch->basePitch = pitch;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax+60], ecx
$LN10@S_AlterCha:

; 463  : 				
; 464  : 				if( flags & SND_CHANGE_VOL )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN11@S_AlterCha

; 465  : 					ch->master_vol = vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN11@S_AlterCha:

; 466  : 				
; 467  : 				if( flags & SND_STOP )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN12@S_AlterCha

; 468  : 					S_FreeChannel( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4
$LN12@S_AlterCha:

; 469  : 
; 470  : 				return true;

	mov	eax, 1
	jmp	$LN1@S_AlterCha
$LN9@S_AlterCha:

; 471  : 			}
; 472  : 		}

	jmp	$LN2@S_AlterCha
$LN3@S_AlterCha:

; 473  : 		// channel not found
; 474  : 		return false;

	xor	eax, eax
	jmp	$LN1@S_AlterCha
$LN8@S_AlterCha:

; 475  : 
; 476  : 	}
; 477  : 
; 478  : 	// regular sound or streaming sound
; 479  : 	for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN7@S_AlterCha
$LN5@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN7@S_AlterCha:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN6@S_AlterCha

; 480  : 	{
; 481  : 		if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx == sfx )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN13@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	jne	SHORT $LN13@S_AlterCha
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN13@S_AlterCha

; 482  : 		{
; 483  : 			if( flags & SND_CHANGE_PITCH )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN14@S_AlterCha

; 484  : 				ch->basePitch = pitch;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax+60], ecx
$LN14@S_AlterCha:

; 485  : 				
; 486  : 			if( flags & SND_CHANGE_VOL )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN15@S_AlterCha

; 487  : 				ch->master_vol = vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [eax+52], ecx
$LN15@S_AlterCha:

; 488  : 
; 489  : 			if( flags & SND_STOP )

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN16@S_AlterCha

; 490  : 				S_FreeChannel( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4
$LN16@S_AlterCha:

; 491  : 
; 492  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@S_AlterCha
$LN13@S_AlterCha:

; 493  : 		}
; 494  : 	}

	jmp	$LN5@S_AlterCha
$LN6@S_AlterCha:

; 495  : 	return false;

	xor	eax, eax
$LN1@S_AlterCha:

; 496  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_AlterChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_FStreamIsPlaying
_TEXT	SEGMENT
_ch_idx$ = -4						; size = 4
_sfx$ = 8						; size = 4
_SND_FStreamIsPlaying PROC				; COMDAT

; 286  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 287  : 	int	ch_idx;
; 288  : 
; 289  : 	for( ch_idx = NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++ )

	mov	DWORD PTR _ch_idx$[ebp], 4
	jmp	SHORT $LN4@SND_FStrea
$LN2@SND_FStrea:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
$LN4@SND_FStrea:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	SHORT $LN3@SND_FStrea

; 290  : 	{
; 291  : 		if( channels[ch_idx].sfx == sfx )

	imul	eax, DWORD PTR _ch_idx$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN5@SND_FStrea

; 292  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_FStrea
$LN5@SND_FStrea:

; 293  : 	}

	jmp	SHORT $LN2@SND_FStrea
$LN3@SND_FStrea:

; 294  : 
; 295  : 	return false;

	xor	eax, eax
$LN1@SND_FStrea:

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_FStreamIsPlaying ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_ChannelTraceReset
_TEXT	SEGMENT
_i$ = -4						; size = 4
_SND_ChannelTraceReset PROC				; COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 258  : 	int	i;
; 259  : 
; 260  : 	// reset search point - make sure we start counting from a new spot 
; 261  : 	// in channel list each time
; 262  : 	last_trace_chan += SND_TRACE_UPDATE_MAX;

	mov	eax, DWORD PTR _last_trace_chan
	add	eax, 2
	mov	DWORD PTR _last_trace_chan, eax

; 263  : 	
; 264  : 	// wrap at total_channels
; 265  : 	if( last_trace_chan >= total_channels )

	mov	eax, DWORD PTR _last_trace_chan
	cmp	eax, DWORD PTR _total_channels
	jl	SHORT $LN5@SND_Channe

; 266  : 		last_trace_chan = last_trace_chan - total_channels;

	mov	eax, DWORD PTR _last_trace_chan
	sub	eax, DWORD PTR _total_channels
	mov	DWORD PTR _last_trace_chan, eax
$LN5@SND_Channe:

; 267  : 
; 268  : 	// reset traceline counter
; 269  : 	trace_count = 0;

	mov	DWORD PTR _trace_count, 0

; 270  : 
; 271  : 	// reset channel traceline flag
; 272  : 	for( i = 0; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SND_Channe
$LN2@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN1@SND_Channe

; 273  : 		channels[i].bTraced = false; 

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	DWORD PTR _channels[eax+128], 0
	jmp	SHORT $LN2@SND_Channe
$LN1@SND_Channe:

; 274  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_ChannelTraceReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_ChannelOkToTrace
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_ch$ = 8						; size = 4
_SND_ChannelOkToTrace PROC				; COMDAT

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 219  : 	int 	i, j;
; 220  : 
; 221  : 	// always trace first time sound is spatialized
; 222  : 	if( ch->bfirstpass ) return true;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+112], 0
	je	SHORT $LN5@SND_Channe
	mov	eax, 1
	jmp	$LN1@SND_Channe
$LN5@SND_Channe:

; 223  : 
; 224  : 	// if already traced max channels, return
; 225  : 	if( trace_count >= SND_TRACE_UPDATE_MAX )

	cmp	DWORD PTR _trace_count, 2
	jl	SHORT $LN6@SND_Channe

; 226  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@SND_Channe
$LN6@SND_Channe:

; 227  : 
; 228  : 	// search through all channels starting at g_snd_last_trace_chan index
; 229  : 	j = last_trace_chan;

	mov	eax, DWORD PTR _last_trace_chan
	mov	DWORD PTR _j$[ebp], eax

; 230  : 
; 231  :  	for( i = 0; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SND_Channe
$LN2@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SND_Channe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN3@SND_Channe

; 232  : 	{
; 233  : 		if( &( channels[j] ) == ch )

	imul	eax, DWORD PTR _j$[ebp], 2480
	add	eax, OFFSET _channels
	cmp	eax, DWORD PTR _ch$[ebp]
	jne	SHORT $LN7@SND_Channe

; 234  : 		{
; 235  : 			ch->bTraced = true;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+128], 1

; 236  : 			trace_count++;

	mov	eax, DWORD PTR _trace_count
	add	eax, 1
	mov	DWORD PTR _trace_count, eax

; 237  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@SND_Channe
$LN7@SND_Channe:

; 238  : 		}
; 239  : 
; 240  : 		// wrap channel index
; 241  : 		if( ++j >= total_channels )

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _total_channels
	jl	SHORT $LN8@SND_Channe

; 242  : 			j = 0;

	mov	DWORD PTR _j$[ebp], 0
$LN8@SND_Channe:

; 243  : 	}

	jmp	SHORT $LN2@SND_Channe
$LN3@SND_Channe:

; 244  : 	
; 245  : 	// why didn't we find this channel?
; 246  : 	return false;			

	xor	eax, eax
$LN1@SND_Channe:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_ChannelOkToTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_UpdateSoundFade
_TEXT	SEGMENT
tv91 = -84						; size = 4
tv90 = -80						; size = 4
_elapsed$ = -12						; size = 4
_totaltime$ = -8					; size = 4
_f$ = -4						; size = 4
_S_UpdateSoundFade PROC					; COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 159  : 	float	f, totaltime, elapsed;
; 160  : 
; 161  : 	// determine current fade value.
; 162  : 	// assume no fading remains
; 163  : 	soundfade.percent = 0;  

	xorps	xmm0, xmm0
	movss	DWORD PTR _soundfade+4, xmm0

; 164  : 
; 165  : 	totaltime = soundfade.fadeouttime + soundfade.fadeintime + soundfade.holdtime;

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+20
	addss	xmm0, DWORD PTR _soundfade+16
	movss	DWORD PTR _totaltime$[ebp], xmm0

; 166  : 
; 167  : 	elapsed = cl.mtime[0] - soundfade.starttime;

	mov	eax, 8
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _soundfade+8
	movsd	xmm1, QWORD PTR _cl[ecx+32]
	subsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _elapsed$[ebp], xmm0

; 168  : 
; 169  : 	// clock wrapped or reset (BUG) or we've gone far enough
; 170  : 	if( elapsed < 0.0f || elapsed >= totaltime || totaltime <= 0.0f )

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	ja	SHORT $LN3@S_UpdateSo
	movss	xmm0, DWORD PTR _elapsed$[ebp]
	comiss	xmm0, DWORD PTR _totaltime$[ebp]
	jae	SHORT $LN3@S_UpdateSo
	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _totaltime$[ebp]
	jb	SHORT $LN2@S_UpdateSo
$LN3@S_UpdateSo:

; 171  : 		return;

	jmp	$LN9@S_UpdateSo
$LN2@S_UpdateSo:

; 172  : 
; 173  : 	// We are in the fade time, so determine amount of fade.
; 174  : 	if( soundfade.fadeouttime > 0.0f && ( elapsed < soundfade.fadeouttime ))

	movss	xmm0, DWORD PTR _soundfade+12
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@S_UpdateSo
	movss	xmm0, DWORD PTR _soundfade+12
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	jbe	SHORT $LN4@S_UpdateSo

; 175  : 	{
; 176  : 		// ramp up
; 177  : 		f = elapsed / soundfade.fadeouttime;

	movss	xmm0, DWORD PTR _elapsed$[ebp]
	divss	xmm0, DWORD PTR _soundfade+12
	movss	DWORD PTR _f$[ebp], xmm0

; 178  : 	}

	jmp	SHORT $LN7@S_UpdateSo
$LN4@S_UpdateSo:

; 179  : 	else if( elapsed <= ( soundfade.fadeouttime + soundfade.holdtime ))	// Inside the hold time

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+16
	comiss	xmm0, DWORD PTR _elapsed$[ebp]
	jb	SHORT $LN6@S_UpdateSo

; 180  : 	{
; 181  : 		// stay
; 182  : 		f = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _f$[ebp], xmm0

; 183  : 	}

	jmp	SHORT $LN7@S_UpdateSo
$LN6@S_UpdateSo:

; 184  : 	else
; 185  : 	{
; 186  : 		// ramp down
; 187  : 		f = ( elapsed - ( soundfade.fadeouttime + soundfade.holdtime ) ) / soundfade.fadeintime;

	movss	xmm0, DWORD PTR _soundfade+12
	addss	xmm0, DWORD PTR _soundfade+16
	movss	xmm1, DWORD PTR _elapsed$[ebp]
	subss	xmm1, xmm0
	divss	xmm1, DWORD PTR _soundfade+20
	movss	DWORD PTR _f$[ebp], xmm1

; 188  : 		f = 1.0f - f; // backward interpolated...

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _f$[ebp], xmm0
$LN7@S_UpdateSo:

; 189  : 	}
; 190  : 
; 191  : 	// spline it.
; 192  : 	f = SimpleSpline( f );

	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_SimpleSpline
	add	esp, 4
	fstp	DWORD PTR _f$[ebp]

; 193  : 	f = bound( 0.0f, f, 1.0f );

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@S_UpdateSo
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN11@S_UpdateSo
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN12@S_UpdateSo
$LN11@S_UpdateSo:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv90[ebp], xmm0
$LN12@S_UpdateSo:
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR tv91[ebp], xmm0
	jmp	SHORT $LN14@S_UpdateSo
$LN13@S_UpdateSo:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv91[ebp], xmm0
$LN14@S_UpdateSo:
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR _f$[ebp], xmm0

; 194  : 
; 195  : 	soundfade.percent = soundfade.initial_percent * f;

	movss	xmm0, DWORD PTR _soundfade
	mulss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR _soundfade+4, xmm0

; 196  : 
; 197  : 	if( snd_fade_sequence )

	cmp	DWORD PTR _snd_fade_sequence, 0
	je	SHORT $LN8@S_UpdateSo

; 198  : 		S_FadeMusicVolume( soundfade.percent );

	push	ecx
	movss	xmm0, DWORD PTR _soundfade+4
	movss	DWORD PTR [esp], xmm0
	call	_S_FadeMusicVolume
	add	esp, 4
$LN8@S_UpdateSo:

; 199  : 
; 200  : 	if( snd_fade_sequence && soundfade.percent == 100.0f )

	cmp	DWORD PTR _snd_fade_sequence, 0
	je	SHORT $LN9@S_UpdateSo
	movss	xmm0, DWORD PTR _soundfade+4
	ucomiss	xmm0, DWORD PTR __real@42c80000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@S_UpdateSo

; 201  : 	{
; 202  : 		S_StopAllSounds( false );

	push	0
	call	_S_StopAllSounds
	add	esp, 4

; 203  : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 204  : 		snd_fade_sequence = false;

	mov	DWORD PTR _snd_fade_sequence, 0
$LN9@S_UpdateSo:

; 205  : 	}
; 206  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateSoundFade ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_IsClient
_TEXT	SEGMENT
tv65 = -68						; size = 4
_entnum$ = 8						; size = 4
_S_IsClient PROC					; COMDAT

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 126  : 	return ( entnum == s_listener.entnum );

	mov	eax, DWORD PTR _entnum$[ebp]
	cmp	eax, DWORD PTR _s_listener+60
	jne	SHORT $LN3@S_IsClient
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@S_IsClient
$LN3@S_IsClient:
	mov	DWORD PTR tv65[ebp], 0
$LN4@S_IsClient:
	mov	eax, DWORD PTR tv65[ebp]

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_IsClient ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _dB_To_Radius
_TEXT	SEGMENT
tv74 = -68						; size = 4
_db$ = 8						; size = 4
_dB_To_Radius PROC					; COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 78   : 	return (SND_RADIUS_MIN + (SND_RADIUS_MAX - SND_RADIUS_MIN) * (db - SND_DB_MIN) / (SND_DB_MAX - SND_DB_MIN));

	movss	xmm0, DWORD PTR _db$[ebp]
	subss	xmm0, DWORD PTR __real@42700000
	mulss	xmm0, DWORD PTR __real@43580000
	divss	xmm0, DWORD PTR __real@42a00000
	addss	xmm0, DWORD PTR __real@41c00000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_dB_To_Radius ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _dB_To_Gain
_TEXT	SEGMENT
tv76 = -68						; size = 4
_dB$ = 8						; size = 4
_dB_To_Gain PROC					; COMDAT

; 70   : _inline float dB_To_Gain ( float dB ) { return pow( 10, dB / 20.0f ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	movss	xmm0, DWORD PTR _dB$[ebp]
	divss	xmm0, DWORD PTR __real@41a00000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	DWORD PTR tv76[ebp]
	fld	DWORD PTR tv76[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_dB_To_Gain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_ExtraUpdate
_TEXT	SEGMENT
_S_ExtraUpdate PROC					; COMDAT

; 1942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1943 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_ExtraUpd
	jmp	SHORT $LN1@S_ExtraUpd
$LN2@S_ExtraUpd:

; 1944 : 	S_UpdateChannels ();

	call	_S_UpdateChannels
$LN1@S_ExtraUpd:

; 1945 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_ExtraUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_UpdateSound
_TEXT	SEGMENT
tv206 = -112						; size = 4
tv86 = -112						; size = 4
_info$ = -44						; size = 20
_combine$ = -24						; size = 4
_ch$ = -20						; size = 4
_total$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_SND_UpdateSound PROC					; COMDAT

; 1972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1973 : 	int		i, j, total;
; 1974 : 	channel_t		*ch, *combine;
; 1975 : 	con_nprint_t	info;
; 1976 : 
; 1977 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN11@SND_Update
	jmp	$LN1@SND_Update
$LN11@SND_Update:

; 1978 : 
; 1979 : 	// if the loading plaque is up, clear everything
; 1980 : 	// out to make sure we aren't looping a dirty
; 1981 : 	// dma buffer while loading
; 1982 : 	// update any client side sound fade
; 1983 : 	S_UpdateSoundFade();

	call	_S_UpdateSoundFade

; 1984 : 
; 1985 : 	// release raw-channels that no longer used more than 10 secs
; 1986 : 	S_FreeIdleRawChannels();

	call	_S_FreeIdleRawChannels

; 1987 : 
; 1988 : 	VectorCopy( cl.simvel, s_listener.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212988]
	mov	DWORD PTR _s_listener[eax+12], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212988]
	mov	DWORD PTR _s_listener[eax+12], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212988]
	mov	DWORD PTR _s_listener[eax+12], ecx

; 1989 : 	s_listener.frametime = (cl.time - cl.oldtime);

	movsd	xmm0, QWORD PTR _cl+2167640
	subsd	xmm0, QWORD PTR _cl+2167648
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s_listener+68, xmm0

; 1990 : 	s_listener.waterlevel = cl.local.waterlevel;

	mov	eax, DWORD PTR _cl+2212736
	mov	DWORD PTR _s_listener+64, eax

; 1991 : 	s_listener.active = CL_IsInGame();

	call	_CL_IsInGame
	mov	DWORD PTR _s_listener+72, eax

; 1992 : 	s_listener.inmenu = CL_IsInMenu();

	call	_CL_IsInMenu
	mov	DWORD PTR _s_listener+76, eax

; 1993 : 	s_listener.paused = cl.paused;

	mov	eax, DWORD PTR _cl+24
	mov	DWORD PTR _s_listener+80, eax

; 1994 : 
; 1995 : 	if( cl.worldmodel != NULL )

	cmp	DWORD PTR _cl+4579004, 0
	je	SHORT $LN12@SND_Update

; 1996 : 		Mod_FatPVS( s_listener.origin, FATPHS_RADIUS, s_listener.pasbytes, world.visbytes, false, !s_phs->value );

	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN31@SND_Update
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN32@SND_Update
$LN31@SND_Update:
	mov	DWORD PTR tv86[ebp], 0
$LN32@SND_Update:
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _world+2588
	push	edx
	push	OFFSET _s_listener+92
	push	ecx
	movss	xmm0, DWORD PTR __real@41800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET _s_listener
	call	_Mod_FatPVS
	add	esp, 24					; 00000018H
$LN12@SND_Update:

; 1997 : 
; 1998 : 	// update general area ambient sound sources
; 1999 : 	S_UpdateAmbientSounds();

	call	_S_UpdateAmbientSounds

; 2000 : 
; 2001 : 	combine = NULL;

	mov	DWORD PTR _combine$[ebp], 0

; 2002 : 
; 2003 : 	// update spatialization for static and dynamic sounds	
; 2004 : 	for( i = NUM_AMBIENTS, ch = channels + NUM_AMBIENTS; i < total_channels; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 4
	mov	DWORD PTR _ch$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@SND_Update
$LN2@SND_Update:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN4@SND_Update:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	$LN3@SND_Update

; 2005 : 	{
; 2006 : 		if( !ch->sfx ) continue;

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN13@SND_Update
	jmp	SHORT $LN2@SND_Update
$LN13@SND_Update:

; 2007 : 		SND_Spatialize( ch ); // respatialize channel

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_Spatialize
	add	esp, 4

; 2008 : 
; 2009 : 		if( !ch->leftvol && !ch->rightvol )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN14@SND_Update
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN14@SND_Update

; 2010 : 			continue;

	jmp	SHORT $LN2@SND_Update
$LN14@SND_Update:

; 2011 : 
; 2012 : 		// try to combine static sounds with a previous channel of the same
; 2013 : 		// sound effect so we don't mix five torches every frame
; 2014 : 		// g-cont: perfomance option, probably kill stereo effect in most cases
; 2015 : 		if( i >= MAX_DYNAMIC_CHANNELS && s_combine_sounds->value )

	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jl	$LN19@SND_Update
	mov	eax, DWORD PTR _s_combine_sounds
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN19@SND_Update

; 2016 : 		{
; 2017 : 			// see if it can just use the last one
; 2018 : 			if( combine && combine->sfx == ch->sfx )

	cmp	DWORD PTR _combine$[ebp], 0
	je	SHORT $LN16@SND_Update
	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN16@SND_Update

; 2019 : 			{
; 2020 : 				combine->leftvol += ch->leftvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2021 : 				combine->rightvol += ch->rightvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2022 : 				ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 2023 : 				continue;

	jmp	$LN2@SND_Update
$LN16@SND_Update:

; 2024 : 			}
; 2025 : 
; 2026 : 			// search for one
; 2027 : 			combine = channels + MAX_DYNAMIC_CHANNELS;

	mov	DWORD PTR _combine$[ebp], OFFSET _channels+158720

; 2028 : 
; 2029 : 			for( j = MAX_DYNAMIC_CHANNELS; j < i; j++, combine++ )

	mov	DWORD PTR _j$[ebp], 64			; 00000040H
	jmp	SHORT $LN7@SND_Update
$LN5@SND_Update:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _combine$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _combine$[ebp], ecx
$LN7@SND_Update:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _i$[ebp]
	jge	SHORT $LN6@SND_Update

; 2030 : 			{
; 2031 : 				if( combine->sfx == ch->sfx )

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN17@SND_Update

; 2032 : 					break;

	jmp	SHORT $LN6@SND_Update
$LN17@SND_Update:

; 2033 : 			}

	jmp	SHORT $LN5@SND_Update
$LN6@SND_Update:

; 2034 : 
; 2035 : 			if( j == total_channels )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jne	SHORT $LN18@SND_Update

; 2036 : 			{
; 2037 : 				combine = NULL;

	mov	DWORD PTR _combine$[ebp], 0

; 2038 : 			}

	jmp	SHORT $LN19@SND_Update
$LN18@SND_Update:

; 2039 : 			else
; 2040 : 			{
; 2041 : 				if( combine != ch )

	mov	eax, DWORD PTR _combine$[ebp]
	cmp	eax, DWORD PTR _ch$[ebp]
	je	SHORT $LN20@SND_Update

; 2042 : 				{
; 2043 : 					combine->leftvol += ch->leftvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2044 : 					combine->rightvol += ch->rightvol;

	mov	eax, DWORD PTR _combine$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _ch$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR _combine$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2045 : 					ch->leftvol = ch->rightvol = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+20], 0
$LN20@SND_Update:

; 2046 : 				}
; 2047 : 				continue;

	jmp	$LN2@SND_Update
$LN19@SND_Update:

; 2048 : 			}
; 2049 : 		}
; 2050 : 	}

	jmp	$LN2@SND_Update
$LN3@SND_Update:

; 2051 : 
; 2052 : 	S_SpatializeRawChannels();

	call	_S_SpatializeRawChannels

; 2053 : 
; 2054 : 	// debugging output
; 2055 : 	if( CVAR_TO_BOOL( s_show ))

	cmp	DWORD PTR _s_show, 0
	je	SHORT $LN33@SND_Update
	mov	eax, DWORD PTR _s_show
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN33@SND_Update
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN34@SND_Update
$LN33@SND_Update:
	mov	DWORD PTR tv206[ebp], 0
$LN34@SND_Update:
	cmp	DWORD PTR tv206[ebp], 0
	je	$LN21@SND_Update

; 2056 : 	{
; 2057 : 		info.color[0] = 1.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0

; 2058 : 		info.color[1] = 0.6f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f19999a
	movss	DWORD PTR _info$[ebp+eax+8], xmm0

; 2059 : 		info.color[2] = 0.0f;

	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0

; 2060 : 		info.time_to_live = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _info$[ebp+4], xmm0

; 2061 : 
; 2062 : 		for( i = 0, total = 1, ch = channels; i < MAX_CHANNELS; i++, ch++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _total$[ebp], 1
	mov	DWORD PTR _ch$[ebp], OFFSET _channels
	jmp	SHORT $LN10@SND_Update
$LN8@SND_Update:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _ch$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _ch$[ebp], ecx
$LN10@SND_Update:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	$LN9@SND_Update

; 2063 : 		{
; 2064 : 			if( ch->sfx && ( ch->leftvol || ch->rightvol ))

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN22@SND_Update
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN23@SND_Update
	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	$LN22@SND_Update
$LN23@SND_Update:

; 2065 : 			{
; 2066 : 				info.index = total;

	mov	eax, DWORD PTR _total$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 2067 : 				Con_NXPrintf( &info, "chan %i, pos (%.f %.f %.f) ent %i, lv%3i rv%3i %s\n",

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+edx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+ecx+36]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@IALGGBFP@chan?5?$CFi?0?5pos?5?$CI?$CF?4f?5?$CF?4f?5?$CF?4f?$CJ?5ent?5@
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_Con_NXPrintf
	add	esp, 52					; 00000034H

; 2068 : 				i, ch->origin[0], ch->origin[1], ch->origin[2], ch->entnum, ch->leftvol, ch->rightvol, ch->sfx->name );
; 2069 : 				total++;

	mov	eax, DWORD PTR _total$[ebp]
	add	eax, 1
	mov	DWORD PTR _total$[ebp], eax
$LN22@SND_Update:

; 2070 : 			}
; 2071 : 		}

	jmp	$LN8@SND_Update
$LN9@SND_Update:

; 2072 : 
; 2073 : 		// to differentiate modes
; 2074 : 		if( s_cull->value && s_phs->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SND_Update
	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SND_Update

; 2075 : 			VectorSet( info.color, 0.0f, 1.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	jmp	$LN29@SND_Update
$LN24@SND_Update:

; 2076 : 		else if( s_phs->value )

	mov	eax, DWORD PTR _s_phs
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@SND_Update

; 2077 : 			VectorSet( info.color, 1.0f, 1.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	jmp	$LN29@SND_Update
$LN26@SND_Update:

; 2078 : 		else if( s_cull->value )

	mov	eax, DWORD PTR _s_cull
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@SND_Update

; 2079 : 			VectorSet( info.color, 1.0f, 0.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	jmp	SHORT $LN29@SND_Update
$LN28@SND_Update:

; 2080 : 		else VectorSet( info.color, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
$LN29@SND_Update:

; 2081 : 		info.index = 0;

	mov	DWORD PTR _info$[ebp], 0

; 2082 : 
; 2083 : 		Con_NXPrintf( &info, "room_type: %i ----(%i)---- painted: %i\n", idsp_room, total - 1, paintedtime );

	mov	eax, DWORD PTR _paintedtime
	push	eax
	mov	ecx, DWORD PTR _total$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _idsp_room
	push	edx
	push	OFFSET ??_C@_0CI@EIBIENGJ@room_type?3?5?$CFi?5?9?9?9?9?$CI?$CFi?$CJ?9?9?9?9?5pain@
	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_Con_NXPrintf
	add	esp, 20					; 00000014H
$LN21@SND_Update:

; 2084 : 	}
; 2085 : 
; 2086 : 	S_StreamBackgroundTrack ();

	call	_S_StreamBackgroundTrack

; 2087 : 	S_StreamSoundTrack ();

	call	_S_StreamSoundTrack

; 2088 : 
; 2089 : 	// mix some sound
; 2090 : 	S_UpdateChannels ();

	call	_S_UpdateChannels
$LN1@SND_Update:

; 2091 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_UpdateSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StartLocalSound
_TEXT	SEGMENT
_channel$ = -12						; size = 4
_flags$ = -8						; size = 4
_sfxHandle$ = -4					; size = 4
_name$ = 8						; size = 4
_volume$ = 12						; size = 4
_reliable$ = 16						; size = 4
_S_StartLocalSound PROC					; COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1241 : 	sound_t	sfxHandle;
; 1242 : 	int	flags = (SND_LOCALSOUND|SND_STOP_LOOPING);

	mov	DWORD PTR _flags$[ebp], 1536		; 00000600H

; 1243 : 	int	channel = CHAN_AUTO;

	mov	DWORD PTR _channel$[ebp], 0

; 1244 : 
; 1245 : 	if( reliable ) channel = CHAN_STATIC;

	cmp	DWORD PTR _reliable$[ebp], 0
	je	SHORT $LN2@S_StartLoc
	mov	DWORD PTR _channel$[ebp], 7
$LN2@S_StartLoc:

; 1246 : 
; 1247 : 	if( !dma.initialized ) return;	

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN3@S_StartLoc
	jmp	SHORT $LN1@S_StartLoc
$LN3@S_StartLoc:

; 1248 : 	sfxHandle = S_RegisterSound( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_S_RegisterSound
	add	esp, 4
	mov	DWORD PTR _sfxHandle$[ebp], eax

; 1249 : 	S_StartSound( NULL, s_listener.entnum, channel, sfxHandle, volume, ATTN_NONE, PITCH_NORM, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	100					; 00000064H
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _volume$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _sfxHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _channel$[ebp]
	push	edx
	mov	eax, DWORD PTR _s_listener+60
	push	eax
	push	0
	call	_S_StartSound
	add	esp, 32					; 00000020H
$LN1@S_StartLoc:

; 1250 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartLocalSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_FadeClientVolume
_TEXT	SEGMENT
_fadePercent$ = 8					; size = 4
_fadeOutSeconds$ = 12					; size = 4
_holdTime$ = 16						; size = 4
_fadeInSeconds$ = 20					; size = 4
_S_FadeClientVolume PROC				; COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 112  : 	soundfade.starttime	= cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR _soundfade+8, xmm0

; 113  : 	soundfade.initial_percent = fadePercent;       

	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	movss	DWORD PTR _soundfade, xmm0

; 114  : 	soundfade.fadeouttime = fadeOutSeconds;    

	movss	xmm0, DWORD PTR _fadeOutSeconds$[ebp]
	movss	DWORD PTR _soundfade+12, xmm0

; 115  : 	soundfade.holdtime = holdTime;   

	movss	xmm0, DWORD PTR _holdTime$[ebp]
	movss	DWORD PTR _soundfade+16, xmm0

; 116  : 	soundfade.fadeintime = fadeInSeconds;

	movss	xmm0, DWORD PTR _fadeInSeconds$[ebp]
	movss	DWORD PTR _soundfade+20, xmm0

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FadeClientVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_AmbientSound
_TEXT	SEGMENT
tv77 = -96						; size = 4
tv182 = -92						; size = 4
tv178 = -92						; size = 4
tv174 = -92						; size = 4
tv76 = -92						; size = 4
_radius$ = -24						; size = 4
_fvox$ = -20						; size = 4
_vol$ = -16						; size = 4
_sfx$ = -12						; size = 4
_pSource$ = -8						; size = 4
_ch$ = -4						; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_handle$ = 16						; size = 4
_fvol$ = 20						; size = 4
_attn$ = 24						; size = 4
_pitch$ = 28						; size = 4
_flags$ = 32						; size = 4
_S_AmbientSound PROC					; COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1156 : 	channel_t	*ch;
; 1157 : 	wavdata_t	*pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 1158 : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 1159 : 	int	vol, fvox = 0;

	mov	DWORD PTR _fvox$[ebp], 0

; 1160 : 	float	radius = SND_RADIUS_MAX;

	movss	xmm0, DWORD PTR __real@43700000
	movss	DWORD PTR _radius$[ebp], xmm0

; 1161 : 
; 1162 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN2@S_AmbientS:

; 1163 : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 1164 : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN3@S_AmbientS:

; 1165 : 
; 1166 : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN16@S_AmbientS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@S_AmbientS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN15@S_AmbientS
$LN14@S_AmbientS:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN15@S_AmbientS:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN17@S_AmbientS
$LN16@S_AmbientS:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN17@S_AmbientS:
	cvttss2si eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], eax

; 1167 : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN4@S_AmbientS
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN4@S_AmbientS:

; 1168 : 
; 1169 : 	if( flags & (SND_STOP|SND_CHANGE_VOL|SND_CHANGE_PITCH))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 224				; 000000e0H
	je	SHORT $LN7@S_AmbientS

; 1170 : 	{
; 1171 : 		if( S_AlterChannel( ent, CHAN_STATIC, sfx, vol, pitch, flags ))

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN6@S_AmbientS

; 1172 : 			return;

	jmp	$LN1@S_AmbientS
$LN6@S_AmbientS:

; 1173 : 		if( flags & SND_STOP ) return;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN7@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN7@S_AmbientS:

; 1174 : 	}
; 1175 : 
; 1176 : 	// pick a channel to play on from the static area
; 1177 : 	ch = SND_PickStaticChannel( pos, sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax

; 1178 : 	if( !ch ) return;

	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN8@S_AmbientS
	jmp	$LN1@S_AmbientS
$LN8@S_AmbientS:

; 1179 : 
; 1180 : 	VectorCopy( pos, ch->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ch$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+36], eax

; 1181 : 	ch->entnum = ent;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1182 : 
; 1183 : 	CL_GetEntitySpatialization( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_CL_GetEntitySpatialization
	add	esp, 4

; 1184 : 
; 1185 : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@S_AmbientS

; 1186 : 	{
; 1187 : 		// this is a sentence. link words to play in sequence.
; 1188 : 		// NOTE: sentence names stored in the cache lookup are
; 1189 : 		// prepended with a '!'.  Sentence names stored in the
; 1190 : 		// sentence file do not have a leading '!'. 
; 1191 : 
; 1192 : 		// link all words and load the first word
; 1193 : 		VOX_LoadSound( ch, S_SkipSoundChar( sfx->name ));

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_VOX_LoadSound
	add	esp, 8

; 1194 : 		Q_strncpy( ch->name, sfx->name, sizeof( ch->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1195 : 		sfx = ch->sfx;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _sfx$[ebp], ecx

; 1196 : 		if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN11@S_AmbientS
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pSource$[ebp], ecx
$LN11@S_AmbientS:

; 1197 : 		fvox = 1;

	mov	DWORD PTR _fvox$[ebp], 1

; 1198 : 	}

	jmp	SHORT $LN10@S_AmbientS
$LN9@S_AmbientS:

; 1199 : 	else
; 1200 : 	{
; 1201 : 		// load regular or stream sound
; 1202 : 		pSource = S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 1203 : 		ch->sfx = sfx;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1204 : 		ch->isSentence = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+56], 0

; 1205 : 		ch->name[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN10@S_AmbientS:

; 1206 : 	}
; 1207 : 
; 1208 : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN12@S_AmbientS

; 1209 : 	{
; 1210 : 		S_FreeChannel( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 1211 : 		return;

	jmp	$LN1@S_AmbientS
$LN12@S_AmbientS:

; 1212 : 	}
; 1213 : 
; 1214 : 	// never update positions if source entity is 0
; 1215 : 	ch->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN18@S_AmbientS
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN19@S_AmbientS
$LN18@S_AmbientS:
	mov	DWORD PTR tv174[ebp], 0
$LN19@S_AmbientS:
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR tv174[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1216 : 	ch->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN20@S_AmbientS
	mov	DWORD PTR tv178[ebp], 0
	jmp	SHORT $LN21@S_AmbientS
$LN20@S_AmbientS:
	mov	DWORD PTR tv178[ebp], 1
$LN21@S_AmbientS:
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR tv178[ebp]
	mov	DWORD PTR [ecx+68], edx

; 1217 : 	ch->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN22@S_AmbientS
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN23@S_AmbientS
$LN22@S_AmbientS:
	mov	DWORD PTR tv182[ebp], 0
$LN23@S_AmbientS:
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR tv182[ebp]
	mov	DWORD PTR [ecx+76], edx

; 1218 : 	ch->master_vol = vol;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 1219 : 	ch->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 1220 : 	ch->entchannel = CHAN_STATIC;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+32], 7

; 1221 : 	ch->basePitch = pitch;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 1222 : 	ch->radius = radius;

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR [eax+132], xmm0

; 1223 : 
; 1224 : 	// initialize gain due to obscured sound source
; 1225 : 	ch->bfirstpass = true;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+112], 1

; 1226 : 	ch->ob_gain = 0.0;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 1227 : 	ch->ob_gain_inc = 0.0;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+124], xmm0

; 1228 : 	ch->ob_gain_target = 0.0;

	mov	eax, DWORD PTR _ch$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+120], xmm0

; 1229 : 	ch->bTraced = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+128], 0

; 1230 : 
; 1231 : 	SND_Spatialize( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_Spatialize
	add	esp, 4
$LN1@S_AmbientS:

; 1232 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_AmbientSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StartSound
_TEXT	SEGMENT
tv77 = -104						; size = 4
tv170 = -100						; size = 4
tv166 = -100						; size = 4
tv162 = -100						; size = 4
tv76 = -100						; size = 4
_skip$1 = -32						; size = 4
_bIgnore$ = -28						; size = 4
_ch_idx$ = -24						; size = 4
_vol$ = -20						; size = 4
_check$ = -16						; size = 4
_target_chan$ = -12					; size = 4
_sfx$ = -8						; size = 4
_pSource$ = -4						; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_handle$ = 20						; size = 4
_fvol$ = 24						; size = 4
_attn$ = 28						; size = 4
_pitch$ = 32						; size = 4
_flags$ = 36						; size = 4
_S_StartSound PROC					; COMDAT

; 899  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi

; 900  : 	wavdata_t	*pSource;
; 901  : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 902  : 	channel_t	*target_chan, *check;
; 903  : 	int	vol, ch_idx;
; 904  : 	qboolean	bIgnore = false;

	mov	DWORD PTR _bIgnore$[ebp], 0

; 905  : 
; 906  : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_StartSou
	jmp	$LN3@S_StartSou
$LN5@S_StartSou:

; 907  : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 908  : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN6@S_StartSou
	jmp	$LN3@S_StartSou
$LN6@S_StartSou:

; 909  : 
; 910  : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN30@S_StartSou
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN28@S_StartSou
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN29@S_StartSou
$LN28@S_StartSou:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN29@S_StartSou:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN31@S_StartSou
$LN30@S_StartSou:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN31@S_StartSou:
	cvttss2si eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], eax

; 911  : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN7@S_StartSou
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN7@S_StartSou:

; 912  : 
; 913  : 	if( flags & ( SND_STOP|SND_CHANGE_VOL|SND_CHANGE_PITCH ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 224				; 000000e0H
	je	SHORT $LN10@S_StartSou

; 914  : 	{
; 915  : 		if( S_AlterChannel( ent, chan, sfx, vol, pitch, flags ))

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pitch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vol$[ebp]
	push	edx
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _chan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
	test	eax, eax
	je	SHORT $LN9@S_StartSou

; 916  : 			return;

	jmp	$LN3@S_StartSou
$LN9@S_StartSou:

; 917  : 
; 918  : 		if( flags & SND_STOP ) return;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN10@S_StartSou
	jmp	$LN3@S_StartSou
$LN10@S_StartSou:

; 919  : 		// fall through - if we're not trying to stop the sound, 
; 920  : 		// and we didn't find it (it's not playing), go ahead and start it up
; 921  : 	}
; 922  : 
; 923  : 	if( !pos ) pos = RI.vieworg;

	cmp	DWORD PTR _pos$[ebp], 0
	jne	SHORT $LN11@S_StartSou
	mov	DWORD PTR _pos$[ebp], OFFSET _RI+200
$LN11@S_StartSou:

; 924  : 
; 925  : 	if( chan == CHAN_STREAM )

	cmp	DWORD PTR _chan$[ebp], 6
	jne	SHORT $LN12@S_StartSou

; 926  : 		SetBits( flags, SND_STOP_LOOPING );

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _flags$[ebp], eax
$LN12@S_StartSou:

; 927  : 
; 928  : 	// pick a channel to play on
; 929  : 	if( chan == CHAN_STATIC ) target_chan = SND_PickStaticChannel( pos, sfx );

	cmp	DWORD PTR _chan$[ebp], 7
	jne	SHORT $LN13@S_StartSou
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _target_chan$[ebp], eax
	jmp	SHORT $LN14@S_StartSou
$LN13@S_StartSou:

; 930  : 	else target_chan = SND_PickDynamicChannel( ent, chan, sfx, &bIgnore );

	lea	eax, DWORD PTR _bIgnore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SND_PickDynamicChannel
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target_chan$[ebp], eax
$LN14@S_StartSou:

; 931  : 
; 932  : 	if( !target_chan )

	cmp	DWORD PTR _target_chan$[ebp], 0
	jne	SHORT $LN15@S_StartSou

; 933  : 	{
; 934  : 		if( !bIgnore )

	cmp	DWORD PTR _bIgnore$[ebp], 0
	jne	SHORT $LN16@S_StartSou

; 935  : 			Con_DPrintf( S_ERROR "dropped sound \"%s%s\"\n", DEFAULT_SOUNDPATH, sfx->name );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_0CB@IFNNOFCP@?$FO1Error?3?$FO7?5dropped?5sound?5?$CC?$CFs?$CFs?$CC@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN16@S_StartSou:

; 936  : 		return;

	jmp	$LN3@S_StartSou
$LN15@S_StartSou:

; 937  : 	}
; 938  : 
; 939  : 	// spatialize
; 940  : 	memset( target_chan, 0, sizeof( *target_chan ));

	push	2480					; 000009b0H
	push	0
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  : 	VectorCopy( pos, target_chan->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+36], eax

; 943  : 	target_chan->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN32@S_StartSou
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN33@S_StartSou
$LN32@S_StartSou:
	mov	DWORD PTR tv162[ebp], 0
$LN33@S_StartSou:
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR [eax+72], ecx

; 944  : 	target_chan->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN34@S_StartSou
	mov	DWORD PTR tv166[ebp], 0
	jmp	SHORT $LN35@S_StartSou
$LN34@S_StartSou:
	mov	DWORD PTR tv166[ebp], 1
$LN35@S_StartSou:
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR [ecx+68], edx

; 945  : 	target_chan->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN36@S_StartSou
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN37@S_StartSou
$LN36@S_StartSou:
	mov	DWORD PTR tv170[ebp], 0
$LN37@S_StartSou:
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR [ecx+76], edx

; 946  : 	target_chan->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _target_chan$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 947  : 	target_chan->master_vol = vol;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 948  : 	target_chan->entnum = ent;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 949  : 	target_chan->entchannel = chan;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 950  : 	target_chan->basePitch = pitch;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 951  : 	target_chan->isSentence = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+56], 0

; 952  : 	target_chan->radius = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+132], xmm0

; 953  : 	target_chan->sfx = sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 954  : 
; 955  : 	// initialize gain due to obscured sound source
; 956  : 	target_chan->bfirstpass = true;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+112], 1

; 957  : 	target_chan->ob_gain = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 958  : 	target_chan->ob_gain_inc = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+124], xmm0

; 959  : 	target_chan->ob_gain_target = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+120], xmm0

; 960  : 	target_chan->bTraced = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+128], 0

; 961  : 
; 962  : 	pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 963  : 
; 964  : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@S_StartSou

; 965  : 	{
; 966  : 		// this is a sentence
; 967  : 		// link all words and load the first word
; 968  : 		// NOTE: sentence names stored in the cache lookup are
; 969  : 		// prepended with a '!'.  Sentence names stored in the
; 970  : 		// sentence file do not have a leading '!'. 
; 971  : 		VOX_LoadSound( target_chan, S_SkipSoundChar( sfx->name ));

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _target_chan$[ebp]
	push	ecx
	call	_VOX_LoadSound
	add	esp, 8

; 972  : 		Q_strncpy( target_chan->name, sfx->name, sizeof( target_chan->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target_chan$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 973  : 		sfx = target_chan->sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _sfx$[ebp], ecx

; 974  : 		if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN19@S_StartSou
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pSource$[ebp], ecx
$LN19@S_StartSou:

; 975  : 	}

	jmp	SHORT $LN18@S_StartSou
$LN17@S_StartSou:

; 976  : 	else
; 977  : 	{
; 978  : 		// regular or streamed sound fx
; 979  : 		pSource = S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 980  : 		target_chan->name[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN18@S_StartSou:

; 981  : 	}
; 982  : 
; 983  : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN20@S_StartSou

; 984  : 	{
; 985  : 		S_FreeChannel( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 986  : 		return;

	jmp	$LN3@S_StartSou
$LN20@S_StartSou:

; 987  : 	}
; 988  : 
; 989  : 	SND_Spatialize( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_SND_Spatialize
	add	esp, 4

; 990  : 
; 991  : 	// If a client can't hear a sound when they FIRST receive the StartSound message,
; 992  : 	// the client will never be able to hear that sound. This is so that out of 
; 993  : 	// range sounds don't fill the playback buffer. For streaming sounds, we bypass this optimization.
; 994  : 	if( !target_chan->leftvol && !target_chan->rightvol )

	mov	eax, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN24@S_StartSou
	mov	eax, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN24@S_StartSou

; 995  : 	{
; 996  : 		// looping sounds don't use this optimization because they should stick around until they're killed.
; 997  : 		if( !sfx->cache || sfx->cache->loopStart == -1 )

	mov	eax, DWORD PTR _sfx$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN23@S_StartSou
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	cmp	DWORD PTR [ecx+4], -1
	jne	SHORT $LN24@S_StartSou
$LN23@S_StartSou:

; 998  : 		{
; 999  : 			// if this is a streaming sound, play the whole thing.
; 1000 : 			if( chan != CHAN_STREAM )

	cmp	DWORD PTR _chan$[ebp], 6
	je	SHORT $LN24@S_StartSou

; 1001 : 			{
; 1002 : 				S_FreeChannel( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 1003 : 				return; // not audible at all

	jmp	$LN3@S_StartSou
$LN24@S_StartSou:

; 1004 : 			}
; 1005 : 		}
; 1006 : 	}
; 1007 : 
; 1008 : 	// Init client entity mouth movement vars
; 1009 : 	SND_InitMouth( ent, chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SND_InitMouth
	add	esp, 8

; 1010 : 
; 1011 : 	for( ch_idx = NUM_AMBIENTS, check = channels + NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++, check++)

	mov	DWORD PTR _ch_idx$[ebp], 4
	mov	DWORD PTR _check$[ebp], OFFSET _channels+9920
	jmp	SHORT $LN4@S_StartSou
$LN2@S_StartSou:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 2480				; 000009b0H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@S_StartSou:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	SHORT $LN3@S_StartSou

; 1012 : 	{
; 1013 : 		if( check == target_chan ) continue;

	mov	eax, DWORD PTR _check$[ebp]
	cmp	eax, DWORD PTR _target_chan$[ebp]
	jne	SHORT $LN25@S_StartSou
	jmp	SHORT $LN2@S_StartSou
$LN25@S_StartSou:

; 1014 : 
; 1015 : 		if( check->sfx == sfx && !check->pMixer.sample )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN26@S_StartSou
	mov	eax, DWORD PTR _check$[ebp]
	movsd	xmm0, QWORD PTR [eax+80]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@S_StartSou

; 1016 : 		{
; 1017 : 			// skip up to 0.1 seconds of audio
; 1018 : 			int skip = COM_RandomLong( 0, (long)( 0.1f * check->sfx->cache->rate ));

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+64]
	movzx	eax, WORD PTR [edx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cvttss2si ecx, xmm0
	push	ecx
	push	0
	call	_COM_RandomLong
	add	esp, 8
	mov	DWORD PTR _skip$1[ebp], eax

; 1019 :                               
; 1020 : 			S_SetSampleStart( check, sfx->cache, skip );

	mov	eax, DWORD PTR _skip$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	call	_S_SetSampleStart
	add	esp, 12					; 0000000cH

; 1021 : 			break;

	jmp	SHORT $LN3@S_StartSou
$LN26@S_StartSou:

; 1022 : 		}
; 1023 : 	}

	jmp	$LN2@S_StartSou
$LN3@S_StartSou:

; 1024 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_RestoreSound
_TEXT	SEGMENT
tv77 = -92						; size = 4
tv155 = -88						; size = 4
tv151 = -88						; size = 4
tv147 = -88						; size = 4
tv76 = -88						; size = 4
_vol$ = -20						; size = 4
_bIgnore$ = -16						; size = 4
_target_chan$ = -12					; size = 4
_sfx$ = -8						; size = 4
_pSource$ = -4						; size = 4
_pos$ = 8						; size = 4
_ent$ = 12						; size = 4
_chan$ = 16						; size = 4
_handle$ = 20						; size = 4
_fvol$ = 24						; size = 4
_attn$ = 28						; size = 4
_pitch$ = 32						; size = 4
_flags$ = 36						; size = 4
_sample$ = 40						; size = 8
_end$ = 48						; size = 8
_wordIndex$ = 56					; size = 4
_S_RestoreSound PROC					; COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1035 : 	wavdata_t	*pSource;
; 1036 : 	sfx_t	*sfx = NULL;

	mov	DWORD PTR _sfx$[ebp], 0

; 1037 : 	channel_t	*target_chan;
; 1038 : 	qboolean	bIgnore = false;

	mov	DWORD PTR _bIgnore$[ebp], 0

; 1039 : 	int	vol;
; 1040 : 
; 1041 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_RestoreS
	jmp	$LN1@S_RestoreS
$LN2@S_RestoreS:

; 1042 : 	sfx = S_GetSfxByHandle( handle );

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	_S_GetSfxByHandle
	add	esp, 4
	mov	DWORD PTR _sfx$[ebp], eax

; 1043 : 	if( !sfx ) return;

	cmp	DWORD PTR _sfx$[ebp], 0
	jne	SHORT $LN3@S_RestoreS
	jmp	$LN1@S_RestoreS
$LN3@S_RestoreS:

; 1044 : 
; 1045 : 	vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN19@S_RestoreS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN17@S_RestoreS
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN18@S_RestoreS
$LN17@S_RestoreS:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv76[ebp], xmm0
$LN18@S_RestoreS:
	movss	xmm0, DWORD PTR tv76[ebp]
	movss	DWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN20@S_RestoreS
$LN19@S_RestoreS:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv77[ebp], xmm0
$LN20@S_RestoreS:
	cvttss2si eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _vol$[ebp], eax

; 1046 : 	if( pitch <= 1 ) pitch = PITCH_NORM; // Invasion issues

	cmp	DWORD PTR _pitch$[ebp], 1
	jg	SHORT $LN4@S_RestoreS
	mov	DWORD PTR _pitch$[ebp], 100		; 00000064H
$LN4@S_RestoreS:

; 1047 : 
; 1048 : 	// pick a channel to play on
; 1049 : 	if( chan == CHAN_STATIC ) target_chan = SND_PickStaticChannel( pos, sfx );

	cmp	DWORD PTR _chan$[ebp], 7
	jne	SHORT $LN5@S_RestoreS
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	call	_SND_PickStaticChannel
	add	esp, 8
	mov	DWORD PTR _target_chan$[ebp], eax
	jmp	SHORT $LN6@S_RestoreS
$LN5@S_RestoreS:

; 1050 : 	else target_chan = SND_PickDynamicChannel( ent, chan, sfx, &bIgnore );

	lea	eax, DWORD PTR _bIgnore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sfx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chan$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	_SND_PickDynamicChannel
	add	esp, 16					; 00000010H
	mov	DWORD PTR _target_chan$[ebp], eax
$LN6@S_RestoreS:

; 1051 : 
; 1052 : 	if( !target_chan )

	cmp	DWORD PTR _target_chan$[ebp], 0
	jne	SHORT $LN7@S_RestoreS

; 1053 : 	{
; 1054 : 		if( !bIgnore )

	cmp	DWORD PTR _bIgnore$[ebp], 0
	jne	SHORT $LN8@S_RestoreS

; 1055 : 			Con_DPrintf( S_ERROR "dropped sound \"%s%s\"\n", DEFAULT_SOUNDPATH, sfx->name );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	push	OFFSET ??_C@_06PBLIODKG@sound?1@
	push	OFFSET ??_C@_0CB@IFNNOFCP@?$FO1Error?3?$FO7?5dropped?5sound?5?$CC?$CFs?$CFs?$CC@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN8@S_RestoreS:

; 1056 : 		return;

	jmp	$LN1@S_RestoreS
$LN7@S_RestoreS:

; 1057 : 	}
; 1058 : 
; 1059 : 	// spatialize
; 1060 : 	memset( target_chan, 0, sizeof( *target_chan ));

	push	2480					; 000009b0H
	push	0
	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1061 : 
; 1062 : 	VectorCopy( pos, target_chan->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax+36], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+edx]
	mov	DWORD PTR [ecx+eax+36], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	esi, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx+36], eax

; 1063 : 	target_chan->staticsound = ( ent == 0 ) ? true : false;

	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN21@S_RestoreS
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN22@S_RestoreS
$LN21@S_RestoreS:
	mov	DWORD PTR tv147[ebp], 0
$LN22@S_RestoreS:
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1064 : 	target_chan->use_loop = (flags & SND_STOP_LOOPING) ? false : true;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN23@S_RestoreS
	mov	DWORD PTR tv151[ebp], 0
	jmp	SHORT $LN24@S_RestoreS
$LN23@S_RestoreS:
	mov	DWORD PTR tv151[ebp], 1
$LN24@S_RestoreS:
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR [ecx+68], edx

; 1065 : 	target_chan->localsound = (flags & SND_LOCALSOUND) ? true : false;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN25@S_RestoreS
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN26@S_RestoreS
$LN25@S_RestoreS:
	mov	DWORD PTR tv155[ebp], 0
$LN26@S_RestoreS:
	mov	ecx, DWORD PTR _target_chan$[ebp]
	mov	edx, DWORD PTR tv155[ebp]
	mov	DWORD PTR [ecx+76], edx

; 1066 : 	target_chan->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _target_chan$[ebp]
	movss	DWORD PTR [eax+48], xmm0

; 1067 : 	target_chan->master_vol = vol;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _vol$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 1068 : 	target_chan->entnum = ent;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 1069 : 	target_chan->entchannel = chan;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _chan$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1070 : 	target_chan->basePitch = pitch;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _pitch$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 1071 : 	target_chan->isSentence = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+56], 0

; 1072 : 	target_chan->radius = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+132], xmm0

; 1073 : 	target_chan->sfx = sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _sfx$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1074 : 
; 1075 : 	// initialize gain due to obscured sound source
; 1076 : 	target_chan->bfirstpass = true;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+112], 1

; 1077 : 	target_chan->ob_gain = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+116], xmm0

; 1078 : 	target_chan->ob_gain_inc = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+124], xmm0

; 1079 : 	target_chan->ob_gain_target = 0.0f;

	mov	eax, DWORD PTR _target_chan$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+120], xmm0

; 1080 : 	target_chan->bTraced = false;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	DWORD PTR [eax+128], 0

; 1081 : 
; 1082 : 	pSource = NULL;

	mov	DWORD PTR _pSource$[ebp], 0

; 1083 : 
; 1084 : 	if( S_TestSoundChar( sfx->name, '!' ))

	push	33					; 00000021H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_TestSoundChar
	add	esp, 8
	test	eax, eax
	je	$LN9@S_RestoreS

; 1085 : 	{
; 1086 : 		// this is a sentence
; 1087 : 		// link all words and load the first word
; 1088 : 		// NOTE: sentence names stored in the cache lookup are
; 1089 : 		// prepended with a '!'.  Sentence names stored in the
; 1090 : 		// sentence file do not have a leading '!'. 
; 1091 : 		VOX_LoadSound( target_chan, S_SkipSoundChar( sfx->name ));

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_SkipSoundChar
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _target_chan$[ebp]
	push	ecx
	call	_VOX_LoadSound
	add	esp, 8

; 1092 : 		Q_strncpy( target_chan->name, sfx->name, sizeof( target_chan->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _target_chan$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1093 : 
; 1094 : 		// not a first word in sentence!
; 1095 : 		if( wordIndex != 0 )

	cmp	DWORD PTR _wordIndex$[ebp], 0
	je	SHORT $LN11@S_RestoreS

; 1096 : 		{
; 1097 : 			VOX_FreeWord( target_chan );		// release first loaded word

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_FreeWord
	add	esp, 4

; 1098 : 			target_chan->wordIndex = wordIndex;	// restore current word

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR _wordIndex$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 1099 : 			VOX_LoadWord( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_VOX_LoadWord
	add	esp, 4

; 1100 : 
; 1101 : 			if( target_chan->currentWord )

	mov	eax, DWORD PTR _target_chan$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN13@S_RestoreS

; 1102 : 			{
; 1103 : 				target_chan->sfx = target_chan->words[target_chan->wordIndex].sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+204]
	mov	DWORD PTR [edx+16], ecx

; 1104 : 				sfx = target_chan->sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _sfx$[ebp], ecx

; 1105 : 				pSource = sfx->cache;

	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pSource$[ebp], ecx
$LN13@S_RestoreS:

; 1106 : 			}
; 1107 : 		}

	jmp	SHORT $LN14@S_RestoreS
$LN11@S_RestoreS:

; 1108 : 		else
; 1109 : 		{
; 1110 : 			sfx = target_chan->sfx;

	mov	eax, DWORD PTR _target_chan$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _sfx$[ebp], ecx

; 1111 : 			if( sfx ) pSource = sfx->cache;

	cmp	DWORD PTR _sfx$[ebp], 0
	je	SHORT $LN14@S_RestoreS
	mov	eax, DWORD PTR _sfx$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _pSource$[ebp], ecx
$LN14@S_RestoreS:

; 1112 : 		}
; 1113 : 	}

	jmp	SHORT $LN10@S_RestoreS
$LN9@S_RestoreS:

; 1114 : 	else
; 1115 : 	{
; 1116 : 		// regular or streamed sound fx
; 1117 : 		pSource = S_LoadSound( sfx );

	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$[ebp], eax

; 1118 : 		target_chan->name[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _target_chan$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN10@S_RestoreS:

; 1119 : 	}
; 1120 : 
; 1121 : 	if( !pSource )

	cmp	DWORD PTR _pSource$[ebp], 0
	jne	SHORT $LN15@S_RestoreS

; 1122 : 	{
; 1123 : 		S_FreeChannel( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 1124 : 		return;

	jmp	SHORT $LN1@S_RestoreS
$LN15@S_RestoreS:

; 1125 : 	}
; 1126 : 
; 1127 : 	SND_Spatialize( target_chan );

	mov	eax, DWORD PTR _target_chan$[ebp]
	push	eax
	call	_SND_Spatialize
	add	esp, 4

; 1128 : 
; 1129 : 	// NOTE: first spatialization may be failed because listener position is invalid at this time
; 1130 : 	// so we should keep all sounds an actual and waiting for player spawn.
; 1131 : 
; 1132 : 	// apply the sample offests
; 1133 : 	target_chan->pMixer.sample = sample;

	mov	eax, DWORD PTR _target_chan$[ebp]
	movsd	xmm0, QWORD PTR _sample$[ebp]
	movsd	QWORD PTR [eax+80], xmm0

; 1134 : 	target_chan->pMixer.forcedEndSample = end;	

	mov	eax, DWORD PTR _target_chan$[ebp]
	movsd	xmm0, QWORD PTR _end$[ebp]
	movsd	QWORD PTR [eax+96], xmm0

; 1135 : 
; 1136 : 	// Init client entity mouth movement vars
; 1137 : 	SND_InitMouth( ent, chan );

	mov	eax, DWORD PTR _chan$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	_SND_InitMouth
	add	esp, 8
$LN1@S_RestoreS:

; 1138 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_RestoreSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StreamAviSamples
_TEXT	SEGMENT
tv252 = -8744						; size = 8
tv93 = -8744						; size = 4
tv92 = -8740						; size = 4
_info$1 = -8224						; size = 4
_ch$ = -8220						; size = 4
_fileBytes$ = -8216					; size = 4
_r$ = -8212						; size = 4
_duration$ = -8208					; size = 4
_raw$ = -8204						; size = 8192
_fileSamples$ = -12					; size = 4
_bufferSamples$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_Avi$ = 8						; size = 4
_entnum$ = 12						; size = 4
_fvol$ = 16						; size = 4
_attn$ = 20						; size = 4
_synctime$ = 24						; size = 4
_S_StreamAviSamples PROC				; COMDAT

; 1596 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8744				; 00002228H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1597 : 	int	bufferSamples;
; 1598 : 	int	fileSamples;
; 1599 : 	byte	raw[MAX_RAW_SAMPLES];
; 1600 : 	float	duration = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _duration$[ebp], xmm0

; 1601 : 	int	r, fileBytes;
; 1602 : 	rawchan_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 1603 : 
; 1604 : 	if( !dma.initialized || s_listener.paused || !CL_IsInGame( ))

	cmp	DWORD PTR _dma+12, 0
	je	SHORT $LN5@S_StreamAv
	cmp	DWORD PTR _s_listener+80, 0
	jne	SHORT $LN5@S_StreamAv
	call	_CL_IsInGame
	test	eax, eax
	jne	SHORT $LN4@S_StreamAv
$LN5@S_StreamAv:

; 1605 : 		return;

	jmp	$LN3@S_StreamAv
$LN4@S_StreamAv:

; 1606 : 
; 1607 : 	if( entnum < 0 || entnum >= GI->max_edicts )

	cmp	DWORD PTR _entnum$[ebp], 0
	jl	SHORT $LN7@S_StreamAv
	mov	eax, DWORD PTR _SI+768
	mov	ecx, DWORD PTR _entnum$[ebp]
	cmp	ecx, DWORD PTR [eax+1656]
	jl	SHORT $LN6@S_StreamAv
$LN7@S_StreamAv:

; 1608 : 		return;

	jmp	$LN3@S_StreamAv
$LN6@S_StreamAv:

; 1609 : 
; 1610 : 	if( !( ch = S_FindRawChannel( entnum, true )))

	push	1
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN8@S_StreamAv

; 1611 : 		return;

	jmp	$LN3@S_StreamAv
$LN8@S_StreamAv:

; 1612 : 
; 1613 : 	if( ch->sound_info.rate == 0 )

	mov	eax, DWORD PTR _ch$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	test	ecx, ecx
	jne	SHORT $LN10@S_StreamAv

; 1614 : 	{
; 1615 : 		if( !AVI_GetAudioInfo( Avi, &ch->sound_info ))

	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	push	ecx
	call	_AVI_GetAudioInfo
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@S_StreamAv

; 1616 : 			return; // no audiotrack

	jmp	$LN3@S_StreamAv
$LN10@S_StreamAv:

; 1617 : 	}
; 1618 : 
; 1619 : 	ch->master_vol = bound( 0, fvol * 255, 255 );

	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN21@S_StreamAv
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	xmm1, DWORD PTR __real@437f0000
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@S_StreamAv
	movss	xmm0, DWORD PTR _fvol$[ebp]
	mulss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv92[ebp], xmm0
	jmp	SHORT $LN20@S_StreamAv
$LN19@S_StreamAv:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv92[ebp], xmm0
$LN20@S_StreamAv:
	movss	xmm0, DWORD PTR tv92[ebp]
	movss	DWORD PTR tv93[ebp], xmm0
	jmp	SHORT $LN22@S_StreamAv
$LN21@S_StreamAv:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv93[ebp], xmm0
$LN22@S_StreamAv:
	cvttss2si eax, DWORD PTR tv93[ebp]
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1620 : 	ch->dist_mult = (attn / SND_CLIP_DISTANCE);

	movss	xmm0, DWORD PTR _attn$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	mov	eax, DWORD PTR _ch$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 1621 : 
; 1622 : 	// see how many samples should be copied into the raw buffer
; 1623 : 	if( ch->s_rawend < soundtime )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _soundtime
	jae	SHORT $LN11@S_StreamAv

; 1624 : 		ch->s_rawend = soundtime;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	mov	DWORD PTR [eax+36], ecx
$LN11@S_StreamAv:

; 1625 : 
; 1626 : 	// position is changed, synchronization is lost etc
; 1627 : 	if( fabs( ch->oldtime - synctime ) > s_mixahead->value )

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR [eax+68]
	subss	xmm0, DWORD PTR _synctime$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv252[ebp]
	movsd	xmm0, QWORD PTR tv252[ebp]
	mov	ecx, DWORD PTR _s_mixahead
	cvtss2sd xmm1, DWORD PTR [ecx+12]
	comisd	xmm0, xmm1
	jbe	SHORT $LN12@S_StreamAv

; 1628 : 		ch->sound_info.loopStart = AVI_TimeToSoundPosition( Avi, synctime * 1000 );

	movss	xmm0, DWORD PTR _synctime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	push	ecx
	call	_AVI_TimeToSoundPosition
	add	esp, 8
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+44], eax
$LN12@S_StreamAv:

; 1629 : 	ch->oldtime = synctime; // keep actual time

	mov	eax, DWORD PTR _ch$[ebp]
	movss	xmm0, DWORD PTR _synctime$[ebp]
	movss	DWORD PTR [eax+68], xmm0
$LN2@S_StreamAv:

; 1630 : 
; 1631 : 	while( ch->s_rawend < soundtime + ch->max_samples )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	add	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+36], ecx
	jae	$LN3@S_StreamAv

; 1632 : 	{
; 1633 : 		wavdata_t	*info = &ch->sound_info;

	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _info$1[ebp], eax

; 1634 : 
; 1635 : 		bufferSamples = ch->max_samples - (ch->s_rawend - soundtime);

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR _soundtime
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+72]
	sub	eax, ecx
	mov	DWORD PTR _bufferSamples$[ebp], eax

; 1636 : 
; 1637 : 		// decide how much data needs to be read from the file
; 1638 : 		fileSamples = bufferSamples * ((float)info->rate / SOUND_DMA_SPEED );

	cvtsi2ss xmm0, DWORD PTR _bufferSamples$[ebp]
	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, WORD PTR [eax]
	cvtsi2ss xmm1, ecx
	divss	xmm1, DWORD PTR __real@472c4400
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _fileSamples$[ebp], edx

; 1639 : 		if( fileSamples <= 1 ) return; // no more samples need

	cmp	DWORD PTR _fileSamples$[ebp], 1
	jg	SHORT $LN13@S_StreamAv
	jmp	$LN3@S_StreamAv
$LN13@S_StreamAv:

; 1640 : 
; 1641 : 		// our max buffer size
; 1642 : 		fileBytes = fileSamples * ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	imul	ecx, DWORD PTR _fileSamples$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], ecx

; 1643 : 
; 1644 : 		if( fileBytes > sizeof( raw ))

	cmp	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H
	jbe	SHORT $LN14@S_StreamAv

; 1645 : 		{
; 1646 : 			fileBytes = sizeof( raw );

	mov	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H

; 1647 : 			fileSamples = fileBytes / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _fileBytes$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN14@S_StreamAv:

; 1648 : 		}
; 1649 : 
; 1650 : 		// read audio stream
; 1651 : 		r = AVI_GetAudioChunk( Avi, raw, info->loopStart, fileBytes );

	mov	eax, DWORD PTR _fileBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _raw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Avi$[ebp]
	push	ecx
	call	_AVI_GetAudioChunk
	add	esp, 16					; 00000010H
	mov	DWORD PTR _r$[ebp], eax

; 1652 : 		info->loopStart += r; // advance play position

	mov	eax, DWORD PTR _info$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _info$1[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1653 : 
; 1654 : 		if( r < fileBytes )

	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _fileBytes$[ebp]
	jge	SHORT $LN15@S_StreamAv

; 1655 : 		{
; 1656 : 			fileBytes = r;

	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], eax

; 1657 : 			fileSamples = r / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _r$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN15@S_StreamAv:

; 1658 : 		}
; 1659 : 
; 1660 : 		if( r > 0 )

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN16@S_StreamAv

; 1661 : 		{
; 1662 : 			// add to raw buffer
; 1663 : 			ch->s_rawend = S_RawSamplesStereo( ch->rawsamples, ch->s_rawend, ch->max_samples,

	lea	eax, DWORD PTR _raw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+3]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+2]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _fileSamples$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _ch$[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	call	_S_RawSamplesStereo
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1664 : 			fileSamples, info->rate, info->width, info->channels, raw );
; 1665 : 		}

	jmp	SHORT $LN17@S_StreamAv
$LN16@S_StreamAv:

; 1666 : 		else break; // no more samples for this frame

	jmp	SHORT $LN3@S_StreamAv
$LN17@S_StreamAv:

; 1667 : 	}

	jmp	$LN2@S_StreamAv
$LN3@S_StreamAv:

; 1668 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamAviSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_ClearRawChannel
_TEXT	SEGMENT
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_S_ClearRawChannel PROC					; COMDAT

; 1691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1692 : 	rawchan_t	*ch;
; 1693 : 
; 1694 : 	if( !( ch = S_FindRawChannel( entnum, false )))

	push	0
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN2@S_ClearRaw

; 1695 : 		return;

	jmp	SHORT $LN1@S_ClearRaw
$LN2@S_ClearRaw:

; 1696 : 
; 1697 : 	ch->s_rawend = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+36], 0
$LN1@S_ClearRaw:

; 1698 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_ClearRawChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_GetRawSamplesLength
_TEXT	SEGMENT
tv88 = -84						; size = 8
tv85 = -76						; size = 4
tv76 = -72						; size = 4
_ch$ = -4						; size = 4
_entnum$ = 8						; size = 4
_S_GetRawSamplesLength PROC				; COMDAT

; 1676 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1677 : 	rawchan_t	*ch;
; 1678 : 
; 1679 : 	if( !( ch = S_FindRawChannel( entnum, false )))

	push	0
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN2@S_GetRawSa

; 1680 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@S_GetRawSa
$LN2@S_GetRawSa:

; 1681 : 
; 1682 : 	return ch->s_rawend <= paintedtime ? 0 : (float)(ch->s_rawend - paintedtime) * DMA_MSEC_PER_SAMPLE;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _paintedtime
	ja	SHORT $LN4@S_GetRawSa
	xorps	xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN5@S_GetRawSa
$LN4@S_GetRawSa:
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	eax, DWORD PTR _paintedtime
	mov	DWORD PTR tv85[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv85[ebp]
	mov	ecx, DWORD PTR tv85[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv88[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv88[ebp]
	mulss	xmm0, DWORD PTR __real@3cb9c278
	movss	DWORD PTR tv76[ebp], xmm0
$LN5@S_GetRawSa:
	movss	xmm0, DWORD PTR tv76[ebp]
	call	__ftol3
$LN1@S_GetRawSa:

; 1683 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetRawSamplesLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_UpdateFrame
_TEXT	SEGMENT
_rvp$ = 8						; size = 4
_S_UpdateFrame PROC					; COMDAT

; 1955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1956 : 	if( !FBitSet( rvp->flags, RF_DRAW_WORLD ) || FBitSet( rvp->flags, RF_ONLY_CLIENTDRAW ))

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 1
	je	SHORT $LN3@S_UpdateFr
	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	and	ecx, 8
	je	SHORT $LN2@S_UpdateFr
$LN3@S_UpdateFr:

; 1957 : 		return; 

	jmp	SHORT $LN1@S_UpdateFr
$LN2@S_UpdateFr:

; 1958 : 
; 1959 : 	VectorCopy( rvp->vieworigin, s_listener.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _s_listener[eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _rvp$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _s_listener[eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _rvp$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _s_listener[ecx], eax

; 1960 : 	AngleVectors( rvp->viewangles, s_listener.forward, s_listener.right, s_listener.up );

	push	OFFSET _s_listener+48
	push	OFFSET _s_listener+36
	push	OFFSET _s_listener+24
	mov	eax, DWORD PTR _rvp$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	call	_AngleVectors
	add	esp, 16					; 00000010H

; 1961 : 	s_listener.entnum = rvp->viewentity; // can be camera entity too

	mov	eax, DWORD PTR _rvp$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _s_listener+60, ecx
$LN1@S_UpdateFr:

; 1962 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_UpdateFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_RawSamples
_TEXT	SEGMENT
_snd_vol$ = -4						; size = 4
_samples$ = 8						; size = 4
_rate$ = 12						; size = 4
_width$ = 16						; size = 2
_channels$ = 20						; size = 2
_data$ = 24						; size = 4
_entnum$ = 28						; size = 4
_S_RawSamples PROC					; COMDAT

; 1581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1582 : 	int	snd_vol = 128;

	mov	DWORD PTR _snd_vol$[ebp], 128		; 00000080H

; 1583 : 
; 1584 : 	if( entnum < 0 ) snd_vol = 256; // bg track or movie track

	cmp	DWORD PTR _entnum$[ebp], 0
	jge	SHORT $LN2@S_RawSampl
	mov	DWORD PTR _snd_vol$[ebp], 256		; 00000100H
$LN2@S_RawSampl:

; 1585 : 	if( snd_vol < 0 ) snd_vol = 0; // fixup negative values

	cmp	DWORD PTR _snd_vol$[ebp], 0
	jge	SHORT $LN3@S_RawSampl
	mov	DWORD PTR _snd_vol$[ebp], 0
$LN3@S_RawSampl:

; 1586 : 
; 1587 : 	S_RawEntSamples( entnum, samples, rate, width, channels, data, snd_vol );

	mov	eax, DWORD PTR _snd_vol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _channels$[ebp]
	push	edx
	movzx	eax, WORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _samples$[ebp]
	push	edx
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_RawEntSamples
	add	esp, 28					; 0000001cH

; 1588 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_RawSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_FindRawChannel
_TEXT	SEGMENT
_time$1 = -28						; size = 4
_ch$ = -24						; size = 4
_raw_samples$ = -20					; size = 4
_best_time$ = -16					; size = 4
_best$ = -12						; size = 4
_free$ = -8						; size = 4
_i$ = -4						; size = 4
_entnum$ = 8						; size = 4
_create$ = 12						; size = 4
_S_FindRawChannel PROC					; COMDAT

; 1432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1433 : 	int	i, free;
; 1434 : 	int	best, best_time;
; 1435 : 	size_t	raw_samples = 0;

	mov	DWORD PTR _raw_samples$[ebp], 0

; 1436 : 	rawchan_t	*ch;
; 1437 : 
; 1438 : 	if( !entnum ) return NULL; // world is unused

	cmp	DWORD PTR _entnum$[ebp], 0
	jne	SHORT $LN5@S_FindRawC
	xor	eax, eax
	jmp	$LN1@S_FindRawC
$LN5@S_FindRawC:

; 1439 : 
; 1440 : 	// check for replacement sound, or find the best one to replace
; 1441 : 	best_time = 0x7fffffff;

	mov	DWORD PTR _best_time$[ebp], 2147483647	; 7fffffffH

; 1442 : 	best = free = -1;

	mov	DWORD PTR _free$[ebp], -1
	mov	eax, DWORD PTR _free$[ebp]
	mov	DWORD PTR _best$[ebp], eax

; 1443 : 
; 1444 : 	for( i = 0; i < MAX_RAW_CHANNELS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_FindRawC
$LN2@S_FindRawC:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_FindRawC:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jge	SHORT $LN3@S_FindRawC

; 1445 : 	{
; 1446 : 		ch = raw_channels[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$[ebp], ecx

; 1447 : 
; 1448 : 		if( free < 0 && !ch )

	cmp	DWORD PTR _free$[ebp], 0
	jge	SHORT $LN6@S_FindRawC
	cmp	DWORD PTR _ch$[ebp], 0
	jne	SHORT $LN6@S_FindRawC

; 1449 : 		{
; 1450 : 			free = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _free$[ebp], eax

; 1451 : 		}

	jmp	SHORT $LN7@S_FindRawC
$LN6@S_FindRawC:

; 1452 : 		else if( ch )

	cmp	DWORD PTR _ch$[ebp], 0
	je	SHORT $LN7@S_FindRawC

; 1453 : 		{
; 1454 : 			int	time;
; 1455 : 
; 1456 : 			// exact match
; 1457 : 			if( ch->entnum == entnum )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@S_FindRawC

; 1458 : 				return ch;

	mov	eax, DWORD PTR _ch$[ebp]
	jmp	$LN1@S_FindRawC
$LN9@S_FindRawC:

; 1459 : 
; 1460 : 			time = ch->s_rawend - paintedtime;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR _paintedtime
	mov	DWORD PTR _time$1[ebp], ecx

; 1461 : 			if( time < best_time )

	mov	eax, DWORD PTR _time$1[ebp]
	cmp	eax, DWORD PTR _best_time$[ebp]
	jge	SHORT $LN7@S_FindRawC

; 1462 : 			{
; 1463 : 				best = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _best$[ebp], eax

; 1464 : 				best_time = time;

	mov	eax, DWORD PTR _time$1[ebp]
	mov	DWORD PTR _best_time$[ebp], eax
$LN7@S_FindRawC:

; 1465 : 			}
; 1466 : 		}
; 1467 : 	}

	jmp	SHORT $LN2@S_FindRawC
$LN3@S_FindRawC:

; 1468 : 
; 1469 : 	if( !create ) return NULL;

	cmp	DWORD PTR _create$[ebp], 0
	jne	SHORT $LN11@S_FindRawC
	xor	eax, eax
	jmp	$LN1@S_FindRawC
$LN11@S_FindRawC:

; 1470 : 
; 1471 : 	if( free >= 0 ) best = free;

	cmp	DWORD PTR _free$[ebp], 0
	jl	SHORT $LN12@S_FindRawC
	mov	eax, DWORD PTR _free$[ebp]
	mov	DWORD PTR _best$[ebp], eax
$LN12@S_FindRawC:

; 1472 : 	if( best < 0 ) return NULL; // no free slots

	cmp	DWORD PTR _best$[ebp], 0
	jge	SHORT $LN13@S_FindRawC
	xor	eax, eax
	jmp	SHORT $LN1@S_FindRawC
$LN13@S_FindRawC:

; 1473 : 
; 1474 : 	if( !raw_channels[best] )

	mov	eax, DWORD PTR _best$[ebp]
	cmp	DWORD PTR _raw_channels[eax*4], 0
	jne	SHORT $LN14@S_FindRawC

; 1475 : 	{
; 1476 : 		raw_samples = MAX_RAW_SAMPLES;

	mov	DWORD PTR _raw_samples$[ebp], 8192	; 00002000H

; 1477 : 		raw_channels[best] = Mem_Calloc( sndpool, sizeof( *ch ) + sizeof( portable_samplepair_t ) * ( raw_samples - 1 ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??S_FindRawChannel@@9@9
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _raw_samples$[ebp]
	lea	edx, DWORD PTR [ecx*8+76]
	push	edx
	mov	eax, DWORD PTR _sndpool
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _best$[ebp]
	mov	DWORD PTR _raw_channels[ecx*4], eax
$LN14@S_FindRawC:

; 1478 : 	}
; 1479 : 
; 1480 : 	ch = raw_channels[best];

	mov	eax, DWORD PTR _best$[ebp]
	mov	ecx, DWORD PTR _raw_channels[eax*4]
	mov	DWORD PTR _ch$[ebp], ecx

; 1481 : 	ch->max_samples = raw_samples;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _raw_samples$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 1482 : 	ch->entnum = entnum;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _entnum$[ebp]
	mov	DWORD PTR [eax], ecx

; 1483 : 	ch->s_rawend = 0;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1484 : 
; 1485 : 	return ch;

	mov	eax, DWORD PTR _ch$[ebp]
$LN1@S_FindRawC:

; 1486 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FindRawChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_GetCurrentDynamicSounds
_TEXT	SEGMENT
tv173 = -80						; size = 4
tv131 = -80						; size = 4
_looped$ = -12						; size = 4
_i$ = -8						; size = 4
_sounds_left$ = -4					; size = 4
_pout$ = 8						; size = 4
_size$ = 12						; size = 4
_S_GetCurrentDynamicSounds PROC				; COMDAT

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1302 : 	int	sounds_left = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1303 : 	int	i, looped;
; 1304 : 
; 1305 : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_GetCurre

; 1306 : 		return 0;

	xor	eax, eax
	jmp	$LN1@S_GetCurre
$LN5@S_GetCurre:

; 1307 : 
; 1308 : 	for( i = 0; i < MAX_CHANNELS && sounds_left; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_GetCurre
$LN2@S_GetCurre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_GetCurre:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	$LN3@S_GetCurre
	cmp	DWORD PTR _sounds_left$[ebp], 0
	je	$LN3@S_GetCurre

; 1309 : 	{
; 1310 : 		if( !channels[i].sfx || !channels[i].sfx->name[0] || !Q_stricmp( channels[i].sfx->name, "*default" ))

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+16], 0
	je	SHORT $LN7@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	je	SHORT $LN7@S_GetCurre
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08KPIGECMN@?$CKdefault@
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@S_GetCurre
$LN7@S_GetCurre:

; 1311 : 			continue;	// don't serialize default sounds

	jmp	SHORT $LN2@S_GetCurre
$LN6@S_GetCurre:

; 1312 : 
; 1313 : 		looped = ( channels[i].use_loop && channels[i].sfx->cache->loopStart != -1 );

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+68], 0
	je	SHORT $LN12@S_GetCurre
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _channels[ecx+16]
	mov	eax, DWORD PTR [edx+64]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN12@S_GetCurre
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN13@S_GetCurre
$LN12@S_GetCurre:
	mov	DWORD PTR tv131[ebp], 0
$LN13@S_GetCurre:
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR _looped$[ebp], ecx

; 1314 : 
; 1315 : 		if( channels[i].entchannel == CHAN_STATIC && looped && !CL_IsQuakeCompatible())

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+32], 7
	jne	SHORT $LN8@S_GetCurre
	cmp	DWORD PTR _looped$[ebp], 0
	je	SHORT $LN8@S_GetCurre
	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN8@S_GetCurre

; 1316 : 			continue;	// never serialize static looped sounds. It will be restoring in game code 

	jmp	$LN2@S_GetCurre
$LN8@S_GetCurre:

; 1317 : 
; 1318 : 		if( channels[i].isSentence && channels[i].name[0] )

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+56], 0
	je	SHORT $LN9@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _channels[eax+edx]
	test	eax, eax
	je	SHORT $LN9@S_GetCurre

; 1319 : 			Q_strncpy( pout->name, channels[i].name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@S_GetCurre
$LN9@S_GetCurre:

; 1320 : 		else Q_strncpy( pout->name, channels[i].sfx->name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	push	ecx
	mov	edx, DWORD PTR _pout$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN10@S_GetCurre:

; 1321 : 		pout->entnum = (channels[i].entnum < 0) ? 0 : channels[i].entnum;

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+28], 0
	jge	SHORT $LN14@S_GetCurre
	mov	DWORD PTR tv173[ebp], 0
	jmp	SHORT $LN15@S_GetCurre
$LN14@S_GetCurre:
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _channels[ecx+28]
	mov	DWORD PTR tv173[ebp], edx
$LN15@S_GetCurre:
	mov	eax, DWORD PTR _pout$[ebp]
	mov	cx, WORD PTR tv173[ebp]
	mov	WORD PTR [eax+64], cx

; 1322 : 		VectorCopy( channels[i].origin, pout->origin );

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR _channels[eax+edx+36]
	mov	DWORD PTR [esi+ecx+68], edx
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	eax, DWORD PTR _channels[eax+ecx+36]
	mov	DWORD PTR [esi+edx+68], eax
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _channels[ecx+edx+36]
	mov	DWORD PTR [esi+eax+68], ecx

; 1323 : 		pout->volume = (float)channels[i].master_vol / 255.0f;

	imul	eax, DWORD PTR _i$[ebp], 2480
	cvtsi2ss xmm0, DWORD PTR _channels[eax+52]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 1324 : 		pout->attenuation = channels[i].dist_mult * SND_CLIP_DISTANCE;

	imul	eax, DWORD PTR _i$[ebp], 2480
	movss	xmm0, DWORD PTR _channels[eax+48]
	mulss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+84], xmm0

; 1325 : 		pout->pitch = channels[i].basePitch;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+60]
	mov	BYTE PTR [ecx+93], dl

; 1326 : 		pout->channel = channels[i].entchannel;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+32]
	mov	BYTE PTR [ecx+92], dl

; 1327 : 		pout->wordIndex = channels[i].wordIndex;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+164]
	mov	BYTE PTR [ecx+94], dl

; 1328 : 		pout->samplePos = channels[i].pMixer.sample;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[eax+80]
	movsd	QWORD PTR [ecx+96], xmm0

; 1329 : 		pout->forcedEnd = channels[i].pMixer.forcedEndSample;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[eax+96]
	movsd	QWORD PTR [ecx+104], xmm0

; 1330 : 		pout->looping = looped;

	mov	eax, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _looped$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 1331 : 
; 1332 : 		sounds_left--;

	mov	eax, DWORD PTR _sounds_left$[ebp]
	sub	eax, 1
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1333 : 		pout++;

	mov	eax, DWORD PTR _pout$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR _pout$[ebp], eax

; 1334 : 	}

	jmp	$LN2@S_GetCurre
$LN3@S_GetCurre:

; 1335 : 
; 1336 : 	return ( size - sounds_left );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _sounds_left$[ebp]
$LN1@S_GetCurre:

; 1337 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetCurrentDynamicSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_PickStaticChannel
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ch$ = -4						; size = 4
_pos$ = 8						; size = 4
_sfx$ = 12						; size = 4
_SND_PickStaticChannel PROC				; COMDAT

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 399  : 	channel_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 400  : 	int	i;
; 401  : 
; 402  : 	// check for replacement sound, or find the best one to replace
; 403  :  	for( i = MAX_DYNAMIC_CHANNELS; i < total_channels; i++ )

	mov	DWORD PTR _i$[ebp], 64			; 00000040H
	jmp	SHORT $LN4@SND_PickSt
$LN2@SND_PickSt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SND_PickSt:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	$LN3@SND_PickSt

; 404  :  	{
; 405  : 		if( channels[i].sfx == NULL )

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+16], 0
	jne	SHORT $LN5@SND_PickSt

; 406  : 			break;

	jmp	$LN3@SND_PickSt
$LN5@SND_PickSt:

; 407  : 
; 408  : 		if( VectorCompare( pos, channels[i].origin ) && channels[i].sfx == sfx )

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$[ebp], 2480
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+ecx]
	ucomiss	xmm0, DWORD PTR _channels[edx+eax+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	ucomiss	xmm0, DWORD PTR _channels[ecx+edx+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	shl	edx, 1
	mov	esi, DWORD PTR _pos$[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	ucomiss	xmm0, DWORD PTR _channels[ecx+edx+36]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@SND_PickSt
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN6@SND_PickSt

; 409  : 			break;

	jmp	SHORT $LN3@SND_PickSt
$LN6@SND_PickSt:

; 410  : 	}

	jmp	$LN2@SND_PickSt
$LN3@SND_PickSt:

; 411  : 
; 412  : 	if( i < total_channels ) 

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	SHORT $LN7@SND_PickSt

; 413  : 	{
; 414  : 		// reuse an empty static sound channel
; 415  : 		ch = &channels[i];

	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _ch$[ebp], eax

; 416  : 	}

	jmp	SHORT $LN8@SND_PickSt
$LN7@SND_PickSt:

; 417  : 	else
; 418  : 	{
; 419  : 		// no empty slots, alloc a new static sound channel
; 420  : 		if( total_channels == MAX_CHANNELS )

	cmp	DWORD PTR _total_channels, 320		; 00000140H
	jne	SHORT $LN9@SND_PickSt

; 421  : 		{
; 422  : 			Con_DPrintf( S_ERROR "S_PickStaticChannel: no free channels\n" );

	push	OFFSET ??_C@_0DC@GJNKBDLN@?$FO1Error?3?$FO7?5S_PickStaticChannel?3@
	call	_Con_DPrintf
	add	esp, 4

; 423  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SND_PickSt
$LN9@SND_PickSt:

; 424  : 		}
; 425  : 
; 426  : 		// get a channel for the static sound
; 427  : 		ch = &channels[total_channels];

	imul	eax, DWORD PTR _total_channels, 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _ch$[ebp], eax

; 428  : 		total_channels++;

	mov	eax, DWORD PTR _total_channels
	add	eax, 1
	mov	DWORD PTR _total_channels, eax
$LN8@SND_PickSt:

; 429  : 	}
; 430  : 	return ch;

	mov	eax, DWORD PTR _ch$[ebp]
$LN1@SND_PickSt:

; 431  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_PickStaticChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _SND_PickDynamicChannel
_TEXT	SEGMENT
_ch$1 = -28						; size = 4
_sc$2 = -24						; size = 4
_ch$3 = -20						; size = 4
_timeleft$ = -16					; size = 4
_life_left$ = -12					; size = 4
_first_to_die$ = -8					; size = 4
_ch_idx$ = -4						; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_sfx$ = 16						; size = 4
_ignore$ = 20						; size = 4
_SND_PickDynamicChannel PROC				; COMDAT

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 309  : 	int	ch_idx;
; 310  : 	int	first_to_die;
; 311  : 	int	life_left;
; 312  : 	int	timeleft;
; 313  : 
; 314  : 	// check for replacement sound, or find the best one to replace
; 315  : 	first_to_die = -1;

	mov	DWORD PTR _first_to_die$[ebp], -1

; 316  : 	life_left = 0x7fffffff;

	mov	DWORD PTR _life_left$[ebp], 2147483647	; 7fffffffH

; 317  : 	if( ignore ) *ignore = false;

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN5@SND_PickDy
	mov	eax, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SND_PickDy:

; 318  : 
; 319  : 	if( channel == CHAN_STREAM && SND_FStreamIsPlaying( sfx ))

	cmp	DWORD PTR _channel$[ebp], 6
	jne	SHORT $LN6@SND_PickDy
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	call	_SND_FStreamIsPlaying
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@SND_PickDy

; 320  : 	{
; 321  : 		if( ignore )

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN7@SND_PickDy

; 322  : 			*ignore = true;

	mov	eax, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [eax], 1
$LN7@SND_PickDy:

; 323  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SND_PickDy
$LN6@SND_PickDy:

; 324  : 	}
; 325  : 
; 326  : 	for( ch_idx = NUM_AMBIENTS; ch_idx < MAX_DYNAMIC_CHANNELS; ch_idx++ )

	mov	DWORD PTR _ch_idx$[ebp], 4
	jmp	SHORT $LN4@SND_PickDy
$LN2@SND_PickDy:
	mov	eax, DWORD PTR _ch_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ch_idx$[ebp], eax
$LN4@SND_PickDy:
	cmp	DWORD PTR _ch_idx$[ebp], 64		; 00000040H
	jge	$LN3@SND_PickDy

; 327  : 	{
; 328  : 		channel_t	*ch = &channels[ch_idx];

	imul	eax, DWORD PTR _ch_idx$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _ch$3[ebp], eax

; 329  : 		
; 330  : 		// Never override a streaming sound that is currently playing or
; 331  : 		// voice over IP data that is playing or any sound on CHAN_VOICE( acting )
; 332  : 		if( ch->sfx && ( ch->entchannel == CHAN_STREAM ))

	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN8@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+32], 6
	jne	SHORT $LN8@SND_PickDy

; 333  : 			continue;

	jmp	SHORT $LN2@SND_PickDy
$LN8@SND_PickDy:

; 334  : 
; 335  : 		if( channel != CHAN_AUTO && ch->entnum == entnum && ( ch->entchannel == channel || channel == -1 ))

	cmp	DWORD PTR _channel$[ebp], 0
	je	SHORT $LN9@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN9@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	je	SHORT $LN10@SND_PickDy
	cmp	DWORD PTR _channel$[ebp], -1
	jne	SHORT $LN9@SND_PickDy
$LN10@SND_PickDy:

; 336  : 		{
; 337  : 			// always override sound from same entity
; 338  : 			first_to_die = ch_idx;

	mov	eax, DWORD PTR _ch_idx$[ebp]
	mov	DWORD PTR _first_to_die$[ebp], eax

; 339  : 			break;

	jmp	SHORT $LN3@SND_PickDy
$LN9@SND_PickDy:

; 340  : 		}
; 341  : 
; 342  : 		// don't let monster sounds override player sounds
; 343  : 		if( ch->sfx && S_IsClient( ch->entnum ) && !S_IsClient( entnum ))

	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN11@SND_PickDy
	mov	eax, DWORD PTR _ch$3[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@SND_PickDy
	mov	eax, DWORD PTR _entnum$[ebp]
	push	eax
	call	_S_IsClient
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN11@SND_PickDy

; 344  : 			continue;

	jmp	$LN2@SND_PickDy
$LN11@SND_PickDy:

; 345  : 
; 346  : 		// try to pick the sound with the least amount of data left to play
; 347  : 		timeleft = 0;

	mov	DWORD PTR _timeleft$[ebp], 0

; 348  : 		if( ch->sfx )

	mov	eax, DWORD PTR _ch$3[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN12@SND_PickDy

; 349  : 		{
; 350  : 			timeleft = 1; // ch->end - paintedtime

	mov	DWORD PTR _timeleft$[ebp], 1
$LN12@SND_PickDy:

; 351  : 		}
; 352  : 
; 353  : 		if( timeleft < life_left )

	mov	eax, DWORD PTR _timeleft$[ebp]
	cmp	eax, DWORD PTR _life_left$[ebp]
	jge	SHORT $LN13@SND_PickDy

; 354  : 		{
; 355  : 			life_left = timeleft;

	mov	eax, DWORD PTR _timeleft$[ebp]
	mov	DWORD PTR _life_left$[ebp], eax

; 356  : 			first_to_die = ch_idx;

	mov	eax, DWORD PTR _ch_idx$[ebp]
	mov	DWORD PTR _first_to_die$[ebp], eax
$LN13@SND_PickDy:

; 357  : 		}
; 358  : 	}

	jmp	$LN2@SND_PickDy
$LN3@SND_PickDy:

; 359  : 
; 360  : 	if( first_to_die == -1 )

	cmp	DWORD PTR _first_to_die$[ebp], -1
	jne	SHORT $LN14@SND_PickDy

; 361  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@SND_PickDy
$LN14@SND_PickDy:

; 362  : 
; 363  : 	if( channels[first_to_die].sfx )

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	cmp	DWORD PTR _channels[eax+16], 0
	je	SHORT $LN15@SND_PickDy

; 364  : 	{
; 365  : 		// don't restart looping sounds for the same entity
; 366  : 		wavdata_t	*sc = channels[first_to_die].sfx->cache;

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR _sc$2[ebp], edx

; 367  : 
; 368  : 		if( sc && sc->loopStart != -1 )

	cmp	DWORD PTR _sc$2[ebp], 0
	je	SHORT $LN16@SND_PickDy
	mov	eax, DWORD PTR _sc$2[ebp]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN16@SND_PickDy

; 369  : 		{
; 370  : 			channel_t	*ch = &channels[first_to_die];

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	add	eax, OFFSET _channels
	mov	DWORD PTR _ch$1[ebp], eax

; 371  : 
; 372  : 			if( ch->entnum == entnum && ch->entchannel == channel && ch->sfx == sfx )

	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR _entnum$[ebp]
	jne	SHORT $LN16@SND_PickDy
	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+32]
	cmp	ecx, DWORD PTR _channel$[ebp]
	jne	SHORT $LN16@SND_PickDy
	mov	eax, DWORD PTR _ch$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _sfx$[ebp]
	jne	SHORT $LN16@SND_PickDy

; 373  : 			{
; 374  : 				if( ignore ) *ignore = true;

	cmp	DWORD PTR _ignore$[ebp], 0
	je	SHORT $LN18@SND_PickDy
	mov	eax, DWORD PTR _ignore$[ebp]
	mov	DWORD PTR [eax], 1
$LN18@SND_PickDy:

; 375  : 				// same looping sound, same ent, same channel, don't restart the sound
; 376  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@SND_PickDy
$LN16@SND_PickDy:

; 377  : 			}
; 378  : 		}
; 379  : 
; 380  : 		// be sure and release previous channel if sentence.
; 381  : 		S_FreeChannel( &( channels[first_to_die] ));

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	call	_S_FreeChannel
	add	esp, 4
$LN15@SND_PickDy:

; 382  : 	}
; 383  : 
; 384  : 	return &channels[first_to_die];

	imul	eax, DWORD PTR _first_to_die$[ebp], 2480
	add	eax, OFFSET _channels
$LN1@SND_PickDy:

; 385  : }       

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SND_PickDynamicChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_SoundInfo_f
_TEXT	SEGMENT
_S_SoundInfo_f PROC					; COMDAT

; 2315 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2316 : 	Con_Printf( "Audio: DirectSound\n" );

	push	OFFSET ??_C@_0BE@GJHINAHM@Audio?3?5DirectSound?6@
	call	_Con_Printf
	add	esp, 4

; 2317 : 	Con_Printf( "%5d channel(s)\n", 2 );

	push	2
	push	OFFSET ??_C@_0BA@JOMDFKBJ@?$CF5d?5channel?$CIs?$CJ?6@
	call	_Con_Printf
	add	esp, 8

; 2318 : 	Con_Printf( "%5d samples\n", dma.samples );

	mov	eax, DWORD PTR _dma
	push	eax
	push	OFFSET ??_C@_0N@LFEODKMK@?$CF5d?5samples?6@
	call	_Con_Printf
	add	esp, 8

; 2319 : 	Con_Printf( "%5d bits/sample\n", 16 );

	push	16					; 00000010H
	push	OFFSET ??_C@_0BB@DAEGPPBO@?$CF5d?5bits?1sample?6@
	call	_Con_Printf
	add	esp, 8

; 2320 : 	Con_Printf( "%5d bytes/sec\n", SOUND_DMA_SPEED );

	push	44100					; 0000ac44H
	push	OFFSET ??_C@_0P@HEEOPNMB@?$CF5d?5bytes?1sec?6@
	call	_Con_Printf
	add	esp, 8

; 2321 : 	Con_Printf( "%5d total_channels\n", total_channels );

	mov	eax, DWORD PTR _total_channels
	push	eax
	push	OFFSET ??_C@_0BE@FHKOKMBN@?$CF5d?5total_channels?6@
	call	_Con_Printf
	add	esp, 8

; 2322 : 
; 2323 : 	S_PrintBackgroundTrackState ();

	call	_S_PrintBackgroundTrackState

; 2324 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_SoundInfo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_FreeChannel
_TEXT	SEGMENT
_ch$ = 8						; size = 4
_S_FreeChannel PROC					; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 141  : 	ch->sfx = NULL;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+16], 0

; 142  : 	ch->name[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 143  : 	ch->use_loop = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+68], 0

; 144  : 	ch->isSentence = false;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [eax+56], 0

; 145  : 
; 146  : 	// clear mixer
; 147  : 	memset( &ch->pMixer, 0, sizeof( ch->pMixer ));

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _ch$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 148  : 
; 149  : 	SND_CloseMouth( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_SND_CloseMouth
	add	esp, 4

; 150  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FreeChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_GetMasterVolume
_TEXT	SEGMENT
tv75 = -76						; size = 4
tv129 = -72						; size = 4
tv74 = -72						; size = 4
_scale$ = -4						; size = 4
_S_GetMasterVolume PROC					; COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 95   : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 96   : 
; 97   : 	if( !s_listener.inmenu && soundfade.percent != 0 )

	cmp	DWORD PTR _s_listener+76, 0
	jne	$LN2@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@S_GetMaste

; 98   : 	{
; 99   : 		scale = bound( 0.0f, soundfade.percent / 100.0f, 1.0f );

	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@S_GetMaste
	movss	xmm0, DWORD PTR _soundfade+4
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN5@S_GetMaste
$LN4@S_GetMaste:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[ebp], xmm0
$LN5@S_GetMaste:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN7@S_GetMaste
$LN6@S_GetMaste:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN7@S_GetMaste:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0

; 100  : 		scale = 1.0f - scale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN2@S_GetMaste:

; 101  : 	}
; 102  : 	return s_volume->value * scale;

	mov	eax, DWORD PTR _s_volume
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
	fld	DWORD PTR tv129[ebp]

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetMasterVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StopAllSounds
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ambient$ = 8						; size = 4
_S_StopAllSounds PROC					; COMDAT

; 1874 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1875 : 	int	i;
; 1876 : 
; 1877 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_StopAllS
	jmp	$LN1@S_StopAllS
$LN5@S_StopAllS:

; 1878 : 	total_channels = MAX_DYNAMIC_CHANNELS;	// no statics

	mov	DWORD PTR _total_channels, 64		; 00000040H

; 1879 : 
; 1880 : 	for( i = 0; i < MAX_CHANNELS; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@S_StopAllS
$LN2@S_StopAllS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_StopAllS:
	cmp	DWORD PTR _i$[ebp], 320			; 00000140H
	jge	SHORT $LN3@S_StopAllS

; 1881 : 	{
; 1882 : 		if( !channels[i].sfx ) continue;

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+16], 0
	jne	SHORT $LN6@S_StopAllS
	jmp	SHORT $LN2@S_StopAllS
$LN6@S_StopAllS:

; 1883 : 		S_FreeChannel( &channels[i] );

	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	call	_S_FreeChannel
	add	esp, 4

; 1884 : 	}

	jmp	SHORT $LN2@S_StopAllS
$LN3@S_StopAllS:

; 1885 : 
; 1886 : 	DSP_ClearState();

	call	_DSP_ClearState

; 1887 : 
; 1888 : 	// clear all the channels
; 1889 : 	memset( channels, 0, sizeof( channels ));

	push	793600					; 000c1c00H
	push	0
	push	OFFSET _channels
	call	_memset
	add	esp, 12					; 0000000cH

; 1890 : 
; 1891 : 	// restart the ambient sounds
; 1892 : 	if( ambient ) S_InitAmbientChannels ();

	cmp	DWORD PTR _ambient$[ebp], 0
	je	SHORT $LN7@S_StopAllS
	call	_S_InitAmbientChannels
$LN7@S_StopAllS:

; 1893 : 
; 1894 : 	S_ClearBuffer ();

	call	_S_ClearBuffer

; 1895 : 
; 1896 : 	// clear any remaining soundfade
; 1897 : 	memset( &soundfade, 0, sizeof( soundfade ));

	push	24					; 00000018H
	push	0
	push	OFFSET _soundfade
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@S_StopAllS:

; 1898 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopAllSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_GetCurrentStaticSounds
_TEXT	SEGMENT
tv192 = -76						; size = 4
_i$ = -8						; size = 4
_sounds_left$ = -4					; size = 4
_pout$ = 8						; size = 4
_size$ = 12						; size = 4
_S_GetCurrentStaticSounds PROC				; COMDAT

; 1260 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1261 : 	int	sounds_left = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1262 : 	int	i;
; 1263 : 
; 1264 : 	if( !dma.initialized )

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN5@S_GetCurre

; 1265 : 		return 0;

	xor	eax, eax
	jmp	$LN1@S_GetCurre
$LN5@S_GetCurre:

; 1266 : 
; 1267 : 	for( i = MAX_DYNAMIC_CHANNELS; i < total_channels && sounds_left; i++ )

	mov	DWORD PTR _i$[ebp], 64			; 00000040H
	jmp	SHORT $LN4@S_GetCurre
$LN2@S_GetCurre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@S_GetCurre:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _total_channels
	jge	$LN3@S_GetCurre
	cmp	DWORD PTR _sounds_left$[ebp], 0
	je	$LN3@S_GetCurre

; 1268 : 	{
; 1269 : 		if( channels[i].entchannel == CHAN_STATIC && channels[i].sfx && channels[i].sfx->name[0] )

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+32], 7
	jne	$LN6@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+16], 0
	je	$LN6@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	je	$LN6@S_GetCurre

; 1270 : 		{
; 1271 : 			if( channels[i].isSentence && channels[i].name[0] )

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+56], 0
	je	SHORT $LN7@S_GetCurre
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _channels[eax+edx]
	test	eax, eax
	je	SHORT $LN7@S_GetCurre

; 1272 : 				Q_strncpy( pout->name, channels[i].name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	add	eax, OFFSET _channels
	push	eax
	mov	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@S_GetCurre
$LN7@S_GetCurre:

; 1273 : 			else Q_strncpy( pout->name, channels[i].sfx->name, sizeof( pout->name ));

	push	64					; 00000040H
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _channels[eax+16]
	push	ecx
	mov	edx, DWORD PTR _pout$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@S_GetCurre:

; 1274 : 			pout->entnum = channels[i].entnum;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dx, WORD PTR _channels[eax+28]
	mov	WORD PTR [ecx+64], dx

; 1275 : 			VectorCopy( channels[i].origin, pout->origin );

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR _channels[eax+edx+36]
	mov	DWORD PTR [esi+ecx+68], edx
	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _pout$[ebp]
	mov	eax, DWORD PTR _channels[eax+ecx+36]
	mov	DWORD PTR [esi+edx+68], eax
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _pout$[ebp]
	mov	ecx, DWORD PTR _channels[ecx+edx+36]
	mov	DWORD PTR [esi+eax+68], ecx

; 1276 : 			pout->volume = (float)channels[i].master_vol / 255.0f;

	imul	eax, DWORD PTR _i$[ebp], 2480
	cvtsi2ss xmm0, DWORD PTR _channels[eax+52]
	divss	xmm0, DWORD PTR __real@437f0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+80], xmm0

; 1277 : 			pout->attenuation = channels[i].dist_mult * SND_CLIP_DISTANCE;

	imul	eax, DWORD PTR _i$[ebp], 2480
	movss	xmm0, DWORD PTR _channels[eax+48]
	mulss	xmm0, DWORD PTR __real@447a0000
	mov	ecx, DWORD PTR _pout$[ebp]
	movss	DWORD PTR [ecx+84], xmm0

; 1278 : 			pout->looping = ( channels[i].use_loop && channels[i].sfx->cache->loopStart != -1 );

	imul	eax, DWORD PTR _i$[ebp], 2480
	cmp	DWORD PTR _channels[eax+68], 0
	je	SHORT $LN10@S_GetCurre
	imul	ecx, DWORD PTR _i$[ebp], 2480
	mov	edx, DWORD PTR _channels[ecx+16]
	mov	eax, DWORD PTR [edx+64]
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN10@S_GetCurre
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN11@S_GetCurre
$LN10@S_GetCurre:
	mov	DWORD PTR tv192[ebp], 0
$LN11@S_GetCurre:
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR [ecx+88], edx

; 1279 : 			pout->pitch = channels[i].basePitch;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+60]
	mov	BYTE PTR [ecx+93], dl

; 1280 : 			pout->channel = channels[i].entchannel;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+32]
	mov	BYTE PTR [ecx+92], dl

; 1281 : 			pout->wordIndex = channels[i].wordIndex;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	mov	dl, BYTE PTR _channels[eax+164]
	mov	BYTE PTR [ecx+94], dl

; 1282 : 			pout->samplePos = channels[i].pMixer.sample;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[eax+80]
	movsd	QWORD PTR [ecx+96], xmm0

; 1283 : 			pout->forcedEnd = channels[i].pMixer.forcedEndSample;

	imul	eax, DWORD PTR _i$[ebp], 2480
	mov	ecx, DWORD PTR _pout$[ebp]
	movsd	xmm0, QWORD PTR _channels[eax+96]
	movsd	QWORD PTR [ecx+104], xmm0

; 1284 : 
; 1285 : 			sounds_left--;

	mov	eax, DWORD PTR _sounds_left$[ebp]
	sub	eax, 1
	mov	DWORD PTR _sounds_left$[ebp], eax

; 1286 : 			pout++;

	mov	eax, DWORD PTR _pout$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR _pout$[ebp], eax
$LN6@S_GetCurre:

; 1287 : 		}
; 1288 : 	}

	jmp	$LN2@S_GetCurre
$LN3@S_GetCurre:

; 1289 : 
; 1290 : 	return ( size - sounds_left );

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, DWORD PTR _sounds_left$[ebp]
$LN1@S_GetCurre:

; 1291 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetCurrentStaticSounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_StopSound
_TEXT	SEGMENT
_sfx$ = -4						; size = 4
_entnum$ = 8						; size = 4
_channel$ = 12						; size = 4
_soundname$ = 16					; size = 4
_S_StopSound PROC					; COMDAT

; 1860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1861 : 	sfx_t	*sfx;
; 1862 : 
; 1863 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StopSoun
	jmp	SHORT $LN1@S_StopSoun
$LN2@S_StopSoun:

; 1864 : 	sfx = S_FindName( soundname, NULL );

	push	0
	mov	eax, DWORD PTR _soundname$[ebp]
	push	eax
	call	_S_FindName
	add	esp, 8
	mov	DWORD PTR _sfx$[ebp], eax

; 1865 : 	S_AlterChannel( entnum, channel, sfx, 0, 0, SND_STOP );

	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sfx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entnum$[ebp]
	push	edx
	call	_S_AlterChannel
	add	esp, 24					; 00000018H
$LN1@S_StopSoun:

; 1866 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Shutdown
_TEXT	SEGMENT
_S_Shutdown PROC					; COMDAT

; 2397 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2398 : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_Shutdown
	jmp	$LN1@S_Shutdown
$LN2@S_Shutdown:

; 2399 : 
; 2400 : 	Cmd_RemoveCommand( "play" );

	push	OFFSET ??_C@_04GBHMDDO@play@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2401 : 	Cmd_RemoveCommand( "playvol" );

	push	OFFSET ??_C@_07IJGGJOCA@playvol@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2402 : 	Cmd_RemoveCommand( "stopsound" );

	push	OFFSET ??_C@_09MAAKNOCD@stopsound@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2403 : 	Cmd_RemoveCommand( "music" );

	push	OFFSET ??_C@_05LLDJOKNO@music@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2404 : 	Cmd_RemoveCommand( "soundlist" );

	push	OFFSET ??_C@_09CJIFEKFJ@soundlist@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2405 : 	Cmd_RemoveCommand( "s_info" );

	push	OFFSET ??_C@_06KDCPAFOD@s_info@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2406 : 	Cmd_RemoveCommand( "s_fade" );

	push	OFFSET ??_C@_06IAHHLOIA@s_fade@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2407 : 	Cmd_RemoveCommand( "+voicerecord" );

	push	OFFSET ??_C@_0N@LEINJAHL@?$CLvoicerecord@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2408 : 	Cmd_RemoveCommand( "-voicerecord" );

	push	OFFSET ??_C@_0N@BEGIEPKG@?9voicerecord@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2409 : 	Cmd_RemoveCommand( "speak" );

	push	OFFSET ??_C@_05PJLNNFLG@speak@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2410 : 	Cmd_RemoveCommand( "spk" );

	push	OFFSET ??_C@_03HFMJPFKN@spk@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2411 : 
; 2412 : 	S_StopAllSounds (false);

	push	0
	call	_S_StopAllSounds
	add	esp, 4

; 2413 : 	S_FreeRawChannels ();

	call	_S_FreeRawChannels

; 2414 : 	S_FreeSounds ();

	call	_S_FreeSounds

; 2415 : 	VOX_Shutdown ();

	call	_VOX_Shutdown

; 2416 : 	SX_Free ();

	call	_SX_Free

; 2417 : 
; 2418 : 	SNDDMA_Shutdown ();

	call	_SNDDMA_Shutdown

; 2419 : 	MIX_FreeAllPaintbuffers ();

	call	_MIX_FreeAllPaintbuffers

; 2420 : 	Mem_FreePool( &sndpool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Shutdown@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _sndpool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH
$LN1@S_Shutdown:

; 2421 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_main.c
;	COMDAT _S_Init
_TEXT	SEGMENT
_S_Init	PROC						; COMDAT

; 2332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2333 : 	if( Sys_CheckParm( "-nosound" ))

	push	OFFSET ??_C@_08FLDKIHPE@?9nosound@
	call	_Sys_CheckParm
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@S_Init

; 2334 : 	{
; 2335 : 		Con_Printf( "Audio: Disabled\n" );

	push	OFFSET ??_C@_0BB@DKLPDJJH@Audio?3?5Disabled?6@
	call	_Con_Printf
	add	esp, 4

; 2336 : 		return false;

	xor	eax, eax
	jmp	$LN1@S_Init
$LN2@S_Init:

; 2337 : 	}
; 2338 : 
; 2339 : 	s_volume = Cvar_Get( "volume", "0.7", FCVAR_ARCHIVE, "sound volume" );

	push	OFFSET ??_C@_0N@DLGNHHCP@sound?5volume@
	push	1
	push	OFFSET ??_C@_03IMEEBDJM@0?47@
	push	OFFSET ??_C@_06EMCPHFGM@volume@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_volume, eax

; 2340 : 	s_musicvolume = Cvar_Get( "MP3Volume", "1.0", FCVAR_ARCHIVE, "background music volume" );

	push	OFFSET ??_C@_0BI@NFGOLMDH@background?5music?5volume@
	push	1
	push	OFFSET ??_C@_03HLLJOCDO@1?40@
	push	OFFSET ??_C@_09OPCAGCAA@MP3Volume@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_musicvolume, eax

; 2341 : 	s_mixahead = Cvar_Get( "_snd_mixahead", "0.12", 0, "how much sound to mix ahead of time" );

	push	OFFSET ??_C@_0CE@MCODGGLH@how?5much?5sound?5to?5mix?5ahead?5of?5@
	push	0
	push	OFFSET ??_C@_04BAMILDLP@0?412@
	push	OFFSET ??_C@_0O@KCANMFKJ@_snd_mixahead@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_mixahead, eax

; 2342 : 	s_show = Cvar_Get( "s_show", "0", FCVAR_ARCHIVE, "show playing sounds" );

	push	OFFSET ??_C@_0BE@NKNFOPGI@show?5playing?5sounds@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_06CBNOHGMK@s_show@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_show, eax

; 2343 : 	s_lerping = Cvar_Get( "s_lerping", "0", FCVAR_ARCHIVE, "apply interpolation to sound output" );

	push	OFFSET ??_C@_0CE@CMGAPAHP@apply?5interpolation?5to?5sound?5ou@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_09GDMJBOMF@s_lerping@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_lerping, eax

; 2344 : 	s_ambient_level = Cvar_Get( "ambient_level", "0.3", FCVAR_ARCHIVE, "volume of environment noises (water and wind)" );

	push	OFFSET ??_C@_0CO@JCIHEOCN@volume?5of?5environment?5noises?5?$CIw@
	push	1
	push	OFFSET ??_C@_03OICINGJI@0?43@
	push	OFFSET ??_C@_0O@CALFHOGH@ambient_level@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_ambient_level, eax

; 2345 : 	s_ambient_fade = Cvar_Get( "ambient_fade", "1000", FCVAR_ARCHIVE, "rate of volume fading when client is moving" );

	push	OFFSET ??_C@_0CM@HCOPHGBE@rate?5of?5volume?5fading?5when?5clie@
	push	1
	push	OFFSET ??_C@_04KOJKLCBG@1000@
	push	OFFSET ??_C@_0N@EEIPABOO@ambient_fade@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_ambient_fade, eax

; 2346 : 	s_combine_sounds = Cvar_Get( "s_combine_channels", "0", FCVAR_ARCHIVE, "combine channels with same sounds" ); 

	push	OFFSET ??_C@_0CC@HMJNPNMG@combine?5channels?5with?5same?5soun@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0BD@OPAKHCCE@s_combine_channels@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_combine_sounds, eax

; 2347 : 	snd_foliage_db_loss = Cvar_Get( "snd_foliage_db_loss", "4", 0, "foliage loss factor" ); 

	push	OFFSET ??_C@_0BE@ODLIHDCK@foliage?5loss?5factor@
	push	0
	push	OFFSET ??_C@_01FAMBOPH@4@
	push	OFFSET ??_C@_0BE@NECBKIEK@snd_foliage_db_loss@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_foliage_db_loss, eax

; 2348 : 	snd_gain_max = Cvar_Get( "snd_gain_max", "1", 0, "gain maximal threshold" );

	push	OFFSET ??_C@_0BH@HDNKNAKN@gain?5maximal?5threshold@
	push	0
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_0N@ELKLCACH@snd_gain_max@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain_max, eax

; 2349 : 	snd_gain_min = Cvar_Get( "snd_gain_min", "0.01", 0, "gain minimal threshold" );

	push	OFFSET ??_C@_0BH@CAHMMIEJ@gain?5minimal?5threshold@
	push	0
	push	OFFSET ??_C@_04DKCHIKEL@0?401@
	push	OFFSET ??_C@_0N@FJCAMEEI@snd_gain_min@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain_min, eax

; 2350 : 	s_refdist = Cvar_Get( "s_refdist", "36", 0, "soundlevel reference distance" );

	push	OFFSET ??_C@_0BO@JNLHGNDP@soundlevel?5reference?5distance@
	push	0
	push	OFFSET ??_C@_02KPIPOMFB@36@
	push	OFFSET ??_C@_09HCMODNKC@s_refdist@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_refdist, eax

; 2351 : 	s_refdb = Cvar_Get( "s_refdb", "60", 0, "soundlevel refernce dB" );

	push	OFFSET ??_C@_0BH@CCJCHMK@soundlevel?5refernce?5dB@
	push	0
	push	OFFSET ??_C@_02PPBOIJDM@60@
	push	OFFSET ??_C@_07HMPPLJEK@s_refdb@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_refdb, eax

; 2352 : 	snd_gain = Cvar_Get( "snd_gain", "1", 0, "sound default gain" );

	push	OFFSET ??_C@_0BD@KNNAKLIE@sound?5default?5gain@
	push	0
	push	OFFSET ??_C@_01HIHLOKLC@1@
	push	OFFSET ??_C@_08IDGIPJKB@snd_gain@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _snd_gain, eax

; 2353 : 	s_cull = Cvar_Get( "s_cull", "0", FCVAR_ARCHIVE, "cull sounds by geometry" );

	push	OFFSET ??_C@_0BI@HNLDNAJD@cull?5sounds?5by?5geometry@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_06EIDNBLMJ@s_cull@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_cull, eax

; 2354 : 	s_test = Cvar_Get( "s_test", "0", 0, "engine developer cvar for quick testing new features" );

	push	OFFSET ??_C@_0DF@LBCJGNLE@engine?5developer?5cvar?5for?5quick@
	push	0
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_06FPIFHLNA@s_test@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_test, eax

; 2355 : 	s_phs = Cvar_Get( "s_phs", "0", FCVAR_ARCHIVE, "cull sounds by PHS" );

	push	OFFSET ??_C@_0BD@MKBJIML@cull?5sounds?5by?5PHS@
	push	1
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_05FACBGJBI@s_phs@
	call	_Cvar_Get
	add	esp, 16					; 00000010H
	mov	DWORD PTR _s_phs, eax

; 2356 : 
; 2357 : 	Cmd_AddCommand( "play", S_Play_f, "playing a specified sound file" );

	push	OFFSET ??_C@_0BP@GMHOHLLC@playing?5a?5specified?5sound?5file@
	push	OFFSET _S_Play_f
	push	OFFSET ??_C@_04GBHMDDO@play@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2358 : 	Cmd_AddCommand( "play2", S_Play2_f, "playing a group of specified sound files" ); // nehahra stuff

	push	OFFSET ??_C@_0CJ@BIFCPPDC@playing?5a?5group?5of?5specified?5so@
	push	OFFSET _S_Play2_f
	push	OFFSET ??_C@_05CMBHFOBJ@play2@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2359 : 	Cmd_AddCommand( "playvol", S_PlayVol_f, "playing a specified sound file with specified volume" );

	push	OFFSET ??_C@_0DF@GNICHBJN@playing?5a?5specified?5sound?5file?5@
	push	OFFSET _S_PlayVol_f
	push	OFFSET ??_C@_07IJGGJOCA@playvol@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2360 : 	Cmd_AddCommand( "stopsound", S_StopSound_f, "stop all sounds" );

	push	OFFSET ??_C@_0BA@INMDPMLC@stop?5all?5sounds@
	push	OFFSET _S_StopSound_f
	push	OFFSET ??_C@_09MAAKNOCD@stopsound@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2361 : 	Cmd_AddCommand( "music", S_Music_f, "starting a background track" );

	push	OFFSET ??_C@_0BM@MCNPGDMO@starting?5a?5background?5track@
	push	OFFSET _S_Music_f
	push	OFFSET ??_C@_05LLDJOKNO@music@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2362 : 	Cmd_AddCommand( "soundlist", S_SoundList_f, "display loaded sounds" );

	push	OFFSET ??_C@_0BG@JLOIOPFH@display?5loaded?5sounds@
	push	OFFSET _S_SoundList_f
	push	OFFSET ??_C@_09CJIFEKFJ@soundlist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2363 : 	Cmd_AddCommand( "s_info", S_SoundInfo_f, "print sound system information" );

	push	OFFSET ??_C@_0BP@MBCFFBJN@print?5sound?5system?5information@
	push	OFFSET _S_SoundInfo_f
	push	OFFSET ??_C@_06KDCPAFOD@s_info@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2364 : 	Cmd_AddCommand( "s_fade", S_SoundFade_f, "fade all sounds then stop all" );

	push	OFFSET ??_C@_0BO@MAIPKJA@fade?5all?5sounds?5then?5stop?5all@
	push	OFFSET _S_SoundFade_f
	push	OFFSET ??_C@_06IAHHLOIA@s_fade@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2365 : 	Cmd_AddCommand( "+voicerecord", Cmd_Null_f, "start voice recording (non-implemented)" );

	push	OFFSET ??_C@_0CI@JBEKFHJI@start?5voice?5recording?5?$CInon?9impl@
	push	OFFSET _Cmd_Null_f
	push	OFFSET ??_C@_0N@LEINJAHL@?$CLvoicerecord@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2366 : 	Cmd_AddCommand( "-voicerecord", Cmd_Null_f, "stop voice recording (non-implemented)" );

	push	OFFSET ??_C@_0CH@EIODAAJG@stop?5voice?5recording?5?$CInon?9imple@
	push	OFFSET _Cmd_Null_f
	push	OFFSET ??_C@_0N@BEGIEPKG@?9voicerecord@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2367 : 	Cmd_AddCommand( "spk", S_SayReliable_f, "reliable play a specified sententce" );

	push	OFFSET ??_C@_0CE@CKJLHGOG@reliable?5play?5a?5specified?5sente@
	push	OFFSET _S_SayReliable_f
	push	OFFSET ??_C@_03HFMJPFKN@spk@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2368 : 	Cmd_AddCommand( "speak", S_Say_f, "playing a specified sententce" );

	push	OFFSET ??_C@_0BO@DILNDKOG@playing?5a?5specified?5sententce@
	push	OFFSET _S_Say_f
	push	OFFSET ??_C@_05PJLNNFLG@speak@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2369 : 
; 2370 : 	if( !SNDDMA_Init( host.hWnd ))

	mov	eax, DWORD PTR _host+34332
	push	eax
	call	_SNDDMA_Init
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@S_Init

; 2371 : 	{
; 2372 : 		Con_Printf( "Audio: sound system can't be initialized\n" );

	push	OFFSET ??_C@_0CK@INIMMNIC@Audio?3?5sound?5system?5can?8t?5be?5in@
	call	_Con_Printf
	add	esp, 4

; 2373 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@S_Init
$LN3@S_Init:

; 2374 : 	}
; 2375 : 
; 2376 : 	sndpool = Mem_AllocPool( "Sound Zone" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??S_Init@@9@9
	add	eax, 44					; 0000002cH
	push	eax
	push	OFFSET ??_C@_0DD@CGGIICNC@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@BJONLKOP@Sound?5Zone@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sndpool, eax

; 2377 : 	soundtime = 0;

	mov	DWORD PTR _soundtime, 0

; 2378 : 	paintedtime = 0;

	mov	DWORD PTR _paintedtime, 0

; 2379 : 
; 2380 : 	// clear ambient sounds
; 2381 : 	memset( ambient_sfx, 0, sizeof( ambient_sfx ));

	push	16					; 00000010H
	push	0
	push	OFFSET _ambient_sfx
	call	_memset
	add	esp, 12					; 0000000cH

; 2382 : 
; 2383 : 	MIX_InitAllPaintbuffers ();

	call	_MIX_InitAllPaintbuffers

; 2384 : 	SX_Init ();

	call	_SX_Init

; 2385 : 	S_InitScaletable ();

	call	_S_InitScaletable

; 2386 : 	S_StopAllSounds ( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 2387 : 	S_InitSounds ();

	call	_S_InitSounds

; 2388 : 	VOX_Init ();

	call	_VOX_Init

; 2389 : 
; 2390 : 	return true;

	mov	eax, 1
$LN1@S_Init:

; 2391 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_Init	ENDP
_TEXT	ENDS
END
