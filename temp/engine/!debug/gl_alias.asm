; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_alias.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_g_posenum:DWORD
_DATA	ENDS
PUBLIC	_Mod_LoadAliasModel
PUBLIC	_R_DrawAliasModel
PUBLIC	_R_AliasInit
PUBLIC	_Mod_UnloadAliasModel
PUBLIC	_BuildTris
PUBLIC	_GL_MakeAliasModelDisplayLists
PUBLIC	_Mod_LoadAliasFrame
PUBLIC	_Mod_LoadAliasGroup
PUBLIC	_Mod_CreateSkinData
PUBLIC	_Mod_LoadSingleSkin
PUBLIC	_Mod_LoadGroupSkin
PUBLIC	_Mod_LoadAllSkins
PUBLIC	_Mod_CalcAliasBounds
PUBLIC	_R_AliasDynamicLight
PUBLIC	_R_AliasSetupLighting
PUBLIC	_R_AliasLighting
PUBLIC	_R_AliasSetRemapColors
PUBLIC	_GL_DrawAliasFrame
PUBLIC	_GL_DrawAliasShadow
PUBLIC	_R_AliasLerpMovement
PUBLIC	_R_SetupAliasFrame
PUBLIC	?__LINE__Var@?0??GL_MakeAliasModelDisplayLists@@9@9 ; `GL_MakeAliasModelDisplayLists'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_CreateSkinData@@9@9	; `Mod_CreateSkinData'::`1'::__LINE__Var
PUBLIC	??_C@_06BALNJMNP@player@			; `string'
PUBLIC	??_C@_07MAOCDBIF@DM_Skin@			; `string'
PUBLIC	??_C@_0L@IMOKENLI@?$CFs?3frame?$CFi@		; `string'
PUBLIC	??_C@_09BHFKCCCE@?$CFs?3luma?$CFi@		; `string'
PUBLIC	??_C@_09OJIFCICD@?$CFs_?$CFi?4tga@		; `string'
PUBLIC	??_C@_08PMEGOJDI@?$CFs_?$CFi_?$CFi@		; `string'
PUBLIC	??_C@_0O@DHCKNAGD@?$CFs_?$CFi_?$CFi_luma@	; `string'
PUBLIC	??_C@_0CM@FADJGGGH@Mod_LoadAliasModel?3?5Invalid?5?$CD?5o@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_LoadAliasModel@@9@9	; `Mod_LoadAliasModel'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ ; `string'
PUBLIC	??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@		; `string'
PUBLIC	??_C@_0CL@OBGJMAHN@?$FO1Error?3?$FO7?5model?5?$CFs?5has?5too?5man@ ; `string'
PUBLIC	?__LINE__Var@?0??Mod_UnloadAliasModel@@9@9	; `Mod_UnloadAliasModel'::`1'::__LINE__Var
PUBLIC	??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@		; `string'
PUBLIC	??_C@_0DF@NNOMOLBF@?$FO3Warning?3?$FO7?5R_GetAliasFrame?3?5n@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3fbf5c29
PUBLIC	__real@40000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40e00000
PUBLIC	__real@41000000
PUBLIC	__real@41800000
PUBLIC	__real@42000000
PUBLIC	__real@437f0000
PUBLIC	__real@43800000
PUBLIC	__real@43820000
PUBLIC	__real@44400000
PUBLIC	__real@45000000
PUBLIC	__real@45f00800
PUBLIC	__real@46000000
PUBLIC	__real@46040000
PUBLIC	__real@47800000
PUBLIC	__real@bf800000
PUBLIC	__real@c2800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_CopyImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_CustomPalette:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_LightToTexGamma:PROC
EXTRN	_sqrt:PROC
EXTRN	_anglemod:PROC
EXTRN	_VectorCompareEpsilon:PROC
EXTRN	_ClearBounds:PROC
EXTRN	_AddPointToBounds:PROC
EXTRN	_AngleQuaternion:PROC
EXTRN	_QuaternionAngle:PROC
EXTRN	_QuaternionSlerp:PROC
EXTRN	_Matrix3x4_VectorTransform:PROC
EXTRN	_Matrix4x4_VectorIRotate:PROC
EXTRN	_Matrix4x4_CreateFromEntity:PROC
EXTRN	_Mod_AliasExtradata:PROC
EXTRN	_CL_TraceLine:PROC
EXTRN	_CL_GetRemapInfoForEntity:PROC
EXTRN	_CL_AllocRemapInfo:PROC
EXTRN	_CL_UpdateRemapInfo:PROC
EXTRN	_PM_TraceSurface:PROC
EXTRN	_GL_CleanUpTextureUnits:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_MultiTexCoord2f:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_R_CullModel:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_LoadTextureFromBuffer:PROC
EXTRN	_GL_FreeTexture:PROC
EXTRN	_R_LightVec:PROC
EXTRN	_R_LoadIdentity:PROC
EXTRN	_R_RotateForEntity:PROC
EXTRN	_pfnPlayerInfo:PROC
EXTRN	_GL_Support:PROC
EXTRN	_TriBegin:PROC
EXTRN	_TriVertex3fv:PROC
EXTRN	_TriColor4f:PROC
EXTRN	_TriBrightness:PROC
EXTRN	_TriRenderMode:PROC
EXTRN	_TriEnd:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host:BYTE
EXTRN	_boxpnt:BYTE
EXTRN	_m_bytenormals:BYTE
EXTRN	_loadmodel:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_r_stats:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_cl_dlights:BYTE
EXTRN	_glState:BYTE
EXTRN	_r_fullbright:DWORD
EXTRN	_r_drawentities:DWORD
EXTRN	_r_dynamic:DWORD
EXTRN	_r_lightmap:DWORD
EXTRN	_r_shadows:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_g_alias DB	060H DUP (?)
_m_fDoRemap DD	01H DUP (?)
_m_pAliasHeader DD 01H DUP (?)
_g_poseverts DD	0100H DUP (?)
_g_triangles DB	010000H DUP (?)
_g_stverts DB	06020H DUP (?)
_g_used	DD	02008H DUP (?)
_g_commands DD	02008H DUP (?)
_g_numcommands DD 01H DUP (?)
_g_vertexorder DD 02000H DUP (?)
_g_numorder DD	01H DUP (?)
_g_stripverts DD 080H DUP (?)
_g_striptris DD	080H DUP (?)
_g_stripcount DD 01H DUP (?)
?skin@?1??Mod_CreateSkinData@@9@9 DB 024H DUP (?)	; `Mod_CreateSkinData'::`2'::skin
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2800000
CONST	SEGMENT
__real@c2800000 DD 0c2800000r			; -64
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@46040000
CONST	SEGMENT
__real@46040000 DD 046040000r			; 8448
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@45f00800
CONST	SEGMENT
__real@45f00800 DD 045f00800r			; 7681
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@44400000
CONST	SEGMENT
__real@44400000 DD 044400000r			; 768
CONST	ENDS
;	COMDAT __real@43820000
CONST	SEGMENT
__real@43820000 DD 043820000r			; 260
CONST	ENDS
;	COMDAT __real@43800000
CONST	SEGMENT
__real@43800000 DD 043800000r			; 256
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fbf5c29
CONST	SEGMENT
__real@3fbf5c29 DD 03fbf5c29r			; 1.495
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DF@NNOMOLBF@?$FO3Warning?3?$FO7?5R_GetAliasFrame?3?5n@
CONST	SEGMENT
??_C@_0DF@NNOMOLBF@?$FO3Warning?3?$FO7?5R_GetAliasFrame?3?5n@ DB '^3Warni'
	DB	'ng:^7 R_GetAliasFrame: no such frame %d (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@ DB 'mod != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_UnloadAliasModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_UnloadAliasModel@@9@9 DD 02e1H	; `Mod_UnloadAliasModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CL@OBGJMAHN@?$FO1Error?3?$FO7?5model?5?$CFs?5has?5too?5man@
CONST	SEGMENT
??_C@_0CL@OBGJMAHN@?$FO1Error?3?$FO7?5model?5?$CFs?5has?5too?5man@ DB '^1'
	DB	'Error:^7 model %s has too many vertices', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
CONST	SEGMENT
??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@ DB '^2%s^7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
CONST	SEGMENT
??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@ DB '^1E'
	DB	'rror:^7 %s has wrong version number (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_LoadAliasModel@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_LoadAliasModel@@9@9 DD 026fH	; `Mod_LoadAliasModel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CM@FADJGGGH@Mod_LoadAliasModel?3?5Invalid?5?$CD?5o@
CONST	SEGMENT
??_C@_0CM@FADJGGGH@Mod_LoadAliasModel?3?5Invalid?5?$CD?5o@ DB 'Mod_LoadAl'
	DB	'iasModel: Invalid # of skins: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DHCKNAGD@?$CFs_?$CFi_?$CFi_luma@
CONST	SEGMENT
??_C@_0O@DHCKNAGD@?$CFs_?$CFi_?$CFi_luma@ DB '%s_%i_%i_luma', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMEGOJDI@?$CFs_?$CFi_?$CFi@
CONST	SEGMENT
??_C@_08PMEGOJDI@?$CFs_?$CFi_?$CFi@ DB '%s_%i_%i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJIFCICD@?$CFs_?$CFi?4tga@
CONST	SEGMENT
??_C@_09OJIFCICD@?$CFs_?$CFi?4tga@ DB '%s_%i.tga', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BHFKCCCE@?$CFs?3luma?$CFi@
CONST	SEGMENT
??_C@_09BHFKCCCE@?$CFs?3luma?$CFi@ DB '%s:luma%i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IMOKENLI@?$CFs?3frame?$CFi@
CONST	SEGMENT
??_C@_0L@IMOKENLI@?$CFs?3frame?$CFi@ DB '%s:frame%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAOCDBIF@DM_Skin@
CONST	SEGMENT
??_C@_07MAOCDBIF@DM_Skin@ DB 'DM_Skin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BALNJMNP@player@
CONST	SEGMENT
??_C@_06BALNJMNP@player@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Mod_CreateSkinData@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Mod_CreateSkinData@@9@9 DD 01a4H	; `Mod_CreateSkinData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_alias.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_MakeAliasModelDisplayLists@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_MakeAliasModelDisplayLists@@9@9 DD 0138H ; `GL_MakeAliasModelDisplayLists'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0212H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02bcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	037fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0405H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	053eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	017ebH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0188H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0291H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0254H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	03eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0ab9H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasSetupTimings
_TEXT	SEGMENT
_R_AliasSetupTimings PROC				; COMDAT

; 1348 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1349 : 	if( RI.drawWorld )

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN2@R_AliasSet

; 1350 : 	{
; 1351 : 		// synchronize with server time
; 1352 : 		g_alias.time = cl.time;

	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR _g_alias, xmm0

; 1353 : 	}

	jmp	SHORT $LN3@R_AliasSet
$LN2@R_AliasSet:

; 1354 : 	else
; 1355 : 	{
; 1356 : 		// menu stuff
; 1357 : 		g_alias.time = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _g_alias, xmm0
$LN3@R_AliasSet:

; 1358 : 	}
; 1359 : 
; 1360 : 	m_fDoRemap = false;

	mov	DWORD PTR _m_fDoRemap, 0

; 1361 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasSetupTimings ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasDrawLightTrace
_TEXT	SEGMENT
tv134 = -84						; size = 4
_origin$1 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_AliasDrawLightTrace PROC				; COMDAT

; 1307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1308 : 	if( r_drawentities->value == 7 )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40e00000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN2@R_AliasDra

; 1309 : 	{
; 1310 : 		vec3_t	origin;
; 1311 : 
; 1312 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1313 : 		pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 1314 : 
; 1315 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 1316 : 		pglColor3f( 1, 0.5, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1317 : 		pglVertex3fv( e->origin );

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	call	DWORD PTR _pglVertex3fv

; 1318 : 		pglVertex3fv( g_alias.lightspot );

	push	OFFSET _g_alias+56
	call	DWORD PTR _pglVertex3fv

; 1319 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 1320 : 
; 1321 : 		pglBegin( GL_LINES );

	push	1
	call	DWORD PTR _pglBegin

; 1322 : 		pglColor3f( 0, 0.5, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1323 : 		VectorMA( g_alias.lightspot, -64.0f, g_alias.lightvec, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_alias[eax+32]
	addss	xmm0, DWORD PTR _g_alias[ecx+56]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _origin$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_alias[ecx+32]
	addss	xmm0, DWORD PTR _g_alias[eax+56]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _origin$1[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR __real@c2800000
	mulss	xmm0, DWORD PTR _g_alias[ecx+32]
	movss	xmm1, DWORD PTR _g_alias[eax+56]
	addss	xmm1, xmm0
	movss	DWORD PTR tv134[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _origin$1[ebp+edx], xmm0

; 1324 : 		pglVertex3fv( g_alias.lightspot );

	push	OFFSET _g_alias+56
	call	DWORD PTR _pglVertex3fv

; 1325 : 		pglVertex3fv( origin );

	lea	eax, DWORD PTR _origin$1[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 1326 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 1327 : 
; 1328 : 		pglPointSize( 5.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 1329 : 		pglColor3f( 1, 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor3f

; 1330 : 		pglBegin( GL_POINTS );

	push	0
	call	DWORD PTR _pglBegin

; 1331 : 		pglVertex3fv( g_alias.lightspot );

	push	OFFSET _g_alias+56
	call	DWORD PTR _pglVertex3fv

; 1332 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 1333 : 		pglPointSize( 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglPointSize

; 1334 : 
; 1335 : 		pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable

; 1336 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable
$LN2@R_AliasDra:

; 1337 : 	}
; 1338 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasDrawLightTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasDrawAbsBBox
_TEXT	SEGMENT
tv133 = -172						; size = 4
tv90 = -172						; size = 4
tv79 = -172						; size = 4
_i$ = -104						; size = 4
_p$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_absmin$ = 12						; size = 4
_absmax$ = 16						; size = 4
_R_AliasDrawAbsBBox PROC				; COMDAT

; 1271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1272 : 	vec3_t	p[8];
; 1273 : 	int	i;
; 1274 : 
; 1275 : 	// looks ugly, skip
; 1276 : 	if( r_drawentities->value != 5 || e == &clgame.viewent )

	mov	eax, DWORD PTR _r_drawentities
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@40a00000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@R_AliasDra
	cmp	DWORD PTR _e$[ebp], OFFSET _clgame+260432
	jne	SHORT $LN8@R_AliasDra
$LN9@R_AliasDra:

; 1277 : 		return;

	jmp	$LN1@R_AliasDra
$LN8@R_AliasDra:

; 1278 : 
; 1279 : 	// compute a full bounding box
; 1280 : 	for( i = 0; i < 8; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_AliasDra
$LN2@R_AliasDra:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_AliasDra:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN3@R_AliasDra

; 1281 : 	{
; 1282 : 		p[i][0] = ( i & 1 ) ? absmin[0] : absmax[0];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 1
	je	SHORT $LN11@R_AliasDra
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _absmin$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv79[ebp], xmm0
	jmp	SHORT $LN12@R_AliasDra
$LN11@R_AliasDra:
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _absmax$[ebp]
	movss	xmm0, DWORD PTR [eax+edx]
	movss	DWORD PTR tv79[ebp], xmm0
$LN12@R_AliasDra:
	imul	ecx, DWORD PTR _i$[ebp], 12
	lea	edx, DWORD PTR _p$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR tv79[ebp]
	movss	DWORD PTR [edx+ecx], xmm0

; 1283 : 		p[i][1] = ( i & 2 ) ? absmin[1] : absmax[1];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 2
	je	SHORT $LN13@R_AliasDra
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _absmin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN14@R_AliasDra
$LN13@R_AliasDra:
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _absmax$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv90[ebp], xmm0
$LN14@R_AliasDra:
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR tv90[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1284 : 		p[i][2] = ( i & 4 ) ? absmin[2] : absmax[2];

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 4
	je	SHORT $LN15@R_AliasDra
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _absmin$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN16@R_AliasDra
$LN15@R_AliasDra:
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _absmax$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR tv133[ebp], xmm0
$LN16@R_AliasDra:
	imul	edx, DWORD PTR _i$[ebp], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 1285 : 	}

	jmp	$LN2@R_AliasDra
$LN3@R_AliasDra:

; 1286 : 
; 1287 : 	GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 1288 : 	TriColor4f( 0.5f, 0.5f, 1.0f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	call	_TriColor4f
	add	esp, 16					; 00000010H

; 1289 : 	TriRenderMode( kRenderTransAdd );

	push	5
	call	_TriRenderMode
	add	esp, 4

; 1290 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1291 : 
; 1292 : 	TriBegin( TRI_QUADS );

	push	2
	call	_TriBegin
	add	esp, 4

; 1293 : 	for( i = 0; i < 6; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@R_AliasDra
$LN5@R_AliasDra:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@R_AliasDra:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$LN6@R_AliasDra

; 1294 : 	{
; 1295 : 		TriBrightness( g_alias.shadelight / 255.0f );

	movss	xmm0, DWORD PTR _g_alias+28
	divss	xmm0, DWORD PTR __real@437f0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_TriBrightness
	add	esp, 4

; 1296 : 		TriVertex3fv( p[boxpnt[i][0]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 1297 : 		TriVertex3fv( p[boxpnt[i][1]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 0
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 1298 : 		TriVertex3fv( p[boxpnt[i][2]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	shl	ecx, 1
	imul	edx, DWORD PTR _boxpnt[eax+ecx], 12
	lea	eax, DWORD PTR _p$[ebp+edx]
	push	eax
	call	_TriVertex3fv
	add	esp, 4

; 1299 : 		TriVertex3fv( p[boxpnt[i][3]] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, 4
	imul	edx, ecx, 3
	imul	eax, DWORD PTR _boxpnt[eax+edx], 12
	lea	ecx, DWORD PTR _p$[ebp+eax]
	push	ecx
	call	_TriVertex3fv
	add	esp, 4

; 1300 : 	}

	jmp	$LN5@R_AliasDra
$LN6@R_AliasDra:

; 1301 : 	TriEnd();

	call	_TriEnd

; 1302 : 
; 1303 : 	TriRenderMode( kRenderNormal );

	push	0
	call	_TriRenderMode
	add	esp, 4
$LN1@R_AliasDra:

; 1304 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasDrawAbsBBox ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_SetupAliasFrame
_TEXT	SEGMENT
_interval$ = -28					; size = 4
_cycle$ = -24						; size = 4
_numposes$ = -20					; size = 4
_oldframe$ = -16					; size = 4
_newframe$ = -12					; size = 4
_oldpose$ = -8						; size = 4
_newpose$ = -4						; size = 4
_e$ = 8							; size = 4
_paliashdr$ = 12					; size = 4
_R_SetupAliasFrame PROC					; COMDAT

; 1217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1218 : 	int	newpose, oldpose;
; 1219 : 	int	newframe, oldframe;
; 1220 : 	int	numposes, cycle;
; 1221 : 	float	interval;
; 1222 : 
; 1223 : 	oldframe = e->latched.prevframe;

	mov	eax, DWORD PTR _e$[ebp]
	cvttss2si ecx, DWORD PTR [eax+3208]
	mov	DWORD PTR _oldframe$[ebp], ecx

; 1224 : 	newframe = e->curstate.frame;

	mov	eax, DWORD PTR _e$[ebp]
	cvttss2si ecx, DWORD PTR [eax+960]
	mov	DWORD PTR _newframe$[ebp], ecx

; 1225 : 
; 1226 : 	if( newframe < 0 )

	cmp	DWORD PTR _newframe$[ebp], 0
	jge	SHORT $LN2@R_SetupAli

; 1227 : 	{
; 1228 : 		newframe = 0;

	mov	DWORD PTR _newframe$[ebp], 0

; 1229 : 	}

	jmp	SHORT $LN4@R_SetupAli
$LN2@R_SetupAli:

; 1230 : 	else if( newframe >= paliashdr->numframes )

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _newframe$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jl	SHORT $LN4@R_SetupAli

; 1231 : 	{
; 1232 : 		if( newframe > paliashdr->numframes )

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _newframe$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jle	SHORT $LN5@R_SetupAli

; 1233 : 			Con_Reportf( S_WARN "R_GetAliasFrame: no such frame %d (%s)\n", newframe, e->model->name );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	mov	edx, DWORD PTR _newframe$[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@NNOMOLBF@?$FO3Warning?3?$FO7?5R_GetAliasFrame?3?5n@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH
$LN5@R_SetupAli:

; 1234 : 		newframe = paliashdr->numframes - 1;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	sub	ecx, 1
	mov	DWORD PTR _newframe$[ebp], ecx
$LN4@R_SetupAli:

; 1235 : 	}
; 1236 : 
; 1237 : 	if(( oldframe >= paliashdr->numframes ) || ( oldframe < 0 ))

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _oldframe$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jge	SHORT $LN7@R_SetupAli
	cmp	DWORD PTR _oldframe$[ebp], 0
	jge	SHORT $LN6@R_SetupAli
$LN7@R_SetupAli:

; 1238 : 		oldframe = newframe;

	mov	eax, DWORD PTR _newframe$[ebp]
	mov	DWORD PTR _oldframe$[ebp], eax
$LN6@R_SetupAli:

; 1239 : 
; 1240 : 	numposes = paliashdr->frames[newframe].numposes;

	imul	eax, DWORD PTR _newframe$[ebp], 36
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1416]
	mov	DWORD PTR _numposes$[ebp], edx

; 1241 : 
; 1242 : 	if( numposes > 1 )

	cmp	DWORD PTR _numposes$[ebp], 1
	jle	$LN8@R_SetupAli

; 1243 : 	{
; 1244 : 		oldpose = newpose = paliashdr->frames[newframe].firstpose;

	imul	eax, DWORD PTR _newframe$[ebp], 36
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1412]
	mov	DWORD PTR _newpose$[ebp], edx
	mov	eax, DWORD PTR _newpose$[ebp]
	mov	DWORD PTR _oldpose$[ebp], eax

; 1245 : 		interval = 1.0f / paliashdr->frames[newframe].interval;

	imul	eax, DWORD PTR _newframe$[ebp], 36
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR [ecx+eax+1428]
	movss	DWORD PTR _interval$[ebp], xmm0

; 1246 : 		cycle = (int)(g_alias.time * interval);

	cvtss2sd xmm0, DWORD PTR _interval$[ebp]
	mulsd	xmm0, QWORD PTR _g_alias
	cvttsd2si eax, xmm0
	mov	DWORD PTR _cycle$[ebp], eax

; 1247 : 		oldpose += (cycle + 0) % numposes; // lerpframe from

	mov	eax, DWORD PTR _cycle$[ebp]
	cdq
	idiv	DWORD PTR _numposes$[ebp]
	add	edx, DWORD PTR _oldpose$[ebp]
	mov	DWORD PTR _oldpose$[ebp], edx

; 1248 : 		newpose += (cycle + 1) % numposes; // lerpframe to

	mov	eax, DWORD PTR _cycle$[ebp]
	add	eax, 1
	cdq
	idiv	DWORD PTR _numposes$[ebp]
	add	edx, DWORD PTR _newpose$[ebp]
	mov	DWORD PTR _newpose$[ebp], edx

; 1249 : 		g_alias.lerpfrac = ( g_alias.time * interval );

	cvtss2sd xmm0, DWORD PTR _interval$[ebp]
	mulsd	xmm0, QWORD PTR _g_alias
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _g_alias+88, xmm0

; 1250 : 		g_alias.lerpfrac -= (int)g_alias.lerpfrac;

	cvttss2si eax, DWORD PTR _g_alias+88
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _g_alias+88
	subss	xmm1, xmm0
	movss	DWORD PTR _g_alias+88, xmm1

; 1251 : 	}

	jmp	SHORT $LN9@R_SetupAli
$LN8@R_SetupAli:

; 1252 : 	else
; 1253 : 	{
; 1254 : 		oldpose = paliashdr->frames[oldframe].firstpose;

	imul	eax, DWORD PTR _oldframe$[ebp], 36
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1412]
	mov	DWORD PTR _oldpose$[ebp], edx

; 1255 : 		newpose = paliashdr->frames[newframe].firstpose;

	imul	eax, DWORD PTR _newframe$[ebp], 36
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1412]
	mov	DWORD PTR _newpose$[ebp], edx
$LN9@R_SetupAli:

; 1256 : 	}
; 1257 : 
; 1258 : 	g_alias.oldpose = oldpose;

	mov	eax, DWORD PTR _oldpose$[ebp]
	mov	DWORD PTR _g_alias+80, eax

; 1259 : 	g_alias.newpose = newpose;

	mov	eax, DWORD PTR _newpose$[ebp]
	mov	DWORD PTR _g_alias+84, eax

; 1260 : 
; 1261 : 	GL_DrawAliasFrame( paliashdr );

	mov	eax, DWORD PTR _paliashdr$[ebp]
	push	eax
	call	_GL_DrawAliasFrame
	add	esp, 4

; 1262 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetupAliasFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasLerpMovement
_TEXT	SEGMENT
tv88 = -128						; size = 4
tv172 = -124						; size = 4
tv87 = -124						; size = 4
_q2$1 = -56						; size = 16
_q1$2 = -40						; size = 16
_q$3 = -24						; size = 16
_f$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_AliasLerpMovement PROC				; COMDAT

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1175 : 	float	f = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _f$[ebp], xmm0

; 1176 : 
; 1177 : 	// don't do it if the goalstarttime hasn't updated in a while.
; 1178 : 	// NOTE: Because we need to interpolate multiplayer characters, the interpolation time limit
; 1179 : 	// was increased to 1.0 s., which is 2x the max lag we are accounting for.
; 1180 : 	if( g_alias.interpolate && ( g_alias.time < e->curstate.animtime + 1.0f ) && ( e->curstate.animtime != e->latched.prevanimtime ))

	cmp	DWORD PTR _g_alias+20, 0
	je	SHORT $LN2@R_AliasLer
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	addss	xmm0, DWORD PTR __real@3f800000
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _g_alias
	jbe	SHORT $LN2@R_AliasLer
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [eax+1004]
	ucomiss	xmm0, DWORD PTR [ecx+3168]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@R_AliasLer

; 1181 : 		f = ( g_alias.time - e->curstate.animtime ) / ( e->curstate.animtime - e->latched.prevanimtime );

	mov	eax, DWORD PTR _e$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+1004]
	movsd	xmm1, QWORD PTR _g_alias
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [ecx+1004]
	subss	xmm0, DWORD PTR [edx+3168]
	cvtss2sd xmm0, xmm0
	divsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	movss	DWORD PTR _f$[ebp], xmm0
$LN2@R_AliasLer:

; 1182 : 
; 1183 : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN3@R_AliasLer

; 1184 : 		f = f + 1.0f;

	movss	xmm0, DWORD PTR _f$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _f$[ebp], xmm0
$LN3@R_AliasLer:

; 1185 : 
; 1186 : 	g_alias.lerpfrac = bound( 0.0f, f, 1.0f );

	movss	xmm0, DWORD PTR _f$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN12@R_AliasLer
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _f$[ebp]
	jbe	SHORT $LN10@R_AliasLer
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN11@R_AliasLer
$LN10@R_AliasLer:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv87[ebp], xmm0
$LN11@R_AliasLer:
	movss	xmm0, DWORD PTR tv87[ebp]
	movss	DWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN13@R_AliasLer
$LN12@R_AliasLer:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv88[ebp], xmm0
$LN13@R_AliasLer:
	movss	xmm0, DWORD PTR tv88[ebp]
	movss	DWORD PTR _g_alias+88, xmm0

; 1187 : 
; 1188 : 	if( e->player || e->curstate.movetype != MOVETYPE_STEP )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN5@R_AliasLer
	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+1000], 4
	je	SHORT $LN4@R_AliasLer
$LN5@R_AliasLer:

; 1189 : 		return; // monsters only

	jmp	$LN8@R_AliasLer
$LN4@R_AliasLer:

; 1190 : 
; 1191 : 	// Con_Printf( "%4.2f %.2f %.2f\n", f, e->curstate.animtime, g_alias.time );
; 1192 : 	VectorLerp( e->latched.prevorigin, f, e->curstate.origin, e->origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+edx+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [eax+ecx+3180]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _e$[ebp]
	movss	DWORD PTR [eax+edx+3224], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+edx+928]
	subss	xmm0, DWORD PTR [edi+eax+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+3180]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [ecx+eax+3224], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	esi, DWORD PTR _e$[ebp]
	mov	edi, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [esi+eax+928]
	subss	xmm0, DWORD PTR [edi+ecx+3180]
	mulss	xmm0, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	movss	xmm1, DWORD PTR [eax+edx+3180]
	addss	xmm1, xmm0
	movss	DWORD PTR tv172[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR [edx+ecx+3224], xmm0

; 1193 : 
; 1194 : 	if( !VectorCompareEpsilon( e->curstate.angles, e->latched.prevangles, ON_EPSILON ))

	push	ecx
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3192				; 00000c78H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_VectorCompareEpsilon
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@R_AliasLer

; 1195 : 	{
; 1196 : 		vec4_t	q, q1, q2;
; 1197 : 
; 1198 : 		AngleQuaternion( e->curstate.angles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 1199 : 		AngleQuaternion( e->latched.prevangles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 3192				; 00000c78H
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 1200 : 		QuaternionSlerp( q2, q1, f, q );

	lea	eax, DWORD PTR _q$3[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$1[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 1201 : 		QuaternionAngle( q, e->angles );

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3236				; 00000ca4H
	push	eax
	lea	ecx, DWORD PTR _q$3[ebp]
	push	ecx
	call	_QuaternionAngle
	add	esp, 8

; 1202 : 	}

	jmp	SHORT $LN7@R_AliasLer
$LN6@R_AliasLer:

; 1203 : 	else VectorCopy( e->curstate.angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+940]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [esi+edx+940]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+eax+940]
	mov	DWORD PTR [edx+ecx+3236], eax
$LN7@R_AliasLer:

; 1204 : 
; 1205 : 	// NOTE: this completely over control about angles and don't broke interpolation
; 1206 : 	if( FBitSet( e->model->flags, ALIAS_ROTATE ))

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+3300]
	mov	edx, DWORD PTR [ecx+80]
	and	edx, 8
	je	SHORT $LN8@R_AliasLer

; 1207 : 		e->angles[1] = anglemod( 100.0f * g_alias.time );

	movsd	xmm0, QWORD PTR __real@4059000000000000
	mulsd	xmm0, QWORD PTR _g_alias
	cvtsd2ss xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_anglemod
	add	esp, 4
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	fstp	DWORD PTR [ecx+eax+3236]
$LN8@R_AliasLer:

; 1208 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasLerpMovement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _GL_DrawAliasShadow
_TEXT	SEGMENT
tv188 = -124						; size = 4
_count$ = -56						; size = 4
_height$ = -52						; size = 4
_order$ = -48						; size = 4
_point$ = -44						; size = 12
_av$ = -32						; size = 12
_vec_y$ = -20						; size = 4
_vec_x$ = -16						; size = 4
_verts1$ = -12						; size = 4
_verts0$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_paliashdr$ = 8						; size = 4
_GL_DrawAliasShadow PROC				; COMDAT

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1097 : 	trivertex_t	*verts0;
; 1098 : 	trivertex_t	*verts1;
; 1099 : 	float		vec_x, vec_y;
; 1100 : 	vec3_t		av, point;
; 1101 : 	int		*order;
; 1102 : 	float		height;
; 1103 : 	int		count;
; 1104 : 
; 1105 : 	if( FBitSet( RI.currententity->curstate.effects, EF_NOSHADOW ))

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN7@GL_DrawAli

; 1106 : 		return;

	jmp	$LN12@GL_DrawAli
$LN7@GL_DrawAli:

; 1107 : 
; 1108 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN8@GL_DrawAli

; 1109 : 		pglEnable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglEnable
$LN8@GL_DrawAli:

; 1110 : 
; 1111 : 	height = g_alias.lightspot[2] + 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_alias[eax+56]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _height$[ebp], xmm0

; 1112 : 	vec_x = -g_alias.lightvec[0] * 8.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_alias[ecx+32]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vec_x$[ebp], xmm0

; 1113 : 	vec_y = -g_alias.lightvec[1] * 8.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_alias[eax+32]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR __real@41000000
	movss	DWORD PTR _vec_y$[ebp], xmm0

; 1114 : 
; 1115 : 	r_stats.c_alias_polys += paliashdr->numtris;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _r_stats+12
	add	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _r_stats+12, ecx

; 1116 : 
; 1117 : 	verts0 = verts1 = paliashdr->posedata;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _verts1$[ebp], ecx
	mov	edx, DWORD PTR _verts1$[ebp]
	mov	DWORD PTR _verts0$[ebp], edx

; 1118 : 	verts0 += g_alias.oldpose * paliashdr->poseverts;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _g_alias+80
	imul	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _verts0$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _verts0$[ebp], eax

; 1119 : 	verts1 += g_alias.newpose * paliashdr->poseverts;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _g_alias+84
	imul	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _verts1$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _verts1$[ebp], eax

; 1120 : 	order = paliashdr->commands;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _order$[ebp], ecx
$LN2@GL_DrawAli:

; 1121 : 
; 1122 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@GL_DrawAli

; 1123 : 	{
; 1124 : 		// get the vertex count and primitive type
; 1125 : 		count = *order++;

	mov	eax, DWORD PTR _order$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _order$[ebp]
	add	edx, 4
	mov	DWORD PTR _order$[ebp], edx

; 1126 : 		if( !count ) break; // done

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN9@GL_DrawAli
	jmp	$LN3@GL_DrawAli
$LN9@GL_DrawAli:

; 1127 : 
; 1128 : 		if( count < 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jge	SHORT $LN10@GL_DrawAli

; 1129 : 		{
; 1130 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 1131 : 			count = -count;

	mov	eax, DWORD PTR _count$[ebp]
	neg	eax
	mov	DWORD PTR _count$[ebp], eax

; 1132 : 		}

	jmp	SHORT $LN11@GL_DrawAli
$LN10@GL_DrawAli:

; 1133 : 		else
; 1134 : 		{
; 1135 : 			pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN11@GL_DrawAli:

; 1136 : 		}
; 1137 : 
; 1138 : 		do
; 1139 : 		{
; 1140 : 			// texture coordinates come from the draw list
; 1141 : 			// (skipped for shadows) pglTexCoord2fv ((float *)order);
; 1142 : 			order += 2;

	mov	eax, DWORD PTR _order$[ebp]
	add	eax, 8
	mov	DWORD PTR _order$[ebp], eax

; 1143 : 
; 1144 : 			// normals and vertexes come from the frame list
; 1145 : 			VectorLerp( verts0->v, g_alias.lerpfrac, verts1->v, av );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	sub	ecx, eax
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _av$[ebp+edx], xmm0
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts0$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _av$[ebp+ecx], xmm0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cvtsi2ss xmm0, ecx
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sub	ecx, edx
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	movss	DWORD PTR tv188[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _av$[ebp+eax], xmm0

; 1146 : 			point[0] = av[0] * paliashdr->scale[0] + paliashdr->scale_origin[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _paliashdr$[ebp]
	movss	xmm0, DWORD PTR _av$[ebp+ecx]
	mulss	xmm0, DWORD PTR [edx+eax+8]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _paliashdr$[ebp]
	addss	xmm0, DWORD PTR [edx+ecx+20]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 1147 : 			point[1] = av[1] * paliashdr->scale[1] + paliashdr->scale_origin[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _paliashdr$[ebp]
	movss	xmm0, DWORD PTR _av$[ebp+eax]
	mulss	xmm0, DWORD PTR [edx+ecx+8]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+20]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 1148 : 			point[2] = av[2] * paliashdr->scale[2] + paliashdr->scale_origin[2];

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _paliashdr$[ebp]
	movss	xmm0, DWORD PTR _av$[ebp+eax]
	mulss	xmm0, DWORD PTR [edx+ecx+8]
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _paliashdr$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax+20]
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _point$[ebp+edx], xmm0

; 1149 : 			Matrix3x4_VectorTransform( RI.objectMatrix, point, av );

	lea	eax, DWORD PTR _av$[ebp]
	push	eax
	lea	ecx, DWORD PTR _point$[ebp]
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix3x4_VectorTransform
	add	esp, 12					; 0000000cH

; 1150 : 
; 1151 : 			point[0] = av[0] - (vec_x * ( av[2] - g_alias.lightspot[2] ));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _av$[ebp+edx]
	subss	xmm0, DWORD PTR _g_alias[eax+56]
	mulss	xmm0, DWORD PTR _vec_x$[ebp]
	movss	xmm1, DWORD PTR _av$[ebp+ecx]
	subss	xmm1, xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _point$[ebp+edx], xmm1

; 1152 : 			point[1] = av[1] - (vec_y * ( av[2] - g_alias.lightspot[2] ));

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR _av$[ebp+ecx]
	subss	xmm0, DWORD PTR _g_alias[edx+56]
	mulss	xmm0, DWORD PTR _vec_y$[ebp]
	movss	xmm1, DWORD PTR _av$[ebp+eax]
	subss	xmm1, xmm0
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _point$[ebp+eax], xmm1

; 1153 : 			point[2] = g_alias.lightspot[2] + 1.0f;

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_alias[eax+56]
	addss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _point$[ebp+ecx], xmm0

; 1154 : 
; 1155 : 			pglVertex3fv( point );

	lea	eax, DWORD PTR _point$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 1156 : 			verts0++, verts1++;

	mov	eax, DWORD PTR _verts0$[ebp]
	add	eax, 4
	mov	DWORD PTR _verts0$[ebp], eax
	mov	ecx, DWORD PTR _verts1$[ebp]
	add	ecx, 4
	mov	DWORD PTR _verts1$[ebp], ecx

; 1157 : 
; 1158 : 		} while( --count );

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	jne	$LN11@GL_DrawAli

; 1159 : 
; 1160 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 1161 : 	}	

	jmp	$LN2@GL_DrawAli
$LN3@GL_DrawAli:

; 1162 : 
; 1163 : 	if( glState.stencilEnabled )

	cmp	DWORD PTR _glState+568, 0
	je	SHORT $LN12@GL_DrawAli

; 1164 : 		pglDisable( GL_STENCIL_TEST );

	push	2960					; 00000b90H
	call	DWORD PTR _pglDisable
$LN12@GL_DrawAli:

; 1165 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_DrawAliasShadow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _GL_DrawAliasFrame
_TEXT	SEGMENT
tv320 = -120						; size = 4
tv209 = -120						; size = 4
_ilength$1 = -52					; size = 4
_count$ = -48						; size = 4
_order$ = -44						; size = 4
_norm$ = -40						; size = 12
_vert$ = -28						; size = 12
_verts1$ = -16						; size = 4
_verts0$ = -12						; size = 4
_lv_tmp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_paliashdr$ = 8						; size = 4
_GL_DrawAliasFrame PROC					; COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1035 : 	float 		lv_tmp;
; 1036 : 	trivertex_t	*verts0;
; 1037 : 	trivertex_t	*verts1;
; 1038 : 	vec3_t		vert, norm;
; 1039 : 	int		*order;
; 1040 : 	int		count;
; 1041 : 
; 1042 : 	verts0 = verts1 = paliashdr->posedata;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _verts1$[ebp], ecx
	mov	edx, DWORD PTR _verts1$[ebp]
	mov	DWORD PTR _verts0$[ebp], edx

; 1043 : 	verts0 += g_alias.oldpose * paliashdr->poseverts;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _g_alias+80
	imul	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _verts0$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _verts0$[ebp], eax

; 1044 : 	verts1 += g_alias.newpose * paliashdr->poseverts;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR _g_alias+84
	imul	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _verts1$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _verts1$[ebp], eax

; 1045 : 	order = paliashdr->commands;

	mov	eax, DWORD PTR _paliashdr$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	DWORD PTR _order$[ebp], ecx
$LN2@GL_DrawAli:

; 1046 : 
; 1047 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@GL_DrawAli

; 1048 : 	{
; 1049 : 		// get the vertex count and primitive type
; 1050 : 		count = *order++;

	mov	eax, DWORD PTR _order$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _count$[ebp], ecx
	mov	edx, DWORD PTR _order$[ebp]
	add	edx, 4
	mov	DWORD PTR _order$[ebp], edx

; 1051 : 		if( !count ) break; // done

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN7@GL_DrawAli
	jmp	$LN3@GL_DrawAli
$LN7@GL_DrawAli:

; 1052 : 
; 1053 : 		if( count < 0 )

	cmp	DWORD PTR _count$[ebp], 0
	jge	SHORT $LN8@GL_DrawAli

; 1054 : 		{
; 1055 : 			pglBegin( GL_TRIANGLE_FAN );

	push	6
	call	DWORD PTR _pglBegin

; 1056 : 			count = -count;

	mov	eax, DWORD PTR _count$[ebp]
	neg	eax
	mov	DWORD PTR _count$[ebp], eax

; 1057 : 		}

	jmp	SHORT $LN9@GL_DrawAli
$LN8@GL_DrawAli:

; 1058 : 		else
; 1059 : 		{
; 1060 : 			pglBegin( GL_TRIANGLE_STRIP );

	push	5
	call	DWORD PTR _pglBegin
$LN9@GL_DrawAli:

; 1061 :                     }
; 1062 : 
; 1063 : 		do
; 1064 : 		{
; 1065 : 			// texture coordinates come from the draw list
; 1066 : 			if( GL_Support( GL_ARB_MULTITEXTURE ) && glState.activeTMU > 0 )

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@GL_DrawAli
	cmp	DWORD PTR _glState+16, 0
	jle	SHORT $LN10@GL_DrawAli

; 1067 : 			{
; 1068 : 				GL_MultiTexCoord2f( GL_TEXTURE0, ((float *)order)[0], ((float *)order)[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	push	0
	call	_GL_MultiTexCoord2f
	add	esp, 12					; 0000000cH

; 1069 : 				GL_MultiTexCoord2f( GL_TEXTURE1, ((float *)order)[0], ((float *)order)[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	_GL_MultiTexCoord2f
	add	esp, 12					; 0000000cH

; 1070 : 			}

	jmp	SHORT $LN11@GL_DrawAli
$LN10@GL_DrawAli:

; 1071 : 			else
; 1072 : 			{
; 1073 : 				pglTexCoord2f( ((float *)order)[0], ((float *)order)[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _order$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f
$LN11@GL_DrawAli:

; 1074 : 			}
; 1075 : 			order += 2;

	mov	eax, DWORD PTR _order$[ebp]
	add	eax, 8
	mov	DWORD PTR _order$[ebp], eax

; 1076 : 
; 1077 : 			VectorLerp( m_bytenormals[verts0->lightnormalindex], g_alias.lerpfrac, m_bytenormals[verts1->lightnormalindex], norm );

	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	imul	edx, ecx, 12
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _verts1$[ebp]
	movzx	eax, BYTE PTR [eax+3]
	imul	eax, eax, 12
	mov	esi, 4
	imul	esi, esi, 0
	mov	edi, DWORD PTR _verts0$[ebp]
	movzx	edi, BYTE PTR [edi+3]
	imul	edi, edi, 12
	mov	ebx, 4
	imul	ebx, ebx, 0
	movss	xmm0, DWORD PTR _m_bytenormals[eax+esi]
	subss	xmm0, DWORD PTR _m_bytenormals[edi+ebx]
	mulss	xmm0, DWORD PTR _g_alias+88
	addss	xmm0, DWORD PTR _m_bytenormals[edx+ecx]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _norm$[ebp+edx], xmm0
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	imul	edx, ecx, 12
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [ecx+3]
	imul	ecx, ecx, 12
	mov	esi, 4
	shl	esi, 0
	mov	edi, DWORD PTR _verts0$[ebp]
	movzx	edi, BYTE PTR [edi+3]
	imul	edi, edi, 12
	mov	ebx, 4
	shl	ebx, 0
	movss	xmm0, DWORD PTR _m_bytenormals[ecx+esi]
	subss	xmm0, DWORD PTR _m_bytenormals[edi+ebx]
	mulss	xmm0, DWORD PTR _g_alias+88
	addss	xmm0, DWORD PTR _m_bytenormals[edx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _norm$[ebp+edx], xmm0
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	imul	edx, ecx, 12
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [ecx+3]
	imul	ecx, ecx, 12
	mov	esi, 4
	shl	esi, 1
	mov	edi, DWORD PTR _verts0$[ebp]
	movzx	edi, BYTE PTR [edi+3]
	imul	edi, edi, 12
	mov	ebx, 4
	shl	ebx, 1
	movss	xmm0, DWORD PTR _m_bytenormals[ecx+esi]
	subss	xmm0, DWORD PTR _m_bytenormals[edi+ebx]
	mulss	xmm0, DWORD PTR _g_alias+88
	movss	xmm1, DWORD PTR _m_bytenormals[edx+eax]
	addss	xmm1, xmm0
	movss	DWORD PTR tv209[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv209[ebp]
	movss	DWORD PTR _norm$[ebp+edx], xmm0

; 1078 : 			VectorNormalize( norm );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _norm$[ebp+ecx]
	mulss	xmm0, DWORD PTR _norm$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _norm$[ebp+ecx]
	mulss	xmm1, DWORD PTR _norm$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _norm$[ebp+eax]
	mulss	xmm1, DWORD PTR _norm$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@GL_DrawAli
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN12@GL_DrawAli:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _norm$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _norm$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _norm$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _norm$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _norm$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _norm$[ebp+ecx], xmm0

; 1079 : 			R_AliasLighting( &lv_tmp, norm );

	lea	eax, DWORD PTR _norm$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lv_tmp$[ebp]
	push	ecx
	call	_R_AliasLighting
	add	esp, 8

; 1080 : 			pglColor4f( g_alias.lightcolor[0] * lv_tmp, g_alias.lightcolor[1] * lv_tmp, g_alias.lightcolor[2] * lv_tmp, tr.blend );

	push	ecx
	movss	xmm0, DWORD PTR _tr+87592
	movss	DWORD PTR [esp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_alias[eax+68]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _g_alias[ecx+68]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _g_alias[eax+68]
	mulss	xmm0, DWORD PTR _lv_tmp$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1081 : 			VectorLerp( verts0->v, g_alias.lerpfrac, verts1->v, vert );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	sub	ecx, eax
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vert$[ebp+edx], xmm0
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts0$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _verts0$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	sub	edx, eax
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vert$[ebp+ecx], xmm0
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cvtsi2ss xmm0, ecx
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts1$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _verts0$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sub	ecx, edx
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _g_alias+88
	addss	xmm0, xmm1
	movss	DWORD PTR tv320[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv320[ebp]
	movss	DWORD PTR _vert$[ebp+eax], xmm0

; 1082 : 			pglVertex3fv( vert );

	lea	eax, DWORD PTR _vert$[ebp]
	push	eax
	call	DWORD PTR _pglVertex3fv

; 1083 : 			verts0++, verts1++;

	mov	eax, DWORD PTR _verts0$[ebp]
	add	eax, 4
	mov	DWORD PTR _verts0$[ebp], eax
	mov	ecx, DWORD PTR _verts1$[ebp]
	add	ecx, 4
	mov	DWORD PTR _verts1$[ebp], ecx

; 1084 : 		} while( --count );

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
	jne	$LN9@GL_DrawAli

; 1085 : 
; 1086 : 		pglEnd();

	call	DWORD PTR _pglEnd

; 1087 : 	}

	jmp	$LN2@GL_DrawAli
$LN3@GL_DrawAli:

; 1088 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_DrawAliasFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasSetRemapColors
_TEXT	SEGMENT
_newTop$ = 8						; size = 4
_newBottom$ = 12					; size = 4
_R_AliasSetRemapColors PROC				; COMDAT

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1019 : 	CL_AllocRemapInfo( newTop, newBottom );

	mov	eax, DWORD PTR _newBottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newTop$[ebp]
	push	ecx
	call	_CL_AllocRemapInfo
	add	esp, 8

; 1020 : 
; 1021 : 	if( CL_GetRemapInfoForEntity( RI.currententity ))

	mov	eax, DWORD PTR _RI+28
	push	eax
	call	_CL_GetRemapInfoForEntity
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@R_AliasSet

; 1022 : 	{
; 1023 : 		CL_UpdateRemapInfo( newTop, newBottom );

	mov	eax, DWORD PTR _newBottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newTop$[ebp]
	push	ecx
	call	_CL_UpdateRemapInfo
	add	esp, 8

; 1024 : 		m_fDoRemap = true;

	mov	DWORD PTR _m_fDoRemap, 1
$LN1@R_AliasSet:

; 1025 : 	}
; 1026 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasSetRemapColors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasLighting
_TEXT	SEGMENT
tv137 = -80						; size = 4
tv135 = -80						; size = 4
_lightcos$ = -12					; size = 4
_r$ = -8						; size = 4
_illum$ = -4						; size = 4
_lv$ = 8						; size = 4
_normal$ = 12						; size = 4
_R_AliasLighting PROC					; COMDAT

; 980  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 981  : 	float 	illum = g_alias.ambientlight;

	movss	xmm0, DWORD PTR _g_alias+24
	movss	DWORD PTR _illum$[ebp], xmm0

; 982  : 	float	r, lightcos;
; 983  : 
; 984  : 	lightcos = DotProduct( normal, g_alias.lightvec_local ); // -1 colinear, 1 opposite

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx]
	mulss	xmm0, DWORD PTR _g_alias[eax+44]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _g_alias[ecx+44]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _normal$[ebp]
	movss	xmm1, DWORD PTR [edx+eax]
	mulss	xmm1, DWORD PTR _g_alias[ecx+44]
	addss	xmm0, xmm1
	movss	DWORD PTR _lightcos$[ebp], xmm0

; 985  : 	if( lightcos > 1.0f ) lightcos = 1.0f;

	movss	xmm0, DWORD PTR _lightcos$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	SHORT $LN2@R_AliasLig
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lightcos$[ebp], xmm0
$LN2@R_AliasLig:

; 986  : 
; 987  : 	illum += g_alias.shadelight;

	movss	xmm0, DWORD PTR _illum$[ebp]
	addss	xmm0, DWORD PTR _g_alias+28
	movss	DWORD PTR _illum$[ebp], xmm0

; 988  : 
; 989  : 	r = SHADE_LAMBERT;

	movss	xmm0, DWORD PTR __real@3fbf5c29
	movss	DWORD PTR _r$[ebp], xmm0

; 990  : 
; 991  : 	// do modified hemispherical lighting
; 992  : 	if( r <= 1.0f )

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _r$[ebp]
	jb	SHORT $LN3@R_AliasLig

; 993  : 	{
; 994  : 		r += 1.0f;

	movss	xmm0, DWORD PTR _r$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _r$[ebp], xmm0

; 995  : 		lightcos = (( r - 1.0f ) - lightcos) / r;

	movss	xmm0, DWORD PTR _r$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _lightcos$[ebp]
	divss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _lightcos$[ebp], xmm0

; 996  : 		if( lightcos > 0.0f ) 

	movss	xmm0, DWORD PTR _lightcos$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@R_AliasLig

; 997  : 			illum += g_alias.shadelight * lightcos; 

	movss	xmm0, DWORD PTR _g_alias+28
	mulss	xmm0, DWORD PTR _lightcos$[ebp]
	addss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0
$LN5@R_AliasLig:

; 998  : 	}

	jmp	SHORT $LN6@R_AliasLig
$LN3@R_AliasLig:

; 999  : 	else
; 1000 : 	{
; 1001 : 		lightcos = (lightcos + ( r - 1.0f )) / r;

	movss	xmm0, DWORD PTR _r$[ebp]
	subss	xmm0, DWORD PTR __real@3f800000
	addss	xmm0, DWORD PTR _lightcos$[ebp]
	divss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR _lightcos$[ebp], xmm0

; 1002 : 		if( lightcos > 0.0f )

	movss	xmm0, DWORD PTR _lightcos$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@R_AliasLig

; 1003 : 			illum -= g_alias.shadelight * lightcos; 

	movss	xmm0, DWORD PTR _g_alias+28
	mulss	xmm0, DWORD PTR _lightcos$[ebp]
	movss	xmm1, DWORD PTR _illum$[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _illum$[ebp], xmm1
$LN6@R_AliasLig:

; 1004 : 	}
; 1005 : 
; 1006 : 	illum = Q_max( illum, 0.0f );

	movss	xmm0, DWORD PTR _illum$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN8@R_AliasLig
	movss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN9@R_AliasLig
$LN8@R_AliasLig:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv135[ebp], xmm0
$LN9@R_AliasLig:
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0

; 1007 : 	illum = Q_min( illum, 255.0f );

	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR _illum$[ebp]
	jbe	SHORT $LN10@R_AliasLig
	movss	xmm0, DWORD PTR _illum$[ebp]
	movss	DWORD PTR tv137[ebp], xmm0
	jmp	SHORT $LN11@R_AliasLig
$LN10@R_AliasLig:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv137[ebp], xmm0
$LN11@R_AliasLig:
	movss	xmm0, DWORD PTR tv137[ebp]
	movss	DWORD PTR _illum$[ebp], xmm0

; 1008 : 	*lv = illum * (1.0f / 255.0f);

	movss	xmm0, DWORD PTR _illum$[ebp]
	mulss	xmm0, DWORD PTR __real@3b808081
	mov	eax, DWORD PTR _lv$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1009 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasSetupLighting
_TEXT	SEGMENT
_ilength$1 = -4						; size = 4
_plight$ = 8						; size = 4
_R_AliasSetupLighting PROC				; COMDAT

; 959  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 960  : 	if( !m_pAliasHeader || !plight )

	cmp	DWORD PTR _m_pAliasHeader, 0
	je	SHORT $LN3@R_AliasSet
	cmp	DWORD PTR _plight$[ebp], 0
	jne	SHORT $LN2@R_AliasSet
$LN3@R_AliasSet:

; 961  : 		return;

	jmp	$LN1@R_AliasSet
$LN2@R_AliasSet:

; 962  : 
; 963  : 	g_alias.ambientlight = plight->ambientlight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	movss	DWORD PTR _g_alias+24, xmm0

; 964  : 	g_alias.shadelight = plight->shadelight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR _g_alias+28, xmm0

; 965  : 	VectorCopy( plight->plightvec, g_alias.lightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	imul	edx, edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_alias[edx+32], eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_alias[edx+32], eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _g_alias[edx+32], eax

; 966  : 	VectorCopy( plight->color, g_alias.lightcolor );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _g_alias[eax+68], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	mov	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR _g_alias[eax+68], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _g_alias[ecx+68], eax

; 967  : 
; 968  : 	// transform back to local space
; 969  : 	Matrix4x4_VectorIRotate( RI.objectMatrix, g_alias.lightvec, g_alias.lightvec_local );

	push	OFFSET _g_alias+44
	push	OFFSET _g_alias+32
	push	OFFSET _RI+456
	call	_Matrix4x4_VectorIRotate
	add	esp, 12					; 0000000cH

; 970  : 	VectorNormalize( g_alias.lightvec_local );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _g_alias[ecx+44]
	mulss	xmm0, DWORD PTR _g_alias[eax+44]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _g_alias[ecx+44]
	mulss	xmm1, DWORD PTR _g_alias[edx+44]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _g_alias[eax+44]
	mulss	xmm1, DWORD PTR _g_alias[ecx+44]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$1[ebp]
	movss	xmm0, DWORD PTR _ilength$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@R_AliasSet
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$1[ebp]
	movss	DWORD PTR _ilength$1[ebp], xmm0
$LN4@R_AliasSet:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_alias[ecx+44]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _g_alias[eax+44], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_alias[eax+44]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _g_alias[ecx+44], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_alias[eax+44]
	mulss	xmm0, DWORD PTR _ilength$1[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _g_alias[ecx+44], xmm0
$LN1@R_AliasSet:

; 971  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasSetupLighting ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasDynamicLight
_TEXT	SEGMENT
tv575 = -480						; size = 4
tv1367 = -476						; size = 8
tv1363 = -468						; size = 4
tv1400 = -464						; size = 8
tv1358 = -464						; size = 8
tv1396 = -456						; size = 4
tv1354 = -456						; size = 4
tv1348 = -452						; size = 8
tv1290 = -452						; size = 8
tv1260 = -452						; size = 8
tv1230 = -452						; size = 8
tv1200 = -452						; size = 8
tv841 = -452						; size = 4
tv582 = -452						; size = 4
tv837 = -448						; size = 4
tv581 = -448						; size = 4
tv297 = -448						; size = 4
tv283 = -448						; size = 4
tv269 = -448						; size = 4
tv1344 = -444						; size = 4
tv1287 = -444						; size = 4
tv1257 = -444						; size = 4
tv1227 = -444						; size = 4
tv1197 = -444						; size = 4
tv819 = -444						; size = 4
tv776 = -444						; size = 4
tv719 = -444						; size = 4
tv698 = -444						; size = 4
tv683 = -444						; size = 4
tv631 = -444						; size = 4
tv599 = -444						; size = 4
tv578 = -444						; size = 4
tv339 = -444						; size = 4
tv318 = -444						; size = 4
tv296 = -444						; size = 4
tv282 = -444						; size = 4
tv268 = -444						; size = 4
tv258 = -444						; size = 4
tv172 = -444						; size = 4
$T1 = -440						; size = 16
$T2 = -424						; size = 16
$T3 = -408						; size = 16
$T4 = -392						; size = 16
$T5 = -376						; size = 16
$T6 = -360						; size = 68
_ilength$7 = -228					; size = 4
_ilength$8 = -224					; size = 4
_grad$9 = -220						; size = 16
_gcolor$10 = -204					; size = 16
_trace$11 = -188					; size = 68
_psurf$12 = -120					; size = 4
_dl$ = -116						; size = 4
_lnum$ = -112						; size = 4
_light$ = -108						; size = 16
_total$ = -92						; size = 4
_radius$ = -88						; size = 4
_add$ = -84						; size = 4
_finalLight$ = -80					; size = 12
_dist$ = -68						; size = 12
_origin$ = -56						; size = 12
_vecEnd$ = -44						; size = 12
_vecSrc$ = -32						; size = 12
_lightDir$ = -20					; size = 12
_mv$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_ent$ = 8						; size = 4
_plight$ = 12						; size = 4
_R_AliasDynamicLight PROC				; COMDAT

; 781  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 782  : 	movevars_t	*mv = &clgame.movevars;

	mov	DWORD PTR _mv$[ebp], OFFSET _clgame+1024

; 783  : 	vec3_t		lightDir, vecSrc, vecEnd;
; 784  : 	vec3_t		origin, dist, finalLight;
; 785  : 	float		add, radius, total;
; 786  : 	colorVec		light;
; 787  : 	uint		lnum;
; 788  : 	dlight_t		*dl;
; 789  : 
; 790  : 	if( !plight || !ent )

	cmp	DWORD PTR _plight$[ebp], 0
	je	SHORT $LN6@R_AliasDyn
	cmp	DWORD PTR _ent$[ebp], 0
	jne	SHORT $LN5@R_AliasDyn
$LN6@R_AliasDyn:

; 791  : 		return;

	jmp	$LN1@R_AliasDyn
$LN5@R_AliasDyn:

; 792  : 
; 793  : 	if( !RI.drawWorld || r_fullbright->value || FBitSet( ent->curstate.effects, EF_FULLBRIGHT ))

	cmp	DWORD PTR _RI+4, 0
	je	SHORT $LN8@R_AliasDyn
	mov	eax, DWORD PTR _r_fullbright
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@R_AliasDyn
	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 134217728				; 08000000H
	je	$LN7@R_AliasDyn
$LN8@R_AliasDyn:

; 794  : 	{
; 795  : 		plight->shadelight = 0;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax+4], 0

; 796  : 		plight->ambientlight = 192;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax], 192			; 000000c0H

; 797  : 
; 798  : 		VectorSet( plight->plightvec, 0.0f, 0.0f, -1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [ecx+eax], xmm0

; 799  : 		VectorSet( plight->color, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax+8], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx+8], xmm0

; 800  : 		return;

	jmp	$LN1@R_AliasDyn
$LN7@R_AliasDyn:

; 801  : 	}
; 802  : 
; 803  : 	// determine plane to get lightvalues from: ceil or floor
; 804  : 	if( FBitSet( ent->curstate.effects, EF_INVLIGHT ))

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [eax+972]
	and	ecx, 16					; 00000010H
	je	SHORT $LN9@R_AliasDyn

; 805  : 		VectorSet( lightDir, 0.0f, 0.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	jmp	SHORT $LN10@R_AliasDyn
$LN9@R_AliasDyn:

; 806  : 	else VectorSet( lightDir, 0.0f, 0.0f, -1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
$LN10@R_AliasDyn:

; 807  : 
; 808  : 	VectorCopy( ent->origin, origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3224]
	mov	DWORD PTR _origin$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3224]
	mov	DWORD PTR _origin$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _ent$[ebp]
	mov	eax, DWORD PTR [edx+eax+3224]
	mov	DWORD PTR _origin$[ebp+ecx], eax

; 809  : 
; 810  : 	VectorSet( vecSrc, origin[0], origin[1], origin[2] - lightDir[2] * 8.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@41000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	movss	DWORD PTR tv172[ebp], xmm1
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv172[ebp]
	movss	DWORD PTR _vecSrc$[ebp+edx], xmm0

; 811  : 	light.r = light.g = light.b = light.a = 0;

	mov	DWORD PTR _light$[ebp+12], 0
	mov	eax, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR _light$[ebp+8], eax
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR _light$[ebp+4], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR _light$[ebp], edx

; 812  : 
; 813  : 	if(( mv->skycolor_r + mv->skycolor_g + mv->skycolor_b ) != 0 )

	mov	eax, DWORD PTR _mv$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	addss	xmm0, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _mv$[ebp]
	addss	xmm0, DWORD PTR [edx+116]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN16@R_AliasDyn

; 814  : 	{
; 815  : 		msurface_t	*psurf = NULL;

	mov	DWORD PTR _psurf$12[ebp], 0

; 816  : 		pmtrace_t		trace;
; 817  : 
; 818  : 		if( FBitSet( host.features, ENGINE_WRITE_LARGE_COORD ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 1
	je	$LN12@R_AliasDyn

; 819  : 		{
; 820  : 			vecEnd[0] = origin[0] - mv->skyvec_x * 65536.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm1

; 821  : 			vecEnd[1] = origin[1] - mv->skyvec_y * 65536.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 822  : 			vecEnd[2] = origin[2] - mv->skyvec_z * 65536.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR __real@47800000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 823  : 		}

	jmp	$LN13@R_AliasDyn
$LN12@R_AliasDyn:

; 824  : 		else
; 825  : 		{
; 826  : 			vecEnd[0] = origin[0] - mv->skyvec_x * 8192.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+120]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+ecx]
	subss	xmm1, xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm1

; 827  : 			vecEnd[1] = origin[1] - mv->skyvec_y * 8192.0f;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+124]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1

; 828  : 			vecEnd[2] = origin[2] - mv->skyvec_z * 8192.0f;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [ecx+128]
	mulss	xmm0, DWORD PTR __real@46000000
	movss	xmm1, DWORD PTR _origin$[ebp+eax]
	subss	xmm1, xmm0
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm1
$LN13@R_AliasDyn:

; 829  : 		}
; 830  : 
; 831  : 		trace = CL_TraceLine( vecSrc, vecEnd, PM_STUDIO_IGNORE );

	push	1
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	_CL_TraceLine
	add	esp, 16					; 00000010H
	mov	ecx, 17					; 00000011H
	mov	esi, eax
	lea	edi, DWORD PTR _trace$11[ebp]
	rep movsd

; 832  : 		if( trace.ent > 0 ) psurf = PM_TraceSurface( &clgame.pmove->physents[trace.ent], vecSrc, vecEnd );

	cmp	DWORD PTR _trace$11[ebp+48], 0
	jle	SHORT $LN14@R_AliasDyn
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	imul	edx, DWORD PTR _trace$11[ebp+48], 224
	mov	eax, DWORD PTR _clgame+1344
	lea	ecx, DWORD PTR [eax+edx+592]
	push	ecx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psurf$12[ebp], eax
	jmp	SHORT $LN15@R_AliasDyn
$LN14@R_AliasDyn:

; 833  :  		else psurf = PM_TraceSurface( clgame.pmove->physents, vecSrc, vecEnd );

	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _clgame+1344
	add	edx, 592				; 00000250H
	push	edx
	call	_PM_TraceSurface
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psurf$12[ebp], eax
$LN15@R_AliasDyn:

; 834  :  
; 835  : 		if( psurf && FBitSet( psurf->flags, SURF_DRAWSKY ))

	cmp	DWORD PTR _psurf$12[ebp], 0
	je	$LN16@R_AliasDyn
	mov	eax, DWORD PTR _psurf$12[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 4
	je	$LN16@R_AliasDyn

; 836  : 		{
; 837  : 			VectorSet( lightDir, mv->skyvec_x, mv->skyvec_y, mv->skyvec_z );

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+120]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+124]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+128]
	movss	DWORD PTR tv258[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv258[ebp]
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0

; 838  : 
; 839  : 			light.r = LightToTexGamma( bound( 0, mv->skycolor_r, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+108]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN35@R_AliasDyn
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+108]
	jbe	SHORT $LN33@R_AliasDyn
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+108]
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN34@R_AliasDyn
$LN33@R_AliasDyn:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv268[ebp], xmm0
$LN34@R_AliasDyn:
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR tv269[ebp], xmm0
	jmp	SHORT $LN36@R_AliasDyn
$LN35@R_AliasDyn:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv269[ebp], xmm0
$LN36@R_AliasDyn:
	cvttss2si eax, DWORD PTR tv269[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp], edx

; 840  : 			light.g = LightToTexGamma( bound( 0, mv->skycolor_g, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+112]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN39@R_AliasDyn
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+112]
	jbe	SHORT $LN37@R_AliasDyn
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+112]
	movss	DWORD PTR tv282[ebp], xmm0
	jmp	SHORT $LN38@R_AliasDyn
$LN37@R_AliasDyn:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv282[ebp], xmm0
$LN38@R_AliasDyn:
	movss	xmm0, DWORD PTR tv282[ebp]
	movss	DWORD PTR tv283[ebp], xmm0
	jmp	SHORT $LN40@R_AliasDyn
$LN39@R_AliasDyn:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv283[ebp], xmm0
$LN40@R_AliasDyn:
	cvttss2si eax, DWORD PTR tv283[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp+4], edx

; 841  : 			light.b = LightToTexGamma( bound( 0, mv->skycolor_b, 255 ));

	mov	eax, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [eax+116]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN43@R_AliasDyn
	mov	ecx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR __real@437f0000
	comiss	xmm0, DWORD PTR [ecx+116]
	jbe	SHORT $LN41@R_AliasDyn
	mov	edx, DWORD PTR _mv$[ebp]
	movss	xmm0, DWORD PTR [edx+116]
	movss	DWORD PTR tv296[ebp], xmm0
	jmp	SHORT $LN42@R_AliasDyn
$LN41@R_AliasDyn:
	movss	xmm0, DWORD PTR __real@437f0000
	movss	DWORD PTR tv296[ebp], xmm0
$LN42@R_AliasDyn:
	movss	xmm0, DWORD PTR tv296[ebp]
	movss	DWORD PTR tv297[ebp], xmm0
	jmp	SHORT $LN44@R_AliasDyn
$LN43@R_AliasDyn:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv297[ebp], xmm0
$LN44@R_AliasDyn:
	cvttss2si eax, DWORD PTR tv297[ebp]
	movzx	ecx, al
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	mov	DWORD PTR _light$[ebp+8], edx
$LN16@R_AliasDyn:

; 842  : 		}
; 843  : 	}
; 844  : 
; 845  : 	if(( light.r + light.g + light.b ) == 0 )

	mov	eax, DWORD PTR _light$[ebp]
	add	eax, DWORD PTR _light$[ebp+4]
	add	eax, DWORD PTR _light$[ebp+8]
	jne	$LN19@R_AliasDyn

; 846  : 	{
; 847  : 		colorVec	gcolor;
; 848  : 		float	grad[4];
; 849  : 
; 850  : 		VectorScale( lightDir, 2048.0f, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@45000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@45000000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@45000000
	movss	DWORD PTR tv318[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv318[ebp]
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 851  : 		VectorAdd( vecEnd, vecSrc, vecEnd );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	movss	DWORD PTR tv339[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv339[ebp]
	movss	DWORD PTR _vecEnd$[ebp+edx], xmm0

; 852  : 
; 853  : 		light = R_LightVec( vecSrc, vecEnd, g_alias.lightspot, g_alias.lightvec );

	push	OFFSET _g_alias+32
	push	OFFSET _g_alias+56
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _light$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _light$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _light$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _light$[ebp+12], edx

; 854  : 
; 855  : 		if( VectorIsNull( g_alias.lightvec ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _g_alias[ecx+32]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@R_AliasDyn
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _g_alias[eax+32]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@R_AliasDyn
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _g_alias[eax+32]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN18@R_AliasDyn

; 856  : 		{
; 857  : 			vecSrc[0] -= 16.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 858  : 			vecSrc[1] -= 16.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	subss	xmm0, DWORD PTR __real@41800000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0

; 859  : 			vecEnd[0] -= 16.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@41800000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 860  : 			vecEnd[1] -= 16.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	subss	xmm0, DWORD PTR __real@41800000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 861  : 
; 862  : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 863  : 			grad[0] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1197[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1197[ebp]
	mov	ecx, DWORD PTR tv1197[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1200[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1200[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _grad$9[ebp+eax], xmm0

; 864  : 
; 865  : 			vecSrc[0] += 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	addss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 866  : 			vecEnd[0] += 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	addss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 867  : 
; 868  : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 869  : 			grad[1] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1227[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1227[ebp]
	mov	ecx, DWORD PTR tv1227[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1230[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1230[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _grad$9[ebp+edx], xmm0

; 870  : 
; 871  : 			vecSrc[1] += 32.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+eax]
	addss	xmm0, DWORD PTR __real@42000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecSrc$[ebp+ecx], xmm0

; 872  : 			vecEnd[1] += 32.0f;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+eax]
	addss	xmm0, DWORD PTR __real@42000000
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _vecEnd$[ebp+ecx], xmm0

; 873  : 
; 874  : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 875  : 			grad[2] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1257[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1257[ebp]
	mov	ecx, DWORD PTR tv1257[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1260[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1260[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _grad$9[ebp+edx], xmm0

; 876  : 
; 877  : 			vecSrc[0] -= 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecSrc$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecSrc$[ebp+eax], xmm0

; 878  : 			vecEnd[0] -= 32.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _vecEnd$[ebp+ecx]
	subss	xmm0, DWORD PTR __real@42000000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _vecEnd$[ebp+eax], xmm0

; 879  : 
; 880  : 			gcolor = R_LightVec( vecSrc, vecEnd, NULL, NULL );

	push	0
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	_R_LightVec
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _gcolor$10[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _gcolor$10[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _gcolor$10[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _gcolor$10[ebp+12], edx

; 881  : 			grad[3] = ( gcolor.r + gcolor.g + gcolor.b ) / 768.0f;

	mov	eax, DWORD PTR _gcolor$10[ebp]
	add	eax, DWORD PTR _gcolor$10[ebp+4]
	add	eax, DWORD PTR _gcolor$10[ebp+8]
	mov	DWORD PTR tv1287[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1287[ebp]
	mov	ecx, DWORD PTR tv1287[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1290[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1290[ebp]
	divss	xmm0, DWORD PTR __real@44400000
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR _grad$9[ebp+eax], xmm0

; 882  : 
; 883  : 			lightDir[0] = grad[0] - grad[1] - grad[2] + grad[3];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _grad$9[ebp+ecx]
	subss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	subss	xmm0, DWORD PTR _grad$9[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 3
	addss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 884  : 			lightDir[1] = grad[1] + grad[0] - grad[2] - grad[3];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _grad$9[ebp+eax]
	addss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 1
	subss	xmm0, DWORD PTR _grad$9[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 3
	subss	xmm0, DWORD PTR _grad$9[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0

; 885  : 			VectorNormalize( lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$8[ebp]
	movss	xmm0, DWORD PTR _ilength$8[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN20@R_AliasDyn
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$8[ebp]
	movss	DWORD PTR _ilength$8[ebp], xmm0
$LN20@R_AliasDyn:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$8[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 886  : 		}

	jmp	SHORT $LN19@R_AliasDyn
$LN18@R_AliasDyn:

; 887  : 		else
; 888  : 		{
; 889  : 			VectorCopy( g_alias.lightvec, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _g_alias[ecx+32]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _g_alias[edx+32]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _g_alias[edx+32]
	mov	DWORD PTR _lightDir$[ebp+eax], ecx
$LN19@R_AliasDyn:

; 890  : 		}
; 891  : 	}
; 892  : 
; 893  : 	VectorSet( finalLight, light.r, light.g, light.b );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv1344[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1344[ebp]
	mov	eax, DWORD PTR tv1344[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1348[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1348[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv1354[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1354[ebp]
	mov	eax, DWORD PTR tv1354[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv1358[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1358[ebp]
	movss	DWORD PTR _finalLight$[ebp+ecx], xmm0
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR tv1363[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1363[ebp]
	mov	edx, DWORD PTR tv1363[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv1367[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1367[ebp]
	movss	DWORD PTR tv575[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv575[ebp]
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0

; 894  : 	ent->cvFloorColor = light;

	mov	eax, DWORD PTR _ent$[ebp]
	add	eax, 3320				; 00000cf8H
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _light$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 895  : 
; 896  : 	total = Q_max( Q_max( light.r, light.g ), light.b );

	mov	eax, DWORD PTR _light$[ebp]
	cmp	eax, DWORD PTR _light$[ebp+4]
	jbe	SHORT $LN45@R_AliasDyn
	mov	ecx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv578[ebp], ecx
	jmp	SHORT $LN46@R_AliasDyn
$LN45@R_AliasDyn:
	mov	edx, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv578[ebp], edx
$LN46@R_AliasDyn:
	mov	eax, DWORD PTR tv578[ebp]
	cmp	eax, DWORD PTR _light$[ebp+8]
	jbe	SHORT $LN49@R_AliasDyn
	mov	ecx, DWORD PTR _light$[ebp]
	cmp	ecx, DWORD PTR _light$[ebp+4]
	jbe	SHORT $LN47@R_AliasDyn
	mov	edx, DWORD PTR _light$[ebp]
	mov	DWORD PTR tv581[ebp], edx
	jmp	SHORT $LN48@R_AliasDyn
$LN47@R_AliasDyn:
	mov	eax, DWORD PTR _light$[ebp+4]
	mov	DWORD PTR tv581[ebp], eax
$LN48@R_AliasDyn:
	mov	ecx, DWORD PTR tv581[ebp]
	mov	DWORD PTR tv582[ebp], ecx
	jmp	SHORT $LN50@R_AliasDyn
$LN49@R_AliasDyn:
	mov	edx, DWORD PTR _light$[ebp+8]
	mov	DWORD PTR tv582[ebp], edx
$LN50@R_AliasDyn:
	mov	eax, DWORD PTR tv582[ebp]
	mov	DWORD PTR tv1396[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1396[ebp]
	mov	ecx, DWORD PTR tv1396[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv1400[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv1400[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 897  : 	if( total == 0.0f ) total = 1.0f;

	movss	xmm0, DWORD PTR _total$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@R_AliasDyn
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _total$[ebp], xmm0
$LN21@R_AliasDyn:

; 898  : 
; 899  : 	// scale lightdir by light intentsity
; 900  : 	VectorScale( lightDir, total, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _total$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _total$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _total$[ebp]
	movss	DWORD PTR tv599[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv599[ebp]
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 901  : 
; 902  : 	for( lnum = 0, dl = cl_dlights; lnum < MAX_DLIGHTS; lnum++, dl++ )

	mov	DWORD PTR _lnum$[ebp], 0
	mov	DWORD PTR _dl$[ebp], OFFSET _cl_dlights
	jmp	SHORT $LN4@R_AliasDyn
$LN2@R_AliasDyn:
	mov	eax, DWORD PTR _lnum$[ebp]
	add	eax, 1
	mov	DWORD PTR _lnum$[ebp], eax
	mov	ecx, DWORD PTR _dl$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _dl$[ebp], ecx
$LN4@R_AliasDyn:
	cmp	DWORD PTR _lnum$[ebp], 32		; 00000020H
	jae	$LN3@R_AliasDyn

; 903  : 	{
; 904  : 		if( dl->die < g_alias.time || !r_dynamic->value )

	mov	eax, DWORD PTR _dl$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _g_alias
	comisd	xmm1, xmm0
	ja	SHORT $LN23@R_AliasDyn
	mov	eax, DWORD PTR _r_dynamic
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@R_AliasDyn
$LN23@R_AliasDyn:

; 905  : 			continue;

	jmp	SHORT $LN2@R_AliasDyn
$LN22@R_AliasDyn:

; 906  : 
; 907  : 		VectorSubtract( origin, dl->origin, dist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+ecx]
	subss	xmm0, DWORD PTR [edx+eax]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+edx]
	subss	xmm0, DWORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR _origin$[ebp+eax]
	subss	xmm0, DWORD PTR [edx+ecx]
	movss	DWORD PTR tv631[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv631[ebp]
	movss	DWORD PTR _dist$[ebp+eax], xmm0

; 908  : 
; 909  : 		radius = VectorLength( dist );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _dist$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm1, DWORD PTR _dist$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _dist$[ebp+eax]
	mulss	xmm1, DWORD PTR _dist$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _radius$[ebp]

; 910  : 		add = dl->radius - radius;

	mov	eax, DWORD PTR _dl$[ebp]
	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _add$[ebp], xmm0

; 911  : 
; 912  : 		if( add > 0.0f )

	movss	xmm0, DWORD PTR _add$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN24@R_AliasDyn

; 913  : 		{
; 914  : 			total += add;

	movss	xmm0, DWORD PTR _total$[ebp]
	addss	xmm0, DWORD PTR _add$[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 915  : 
; 916  : 			if( radius > 1.0f )

	movss	xmm0, DWORD PTR _radius$[ebp]
	comiss	xmm0, DWORD PTR __real@3f800000
	jbe	$LN25@R_AliasDyn

; 917  : 				VectorScale( dist, ( add / radius ), dist );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dist$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	mulss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _add$[ebp]
	divss	xmm0, DWORD PTR _radius$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp+eax]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv683[ebp], xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv683[ebp]
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
	jmp	SHORT $LN26@R_AliasDyn
$LN25@R_AliasDyn:

; 918  : 			else VectorScale( dist, add, dist );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _dist$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mulss	xmm0, DWORD PTR _add$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _dist$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _dist$[ebp+eax]
	mulss	xmm0, DWORD PTR _add$[ebp]
	movss	DWORD PTR tv698[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv698[ebp]
	movss	DWORD PTR _dist$[ebp+ecx], xmm0
$LN26@R_AliasDyn:

; 919  : 
; 920  : 			VectorAdd( lightDir, dist, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, DWORD PTR _dist$[ebp+eax]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	addss	xmm0, DWORD PTR _dist$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	addss	xmm0, DWORD PTR _dist$[ebp+ecx]
	movss	DWORD PTR tv719[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv719[ebp]
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0

; 921  : 
; 922  : 			finalLight[0] += LightToTexGamma( dl->color.r ) * ( add / 256.0f ) * 2.0f;

	mov	eax, 4
	imul	esi, eax, 0
	mov	ecx, DWORD PTR _dl$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	push	edx
	call	_LightToTexGamma
	add	esp, 4
	movzx	eax, al
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _finalLight$[ebp+edx], xmm0

; 923  : 			finalLight[1] += LightToTexGamma( dl->color.g ) * ( add / 256.0f ) * 2.0f;

	mov	esi, 4
	shl	esi, 0
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0

; 924  : 			finalLight[2] += LightToTexGamma( dl->color.b ) * ( add / 256.0f ) * 2.0f;

	mov	esi, 4
	shl	esi, 1
	mov	eax, DWORD PTR _dl$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	push	ecx
	call	_LightToTexGamma
	add	esp, 4
	movzx	edx, al
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _add$[ebp]
	divss	xmm1, DWORD PTR __real@43800000
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _finalLight$[ebp+esi]
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _finalLight$[ebp+eax], xmm0
$LN24@R_AliasDyn:

; 925  : 		}
; 926  : 	}

	jmp	$LN2@R_AliasDyn
$LN3@R_AliasDyn:

; 927  : 
; 928  : 	VectorScale( lightDir, 0.9f, lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _lightDir$[ebp+eax], xmm0
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR __real@3f666666
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _lightDir$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR __real@3f666666
	movss	DWORD PTR tv776[ebp], xmm0
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR tv776[ebp]
	movss	DWORD PTR _lightDir$[ebp+ecx], xmm0

; 929  : 
; 930  : 	plight->shadelight = VectorLength( lightDir );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx+4], eax

; 931  : 	plight->ambientlight = total - plight->shadelight;

	mov	eax, DWORD PTR _plight$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR _total$[ebp]
	subss	xmm1, xmm0
	cvttss2si ecx, xmm1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx], ecx

; 932  : 
; 933  : 	total = Q_max( Q_max( finalLight[0], finalLight[1] ), finalLight[2] );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	mov	edx, 4
	shl	edx, 0
	comiss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	jbe	SHORT $LN51@R_AliasDyn
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	movss	DWORD PTR tv819[ebp], xmm0
	jmp	SHORT $LN52@R_AliasDyn
$LN51@R_AliasDyn:
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	movss	DWORD PTR tv819[ebp], xmm0
$LN52@R_AliasDyn:
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv819[ebp]
	comiss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	jbe	SHORT $LN55@R_AliasDyn
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	mov	eax, 4
	shl	eax, 0
	comiss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	jbe	SHORT $LN53@R_AliasDyn
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+edx]
	movss	DWORD PTR tv837[ebp], xmm0
	jmp	SHORT $LN54@R_AliasDyn
$LN53@R_AliasDyn:
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	movss	DWORD PTR tv837[ebp], xmm0
$LN54@R_AliasDyn:
	movss	xmm0, DWORD PTR tv837[ebp]
	movss	DWORD PTR tv841[ebp], xmm0
	jmp	SHORT $LN56@R_AliasDyn
$LN55@R_AliasDyn:
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	movss	DWORD PTR tv841[ebp], xmm0
$LN56@R_AliasDyn:
	movss	xmm0, DWORD PTR tv841[ebp]
	movss	DWORD PTR _total$[ebp], xmm0

; 934  : 
; 935  : 	if( total > 0.0f )

	movss	xmm0, DWORD PTR _total$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN27@R_AliasDyn

; 936  : 	{
; 937  : 		plight->color[0] = finalLight[0] * ( 1.0f / total );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [ecx+eax+8], xmm0

; 938  : 		plight->color[1] = finalLight[1] * ( 1.0f / total );

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 939  : 		plight->color[2] = finalLight[2] * ( 1.0f / total );

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _total$[ebp]
	mulss	xmm0, DWORD PTR _finalLight$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	movss	DWORD PTR [edx+ecx+8], xmm0

; 940  : 	}

	jmp	SHORT $LN28@R_AliasDyn
$LN27@R_AliasDyn:

; 941  : 	else VectorSet( plight->color, 1.0f, 1.0f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx+8], xmm0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+eax+8], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _plight$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edx+8], xmm0
$LN28@R_AliasDyn:

; 942  : 
; 943  : 	if( plight->ambientlight > 128 )

	mov	eax, DWORD PTR _plight$[ebp]
	cmp	DWORD PTR [eax], 128			; 00000080H
	jle	SHORT $LN29@R_AliasDyn

; 944  : 		plight->ambientlight = 128;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [eax], 128			; 00000080H
$LN29@R_AliasDyn:

; 945  : 
; 946  : 	if( plight->ambientlight + plight->shadelight > 255 )

	mov	eax, DWORD PTR _plight$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _plight$[ebp]
	add	ecx, DWORD PTR [edx+4]
	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN30@R_AliasDyn

; 947  : 		plight->shadelight = 255 - plight->ambientlight;

	mov	eax, DWORD PTR _plight$[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _plight$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN30@R_AliasDyn:

; 948  : 
; 949  : 	VectorNormalize2( lightDir, plight->plightvec );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm1, DWORD PTR _lightDir$[ebp+ecx]
	addss	xmm0, xmm1
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _ilength$7[ebp]
	movss	xmm0, DWORD PTR _ilength$7[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN31@R_AliasDyn
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _ilength$7[ebp]
	movss	DWORD PTR _ilength$7[ebp], xmm0
$LN31@R_AliasDyn:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+ecx]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _plight$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	movss	DWORD PTR [eax+edx], xmm0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _lightDir$[ebp+eax]
	mulss	xmm0, DWORD PTR _ilength$7[ebp]
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _plight$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movss	DWORD PTR [ecx+eax], xmm0
$LN1@R_AliasDyn:

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasDynamicLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_CalcAliasBounds
_TEXT	SEGMENT
_v$ = -36						; size = 12
_dist$ = -24						; size = 4
_radius$ = -20						; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_Mod_CalcAliasBounds PROC				; COMDAT

; 589  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 590  : 	int	i, j, k;
; 591  : 	float	radius;
; 592  : 	float	dist;
; 593  : 	vec3_t	v;
; 594  : 
; 595  : 	ClearBounds( mod->mins, mod->maxs );

	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	call	_ClearBounds
	add	esp, 8

; 596  : 	radius = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _radius$[ebp], xmm0

; 597  : 
; 598  : 	// process verts
; 599  : 	for( i = 0; i < m_pAliasHeader->numposes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_CalcAl
$LN2@Mod_CalcAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_CalcAl:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	$LN3@Mod_CalcAl

; 600  : 	{
; 601  : 		for( j = 0; j < m_pAliasHeader->numverts; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_CalcAl
$LN5@Mod_CalcAl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_CalcAl:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jge	$LN6@Mod_CalcAl

; 602  : 		{
; 603  : 			for( k = 0; k < 3; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN10@Mod_CalcAl
$LN8@Mod_CalcAl:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN10@Mod_CalcAl:
	cmp	DWORD PTR _k$[ebp], 3
	jge	SHORT $LN9@Mod_CalcAl

; 604  : 				v[k] = g_poseverts[i][j].v[k] * m_pAliasHeader->scale[k] + m_pAliasHeader->scale_origin[k];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_poseverts[eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _k$[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	mulss	xmm0, DWORD PTR [ecx+eax*4+8]
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _m_pAliasHeader
	addss	xmm0, DWORD PTR [eax+edx*4+20]
	mov	ecx, DWORD PTR _k$[ebp]
	movss	DWORD PTR _v$[ebp+ecx*4], xmm0
	jmp	SHORT $LN8@Mod_CalcAl
$LN9@Mod_CalcAl:

; 605  : 
; 606  : 			AddPointToBounds( v, mod->mins, mod->maxs );

	mov	eax, DWORD PTR _mod$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	lea	edx, DWORD PTR _v$[ebp]
	push	edx
	call	_AddPointToBounds
	add	esp, 12					; 0000000cH

; 607  : 			dist = DotProduct( v, v );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	movss	xmm0, DWORD PTR _v$[ebp+ecx]
	mulss	xmm0, DWORD PTR _v$[ebp+eax]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm1, DWORD PTR _v$[ebp+ecx]
	mulss	xmm1, DWORD PTR _v$[ebp+edx]
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	movss	xmm1, DWORD PTR _v$[ebp+eax]
	mulss	xmm1, DWORD PTR _v$[ebp+ecx]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist$[ebp], xmm0

; 608  : 
; 609  : 			if( radius < dist )

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _radius$[ebp]
	jbe	SHORT $LN11@Mod_CalcAl

; 610  : 				radius = dist;

	movss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _radius$[ebp], xmm0
$LN11@Mod_CalcAl:

; 611  : 		}

	jmp	$LN5@Mod_CalcAl
$LN6@Mod_CalcAl:

; 612  : 	}

	jmp	$LN2@Mod_CalcAl
$LN3@Mod_CalcAl:

; 613  : 
; 614  : 	mod->radius = sqrt( radius );

	cvtss2sd xmm0, DWORD PTR _radius$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	mov	eax, DWORD PTR _mod$[ebp]
	fstp	DWORD PTR [eax+108]

; 615  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CalcAliasBounds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadAllSkins
_TEXT	SEGMENT
_size$ = -8						; size = 4
_i$ = -4						; size = 4
_numskins$ = 8						; size = 4
_pskintype$ = 12					; size = 4
_Mod_LoadAllSkins PROC					; COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 560  : 	int	i, size;
; 561  : 
; 562  : 	if( numskins < 1 || numskins > MAX_SKINS )

	cmp	DWORD PTR _numskins$[ebp], 1
	jl	SHORT $LN6@Mod_LoadAl
	cmp	DWORD PTR _numskins$[ebp], 32		; 00000020H
	jle	SHORT $LN5@Mod_LoadAl
$LN6@Mod_LoadAl:

; 563  : 		Host_Error( "Mod_LoadAliasModel: Invalid # of skins: %d\n", numskins );

	mov	eax, DWORD PTR _numskins$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@FADJGGGH@Mod_LoadAliasModel?3?5Invalid?5?$CD?5o@
	call	_Host_Error
	add	esp, 8
$LN5@Mod_LoadAl:

; 564  : 
; 565  : 	size = m_pAliasHeader->skinwidth * m_pAliasHeader->skinheight;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR [eax+52]
	imul	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR _size$[ebp], edx

; 566  : 
; 567  : 	for( i = 0; i < numskins; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadAl
$LN2@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numskins$[ebp]
	jge	SHORT $LN3@Mod_LoadAl

; 568  : 	{
; 569  : 		if( pskintype->type == ALIAS_SKIN_SINGLE )

	mov	eax, DWORD PTR _pskintype$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@Mod_LoadAl

; 570  : 		{
; 571  : 			pskintype = (daliasskintype_t *)Mod_LoadSingleSkin( pskintype, i, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pskintype$[ebp]
	push	edx
	call	_Mod_LoadSingleSkin
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pskintype$[ebp], eax

; 572  : 		}

	jmp	SHORT $LN8@Mod_LoadAl
$LN7@Mod_LoadAl:

; 573  : 		else
; 574  : 		{
; 575  : 			pskintype = (daliasskintype_t *)Mod_LoadGroupSkin( pskintype, i, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pskintype$[ebp]
	push	edx
	call	_Mod_LoadGroupSkin
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pskintype$[ebp], eax
$LN8@Mod_LoadAl:

; 576  : 		}
; 577  : 	}

	jmp	SHORT $LN2@Mod_LoadAl
$LN3@Mod_LoadAl:

; 578  : 
; 579  : 	return (void *)pskintype;

	mov	eax, DWORD PTR _pskintype$[ebp]

; 580  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadAllSkins ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadGroupSkin
_TEXT	SEGMENT
_j$ = -536						; size = 4
_i$ = -532						; size = 4
_pic$ = -528						; size = 4
_lumaname$ = -524					; size = 256
_name$ = -268						; size = 256
_pinskingroup$ = -12					; size = 4
_pinskinintervals$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_pskintype$ = 8						; size = 4
_skinnum$ = 12						; size = 4
_size$ = 16						; size = 4
_Mod_LoadGroupSkin PROC					; COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 664				; 00000298H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 514  : 	daliasskininterval_t	*pinskinintervals;
; 515  : 	daliasskingroup_t		*pinskingroup;
; 516  : 	string			name, lumaname;
; 517  : 	rgbdata_t			*pic;
; 518  : 	int			i, j;
; 519  : 
; 520  : 	// animating skin group.  yuck.
; 521  : 	pskintype++;

	mov	eax, DWORD PTR _pskintype$[ebp]
	add	eax, 4
	mov	DWORD PTR _pskintype$[ebp], eax

; 522  : 	pinskingroup = (daliasskingroup_t *)pskintype;

	mov	eax, DWORD PTR _pskintype$[ebp]
	mov	DWORD PTR _pinskingroup$[ebp], eax

; 523  : 	pinskinintervals = (daliasskininterval_t *)(pinskingroup + 1);

	mov	eax, DWORD PTR _pinskingroup$[ebp]
	add	eax, 4
	mov	DWORD PTR _pinskinintervals$[ebp], eax

; 524  : 	pskintype = (void *)(pinskinintervals + pinskingroup->numskins);

	mov	eax, DWORD PTR _pinskingroup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pinskinintervals$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pskintype$[ebp], eax

; 525  : 
; 526  : 	for( i = 0; i < pinskingroup->numskins; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadGr
$LN2@Mod_LoadGr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadGr:
	mov	eax, DWORD PTR _pinskingroup$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	$LN3@Mod_LoadGr

; 527  : 	{
; 528  : 		Q_snprintf( name, sizeof( name ), "%s_%i_%i", loadmodel->name, skinnum, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _skinnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET ??_C@_08PMEGOJDI@?$CFs_?$CFi_?$CFi@
	push	256					; 00000100H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 529  : 		pic = Mod_CreateSkinData( loadmodel, (byte *)(pskintype), m_pAliasHeader->skinwidth, m_pAliasHeader->skinheight );

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _pskintype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_Mod_CreateSkinData
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 530  : 		m_pAliasHeader->gl_texturenum[skinnum][i & 3] = GL_LoadTextureInternal( name, pic, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+edx*8+132]
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 3
	mov	WORD PTR [edx+ecx*2], ax

; 531  : 		FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 532  : 
; 533  : 		if( R_GetTexture( m_pAliasHeader->gl_texturenum[skinnum][i & 3] )->flags & TF_HAS_LUMA )

	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 3
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	edx, DWORD PTR [eax+284]
	and	edx, 8192				; 00002000H
	je	$LN8@Mod_LoadGr

; 534  : 		{
; 535  : 			Q_snprintf( lumaname, sizeof( lumaname ), "%s_%i_%i_luma", loadmodel->name, skinnum, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _skinnum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	push	OFFSET ??_C@_0O@DHCKNAGD@?$CFs_?$CFi_?$CFi_luma@
	push	256					; 00000100H
	lea	eax, DWORD PTR _lumaname$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 24					; 00000018H

; 536  : 			pic = Mod_CreateSkinData( NULL, (byte *)(pskintype), m_pAliasHeader->skinwidth, m_pAliasHeader->skinheight );

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _pskintype$[ebp]
	push	ecx
	push	0
	call	_Mod_CreateSkinData
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 537  : 			m_pAliasHeader->fb_texturenum[skinnum][i & 3] = GL_LoadTextureInternal( lumaname, pic, TF_MAKELUMA );

	push	0
	push	16384					; 00004000H
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lumaname$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+edx*8+388]
	mov	ecx, DWORD PTR _i$[ebp]
	and	ecx, 3
	mov	WORD PTR [edx+ecx*2], ax

; 538  : 			FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4
$LN8@Mod_LoadGr:

; 539  : 		}
; 540  : 
; 541  : 		pskintype = (daliasskintype_t *)((byte *)(pskintype) + size);

	mov	eax, DWORD PTR _pskintype$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _pskintype$[ebp], eax

; 542  : 	}

	jmp	$LN2@Mod_LoadGr
$LN3@Mod_LoadGr:

; 543  : 
; 544  : 	for( j = i; i < 4; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@Mod_LoadGr
$LN5@Mod_LoadGr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_LoadGr:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN6@Mod_LoadGr

; 545  : 	{
; 546  : 		m_pAliasHeader->gl_texturenum[skinnum][i & 3] = m_pAliasHeader->gl_texturenum[skinnum][i - j]; 

	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _skinnum$[ebp]
	mov	esi, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [esi+ecx*8+132]
	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 3
	mov	dx, WORD PTR [edx+eax*2]
	mov	WORD PTR [ecx+esi*2], dx

; 547  : 		m_pAliasHeader->fb_texturenum[skinnum][i & 3] = m_pAliasHeader->fb_texturenum[skinnum][i - j]; 

	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _skinnum$[ebp]
	mov	esi, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [esi+ecx*8+388]
	mov	esi, DWORD PTR _i$[ebp]
	and	esi, 3
	mov	dx, WORD PTR [edx+eax*2]
	mov	WORD PTR [ecx+esi*2], dx

; 548  : 	}

	jmp	$LN5@Mod_LoadGr
$LN6@Mod_LoadGr:

; 549  : 
; 550  : 	return pskintype;

	mov	eax, DWORD PTR _pskintype$[ebp]

; 551  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadGroupSkin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadSingleSkin
_TEXT	SEGMENT
tv197 = -908						; size = 4
tv151 = -908						; size = 4
_pic$ = -776						; size = 4
_checkname$ = -772					; size = 256
_lumaname$ = -516					; size = 256
_name$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pskintype$ = 8						; size = 4
_skinnum$ = 12						; size = 4
_size$ = 16						; size = 4
_Mod_LoadSingleSkin PROC				; COMDAT

; 482  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 908				; 0000038cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 483  : 	string	name, lumaname;
; 484  : 	string	checkname;
; 485  : 	rgbdata_t	*pic;
; 486  : 
; 487  : 	Q_snprintf( name, sizeof( name ), "%s:frame%i", loadmodel->name, skinnum );

	mov	eax, DWORD PTR _skinnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET ??_C@_0L@IMOKENLI@?$CFs?3frame?$CFi@
	push	256					; 00000100H
	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 488  : 	Q_snprintf( lumaname, sizeof( lumaname ), "%s:luma%i", loadmodel->name, skinnum );

	mov	eax, DWORD PTR _skinnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET ??_C@_09BHFKCCCE@?$CFs?3luma?$CFi@
	push	256					; 00000100H
	lea	edx, DWORD PTR _lumaname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 489  : 	Q_snprintf( checkname, sizeof( checkname ), "%s_%i.tga", loadmodel->name, skinnum );

	mov	eax, DWORD PTR _skinnum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	push	OFFSET ??_C@_09OJIFCICD@?$CFs_?$CFi?4tga@
	push	256					; 00000100H
	lea	edx, DWORD PTR _checkname$[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 490  : 	if( !FS_FileExists( checkname, false ) || ( pic = FS_LoadImage( checkname, NULL, 0 )) == NULL )

	push	0
	lea	eax, DWORD PTR _checkname$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@Mod_LoadSi
	push	0
	push	0
	lea	eax, DWORD PTR _checkname$[ebp]
	push	eax
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax
	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN2@Mod_LoadSi
$LN3@Mod_LoadSi:

; 491  : 		pic = Mod_CreateSkinData( loadmodel, (byte *)(pskintype + 1), m_pAliasHeader->skinwidth, m_pAliasHeader->skinheight );

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _pskintype$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _loadmodel
	push	edx
	call	_Mod_CreateSkinData
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax
$LN2@Mod_LoadSi:

; 492  : 
; 493  : 	m_pAliasHeader->gl_texturenum[skinnum][0] =

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv151[ebp], eax
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	eax, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [eax+edx*8+132]
	mov	edx, 2
	imul	eax, edx, 3
	mov	dx, WORD PTR tv151[ebp]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, 2
	shl	eax, 1
	mov	cx, WORD PTR tv151[ebp]
	mov	WORD PTR [edx+eax], cx
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	eax, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [eax+edx*8+132]
	mov	edx, 2
	shl	edx, 0
	mov	ax, WORD PTR tv151[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	ecx, DWORD PTR _skinnum$[ebp]
	mov	edx, DWORD PTR _m_pAliasHeader
	lea	eax, DWORD PTR [edx+ecx*8+132]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	cx, WORD PTR tv151[ebp]
	mov	WORD PTR [eax+edx], cx

; 494  : 	m_pAliasHeader->gl_texturenum[skinnum][1] =
; 495  : 	m_pAliasHeader->gl_texturenum[skinnum][2] =
; 496  : 	m_pAliasHeader->gl_texturenum[skinnum][3] = GL_LoadTextureInternal( name, pic, 0 );
; 497  : 	FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 498  : 
; 499  : 	if( R_GetTexture( m_pAliasHeader->gl_texturenum[skinnum][0] )->flags & TF_HAS_LUMA )

	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, 2
	imul	ecx, eax, 0
	movzx	edx, WORD PTR [edx+ecx]
	push	edx
	call	_R_GetTexture
	add	esp, 4
	mov	eax, DWORD PTR [eax+284]
	and	eax, 8192				; 00002000H
	je	$LN4@Mod_LoadSi

; 500  : 	{
; 501  : 		pic = Mod_CreateSkinData( NULL, (byte *)(pskintype + 1), m_pAliasHeader->skinwidth, m_pAliasHeader->skinheight );

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _pskintype$[ebp]
	add	ecx, 4
	push	ecx
	push	0
	call	_Mod_CreateSkinData
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 502  : 		m_pAliasHeader->fb_texturenum[skinnum][0] =

	push	0
	push	16384					; 00004000H
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lumaname$[ebp]
	push	ecx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv197[ebp], eax
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	eax, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [eax+edx*8+388]
	mov	edx, 2
	imul	eax, edx, 3
	mov	dx, WORD PTR tv197[ebp]
	mov	WORD PTR [ecx+eax], dx
	mov	eax, DWORD PTR _skinnum$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, 2
	shl	eax, 1
	mov	cx, WORD PTR tv197[ebp]
	mov	WORD PTR [edx+eax], cx
	mov	edx, DWORD PTR _skinnum$[ebp]
	mov	eax, DWORD PTR _m_pAliasHeader
	lea	ecx, DWORD PTR [eax+edx*8+388]
	mov	edx, 2
	shl	edx, 0
	mov	ax, WORD PTR tv197[ebp]
	mov	WORD PTR [ecx+edx], ax
	mov	ecx, DWORD PTR _skinnum$[ebp]
	mov	edx, DWORD PTR _m_pAliasHeader
	lea	eax, DWORD PTR [edx+ecx*8+388]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	cx, WORD PTR tv197[ebp]
	mov	WORD PTR [eax+edx], cx

; 503  : 		m_pAliasHeader->fb_texturenum[skinnum][1] =
; 504  : 		m_pAliasHeader->fb_texturenum[skinnum][2] =
; 505  : 		m_pAliasHeader->fb_texturenum[skinnum][3] = GL_LoadTextureInternal( lumaname, pic, TF_MAKELUMA );
; 506  : 		FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4
$LN4@Mod_LoadSi:

; 507  : 	}
; 508  : 
; 509  : 	return ((byte *)(pskintype + 1) + size);

	mov	eax, DWORD PTR _size$[ebp]
	mov	ecx, DWORD PTR _pskintype$[ebp]
	lea	eax, DWORD PTR [ecx+eax+4]

; 510  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadSingleSkin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_CreateSkinData
_TEXT	SEGMENT
_size$1 = -84						; size = 4
_i$2 = -80						; size = 4
_tx$3 = -76						; size = 4
_i$ = -72						; size = 4
_name$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_mod$ = 8						; size = 4
_data$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
_Mod_CreateSkinData PROC				; COMDAT

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 421  : 	static rgbdata_t	skin;
; 422  : 	char		name[MAX_QPATH];
; 423  : 	int		i;
; 424  : 
; 425  : 	skin.width = width;

	mov	ax, WORD PTR _width$[ebp]
	mov	WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9, ax

; 426  : 	skin.height = height;

	mov	ax, WORD PTR _height$[ebp]
	mov	WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+2, ax

; 427  : 	skin.depth = 1;

	mov	eax, 1
	mov	WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+4, ax

; 428  : 	skin.type = PF_INDEXED_24;

	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+8, 1

; 429  : 	skin.flags = IMAGE_HAS_COLOR|IMAGE_QUAKEPAL;

	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+12, 1028 ; 00000404H

; 430  : 	skin.encode = DXT_ENCODE_DEFAULT;

	xor	eax, eax
	mov	WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+16, ax

; 431  : 	skin.numMips = 1;

	mov	BYTE PTR ?skin@?1??Mod_CreateSkinData@@9@9+18, 1

; 432  : 	skin.buffer = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+24, eax

; 433  : 	skin.palette = (byte *)&clgame.palette;

	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+20, OFFSET _clgame+217656

; 434  : 	skin.size = width * height;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+32, eax

; 435  : 
; 436  : 	if( !Image_CustomPalette() )

	call	_Image_CustomPalette
	test	eax, eax
	jne	SHORT $LN5@Mod_Create

; 437  : 	{
; 438  : 		for( i = 0; i < skin.width * skin.height; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Create
$LN2@Mod_Create:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Create:
	movzx	eax, WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9
	movzx	ecx, WORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+2
	imul	eax, ecx
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN5@Mod_Create

; 439  : 		{
; 440  : 			if( data[i] > 224 && data[i] != 255 )

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 224				; 000000e0H
	jle	SHORT $LN6@Mod_Create
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN6@Mod_Create

; 441  : 			{
; 442  : 				SetBits( skin.flags, IMAGE_HAS_LUMA );

	mov	eax, DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+12
	or	eax, 16					; 00000010H
	mov	DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+12, eax

; 443  : 				break;

	jmp	SHORT $LN5@Mod_Create
$LN6@Mod_Create:

; 444  : 			}
; 445  : 		}

	jmp	SHORT $LN2@Mod_Create
$LN5@Mod_Create:

; 446  : 	}
; 447  : 
; 448  : 	COM_FileBase( loadmodel->name, name );

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadmodel
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 449  : 
; 450  : 	// for alias models only player can have remap textures
; 451  : 	if( mod != NULL && !Q_stricmp( name, "player" ))

	cmp	DWORD PTR _mod$[ebp], 0
	je	$LN7@Mod_Create
	push	99999					; 0001869fH
	push	OFFSET ??_C@_06BALNJMNP@player@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN7@Mod_Create

; 452  : 	{
; 453  : 		texture_t	*tx = NULL;

	mov	DWORD PTR _tx$3[ebp], 0

; 454  : 		int	i, size;
; 455  : 
; 456  : 		i = mod->numtextures;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+368]
	mov	DWORD PTR _i$2[ebp], ecx

; 457  : 		mod->textures = (texture_t **)Mem_Realloc( mod->mempool, mod->textures, ( i + 1 ) * sizeof( texture_t* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_CreateSkinData@@9@9
	add	eax, 37					; 00000025H
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _i$2[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 458  : 		size = width * height + 768;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	add	eax, 768				; 00000300H
	mov	DWORD PTR _size$1[ebp], eax

; 459  : 		tx = Mem_Calloc( mod->mempool, sizeof( *tx ) + size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_CreateSkinData@@9@9
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$1[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tx$3[ebp], eax

; 460  : 		mod->textures[i] = tx;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _tx$3[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 461  : 
; 462  : 		Q_strncpy( tx->name, "DM_Skin", sizeof( tx->name ));

	push	16					; 00000010H
	push	OFFSET ??_C@_07MAOCDBIF@DM_Skin@
	mov	eax, DWORD PTR _tx$3[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 463  : 		tx->anim_min = SHIRT_HUE_START; // topcolor start

	mov	eax, DWORD PTR _tx$3[ebp]
	mov	DWORD PTR [eax+36], 16			; 00000010H

; 464  : 		tx->anim_max = SHIRT_HUE_END; // topcolor end

	mov	eax, DWORD PTR _tx$3[ebp]
	mov	DWORD PTR [eax+40], 32			; 00000020H

; 465  : 		// bottomcolor start always equal is (topcolor end + 1)
; 466  : 		tx->anim_total = PANTS_HUE_END;// bottomcolor end

	mov	eax, DWORD PTR _tx$3[ebp]
	mov	DWORD PTR [eax+32], 112			; 00000070H

; 467  : 
; 468  : 		tx->width = width;

	mov	eax, DWORD PTR _tx$3[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 469  : 		tx->height = height;

	mov	eax, DWORD PTR _tx$3[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 470  : 
; 471  : 		// the pixels immediately follow the structures
; 472  : 		memcpy( (tx+1), data, width * height );

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tx$3[ebp]
	add	edx, 68					; 00000044H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 473  : 		memcpy( ((byte *)(tx+1)+(width * height)), skin.palette, 768 );

	push	768					; 00000300H
	mov	eax, DWORD PTR ?skin@?1??Mod_CreateSkinData@@9@9+20
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	imul	ecx, DWORD PTR _height$[ebp]
	mov	edx, DWORD PTR _tx$3[ebp]
	lea	eax, DWORD PTR [edx+ecx+68]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 474  : 		mod->numtextures++;	// done

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+368]
	add	ecx, 1
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+368], ecx
$LN7@Mod_Create:

; 475  : 	}
; 476  : 
; 477  : 	// make an copy
; 478  : 	return FS_CopyImage( &skin );

	push	OFFSET ?skin@?1??Mod_CreateSkinData@@9@9
	call	_FS_CopyImage
	add	esp, 4

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_CreateSkinData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadAliasGroup
_TEXT	SEGMENT
_ptemp$ = -20						; size = 4
_pin_intervals$ = -16					; size = 4
_numframes$ = -12					; size = 4
_i$ = -8						; size = 4
_pingroup$ = -4						; size = 4
_pin$ = 8						; size = 4
_frame$ = 12						; size = 4
_Mod_LoadAliasGroup PROC				; COMDAT

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 380  : 	daliasgroup_t	*pingroup;
; 381  : 	int		i, numframes;
; 382  : 	daliasinterval_t	*pin_intervals;
; 383  : 	void		*ptemp;
; 384  : 
; 385  : 	pingroup = (daliasgroup_t *)pin;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _pingroup$[ebp], eax

; 386  : 	numframes = pingroup->numframes;

	mov	eax, DWORD PTR _pingroup$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _numframes$[ebp], ecx

; 387  : 
; 388  : 	frame->firstpose = g_posenum;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _g_posenum
	mov	DWORD PTR [eax], ecx

; 389  : 	frame->numposes = numframes;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _numframes$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 390  : 
; 391  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadAl
$LN2@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadAl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@Mod_LoadAl

; 392  : 	{
; 393  : 		frame->bboxmin.v[i] = pingroup->bboxmin.v[i];

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pingroup$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+8], dl

; 394  : 		frame->bboxmax.v[i] = pingroup->bboxmax.v[i];

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pingroup$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx+8]
	mov	BYTE PTR [eax+12], dl

; 395  : 	}

	jmp	SHORT $LN2@Mod_LoadAl
$LN3@Mod_LoadAl:

; 396  : 
; 397  : 	pin_intervals = (daliasinterval_t *)(pingroup + 1);

	mov	eax, DWORD PTR _pingroup$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pin_intervals$[ebp], eax

; 398  : 
; 399  : 	// all the intervals are always equal 0.1 so we don't care about them
; 400  : 	frame->interval = pin_intervals->interval;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _pin_intervals$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], edx

; 401  : 	pin_intervals += numframes;

	mov	eax, DWORD PTR _numframes$[ebp]
	mov	ecx, DWORD PTR _pin_intervals$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pin_intervals$[ebp], edx

; 402  : 	ptemp = (void *)pin_intervals;

	mov	eax, DWORD PTR _pin_intervals$[ebp]
	mov	DWORD PTR _ptemp$[ebp], eax

; 403  : 
; 404  : 	for( i = 0; i < numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadAl
$LN5@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numframes$[ebp]
	jge	SHORT $LN6@Mod_LoadAl

; 405  : 	{
; 406  : 		g_poseverts[g_posenum] = (trivertex_t *)((daliasframe_t *)ptemp + 1);

	mov	eax, DWORD PTR _ptemp$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _g_posenum
	mov	DWORD PTR _g_poseverts[ecx*4], eax

; 407  : 		ptemp = (trivertex_t *)((daliasframe_t *)ptemp + 1) + m_pAliasHeader->numverts;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _ptemp$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+24]
	mov	DWORD PTR _ptemp$[ebp], eax

; 408  : 		g_posenum++;

	mov	eax, DWORD PTR _g_posenum
	add	eax, 1
	mov	DWORD PTR _g_posenum, eax

; 409  : 	}

	jmp	SHORT $LN5@Mod_LoadAl
$LN6@Mod_LoadAl:

; 410  : 
; 411  : 	return ptemp;

	mov	eax, DWORD PTR _ptemp$[ebp]

; 412  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadAliasGroup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadAliasFrame
_TEXT	SEGMENT
_i$ = -12						; size = 4
_pinframe$ = -8						; size = 4
_pdaliasframe$ = -4					; size = 4
_pin$ = 8						; size = 4
_frame$ = 12						; size = 4
_Mod_LoadAliasFrame PROC				; COMDAT

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 348  : 	daliasframe_t	*pdaliasframe;
; 349  : 	trivertex_t	*pinframe;
; 350  : 	int		i;
; 351  : 
; 352  : 	pdaliasframe = (daliasframe_t *)pin;

	mov	eax, DWORD PTR _pin$[ebp]
	mov	DWORD PTR _pdaliasframe$[ebp], eax

; 353  : 
; 354  : 	Q_strncpy( frame->name, pdaliasframe->name, sizeof( frame->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _pdaliasframe$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _frame$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 355  : 	frame->firstpose = g_posenum;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR _g_posenum
	mov	DWORD PTR [eax], ecx

; 356  : 	frame->numposes = 1;

	mov	eax, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax+4], 1

; 357  : 
; 358  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadAl
$LN2@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadAl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@Mod_LoadAl

; 359  : 	{
; 360  : 		frame->bboxmin.v[i] = pdaliasframe->bboxmin.v[i];

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pdaliasframe$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+8], dl

; 361  : 		frame->bboxmax.v[i] = pdaliasframe->bboxmax.v[i];

	mov	eax, DWORD PTR _frame$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pdaliasframe$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+12], dl

; 362  : 	}

	jmp	SHORT $LN2@Mod_LoadAl
$LN3@Mod_LoadAl:

; 363  : 
; 364  : 	pinframe = (trivertex_t *)(pdaliasframe + 1);

	mov	eax, DWORD PTR _pdaliasframe$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _pinframe$[ebp], eax

; 365  : 
; 366  : 	g_poseverts[g_posenum] = (trivertex_t *)pinframe;

	mov	eax, DWORD PTR _g_posenum
	mov	ecx, DWORD PTR _pinframe$[ebp]
	mov	DWORD PTR _g_poseverts[eax*4], ecx

; 367  : 	pinframe += m_pAliasHeader->numverts;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _pinframe$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pinframe$[ebp], eax

; 368  : 	g_posenum++;

	mov	eax, DWORD PTR _g_posenum
	add	eax, 1
	mov	DWORD PTR _g_posenum, eax

; 369  : 
; 370  : 	return (void *)pinframe;

	mov	eax, DWORD PTR _pinframe$[ebp]

; 371  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadAliasFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _GL_MakeAliasModelDisplayLists
_TEXT	SEGMENT
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_verts$ = -4						; size = 4
_m$ = 8							; size = 4
_GL_MakeAliasModelDisplayLists PROC			; COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 313  : 	trivertex_t	*verts;
; 314  : 	int		i, j;
; 315  : 
; 316  : 	BuildTris( );

	call	_BuildTris

; 317  : 
; 318  : 	// save the data out
; 319  : 	m_pAliasHeader->poseverts = g_numorder;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _g_numorder
	mov	DWORD PTR [eax+120], ecx

; 320  : 
; 321  : 	m_pAliasHeader->commands = Mem_Malloc( m->mempool, g_numcommands * 4 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_MakeAliasModelDisplayLists@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _g_numcommands
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	DWORD PTR [ecx+128], eax

; 322  : 	memcpy( m_pAliasHeader->commands, g_commands, g_numcommands * 4 );

	mov	eax, DWORD PTR _g_numcommands
	shl	eax, 2
	push	eax
	push	OFFSET _g_commands
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR [ecx+128]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 323  : 
; 324  : 	m_pAliasHeader->posedata = Mem_Malloc( m->mempool, m_pAliasHeader->numposes * m_pAliasHeader->poseverts * sizeof( trivertex_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_MakeAliasModelDisplayLists@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [ecx+116]
	imul	eax, DWORD PTR [edx+120]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	DWORD PTR [ecx+124], eax

; 325  : 	verts = m_pAliasHeader->posedata;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+124]
	mov	DWORD PTR _verts$[ebp], ecx

; 326  : 
; 327  : 	for( i = 0; i < m_pAliasHeader->numposes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_MakeAli
$LN2@GL_MakeAli:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_MakeAli:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $LN1@GL_MakeAli

; 328  : 	{
; 329  : 		for( j = 0; j < g_numorder; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@GL_MakeAli
$LN5@GL_MakeAli:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@GL_MakeAli:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _g_numorder
	jge	SHORT $LN6@GL_MakeAli

; 330  : 			*verts++ = g_poseverts[i][g_vertexorder[j]];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _g_vertexorder[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _g_poseverts[edx*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _verts$[ebp]
	add	eax, 4
	mov	DWORD PTR _verts$[ebp], eax
	jmp	SHORT $LN5@GL_MakeAli
$LN6@GL_MakeAli:

; 331  : 	}

	jmp	SHORT $LN2@GL_MakeAli
$LN1@GL_MakeAli:

; 332  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_MakeAliasModelDisplayLists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _BuildTris
_TEXT	SEGMENT
_t$ = -8236						; size = 4
_s$ = -8232						; size = 4
_k$ = -8228						; size = 4
_j$ = -8224						; size = 4
_i$ = -8220						; size = 4
_startv$ = -8216					; size = 4
_type$ = -8212						; size = 4
_besttris$ = -8208					; size = 4096
_bestverts$ = -4112					; size = 4096
_besttype$ = -16					; size = 4
_bestlen$ = -12						; size = 4
_len$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_BuildTris PROC						; COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8748				; 0000222cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 233  : 	int	len, bestlen, besttype;
; 234  : 	int	bestverts[1024];
; 235  : 	int	besttris[1024];
; 236  : 	int	type, startv;
; 237  : 	int	i, j, k;
; 238  : 	float	s, t;
; 239  : 
; 240  : 	//
; 241  : 	// build tristrips
; 242  : 	//
; 243  : 	memset( g_used, 0, sizeof( g_used ));

	push	32768					; 00008000H
	push	0
	push	OFFSET _g_used
	call	_memset
	add	esp, 12					; 0000000cH

; 244  : 	g_numcommands = 0;

	mov	DWORD PTR _g_numcommands, 0

; 245  : 	g_numorder = 0;

	mov	DWORD PTR _g_numorder, 0

; 246  : 
; 247  : 	for( i = 0; i < m_pAliasHeader->numtris; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@BuildTris
$LN2@BuildTris:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@BuildTris:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	$LN3@BuildTris

; 248  : 	{
; 249  : 		// pick an unused triangle and start the trifan
; 250  : 		if( g_used[i] ) continue;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _g_used[eax*4], 0
	je	SHORT $LN23@BuildTris
	jmp	SHORT $LN2@BuildTris
$LN23@BuildTris:

; 251  : 
; 252  : 		bestlen = 0;

	mov	DWORD PTR _bestlen$[ebp], 0

; 253  : 		for( type = 0; type < 2; type++ )

	mov	DWORD PTR _type$[ebp], 0
	jmp	SHORT $LN7@BuildTris
$LN5@BuildTris:
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, 1
	mov	DWORD PTR _type$[ebp], eax
$LN7@BuildTris:
	cmp	DWORD PTR _type$[ebp], 2
	jge	$LN6@BuildTris

; 254  : 		{
; 255  : 			for( startv = 0; startv < 3; startv++ )

	mov	DWORD PTR _startv$[ebp], 0
	jmp	SHORT $LN10@BuildTris
$LN8@BuildTris:
	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 1
	mov	DWORD PTR _startv$[ebp], eax
$LN10@BuildTris:
	cmp	DWORD PTR _startv$[ebp], 3
	jge	$LN9@BuildTris

; 256  : 			{
; 257  : 				if( type == 1 ) len = StripLength( i, startv );

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN24@BuildTris
	mov	eax, DWORD PTR _startv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_StripLength
	add	esp, 8
	mov	DWORD PTR _len$[ebp], eax
	jmp	SHORT $LN25@BuildTris
$LN24@BuildTris:

; 258  : 				else len = FanLength( i, startv );

	mov	eax, DWORD PTR _startv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_FanLength
	add	esp, 8
	mov	DWORD PTR _len$[ebp], eax
$LN25@BuildTris:

; 259  : 
; 260  : 				if( len > bestlen )

	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _bestlen$[ebp]
	jle	$LN15@BuildTris

; 261  : 				{
; 262  : 					besttype = type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _besttype$[ebp], eax

; 263  : 					bestlen = len;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _bestlen$[ebp], eax

; 264  : 
; 265  : 					for( j = 0; j < bestlen + 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@BuildTris
$LN11@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@BuildTris:
	mov	eax, DWORD PTR _bestlen$[ebp]
	add	eax, 2
	cmp	DWORD PTR _j$[ebp], eax
	jge	SHORT $LN12@BuildTris

; 266  : 						bestverts[j] = g_stripverts[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _g_stripverts[ecx*4]
	mov	DWORD PTR _bestverts$[ebp+eax*4], edx
	jmp	SHORT $LN11@BuildTris
$LN12@BuildTris:

; 267  : 
; 268  : 					for( j = 0; j < bestlen; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN16@BuildTris
$LN14@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN16@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _bestlen$[ebp]
	jge	SHORT $LN15@BuildTris

; 269  : 						besttris[j] = g_striptris[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _g_striptris[ecx*4]
	mov	DWORD PTR _besttris$[ebp+eax*4], edx
	jmp	SHORT $LN14@BuildTris
$LN15@BuildTris:

; 270  : 				}
; 271  : 			}

	jmp	$LN8@BuildTris
$LN9@BuildTris:

; 272  : 		}

	jmp	$LN5@BuildTris
$LN6@BuildTris:

; 273  : 
; 274  : 		// mark the tris on the best strip as used
; 275  : 		for( j = 0; j < bestlen; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN19@BuildTris
$LN17@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN19@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _bestlen$[ebp]
	jge	SHORT $LN18@BuildTris

; 276  : 			g_used[besttris[j]] = 1;

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _besttris$[ebp+eax*4]
	mov	DWORD PTR _g_used[ecx*4], 1
	jmp	SHORT $LN17@BuildTris
$LN18@BuildTris:

; 277  : 
; 278  : 		if( besttype == 1 )

	cmp	DWORD PTR _besttype$[ebp], 1
	jne	SHORT $LN27@BuildTris

; 279  : 			g_commands[g_numcommands++] = (bestlen + 2);

	mov	eax, DWORD PTR _bestlen$[ebp]
	add	eax, 2
	mov	ecx, DWORD PTR _g_numcommands
	mov	DWORD PTR _g_commands[ecx*4], eax
	mov	edx, DWORD PTR _g_numcommands
	add	edx, 1
	mov	DWORD PTR _g_numcommands, edx
	jmp	SHORT $LN28@BuildTris
$LN27@BuildTris:

; 280  : 		else g_commands[g_numcommands++] = -(bestlen + 2);

	mov	eax, DWORD PTR _bestlen$[ebp]
	add	eax, 2
	neg	eax
	mov	ecx, DWORD PTR _g_numcommands
	mov	DWORD PTR _g_commands[ecx*4], eax
	mov	edx, DWORD PTR _g_numcommands
	add	edx, 1
	mov	DWORD PTR _g_numcommands, edx
$LN28@BuildTris:

; 281  : 
; 282  : 		for( j = 0; j < bestlen + 2; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@BuildTris
$LN20@BuildTris:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@BuildTris:
	mov	eax, DWORD PTR _bestlen$[ebp]
	add	eax, 2
	cmp	DWORD PTR _j$[ebp], eax
	jge	$LN21@BuildTris

; 283  : 		{
; 284  : 			// emit a vertex into the reorder buffer
; 285  : 			k = bestverts[j];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _bestverts$[ebp+eax*4]
	mov	DWORD PTR _k$[ebp], ecx

; 286  : 			g_vertexorder[g_numorder++] = k;

	mov	eax, DWORD PTR _g_numorder
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _g_vertexorder[eax*4], ecx
	mov	edx, DWORD PTR _g_numorder
	add	edx, 1
	mov	DWORD PTR _g_numorder, edx

; 287  : 
; 288  : 			// emit s/t coords into the commands stream
; 289  : 			s = g_stverts[k].s;

	imul	eax, DWORD PTR _k$[ebp], 12
	cvtsi2ss xmm0, DWORD PTR _g_stverts[eax+4]
	movss	DWORD PTR _s$[ebp], xmm0

; 290  : 			t = g_stverts[k].t;

	imul	eax, DWORD PTR _k$[ebp], 12
	cvtsi2ss xmm0, DWORD PTR _g_stverts[eax+8]
	movss	DWORD PTR _t$[ebp], xmm0

; 291  : 
; 292  : 			if( !g_triangles[besttris[0]].facesfront && g_stverts[k].onseam )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _besttris$[ebp+ecx]
	shl	edx, 4
	cmp	DWORD PTR _g_triangles[edx], 0
	jne	SHORT $LN29@BuildTris
	imul	eax, DWORD PTR _k$[ebp], 12
	cmp	DWORD PTR _g_stverts[eax], 0
	je	SHORT $LN29@BuildTris

; 293  : 				s += m_pAliasHeader->skinwidth / 2;	// on back side

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	eax, DWORD PTR [eax+52]
	cdq
	sub	eax, edx
	sar	eax, 1
	cvtsi2ss xmm0, eax
	addss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _s$[ebp], xmm0
$LN29@BuildTris:

; 294  : 			s = (s + 0.5f) / m_pAliasHeader->skinwidth;

	movss	xmm0, DWORD PTR _s$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _m_pAliasHeader
	cvtsi2ss xmm1, DWORD PTR [eax+52]
	divss	xmm0, xmm1
	movss	DWORD PTR _s$[ebp], xmm0

; 295  : 			t = (t + 0.5f) / m_pAliasHeader->skinheight;

	movss	xmm0, DWORD PTR _t$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR _m_pAliasHeader
	cvtsi2ss xmm1, DWORD PTR [eax+56]
	divss	xmm0, xmm1
	movss	DWORD PTR _t$[ebp], xmm0

; 296  : 
; 297  : 			// Carmack use floats and Valve use shorts here...
; 298  : 			*(float *)&g_commands[g_numcommands++] = s;

	mov	eax, DWORD PTR _g_numcommands
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR _g_commands[eax*4], xmm0
	mov	ecx, DWORD PTR _g_numcommands
	add	ecx, 1
	mov	DWORD PTR _g_numcommands, ecx

; 299  : 			*(float *)&g_commands[g_numcommands++] = t;

	mov	eax, DWORD PTR _g_numcommands
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR _g_commands[eax*4], xmm0
	mov	ecx, DWORD PTR _g_numcommands
	add	ecx, 1
	mov	DWORD PTR _g_numcommands, ecx

; 300  : 		}

	jmp	$LN20@BuildTris
$LN21@BuildTris:

; 301  : 	}

	jmp	$LN2@BuildTris
$LN3@BuildTris:

; 302  : 
; 303  : 	g_commands[g_numcommands++] = 0; // end of list marker

	mov	eax, DWORD PTR _g_numcommands
	mov	DWORD PTR _g_commands[eax*4], 0
	mov	ecx, DWORD PTR _g_numcommands
	add	ecx, 1
	mov	DWORD PTR _g_numcommands, ecx

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildTris ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _FanLength
_TEXT	SEGMENT
_check$ = -24						; size = 4
_last$ = -20						; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_m2$ = -8						; size = 4
_m1$ = -4						; size = 4
_starttri$ = 8						; size = 4
_startv$ = 12						; size = 4
_FanLength PROC						; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 166  : 	int		m1, m2, j, k;
; 167  : 	dtriangle_t	*last, *check;
; 168  : 
; 169  : 	g_used[starttri] = 2;

	mov	eax, DWORD PTR _starttri$[ebp]
	mov	DWORD PTR _g_used[eax*4], 2

; 170  : 
; 171  : 	last = &g_triangles[starttri];

	mov	eax, DWORD PTR _starttri$[ebp]
	shl	eax, 4
	add	eax, OFFSET _g_triangles
	mov	DWORD PTR _last$[ebp], eax

; 172  : 
; 173  : 	g_stripverts[0] = last->vertindex[(startv+0) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _g_stripverts[ecx], edx

; 174  : 	g_stripverts[1] = last->vertindex[(startv+1) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _g_stripverts[eax], edx

; 175  : 	g_stripverts[2] = last->vertindex[(startv+2) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _g_stripverts[eax], edx

; 176  : 
; 177  : 	g_striptris[0] = starttri;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _starttri$[ebp]
	mov	DWORD PTR _g_striptris[ecx], edx

; 178  : 	g_stripcount = 1;

	mov	DWORD PTR _g_stripcount, 1

; 179  : 
; 180  : 	m1 = last->vertindex[(startv+0) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m1$[ebp], ecx

; 181  : 	m2 = last->vertindex[(startv+2) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m2$[ebp], ecx
$nexttri$17:

; 182  : 
; 183  : nexttri:
; 184  : 	// look for a matching triangle
; 185  : 	for( j = starttri + 1, check = &g_triangles[starttri + 1]; j < m_pAliasHeader->numtris; j++, check++ )

	mov	eax, DWORD PTR _starttri$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _starttri$[ebp]
	add	ecx, 1
	shl	ecx, 4
	add	ecx, OFFSET _g_triangles
	mov	DWORD PTR _check$[ebp], ecx
	jmp	SHORT $LN4@FanLength
$LN2@FanLength:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@FanLength:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	$done$18

; 186  : 	{
; 187  : 		if( check->facesfront != last->facesfront )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN11@FanLength

; 188  : 			continue;

	jmp	SHORT $LN2@FanLength
$LN11@FanLength:

; 189  : 
; 190  : 		for( k = 0; k < 3; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@FanLength
$LN5@FanLength:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@FanLength:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$LN6@FanLength

; 191  : 		{
; 192  : 			if( check->vertindex[k] != m1 )

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	cmp	edx, DWORD PTR _m1$[ebp]
	je	SHORT $LN12@FanLength

; 193  : 				continue;

	jmp	SHORT $LN5@FanLength
$LN12@FanLength:

; 194  : 			if( check->vertindex[(k+1) % 3] != m2 )

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	cmp	ecx, DWORD PTR _m2$[ebp]
	je	SHORT $LN13@FanLength

; 195  : 				continue;

	jmp	SHORT $LN5@FanLength
$LN13@FanLength:

; 196  : 
; 197  : 			// this is the next part of the fan
; 198  : 			// if we can't use this triangle, this tristrip is done
; 199  : 			if( g_used[j] ) goto done;

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _g_used[eax*4], 0
	je	SHORT $LN14@FanLength
	jmp	SHORT $done$18
$LN14@FanLength:

; 200  : 
; 201  : 			// the new edge
; 202  : 			m2 = check->vertindex[(k+2) % 3];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m2$[ebp], ecx

; 203  : 
; 204  : 			g_stripverts[g_stripcount + 2] = m2;

	mov	eax, DWORD PTR _g_stripcount
	mov	ecx, DWORD PTR _m2$[ebp]
	mov	DWORD PTR _g_stripverts[eax*4+8], ecx

; 205  : 			g_striptris[g_stripcount] = j;

	mov	eax, DWORD PTR _g_stripcount
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_striptris[eax*4], ecx

; 206  : 			g_stripcount++;

	mov	eax, DWORD PTR _g_stripcount
	add	eax, 1
	mov	DWORD PTR _g_stripcount, eax

; 207  : 
; 208  : 			g_used[j] = 2;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_used[eax*4], 2

; 209  : 			goto nexttri;

	jmp	$nexttri$17

; 210  : 		}

	jmp	$LN5@FanLength
$LN6@FanLength:

; 211  : 	}

	jmp	$LN2@FanLength
$done$18:

; 212  : done:
; 213  : 	// clear the temp used flags
; 214  : 	for( j = starttri + 1; j < m_pAliasHeader->numtris; j++ )

	mov	eax, DWORD PTR _starttri$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN10@FanLength
$LN8@FanLength:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@FanLength:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	SHORT $LN9@FanLength

; 215  : 	{
; 216  : 		if( g_used[j] == 2 )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _g_used[eax*4], 2
	jne	SHORT $LN15@FanLength

; 217  : 			g_used[j] = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_used[eax*4], 0
$LN15@FanLength:

; 218  : 	}

	jmp	SHORT $LN8@FanLength
$LN9@FanLength:

; 219  : 
; 220  : 	return g_stripcount;

	mov	eax, DWORD PTR _g_stripcount

; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FanLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _StripLength
_TEXT	SEGMENT
_check$ = -24						; size = 4
_last$ = -20						; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_m2$ = -8						; size = 4
_m1$ = -4						; size = 4
_starttri$ = 8						; size = 4
_startv$ = 12						; size = 4
_StripLength PROC					; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 100  : 	int		m1, m2, j, k;
; 101  : 	dtriangle_t	*last, *check;
; 102  : 
; 103  : 	g_used[starttri] = 2;

	mov	eax, DWORD PTR _starttri$[ebp]
	mov	DWORD PTR _g_used[eax*4], 2

; 104  : 
; 105  : 	last = &g_triangles[starttri];

	mov	eax, DWORD PTR _starttri$[ebp]
	shl	eax, 4
	add	eax, OFFSET _g_triangles
	mov	DWORD PTR _last$[ebp], eax

; 106  : 
; 107  : 	g_stripverts[0] = last->vertindex[(startv+0) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _g_stripverts[ecx], edx

; 108  : 	g_stripverts[1] = last->vertindex[(startv+1) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _g_stripverts[eax], edx

; 109  : 	g_stripverts[2] = last->vertindex[(startv+2) % 3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _g_stripverts[eax], edx

; 110  : 
; 111  : 	g_striptris[0] = starttri;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _starttri$[ebp]
	mov	DWORD PTR _g_striptris[ecx], edx

; 112  : 	g_stripcount = 1;

	mov	DWORD PTR _g_stripcount, 1

; 113  : 
; 114  : 	m1 = last->vertindex[(startv+2)%3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m1$[ebp], ecx

; 115  : 	m2 = last->vertindex[(startv+1)%3];

	mov	eax, DWORD PTR _startv$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m2$[ebp], ecx
$nexttri$19:

; 116  : nexttri:
; 117  : 	// look for a matching triangle
; 118  : 	for( j = starttri + 1, check = &g_triangles[starttri + 1]; j < m_pAliasHeader->numtris; j++, check++ )

	mov	eax, DWORD PTR _starttri$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _starttri$[ebp]
	add	ecx, 1
	shl	ecx, 4
	add	ecx, OFFSET _g_triangles
	mov	DWORD PTR _check$[ebp], ecx
	jmp	SHORT $LN4@StripLengt
$LN2@StripLengt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _check$[ebp], ecx
$LN4@StripLengt:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	$done$20

; 119  : 	{
; 120  : 		if( check->facesfront != last->facesfront )

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN11@StripLengt

; 121  : 			continue;

	jmp	SHORT $LN2@StripLengt
$LN11@StripLengt:

; 122  : 
; 123  : 		for( k = 0; k < 3; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN7@StripLengt
$LN5@StripLengt:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN7@StripLengt:
	cmp	DWORD PTR _k$[ebp], 3
	jge	$LN6@StripLengt

; 124  : 		{
; 125  : 			if( check->vertindex[k] != m1 )

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	cmp	edx, DWORD PTR _m1$[ebp]
	je	SHORT $LN12@StripLengt

; 126  : 				continue;

	jmp	SHORT $LN5@StripLengt
$LN12@StripLengt:

; 127  : 			if( check->vertindex[(k+1) % 3] != m2 )

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	cmp	ecx, DWORD PTR _m2$[ebp]
	je	SHORT $LN13@StripLengt

; 128  : 				continue;

	jmp	SHORT $LN5@StripLengt
$LN13@StripLengt:

; 129  : 
; 130  : 			// this is the next part of the fan
; 131  : 
; 132  : 			// if we can't use this triangle, this tristrip is done
; 133  : 			if( g_used[j] ) goto done;

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _g_used[eax*4], 0
	je	SHORT $LN14@StripLengt
	jmp	$done$20
$LN14@StripLengt:

; 134  : 
; 135  : 			// the new edge
; 136  : 			if( g_stripcount & 1 )

	mov	eax, DWORD PTR _g_stripcount
	and	eax, 1
	je	SHORT $LN15@StripLengt

; 137  : 				m2 = check->vertindex[(k+2) % 3];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m2$[ebp], ecx
	jmp	SHORT $LN16@StripLengt
$LN15@StripLengt:

; 138  : 			else m1 = check->vertindex[(k+2) % 3];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	mov	DWORD PTR _m1$[ebp], ecx
$LN16@StripLengt:

; 139  : 
; 140  : 			g_stripverts[g_stripcount+2] = check->vertindex[(k+2) % 3];

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 2
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR _g_stripcount
	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR _g_stripverts[eax*4+8], edx

; 141  : 			g_striptris[g_stripcount] = j;

	mov	eax, DWORD PTR _g_stripcount
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_striptris[eax*4], ecx

; 142  : 			g_stripcount++;

	mov	eax, DWORD PTR _g_stripcount
	add	eax, 1
	mov	DWORD PTR _g_stripcount, eax

; 143  : 
; 144  : 			g_used[j] = 2;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_used[eax*4], 2

; 145  : 			goto nexttri;

	jmp	$nexttri$19

; 146  : 		}

	jmp	$LN5@StripLengt
$LN6@StripLengt:

; 147  : 	}

	jmp	$LN2@StripLengt
$done$20:

; 148  : done:
; 149  : 	// clear the temp used flags
; 150  : 	for( j = starttri + 1; j < m_pAliasHeader->numtris; j++ )

	mov	eax, DWORD PTR _starttri$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN10@StripLengt
$LN8@StripLengt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@StripLengt:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	SHORT $LN9@StripLengt

; 151  : 	{
; 152  : 		if( g_used[j] == 2 )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR _g_used[eax*4], 2
	jne	SHORT $LN17@StripLengt

; 153  : 			g_used[j] = 0;

	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _g_used[eax*4], 0
$LN17@StripLengt:

; 154  : 	}

	jmp	SHORT $LN8@StripLengt
$LN9@StripLengt:

; 155  : 
; 156  : 	return g_stripcount;

	mov	eax, DWORD PTR _g_stripcount

; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_StripLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_UnloadAliasModel
_TEXT	SEGMENT
tv70 = -80						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_palias$ = -4						; size = 4
_mod$ = 8						; size = 4
_Mod_UnloadAliasModel PROC				; COMDAT

; 737  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 738  : 	aliashdr_t	*palias;
; 739  : 	int		i, j;
; 740  : 
; 741  : 	Assert( mod != NULL );

	cmp	DWORD PTR _mod$[ebp], 0
	je	SHORT $LN12@Mod_Unload
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN13@Mod_Unload
$LN12@Mod_Unload:
	mov	DWORD PTR tv70[ebp], 0
$LN13@Mod_Unload:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadAliasModel@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@GOJONOFI@mod?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 742  : 
; 743  : 	if( mod->type != mod_alias )

	mov	eax, DWORD PTR _mod$[ebp]
	cmp	DWORD PTR [eax+68], 2
	je	SHORT $LN8@Mod_Unload

; 744  : 		return; // not an alias

	jmp	$LN1@Mod_Unload
$LN8@Mod_Unload:

; 745  : 
; 746  : 	palias = mod->cache.data;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR _palias$[ebp], ecx

; 747  : 	if( !palias ) return; // already freed

	cmp	DWORD PTR _palias$[ebp], 0
	jne	SHORT $LN9@Mod_Unload
	jmp	$LN1@Mod_Unload
$LN9@Mod_Unload:

; 748  : 
; 749  : 	for( i = 0; i < MAX_SKINS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_Unload
$LN2@Mod_Unload:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_Unload:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $LN3@Mod_Unload

; 750  : 	{
; 751  : 		if( !palias->gl_texturenum[i][0] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _palias$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, 2
	imul	ecx, eax, 0
	movzx	edx, WORD PTR [edx+ecx]
	test	edx, edx
	jne	SHORT $LN10@Mod_Unload

; 752  : 			break;

	jmp	SHORT $LN3@Mod_Unload
$LN10@Mod_Unload:

; 753  : 
; 754  : 		for( j = 0; j < 4; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@Mod_Unload
$LN5@Mod_Unload:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@Mod_Unload:
	cmp	DWORD PTR _j$[ebp], 4
	jge	SHORT $LN6@Mod_Unload

; 755  : 		{
; 756  : 			GL_FreeTexture( palias->gl_texturenum[i][j] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _palias$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 757  : 			GL_FreeTexture( palias->fb_texturenum[i][j] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _palias$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	call	_GL_FreeTexture
	add	esp, 4

; 758  : 		}

	jmp	SHORT $LN5@Mod_Unload
$LN6@Mod_Unload:

; 759  : 	}

	jmp	$LN2@Mod_Unload
$LN3@Mod_Unload:

; 760  : 
; 761  : 	Mem_FreePool( &mod->mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_UnloadAliasModel@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 762  : 	memset( mod, 0, sizeof( *mod ));

	push	392					; 00000188H
	push	0
	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Mod_Unload:

; 763  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_UnloadAliasModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_AliasInit
_TEXT	SEGMENT
_R_AliasInit PROC					; COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 89   : 	g_alias.interpolate = true;

	mov	DWORD PTR _g_alias+20, 1

; 90   : 	m_fDoRemap = false;

	mov	DWORD PTR _m_fDoRemap, 0

; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_AliasInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _R_DrawAliasModel
_TEXT	SEGMENT
tv287 = -176						; size = 4
tv219 = -176						; size = 4
tv212 = -176						; size = 4
tv423 = -172						; size = 4
tv396 = -172						; size = 4
tv286 = -172						; size = 4
tv218 = -172						; size = 4
tv211 = -172						; size = 4
tv150 = -172						; size = 4
tv91 = -172						; size = 4
_bottomcolor$1 = -104					; size = 4
_topcolor$2 = -100					; size = 4
_angles$ = -96						; size = 12
_dir$ = -84						; size = 12
_playerinfo$ = -72					; size = 4
_lighting$ = -68					; size = 24
_skin$ = -44						; size = 4
_anim$ = -40						; size = 4
_pinfo$ = -36						; size = 4
_absmax$ = -32						; size = 12
_absmin$ = -20						; size = 12
_clmodel$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_e$ = 8							; size = 4
_R_DrawAliasModel PROC					; COMDAT

; 1370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1371 : 	model_t		*clmodel;
; 1372 : 	vec3_t		absmin, absmax;
; 1373 : 	remap_info_t	*pinfo = NULL;

	mov	DWORD PTR _pinfo$[ebp], 0

; 1374 : 	int		anim, skin;
; 1375 : 	alight_t		lighting;
; 1376 : 	player_info_t	*playerinfo;
; 1377 : 	vec3_t		dir, angles;
; 1378 : 
; 1379 : 	clmodel = RI.currententity->model;

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	mov	DWORD PTR _clmodel$[ebp], ecx

; 1380 : 
; 1381 : 	VectorAdd( e->origin, clmodel->mins, absmin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _absmin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _absmin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+84]
	movss	DWORD PTR tv91[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv91[ebp]
	movss	DWORD PTR _absmin$[ebp+eax], xmm0

; 1382 : 	VectorAdd( e->origin, clmodel->maxs, absmax );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _absmax$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _absmax$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+96]
	movss	DWORD PTR tv150[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv150[ebp]
	movss	DWORD PTR _absmax$[ebp+eax], xmm0

; 1383 : 
; 1384 : 	if( R_CullModel( e, absmin, absmax ))

	lea	eax, DWORD PTR _absmax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _absmin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_CullModel
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@R_DrawAlia

; 1385 : 		return;

	jmp	$LN1@R_DrawAlia
$LN2@R_DrawAlia:

; 1386 : 
; 1387 : 	//
; 1388 : 	// locate the proper data
; 1389 : 	//
; 1390 : 	m_pAliasHeader = (aliashdr_t *)Mod_AliasExtradata( RI.currententity->model );

	mov	eax, DWORD PTR _RI+28
	mov	ecx, DWORD PTR [eax+3300]
	push	ecx
	call	_Mod_AliasExtradata
	add	esp, 4
	mov	DWORD PTR _m_pAliasHeader, eax

; 1391 : 	if( !m_pAliasHeader ) return;

	cmp	DWORD PTR _m_pAliasHeader, 0
	jne	SHORT $LN3@R_DrawAlia
	jmp	$LN1@R_DrawAlia
$LN3@R_DrawAlia:

; 1392 : 
; 1393 : 	// init time
; 1394 : 	R_AliasSetupTimings();

	call	_R_AliasSetupTimings

; 1395 : 
; 1396 : 	// angles will be modify below keep original
; 1397 : 	VectorCopy( e->angles, angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+3236]
	mov	DWORD PTR _angles$[ebp+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+edx+3236]
	mov	DWORD PTR _angles$[ebp+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+eax+3236]
	mov	DWORD PTR _angles$[ebp+ecx], eax

; 1398 : 
; 1399 : 	R_AliasLerpMovement( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_AliasLerpMovement
	add	esp, 4

; 1400 : 
; 1401 : 	if( !FBitSet( host.features, ENGINE_COMPENSATE_QUAKE_BUG ))

	mov	eax, DWORD PTR _host+34752
	and	eax, 32					; 00000020H
	jne	SHORT $LN4@R_DrawAlia

; 1402 : 		e->angles[PITCH] = -e->angles[PITCH]; // stupid quake bug

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3236]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	movss	DWORD PTR [edx+ecx+3236], xmm0
$LN4@R_DrawAlia:

; 1403 : 
; 1404 : 	// don't rotate clients, only aim
; 1405 : 	if( e->player ) e->angles[PITCH] = 0.0f;

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@R_DrawAlia
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _e$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx+3236], xmm0
$LN5@R_DrawAlia:

; 1406 : 
; 1407 : 	//
; 1408 : 	// get lighting information
; 1409 : 	//
; 1410 : 	lighting.plightvec = dir;

	lea	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR _lighting$[ebp+20], eax

; 1411 : 	R_AliasDynamicLight( e, &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_AliasDynamicLight
	add	esp, 8

; 1412 : 
; 1413 : 	r_stats.c_alias_polys += m_pAliasHeader->numtris;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _r_stats+12
	add	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _r_stats+12, ecx

; 1414 : 	r_stats.c_alias_models_drawn++;

	mov	eax, DWORD PTR _r_stats+28
	add	eax, 1
	mov	DWORD PTR _r_stats+28, eax

; 1415 : 
; 1416 : 	//
; 1417 : 	// draw all the triangles
; 1418 : 	//
; 1419 : 
; 1420 : 	R_RotateForEntity( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_RotateForEntity
	add	esp, 4

; 1421 : 
; 1422 : 	// model and frame independant
; 1423 : 	R_AliasSetupLighting( &lighting );

	lea	eax, DWORD PTR _lighting$[ebp]
	push	eax
	call	_R_AliasSetupLighting
	add	esp, 4

; 1424 : 	GL_SetRenderMode( e->curstate.rendermode );

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	push	ecx
	call	_GL_SetRenderMode
	add	esp, 4

; 1425 : 
; 1426 : 	// setup remapping only for players
; 1427 : 	if( e->player && ( playerinfo = pfnPlayerInfo( e->curstate.number - 1 )) != NULL )

	mov	eax, DWORD PTR _e$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN6@R_DrawAlia
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	sub	ecx, 1
	push	ecx
	call	_pfnPlayerInfo
	add	esp, 4
	mov	DWORD PTR _playerinfo$[ebp], eax
	cmp	DWORD PTR _playerinfo$[ebp], 0
	je	$LN6@R_DrawAlia

; 1428 : 	{
; 1429 : 		// get remap colors
; 1430 : 		int topcolor = bound( 0, playerinfo->topcolor, 13 );

	mov	eax, DWORD PTR _playerinfo$[ebp]
	cmp	DWORD PTR [eax+368], 0
	jl	SHORT $LN21@R_DrawAlia
	mov	ecx, DWORD PTR _playerinfo$[ebp]
	cmp	DWORD PTR [ecx+368], 13			; 0000000dH
	jge	SHORT $LN19@R_DrawAlia
	mov	edx, DWORD PTR _playerinfo$[ebp]
	mov	eax, DWORD PTR [edx+368]
	mov	DWORD PTR tv211[ebp], eax
	jmp	SHORT $LN20@R_DrawAlia
$LN19@R_DrawAlia:
	mov	DWORD PTR tv211[ebp], 13		; 0000000dH
$LN20@R_DrawAlia:
	mov	ecx, DWORD PTR tv211[ebp]
	mov	DWORD PTR tv212[ebp], ecx
	jmp	SHORT $LN22@R_DrawAlia
$LN21@R_DrawAlia:
	mov	DWORD PTR tv212[ebp], 0
$LN22@R_DrawAlia:
	mov	edx, DWORD PTR tv212[ebp]
	mov	DWORD PTR _topcolor$2[ebp], edx

; 1431 : 		int bottomcolor = bound( 0, playerinfo->bottomcolor, 13 );

	mov	eax, DWORD PTR _playerinfo$[ebp]
	cmp	DWORD PTR [eax+372], 0
	jl	SHORT $LN25@R_DrawAlia
	mov	ecx, DWORD PTR _playerinfo$[ebp]
	cmp	DWORD PTR [ecx+372], 13			; 0000000dH
	jge	SHORT $LN23@R_DrawAlia
	mov	edx, DWORD PTR _playerinfo$[ebp]
	mov	eax, DWORD PTR [edx+372]
	mov	DWORD PTR tv218[ebp], eax
	jmp	SHORT $LN24@R_DrawAlia
$LN23@R_DrawAlia:
	mov	DWORD PTR tv218[ebp], 13		; 0000000dH
$LN24@R_DrawAlia:
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR tv219[ebp], ecx
	jmp	SHORT $LN26@R_DrawAlia
$LN25@R_DrawAlia:
	mov	DWORD PTR tv219[ebp], 0
$LN26@R_DrawAlia:
	mov	edx, DWORD PTR tv219[ebp]
	mov	DWORD PTR _bottomcolor$1[ebp], edx

; 1432 : 		R_AliasSetRemapColors( topcolor, bottomcolor );

	mov	eax, DWORD PTR _bottomcolor$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _topcolor$2[ebp]
	push	ecx
	call	_R_AliasSetRemapColors
	add	esp, 8
$LN6@R_DrawAlia:

; 1433 : 	}
; 1434 : 
; 1435 : 	if( tr.fFlipViewModel )

	cmp	DWORD PTR _tr+83216, 0
	je	$LN7@R_DrawAlia

; 1436 : 	{
; 1437 : 		pglTranslatef( m_pAliasHeader->scale_origin[0], -m_pAliasHeader->scale_origin[1], m_pAliasHeader->scale_origin[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	movss	xmm0, DWORD PTR [eax+edx+20]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+20]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1438 : 		pglScalef( m_pAliasHeader->scale[0], -m_pAliasHeader->scale[1], m_pAliasHeader->scale[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	movss	xmm0, DWORD PTR [eax+edx+8]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglScalef

; 1439 : 	}

	jmp	$LN8@R_DrawAlia
$LN7@R_DrawAlia:

; 1440 : 	else
; 1441 : 	{
; 1442 : 		pglTranslatef( m_pAliasHeader->scale_origin[0], m_pAliasHeader->scale_origin[1], m_pAliasHeader->scale_origin[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+20]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+20]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+20]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 1443 : 		pglScalef( m_pAliasHeader->scale[0], m_pAliasHeader->scale[1], m_pAliasHeader->scale[2] );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [ecx+eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _m_pAliasHeader
	push	ecx
	movss	xmm0, DWORD PTR [eax+edx+8]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglScalef
$LN8@R_DrawAlia:

; 1444 : 	}
; 1445 : 
; 1446 : 	anim = (int)(g_alias.time * 10) & 3;

	movsd	xmm0, QWORD PTR _g_alias
	mulsd	xmm0, QWORD PTR __real@4024000000000000
	cvttsd2si eax, xmm0
	and	eax, 3
	mov	DWORD PTR _anim$[ebp], eax

; 1447 : 	skin = bound( 0, RI.currententity->curstate.skin, m_pAliasHeader->numskins - 1 );

	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1048], 0
	jl	SHORT $LN29@R_DrawAlia
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR [ecx+48]
	sub	edx, 1
	mov	eax, DWORD PTR _RI+28
	cmp	DWORD PTR [eax+1048], edx
	jge	SHORT $LN27@R_DrawAlia
	mov	ecx, DWORD PTR _RI+28
	mov	edx, DWORD PTR [ecx+1048]
	mov	DWORD PTR tv286[ebp], edx
	jmp	SHORT $LN28@R_DrawAlia
$LN27@R_DrawAlia:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+48]
	sub	ecx, 1
	mov	DWORD PTR tv286[ebp], ecx
$LN28@R_DrawAlia:
	mov	edx, DWORD PTR tv286[ebp]
	mov	DWORD PTR tv287[ebp], edx
	jmp	SHORT $LN30@R_DrawAlia
$LN29@R_DrawAlia:
	mov	DWORD PTR tv287[ebp], 0
$LN30@R_DrawAlia:
	mov	eax, DWORD PTR tv287[ebp]
	mov	DWORD PTR _skin$[ebp], eax

; 1448 : 	if( m_fDoRemap ) pinfo = CL_GetRemapInfoForEntity( e );

	cmp	DWORD PTR _m_fDoRemap, 0
	je	SHORT $LN9@R_DrawAlia
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_CL_GetRemapInfoForEntity
	add	esp, 4
	mov	DWORD PTR _pinfo$[ebp], eax
$LN9@R_DrawAlia:

; 1449 : 
; 1450 : 	if( r_lightmap->value && !r_fullbright->value )

	mov	eax, DWORD PTR _r_lightmap
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@R_DrawAlia
	mov	eax, DWORD PTR _r_fullbright
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@R_DrawAlia

; 1451 : 		GL_Bind( GL_TEXTURE0, tr.whiteTexture );

	mov	eax, DWORD PTR _tr+8
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8
	jmp	$LN14@R_DrawAlia
$LN10@R_DrawAlia:

; 1452 : 	else if( pinfo != NULL && pinfo->textures[skin] != 0 )

	cmp	DWORD PTR _pinfo$[ebp], 0
	je	SHORT $LN12@R_DrawAlia
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _pinfo$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN12@R_DrawAlia

; 1453 : 		GL_Bind( GL_TEXTURE0, pinfo->textures[skin] );	// FIXME: allow remapping for skingroups someday

	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _pinfo$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2]
	push	edx
	push	0
	call	_GL_Bind
	add	esp, 8
	jmp	SHORT $LN14@R_DrawAlia
$LN12@R_DrawAlia:

; 1454 : 	else
; 1455 : 	{
; 1456 : 		GL_Bind( GL_TEXTURE0, m_pAliasHeader->gl_texturenum[skin][anim] );

	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, DWORD PTR _anim$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	push	0
	call	_GL_Bind
	add	esp, 8

; 1457 : 
; 1458 : 		if( FBitSet( R_GetTexture( m_pAliasHeader->gl_texturenum[skin][anim] )->flags, TF_HAS_ALPHA ))

	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+132]
	mov	eax, DWORD PTR _anim$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	call	_R_GetTexture
	add	esp, 4
	mov	edx, DWORD PTR [eax+284]
	and	edx, 65536				; 00010000H
	je	SHORT $LN14@R_DrawAlia

; 1459 : 		{
; 1460 : 			pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 1461 : 			pglAlphaFunc( GL_GREATER, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1462 : 			tr.blend = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tr+87592, xmm0
$LN14@R_DrawAlia:

; 1463 : 		}
; 1464 : 	}
; 1465 : 
; 1466 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

	push	ecx
	movss	xmm0, DWORD PTR __real@46040000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1467 : 
; 1468 : 	if( GL_Support( GL_ARB_MULTITEXTURE ) && m_pAliasHeader->fb_texturenum[skin][anim] )

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN15@R_DrawAlia
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, DWORD PTR _anim$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	test	ecx, ecx
	je	SHORT $LN15@R_DrawAlia

; 1469 : 	{
; 1470 : 		GL_Bind( GL_TEXTURE1, m_pAliasHeader->fb_texturenum[skin][anim] );

	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, DWORD PTR _anim$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	push	1
	call	_GL_Bind
	add	esp, 8

; 1471 : 		pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_ADD );

	push	ecx
	movss	xmm0, DWORD PTR __real@43820000
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf
$LN15@R_DrawAlia:

; 1472 : 	}
; 1473 : 
; 1474 : 	pglShadeModel( GL_SMOOTH );

	push	7425					; 00001d01H
	call	DWORD PTR _pglShadeModel

; 1475 : 	R_SetupAliasFrame( e, m_pAliasHeader );

	mov	eax, DWORD PTR _m_pAliasHeader
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_R_SetupAliasFrame
	add	esp, 8

; 1476 : 
; 1477 : 	if( GL_Support( GL_ARB_MULTITEXTURE ) && m_pAliasHeader->fb_texturenum[skin][anim] )

	push	4
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@R_DrawAlia
	mov	eax, DWORD PTR _skin$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax*8+388]
	mov	eax, DWORD PTR _anim$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	test	ecx, ecx
	je	SHORT $LN16@R_DrawAlia

; 1478 : 		GL_CleanUpTextureUnits( 1 );

	push	1
	call	_GL_CleanUpTextureUnits
	add	esp, 4
$LN16@R_DrawAlia:

; 1479 : 
; 1480 : 	pglShadeModel( GL_FLAT );

	push	7424					; 00001d00H
	call	DWORD PTR _pglShadeModel

; 1481 : 	R_LoadIdentity();

	call	_R_LoadIdentity

; 1482 : 
; 1483 : 	// get lerped origin
; 1484 : 	VectorAdd( e->origin, clmodel->mins, absmin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _absmin$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+84]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _absmin$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+84]
	movss	DWORD PTR tv396[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv396[ebp]
	movss	DWORD PTR _absmin$[ebp+eax], xmm0

; 1485 : 	VectorAdd( e->origin, clmodel->maxs, absmax );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _absmax$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [ecx+edx+3224]
	addss	xmm0, DWORD PTR [esi+eax+96]
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _absmax$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	esi, DWORD PTR _clmodel$[ebp]
	movss	xmm0, DWORD PTR [edx+eax+3224]
	addss	xmm0, DWORD PTR [esi+ecx+96]
	movss	DWORD PTR tv423[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR tv423[ebp]
	movss	DWORD PTR _absmax$[ebp+eax], xmm0

; 1486 : 
; 1487 : 	R_AliasDrawAbsBBox( e, absmin, absmax );

	lea	eax, DWORD PTR _absmax$[ebp]
	push	eax
	lea	ecx, DWORD PTR _absmin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	_R_AliasDrawAbsBBox
	add	esp, 12					; 0000000cH

; 1488 : 	R_AliasDrawLightTrace( e );

	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	_R_AliasDrawLightTrace
	add	esp, 4

; 1489 : 
; 1490 : 	pglTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	ecx
	movss	xmm0, DWORD PTR __real@45f00800
	movss	DWORD PTR [esp], xmm0
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvf

; 1491 : 	pglAlphaFunc( GL_GREATER, DEFAULT_ALPHATEST );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	516					; 00000204H
	call	DWORD PTR _pglAlphaFunc

; 1492 : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 1493 : 
; 1494 : 	if( r_shadows.value )

	movss	xmm0, DWORD PTR _r_shadows+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN17@R_DrawAlia

; 1495 : 	{
; 1496 : 		// need to compute transformation matrix
; 1497 : 		Matrix4x4_CreateFromEntity( RI.objectMatrix, e->angles, e->origin, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 3224				; 00000c98H
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 3236				; 00000ca4H
	push	ecx
	push	OFFSET _RI+456
	call	_Matrix4x4_CreateFromEntity
	add	esp, 16					; 00000010H

; 1498 : 		pglDisable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglDisable

; 1499 : 		pglBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR _pglBlendFunc

; 1500 : 		pglEnable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglEnable

; 1501 : 		pglColor4f( 0.0f, 0.0f, 0.0f, 0.5f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1502 : 		pglDepthFunc( GL_LESS );

	push	513					; 00000201H
	call	DWORD PTR _pglDepthFunc

; 1503 : 
; 1504 : 		GL_DrawAliasShadow( m_pAliasHeader );

	mov	eax, DWORD PTR _m_pAliasHeader
	push	eax
	call	_GL_DrawAliasShadow
	add	esp, 4

; 1505 : 
; 1506 : 		pglDepthFunc( GL_LEQUAL );

	push	515					; 00000203H
	call	DWORD PTR _pglDepthFunc

; 1507 : 		pglEnable( GL_TEXTURE_2D );

	push	3553					; 00000de1H
	call	DWORD PTR _pglEnable

; 1508 : 		pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 1509 : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 1510 : 		R_LoadIdentity();

	call	_R_LoadIdentity
$LN17@R_DrawAlia:

; 1511 : 	}
; 1512 : 
; 1513 : 	// restore original angles
; 1514 : 	VectorCopy( angles, e->angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _angles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+3236], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _angles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+3236], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _angles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+3236], eax
$LN1@R_DrawAlia:

; 1515 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawAliasModel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_alias.c
;	COMDAT _Mod_LoadAliasModel
_TEXT	SEGMENT
_frametype$1 = -36					; size = 4
_size$ = -32						; size = 4
_j$ = -28						; size = 4
_i$ = -24						; size = 4
_pskintype$ = -20					; size = 4
_pframetype$ = -16					; size = 4
_pintriangles$ = -12					; size = 4
_pinstverts$ = -8					; size = 4
_pinmodel$ = -4						; size = 4
_mod$ = 8						; size = 4
_buffer$ = 12						; size = 4
_loaded$ = 16						; size = 4
_Mod_LoadAliasModel PROC				; COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 624  : 	daliashdr_t	*pinmodel;
; 625  : 	stvert_t		*pinstverts;
; 626  : 	dtriangle_t	*pintriangles;
; 627  : 	daliasframetype_t	*pframetype;
; 628  : 	daliasskintype_t	*pskintype;
; 629  : 	int		i, j, size;
; 630  : 
; 631  : 	if( loaded ) *loaded = false;

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN17@Mod_LoadAl
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN17@Mod_LoadAl:

; 632  : 	pinmodel = (daliashdr_t *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _pinmodel$[ebp], eax

; 633  : 	i = pinmodel->version;

	mov	eax, DWORD PTR _pinmodel$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx

; 634  : 
; 635  : 	if( i != ALIAS_VERSION )

	cmp	DWORD PTR _i$[ebp], 6
	je	SHORT $LN18@Mod_LoadAl

; 636  : 	{
; 637  : 		Con_DPrintf( S_ERROR "%s has wrong version number (%i should be %i)\n", mod->name, i, ALIAS_VERSION );

	push	6
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DK@DGDPMGLF@?$FO1Error?3?$FO7?5?$CFs?5has?5wrong?5version@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H

; 638  : 		return;

	jmp	$LN24@Mod_LoadAl
$LN18@Mod_LoadAl:

; 639  : 	}
; 640  : 
; 641  : 	if( pinmodel->numverts <= 0 || pinmodel->numtris <= 0 || pinmodel->numframes <= 0 )

	mov	eax, DWORD PTR _pinmodel$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jle	SHORT $LN20@Mod_LoadAl
	mov	eax, DWORD PTR _pinmodel$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jle	SHORT $LN20@Mod_LoadAl
	mov	eax, DWORD PTR _pinmodel$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jg	SHORT $LN19@Mod_LoadAl
$LN20@Mod_LoadAl:

; 642  : 		return; // how to possible is make that?

	jmp	$LN24@Mod_LoadAl
$LN19@Mod_LoadAl:

; 643  : 
; 644  : 	mod->mempool = Mem_AllocPool( va( "^2%s^7", mod->name ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadAliasModel@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	push	OFFSET ??_C@_06NOEFBIEF@?$FO2?$CFs?$FO7@
	call	_va
	add	esp, 8
	push	eax
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [edx+76], eax

; 645  : 
; 646  : 	// allocate space for a working header, plus all the data except the frames,
; 647  : 	// skin and group info
; 648  : 	size = sizeof( aliashdr_t ) + (pinmodel->numframes - 1) * sizeof( maliasframedesc_t );

	mov	eax, DWORD PTR _pinmodel$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	sub	ecx, 1
	imul	edx, ecx, 36
	add	edx, 1448				; 000005a8H
	mov	DWORD PTR _size$[ebp], edx

; 649  : 
; 650  : 	m_pAliasHeader = Mem_Calloc( mod->mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Mod_LoadAliasModel@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DF@JEBANBEJ@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mod$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _m_pAliasHeader, eax

; 651  : 	mod->flags = pinmodel->flags;	// share effects flags

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+80], edx

; 652  : 
; 653  : 	// endian-adjust and copy the data, starting with the alias model header
; 654  : 	m_pAliasHeader->boundingradius = pinmodel->boundingradius;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 655  : 	m_pAliasHeader->numskins = pinmodel->numskins;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx

; 656  : 	m_pAliasHeader->skinwidth = pinmodel->skinwidth;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx

; 657  : 	m_pAliasHeader->skinheight = pinmodel->skinheight;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx

; 658  : 	m_pAliasHeader->numverts = pinmodel->numverts;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx

; 659  : 	m_pAliasHeader->numtris = pinmodel->numtris;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx

; 660  : 	m_pAliasHeader->numframes = pinmodel->numframes;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx

; 661  : 
; 662  : 	if( m_pAliasHeader->numverts > MAXALIASVERTS )

	mov	eax, DWORD PTR _m_pAliasHeader
	cmp	DWORD PTR [eax+60], 2048		; 00000800H
	jle	SHORT $LN21@Mod_LoadAl

; 663  : 	{
; 664  : 		Con_DPrintf( S_ERROR "model %s has too many vertices\n", mod->name );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@OBGJMAHN@?$FO1Error?3?$FO7?5model?5?$CFs?5has?5too?5man@
	call	_Con_DPrintf
	add	esp, 8

; 665  : 		return;

	jmp	$LN24@Mod_LoadAl
$LN21@Mod_LoadAl:

; 666  : 	}
; 667  : 
; 668  : 	m_pAliasHeader->size = pinmodel->size;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx

; 669  : //	mod->synctype = pinmodel->synctype;
; 670  : 	mod->numframes = m_pAliasHeader->numframes;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+72], edx

; 671  : 
; 672  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Mod_LoadAl
$LN2@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Mod_LoadAl:
	cmp	DWORD PTR _i$[ebp], 3
	jge	SHORT $LN3@Mod_LoadAl

; 673  : 	{
; 674  : 		m_pAliasHeader->scale[i] = pinmodel->scale[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+8]
	mov	DWORD PTR [ecx+eax*4+8], edx

; 675  : 		m_pAliasHeader->scale_origin[i] = pinmodel->scale_origin[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+20]
	mov	DWORD PTR [ecx+eax*4+20], edx

; 676  : 		m_pAliasHeader->eyeposition[i] = pinmodel->eyeposition[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _pinmodel$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+36]
	mov	DWORD PTR [ecx+eax*4+36], edx

; 677  : 	}

	jmp	SHORT $LN2@Mod_LoadAl
$LN3@Mod_LoadAl:

; 678  : 
; 679  : 	// load the skins
; 680  : 	pskintype = (daliasskintype_t *)&pinmodel[1];

	mov	eax, 84					; 00000054H
	shl	eax, 0
	add	eax, DWORD PTR _pinmodel$[ebp]
	mov	DWORD PTR _pskintype$[ebp], eax

; 681  : 	pskintype = Mod_LoadAllSkins( m_pAliasHeader->numskins, pskintype );

	mov	eax, DWORD PTR _pskintype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	_Mod_LoadAllSkins
	add	esp, 8
	mov	DWORD PTR _pskintype$[ebp], eax

; 682  : 
; 683  : 	// load base s and t vertices
; 684  : 	pinstverts = (stvert_t *)pskintype;

	mov	eax, DWORD PTR _pskintype$[ebp]
	mov	DWORD PTR _pinstverts$[ebp], eax

; 685  : 
; 686  : 	for( i = 0; i < m_pAliasHeader->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Mod_LoadAl
$LN5@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Mod_LoadAl:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+60]
	jge	SHORT $LN6@Mod_LoadAl

; 687  : 	{
; 688  : 		g_stverts[i].onseam = pinstverts[i].onseam;

	imul	eax, DWORD PTR _i$[ebp], 12
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _pinstverts$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _g_stverts[ecx], eax

; 689  : 		g_stverts[i].s = pinstverts[i].s;

	imul	eax, DWORD PTR _i$[ebp], 12
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _pinstverts$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _g_stverts[ecx+4], eax

; 690  : 		g_stverts[i].t = pinstverts[i].t;

	imul	eax, DWORD PTR _i$[ebp], 12
	imul	ecx, DWORD PTR _i$[ebp], 12
	mov	edx, DWORD PTR _pinstverts$[ebp]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR _g_stverts[ecx+8], eax

; 691  : 	}

	jmp	SHORT $LN5@Mod_LoadAl
$LN6@Mod_LoadAl:

; 692  : 
; 693  : 	// load triangle lists
; 694  : 	pintriangles = (dtriangle_t *)&pinstverts[m_pAliasHeader->numverts];

	mov	eax, DWORD PTR _m_pAliasHeader
	imul	ecx, DWORD PTR [eax+60], 12
	add	ecx, DWORD PTR _pinstverts$[ebp]
	mov	DWORD PTR _pintriangles$[ebp], ecx

; 695  : 
; 696  : 	for( i = 0; i < m_pAliasHeader->numtris; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@Mod_LoadAl
$LN8@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@Mod_LoadAl:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jge	SHORT $LN9@Mod_LoadAl

; 697  : 	{
; 698  : 		g_triangles[i].facesfront = pintriangles[i].facesfront;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _pintriangles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _g_triangles[ecx], eax

; 699  : 
; 700  : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@Mod_LoadAl
$LN11@Mod_LoadAl:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@Mod_LoadAl:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $LN12@Mod_LoadAl

; 701  : 			g_triangles[i].vertindex[j] = pintriangles[i].vertindex[j];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _pintriangles$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+esi*4+4]
	mov	DWORD PTR _g_triangles[ecx+edx*4+4], eax
	jmp	SHORT $LN11@Mod_LoadAl
$LN12@Mod_LoadAl:

; 702  : 	}

	jmp	SHORT $LN8@Mod_LoadAl
$LN9@Mod_LoadAl:

; 703  : 
; 704  : 	// load the frames
; 705  : 	pframetype = (daliasframetype_t *)&pintriangles[m_pAliasHeader->numtris];

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR [eax+64]
	shl	ecx, 4
	add	ecx, DWORD PTR _pintriangles$[ebp]
	mov	DWORD PTR _pframetype$[ebp], ecx

; 706  : 	g_posenum = 0;

	mov	DWORD PTR _g_posenum, 0

; 707  : 
; 708  : 	for( i = 0; i < m_pAliasHeader->numframes; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Mod_LoadAl
$LN14@Mod_LoadAl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Mod_LoadAl:
	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jge	SHORT $LN15@Mod_LoadAl

; 709  : 	{
; 710  : 		aliasframetype_t	frametype = pframetype->type;

	mov	eax, DWORD PTR _pframetype$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _frametype$1[ebp], ecx

; 711  : 
; 712  : 		if( frametype == ALIAS_SINGLE )

	cmp	DWORD PTR _frametype$1[ebp], 0
	jne	SHORT $LN22@Mod_LoadAl

; 713  : 			pframetype = (daliasframetype_t *)Mod_LoadAliasFrame( pframetype + 1, &m_pAliasHeader->frames[i] );

	imul	eax, DWORD PTR _i$[ebp], 36
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax+1412]
	push	edx
	mov	eax, DWORD PTR _pframetype$[ebp]
	add	eax, 4
	push	eax
	call	_Mod_LoadAliasFrame
	add	esp, 8
	mov	DWORD PTR _pframetype$[ebp], eax
	jmp	SHORT $LN23@Mod_LoadAl
$LN22@Mod_LoadAl:

; 714  : 		else pframetype = (daliasframetype_t *)Mod_LoadAliasGroup( pframetype + 1, &m_pAliasHeader->frames[i] );

	imul	eax, DWORD PTR _i$[ebp], 36
	mov	ecx, DWORD PTR _m_pAliasHeader
	lea	edx, DWORD PTR [ecx+eax+1412]
	push	edx
	mov	eax, DWORD PTR _pframetype$[ebp]
	add	eax, 4
	push	eax
	call	_Mod_LoadAliasGroup
	add	esp, 8
	mov	DWORD PTR _pframetype$[ebp], eax
$LN23@Mod_LoadAl:

; 715  : 	}

	jmp	SHORT $LN14@Mod_LoadAl
$LN15@Mod_LoadAl:

; 716  : 
; 717  : 	m_pAliasHeader->numposes = g_posenum;

	mov	eax, DWORD PTR _m_pAliasHeader
	mov	ecx, DWORD PTR _g_posenum
	mov	DWORD PTR [eax+116], ecx

; 718  : 
; 719  : 	Mod_CalcAliasBounds( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_Mod_CalcAliasBounds
	add	esp, 4

; 720  : 	mod->type = mod_alias;

	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [eax+68], 2

; 721  : 
; 722  : 	// build the draw lists
; 723  : 	GL_MakeAliasModelDisplayLists( mod );

	mov	eax, DWORD PTR _mod$[ebp]
	push	eax
	call	_GL_MakeAliasModelDisplayLists
	add	esp, 4

; 724  : 
; 725  : 	// move the complete, relocatable alias model to the cache
; 726  : 	loadmodel->cache.data = m_pAliasHeader;

	mov	eax, DWORD PTR _loadmodel
	mov	ecx, DWORD PTR _m_pAliasHeader
	mov	DWORD PTR [eax+388], ecx

; 727  : 
; 728  : 	if( loaded ) *loaded = true;	// done

	cmp	DWORD PTR _loaded$[ebp], 0
	je	SHORT $LN24@Mod_LoadAl
	mov	eax, DWORD PTR _loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN24@Mod_LoadAl:

; 729  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Mod_LoadAliasModel ENDP
_TEXT	ENDS
END
