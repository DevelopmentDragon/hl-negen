; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cmd.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_cmd_wait:DWORD
COMM	_cmd_text:BYTE:0cH
COMM	_cmd_text_buf:BYTE:010000H
COMM	_cmd_alias:DWORD
COMM	_cmd_condition:DWORD
COMM	_cmd_condlevel:DWORD
_DATA	ENDS
PUBLIC	_Cbuf_Init
PUBLIC	_Cbuf_Clear
PUBLIC	_Cbuf_AddText
PUBLIC	_Cbuf_InsertText
PUBLIC	_Cbuf_ExecStuffCmds
PUBLIC	_Cbuf_Execute
PUBLIC	_Cmd_Argc
PUBLIC	_Cmd_Args
PUBLIC	_Cmd_Argv
PUBLIC	_Cmd_Init
PUBLIC	_Cmd_Unlink
PUBLIC	_Cmd_AddCommand
PUBLIC	_Cmd_AddServerCommand
PUBLIC	_Cmd_AddClientCommand
PUBLIC	_Cmd_AddGameUICommand
PUBLIC	_Cmd_RemoveCommand
PUBLIC	_Cmd_Exists
PUBLIC	_Cmd_LookupCmds
PUBLIC	_Cmd_TokenizeString
PUBLIC	_Cmd_ExecuteString
PUBLIC	_Cmd_ForwardToServer
PUBLIC	_Cmd_Null_f
PUBLIC	_Cbuf_GetSpace
PUBLIC	_Cmd_StuffCmds_f
PUBLIC	_Cmd_Wait_f
PUBLIC	_Cmd_Echo_f
PUBLIC	_Cmd_Alias_f
PUBLIC	_Cmd_If_f
PUBLIC	_Cmd_Else_f
PUBLIC	_Cmd_List_f
PUBLIC	??_C@_0BJ@CIOHDACP@Cbuf_GetSpace?3?5overflow?6@	; `string'
PUBLIC	??_C@_0CF@OCNJCEGP@?$FO3Warning?3?$FO7?5Cbuf_AddText?3?5over@ ; `string'
PUBLIC	??_C@_0CI@OFNEIEPG@?$FO3Warning?3?$FO7?5Cbuf_InsertText?3?5o@ ; `string'
PUBLIC	??_C@_0DC@BCFOHFGH@?$FO1Error?3?$FO7?5Cbuf_Execute?3?5comman@ ; `string'
PUBLIC	??_C@_09CCCNFKCN@stuffcmds@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	?__LINE__Var@?0??Cmd_Alias_f@@9@9		; `Cmd_Alias_f'::`1'::__LINE__Var
PUBLIC	??_C@_0BJ@GLKEFIHM@Current?5alias?5commands?3?6@ ; `string'
PUBLIC	??_C@_0BB@EOJLLEDG@?$FO2?$CFs?$FO7?5?3?5?$FO3?$CFs?$FO7?6@ ; `string'
PUBLIC	??_C@_0BI@MCCCFJOE@Alias?5name?5is?5too?5long?6@ ; `string'
PUBLIC	??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	?__LINE__Var@?0??Cmd_UnAlias_f@@9@9		; `Cmd_UnAlias_f'::`1'::__LINE__Var
PUBLIC	??_C@_0CE@JMDNPNJG@Usage?3?5unalias?5alias1?5?$FLalias2?5?4@ ; `string'
PUBLIC	??_C@_0O@EAMFOJNK@?$CFs?5not?5found?6@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?__LINE__Var@?0??Cmd_TokenizeString@@9@9	; `Cmd_TokenizeString'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??Cmd_AddCommand@@9@9		; `Cmd_AddCommand'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@HOHANNMH@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@ ; `string'
PUBLIC	??_C@_0CP@HKJBNAGP@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@ ; `string'
PUBLIC	?__LINE__Var@?0??Cmd_AddServerCommand@@9@9	; `Cmd_AddServerCommand'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@EMMODOMG@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@ ; `string'
PUBLIC	??_C@_0DF@BDCGNJBO@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@ ; `string'
PUBLIC	??_C@_0P@EBHCEBON@server?5command@		; `string'
PUBLIC	?__LINE__Var@?0??Cmd_AddClientCommand@@9@9	; `Cmd_AddClientCommand'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@CGGHKOBF@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@ ; `string'
PUBLIC	??_C@_0DF@FABHCDHB@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@ ; `string'
PUBLIC	??_C@_0P@KNDBPAJE@client?5command@		; `string'
PUBLIC	?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9	; `Cmd_AddGameUICommand'::`1'::__LINE__Var
PUBLIC	??_C@_0DO@MGNIHGGC@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@ ; `string'
PUBLIC	??_C@_0DF@KDOLHCKF@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@ ; `string'
PUBLIC	??_C@_0P@EOINHEHE@GameUI?5command@		; `string'
PUBLIC	?__LINE__Var@?0??Cmd_RemoveCommand@@9@9		; `Cmd_RemoveCommand'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@HPNNAJHD@Usage?3?5if?5?$DMop1?$DO?5?$FL?5?$DMoperator?$DO?5?$DMo@ ; `string'
PUBLIC	??_C@_0M@HGJGLBCK@?3?$DMaction1?$DO?6@		; `string'
PUBLIC	??_C@_0M@GECDBOME@?3?$DMaction2?$DO?6@		; `string'
PUBLIC	??_C@_05IHLPLEMK@else?6@			; `string'
PUBLIC	??_C@_0M@NMJPHJKB@?3?$DMaction3?$DO?6@		; `string'
PUBLIC	??_C@_0CF@GEMMIBOF@operands?5are?5string?5or?5float?5va@ ; `string'
PUBLIC	??_C@_0CF@ODPFLMJH@and?5substituted?5cvars?5like?5?8$cl@ ; `string'
PUBLIC	??_C@_0DG@NKPEPCAM@operator?5is?5?8?$DN?8?8?0?5?8?$DN?$DN?8?0?5?8?$DO?8?0?5?8?$DM@ ; `string'
PUBLIC	??_C@_04MGEIEJAD@exec@				; `string'
PUBLIC	??_C@_0BA@HFMOEDOL@host_gameloaded@		; `string'
PUBLIC	??_C@_0CD@NMMIHOJO@?$FO3Warning?3?$FO7?5Unknown?5command?5?$CC?$CF@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_07BANLMPIG@setinfo@			; `string'
PUBLIC	??_C@_0BL@HFMAFAHP@Can?8t?5?$CC?$CFs?$CC?0?5not?5connected?6@ ; `string'
PUBLIC	??_C@_03LGLGIONO@cmd@				; `string'
PUBLIC	??_C@_0O@PAHOIENE@?5?$CF?9?$CKs?5?$FO3?$CFs?$FO7?6@ ; `string'
PUBLIC	??_C@_0N@IIIOLKJI@?$CFi?5commands?6@		; `string'
PUBLIC	?__LINE__Var@?0??Cmd_Unlink@@9@9		; `Cmd_Unlink'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@CKKMCGJ@host_clientloaded@		; `string'
PUBLIC	??_C@_0BC@CFEOCCMF@host_gameuiloaded@		; `string'
PUBLIC	??_C@_0BE@DCJKOCHK@unlink?5?$CFi?5commands?6@	; `string'
PUBLIC	??_C@_0DD@HOLPNNNB@print?5a?5message?5to?5the?5console?5@ ; `string'
PUBLIC	??_C@_04OFDNEFMC@echo@				; `string'
PUBLIC	??_C@_0DE@MEIKPKCK@make?5script?5execution?5wait?5for?5@ ; `string'
PUBLIC	??_C@_04PNOAOIAG@wait@				; `string'
PUBLIC	??_C@_0EB@OAEACPLJ@display?5all?5console?5commands?5be@ ; `string'
PUBLIC	??_C@_07LKLFKPJJ@cmdlist@			; `string'
PUBLIC	??_C@_0DP@EFBHGBPO@execute?5commandline?5parameters?5@ ; `string'
PUBLIC	??_C@_0CJ@DIAGANNE@send?5a?5console?5commandline?5to?5t@ ; `string'
PUBLIC	??_C@_0EH@OJMKBLHF@create?5a?5script?5function?4?5Witho@ ; `string'
PUBLIC	??_C@_05NKHOCLEE@alias@				; `string'
PUBLIC	??_C@_0BJ@FDJGDOFM@remove?5a?5script?5function@	; `string'
PUBLIC	??_C@_07DBKHPNMC@unalias@			; `string'
PUBLIC	??_C@_0BP@FPBPAFLB@compare?5and?5set?5condition?5bits@ ; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_0BF@CAMMAINI@invert?5condition?5bit@	; `string'
PUBLIC	??_C@_04FHMCPBIP@else@				; `string'
PUBLIC	__real@00000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	__copystring:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_stricmpext:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_Cvar_VariableString:PROC
EXTRN	_Cvar_Command:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	_MSG_WriteCmdExt:PROC
EXTRN	_MSG_WriteString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_cmd_scripting:DWORD
EXTRN	_host:BYTE
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_cmd_argc DD	01H DUP (?)
_cmd_args DD	01H DUP (?)
_cmd_argv DD	050H DUP (?)
_cmd_functions DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_04FHMCPBIP@else@
CONST	SEGMENT
??_C@_04FHMCPBIP@else@ DB 'else', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CAMMAINI@invert?5condition?5bit@
CONST	SEGMENT
??_C@_0BF@CAMMAINI@invert?5condition?5bit@ DB 'invert condition bit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FPBPAFLB@compare?5and?5set?5condition?5bits@
CONST	SEGMENT
??_C@_0BP@FPBPAFLB@compare?5and?5set?5condition?5bits@ DB 'compare and se'
	DB	't condition bits', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBKHPNMC@unalias@
CONST	SEGMENT
??_C@_07DBKHPNMC@unalias@ DB 'unalias', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDJGDOFM@remove?5a?5script?5function@
CONST	SEGMENT
??_C@_0BJ@FDJGDOFM@remove?5a?5script?5function@ DB 'remove a script funct'
	DB	'ion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKHOCLEE@alias@
CONST	SEGMENT
??_C@_05NKHOCLEE@alias@ DB 'alias', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OJMKBLHF@create?5a?5script?5function?4?5Witho@
CONST	SEGMENT
??_C@_0EH@OJMKBLHF@create?5a?5script?5function?4?5Witho@ DB 'create a scr'
	DB	'ipt function. Without arguments show the list of all alias', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DIAGANNE@send?5a?5console?5commandline?5to?5t@
CONST	SEGMENT
??_C@_0CJ@DIAGANNE@send?5a?5console?5commandline?5to?5t@ DB 'send a conso'
	DB	'le commandline to the server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@EFBHGBPO@execute?5commandline?5parameters?5@
CONST	SEGMENT
??_C@_0DP@EFBHGBPO@execute?5commandline?5parameters?5@ DB 'execute comman'
	DB	'dline parameters (must be present in .rc script)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKLFKPJJ@cmdlist@
CONST	SEGMENT
??_C@_07LKLFKPJJ@cmdlist@ DB 'cmdlist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@OAEACPLJ@display?5all?5console?5commands?5be@
CONST	SEGMENT
??_C@_0EB@OAEACPLJ@display?5all?5console?5commands?5be@ DB 'display all c'
	DB	'onsole commands beginning with the specified prefix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PNOAOIAG@wait@
CONST	SEGMENT
??_C@_04PNOAOIAG@wait@ DB 'wait', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MEIKPKCK@make?5script?5execution?5wait?5for?5@
CONST	SEGMENT
??_C@_0DE@MEIKPKCK@make?5script?5execution?5wait?5for?5@ DB 'make script '
	DB	'execution wait for some rendered frames', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFDNEFMC@echo@
CONST	SEGMENT
??_C@_04OFDNEFMC@echo@ DB 'echo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HOLPNNNB@print?5a?5message?5to?5the?5console?5@
CONST	SEGMENT
??_C@_0DD@HOLPNNNB@print?5a?5message?5to?5the?5console?5@ DB 'print a mes'
	DB	'sage to the console (useful in scripts)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCJKOCHK@unlink?5?$CFi?5commands?6@
CONST	SEGMENT
??_C@_0BE@DCJKOCHK@unlink?5?$CFi?5commands?6@ DB 'unlink %i commands', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CFEOCCMF@host_gameuiloaded@
CONST	SEGMENT
??_C@_0BC@CFEOCCMF@host_gameuiloaded@ DB 'host_gameuiloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CKKMCGJ@host_clientloaded@
CONST	SEGMENT
??_C@_0BC@CKKMCGJ@host_clientloaded@ DB 'host_clientloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_Unlink@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_Unlink@@9@9 DD 042bH		; `Cmd_Unlink'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@IIIOLKJI@?$CFi?5commands?6@
CONST	SEGMENT
??_C@_0N@IIIOLKJI@?$CFi?5commands?6@ DB '%i commands', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PAHOIENE@?5?$CF?9?$CKs?5?$FO3?$CFs?$FO7?6@
CONST	SEGMENT
??_C@_0O@PAHOIENE@?5?$CF?9?$CKs?5?$FO3?$CFs?$FO7?6@ DB ' %-*s ^3%s^7', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGLGIONO@cmd@
CONST	SEGMENT
??_C@_03LGLGIONO@cmd@ DB 'cmd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HFMAFAHP@Can?8t?5?$CC?$CFs?$CC?0?5not?5connected?6@
CONST	SEGMENT
??_C@_0BL@HFMAFAHP@Can?8t?5?$CC?$CFs?$CC?0?5not?5connected?6@ DB 'Can''t '
	DB	'"%s", not connected', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BANLMPIG@setinfo@
CONST	SEGMENT
??_C@_07BANLMPIG@setinfo@ DB 'setinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NMMIHOJO@?$FO3Warning?3?$FO7?5Unknown?5command?5?$CC?$CF@
CONST	SEGMENT
??_C@_0CD@NMMIHOJO@?$FO3Warning?3?$FO7?5Unknown?5command?5?$CC?$CF@ DB '^'
	DB	'3Warning:^7 Unknown command "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HFMOEDOL@host_gameloaded@
CONST	SEGMENT
??_C@_0BA@HFMOEDOL@host_gameloaded@ DB 'host_gameloaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGEIEJAD@exec@
CONST	SEGMENT
??_C@_04MGEIEJAD@exec@ DB 'exec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NKPEPCAM@operator?5is?5?8?$DN?8?8?0?5?8?$DN?$DN?8?0?5?8?$DO?8?0?5?8?$DM@
CONST	SEGMENT
??_C@_0DG@NKPEPCAM@operator?5is?5?8?$DN?8?8?0?5?8?$DN?$DN?8?0?5?8?$DO?8?0?5?8?$DM@ DB 'o'
	DB	'perator is ''='''', ''=='', ''>'', ''<'', ''>='', ''<='' or '''
	DB	'!=''', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ODPFLMJH@and?5substituted?5cvars?5like?5?8$cl@
CONST	SEGMENT
??_C@_0CF@ODPFLMJH@and?5substituted?5cvars?5like?5?8$cl@ DB 'and substitu'
	DB	'ted cvars like ''$cl_lw''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GEMMIBOF@operands?5are?5string?5or?5float?5va@
CONST	SEGMENT
??_C@_0CF@GEMMIBOF@operands?5are?5string?5or?5float?5va@ DB 'operands are'
	DB	' string or float values', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMJPHJKB@?3?$DMaction3?$DO?6@
CONST	SEGMENT
??_C@_0M@NMJPHJKB@?3?$DMaction3?$DO?6@ DB ':<action3>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHLPLEMK@else?6@
CONST	SEGMENT
??_C@_05IHLPLEMK@else?6@ DB 'else', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GECDBOME@?3?$DMaction2?$DO?6@
CONST	SEGMENT
??_C@_0M@GECDBOME@?3?$DMaction2?$DO?6@ DB ':<action2>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HGJGLBCK@?3?$DMaction1?$DO?6@
CONST	SEGMENT
??_C@_0M@HGJGLBCK@?3?$DMaction1?$DO?6@ DB ':<action1>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPNNAJHD@Usage?3?5if?5?$DMop1?$DO?5?$FL?5?$DMoperator?$DO?5?$DMo@
CONST	SEGMENT
??_C@_0CG@HPNNAJHD@Usage?3?5if?5?$DMop1?$DO?5?$FL?5?$DMoperator?$DO?5?$DMo@ DB 'U'
	DB	'sage: if <op1> [ <operator> <op2> ]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_RemoveCommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_RemoveCommand@@9@9 DD 02dbH	; `Cmd_RemoveCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@EOINHEHE@GameUI?5command@
CONST	SEGMENT
??_C@_0P@EOINHEHE@GameUI?5command@ DB 'GameUI command', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KDOLHCKF@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@
CONST	SEGMENT
??_C@_0DF@KDOLHCKF@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@ DB '^1Error:^'
	DB	'7 Cmd_AddGameUICommand: %s already defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MGNIHGGC@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@
CONST	SEGMENT
??_C@_0DO@MGNIHGGC@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@ DB '^1Error:^'
	DB	'7 Cmd_AddGameUICommand: %s already defined as a var', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9 DD 02b0H	; `Cmd_AddGameUICommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@KNDBPAJE@client?5command@
CONST	SEGMENT
??_C@_0P@KNDBPAJE@client?5command@ DB 'client command', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FABHCDHB@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@
CONST	SEGMENT
??_C@_0DF@FABHCDHB@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@ DB '^1Error:^'
	DB	'7 Cmd_AddClientCommand: %s already defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CGGHKOBF@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@
CONST	SEGMENT
??_C@_0DO@CGGHKOBF@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@ DB '^1Error:^'
	DB	'7 Cmd_AddClientCommand: %s already defined as a var', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_AddClientCommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_AddClientCommand@@9@9 DD 0285H	; `Cmd_AddClientCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@EBHCEBON@server?5command@
CONST	SEGMENT
??_C@_0P@EBHCEBON@server?5command@ DB 'server command', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BDCGNJBO@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@
CONST	SEGMENT
??_C@_0DF@BDCGNJBO@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@ DB '^1Error:^'
	DB	'7 Cmd_AddServerCommand: %s already defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EMMODOMG@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@
CONST	SEGMENT
??_C@_0DO@EMMODOMG@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@ DB '^1Error:^'
	DB	'7 Cmd_AddServerCommand: %s already defined as a var', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_AddServerCommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_AddServerCommand@@9@9 DD 025cH	; `Cmd_AddServerCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CP@HKJBNAGP@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@
CONST	SEGMENT
??_C@_0CP@HKJBNAGP@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@ DB '^1E'
	DB	'rror:^7 Cmd_AddCommand: %s already defined', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HOHANNMH@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@
CONST	SEGMENT
??_C@_0DI@HOHANNMH@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@ DB '^1E'
	DB	'rror:^7 Cmd_AddCommand: %s already defined as a var', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_AddCommand@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_AddCommand@@9@9 DD 0236H		; `Cmd_AddCommand'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_TokenizeString@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_TokenizeString@@9@9 DD 0200H	; `Cmd_TokenizeString'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EAMFOJNK@?$CFs?5not?5found?6@
CONST	SEGMENT
??_C@_0O@EAMFOJNK@?$CFs?5not?5found?6@ DB '%s not found', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JMDNPNJG@Usage?3?5unalias?5alias1?5?$FLalias2?5?4@
CONST	SEGMENT
??_C@_0CE@JMDNPNJG@Usage?3?5unalias?5alias1?5?$FLalias2?5?4@ DB 'Usage: u'
	DB	'nalias alias1 [alias2 ...]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_UnAlias_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_UnAlias_f@@9@9 DD 019eH		; `Cmd_UnAlias_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\cmd.c', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCCCFJOE@Alias?5name?5is?5too?5long?6@
CONST	SEGMENT
??_C@_0BI@MCCCFJOE@Alias?5name?5is?5too?5long?6@ DB 'Alias name is too lo'
	DB	'ng', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOJLLEDG@?$FO2?$CFs?$FO7?5?3?5?$FO3?$CFs?$FO7?6@
CONST	SEGMENT
??_C@_0BB@EOJLLEDG@?$FO2?$CFs?$FO7?5?3?5?$FO3?$CFs?$FO7?6@ DB '^2%s^7 : ^'
	DB	'3%s^7', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GLKEFIHM@Current?5alias?5commands?3?6@
CONST	SEGMENT
??_C@_0BJ@GLKEFIHM@Current?5alias?5commands?3?6@ DB 'Current alias comman'
	DB	'ds:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Cmd_Alias_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??Cmd_Alias_f@@9@9 DD 0157H		; `Cmd_Alias_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CCCNFKCN@stuffcmds@
CONST	SEGMENT
??_C@_09CCCNFKCN@stuffcmds@ DB 'stuffcmds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BCFOHFGH@?$FO1Error?3?$FO7?5Cbuf_Execute?3?5comman@
CONST	SEGMENT
??_C@_0DC@BCFOHFGH@?$FO1Error?3?$FO7?5Cbuf_Execute?3?5comman@ DB '^1Error'
	DB	':^7 Cbuf_Execute: command string owerflow', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OFNEIEPG@?$FO3Warning?3?$FO7?5Cbuf_InsertText?3?5o@
CONST	SEGMENT
??_C@_0CI@OFNEIEPG@?$FO3Warning?3?$FO7?5Cbuf_InsertText?3?5o@ DB '^3Warni'
	DB	'ng:^7 Cbuf_InsertText: overflow', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OCNJCEGP@?$FO3Warning?3?$FO7?5Cbuf_AddText?3?5over@
CONST	SEGMENT
??_C@_0CF@OCNJCEGP@?$FO3Warning?3?$FO7?5Cbuf_AddText?3?5over@ DB '^3Warni'
	DB	'ng:^7 Cbuf_AddText: overflow', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CIOHDACP@Cbuf_GetSpace?3?5overflow?6@
CONST	SEGMENT
??_C@_0BJ@CIOHDACP@Cbuf_GetSpace?3?5overflow?6@ DB 'Cbuf_GetSpace: overfl'
	DB	'ow', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02bcH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0197H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0381H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	01c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0301H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0419H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_List_f
_TEXT	SEGMENT
_match$ = -12						; size = 4
_i$ = -8						; size = 4
_cmd$ = -4						; size = 4
_Cmd_List_f PROC					; COMDAT

; 1036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1037 : 	cmd_t	*cmd;
; 1038 : 	int	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 1039 : 	char	*match;
; 1040 : 
; 1041 : 	if( Cmd_Argc() > 1 ) match = Cmd_Argv( 1 );

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN5@Cmd_List_f
	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _match$[ebp], eax
	jmp	SHORT $LN6@Cmd_List_f
$LN5@Cmd_List_f:

; 1042 : 	else match = NULL;

	mov	DWORD PTR _match$[ebp], 0
$LN6@Cmd_List_f:

; 1043 : 
; 1044 : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_List_f
$LN2@Cmd_List_f:
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx
$LN4@Cmd_List_f:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_List_f

; 1045 : 	{
; 1046 : 		if( cmd->name[0] == '@' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN7@Cmd_List_f

; 1047 : 			continue;	// never show system cmds

	jmp	SHORT $LN2@Cmd_List_f
$LN7@Cmd_List_f:

; 1048 : 
; 1049 : 		if( match && !Q_stricmpext( match, cmd->name ))

	cmp	DWORD PTR _match$[ebp], 0
	je	SHORT $LN8@Cmd_List_f
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _match$[ebp]
	push	edx
	call	_Q_stricmpext
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@Cmd_List_f

; 1050 : 			continue;

	jmp	SHORT $LN2@Cmd_List_f
$LN8@Cmd_List_f:

; 1051 : 
; 1052 : 		Con_Printf( " %-*s ^3%s^7\n", 32, cmd->name, cmd->desc );

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	32					; 00000020H
	push	OFFSET ??_C@_0O@PAHOIENE@?5?$CF?9?$CKs?5?$FO3?$CFs?$FO7?6@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 1053 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 1054 : 	}

	jmp	SHORT $LN2@Cmd_List_f
$LN3@Cmd_List_f:

; 1055 : 
; 1056 : 	Con_Printf( "%i commands\n", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@IIIOLKJI@?$CFi?5commands?6@
	call	_Con_Printf
	add	esp, 8

; 1057 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_List_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Else_f
_TEXT	SEGMENT
_Cmd_Else_f PROC					; COMDAT

; 870  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 871  : 	cmd_condition ^= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	xor	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax

; 872  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Else_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_If_f
_TEXT	SEGMENT
tv197 = -76						; size = 4
_f2$1 = -8						; size = 4
_f1$2 = -4						; size = 4
_Cmd_If_f PROC						; COMDAT

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 810  : 	// reset bit first
; 811  : 	cmd_condition &= ~BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	not	eax
	and	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax

; 812  : 
; 813  : 	// usage
; 814  : 	if( cmd_argc == 1 )

	cmp	DWORD PTR _cmd_argc, 1
	jne	SHORT $LN2@Cmd_If_f

; 815  : 	{
; 816  : 		Con_Printf( S_USAGE "if <op1> [ <operator> <op2> ]\n");

	push	OFFSET ??_C@_0CG@HPNNAJHD@Usage?3?5if?5?$DMop1?$DO?5?$FL?5?$DMoperator?$DO?5?$DMo@
	call	_Con_Printf
	add	esp, 4

; 817  : 		Con_Printf( ":<action1>\n" );

	push	OFFSET ??_C@_0M@HGJGLBCK@?3?$DMaction1?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 818  : 		Con_Printf( ":<action2>\n" );

	push	OFFSET ??_C@_0M@GECDBOME@?3?$DMaction2?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 819  : 		Con_Printf( "else\n" );

	push	OFFSET ??_C@_05IHLPLEMK@else?6@
	call	_Con_Printf
	add	esp, 4

; 820  : 		Con_Printf( ":<action3>\n" );

	push	OFFSET ??_C@_0M@NMJPHJKB@?3?$DMaction3?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 821  : 		Con_Printf( "operands are string or float values\n" );

	push	OFFSET ??_C@_0CF@GEMMIBOF@operands?5are?5string?5or?5float?5va@
	call	_Con_Printf
	add	esp, 4

; 822  : 		Con_Printf( "and substituted cvars like '$cl_lw'\n" );

	push	OFFSET ??_C@_0CF@ODPFLMJH@and?5substituted?5cvars?5like?5?8$cl@
	call	_Con_Printf
	add	esp, 4

; 823  : 		Con_Printf( "operator is '='', '==', '>', '<', '>=', '<=' or '!='\n" );

	push	OFFSET ??_C@_0DG@NKPEPCAM@operator?5is?5?8?$DN?8?8?0?5?8?$DN?$DN?8?0?5?8?$DO?8?0?5?8?$DM@
	call	_Con_Printf
	add	esp, 4

; 824  : 		return;

	jmp	$LN15@Cmd_If_f
$LN2@Cmd_If_f:

; 825  : 	}
; 826  : 
; 827  : 	// one argument - check if nonzero
; 828  : 	if( cmd_argc == 2 )

	cmp	DWORD PTR _cmd_argc, 2
	jne	SHORT $LN3@Cmd_If_f

; 829  : 	{
; 830  : 		if( Q_atof( cmd_argv[1] ))

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv197[ebp]
	movss	xmm0, DWORD PTR tv197[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@Cmd_If_f

; 831  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	or	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax
$LN5@Cmd_If_f:

; 832  : 	}

	jmp	$LN15@Cmd_If_f
$LN3@Cmd_If_f:

; 833  : 	else if( cmd_argc == 4 )

	cmp	DWORD PTR _cmd_argc, 4
	jne	$LN15@Cmd_If_f

; 834  : 	{
; 835  : 		// simple compare
; 836  : 		float	f1 = Q_atof( cmd_argv[1] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _f1$2[ebp]

; 837  : 		float	f2 = Q_atof( cmd_argv[3] );

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR _f2$1[ebp]

; 838  : 
; 839  : 		if( !cmd_argv[2][0] ) // this is wrong

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN7@Cmd_If_f

; 840  : 			return;

	jmp	$LN15@Cmd_If_f
$LN7@Cmd_If_f:

; 841  : 
; 842  : 		if(( cmd_argv[2][0] == '=' ) || ( cmd_argv[2][1] == '=' )) // =, ==, >=, <=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN9@Cmd_If_f
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cmd_argv[eax]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN10@Cmd_If_f
$LN9@Cmd_If_f:

; 843  : 		{
; 844  : 			if( !Q_strcmp( cmd_argv[1], cmd_argv[3] ) || (( f1 || f2 ) && ( f1 == f2 )))

	push	99999					; 0001869fH
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@Cmd_If_f
	movss	xmm0, DWORD PTR _f1$2[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@Cmd_If_f
	movss	xmm0, DWORD PTR _f2$1[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@Cmd_If_f
$LN12@Cmd_If_f:
	movss	xmm0, DWORD PTR _f1$2[ebp]
	ucomiss	xmm0, DWORD PTR _f2$1[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@Cmd_If_f
$LN11@Cmd_If_f:

; 845  : 				cmd_condition |= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	or	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax
$LN10@Cmd_If_f:

; 846  : 		}
; 847  : 
; 848  : 		if( cmd_argv[2][0] == '!' ) 					// !=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN13@Cmd_If_f

; 849  : 		{
; 850  : 			cmd_condition ^= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	xor	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax

; 851  : 			return;

	jmp	$LN15@Cmd_If_f
$LN13@Cmd_If_f:

; 852  : 		}
; 853  : 
; 854  : 		if(( cmd_argv[2][0] == '>' ) && ( f1 > f2 )) // >, >=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $LN14@Cmd_If_f
	movss	xmm0, DWORD PTR _f1$2[ebp]
	comiss	xmm0, DWORD PTR _f2$1[ebp]
	jbe	SHORT $LN14@Cmd_If_f

; 855  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	or	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax
$LN14@Cmd_If_f:

; 856  : 		
; 857  : 		if(( cmd_argv[2][0] == '<' ) && ( f1 < f2 )) // <, <=

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[eax]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	jne	SHORT $LN15@Cmd_If_f
	movss	xmm0, DWORD PTR _f2$1[ebp]
	comiss	xmm0, DWORD PTR _f1$2[ebp]
	jbe	SHORT $LN15@Cmd_If_f

; 858  : 			cmd_condition |= BIT( cmd_condlevel );

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	or	eax, DWORD PTR _cmd_condition
	mov	DWORD PTR _cmd_condition, eax
$LN15@Cmd_If_f:

; 859  : 	}
; 860  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_If_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_UnAlias_f
_TEXT	SEGMENT
_i$ = -16						; size = 4
_s$ = -12						; size = 4
_p$ = -8						; size = 4
_a$ = -4						; size = 4
_Cmd_UnAlias_f PROC					; COMDAT

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 415  : 	cmdalias_t	*a, *p;
; 416  : 	const char	*s;
; 417  : 	int		i;
; 418  : 
; 419  : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN8@Cmd_UnAlia

; 420  : 	{
; 421  : 		Con_Printf( S_USAGE "unalias alias1 [alias2 ...]\n" );

	push	OFFSET ??_C@_0CE@JMDNPNJG@Usage?3?5unalias?5alias1?5?$FLalias2?5?4@
	call	_Con_Printf
	add	esp, 4

; 422  : 		return;

	jmp	$LN1@Cmd_UnAlia
$LN8@Cmd_UnAlia:

; 423  : 	}
; 424  : 
; 425  : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Cmd_UnAlia
$LN2@Cmd_UnAlia:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_UnAlia:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN1@Cmd_UnAlia

; 426  : 	{
; 427  : 		s = Cmd_Argv( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 428  : 		p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 429  : 
; 430  : 		for( a = cmd_alias; a; p = a, a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN7@Cmd_UnAlia
$LN5@Cmd_UnAlia:
	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _a$[ebp], edx
$LN7@Cmd_UnAlia:
	cmp	DWORD PTR _a$[ebp], 0
	je	$LN6@Cmd_UnAlia

; 431  : 		{
; 432  : 			if( !Q_strcmp( s, a->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@Cmd_UnAlia

; 433  : 			{
; 434  : 				if( a == cmd_alias )

	mov	eax, DWORD PTR _a$[ebp]
	cmp	eax, DWORD PTR _cmd_alias
	jne	SHORT $LN10@Cmd_UnAlia

; 435  : 					cmd_alias = a->next;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd_alias, ecx
$LN10@Cmd_UnAlia:

; 436  : 				if( p ) p->next = a->next;

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN11@Cmd_UnAlia
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN11@Cmd_UnAlia:

; 437  : 				Mem_Free( a->value );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_UnAlias_f@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 438  : 				Mem_Free( a );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_UnAlias_f@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 439  : 				break;

	jmp	SHORT $LN6@Cmd_UnAlia
$LN9@Cmd_UnAlia:

; 440  : 			}
; 441  : 		}

	jmp	$LN5@Cmd_UnAlia
$LN6@Cmd_UnAlia:

; 442  : 
; 443  : 		if( !a ) Con_Printf( "%s not found\n", s );

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $LN12@Cmd_UnAlia
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@EAMFOJNK@?$CFs?5not?5found?6@
	call	_Con_Printf
	add	esp, 8
$LN12@Cmd_UnAlia:

; 444  : 	}

	jmp	$LN2@Cmd_UnAlia
$LN1@Cmd_UnAlia:

; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_UnAlias_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Alias_f
_TEXT	SEGMENT
$T1 = -2400						; size = 4
_prev$2 = -2076						; size = 4
_cur$3 = -2072						; size = 4
_s$ = -2068						; size = 4
_c$ = -2064						; size = 4
_i$ = -2060						; size = 4
_cmd$ = -2056						; size = 2048
_a$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Cmd_Alias_f PROC					; COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2400				; 00000960H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 344  : 	cmdalias_t	*a;
; 345  : 	char		cmd[MAX_CMD_LINE];
; 346  : 	int		i, c;
; 347  : 	char		*s;
; 348  : 
; 349  : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN14@Cmd_Alias_

; 350  : 	{
; 351  : 		Con_Printf( "Current alias commands:\n" );

	push	OFFSET ??_C@_0BJ@GLKEFIHM@Current?5alias?5commands?3?6@
	call	_Con_Printf
	add	esp, 4

; 352  : 		for( a = cmd_alias; a; a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN4@Cmd_Alias_
$LN2@Cmd_Alias_:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _a$[ebp], ecx
$LN4@Cmd_Alias_:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN3@Cmd_Alias_

; 353  : 			Con_Printf( "^2%s^7 : ^3%s^7\n", a->name, a->value );

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	add	edx, 4
	push	edx
	push	OFFSET ??_C@_0BB@EOJLLEDG@?$FO2?$CFs?$FO7?5?3?5?$FO3?$CFs?$FO7?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@Cmd_Alias_
$LN3@Cmd_Alias_:

; 354  : 		return;

	jmp	$LN22@Cmd_Alias_
$LN14@Cmd_Alias_:

; 355  : 	}
; 356  : 
; 357  : 	s = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _s$[ebp], eax

; 358  : 
; 359  : 	if( Q_strlen( s ) >= MAX_ALIAS_NAME )

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN15@Cmd_Alias_

; 360  : 	{
; 361  : 		Con_Printf( "Alias name is too long\n" );

	push	OFFSET ??_C@_0BI@MCCCFJOE@Alias?5name?5is?5too?5long?6@
	call	_Con_Printf
	add	esp, 4

; 362  : 		return;

	jmp	$LN22@Cmd_Alias_
$LN15@Cmd_Alias_:

; 363  : 	}
; 364  : 
; 365  : 	// if the alias already exists, reuse it
; 366  : 	for( a = cmd_alias; a; a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN7@Cmd_Alias_
$LN5@Cmd_Alias_:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _a$[ebp], ecx
$LN7@Cmd_Alias_:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN6@Cmd_Alias_

; 367  : 	{
; 368  : 		if( !Q_strcmp( s, a->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Cmd_Alias_

; 369  : 		{
; 370  : 			Z_Free( a->value );

	mov	eax, DWORD PTR _a$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN17@Cmd_Alias_
	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Alias_f@@9@9
	add	eax, 27					; 0000001bH
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN17@Cmd_Alias_:

; 371  : 			break;

	jmp	SHORT $LN6@Cmd_Alias_
$LN16@Cmd_Alias_:

; 372  : 		}
; 373  : 	}

	jmp	SHORT $LN5@Cmd_Alias_
$LN6@Cmd_Alias_:

; 374  : 
; 375  : 	if( !a )

	cmp	DWORD PTR _a$[ebp], 0
	jne	$LN18@Cmd_Alias_

; 376  : 	{
; 377  : 		cmdalias_t	*cur, *prev;
; 378  : 
; 379  : 		a = Z_Malloc( sizeof( cmdalias_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Alias_f@@9@9
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	40					; 00000028H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _a$[ebp], eax

; 380  : 
; 381  : 		Q_strncpy( a->name, s, sizeof( a->name ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 4
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 382  : 
; 383  : 		// insert it at the right alphanumeric position
; 384  : 		for( prev = NULL, cur = cmd_alias; cur && Q_strcmp( cur->name, a->name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$2[ebp], 0
	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _cur$3[ebp], eax
	jmp	SHORT $LN10@Cmd_Alias_
$LN8@Cmd_Alias_:
	mov	eax, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR _prev$2[ebp], eax
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$3[ebp], edx
$LN10@Cmd_Alias_:
	cmp	DWORD PTR _cur$3[ebp], 0
	je	SHORT $LN9@Cmd_Alias_
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _cur$3[ebp]
	add	ecx, 4
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN9@Cmd_Alias_
	jmp	SHORT $LN8@Cmd_Alias_
$LN9@Cmd_Alias_:

; 385  : 
; 386  : 		if( prev ) prev->next = a;

	cmp	DWORD PTR _prev$2[ebp], 0
	je	SHORT $LN19@Cmd_Alias_
	mov	eax, DWORD PTR _prev$2[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN20@Cmd_Alias_
$LN19@Cmd_Alias_:

; 387  : 		else cmd_alias = a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _cmd_alias, eax
$LN20@Cmd_Alias_:

; 388  : 		a->next = cur;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _cur$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN18@Cmd_Alias_:

; 389  : 	}
; 390  : 
; 391  : 	// copy the rest of the command line
; 392  : 	cmd[0] = 0; // start out with a null string

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN23@Cmd_Alias_
	jmp	SHORT $LN24@Cmd_Alias_
$LN23@Cmd_Alias_:
	call	___report_rangecheckfailure
$LN24@Cmd_Alias_:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cmd$[ebp+edx], 0

; 393  : 
; 394  : 	c = Cmd_Argc();

	call	_Cmd_Argc
	mov	DWORD PTR _c$[ebp], eax

; 395  : 
; 396  : 	for( i = 2; i < c; i++ )

	mov	DWORD PTR _i$[ebp], 2
	jmp	SHORT $LN13@Cmd_Alias_
$LN11@Cmd_Alias_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@Cmd_Alias_:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jge	SHORT $LN12@Cmd_Alias_

; 397  : 	{
; 398  : 		if( i != 2 ) Q_strncat( cmd, " ", sizeof( cmd ));

	cmp	DWORD PTR _i$[ebp], 2
	je	SHORT $LN21@Cmd_Alias_
	push	2048					; 00000800H
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN21@Cmd_Alias_:

; 399  : 		Q_strncat( cmd, Cmd_Argv( i ), sizeof( cmd ));

	push	2048					; 00000800H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 400  : 	}

	jmp	SHORT $LN11@Cmd_Alias_
$LN12@Cmd_Alias_:

; 401  : 
; 402  : 	Q_strncat( cmd, "\n", sizeof( cmd ));

	push	2048					; 00000800H
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 403  : 	a->value = copystring( cmd );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Alias_f@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	lea	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _a$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN22@Cmd_Alias_:

; 404  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Alias_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Echo_f
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Cmd_Echo_f PROC					; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 328  : 	int	i;
; 329  : 	
; 330  : 	for( i = 1; i < Cmd_Argc(); i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@Cmd_Echo_f
$LN2@Cmd_Echo_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_Echo_f:
	call	_Cmd_Argc
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@Cmd_Echo_f

; 331  : 		Con_Printf( "%s", Cmd_Argv( i ));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN2@Cmd_Echo_f
$LN3@Cmd_Echo_f:

; 332  : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Echo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Wait_f
_TEXT	SEGMENT
_Cmd_Wait_f PROC					; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 316  : 	cmd_wait = true;

	mov	DWORD PTR _cmd_wait, 1

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Wait_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_StuffCmds_f
_TEXT	SEGMENT
_Cmd_StuffCmds_f PROC					; COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 302  : 	host.stuffcmds_pending = true;

	mov	DWORD PTR _host+34348, 1

; 303  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_StuffCmds_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_GetSpace
_TEXT	SEGMENT
_data$ = -4						; size = 4
_buf$ = 8						; size = 4
_length$ = 12						; size = 4
_Cbuf_GetSpace PROC					; COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 82   : 	void    *data;
; 83   : 	
; 84   : 	if(( buf->cursize + length ) > buf->maxsize )

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jle	SHORT $LN2@Cbuf_GetSp

; 85   : 	{
; 86   : 		buf->cursize = 0;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		Host_Error( "Cbuf_GetSpace: overflow\n" );

	push	OFFSET ??_C@_0BJ@CIOHDACP@Cbuf_GetSpace?3?5overflow?6@
	call	_Host_Error
	add	esp, 4
$LN2@Cbuf_GetSp:

; 88   : 	}
; 89   : 
; 90   : 	data = buf->data + buf->cursize;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _buf$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _data$[ebp], ecx

; 91   : 	buf->cursize += length;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _length$[ebp]
	mov	edx, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 92   : 	
; 93   : 	return data;

	mov	eax, DWORD PTR _data$[ebp]

; 94   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_GetSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Null_f
_TEXT	SEGMENT
_Cmd_Null_f PROC					; COMDAT

; 1115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1116 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Null_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_ForwardToServer
_TEXT	SEGMENT
$T1 = -66056						; size = 4
_str$ = -65540						; size = 65536
__$ArrayPad$ = -4					; size = 4
_Cmd_ForwardToServer PROC				; COMDAT

; 997  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 66056				; 00010208H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 998  : 	char	str[MAX_CMD_BUFFER];
; 999  : 	
; 1000 : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN2@Cmd_Forwar

; 1001 : 	{
; 1002 : 		if( !Q_stricmp( Cmd_Argv( 0 ), "pause" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05PDJBBECF@pause@
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@Cmd_Forwar

; 1003 : 			cl.paused ^= 1;

	mov	eax, DWORD PTR _cl+24
	xor	eax, 1
	mov	DWORD PTR _cl+24, eax
$LN3@Cmd_Forwar:

; 1004 : 		return;

	jmp	$LN10@Cmd_Forwar
$LN2@Cmd_Forwar:

; 1005 : 	}
; 1006 : 
; 1007 : 	if( cls.state < ca_connected || cls.state > ca_active )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN5@Cmd_Forwar
	cmp	DWORD PTR _cls, 4
	jle	SHORT $LN4@Cmd_Forwar
$LN5@Cmd_Forwar:

; 1008 : 	{
; 1009 : 		if( Q_stricmp( Cmd_Argv( 0 ), "setinfo" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07BANLMPIG@setinfo@
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@Cmd_Forwar

; 1010 : 			Con_Printf( "Can't \"%s\", not connected\n", Cmd_Argv( 0 ));

	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BL@HFMAFAHP@Can?8t?5?$CC?$CFs?$CC?0?5not?5connected?6@
	call	_Con_Printf
	add	esp, 8
$LN6@Cmd_Forwar:

; 1011 : 		return; // not connected

	jmp	$LN10@Cmd_Forwar
$LN4@Cmd_Forwar:

; 1012 : 	}
; 1013 : 
; 1014 : 	MSG_BeginClientCmd( &cls.netchan.message, clc_stringcmd );

	push	0
	push	0
	push	3
	push	OFFSET _cls+26900
	call	_MSG_WriteCmdExt
	add	esp, 16					; 00000010H

; 1015 : 
; 1016 : 	str[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 65536		; 00010000H
	jae	SHORT $LN11@Cmd_Forwar
	jmp	SHORT $LN12@Cmd_Forwar
$LN11@Cmd_Forwar:
	call	___report_rangecheckfailure
$LN12@Cmd_Forwar:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _str$[ebp+edx], 0

; 1017 : 	if( Q_stricmp( Cmd_Argv( 0 ), "cmd" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03LGLGIONO@cmd@
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@Cmd_Forwar

; 1018 : 	{
; 1019 : 		Q_strcat( str, Cmd_Argv( 0 ));

	push	99999					; 0001869fH
	push	0
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1020 : 		Q_strcat( str, " " );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01CLKCMJKC@?5@
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN7@Cmd_Forwar:

; 1021 : 	}
; 1022 : 	
; 1023 : 	if( Cmd_Argc() > 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jbe	SHORT $LN8@Cmd_Forwar

; 1024 : 		Q_strcat( str, Cmd_Args( ));

	push	99999					; 0001869fH
	call	_Cmd_Args
	push	eax
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@Cmd_Forwar
$LN8@Cmd_Forwar:

; 1025 : 	else Q_strcat( str, "\n" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01EEMJAFIK@?6@
	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN9@Cmd_Forwar:

; 1026 : 
; 1027 : 	MSG_WriteString( &cls.netchan.message, str );

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET _cls+26900
	call	_MSG_WriteString
	add	esp, 8
$LN10@Cmd_Forwar:

; 1028 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_ForwardToServer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_ExecuteString
_TEXT	SEGMENT
_ptoken$1 = -4120					; size = 4
_token$2 = -4116					; size = 2048
_len$ = -2068						; size = 4
_pcmd$ = -2064						; size = 4
_command$ = -2060					; size = 2048
_a$ = -12						; size = 4
_cmd$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_Cmd_ExecuteString PROC					; COMDAT

; 882  : {	

	push	ebp
	mov	ebp, esp
	mov	eax, 4632				; 00001218H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 883  : 	cmd_t		*cmd;
; 884  : 	cmdalias_t	*a;
; 885  : 	char		command[MAX_CMD_LINE];
; 886  : 	char		*pcmd = command;

	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR _pcmd$[ebp], eax

; 887  : 	int		len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 888  : 
; 889  : 	cmd_condlevel = 0;

	mov	DWORD PTR _cmd_condlevel, 0

; 890  : 
; 891  : 	// cvar value substitution
; 892  : 	if( cmd_scripting && cmd_scripting->value )

	cmp	DWORD PTR _cmd_scripting, 0
	je	$LN7@Cmd_Execut
	mov	eax, DWORD PTR _cmd_scripting
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN7@Cmd_Execut
$LN2@Cmd_Execut:

; 893  : 	{
; 894  : 		while( *text )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@Cmd_Execut

; 895  : 		{
; 896  : 			// check for escape
; 897  : 			if(( *text == '\\' || *text == '$' ) && (*( text + 1 ) == '$' ))

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN17@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN15@Cmd_Execut
$LN17@Cmd_Execut:
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN15@Cmd_Execut

; 898  : 			{
; 899  : 				text ++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax

; 900  : 			}

	jmp	$LN23@Cmd_Execut
$LN15@Cmd_Execut:

; 901  : 			else if( *text == '$' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 36					; 00000024H
	jne	$LN23@Cmd_Execut

; 902  : 			{
; 903  : 				char	token[MAX_CMD_LINE];
; 904  : 				char	*ptoken = token;

	lea	eax, DWORD PTR _token$2[ebp]
	mov	DWORD PTR _ptoken$1[ebp], eax

; 905  : 
; 906  : 				// check for correct cvar name
; 907  : 				text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN4@Cmd_Execut:

; 908  : 				while(( *text >= '0' && *text <= '9' ) || ( *text >= 'A' && *text <= 'Z' ) || ( *text >= 'a' && *text <= 'z' ) || ( *text == '_' ))

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN20@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN19@Cmd_Execut
$LN20@Cmd_Execut:
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN21@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jle	SHORT $LN19@Cmd_Execut
$LN21@Cmd_Execut:
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN22@Cmd_Execut
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 122				; 0000007aH
	jle	SHORT $LN19@Cmd_Execut
$LN22@Cmd_Execut:
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $LN5@Cmd_Execut
$LN19@Cmd_Execut:

; 909  : 					*ptoken++ = *text++;

	mov	eax, DWORD PTR _ptoken$1[ebp]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ptoken$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ptoken$1[ebp], eax
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx
	jmp	SHORT $LN4@Cmd_Execut
$LN5@Cmd_Execut:

; 910  : 				*ptoken = 0;

	mov	eax, DWORD PTR _ptoken$1[ebp]
	mov	BYTE PTR [eax], 0

; 911  : 
; 912  : 				len += Q_strncpy( pcmd, Cvar_VariableString( token ), MAX_CMD_LINE - len );

	mov	eax, 2048				; 00000800H
	sub	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _token$2[ebp]
	push	ecx
	call	_Cvar_VariableString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pcmd$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR _len$[ebp], eax

; 913  : 				pcmd = command + len;

	mov	eax, DWORD PTR _len$[ebp]
	lea	ecx, DWORD PTR _command$[ebp+eax]
	mov	DWORD PTR _pcmd$[ebp], ecx

; 914  : 
; 915  : 				if( !*text ) break;

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN23@Cmd_Execut
	jmp	SHORT $LN3@Cmd_Execut
$LN23@Cmd_Execut:

; 916  : 			}
; 917  : 
; 918  : 			*pcmd++ = *text++;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	ecx, DWORD PTR _text$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 1
	mov	DWORD PTR _pcmd$[ebp], eax
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, 1
	mov	DWORD PTR _text$[ebp], ecx

; 919  : 			len++;

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	mov	DWORD PTR _len$[ebp], eax

; 920  : 		}

	jmp	$LN2@Cmd_Execut
$LN3@Cmd_Execut:

; 921  : 
; 922  : 		*pcmd = 0;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	BYTE PTR [eax], 0

; 923  : 		text = command;

	lea	eax, DWORD PTR _command$[ebp]
	mov	DWORD PTR _text$[ebp], eax
$LN6@Cmd_Execut:

; 924  : 
; 925  : 		while( *text == ':' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN7@Cmd_Execut

; 926  : 		{
; 927  : 			if( !FBitSet( cmd_condition, BIT( cmd_condlevel )))

	mov	eax, 1
	mov	ecx, DWORD PTR _cmd_condlevel
	shl	eax, cl
	and	eax, DWORD PTR _cmd_condition
	jne	SHORT $LN24@Cmd_Execut

; 928  : 				return;

	jmp	$LN36@Cmd_Execut
$LN24@Cmd_Execut:

; 929  : 			cmd_condlevel++;

	mov	eax, DWORD PTR _cmd_condlevel
	add	eax, 1
	mov	DWORD PTR _cmd_condlevel, eax

; 930  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax

; 931  : 		}

	jmp	SHORT $LN6@Cmd_Execut
$LN7@Cmd_Execut:

; 932  : 	}
; 933  : 
; 934  : 	// execute the command line
; 935  : 	Cmd_TokenizeString( text );		

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Cmd_TokenizeString
	add	esp, 4

; 936  : 
; 937  : 	if( !Cmd_Argc( )) return; // no tokens

	call	_Cmd_Argc
	test	eax, eax
	jne	SHORT $LN25@Cmd_Execut
	jmp	$LN36@Cmd_Execut
$LN25@Cmd_Execut:

; 938  : 
; 939  : 	if( !host.apply_game_config )

	cmp	DWORD PTR _host+34388, 0
	jne	SHORT $LN9@Cmd_Execut

; 940  : 	{
; 941  : 		// check aliases
; 942  : 		for( a = cmd_alias; a; a = a->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _a$[ebp], eax
	jmp	SHORT $LN10@Cmd_Execut
$LN8@Cmd_Execut:
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _a$[ebp], ecx
$LN10@Cmd_Execut:
	cmp	DWORD PTR _a$[ebp], 0
	je	SHORT $LN9@Cmd_Execut

; 943  : 		{
; 944  : 			if( !Q_stricmp( cmd_argv[0], a->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cmd_argv[edx]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@Cmd_Execut

; 945  : 			{
; 946  : 				Cbuf_InsertText( a->value );

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_Cbuf_InsertText
	add	esp, 4

; 947  : 				return;

	jmp	$LN36@Cmd_Execut
$LN27@Cmd_Execut:

; 948  : 			}
; 949  : 		}

	jmp	SHORT $LN8@Cmd_Execut
$LN9@Cmd_Execut:

; 950  : 	}
; 951  : 
; 952  : 	// special mode for restore game.dll archived cvars
; 953  : 	if( !host.apply_game_config || !Q_strcmp( cmd_argv[0], "exec" ))

	cmp	DWORD PTR _host+34388, 0
	je	SHORT $LN29@Cmd_Execut
	push	99999					; 0001869fH
	push	OFFSET ??_C@_04MGEIEJAD@exec@
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cmd_argv[ecx]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@Cmd_Execut
$LN29@Cmd_Execut:

; 954  : 	{
; 955  : 		// check functions
; 956  : 		for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN13@Cmd_Execut
$LN11@Cmd_Execut:
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx
$LN13@Cmd_Execut:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN12@Cmd_Execut

; 957  : 		{
; 958  : 			if( !Q_stricmp( cmd_argv[0], cmd->name ) && cmd->function )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cmd_argv[eax]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@Cmd_Execut
	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN30@Cmd_Execut

; 959  : 			{
; 960  : 				cmd->function();

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	ecx

; 961  : 				return;

	jmp	SHORT $LN36@Cmd_Execut
$LN30@Cmd_Execut:

; 962  : 			}
; 963  : 		}

	jmp	SHORT $LN11@Cmd_Execut
$LN12@Cmd_Execut:

; 964  : 	}
; 965  : 
; 966  : 	// check cvars
; 967  : 	if( Cvar_Command( )) return;

	call	_Cvar_Command
	test	eax, eax
	je	SHORT $LN31@Cmd_Execut
	jmp	SHORT $LN36@Cmd_Execut
$LN31@Cmd_Execut:

; 968  : 
; 969  : 	if( host.apply_game_config )

	cmp	DWORD PTR _host+34388, 0
	je	SHORT $LN32@Cmd_Execut

; 970  : 		return; // don't send nothing to server: we is a server!

	jmp	SHORT $LN36@Cmd_Execut
$LN32@Cmd_Execut:

; 971  : 
; 972  : 	// forward the command line to the server, so the entity DLL can parse it
; 973  : 	if( host.type == HOST_NORMAL )

	cmp	DWORD PTR _host+164, 0
	jne	SHORT $LN36@Cmd_Execut

; 974  : 	{
; 975  : 		if( cls.state >= ca_connected )

	cmp	DWORD PTR _cls, 2
	jl	SHORT $LN34@Cmd_Execut

; 976  : 		{
; 977  : 			Cmd_ForwardToServer();

	call	_Cmd_ForwardToServer

; 978  : 		}

	jmp	SHORT $LN36@Cmd_Execut
$LN34@Cmd_Execut:

; 979  : 		else if( text[0] != '@' && Cvar_VariableInteger( "host_gameloaded" ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _text$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN36@Cmd_Execut
	push	OFFSET ??_C@_0BA@HFMOEDOL@host_gameloaded@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN36@Cmd_Execut

; 980  : 		{
; 981  : 			// commands with leading '@' are hidden system commands
; 982  : 			Con_Printf( S_WARN "Unknown command \"%s\"\n", text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@NMMIHOJO@?$FO3Warning?3?$FO7?5Unknown?5command?5?$CC?$CF@
	call	_Con_Printf
	add	esp, 8
$LN36@Cmd_Execut:

; 983  : 		}
; 984  : 	}
; 985  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_ExecuteString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_TokenizeString
_TEXT	SEGMENT
_i$ = -65544						; size = 4
_cmd_token$ = -65540					; size = 65536
__$ArrayPad$ = -4					; size = 4
_text$ = 8						; size = 4
_Cmd_TokenizeString PROC				; COMDAT

; 512  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 66056				; 00010208H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 513  : 	char	cmd_token[MAX_CMD_BUFFER];
; 514  : 	int	i;
; 515  : 
; 516  : 	// clear the args from the last string
; 517  : 	for( i = 0; i < cmd_argc; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Cmd_Tokeni
$LN2@Cmd_Tokeni:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cmd_Tokeni:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cmd_argc
	jge	SHORT $LN3@Cmd_Tokeni

; 518  : 		Z_Free( cmd_argv[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _cmd_argv[eax*4], 0
	je	SHORT $LN9@Cmd_Tokeni
	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_TokenizeString@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cmd_argv[ecx*4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Tokeni:
	jmp	SHORT $LN2@Cmd_Tokeni
$LN3@Cmd_Tokeni:

; 519  : 
; 520  : 	cmd_argc = 0; // clear previous args

	mov	DWORD PTR _cmd_argc, 0

; 521  : 	cmd_args = NULL;

	mov	DWORD PTR _cmd_args, 0

; 522  : 
; 523  : 	if( !text ) return;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN5@Cmd_Tokeni
	jmp	$LN1@Cmd_Tokeni
$LN5@Cmd_Tokeni:

; 524  : 
; 525  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN1@Cmd_Tokeni
$LN7@Cmd_Tokeni:

; 526  : 	{
; 527  : 		// skip whitespace up to a /n
; 528  : 		while( *text && ((byte)*text) <= ' ' && *text != '\r' && *text != '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@Cmd_Tokeni
	mov	eax, DWORD PTR _text$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN8@Cmd_Tokeni
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN8@Cmd_Tokeni
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN8@Cmd_Tokeni

; 529  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
	jmp	SHORT $LN7@Cmd_Tokeni
$LN8@Cmd_Tokeni:

; 530  : 
; 531  : 		if( *text == '\n' || *text == '\r' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN12@Cmd_Tokeni
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN11@Cmd_Tokeni
$LN12@Cmd_Tokeni:

; 532  : 		{
; 533  : 			// a newline seperates commands in the buffer
; 534  : 			if( *text == '\r' && text[1] == '\n' )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN13@Cmd_Tokeni
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN13@Cmd_Tokeni

; 535  : 				text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax
$LN13@Cmd_Tokeni:

; 536  : 			text++;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, 1
	mov	DWORD PTR _text$[ebp], eax

; 537  : 			break;

	jmp	$LN1@Cmd_Tokeni
$LN11@Cmd_Tokeni:

; 538  : 		}
; 539  : 
; 540  : 		if( !*text )

	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN14@Cmd_Tokeni

; 541  : 			return;

	jmp	$LN1@Cmd_Tokeni
$LN14@Cmd_Tokeni:

; 542  : 
; 543  : 		if( cmd_argc == 1 )

	cmp	DWORD PTR _cmd_argc, 1
	jne	SHORT $LN15@Cmd_Tokeni

; 544  : 			 cmd_args = text;

	mov	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR _cmd_args, eax
$LN15@Cmd_Tokeni:

; 545  : 
; 546  : 		host.com_ignorebracket = true;

	mov	DWORD PTR _host+34364, 1

; 547  : 		text = COM_ParseFile( text, cmd_token );

	lea	eax, DWORD PTR _cmd_token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _text$[ebp], eax

; 548  : 		host.com_ignorebracket = false;

	mov	DWORD PTR _host+34364, 0

; 549  : 
; 550  : 		if( !text ) return;

	cmp	DWORD PTR _text$[ebp], 0
	jne	SHORT $LN16@Cmd_Tokeni
	jmp	SHORT $LN1@Cmd_Tokeni
$LN16@Cmd_Tokeni:

; 551  : 
; 552  : 		if( cmd_argc < MAX_CMD_TOKENS )

	cmp	DWORD PTR _cmd_argc, 80			; 00000050H
	jge	SHORT $LN17@Cmd_Tokeni

; 553  : 		{
; 554  : 			cmd_argv[cmd_argc] = copystring( cmd_token );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_TokenizeString@@9@9
	add	eax, 42					; 0000002aH
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	lea	ecx, DWORD PTR _cmd_token$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd_argc
	mov	DWORD PTR _cmd_argv[ecx*4], eax

; 555  : 			cmd_argc++;

	mov	eax, DWORD PTR _cmd_argc
	add	eax, 1
	mov	DWORD PTR _cmd_argc, eax
$LN17@Cmd_Tokeni:

; 556  : 		}
; 557  : 	}

	jmp	$LN5@Cmd_Tokeni
$LN1@Cmd_Tokeni:

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_TokenizeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_LookupCmds
_TEXT	SEGMENT
_alias$ = -8						; size = 4
_cmd$ = -4						; size = 4
_buffer$ = 8						; size = 4
_ptr$ = 12						; size = 4
_callback$ = 16						; size = 4
_Cmd_LookupCmds PROC					; COMDAT

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 767  : 	cmd_t	*cmd;
; 768  : 	cmdalias_t	*alias;
; 769  : 
; 770  : 	// nothing to process ?
; 771  : 	if( !callback ) return;

	cmp	DWORD PTR _callback$[ebp], 0
	jne	SHORT $LN8@Cmd_Lookup
	jmp	$LN1@Cmd_Lookup
$LN8@Cmd_Lookup:

; 772  : 	
; 773  : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_Lookup
$LN2@Cmd_Lookup:
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx
$LN4@Cmd_Lookup:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_Lookup

; 774  : 	{
; 775  : 		if( !buffer ) callback( cmd->name, (char *)cmd->function, cmd->desc, ptr );

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN9@Cmd_Lookup
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@Cmd_Lookup
$LN9@Cmd_Lookup:

; 776  : 		else callback( cmd->name, (char *)cmd->function, buffer, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
$LN10@Cmd_Lookup:

; 777  : 	}

	jmp	SHORT $LN2@Cmd_Lookup
$LN3@Cmd_Lookup:

; 778  : 
; 779  : 	// lookup an aliases too
; 780  : 	for( alias = cmd_alias; alias; alias = alias->next )

	mov	eax, DWORD PTR _cmd_alias
	mov	DWORD PTR _alias$[ebp], eax
	jmp	SHORT $LN7@Cmd_Lookup
$LN5@Cmd_Lookup:
	mov	eax, DWORD PTR _alias$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _alias$[ebp], ecx
$LN7@Cmd_Lookup:
	cmp	DWORD PTR _alias$[ebp], 0
	je	SHORT $LN1@Cmd_Lookup

; 781  : 		callback( alias->name, alias->value, buffer, ptr );

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _alias$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _alias$[ebp]
	add	ecx, 4
	push	ecx
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
	jmp	SHORT $LN5@Cmd_Lookup
$LN1@Cmd_Lookup:

; 782  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_LookupCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Exists
_TEXT	SEGMENT
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_Cmd_Exists PROC					; COMDAT

; 790  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 791  : 	cmd_t	*cmd;
; 792  : 
; 793  : 	for( cmd = cmd_functions; cmd; cmd = cmd->next )

	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cmd$[ebp], eax
	jmp	SHORT $LN4@Cmd_Exists
$LN2@Cmd_Exists:
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx
$LN4@Cmd_Exists:
	cmp	DWORD PTR _cmd$[ebp], 0
	je	SHORT $LN3@Cmd_Exists

; 794  : 	{
; 795  : 		if( !Q_strcmp( cmd_name, cmd->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@Cmd_Exists

; 796  : 			return true;

	mov	eax, 1
	jmp	SHORT $LN1@Cmd_Exists
$LN5@Cmd_Exists:

; 797  : 	}

	jmp	SHORT $LN2@Cmd_Exists
$LN3@Cmd_Exists:

; 798  : 	return false;

	xor	eax, eax
$LN1@Cmd_Exists:

; 799  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Exists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_RemoveCommand
_TEXT	SEGMENT
_back$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_Cmd_RemoveCommand PROC					; COMDAT

; 731  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 732  : 	cmd_t	*cmd, **back;
; 733  : 
; 734  : 	if( !cmd_name || !*cmd_name )

	cmp	DWORD PTR _cmd_name$[ebp], 0
	je	SHORT $LN5@Cmd_Remove
	mov	eax, DWORD PTR _cmd_name$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@Cmd_Remove
$LN5@Cmd_Remove:

; 735  : 		return;

	jmp	$LN1@Cmd_Remove
$LN4@Cmd_Remove:

; 736  : 
; 737  : 	back = &cmd_functions;

	mov	DWORD PTR _back$[ebp], OFFSET _cmd_functions
$LN2@Cmd_Remove:

; 738  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN1@Cmd_Remove

; 739  : 	{
; 740  : 		cmd = *back;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx

; 741  : 		if( !cmd ) return;

	cmp	DWORD PTR _cmd$[ebp], 0
	jne	SHORT $LN6@Cmd_Remove
	jmp	$LN1@Cmd_Remove
$LN6@Cmd_Remove:

; 742  : 
; 743  : 		if( !Q_strcmp( cmd_name, cmd->name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _cmd_name$[ebp]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@Cmd_Remove

; 744  : 		{
; 745  : 			*back = cmd->next;

	mov	eax, DWORD PTR _back$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 746  : 
; 747  : 			if( cmd->name )

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN8@Cmd_Remove

; 748  : 				Mem_Free( cmd->name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_RemoveCommand@@9@9
	add	eax, 17					; 00000011H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN8@Cmd_Remove:

; 749  : 
; 750  : 			if( cmd->desc )

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN9@Cmd_Remove

; 751  : 				Mem_Free( cmd->desc );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_RemoveCommand@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Remove:

; 752  : 
; 753  : 			Mem_Free( cmd );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_RemoveCommand@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 754  : 			return;

	jmp	SHORT $LN1@Cmd_Remove
$LN7@Cmd_Remove:

; 755  : 		}
; 756  : 		back = &cmd->next;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _back$[ebp], eax

; 757  : 	}

	jmp	$LN2@Cmd_Remove
$LN1@Cmd_Remove:

; 758  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_RemoveCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_AddGameUICommand
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddGameUICommand PROC				; COMDAT

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 689  : 	cmd_t	*cmd, *cur, *prev;
; 690  : 
; 691  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddGam

; 692  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN5@Cmd_AddGam:

; 693  : 
; 694  : 	// fail if the command is a variable name
; 695  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddGam

; 696  : 	{
; 697  : 		Con_DPrintf( S_ERROR "Cmd_AddGameUICommand: %s already defined as a var\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@MGNIHGGC@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@
	call	_Con_DPrintf
	add	esp, 8

; 698  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN6@Cmd_AddGam:

; 699  : 	}
; 700  : 	
; 701  : 	// fail if the command already exists
; 702  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddGam

; 703  : 	{
; 704  : 		Con_DPrintf( S_ERROR "Cmd_AddGameUICommand: %s already defined\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@KDOLHCKF@?$FO1Error?3?$FO7?5Cmd_AddGameUICommand@
	call	_Con_DPrintf
	add	esp, 8

; 705  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddGam
$LN7@Cmd_AddGam:

; 706  : 	}
; 707  : 
; 708  : 	// use a small malloc to avoid zone fragmentation
; 709  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 710  : 	cmd->name = copystring( cmd_name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 711  : 	cmd->desc = copystring( "GameUI command" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddGameUICommand@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@EOINHEHE@GameUI?5command@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+12], eax

; 712  : 	cmd->function = function;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _function$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 713  : 	cmd->flags = CMD_GAMEUIDLL;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax+16], 4

; 714  : 
; 715  : 	// insert it at the right alphanumeric position
; 716  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@Cmd_AddGam
$LN2@Cmd_AddGam:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddGam:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddGam
	jmp	SHORT $LN2@Cmd_AddGam
$LN3@Cmd_AddGam:

; 717  : 
; 718  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddGam
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddGam
$LN8@Cmd_AddGam:

; 719  : 	else cmd_functions = cmd;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, eax
$LN9@Cmd_AddGam:

; 720  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 721  : 
; 722  : 	return 1;

	mov	eax, 1
$LN1@Cmd_AddGam:

; 723  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddGameUICommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_AddClientCommand
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddClientCommand PROC				; COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 646  : 	cmd_t	*cmd, *cur, *prev;
; 647  : 
; 648  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddCli

; 649  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN5@Cmd_AddCli:

; 650  : 
; 651  : 	// fail if the command is a variable name
; 652  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddCli

; 653  : 	{
; 654  : 		Con_DPrintf( S_ERROR "Cmd_AddClientCommand: %s already defined as a var\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@CGGHKOBF@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@
	call	_Con_DPrintf
	add	esp, 8

; 655  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN6@Cmd_AddCli:

; 656  : 	}
; 657  : 	
; 658  : 	// fail if the command already exists
; 659  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddCli

; 660  : 	{
; 661  : 		Con_DPrintf( S_ERROR "Cmd_AddClientCommand: %s already defined\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@FABHCDHB@?$FO1Error?3?$FO7?5Cmd_AddClientCommand@
	call	_Con_DPrintf
	add	esp, 8

; 662  : 		return 0;

	xor	eax, eax
	jmp	$LN1@Cmd_AddCli
$LN7@Cmd_AddCli:

; 663  : 	}
; 664  : 
; 665  : 	// use a small malloc to avoid zone fragmentation
; 666  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddClientCommand@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 667  : 	cmd->name = copystring( cmd_name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddClientCommand@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 668  : 	cmd->desc = copystring( "client command" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddClientCommand@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@KNDBPAJE@client?5command@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+12], eax

; 669  : 	cmd->function = function;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _function$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 670  : 	cmd->flags = CMD_CLIENTDLL;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax+16], 2

; 671  : 
; 672  : 	// insert it at the right alphanumeric position
; 673  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@Cmd_AddCli
$LN2@Cmd_AddCli:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddCli:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddCli
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddCli
	jmp	SHORT $LN2@Cmd_AddCli
$LN3@Cmd_AddCli:

; 674  : 
; 675  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddCli
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddCli
$LN8@Cmd_AddCli:

; 676  : 	else cmd_functions = cmd;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, eax
$LN9@Cmd_AddCli:

; 677  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 678  : 
; 679  : 	return 1;

	mov	eax, 1
$LN1@Cmd_AddCli:

; 680  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddClientCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_AddServerCommand
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_Cmd_AddServerCommand PROC				; COMDAT

; 604  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 605  : 	cmd_t	*cmd, *cur, *prev;
; 606  : 
; 607  : 	if( !COM_CheckString( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@Cmd_AddSer

; 608  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN5@Cmd_AddSer:

; 609  : 
; 610  : 	// fail if the command is a variable name
; 611  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@Cmd_AddSer

; 612  : 	{
; 613  : 		Con_DPrintf( S_ERROR "Cmd_AddServerCommand: %s already defined as a var\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@EMMODOMG@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@
	call	_Con_DPrintf
	add	esp, 8

; 614  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN6@Cmd_AddSer:

; 615  : 	}
; 616  : 	
; 617  : 	// fail if the command already exists
; 618  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@Cmd_AddSer

; 619  : 	{
; 620  : 		Con_DPrintf( S_ERROR "Cmd_AddServerCommand: %s already defined\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@BDCGNJBO@?$FO1Error?3?$FO7?5Cmd_AddServerCommand@
	call	_Con_DPrintf
	add	esp, 8

; 621  : 		return;

	jmp	$LN1@Cmd_AddSer
$LN7@Cmd_AddSer:

; 622  : 	}
; 623  : 
; 624  : 	// use a small malloc to avoid zone fragmentation
; 625  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddServerCommand@@9@9
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 626  : 	cmd->name = copystring( cmd_name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddServerCommand@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 627  : 	cmd->desc = copystring( "server command" );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddServerCommand@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@EBHCEBON@server?5command@
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [edx+12], eax

; 628  : 	cmd->function = function;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _function$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 629  : 	cmd->flags = CMD_SERVERDLL;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax+16], 1

; 630  : 
; 631  : 	// insert it at the right alphanumeric position
; 632  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@Cmd_AddSer
$LN2@Cmd_AddSer:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddSer:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddSer
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddSer
	jmp	SHORT $LN2@Cmd_AddSer
$LN3@Cmd_AddSer:

; 633  : 
; 634  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN8@Cmd_AddSer
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN9@Cmd_AddSer
$LN8@Cmd_AddSer:

; 635  : 	else cmd_functions = cmd;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, eax
$LN9@Cmd_AddSer:

; 636  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Cmd_AddSer:

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddServerCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_AddCommand
_TEXT	SEGMENT
_prev$ = -12						; size = 4
_cur$ = -8						; size = 4
_cmd$ = -4						; size = 4
_cmd_name$ = 8						; size = 4
_function$ = 12						; size = 4
_cmd_desc$ = 16						; size = 4
_Cmd_AddCommand PROC					; COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 567  : 	cmd_t	*cmd, *cur, *prev;
; 568  : 
; 569  : 	// fail if the command is a variable name
; 570  : 	if( Cvar_FindVar( cmd_name ))

	push	0
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@Cmd_AddCom

; 571  : 	{
; 572  : 		Con_Printf( S_ERROR "Cmd_AddCommand: %s already defined as a var\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@HOHANNMH@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@
	call	_Con_Printf
	add	esp, 8

; 573  : 		return;

	jmp	$LN1@Cmd_AddCom
$LN5@Cmd_AddCom:

; 574  : 	}
; 575  : 	
; 576  : 	// fail if the command already exists
; 577  : 	if( Cmd_Exists( cmd_name ))

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	call	_Cmd_Exists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@Cmd_AddCom

; 578  : 	{
; 579  : 		Con_Printf( S_ERROR "Cmd_AddCommand: %s already defined\n", cmd_name );

	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@HKJBNAGP@?$FO1Error?3?$FO7?5Cmd_AddCommand?3?5?$CFs?5a@
	call	_Con_Printf
	add	esp, 8

; 580  : 		return;

	jmp	$LN1@Cmd_AddCom
$LN6@Cmd_AddCom:

; 581  : 	}
; 582  : 
; 583  : 	// use a small malloc to avoid zone fragmentation
; 584  : 	cmd = Z_Malloc( sizeof( cmd_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddCommand@@9@9
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	20					; 00000014H
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cmd$[ebp], eax

; 585  : 	cmd->name = copystring( cmd_name );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddCommand@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd_name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 586  : 	cmd->desc = copystring( cmd_desc );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_AddCommand@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd_desc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host+236
	push	edx
	call	__copystring
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 587  : 	cmd->function = function;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _function$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 588  : 	cmd->flags = 0;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax+16], 0

; 589  : 
; 590  : 	// insert it at the right alphanumeric position
; 591  : 	for( prev = NULL, cur = cmd_functions; cur && Q_strcmp( cur->name, cmd_name ) < 0; prev = cur, cur = cur->next );

	mov	DWORD PTR _prev$[ebp], 0
	mov	eax, DWORD PTR _cmd_functions
	mov	DWORD PTR _cur$[ebp], eax
	jmp	SHORT $LN4@Cmd_AddCom
$LN2@Cmd_AddCom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@Cmd_AddCom:
	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cmd_AddCom
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _cmd_name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jge	SHORT $LN3@Cmd_AddCom
	jmp	SHORT $LN2@Cmd_AddCom
$LN3@Cmd_AddCom:

; 592  : 
; 593  : 	if( prev ) prev->next = cmd;

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN7@Cmd_AddCom
	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN8@Cmd_AddCom
$LN7@Cmd_AddCom:

; 594  : 	else cmd_functions = cmd;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _cmd_functions, eax
$LN8@Cmd_AddCom:

; 595  : 	cmd->next = cur;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@Cmd_AddCom:

; 596  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_AddCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Unlink
_TEXT	SEGMENT
_count$ = -12						; size = 4
_prev$ = -8						; size = 4
_cmd$ = -4						; size = 4
_group$ = 8						; size = 4
_Cmd_Unlink PROC					; COMDAT

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1068 : 	cmd_t	*cmd;
; 1069 : 	cmd_t	**prev;
; 1070 : 	int	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 1071 : 
; 1072 : 	if( Cvar_VariableInteger( "host_gameloaded" ) && FBitSet( group, CMD_SERVERDLL ))

	push	OFFSET ??_C@_0BA@HFMOEDOL@host_gameloaded@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@Cmd_Unlink
	mov	eax, DWORD PTR _group$[ebp]
	and	eax, 1
	je	SHORT $LN4@Cmd_Unlink

; 1073 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN4@Cmd_Unlink:

; 1074 : 
; 1075 : 	if( Cvar_VariableInteger( "host_clientloaded" ) && FBitSet( group, CMD_CLIENTDLL ))

	push	OFFSET ??_C@_0BC@CKKMCGJ@host_clientloaded@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@Cmd_Unlink
	mov	eax, DWORD PTR _group$[ebp]
	and	eax, 2
	je	SHORT $LN5@Cmd_Unlink

; 1076 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN5@Cmd_Unlink:

; 1077 : 
; 1078 : 	if( Cvar_VariableInteger( "host_gameuiloaded" ) && FBitSet( group, CMD_GAMEUIDLL ))

	push	OFFSET ??_C@_0BC@CFEOCCMF@host_gameuiloaded@
	call	_Cvar_VariableInteger
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@Cmd_Unlink
	mov	eax, DWORD PTR _group$[ebp]
	and	eax, 4
	je	SHORT $LN6@Cmd_Unlink

; 1079 : 		return;

	jmp	$LN1@Cmd_Unlink
$LN6@Cmd_Unlink:

; 1080 : 
; 1081 : 	prev = &cmd_functions;

	mov	DWORD PTR _prev$[ebp], OFFSET _cmd_functions
$LN2@Cmd_Unlink:

; 1082 : 
; 1083 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN3@Cmd_Unlink

; 1084 : 	{
; 1085 : 		cmd = *prev;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cmd$[ebp], ecx

; 1086 : 		if( !cmd ) break;

	cmp	DWORD PTR _cmd$[ebp], 0
	jne	SHORT $LN7@Cmd_Unlink
	jmp	$LN3@Cmd_Unlink
$LN7@Cmd_Unlink:

; 1087 : 
; 1088 : 		// do filter by specified group
; 1089 : 		if( group && !FBitSet( cmd->flags, group ))

	cmp	DWORD PTR _group$[ebp], 0
	je	SHORT $LN8@Cmd_Unlink
	mov	eax, DWORD PTR _cmd$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, DWORD PTR _group$[ebp]
	jne	SHORT $LN8@Cmd_Unlink

; 1090 : 		{
; 1091 : 			prev = &cmd->next;

	mov	eax, DWORD PTR _cmd$[ebp]
	mov	DWORD PTR _prev$[ebp], eax

; 1092 : 			continue;

	jmp	SHORT $LN2@Cmd_Unlink
$LN8@Cmd_Unlink:

; 1093 : 		}
; 1094 : 
; 1095 : 		*prev = cmd->next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1096 : 
; 1097 : 		if( cmd->name ) Mem_Free( cmd->name );

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN9@Cmd_Unlink
	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Unlink@@9@9
	add	eax, 30					; 0000001eH
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@Cmd_Unlink:

; 1098 : 		if( cmd->desc ) Mem_Free( cmd->desc );

	mov	eax, DWORD PTR _cmd$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN10@Cmd_Unlink
	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Unlink@@9@9
	add	eax, 31					; 0000001fH
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@Cmd_Unlink:

; 1099 : 
; 1100 : 		Mem_Free( cmd );

	mov	eax, DWORD PTR ?__LINE__Var@?0??Cmd_Unlink@@9@9
	add	eax, 33					; 00000021H
	push	eax
	push	OFFSET ??_C@_0DA@FBEMEBKB@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _cmd$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1101 : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 1102 : 	}

	jmp	$LN2@Cmd_Unlink
$LN3@Cmd_Unlink:

; 1103 : 
; 1104 : 	Con_Reportf( "unlink %i commands\n", count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@DCJKOCHK@unlink?5?$CFi?5commands?6@
	call	_Con_Reportf
	add	esp, 8
$LN1@Cmd_Unlink:

; 1105 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Unlink ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Init
_TEXT	SEGMENT
_Cmd_Init PROC						; COMDAT

; 1124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1125 : 	Cbuf_Init();

	call	_Cbuf_Init

; 1126 : 
; 1127 : 	cmd_functions = NULL;

	mov	DWORD PTR _cmd_functions, 0

; 1128 : 	cmd_condition = 0;

	mov	DWORD PTR _cmd_condition, 0

; 1129 : 	cmd_alias = NULL;

	mov	DWORD PTR _cmd_alias, 0

; 1130 : 	cmd_args = NULL;

	mov	DWORD PTR _cmd_args, 0

; 1131 : 	cmd_argc = 0;

	mov	DWORD PTR _cmd_argc, 0

; 1132 : 
; 1133 : 	// register our commands
; 1134 : 	Cmd_AddCommand( "echo", Cmd_Echo_f, "print a message to the console (useful in scripts)" );

	push	OFFSET ??_C@_0DD@HOLPNNNB@print?5a?5message?5to?5the?5console?5@
	push	OFFSET _Cmd_Echo_f
	push	OFFSET ??_C@_04OFDNEFMC@echo@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1135 : 	Cmd_AddCommand( "wait", Cmd_Wait_f, "make script execution wait for some rendered frames" );

	push	OFFSET ??_C@_0DE@MEIKPKCK@make?5script?5execution?5wait?5for?5@
	push	OFFSET _Cmd_Wait_f
	push	OFFSET ??_C@_04PNOAOIAG@wait@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1136 : 	Cmd_AddCommand( "cmdlist", Cmd_List_f, "display all console commands beginning with the specified prefix" );

	push	OFFSET ??_C@_0EB@OAEACPLJ@display?5all?5console?5commands?5be@
	push	OFFSET _Cmd_List_f
	push	OFFSET ??_C@_07LKLFKPJJ@cmdlist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1137 : 	Cmd_AddCommand( "stuffcmds", Cmd_StuffCmds_f, "execute commandline parameters (must be present in .rc script)" );

	push	OFFSET ??_C@_0DP@EFBHGBPO@execute?5commandline?5parameters?5@
	push	OFFSET _Cmd_StuffCmds_f
	push	OFFSET ??_C@_09CCCNFKCN@stuffcmds@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1138 : 	Cmd_AddCommand( "cmd", Cmd_ForwardToServer, "send a console commandline to the server" );

	push	OFFSET ??_C@_0CJ@DIAGANNE@send?5a?5console?5commandline?5to?5t@
	push	OFFSET _Cmd_ForwardToServer
	push	OFFSET ??_C@_03LGLGIONO@cmd@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1139 : 	Cmd_AddCommand( "alias", Cmd_Alias_f, "create a script function. Without arguments show the list of all alias" );

	push	OFFSET ??_C@_0EH@OJMKBLHF@create?5a?5script?5function?4?5Witho@
	push	OFFSET _Cmd_Alias_f
	push	OFFSET ??_C@_05NKHOCLEE@alias@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1140 : 	Cmd_AddCommand( "unalias", Cmd_UnAlias_f, "remove a script function" );

	push	OFFSET ??_C@_0BJ@FDJGDOFM@remove?5a?5script?5function@
	push	OFFSET _Cmd_UnAlias_f
	push	OFFSET ??_C@_07DBKHPNMC@unalias@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1141 : 	Cmd_AddCommand( "if", Cmd_If_f, "compare and set condition bits" );

	push	OFFSET ??_C@_0BP@FPBPAFLB@compare?5and?5set?5condition?5bits@
	push	OFFSET _Cmd_If_f
	push	OFFSET ??_C@_02HEBPBKGD@if@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1142 : 	Cmd_AddCommand( "else", Cmd_Else_f, "invert condition bit" );

	push	OFFSET ??_C@_0BF@CAMMAINI@invert?5condition?5bit@
	push	OFFSET _Cmd_Else_f
	push	OFFSET ??_C@_04FHMCPBIP@else@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1143 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Argv
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_Cmd_Argv PROC						; COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 486  : 	if((uint)arg >= cmd_argc )

	mov	eax, DWORD PTR _arg$[ebp]
	cmp	eax, DWORD PTR _cmd_argc
	jb	SHORT $LN2@Cmd_Argv

; 487  : 		return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN1@Cmd_Argv
$LN2@Cmd_Argv:

; 488  : 	return cmd_argv[arg];	

	mov	eax, DWORD PTR _arg$[ebp]
	mov	eax, DWORD PTR _cmd_argv[eax*4]
$LN1@Cmd_Argv:

; 489  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Argv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Args
_TEXT	SEGMENT
_Cmd_Args PROC						; COMDAT

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 498  : 	return cmd_args;

	mov	eax, DWORD PTR _cmd_args

; 499  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cmd_Argc
_TEXT	SEGMENT
_Cmd_Argc PROC						; COMDAT

; 475  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 476  : 	return cmd_argc;

	mov	eax, DWORD PTR _cmd_argc

; 477  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cmd_Argc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_Execute
_TEXT	SEGMENT
tv168 = -2400						; size = 4
tv163 = -2400						; size = 4
tv73 = -2400						; size = 4
$T1 = -2396						; size = 4
$T2 = -2392						; size = 4
_comment$ = -2068					; size = 4
_quotes$ = -2064					; size = 4
_i$ = -2060						; size = 4
_line$ = -2056						; size = 2048
_text$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Cbuf_Execute PROC					; COMDAT

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2400				; 00000960H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
$LN2@Cbuf_Execu:

; 148  : 	char	*text;
; 149  : 	char	line[MAX_CMD_LINE];
; 150  : 	int	i, quotes;
; 151  : 	char	*comment;
; 152  : 
; 153  : 	while( cmd_text.cursize )

	cmp	DWORD PTR _cmd_text+4, 0
	je	$LN23@Cbuf_Execu

; 154  : 	{
; 155  : 		// find a \n or ; line break
; 156  : 		text = (char *)cmd_text.data;

	mov	eax, DWORD PTR _cmd_text
	mov	DWORD PTR _text$[ebp], eax

; 157  : 
; 158  : 		quotes = false;

	mov	DWORD PTR _quotes$[ebp], 0

; 159  : 		comment = NULL;

	mov	DWORD PTR _comment$[ebp], 0

; 160  : 
; 161  : 		for( i = 0; i < cmd_text.cursize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@Cbuf_Execu
$LN4@Cbuf_Execu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@Cbuf_Execu:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cmd_text+4
	jge	$LN5@Cbuf_Execu

; 162  : 		{
; 163  : 			if( !comment )

	cmp	DWORD PTR _comment$[ebp], 0
	jne	$LN7@Cbuf_Execu

; 164  : 			{
; 165  : 				if( text[i] == '"' ) quotes = !quotes;

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN8@Cbuf_Execu
	cmp	DWORD PTR _quotes$[ebp], 0
	jne	SHORT $LN24@Cbuf_Execu
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN25@Cbuf_Execu
$LN24@Cbuf_Execu:
	mov	DWORD PTR tv73[ebp], 0
$LN25@Cbuf_Execu:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR _quotes$[ebp], eax
$LN8@Cbuf_Execu:

; 166  : 
; 167  : 				if( quotes )

	cmp	DWORD PTR _quotes$[ebp], 0
	je	SHORT $LN9@Cbuf_Execu

; 168  : 				{
; 169  : 					// make sure i doesn't get > cursize which causes a negative size in memmove, which is fatal --blub
; 170  : 					if( i < ( cmd_text.cursize - 1 ) && ( text[i+0] == '\\' && (text[i+1] == '"' || text[i+1] == '\\')))

	mov	eax, DWORD PTR _cmd_text+4
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN11@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN11@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN12@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN11@Cbuf_Execu
$LN12@Cbuf_Execu:

; 171  : 						i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@Cbuf_Execu:

; 172  : 				}

	jmp	SHORT $LN7@Cbuf_Execu
$LN9@Cbuf_Execu:

; 173  : 				else
; 174  : 				{
; 175  : 					if( text[i+0] == '/' && text[i+1] == '/' && ( i == 0 || (byte)text[i - 1] <= ' ' ))

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN13@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN13@Cbuf_Execu
	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $LN14@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN13@Cbuf_Execu
$LN14@Cbuf_Execu:

; 176  : 						comment = &text[i];

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _comment$[ebp], eax
$LN13@Cbuf_Execu:

; 177  : 					if( text[i] == ';' ) break; // don't break if inside a quoted string or comment

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 59					; 0000003bH
	jne	SHORT $LN7@Cbuf_Execu
	jmp	SHORT $LN5@Cbuf_Execu
$LN7@Cbuf_Execu:

; 178  : 				}
; 179  : 			}
; 180  : 
; 181  : 			if( text[i] == '\n' || text[i] == '\r' )

	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN17@Cbuf_Execu
	mov	eax, DWORD PTR _text$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN16@Cbuf_Execu
$LN17@Cbuf_Execu:

; 182  : 				break;

	jmp	SHORT $LN5@Cbuf_Execu
$LN16@Cbuf_Execu:

; 183  : 		}

	jmp	$LN4@Cbuf_Execu
$LN5@Cbuf_Execu:

; 184  : 
; 185  : 		if( i >= ( MAX_CMD_LINE - 1 ))

	cmp	DWORD PTR _i$[ebp], 2047		; 000007ffH
	jl	SHORT $LN18@Cbuf_Execu

; 186  : 		{
; 187  : 			Con_DPrintf( S_ERROR "Cbuf_Execute: command string owerflow\n" );

	push	OFFSET ??_C@_0DC@BCFOHFGH@?$FO1Error?3?$FO7?5Cbuf_Execute?3?5comman@
	call	_Con_DPrintf
	add	esp, 4

; 188  : 			line[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN26@Cbuf_Execu
	jmp	SHORT $LN27@Cbuf_Execu
$LN26@Cbuf_Execu:
	call	___report_rangecheckfailure
$LN27@Cbuf_Execu:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _line$[ebp+edx], 0

; 189  : 		}

	jmp	$LN19@Cbuf_Execu
$LN18@Cbuf_Execu:

; 190  : 		else
; 191  : 		{
; 192  : 			memcpy( line, text, comment ? (comment - text) : i );

	cmp	DWORD PTR _comment$[ebp], 0
	je	SHORT $LN28@Cbuf_Execu
	mov	eax, DWORD PTR _comment$[ebp]
	sub	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN29@Cbuf_Execu
$LN28@Cbuf_Execu:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
$LN29@Cbuf_Execu:
	mov	edx, DWORD PTR tv163[ebp]
	push	edx
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 193  : 			line[comment ? (comment - text) : i] = 0;

	cmp	DWORD PTR _comment$[ebp], 0
	je	SHORT $LN30@Cbuf_Execu
	mov	eax, DWORD PTR _comment$[ebp]
	sub	eax, DWORD PTR _text$[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN31@Cbuf_Execu
$LN30@Cbuf_Execu:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv168[ebp], ecx
$LN31@Cbuf_Execu:
	mov	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN32@Cbuf_Execu
	jmp	SHORT $LN33@Cbuf_Execu
$LN32@Cbuf_Execu:
	call	___report_rangecheckfailure
$LN33@Cbuf_Execu:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _line$[ebp+eax], 0
$LN19@Cbuf_Execu:

; 194  : 		}
; 195  : 
; 196  : 		// delete the text from the command buffer and move remaining commands down
; 197  : 		// this is necessary because commands (exec) can insert data at the
; 198  : 		// beginning of the text buffer
; 199  : 		if( i == cmd_text.cursize )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _cmd_text+4
	jne	SHORT $LN20@Cbuf_Execu

; 200  : 		{
; 201  : 			cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 202  : 		}

	jmp	SHORT $LN21@Cbuf_Execu
$LN20@Cbuf_Execu:

; 203  : 		else
; 204  : 		{
; 205  : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 206  : 			cmd_text.cursize -= i;

	mov	eax, DWORD PTR _cmd_text+4
	sub	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cmd_text+4, eax

; 207  : 			memmove( cmd_text.data, text + i, cmd_text.cursize );

	mov	eax, DWORD PTR _cmd_text+4
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmd_text
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN21@Cbuf_Execu:

; 208  : 		}
; 209  : 
; 210  : 		// execute the command line
; 211  : 		Cmd_ExecuteString( line );

	lea	eax, DWORD PTR _line$[ebp]
	push	eax
	call	_Cmd_ExecuteString
	add	esp, 4

; 212  : 
; 213  : 		if( cmd_wait )

	cmp	DWORD PTR _cmd_wait, 0
	je	SHORT $LN22@Cbuf_Execu

; 214  : 		{
; 215  : 			// skip out while text still remains in buffer,
; 216  : 			// leaving it for next frame
; 217  : 			cmd_wait = false;

	mov	DWORD PTR _cmd_wait, 0

; 218  : 			break;

	jmp	SHORT $LN23@Cbuf_Execu
$LN22@Cbuf_Execu:

; 219  : 		}
; 220  : 	}

	jmp	$LN2@Cbuf_Execu
$LN23@Cbuf_Execu:

; 221  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_Execute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_ExecStuffCmds
_TEXT	SEGMENT
$T1 = -2392						; size = 4
$T2 = -2388						; size = 4
_l$ = -2064						; size = 4
_j$ = -2060						; size = 4
_i$ = -2056						; size = 4
_build$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_Cbuf_ExecStuffCmds PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2392				; 00000958H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 232  : 	char	build[MAX_CMD_LINE]; // this is for all commandline options combined (and is bounds checked)
; 233  : 	int	i, j, l = 0;

	mov	DWORD PTR _l$[ebp], 0

; 234  : 
; 235  : 	// no reason to run the commandline arguments twice
; 236  : 	if( !host.stuffcmds_pending )

	cmp	DWORD PTR _host+34348, 0
	jne	SHORT $LN13@Cbuf_ExecS

; 237  : 		return;

	jmp	$LN23@Cbuf_ExecS
$LN13@Cbuf_ExecS:

; 238  : 	build[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 2048		; 00000800H
	jae	SHORT $LN24@Cbuf_ExecS
	jmp	SHORT $LN25@Cbuf_ExecS
$LN24@Cbuf_ExecS:
	call	___report_rangecheckfailure
$LN25@Cbuf_ExecS:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _build$[ebp+edx], 0

; 239  : 
; 240  : 	for( i = 0; i < host.argc; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Cbuf_ExecS
$LN2@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+920
	jge	$LN3@Cbuf_ExecS

; 241  : 	{
; 242  : 		if( host.argv[i] && host.argv[i][0] == '+' && ( host.argv[i][1] < '0' || host.argv[i][1] > '9' ) && l + Q_strlen( host.argv[i] ) - 1 <= sizeof( build ) - 1 )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _host[eax*4+924], 0
	je	$LN14@Cbuf_ExecS
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 43					; 0000002bH
	jne	$LN14@Cbuf_ExecS
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN15@Cbuf_ExecS
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 57					; 00000039H
	jle	$LN14@Cbuf_ExecS
$LN15@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR [edx+eax-1]
	cmp	eax, 2047				; 000007ffH
	ja	$LN14@Cbuf_ExecS

; 243  : 		{
; 244  : 			j = 1;

	mov	DWORD PTR _j$[ebp], 1
$LN5@Cbuf_ExecS:

; 245  : 
; 246  : 			while( host.argv[i][j] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN6@Cbuf_ExecS

; 247  : 				build[l++] = host.argv[i][j++];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _build$[ebp+edx], cl
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN5@Cbuf_ExecS
$LN6@Cbuf_ExecS:

; 248  : 
; 249  : 			for( i++; i < host.argc; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN9@Cbuf_ExecS
$LN7@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _host+920
	jge	$LN8@Cbuf_ExecS

; 250  : 			{
; 251  : 				if( !host.argv[i] ) continue;

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _host[eax*4+924], 0
	jne	SHORT $LN16@Cbuf_ExecS
	jmp	SHORT $LN7@Cbuf_ExecS
$LN16@Cbuf_ExecS:

; 252  : 				if(( host.argv[i][0] == '+' || host.argv[i][0] == '-' ) && ( host.argv[i][1] < '0' || host.argv[i][1] > '9' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN18@Cbuf_ExecS
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _host[edx*4+924]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN17@Cbuf_ExecS
$LN18@Cbuf_ExecS:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN19@Cbuf_ExecS
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _host[ecx*4+924]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN17@Cbuf_ExecS
$LN19@Cbuf_ExecS:

; 253  : 					break;

	jmp	$LN8@Cbuf_ExecS
$LN17@Cbuf_ExecS:

; 254  : 				if( l + Q_strlen( host.argv[i] ) + 4 > sizeof( build ) - 1 )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _l$[ebp]
	lea	eax, DWORD PTR [edx+eax+4]
	cmp	eax, 2047				; 000007ffH
	jbe	SHORT $LN20@Cbuf_ExecS

; 255  : 					break;

	jmp	$LN8@Cbuf_ExecS
$LN20@Cbuf_ExecS:

; 256  : 				build[l++] = ' ';

	mov	eax, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+eax], 32		; 00000020H
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$[ebp], ecx

; 257  : 	
; 258  : 				if( Q_strchr( host.argv[i], ' ' ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@Cbuf_ExecS

; 259  : 					build[l++] = '\"';

	mov	eax, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+eax], 34		; 00000022H
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$[ebp], ecx
$LN21@Cbuf_ExecS:

; 260  : 	
; 261  : 				for( j = 0; host.argv[i][j]; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN12@Cbuf_ExecS
$LN10@Cbuf_ExecS:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN12@Cbuf_ExecS:
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN11@Cbuf_ExecS

; 262  : 					build[l++] = host.argv[i][j];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _build$[ebp+edx], cl
	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $LN10@Cbuf_ExecS
$LN11@Cbuf_ExecS:

; 263  : 	
; 264  : 				if( Q_strchr( host.argv[i], ' ' ))

	push	32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _host[eax*4+924]
	push	ecx
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@Cbuf_ExecS

; 265  : 					build[l++] = '\"';

	mov	eax, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+eax], 34		; 00000022H
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$[ebp], ecx
$LN22@Cbuf_ExecS:

; 266  : 			}

	jmp	$LN7@Cbuf_ExecS
$LN8@Cbuf_ExecS:

; 267  : 			build[l++] = '\n';

	mov	eax, DWORD PTR _l$[ebp]
	mov	BYTE PTR _build$[ebp+eax], 10		; 0000000aH
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$[ebp], ecx

; 268  : 			i--;

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@Cbuf_ExecS:

; 269  : 		}
; 270  : 	}

	jmp	$LN2@Cbuf_ExecS
$LN3@Cbuf_ExecS:

; 271  : 
; 272  : 	// now terminate the combined string and prepend it to the command buffer
; 273  : 	// we already reserved space for the terminator
; 274  : 	build[l++] = 0;

	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _l$[ebp]
	add	ecx, 1
	mov	DWORD PTR _l$[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 2048		; 00000800H
	jae	SHORT $LN26@Cbuf_ExecS
	jmp	SHORT $LN27@Cbuf_ExecS
$LN26@Cbuf_ExecS:
	call	___report_rangecheckfailure
$LN27@Cbuf_ExecS:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _build$[ebp+edx], 0

; 275  : 	Cbuf_InsertText( build );

	lea	eax, DWORD PTR _build$[ebp]
	push	eax
	call	_Cbuf_InsertText
	add	esp, 4

; 276  : 	Cbuf_Execute(); // apply now

	call	_Cbuf_Execute

; 277  : 
; 278  : 	// this command can be called only from .rc
; 279  : 	Cmd_RemoveCommand( "stuffcmds" );

	push	OFFSET ??_C@_09CCCNFKCN@stuffcmds@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 280  : 	host.stuffcmds_pending = false;

	mov	DWORD PTR _host+34348, 0
$LN23@Cbuf_ExecS:

; 281  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_ExecStuffCmds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_InsertText
_TEXT	SEGMENT
_l$ = -4						; size = 4
_text$ = 8						; size = 4
_Cbuf_InsertText PROC					; COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 127  : 	int	l = Q_strlen( text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 128  : 
; 129  : 	if(( cmd_text.cursize + l ) >= cmd_text.maxsize )

	mov	eax, DWORD PTR _cmd_text+4
	add	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _cmd_text+8
	jl	SHORT $LN2@Cbuf_Inser

; 130  : 	{
; 131  : 		Con_Reportf( S_WARN "Cbuf_InsertText: overflow\n" );

	push	OFFSET ??_C@_0CI@OFNEIEPG@?$FO3Warning?3?$FO7?5Cbuf_InsertText?3?5o@
	call	_Con_Reportf
	add	esp, 4

; 132  : 	}

	jmp	SHORT $LN1@Cbuf_Inser
$LN2@Cbuf_Inser:

; 133  : 	else
; 134  : 	{
; 135  : 		memmove( cmd_text.data + l, cmd_text.data, cmd_text.cursize );

	mov	eax, DWORD PTR _cmd_text+4
	push	eax
	mov	ecx, DWORD PTR _cmd_text
	push	ecx
	mov	edx, DWORD PTR _cmd_text
	add	edx, DWORD PTR _l$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 136  : 		memcpy( cmd_text.data, text, l );

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cmd_text
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 137  : 		cmd_text.cursize += l;

	mov	eax, DWORD PTR _cmd_text+4
	add	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _cmd_text+4, eax
$LN1@Cbuf_Inser:

; 138  : 	}
; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_InsertText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_AddText
_TEXT	SEGMENT
_l$ = -4						; size = 4
_text$ = 8						; size = 4
_Cbuf_AddText PROC					; COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 105  : 	int	l = Q_strlen( text );

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _l$[ebp], eax

; 106  : 
; 107  : 	if(( cmd_text.cursize + l ) >= cmd_text.maxsize )

	mov	eax, DWORD PTR _cmd_text+4
	add	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _cmd_text+8
	jl	SHORT $LN2@Cbuf_AddTe

; 108  : 	{
; 109  : 		Con_Reportf( S_WARN "Cbuf_AddText: overflow\n" );

	push	OFFSET ??_C@_0CF@OCNJCEGP@?$FO3Warning?3?$FO7?5Cbuf_AddText?3?5over@
	call	_Con_Reportf
	add	esp, 4

; 110  : 	}

	jmp	SHORT $LN1@Cbuf_AddTe
$LN2@Cbuf_AddTe:

; 111  : 	else
; 112  : 	{
; 113  : 		memcpy( Cbuf_GetSpace( &cmd_text, l ), text, l );

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$[ebp]
	push	edx
	push	OFFSET _cmd_text
	call	_Cbuf_GetSpace
	add	esp, 8
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Cbuf_AddTe:

; 114  : 	}
; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_AddText ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_Clear
_TEXT	SEGMENT
_Cbuf_Clear PROC					; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 71   : 	memset( cmd_text.data, 0, sizeof( cmd_text_buf ));

	push	65536					; 00010000H
	push	0
	mov	eax, DWORD PTR _cmd_text
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 72   : 	cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_Clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cmd.c
;	COMDAT _Cbuf_Init
_TEXT	SEGMENT
_Cbuf_Init PROC						; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 59   : 	cmd_text.data = cmd_text_buf;

	mov	DWORD PTR _cmd_text, OFFSET _cmd_text_buf

; 60   : 	cmd_text.maxsize = MAX_CMD_BUFFER;

	mov	DWORD PTR _cmd_text+8, 65536		; 00010000H

; 61   : 	cmd_text.cursize = 0;

	mov	DWORD PTR _cmd_text+4, 0

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_Cbuf_Init ENDP
_TEXT	ENDS
END
