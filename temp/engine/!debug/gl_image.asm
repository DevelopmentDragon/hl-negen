; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_image.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_GL_FreeImage
PUBLIC	_GL_Bind
PUBLIC	_R_SetTextureParameters
PUBLIC	_R_GetTexture
PUBLIC	_GL_LoadTexture
PUBLIC	_GL_LoadTextureArray
PUBLIC	_GL_LoadTextureFromBuffer
PUBLIC	_GL_ResampleTexture
PUBLIC	_GL_CreateTexture
PUBLIC	_GL_CreateTextureArray
PUBLIC	_GL_ProcessTexture
PUBLIC	_GL_UpdateTexSize
PUBLIC	_GL_ApplyTextureParams
PUBLIC	_GL_FindTexture
PUBLIC	_GL_FreeTexture
PUBLIC	_R_InitDlightTexture
PUBLIC	_R_TextureList_f
PUBLIC	_R_InitImages
PUBLIC	_R_ShutdownImages
PUBLIC	_GL_BoxFilter3x3
PUBLIC	_GL_ApplyFilter
PUBLIC	_GL_CheckTexName
PUBLIC	?__LINE__Var@?0??R_GetTexture@@9@9		; `R_GetTexture'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ ; `string'
PUBLIC	??_C@_02LBACCDEL@1D@				; `string'
PUBLIC	??_C@_02LDEEJNBC@2D@				; `string'
PUBLIC	??_C@_02LCIGPHCF@3D@				; `string'
PUBLIC	??_C@_04CJLGPKHJ@Cube@				; `string'
PUBLIC	??_C@_05HPPFDPIF@Array@				; `string'
PUBLIC	??_C@_04HGDEFKPD@Rect@				; `string'
PUBLIC	??_C@_02HHFHKOHM@?$DP?$DP@			; `string'
PUBLIC	?__LINE__Var@?0??GL_Bind@@9@9			; `GL_Bind'::`1'::__LINE__Var
PUBLIC	??_C@_0CF@MPKGELAE@texnum?5?$DO?$DN?50?5?$CG?$CG?5texnum?5?$DM?5MAX_TEX@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_ApplyTextureParams@@9@9	; `GL_ApplyTextureParams'::`1'::__LINE__Var
PUBLIC	??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??GL_UpdateTextureParams@@9@9	; `GL_UpdateTextureParams'::`1'::__LINE__Var
PUBLIC	??_C@_0O@DGIPFEHA@gl_anisotropy@		; `string'
PUBLIC	??_C@_0BD@KLPBGJAB@gl_texture_lodbias@		; `string'
PUBLIC	??_C@_0DG@JMKCEBIO@GL_CalcTextureSize?3?5bad?5texture@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_CalcMipmapCount@@9@9	; `GL_CalcMipmapCount'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_SetTextureDimensions@@9@9	; `GL_SetTextureDimensions'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_SetTextureTarget@@9@9	; `GL_SetTextureTarget'::`1'::__LINE__Var
PUBLIC	??_C@_0M@PGEAODHA@pic?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??GL_SetTextureFormat@@9@9	; `GL_SetTextureFormat'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_ResampleTexture@@9@9	; `GL_ResampleTexture'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_TextureImageRAW@@9@9	; `GL_TextureImageRAW'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_TextureImageDXT@@9@9	; `GL_TextureImageDXT'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??GL_CheckTexImageError@@9@9	; `GL_CheckTexImageError'::`1'::__LINE__Var
PUBLIC	??_C@_0CO@HEGNHHDC@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5while?5uplo@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_UploadTexture@@9@9		; `GL_UploadTexture'::`1'::__LINE__Var
PUBLIC	??_C@_0ED@DEBJKEAE@?$FO1Error?3?$FO7?5GL_UploadTexture?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CE@IJOCGAGP@GL_UploadTexture?3?5?$CFs?5s?$CG3?5?$FL?$CFd?5x?5@ ; `string'
PUBLIC	??_C@_0CM@HKKDAIOF@GL_UploadTexture?3?5?$CFs?5image?5buff@ ; `string'
PUBLIC	??_C@_0CP@PJGPEJK@?$FO1Error?3?$FO7?5LoadTexture?3?5too?5lon@ ; `string'
PUBLIC	??_C@_0CN@DDGFAJIN@GL_AllocTexture?3?5MAX_TEXTURES?5l@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_DeleteTexture@@9@9		; `GL_DeleteTexture'::`1'::__LINE__Var
PUBLIC	??_C@_0EM@OBIPLNLC@?$FO1Error?3?$FO7?5GL_DeleteTexture?3?5tr@ ; `string'
PUBLIC	?__LINE__Var@?0??GL_LoadTextureArray@@9@9	; `GL_LoadTextureArray'::`1'::__LINE__Var
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_01DNKMNLPK@?$HM@				; `string'
PUBLIC	??_C@_04KJOBHKIC@?$FL?$CFi?$FN@			; `string'
PUBLIC	??_C@_0EF@DOCILBDF@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ ; `string'
PUBLIC	??_C@_0EC@GJAFFJKB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ ; `string'
PUBLIC	??_C@_0EI@EBJDPNMO@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ ; `string'
PUBLIC	??_C@_0ED@HMAKJHB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ ; `string'
PUBLIC	??_C@_0FK@GJHFFGAI@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ ; `string'
PUBLIC	??_C@_0DP@KMJLBDPK@GL_LoadTextureFromBuffer?3?5could@ ; `string'
PUBLIC	??_C@_0DE@DAELPBJM@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5b@ ; `string'
PUBLIC	??_C@_0DE@NHNGPALK@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5n@ ; `string'
PUBLIC	??_C@_0ED@IPLDKKAL@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5c@ ; `string'
PUBLIC	??_C@_07MNOAAFDD@?$CKdlight@			; `string'
PUBLIC	??_C@_08KPIGECMN@?$CKdefault@			; `string'
PUBLIC	??_C@_09KHFKAJMC@?$CKparticle@			; `string'
PUBLIC	??_C@_06LLGHKAEB@?$CKwhite@			; `string'
PUBLIC	??_C@_05LFMGNIOO@?$CKgray@			; `string'
PUBLIC	??_C@_06FPKCCFDN@?$CKblack@			; `string'
PUBLIC	??_C@_0M@POAMJEF@?$CKcintexture@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0FI@DHCNGGFA@?5?9id?9?5?5?5?9w?9?5?5?9h?9?5?5?5?5?5?9size?9?5?9fm@ ; `string'
PUBLIC	??_C@_05LHKLCIPC@?$CF4i?3?5@			; `string'
PUBLIC	??_C@_08GNHPGGLF@?$CF4i?5?$CF4i?5@		; `string'
PUBLIC	??_C@_05BMAMJJGO@?$CF12s?5@			; `string'
PUBLIC	??_C@_06GJCEDBCD@CRGBA?5@			; `string'
PUBLIC	??_C@_06CADBJADE@CRGB?5?5@			; `string'
PUBLIC	??_C@_06HICDJPH@CLA?5?5?5@			; `string'
PUBLIC	??_C@_06KDNAGHAK@CL?5?5?5?5@			; `string'
PUBLIC	??_C@_06BPEOHENE@CA?5?5?5?5@			; `string'
PUBLIC	??_C@_06PDBNPGLJ@CI?5?5?5?5@			; `string'
PUBLIC	??_C@_06GIBLFMGF@DXT1c?5@			; `string'
PUBLIC	??_C@_06GLJPIIAL@DXT1a?5@			; `string'
PUBLIC	??_C@_06LAMOKHHH@DXT3?5?5@			; `string'
PUBLIC	??_C@_06JFKFPIKL@DXT5?5?5@			; `string'
PUBLIC	??_C@_06LFPIHMPN@ATI2?5?5@			; `string'
PUBLIC	??_C@_06GINGLEPI@RGBA?5?5@			; `string'
PUBLIC	??_C@_06HKODEGDA@RGBA8?5@			; `string'
PUBLIC	??_C@_06HDPJLPFE@RGBA4?5@			; `string'
PUBLIC	??_C@_06OLEMCEJO@RGB?5?5?5@			; `string'
PUBLIC	??_C@_06HOOBFLOO@RGB8?5?5@			; `string'
PUBLIC	??_C@_06IMILIDDD@RGB5?5?5@			; `string'
PUBLIC	??_C@_06MJMAAGHK@L4A4?5?5@			; `string'
PUBLIC	??_C@_06PENEHJLJ@L8A8?5?5@			; `string'
PUBLIC	??_C@_06LCOJJIEP@L4?5?5?5?5@			; `string'
PUBLIC	??_C@_06MFCLFIDE@L8?5?5?5?5@			; `string'
PUBLIC	??_C@_06KEPMDJPE@A8?5?5?5?5@			; `string'
PUBLIC	??_C@_06JHBDHHJD@I8?5?5?5?5@			; `string'
PUBLIC	??_C@_06NBKPKCMM@DPTH24@			; `string'
PUBLIC	??_C@_06IGDHGPHN@DPTH32@			; `string'
PUBLIC	??_C@_06BDMJMDAB@L16F?5?5@			; `string'
PUBLIC	??_C@_06KLIBMEMK@L32F?5?5@			; `string'
PUBLIC	??_C@_06INKOAFNO@LA16F?5@			; `string'
PUBLIC	??_C@_06HIAMMBOJ@LA32F?5@			; `string'
PUBLIC	??_C@_06GMBGABFA@RG16F?5@			; `string'
PUBLIC	??_C@_06JJLEMFGH@RG32F?5@			; `string'
PUBLIC	??_C@_06CIOFAHIH@RGB16F@			; `string'
PUBLIC	??_C@_06IFOFGHNA@RGB32F@			; `string'
PUBLIC	??_C@_07OFCDKLCB@RGBA16F@			; `string'
PUBLIC	??_C@_07EICDMLHG@RGBA32F@			; `string'
PUBLIC	??_C@_0M@CFABDMBF@?5?$FO1ERROR?$FO7?5@		; `string'
PUBLIC	??_C@_06MCIAPOOA@?51D?5?5?5@			; `string'
PUBLIC	??_C@_06EEBEIMEO@?52D?5?5?5@			; `string'
PUBLIC	??_C@_06IPEIFPOL@?53D?5?5?5@			; `string'
PUBLIC	??_C@_06GIADBHEF@CUBE?5?5@			; `string'
PUBLIC	??_C@_06HPLJJLOO@RECT?5?5@			; `string'
PUBLIC	??_C@_06FGDLGFNO@ARRAY?5@			; `string'
PUBLIC	??_C@_06OPGEOFKA@?$DP?$DP?$DP?$DP?5?5@		; `string'
PUBLIC	??_C@_08DDGKKKPC@normal?5?5@			; `string'
PUBLIC	??_C@_08HCDGFIFF@diffuse?5@			; `string'
PUBLIC	??_C@_0L@EDEJAPEP@YCoCg?5?5?5?5?5@		; `string'
PUBLIC	??_C@_0L@LNMBILNN@ortho?5?5?5?5?5@		; `string'
PUBLIC	??_C@_0L@BIINDBLA@stereo?5?5?5?5@		; `string'
PUBLIC	??_C@_0L@LGBJKLIF@parabolic?5@			; `string'
PUBLIC	??_C@_0L@PKGMOELN@quartic?5?5?5@		; `string'
PUBLIC	??_C@_0L@IPBFJKHI@azimuthal?5@			; `string'
PUBLIC	??_C@_0L@LAEMIHEI@default?5?5?5@		; `string'
PUBLIC	??_C@_07OMFDAMIC@clamp?5?5@			; `string'
PUBLIC	??_C@_07JBLMFJLG@border?5@			; `string'
PUBLIC	??_C@_07LCDAFEIN@repeat?5@			; `string'
PUBLIC	??_C@_07LLBGNMAI@?5?5?5?$CFd?5?5@		; `string'
PUBLIC	??_C@_05LDOEBFOB@?5?5?$CFs?6@			; `string'
PUBLIC	??_C@_0DL@PHAADJIH@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0BD@GMIIEODJ@?$CFi?5total?5textures?6@	; `string'
PUBLIC	??_C@_0BG@KLOGNFAM@?$CFs?5total?5memory?5used?6@ ; `string'
PUBLIC	??_C@_08PIMAOFKI@?$CKunused?$CK@		; `string'
PUBLIC	??_C@_0BN@GENJBCGG@display?5loaded?5textures?5list@ ; `string'
PUBLIC	??_C@_0M@KECGGPF@texturelist@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3c010204
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f400000
PUBLIC	__real@3f800000
PUBLIC	__real@4041800000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@42fe0000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Sys_Error:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Cmd_RemoveCommand:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_LoadImage:PROC
EXTRN	_FS_CopyImage:PROC
EXTRN	_FS_FreeImage:PROC
EXTRN	_Image_Process:PROC
EXTRN	_Image_SetForceFlags:PROC
EXTRN	_Host_Error:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_HashKey:PROC
EXTRN	_CL_IsQuakeCompatible:PROC
EXTRN	_sqrt:PROC
EXTRN	_VectorNormalizeLength2:PROC
EXTRN	_GL_SelectTexture:PROC
EXTRN	_GL_CleanupAllTextureUnits:PROC
EXTRN	_GL_ErrorString:PROC
EXTRN	_GL_Support:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_PFDesc:BYTE
EXTRN	_r_temppool:DWORD
EXTRN	_tr:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	_glw_state:BYTE
EXTRN	_gl_texture_anisotropy:DWORD
EXTRN	_gl_check_errors:DWORD
EXTRN	_gl_texture_lodbias:DWORD
EXTRN	_gl_texture_nearest:DWORD
EXTRN	_gl_lightmap_nearest:DWORD
EXTRN	_gl_emboss_scale:DWORD
EXTRN	_gl_round_down:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_gl_textures DB	0140000H DUP (?)
_gl_texturesHashTable DD 0400H DUP (?)
_gl_numTextures DD 01H DUP (?)
?scaledImage@?1??GL_ResampleTexture@@9@9 DD 01H DUP (?)	; `GL_ResampleTexture'::`2'::scaledImage
?data2D@?1??GL_FakeImage@@9@9 DB 0400H DUP (?)		; `GL_FakeImage'::`2'::data2D
?r_image@?1??GL_FakeImage@@9@9 DB 024H DUP (?)		; `GL_FakeImage'::`2'::r_image
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4041800000000000
CONST	SEGMENT
__real@4041800000000000 DQ 04041800000000000r	; 35
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3c010204
CONST	SEGMENT
__real@3c010204 DD 03c010204r			; 0.00787402
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0M@KECGGPF@texturelist@
CONST	SEGMENT
??_C@_0M@KECGGPF@texturelist@ DB 'texturelist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GENJBCGG@display?5loaded?5textures?5list@
CONST	SEGMENT
??_C@_0BN@GENJBCGG@display?5loaded?5textures?5list@ DB 'display loaded te'
	DB	'xtures list', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08PIMAOFKI@?$CKunused?$CK@
CONST	SEGMENT
??_C@_08PIMAOFKI@?$CKunused?$CK@ DB '*unused*', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KLOGNFAM@?$CFs?5total?5memory?5used?6@
CONST	SEGMENT
??_C@_0BG@KLOGNFAM@?$CFs?5total?5memory?5used?6@ DB '%s total memory used'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMIIEODJ@?$CFi?5total?5textures?6@
CONST	SEGMENT
??_C@_0BD@GMIIEODJ@?$CFi?5total?5textures?6@ DB '%i total textures', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PHAADJIH@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
CONST	SEGMENT
??_C@_0DL@PHAADJIH@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '-'
	DB	'--------------------------------------------------------', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDOEBFOB@?5?5?$CFs?6@
CONST	SEGMENT
??_C@_05LDOEBFOB@?5?5?$CFs?6@ DB '  %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLBGNMAI@?5?5?5?$CFd?5?5@
CONST	SEGMENT
??_C@_07LLBGNMAI@?5?5?5?$CFd?5?5@ DB '   %d  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCDAFEIN@repeat?5@
CONST	SEGMENT
??_C@_07LCDAFEIN@repeat?5@ DB 'repeat ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JBLMFJLG@border?5@
CONST	SEGMENT
??_C@_07JBLMFJLG@border?5@ DB 'border ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OMFDAMIC@clamp?5?5@
CONST	SEGMENT
??_C@_07OMFDAMIC@clamp?5?5@ DB 'clamp  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LAEMIHEI@default?5?5?5@
CONST	SEGMENT
??_C@_0L@LAEMIHEI@default?5?5?5@ DB 'default   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IPBFJKHI@azimuthal?5@
CONST	SEGMENT
??_C@_0L@IPBFJKHI@azimuthal?5@ DB 'azimuthal ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKGMOELN@quartic?5?5?5@
CONST	SEGMENT
??_C@_0L@PKGMOELN@quartic?5?5?5@ DB 'quartic   ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LGBJKLIF@parabolic?5@
CONST	SEGMENT
??_C@_0L@LGBJKLIF@parabolic?5@ DB 'parabolic ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BIINDBLA@stereo?5?5?5?5@
CONST	SEGMENT
??_C@_0L@BIINDBLA@stereo?5?5?5?5@ DB 'stereo    ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNMBILNN@ortho?5?5?5?5?5@
CONST	SEGMENT
??_C@_0L@LNMBILNN@ortho?5?5?5?5?5@ DB 'ortho     ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDEJAPEP@YCoCg?5?5?5?5?5@
CONST	SEGMENT
??_C@_0L@EDEJAPEP@YCoCg?5?5?5?5?5@ DB 'YCoCg     ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HCDGFIFF@diffuse?5@
CONST	SEGMENT
??_C@_08HCDGFIFF@diffuse?5@ DB 'diffuse ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDGKKKPC@normal?5?5@
CONST	SEGMENT
??_C@_08DDGKKKPC@normal?5?5@ DB 'normal  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OPGEOFKA@?$DP?$DP?$DP?$DP?5?5@
CONST	SEGMENT
??_C@_06OPGEOFKA@?$DP?$DP?$DP?$DP?5?5@ DB '????  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGDLGFNO@ARRAY?5@
CONST	SEGMENT
??_C@_06FGDLGFNO@ARRAY?5@ DB 'ARRAY ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPLJJLOO@RECT?5?5@
CONST	SEGMENT
??_C@_06HPLJJLOO@RECT?5?5@ DB 'RECT  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GIADBHEF@CUBE?5?5@
CONST	SEGMENT
??_C@_06GIADBHEF@CUBE?5?5@ DB 'CUBE  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPEIFPOL@?53D?5?5?5@
CONST	SEGMENT
??_C@_06IPEIFPOL@?53D?5?5?5@ DB ' 3D   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EEBEIMEO@?52D?5?5?5@
CONST	SEGMENT
??_C@_06EEBEIMEO@?52D?5?5?5@ DB ' 2D   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MCIAPOOA@?51D?5?5?5@
CONST	SEGMENT
??_C@_06MCIAPOOA@?51D?5?5?5@ DB ' 1D   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFABDMBF@?5?$FO1ERROR?$FO7?5@
CONST	SEGMENT
??_C@_0M@CFABDMBF@?5?$FO1ERROR?$FO7?5@ DB ' ^1ERROR^7 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EICDMLHG@RGBA32F@
CONST	SEGMENT
??_C@_07EICDMLHG@RGBA32F@ DB 'RGBA32F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OFCDKLCB@RGBA16F@
CONST	SEGMENT
??_C@_07OFCDKLCB@RGBA16F@ DB 'RGBA16F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IFOFGHNA@RGB32F@
CONST	SEGMENT
??_C@_06IFOFGHNA@RGB32F@ DB 'RGB32F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CIOFAHIH@RGB16F@
CONST	SEGMENT
??_C@_06CIOFAHIH@RGB16F@ DB 'RGB16F', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJLEMFGH@RG32F?5@
CONST	SEGMENT
??_C@_06JJLEMFGH@RG32F?5@ DB 'RG32F ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMBGABFA@RG16F?5@
CONST	SEGMENT
??_C@_06GMBGABFA@RG16F?5@ DB 'RG16F ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HIAMMBOJ@LA32F?5@
CONST	SEGMENT
??_C@_06HIAMMBOJ@LA32F?5@ DB 'LA32F ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INKOAFNO@LA16F?5@
CONST	SEGMENT
??_C@_06INKOAFNO@LA16F?5@ DB 'LA16F ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLIBMEMK@L32F?5?5@
CONST	SEGMENT
??_C@_06KLIBMEMK@L32F?5?5@ DB 'L32F  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BDMJMDAB@L16F?5?5@
CONST	SEGMENT
??_C@_06BDMJMDAB@L16F?5?5@ DB 'L16F  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGDHGPHN@DPTH32@
CONST	SEGMENT
??_C@_06IGDHGPHN@DPTH32@ DB 'DPTH32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NBKPKCMM@DPTH24@
CONST	SEGMENT
??_C@_06NBKPKCMM@DPTH24@ DB 'DPTH24', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHBDHHJD@I8?5?5?5?5@
CONST	SEGMENT
??_C@_06JHBDHHJD@I8?5?5?5?5@ DB 'I8    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEPMDJPE@A8?5?5?5?5@
CONST	SEGMENT
??_C@_06KEPMDJPE@A8?5?5?5?5@ DB 'A8    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MFCLFIDE@L8?5?5?5?5@
CONST	SEGMENT
??_C@_06MFCLFIDE@L8?5?5?5?5@ DB 'L8    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCOJJIEP@L4?5?5?5?5@
CONST	SEGMENT
??_C@_06LCOJJIEP@L4?5?5?5?5@ DB 'L4    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PENEHJLJ@L8A8?5?5@
CONST	SEGMENT
??_C@_06PENEHJLJ@L8A8?5?5@ DB 'L8A8  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJMAAGHK@L4A4?5?5@
CONST	SEGMENT
??_C@_06MJMAAGHK@L4A4?5?5@ DB 'L4A4  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IMILIDDD@RGB5?5?5@
CONST	SEGMENT
??_C@_06IMILIDDD@RGB5?5?5@ DB 'RGB5  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOOBFLOO@RGB8?5?5@
CONST	SEGMENT
??_C@_06HOOBFLOO@RGB8?5?5@ DB 'RGB8  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLEMCEJO@RGB?5?5?5@
CONST	SEGMENT
??_C@_06OLEMCEJO@RGB?5?5?5@ DB 'RGB   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDPJLPFE@RGBA4?5@
CONST	SEGMENT
??_C@_06HDPJLPFE@RGBA4?5@ DB 'RGBA4 ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKODEGDA@RGBA8?5@
CONST	SEGMENT
??_C@_06HKODEGDA@RGBA8?5@ DB 'RGBA8 ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GINGLEPI@RGBA?5?5@
CONST	SEGMENT
??_C@_06GINGLEPI@RGBA?5?5@ DB 'RGBA  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LFPIHMPN@ATI2?5?5@
CONST	SEGMENT
??_C@_06LFPIHMPN@ATI2?5?5@ DB 'ATI2  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JFKFPIKL@DXT5?5?5@
CONST	SEGMENT
??_C@_06JFKFPIKL@DXT5?5?5@ DB 'DXT5  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAMOKHHH@DXT3?5?5@
CONST	SEGMENT
??_C@_06LAMOKHHH@DXT3?5?5@ DB 'DXT3  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLJPIIAL@DXT1a?5@
CONST	SEGMENT
??_C@_06GLJPIIAL@DXT1a?5@ DB 'DXT1a ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GIBLFMGF@DXT1c?5@
CONST	SEGMENT
??_C@_06GIBLFMGF@DXT1c?5@ DB 'DXT1c ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDBNPGLJ@CI?5?5?5?5@
CONST	SEGMENT
??_C@_06PDBNPGLJ@CI?5?5?5?5@ DB 'CI    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPEOHENE@CA?5?5?5?5@
CONST	SEGMENT
??_C@_06BPEOHENE@CA?5?5?5?5@ DB 'CA    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KDNAGHAK@CL?5?5?5?5@
CONST	SEGMENT
??_C@_06KDNAGHAK@CL?5?5?5?5@ DB 'CL    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HICDJPH@CLA?5?5?5@
CONST	SEGMENT
??_C@_06HICDJPH@CLA?5?5?5@ DB 'CLA   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CADBJADE@CRGB?5?5@
CONST	SEGMENT
??_C@_06CADBJADE@CRGB?5?5@ DB 'CRGB  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJCEDBCD@CRGBA?5@
CONST	SEGMENT
??_C@_06GJCEDBCD@CRGBA?5@ DB 'CRGBA ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMAMJJGO@?$CF12s?5@
CONST	SEGMENT
??_C@_05BMAMJJGO@?$CF12s?5@ DB '%12s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNHPGGLF@?$CF4i?5?$CF4i?5@
CONST	SEGMENT
??_C@_08GNHPGGLF@?$CF4i?5?$CF4i?5@ DB '%4i %4i ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHKLCIPC@?$CF4i?3?5@
CONST	SEGMENT
??_C@_05LHKLCIPC@?$CF4i?3?5@ DB '%4i: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@DHCNGGFA@?5?9id?9?5?5?5?9w?9?5?5?9h?9?5?5?5?5?5?9size?9?5?9fm@
CONST	SEGMENT
??_C@_0FI@DHCNGGFA@?5?9id?9?5?5?5?9w?9?5?5?9h?9?5?5?5?5?5?9size?9?5?9fm@ DB ' '
	DB	'-id-   -w-  -h-     -size- -fmt- -type- -data-  -encode- -wra'
	DB	'p- -depth- -name--------', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POAMJEF@?$CKcintexture@
CONST	SEGMENT
??_C@_0M@POAMJEF@?$CKcintexture@ DB '*cintexture', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FPKCCFDN@?$CKblack@
CONST	SEGMENT
??_C@_06FPKCCFDN@?$CKblack@ DB '*black', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LFMGNIOO@?$CKgray@
CONST	SEGMENT
??_C@_05LFMGNIOO@?$CKgray@ DB '*gray', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LLGHKAEB@?$CKwhite@
CONST	SEGMENT
??_C@_06LLGHKAEB@?$CKwhite@ DB '*white', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHFKAJMC@?$CKparticle@
CONST	SEGMENT
??_C@_09KHFKAJMC@?$CKparticle@ DB '*particle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPIGECMN@?$CKdefault@
CONST	SEGMENT
??_C@_08KPIGECMN@?$CKdefault@ DB '*default', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNOAAFDD@?$CKdlight@
CONST	SEGMENT
??_C@_07MNOAAFDD@?$CKdlight@ DB '*dlight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@IPLDKKAL@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5c@
CONST	SEGMENT
??_C@_0ED@IPLDKKAL@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5c@ DB '^1Error'
	DB	':^7 GL_ProcessTexture: can''t process compressed texture %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NHNGPALK@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5n@
CONST	SEGMENT
??_C@_0DE@NHNGPALK@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5n@ DB '^1Error'
	DB	':^7 GL_ProcessTexture: no input data for %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DAELPBJM@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5b@
CONST	SEGMENT
??_C@_0DE@DAELPBJM@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5b@ DB '^1Error'
	DB	':^7 GL_ProcessTexture: bad operation for %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KMJLBDPK@GL_LoadTextureFromBuffer?3?5could@
CONST	SEGMENT
??_C@_0DP@KMJLBDPK@GL_LoadTextureFromBuffer?3?5could@ DB 'GL_LoadTextureF'
	DB	'romBuffer: couldn''t find texture %s for update', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@GJHFFGAI@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
CONST	SEGMENT
??_C@_0FK@GJHFFGAI@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ DB '^1Error:'
	DB	'^7 GL_LoadTextureArray: not all layers were loaded. Texture a'
	DB	'rray is not created', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@HMAKJHB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
CONST	SEGMENT
??_C@_0ED@HMAKJHB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ DB '^1Error:^'
	DB	'7 GL_LoadTextureArray: mismatch image size for %s and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@EBJDPNMO@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
CONST	SEGMENT
??_C@_0EI@EBJDPNMO@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ DB '^1Error:'
	DB	'^7 GL_LoadTextureArray: mismatch custom encoding for %s and %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@GJAFFJKB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
CONST	SEGMENT
??_C@_0EC@GJAFFJKB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ DB '^1Error:'
	DB	'^7 GL_LoadTextureArray: mismatch mip count for %s and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DOCILBDF@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
CONST	SEGMENT
??_C@_0EF@DOCILBDF@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@ DB '^1Error:'
	DB	'^7 GL_LoadTextureArray: mismatch image format for %s and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJOBHKIC@?$FL?$CFi?$FN@
CONST	SEGMENT
??_C@_04KJOBHKIC@?$FL?$CFi?$FN@ DB '[%i]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM@ DB '|', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_LoadTextureArray@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_LoadTextureArray@@9@9 DD 05c7H	; `GL_LoadTextureArray'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EM@OBIPLNLC@?$FO1Error?3?$FO7?5GL_DeleteTexture?3?5tr@
CONST	SEGMENT
??_C@_0EM@OBIPLNLC@?$FO1Error?3?$FO7?5GL_DeleteTexture?3?5tr@ DB '^1Error'
	DB	':^7 GL_DeleteTexture: trying to free unnamed texture with tex'
	DB	'num %i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_DeleteTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_DeleteTexture@@9@9 DD 0548H		; `GL_DeleteTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CN@DDGFAJIN@GL_AllocTexture?3?5MAX_TEXTURES?5l@
CONST	SEGMENT
??_C@_0CN@DDGFAJIN@GL_AllocTexture?3?5MAX_TEXTURES?5l@ DB 'GL_AllocTextur'
	DB	'e: MAX_TEXTURES limit exceeds', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PJGPEJK@?$FO1Error?3?$FO7?5LoadTexture?3?5too?5lon@
CONST	SEGMENT
??_C@_0CP@PJGPEJK@?$FO1Error?3?$FO7?5LoadTexture?3?5too?5lon@ DB '^1Error'
	DB	':^7 LoadTexture: too long name %s (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HKKDAIOF@GL_UploadTexture?3?5?$CFs?5image?5buff@
CONST	SEGMENT
??_C@_0CM@HKKDAIOF@GL_UploadTexture?3?5?$CFs?5image?5buff@ DB 'GL_UploadT'
	DB	'exture: %s image buffer overflow', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IJOCGAGP@GL_UploadTexture?3?5?$CFs?5s?$CG3?5?$FL?$CFd?5x?5@
CONST	SEGMENT
??_C@_0CE@IJOCGAGP@GL_UploadTexture?3?5?$CFs?5s?$CG3?5?$FL?$CFd?5x?5@ DB 'G'
	DB	'L_UploadTexture: %s s&3 [%d x %d]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@DEBJKEAE@?$FO1Error?3?$FO7?5GL_UploadTexture?3?5?$CFs@
CONST	SEGMENT
??_C@_0ED@DEBJKEAE@?$FO1Error?3?$FO7?5GL_UploadTexture?3?5?$CFs@ DB '^1Er'
	DB	'ror:^7 GL_UploadTexture: %s is not supported by your hardware'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_UploadTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_UploadTexture@@9@9 DD 0437H		; `GL_UploadTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CO@HEGNHHDC@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5while?5uplo@
CONST	SEGMENT
??_C@_0CO@HEGNHHDC@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5while?5uplo@ DB '^3O'
	DB	'penGL Error:^7 %s while uploading %s [%s]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_CheckTexImageError@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_CheckTexImageError@@9@9 DD 0425H	; `GL_CheckTexImageError'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_TextureImageDXT@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_TextureImageDXT@@9@9 DD 0401H	; `GL_TextureImageDXT'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_TextureImageRAW@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_TextureImageRAW@@9@9 DD 03daH	; `GL_TextureImageRAW'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_ResampleTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_ResampleTexture@@9@9 DD 02e3H	; `GL_ResampleTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_SetTextureFormat@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_SetTextureFormat@@9@9 DD 0285H	; `GL_SetTextureFormat'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@PGEAODHA@pic?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@PGEAODHA@pic?5?$CB?$DN?5NULL@ DB 'pic != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_SetTextureTarget@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_SetTextureTarget@@9@9 DD 0251H	; `GL_SetTextureTarget'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_SetTextureDimensions@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_SetTextureDimensions@@9@9 DD 01f8H	; `GL_SetTextureDimensions'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??GL_CalcMipmapCount@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_CalcMipmapCount@@9@9 DD 01d9H	; `GL_CalcMipmapCount'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@JMKCEBIO@GL_CalcTextureSize?3?5bad?5texture@
CONST	SEGMENT
??_C@_0DG@JMKCEBIO@GL_CalcTextureSize?3?5bad?5texture@ DB 'GL_CalcTexture'
	DB	'Size: bad texture internal format (%u)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KLPBGJAB@gl_texture_lodbias@
CONST	SEGMENT
??_C@_0BD@KLPBGJAB@gl_texture_lodbias@ DB 'gl_texture_lodbias', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DGIPFEHA@gl_anisotropy@
CONST	SEGMENT
??_C@_0O@DGIPFEHA@gl_anisotropy@ DB 'gl_anisotropy', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_UpdateTextureParams@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_UpdateTextureParams@@9@9 DD 0f5H	; `GL_UpdateTextureParams'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@ DB 'tex != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_ApplyTextureParams@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_ApplyTextureParams@@9@9 DD 070H	; `GL_ApplyTextureParams'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CF@MPKGELAE@texnum?5?$DO?$DN?50?5?$CG?$CG?5texnum?5?$DM?5MAX_TEX@
CONST	SEGMENT
??_C@_0CF@MPKGELAE@texnum?5?$DO?$DN?50?5?$CG?$CG?5texnum?5?$DM?5MAX_TEX@ DB 't'
	DB	'exnum >= 0 && texnum < MAX_TEXTURES', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GL_Bind@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??GL_Bind@@9@9 DD 047H			; `GL_Bind'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02HHFHKOHM@?$DP?$DP@
CONST	SEGMENT
??_C@_02HHFHKOHM@?$DP?$DP@ DB '??', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGDEFKPD@Rect@
CONST	SEGMENT
??_C@_04HGDEFKPD@Rect@ DB 'Rect', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPPFDPIF@Array@
CONST	SEGMENT
??_C@_05HPPFDPIF@Array@ DB 'Array', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CJLGPKHJ@Cube@
CONST	SEGMENT
??_C@_04CJLGPKHJ@Cube@ DB 'Cube', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LCIGPHCF@3D@
CONST	SEGMENT
??_C@_02LCIGPHCF@3D@ DB '3D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LDEEJNBC@2D@
CONST	SEGMENT
??_C@_02LDEEJNBC@2D@ DB '2D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LBACCDEL@1D@
CONST	SEGMENT
??_C@_02LBACCDEL@1D@ DB '1D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
CONST	SEGMENT
??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@ DB 'assert failed '
	DB	'at %s:%i', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\gl_image.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??R_GetTexture@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??R_GetTexture@@9@9 DD 023H		; `R_GetTexture'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0774H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	081H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0689H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0124H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	08c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	06f4H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CreateInternalTextures
_TEXT	SEGMENT
tv245 = -96						; size = 8
tv156 = -96						; size = 4
tv75 = -96						; size = 4
tv155 = -92						; size = 4
tv76 = -92						; size = 4
_pic$ = -24						; size = 4
_y$ = -20						; size = 4
_x$ = -16						; size = 4
_d$ = -12						; size = 4
_dy$ = -8						; size = 4
_dx2$ = -4						; size = 4
_GL_CreateInternalTextures PROC				; COMDAT

; 1909 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1910 : 	int	dx2, dy, d;
; 1911 : 	int	x, y;
; 1912 : 	rgbdata_t	*pic;
; 1913 : 
; 1914 : 	// emo-texture from quake1
; 1915 : 	pic = GL_FakeImage( 16, 16, 1, IMAGE_HAS_COLOR );

	push	4
	push	1
	push	16					; 00000010H
	push	16					; 00000010H
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1916 : 
; 1917 : 	for( y = 0; y < 16; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN4@GL_CreateI
$LN2@GL_CreateI:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN4@GL_CreateI:
	cmp	DWORD PTR _y$[ebp], 16			; 00000010H
	jge	$LN3@GL_CreateI

; 1918 : 	{
; 1919 : 		for( x = 0; x < 16; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN7@GL_CreateI
$LN5@GL_CreateI:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN7@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 16			; 00000010H
	jge	SHORT $LN6@GL_CreateI

; 1920 : 		{
; 1921 : 			if(( y < 8 ) ^ ( x < 8 ))

	cmp	DWORD PTR _y$[ebp], 8
	jge	SHORT $LN28@GL_CreateI
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN29@GL_CreateI
$LN28@GL_CreateI:
	mov	DWORD PTR tv76[ebp], 0
$LN29@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 8
	jge	SHORT $LN26@GL_CreateI
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN27@GL_CreateI
$LN26@GL_CreateI:
	mov	DWORD PTR tv75[ebp], 0
$LN27@GL_CreateI:
	mov	eax, DWORD PTR tv76[ebp]
	xor	eax, DWORD PTR tv75[ebp]
	je	SHORT $LN23@GL_CreateI

; 1922 : 				((uint *)pic->buffer)[y*16+x] = 0xFFFF00FF;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+eax*4], -65281		; ffff00ffH
	jmp	SHORT $LN24@GL_CreateI
$LN23@GL_CreateI:

; 1923 : 			else ((uint *)pic->buffer)[y*16+x] = 0xFF000000;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+eax*4], -16777216	; ff000000H
$LN24@GL_CreateI:

; 1924 : 		}

	jmp	SHORT $LN5@GL_CreateI
$LN6@GL_CreateI:

; 1925 : 	}

	jmp	$LN2@GL_CreateI
$LN3@GL_CreateI:

; 1926 : 
; 1927 : 	tr.defaultTexture = GL_LoadTextureInternal( "*default", pic, TF_COLORMAP );

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_08KPIGECMN@?$CKdefault@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr, eax

; 1928 : 
; 1929 : 	// particle texture from quake1
; 1930 : 	pic = GL_FakeImage( 16, 16, 1, IMAGE_HAS_COLOR|IMAGE_HAS_ALPHA );

	push	6
	push	1
	push	16					; 00000010H
	push	16					; 00000010H
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1931 : 
; 1932 : 	for( x = 0; x < 16; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN10@GL_CreateI
$LN8@GL_CreateI:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN10@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 16			; 00000010H
	jge	$LN9@GL_CreateI

; 1933 : 	{
; 1934 : 		dx2 = x - 8;

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 8
	mov	DWORD PTR _dx2$[ebp], eax

; 1935 : 		dx2 = dx2 * dx2;

	mov	eax, DWORD PTR _dx2$[ebp]
	imul	eax, DWORD PTR _dx2$[ebp]
	mov	DWORD PTR _dx2$[ebp], eax

; 1936 : 
; 1937 : 		for( y = 0; y < 16; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN13@GL_CreateI
$LN11@GL_CreateI:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN13@GL_CreateI:
	cmp	DWORD PTR _y$[ebp], 16			; 00000010H
	jge	$LN12@GL_CreateI

; 1938 : 		{
; 1939 : 			dy = y - 8;

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, 8
	mov	DWORD PTR _dy$[ebp], eax

; 1940 : 			d = 255 - 35 * sqrt( dx2 + dy * dy );

	mov	eax, DWORD PTR _dy$[ebp]
	imul	eax, DWORD PTR _dy$[ebp]
	add	eax, DWORD PTR _dx2$[ebp]
	cvtsi2sd xmm0, eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR tv245[ebp]
	movsd	xmm0, QWORD PTR tv245[ebp]
	mulsd	xmm0, QWORD PTR __real@4041800000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	subsd	xmm1, xmm0
	cvttsd2si ecx, xmm1
	mov	DWORD PTR _d$[ebp], ecx

; 1941 : 			pic->buffer[( y * 16 + x ) * 4 + 3] = bound( 0, d, 255 );

	cmp	DWORD PTR _d$[ebp], 0
	jl	SHORT $LN32@GL_CreateI
	cmp	DWORD PTR _d$[ebp], 255			; 000000ffH
	jge	SHORT $LN30@GL_CreateI
	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $LN31@GL_CreateI
$LN30@GL_CreateI:
	mov	DWORD PTR tv155[ebp], 255		; 000000ffH
$LN31@GL_CreateI:
	mov	ecx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], ecx
	jmp	SHORT $LN33@GL_CreateI
$LN32@GL_CreateI:
	mov	DWORD PTR tv156[ebp], 0
$LN33@GL_CreateI:
	mov	edx, DWORD PTR _y$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	al, BYTE PTR tv156[ebp]
	mov	BYTE PTR [ecx+edx*4+3], al

; 1942 : 		}

	jmp	$LN11@GL_CreateI
$LN12@GL_CreateI:

; 1943 : 	}

	jmp	$LN8@GL_CreateI
$LN9@GL_CreateI:

; 1944 : 
; 1945 : 	tr.particleTexture = GL_LoadTextureInternal( "*particle", pic, TF_CLAMP );

	push	0
	push	2048					; 00000800H
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_09KHFKAJMC@?$CKparticle@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+4, eax

; 1946 : 
; 1947 : 	// white texture
; 1948 : 	pic = GL_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );

	push	4
	push	1
	push	4
	push	4
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1949 : 	for( x = 0; x < 16; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN16@GL_CreateI
$LN14@GL_CreateI:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN16@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 16			; 00000010H
	jge	SHORT $LN15@GL_CreateI

; 1950 : 		((uint *)pic->buffer)[x] = 0xFFFFFFFF;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+edx*4], -1
	jmp	SHORT $LN14@GL_CreateI
$LN15@GL_CreateI:

; 1951 : 	tr.whiteTexture = GL_LoadTextureInternal( "*white", pic, TF_COLORMAP );

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_06LLGHKAEB@?$CKwhite@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+8, eax

; 1952 : 
; 1953 : 	// gray texture
; 1954 : 	pic = GL_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );

	push	4
	push	1
	push	4
	push	4
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1955 : 	for( x = 0; x < 16; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN19@GL_CreateI
$LN17@GL_CreateI:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN19@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 16			; 00000010H
	jge	SHORT $LN18@GL_CreateI

; 1956 : 		((uint *)pic->buffer)[x] = 0xFF7F7F7F;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+edx*4], -8421505		; ff7f7f7fH
	jmp	SHORT $LN17@GL_CreateI
$LN18@GL_CreateI:

; 1957 : 	tr.grayTexture = GL_LoadTextureInternal( "*gray", pic, TF_COLORMAP );

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_05LFMGNIOO@?$CKgray@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+12, eax

; 1958 : 
; 1959 : 	// black texture
; 1960 : 	pic = GL_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );

	push	4
	push	1
	push	4
	push	4
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1961 : 	for( x = 0; x < 16; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN22@GL_CreateI
$LN20@GL_CreateI:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN22@GL_CreateI:
	cmp	DWORD PTR _x$[ebp], 16			; 00000010H
	jge	SHORT $LN21@GL_CreateI

; 1962 : 		((uint *)pic->buffer)[x] = 0xFF000000;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+edx*4], -16777216	; ff000000H
	jmp	SHORT $LN20@GL_CreateI
$LN21@GL_CreateI:

; 1963 : 	tr.blackTexture = GL_LoadTextureInternal( "*black", pic, TF_COLORMAP );

	push	0
	push	0
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_06FPKCCFDN@?$CKblack@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+16, eax

; 1964 : 
; 1965 : 	// cinematic dummy
; 1966 : 	pic = GL_FakeImage( 640, 100, 1, IMAGE_HAS_COLOR );

	push	4
	push	1
	push	100					; 00000064H
	push	640					; 00000280H
	call	_GL_FakeImage
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pic$[ebp], eax

; 1967 : 	tr.cinTexture = GL_LoadTextureInternal( "*cintexture", pic, TF_NOMIPMAP|TF_CLAMP );

	push	0
	push	6144					; 00001800H
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@POAMJEF@?$CKcintexture@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+1080, eax

; 1968 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateInternalTextures ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_FakeImage
_TEXT	SEGMENT
tv80 = -68						; size = 4
tv71 = -68						; size = 4
tv68 = -68						; size = 4
tv65 = -68						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_flags$ = 20						; size = 4
_GL_FakeImage PROC					; COMDAT

; 1858 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1859 : 	static byte	data2D[1024]; // 16x16x4
; 1860 : 	static rgbdata_t	r_image;
; 1861 : 
; 1862 : 	// also use this for bad textures, but without alpha
; 1863 : 	r_image.width = Q_max( 1, width );

	cmp	DWORD PTR _width$[ebp], 1
	jge	SHORT $LN4@GL_FakeIma
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN5@GL_FakeIma
$LN4@GL_FakeIma:
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv65[ebp], eax
$LN5@GL_FakeIma:
	mov	cx, WORD PTR tv65[ebp]
	mov	WORD PTR ?r_image@?1??GL_FakeImage@@9@9, cx

; 1864 : 	r_image.height = Q_max( 1, height );

	cmp	DWORD PTR _height$[ebp], 1
	jge	SHORT $LN6@GL_FakeIma
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN7@GL_FakeIma
$LN6@GL_FakeIma:
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv68[ebp], eax
$LN7@GL_FakeIma:
	mov	cx, WORD PTR tv68[ebp]
	mov	WORD PTR ?r_image@?1??GL_FakeImage@@9@9+2, cx

; 1865 : 	r_image.depth = Q_max( 1, depth );

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN8@GL_FakeIma
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN9@GL_FakeIma
$LN8@GL_FakeIma:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv71[ebp], eax
$LN9@GL_FakeIma:
	mov	cx, WORD PTR tv71[ebp]
	mov	WORD PTR ?r_image@?1??GL_FakeImage@@9@9+4, cx

; 1866 : 	r_image.flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+12, eax

; 1867 : 	r_image.type = PF_RGBA_32;

	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+8, 3

; 1868 : 	r_image.size = r_image.width * r_image.height * r_image.depth * 4;

	movzx	eax, WORD PTR ?r_image@?1??GL_FakeImage@@9@9
	movzx	ecx, WORD PTR ?r_image@?1??GL_FakeImage@@9@9+2
	imul	eax, ecx
	movzx	edx, WORD PTR ?r_image@?1??GL_FakeImage@@9@9+4
	imul	eax, edx
	shl	eax, 2
	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+32, eax

; 1869 : 	r_image.buffer = (r_image.size > sizeof( data2D )) ? NULL : data2D;

	cmp	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+32, 1024 ; 00000400H
	jbe	SHORT $LN10@GL_FakeIma
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN11@GL_FakeIma
$LN10@GL_FakeIma:
	mov	DWORD PTR tv80[ebp], OFFSET ?data2D@?1??GL_FakeImage@@9@9
$LN11@GL_FakeIma:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+24, eax

; 1870 : 	r_image.palette = NULL;

	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+20, 0

; 1871 : 	r_image.numMips = 1;

	mov	BYTE PTR ?r_image@?1??GL_FakeImage@@9@9+18, 1

; 1872 : 	r_image.encode = 0;

	xor	eax, eax
	mov	WORD PTR ?r_image@?1??GL_FakeImage@@9@9+16, ax

; 1873 : 
; 1874 : 	if( FBitSet( r_image.flags, IMAGE_CUBEMAP ))

	mov	eax, DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+12
	and	eax, 1
	je	SHORT $LN2@GL_FakeIma

; 1875 : 		r_image.size *= 6;

	imul	eax, DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+32, 6
	mov	DWORD PTR ?r_image@?1??GL_FakeImage@@9@9+32, eax
$LN2@GL_FakeIma:

; 1876 : 	memset( data2D, 0xFF, sizeof( data2D ));

	push	1024					; 00000400H
	push	255					; 000000ffH
	push	OFFSET ?data2D@?1??GL_FakeImage@@9@9
	call	_memset
	add	esp, 12					; 0000000cH

; 1877 : 
; 1878 : 	return &r_image;

	mov	eax, OFFSET ?r_image@?1??GL_FakeImage@@9@9

; 1879 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FakeImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_DeleteTexture
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_prev$ = -4						; size = 4
_tex$ = 8						; size = 4
_GL_DeleteTexture PROC					; COMDAT

; 1352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1353 : 	gl_texture_t	**prev;
; 1354 : 	gl_texture_t	*cur;
; 1355 : 
; 1356 : 	ASSERT( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	jne	SHORT $LN4@GL_DeleteT
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_DeleteTexture@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN4@GL_DeleteT:

; 1357 : 
; 1358 : 	// already freed?
; 1359 : 	if( !tex->texnum ) return;

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+272], 0
	jne	SHORT $LN5@GL_DeleteT
	jmp	$LN1@GL_DeleteT
$LN5@GL_DeleteT:

; 1360 : 
; 1361 : 	// debug
; 1362 : 	if( !tex->name[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN6@GL_DeleteT

; 1363 : 	{
; 1364 : 		Con_Printf( S_ERROR "GL_DeleteTexture: trying to free unnamed texture with texnum %i\n", tex->texnum );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	push	OFFSET ??_C@_0EM@OBIPLNLC@?$FO1Error?3?$FO7?5GL_DeleteTexture?3?5tr@
	call	_Con_Printf
	add	esp, 8

; 1365 : 		return;

	jmp	$LN1@GL_DeleteT
$LN6@GL_DeleteT:

; 1366 : 	}
; 1367 : 
; 1368 : 	// remove from hash table
; 1369 : 	prev = &gl_texturesHashTable[tex->hashValue];

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	lea	edx, DWORD PTR _gl_texturesHashTable[ecx*4]
	mov	DWORD PTR _prev$[ebp], edx
$LN2@GL_DeleteT:

; 1370 : 
; 1371 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@GL_DeleteT

; 1372 : 	{
; 1373 : 		cur = *prev;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cur$[ebp], ecx

; 1374 : 		if( !cur ) break;

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@GL_DeleteT
	jmp	SHORT $LN3@GL_DeleteT
$LN7@GL_DeleteT:

; 1375 : 
; 1376 : 		if( cur == tex )

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR _tex$[ebp]
	jne	SHORT $LN8@GL_DeleteT

; 1377 : 		{
; 1378 : 			*prev = cur->nextHash;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+316]
	mov	DWORD PTR [eax], edx

; 1379 : 			break;

	jmp	SHORT $LN3@GL_DeleteT
$LN8@GL_DeleteT:

; 1380 : 		}
; 1381 : 		prev = &cur->nextHash;

	mov	eax, DWORD PTR _cur$[ebp]
	add	eax, 316				; 0000013cH
	mov	DWORD PTR _prev$[ebp], eax

; 1382 : 	}

	jmp	SHORT $LN2@GL_DeleteT
$LN3@GL_DeleteT:

; 1383 : 
; 1384 : 	// release source
; 1385 : 	if( tex->original )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $LN9@GL_DeleteT

; 1386 : 		FS_FreeImage( tex->original );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	_FS_FreeImage
	add	esp, 4
$LN9@GL_DeleteT:

; 1387 : 
; 1388 : 	pglDeleteTextures( 1, &tex->texnum );

	mov	eax, DWORD PTR _tex$[ebp]
	add	eax, 272				; 00000110H
	push	eax
	push	1
	call	DWORD PTR _pglDeleteTextures

; 1389 : 	memset( tex, 0, sizeof( *tex ));

	push	320					; 00000140H
	push	0
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@GL_DeleteT:

; 1390 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_DeleteTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_AllocTexture
_TEXT	SEGMENT
_i$ = -8						; size = 4
_tex$ = -4						; size = 4
_name$ = 8						; size = 4
_flags$ = 12						; size = 4
_GL_AllocTexture PROC					; COMDAT

; 1314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1315 : 	gl_texture_t	*tex;
; 1316 : 	uint		i;
; 1317 : 
; 1318 : 	// find a free texture_t slot
; 1319 : 	for( i = 0, tex = gl_textures; i < gl_numTextures; i++, tex++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _tex$[ebp], OFFSET _gl_textures
	jmp	SHORT $LN4@GL_AllocTe
$LN2@GL_AllocTe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _tex$[ebp]
	add	ecx, 320				; 00000140H
	mov	DWORD PTR _tex$[ebp], ecx
$LN4@GL_AllocTe:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gl_numTextures
	jae	SHORT $LN3@GL_AllocTe

; 1320 : 		if( !tex->name[0] ) break;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tex$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@GL_AllocTe
	jmp	SHORT $LN3@GL_AllocTe
$LN5@GL_AllocTe:
	jmp	SHORT $LN2@GL_AllocTe
$LN3@GL_AllocTe:

; 1321 : 
; 1322 : 	if( i == gl_numTextures )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gl_numTextures
	jne	SHORT $LN6@GL_AllocTe

; 1323 : 	{
; 1324 : 		if( gl_numTextures == MAX_TEXTURES )

	cmp	DWORD PTR _gl_numTextures, 4096		; 00001000H
	jne	SHORT $LN7@GL_AllocTe

; 1325 : 			Host_Error( "GL_AllocTexture: MAX_TEXTURES limit exceeds\n" );

	push	OFFSET ??_C@_0CN@DDGFAJIN@GL_AllocTexture?3?5MAX_TEXTURES?5l@
	call	_Host_Error
	add	esp, 4
$LN7@GL_AllocTe:

; 1326 : 		gl_numTextures++;

	mov	eax, DWORD PTR _gl_numTextures
	add	eax, 1
	mov	DWORD PTR _gl_numTextures, eax
$LN6@GL_AllocTe:

; 1327 : 	}
; 1328 : 
; 1329 : 	tex = &gl_textures[i];

	imul	eax, DWORD PTR _i$[ebp], 320
	add	eax, OFFSET _gl_textures
	mov	DWORD PTR _tex$[ebp], eax

; 1330 : 
; 1331 : 	// copy initial params
; 1332 : 	Q_strncpy( tex->name, name, sizeof( tex->name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1333 : 	if( FBitSet( flags, TF_SKYSIDE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN8@GL_AllocTe

; 1334 : 		tex->texnum = tr.skyboxbasenum++;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR _tr+1220
	mov	DWORD PTR [eax+272], ecx
	mov	edx, DWORD PTR _tr+1220
	add	edx, 1
	mov	DWORD PTR _tr+1220, edx
	jmp	SHORT $LN9@GL_AllocTe
$LN8@GL_AllocTe:

; 1335 : 	else tex->texnum = i; // texnum is used for fast acess into gl_textures array too

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+272], ecx
$LN9@GL_AllocTe:

; 1336 : 	tex->flags = flags;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+284], ecx

; 1337 : 
; 1338 : 	// add to hash table
; 1339 : 	tex->hashValue = COM_HashKey( name, TEXTURES_HASH_SIZE );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_HashKey
	add	esp, 8
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 1340 : 	tex->nextHash = gl_texturesHashTable[tex->hashValue];

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR _gl_texturesHashTable[ecx*4]
	mov	DWORD PTR [edx+316], eax

; 1341 : 	gl_texturesHashTable[tex->hashValue] = tex;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+312]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR _gl_texturesHashTable[ecx*4], edx

; 1342 : 
; 1343 : 	return tex;

	mov	eax, DWORD PTR _tex$[ebp]

; 1344 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_AllocTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_TextureForName
_TEXT	SEGMENT
_hash$ = -8						; size = 4
_tex$ = -4						; size = 4
_name$ = 8						; size = 4
_GL_TextureForName PROC					; COMDAT

; 1292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1293 : 	gl_texture_t	*tex;
; 1294 : 	uint		hash;
; 1295 : 
; 1296 : 	// find the texture in array
; 1297 : 	hash = COM_HashKey( name, TEXTURES_HASH_SIZE );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_HashKey
	add	esp, 8
	mov	DWORD PTR _hash$[ebp], eax

; 1298 : 
; 1299 : 	for( tex = gl_texturesHashTable[hash]; tex != NULL; tex = tex->nextHash )

	mov	eax, DWORD PTR _hash$[ebp]
	mov	ecx, DWORD PTR _gl_texturesHashTable[eax*4]
	mov	DWORD PTR _tex$[ebp], ecx
	jmp	SHORT $LN4@GL_Texture
$LN2@GL_Texture:
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+316]
	mov	DWORD PTR _tex$[ebp], ecx
$LN4@GL_Texture:
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN3@GL_Texture

; 1300 : 	{
; 1301 : 		if( !Q_stricmp( tex->name, name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@GL_Texture

; 1302 : 			return tex;

	mov	eax, DWORD PTR _tex$[ebp]
	jmp	SHORT $LN1@GL_Texture
$LN5@GL_Texture:

; 1303 : 	}

	jmp	SHORT $LN2@GL_Texture
$LN3@GL_Texture:

; 1304 : 
; 1305 : 	return NULL;

	xor	eax, eax
$LN1@GL_Texture:

; 1306 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureForName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CheckTexName
_TEXT	SEGMENT
_name$ = 8						; size = 4
_GL_CheckTexName PROC					; COMDAT

; 1272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1273 : 	if( !COM_CheckString( name ) || !glw_state.initialized )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@GL_CheckTe
	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN2@GL_CheckTe
$LN3@GL_CheckTe:

; 1274 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@GL_CheckTe
$LN2@GL_CheckTe:

; 1275 : 
; 1276 : 	// because multi-layered textures can exceed name string
; 1277 : 	if( Q_strlen( name ) >= sizeof( gl_textures->name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jb	SHORT $LN4@GL_CheckTe

; 1278 : 	{
; 1279 : 		Con_Printf( S_ERROR "LoadTexture: too long name %s (%d)\n", name, Q_strlen( name ));

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CP@PJGPEJK@?$FO1Error?3?$FO7?5LoadTexture?3?5too?5lon@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1280 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@GL_CheckTe
$LN4@GL_CheckTe:

; 1281 : 	}
; 1282 : 
; 1283 : 	return true;

	mov	eax, 1
$LN1@GL_CheckTe:

; 1284 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckTexName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_ProcessImage
_TEXT	SEGMENT
_img_flags$ = -4					; size = 4
_tex$ = 8						; size = 4
_pic$ = 12						; size = 4
_GL_ProcessImage PROC					; COMDAT

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1213 : 	uint	img_flags = 0; 

	mov	DWORD PTR _img_flags$[ebp], 0

; 1214 : 
; 1215 : 	// force upload texture as RGB or RGBA (detail textures requires this)
; 1216 : 	if( tex->flags & TF_FORCE_COLOR ) pic->flags |= IMAGE_HAS_COLOR;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN2@GL_Process
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 4
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN2@GL_Process:

; 1217 : 	if( pic->flags & IMAGE_HAS_ALPHA ) tex->flags |= TF_HAS_ALPHA;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN3@GL_Process
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN3@GL_Process:

; 1218 : 
; 1219 : 	tex->encode = pic->encode; // share encode method

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+280], ecx

; 1220 : 
; 1221 : 	if( ImageDXT( pic->type ))

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 7
	je	SHORT $LN6@GL_Process
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 8
	je	SHORT $LN6@GL_Process
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 9
	je	SHORT $LN6@GL_Process
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 10			; 0000000aH
	jne	SHORT $LN4@GL_Process
$LN6@GL_Process:

; 1222 : 	{
; 1223 : 		if( !pic->numMips )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	test	ecx, ecx
	jne	SHORT $LN7@GL_Process

; 1224 : 			tex->flags |= TF_NOMIPMAP; // disable mipmapping by user request

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 4096				; 00001000H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN7@GL_Process:

; 1225 : 
; 1226 : 		// clear all the unsupported flags
; 1227 : 		tex->flags &= ~TF_KEEP_SOURCE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx

; 1228 : 	}

	jmp	$LN16@GL_Process
$LN4@GL_Process:

; 1229 : 	else
; 1230 : 	{
; 1231 : 		// copy flag about luma pixels
; 1232 : 		if( pic->flags & IMAGE_HAS_LUMA )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 16					; 00000010H
	je	SHORT $LN8@GL_Process

; 1233 : 			tex->flags |= TF_HAS_LUMA;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN8@GL_Process:

; 1234 : 
; 1235 : 		if( pic->flags & IMAGE_QUAKEPAL )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN9@GL_Process

; 1236 : 			tex->flags |= TF_QUAKEPAL;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN9@GL_Process:

; 1237 : 
; 1238 : 		// create luma texture from quake texture
; 1239 : 		if( tex->flags & TF_MAKELUMA )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 16384				; 00004000H
	je	SHORT $LN10@GL_Process

; 1240 : 		{
; 1241 : 			img_flags |= IMAGE_MAKE_LUMA;

	mov	eax, DWORD PTR _img_flags$[ebp]
	or	eax, 16777216				; 01000000H
	mov	DWORD PTR _img_flags$[ebp], eax

; 1242 : 			tex->flags &= ~TF_MAKELUMA;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, -16385				; ffffbfffH
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN10@GL_Process:

; 1243 : 		}
; 1244 : 
; 1245 : 		if( tex->flags & TF_ALLOW_EMBOSS )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 16					; 00000010H
	je	SHORT $LN11@GL_Process

; 1246 : 		{
; 1247 : 			img_flags |= IMAGE_EMBOSS;

	mov	eax, DWORD PTR _img_flags$[ebp]
	or	eax, 524288				; 00080000H
	mov	DWORD PTR _img_flags$[ebp], eax

; 1248 : 			tex->flags &= ~TF_ALLOW_EMBOSS;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN11@GL_Process:

; 1249 : 		}
; 1250 : 
; 1251 : 		if( !FBitSet( tex->flags, TF_IMG_UPLOADED ) && FBitSet( tex->flags, TF_KEEP_SOURCE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 33554432				; 02000000H
	jne	SHORT $LN12@GL_Process
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 2
	je	SHORT $LN12@GL_Process

; 1252 : 			tex->original = FS_CopyImage( pic ); // because current pic will be expanded to rgba

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_CopyImage
	add	esp, 4
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [ecx+292], eax
$LN12@GL_Process:

; 1253 : 
; 1254 : 		// we need to expand image into RGBA buffer
; 1255 : 		if( pic->type == PF_INDEXED_24 || pic->type == PF_INDEXED_32 )

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 1
	je	SHORT $LN14@GL_Process
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN13@GL_Process
$LN14@GL_Process:

; 1256 : 			img_flags |= IMAGE_FORCE_RGBA;

	mov	eax, DWORD PTR _img_flags$[ebp]
	or	eax, 8388608				; 00800000H
	mov	DWORD PTR _img_flags$[ebp], eax
$LN13@GL_Process:

; 1257 : 
; 1258 : 		// processing image before uploading (force to rgba, make luma etc)
; 1259 : 		if( pic->buffer ) Image_Process( &pic, 0, 0, img_flags, gl_emboss_scale->value );

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN15@GL_Process
	mov	eax, DWORD PTR _gl_emboss_scale
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _img_flags$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _pic$[ebp]
	push	edx
	call	_Image_Process
	add	esp, 20					; 00000014H
$LN15@GL_Process:

; 1260 : 
; 1261 : 		if( FBitSet( tex->flags, TF_LUMINANCE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 512				; 00000200H
	je	SHORT $LN16@GL_Process

; 1262 : 			ClearBits( pic->flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN16@GL_Process:

; 1263 : 	}
; 1264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ProcessImage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_UploadTexture
_TEXT	SEGMENT
tv430 = -120						; size = 4
tv422 = -120						; size = 4
tv360 = -120						; size = 4
tv321 = -120						; size = 4
tv313 = -120						; size = 4
tv304 = -120						; size = 4
tv296 = -120						; size = 4
tv255 = -120						; size = 4
tv247 = -120						; size = 4
tv238 = -120						; size = 4
tv209 = -120						; size = 4
tv205 = -120						; size = 4
tv78 = -120						; size = 4
tv70 = -120						; size = 4
_mipCount$1 = -52					; size = 4
_bufend$ = -48						; size = 4
_normalMap$ = -44					; size = 4
_offset$ = -40						; size = 4
_numSides$ = -36					; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_height$ = -24						; size = 4
_width$ = -20						; size = 4
_size$ = -16						; size = 4
_texsize$ = -12						; size = 4
_data$ = -8						; size = 4
_buf$ = -4						; size = 4
_tex$ = 8						; size = 4
_pic$ = 12						; size = 4
_GL_UploadTexture PROC					; COMDAT

; 1079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi

; 1080 : 	byte		*buf, *data;
; 1081 : 	size_t		texsize, size;
; 1082 : 	uint		width, height;
; 1083 : 	uint		i, j, numSides;
; 1084 : 	uint		offset = 0;

	mov	DWORD PTR _offset$[ebp], 0

; 1085 : 	qboolean		normalMap;
; 1086 : 	const byte	*bufend;
; 1087 : 
; 1088 : 	Assert( pic != NULL );

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN30@GL_UploadT
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN31@GL_UploadT
$LN30@GL_UploadT:
	mov	DWORD PTR tv70[ebp], 0
$LN31@GL_UploadT:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_UploadTexture@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@PGEAODHA@pic?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1089 : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN32@GL_UploadT
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN33@GL_UploadT
$LN32@GL_UploadT:
	mov	DWORD PTR tv78[ebp], 0
$LN33@GL_UploadT:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_UploadTexture@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1090 : 
; 1091 : 	GL_SetTextureTarget( tex, pic ); // must be first

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_SetTextureTarget
	add	esp, 8

; 1092 : 
; 1093 : 	// make sure what target is correct
; 1094 : 	if( tex->target == GL_NONE )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 0
	jne	SHORT $LN14@GL_UploadT

; 1095 : 	{
; 1096 : 		Con_DPrintf( S_ERROR "GL_UploadTexture: %s is not supported by your hardware\n", tex->name );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@DEBJKEAE@?$FO1Error?3?$FO7?5GL_UploadTexture?3?5?$CFs@
	call	_Con_DPrintf
	add	esp, 8

; 1097 : 		return false;

	xor	eax, eax
	jmp	$LN1@GL_UploadT
$LN14@GL_UploadT:

; 1098 : 	}
; 1099 : 
; 1100 : 	GL_SetTextureDimensions( tex, pic->width, pic->height, pic->depth );

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_SetTextureDimensions
	add	esp, 16					; 00000010H

; 1101 : 	GL_SetTextureFormat( tex, pic->type, pic->flags );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_SetTextureFormat
	add	esp, 12					; 0000000cH

; 1102 : 
; 1103 : 	tex->fogParams[0] = pic->fogParams[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _tex$[ebp]
	mov	esi, DWORD PTR _pic$[ebp]
	mov	cl, BYTE PTR [esi+ecx+28]
	mov	BYTE PTR [edx+eax+288], cl

; 1104 : 	tex->fogParams[1] = pic->fogParams[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _tex$[ebp]
	mov	esi, DWORD PTR _pic$[ebp]
	mov	al, BYTE PTR [esi+eax+28]
	mov	BYTE PTR [edx+ecx+288], al

; 1105 : 	tex->fogParams[2] = pic->fogParams[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _tex$[ebp]
	mov	esi, DWORD PTR _pic$[ebp]
	mov	al, BYTE PTR [esi+eax+28]
	mov	BYTE PTR [edx+ecx+288], al

; 1106 : 	tex->fogParams[3] = pic->fogParams[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _tex$[ebp]
	mov	esi, DWORD PTR _pic$[ebp]
	mov	cl, BYTE PTR [esi+ecx+28]
	mov	BYTE PTR [edx+eax+288], cl

; 1107 : 
; 1108 : 	if(( pic->width * pic->height ) & 3 )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	and	ecx, 3
	je	SHORT $LN15@GL_UploadT

; 1109 : 	{
; 1110 : 		// will be resampled, just tell me for debug targets
; 1111 : 		Con_Reportf( "GL_UploadTexture: %s s&3 [%d x %d]\n", tex->name, pic->width, pic->height );

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CE@IJOCGAGP@GL_UploadTexture?3?5?$CFs?5s?$CG3?5?$FL?$CFd?5x?5@
	call	_Con_Reportf
	add	esp, 16					; 00000010H
$LN15@GL_UploadT:

; 1112 : 	}
; 1113 : 
; 1114 : 	buf = pic->buffer;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _buf$[ebp], ecx

; 1115 : 	bufend = pic->buffer + pic->size; // total image size include all the layers, cube sides, mipmaps

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _pic$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR _bufend$[ebp], ecx

; 1116 : 	offset = GL_CalcImageSize( pic->type, pic->width, pic->height, pic->depth );

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _offset$[ebp], eax

; 1117 : 	texsize = GL_CalcTextureSize( tex->format, tex->width, tex->height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+262]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [ecx+260]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	_GL_CalcTextureSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texsize$[ebp], eax

; 1118 : 	normalMap = FBitSet( tex->flags, TF_NORMALMAP ) ? true : false;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN34@GL_UploadT
	mov	DWORD PTR tv205[ebp], 1
	jmp	SHORT $LN35@GL_UploadT
$LN34@GL_UploadT:
	mov	DWORD PTR tv205[ebp], 0
$LN35@GL_UploadT:
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR _normalMap$[ebp], edx

; 1119 : 	numSides = FBitSet( pic->flags, IMAGE_CUBEMAP ) ? 6 : 1;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	SHORT $LN36@GL_UploadT
	mov	DWORD PTR tv209[ebp], 6
	jmp	SHORT $LN37@GL_UploadT
$LN36@GL_UploadT:
	mov	DWORD PTR tv209[ebp], 1
$LN37@GL_UploadT:
	mov	edx, DWORD PTR tv209[ebp]
	mov	DWORD PTR _numSides$[ebp], edx

; 1120 : 
; 1121 : 	// uploading texture into video memory, change the binding
; 1122 : 	glState.currentTextures[glState.activeTMU] = tex->texnum;

	mov	eax, DWORD PTR _glState+16
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR _glState[eax*4+20], edx

; 1123 : 	pglBindTexture( tex->target, tex->texnum );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglBindTexture

; 1124 : 
; 1125 : 	for( i = 0; i < numSides; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_UploadT
$LN2@GL_UploadT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_UploadT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numSides$[ebp]
	jae	$LN3@GL_UploadT

; 1126 : 	{
; 1127 : 		// track the buffer bounds
; 1128 : 		if( buf != NULL && buf >= bufend )

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN16@GL_UploadT
	mov	eax, DWORD PTR _buf$[ebp]
	cmp	eax, DWORD PTR _bufend$[ebp]
	jb	SHORT $LN16@GL_UploadT

; 1129 : 			Host_Error( "GL_UploadTexture: %s image buffer overflow\n", tex->name );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@HKKDAIOF@GL_UploadTexture?3?5?$CFs?5image?5buff@
	call	_Host_Error
	add	esp, 8
$LN16@GL_UploadT:

; 1130 : 
; 1131 : 		if( ImageDXT( pic->type ))

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 7
	je	SHORT $LN19@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 8
	je	SHORT $LN19@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 9
	je	SHORT $LN19@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 10			; 0000000aH
	jne	$LN17@GL_UploadT
$LN19@GL_UploadT:

; 1132 : 		{
; 1133 : 			for( j = 0; j < Q_max( 1, pic->numMips ); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@GL_UploadT
$LN5@GL_UploadT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@GL_UploadT:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	cmp	ecx, 1
	jge	SHORT $LN38@GL_UploadT
	mov	DWORD PTR tv238[ebp], 1
	jmp	SHORT $LN39@GL_UploadT
$LN38@GL_UploadT:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	mov	DWORD PTR tv238[ebp], eax
$LN39@GL_UploadT:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR tv238[ebp]
	jae	$LN6@GL_UploadT

; 1134 : 			{
; 1135 : 				width = Q_max( 1, ( tex->width >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN40@GL_UploadT
	mov	DWORD PTR tv247[ebp], 1
	jmp	SHORT $LN41@GL_UploadT
$LN40@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv247[ebp], edx
$LN41@GL_UploadT:
	mov	eax, DWORD PTR tv247[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 1136 : 				height = Q_max( 1, ( tex->height >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN42@GL_UploadT
	mov	DWORD PTR tv255[ebp], 1
	jmp	SHORT $LN43@GL_UploadT
$LN42@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv255[ebp], edx
$LN43@GL_UploadT:
	mov	eax, DWORD PTR tv255[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 1137 : 				texsize = GL_CalcTextureSize( tex->format, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	_GL_CalcTextureSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texsize$[ebp], eax

; 1138 : 				size = GL_CalcImageSize( pic->type, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$[ebp], eax

; 1139 : 				GL_TextureImageDXT( tex, i, j, width, height, tex->depth, size, buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+264]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	push	edx
	call	_GL_TextureImageDXT
	add	esp, 32					; 00000020H

; 1140 : 				tex->size += texsize;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _texsize$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 1141 : 				buf += size; // move pointer

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _buf$[ebp], eax

; 1142 : 				tex->numMips++;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cl, BYTE PTR [eax+266]
	add	cl, 1
	mov	edx, DWORD PTR _tex$[ebp]
	mov	BYTE PTR [edx+266], cl

; 1143 : 
; 1144 : 				GL_CheckTexImageError( tex );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_CheckTexImageError
	add	esp, 4

; 1145 : 			}

	jmp	$LN5@GL_UploadT
$LN6@GL_UploadT:

; 1146 : 		}

	jmp	$LN18@GL_UploadT
$LN17@GL_UploadT:

; 1147 : 		else if( Q_max( 1, pic->numMips ) > 1 )	// not-compressed DDS

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	cmp	ecx, 1
	jge	SHORT $LN44@GL_UploadT
	mov	DWORD PTR tv296[ebp], 1
	jmp	SHORT $LN45@GL_UploadT
$LN44@GL_UploadT:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	mov	DWORD PTR tv296[ebp], eax
$LN45@GL_UploadT:
	cmp	DWORD PTR tv296[ebp], 1
	jle	$LN20@GL_UploadT

; 1148 : 		{
; 1149 : 			for( j = 0; j < Q_max( 1, pic->numMips ); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN10@GL_UploadT
$LN8@GL_UploadT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN10@GL_UploadT:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	cmp	ecx, 1
	jge	SHORT $LN46@GL_UploadT
	mov	DWORD PTR tv304[ebp], 1
	jmp	SHORT $LN47@GL_UploadT
$LN46@GL_UploadT:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	mov	DWORD PTR tv304[ebp], eax
$LN47@GL_UploadT:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR tv304[ebp]
	jae	$LN9@GL_UploadT

; 1150 : 			{
; 1151 : 				width = Q_max( 1, ( tex->width >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN48@GL_UploadT
	mov	DWORD PTR tv313[ebp], 1
	jmp	SHORT $LN49@GL_UploadT
$LN48@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv313[ebp], edx
$LN49@GL_UploadT:
	mov	eax, DWORD PTR tv313[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 1152 : 				height = Q_max( 1, ( tex->height >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN50@GL_UploadT
	mov	DWORD PTR tv321[ebp], 1
	jmp	SHORT $LN51@GL_UploadT
$LN50@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv321[ebp], edx
$LN51@GL_UploadT:
	mov	eax, DWORD PTR tv321[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 1153 : 				texsize = GL_CalcTextureSize( tex->format, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	_GL_CalcTextureSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texsize$[ebp], eax

; 1154 : 				size = GL_CalcImageSize( pic->type, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$[ebp], eax

; 1155 : 				GL_TextureImageRAW( tex, i, j, width, height, tex->depth, pic->type, buf );

	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_TextureImageRAW
	add	esp, 32					; 00000020H

; 1156 : 				tex->size += texsize;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _texsize$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 1157 : 				buf += size; // move pointer

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _buf$[ebp], eax

; 1158 : 				tex->numMips++;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cl, BYTE PTR [eax+266]
	add	cl, 1
	mov	edx, DWORD PTR _tex$[ebp]
	mov	BYTE PTR [edx+266], cl

; 1159 : 
; 1160 : 				GL_CheckTexImageError( tex );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_CheckTexImageError
	add	esp, 4

; 1161 : 
; 1162 : 			}

	jmp	$LN8@GL_UploadT
$LN9@GL_UploadT:

; 1163 : 		}

	jmp	$LN18@GL_UploadT
$LN20@GL_UploadT:

; 1164 : 		else // RGBA32
; 1165 : 		{
; 1166 : 			int mipCount = GL_CalcMipmapCount( tex, ( buf != NULL ));

	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN52@GL_UploadT
	mov	DWORD PTR tv360[ebp], 1
	jmp	SHORT $LN53@GL_UploadT
$LN52@GL_UploadT:
	mov	DWORD PTR tv360[ebp], 0
$LN53@GL_UploadT:
	mov	eax, DWORD PTR tv360[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_CalcMipmapCount
	add	esp, 8
	mov	DWORD PTR _mipCount$1[ebp], eax

; 1167 : 
; 1168 : 			// NOTE: only single uncompressed textures can be resamples, no mips, no layers, no sides
; 1169 : 			if(( tex->depth == 1 ) && ( pic->width != tex->width ) || ( pic->height != tex->height ))

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	cmp	ecx, 1
	jne	SHORT $LN25@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+260]
	cmp	ecx, eax
	jne	SHORT $LN24@GL_UploadT
$LN25@GL_UploadT:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+262]
	cmp	ecx, eax
	je	SHORT $LN22@GL_UploadT
$LN24@GL_UploadT:

; 1170 : 				data = GL_ResampleTexture( buf, pic->width, pic->height, tex->width, tex->height, normalMap );

	mov	eax, DWORD PTR _normalMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [ecx+262]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+260]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_GL_ResampleTexture
	add	esp, 24					; 00000018H
	mov	DWORD PTR _data$[ebp], eax
	jmp	SHORT $LN23@GL_UploadT
$LN22@GL_UploadT:

; 1171 : 			else data = buf;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _data$[ebp], eax
$LN23@GL_UploadT:

; 1172 : 
; 1173 : 			if( !ImageDXT( pic->type ) && !FBitSet( tex->flags, TF_NOMIPMAP ) && FBitSet( pic->flags, IMAGE_ONEBIT_ALPHA ))

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 7
	je	SHORT $LN26@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 8
	je	SHORT $LN26@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 9
	je	SHORT $LN26@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 10			; 0000000aH
	je	SHORT $LN26@GL_UploadT
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN26@GL_UploadT
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 512				; 00000200H
	je	SHORT $LN26@GL_UploadT

; 1174 : 				data = GL_ApplyFilter( data, tex->width, tex->height );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+260]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_GL_ApplyFilter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _data$[ebp], eax
$LN26@GL_UploadT:

; 1175 : 
; 1176 : 			// mips will be auto-generated if desired
; 1177 : 			for( j = 0; j < mipCount; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@GL_UploadT
$LN11@GL_UploadT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@GL_UploadT:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _mipCount$1[ebp]
	jae	$LN12@GL_UploadT

; 1178 : 			{
; 1179 : 				width = Q_max( 1, ( tex->width >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN54@GL_UploadT
	mov	DWORD PTR tv422[ebp], 1
	jmp	SHORT $LN55@GL_UploadT
$LN54@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv422[ebp], edx
$LN55@GL_UploadT:
	mov	eax, DWORD PTR tv422[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 1180 : 				height = Q_max( 1, ( tex->height >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN56@GL_UploadT
	mov	DWORD PTR tv430[ebp], 1
	jmp	SHORT $LN57@GL_UploadT
$LN56@GL_UploadT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv430[ebp], edx
$LN57@GL_UploadT:
	mov	eax, DWORD PTR tv430[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 1181 : 				texsize = GL_CalcTextureSize( tex->format, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	_GL_CalcTextureSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texsize$[ebp], eax

; 1182 : 				size = GL_CalcImageSize( pic->type, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$[ebp], eax

; 1183 : 				GL_TextureImageRAW( tex, i, j, width, height, tex->depth, pic->type, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_TextureImageRAW
	add	esp, 32					; 00000020H

; 1184 : 				if( mipCount > 1 )

	cmp	DWORD PTR _mipCount$1[ebp], 1
	jle	SHORT $LN27@GL_UploadT

; 1185 : 					GL_BuildMipMap( data, width, height, tex->depth, tex->flags );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, WORD PTR [edx+264]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	_GL_BuildMipMap
	add	esp, 20					; 00000014H
$LN27@GL_UploadT:

; 1186 : 				tex->size += texsize;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _texsize$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 1187 : 				tex->numMips++;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cl, BYTE PTR [eax+266]
	add	cl, 1
	mov	edx, DWORD PTR _tex$[ebp]
	mov	BYTE PTR [edx+266], cl

; 1188 : 
; 1189 : 				GL_CheckTexImageError( tex );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_CheckTexImageError
	add	esp, 4

; 1190 : 			}

	jmp	$LN11@GL_UploadT
$LN12@GL_UploadT:

; 1191 : 
; 1192 : 			// move to next side
; 1193 : 			if( numSides > 1 && ( buf != NULL ))

	cmp	DWORD PTR _numSides$[ebp], 1
	jbe	SHORT $LN18@GL_UploadT
	cmp	DWORD PTR _buf$[ebp], 0
	je	SHORT $LN18@GL_UploadT

; 1194 : 				buf += GL_CalcImageSize( pic->type, pic->width, pic->height, 1 );

	push	1
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _buf$[ebp], eax
$LN18@GL_UploadT:

; 1195 : 		}
; 1196 : 	}

	jmp	$LN2@GL_UploadT
$LN3@GL_UploadT:

; 1197 : 
; 1198 : 	SetBits( tex->flags, TF_IMG_UPLOADED ); // done

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 33554432				; 02000000H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx

; 1199 : 	tex->numMips /= numSides;

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	eax, BYTE PTR [eax+266]
	xor	edx, edx
	div	DWORD PTR _numSides$[ebp]
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	BYTE PTR [ecx+266], al

; 1200 : 
; 1201 : 	return true;

	mov	eax, 1
$LN1@GL_UploadT:

; 1202 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UploadTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CheckTexImageError
_TEXT	SEGMENT
tv75 = -72						; size = 4
tv70 = -72						; size = 4
_err$ = -4						; size = 4
_tex$ = 8						; size = 4
_GL_CheckTexImageError PROC				; COMDAT

; 1061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1062 : 	int	err;
; 1063 : 
; 1064 : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN4@GL_CheckTe
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@GL_CheckTe
$LN4@GL_CheckTe:
	mov	DWORD PTR tv70[ebp], 0
$LN5@GL_CheckTe:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_CheckTexImageError@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1065 : 
; 1066 : 	// catch possible errors
; 1067 : 	if( CVAR_TO_BOOL( gl_check_errors ) && ( err = pglGetError()) != GL_NO_ERROR )

	cmp	DWORD PTR _gl_check_errors, 0
	je	SHORT $LN6@GL_CheckTe
	mov	eax, DWORD PTR _gl_check_errors
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@GL_CheckTe
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN7@GL_CheckTe
$LN6@GL_CheckTe:
	mov	DWORD PTR tv75[ebp], 0
$LN7@GL_CheckTe:
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN2@GL_CheckTe
	call	DWORD PTR _pglGetError
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN2@GL_CheckTe

; 1068 : 		Con_Printf( S_OPENGL_ERROR "%s while uploading %s [%s]\n", GL_ErrorString( err ), tex->name, GL_TargetToString( tex->target ));

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	_GL_TargetToString
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _tex$[ebp]
	push	edx
	mov	eax, DWORD PTR _err$[ebp]
	push	eax
	call	_GL_ErrorString
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0CO@HEGNHHDC@?$FO3OpenGL?5Error?3?$FO7?5?$CFs?5while?5uplo@
	call	_Con_Printf
	add	esp, 16					; 00000010H
$LN2@GL_CheckTe:

; 1069 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CheckTexImageError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_TextureImageDXT
_TEXT	SEGMENT
tv72 = -76						; size = 4
_subImage$ = -8						; size = 4
_cubeTarget$ = -4					; size = 4
_tex$ = 8						; size = 4
_side$ = 12						; size = 4
_level$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_depth$ = 28						; size = 4
_size$ = 32						; size = 4
_data$ = 36						; size = 4
_GL_TextureImageDXT PROC				; COMDAT

; 1025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1026 : 	GLuint	cubeTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB;

	mov	DWORD PTR _cubeTarget$[ebp], 34069	; 00008515H

; 1027 : 	qboolean	subImage = FBitSet( tex->flags, TF_IMG_UPLOADED );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 33554432				; 02000000H
	mov	DWORD PTR _subImage$[ebp], ecx

; 1028 : 
; 1029 : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN18@GL_Texture
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN19@GL_Texture
$LN18@GL_Texture:
	mov	DWORD PTR tv72[ebp], 0
$LN19@GL_Texture:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_TextureImageDXT@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1030 : 
; 1031 : 	if( tex->target == GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	jne	SHORT $LN2@GL_Texture

; 1032 : 	{
; 1033 : 		if( subImage ) pglCompressedTexSubImage1DARB( tex->target, level, 0, width, tex->format, size, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN4@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglCompressedTexSubImage1DARB
	jmp	SHORT $LN5@GL_Texture
$LN4@GL_Texture:

; 1034 : 		else pglCompressedTexImage1DARB( tex->target, level, tex->format, width, 0, size, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglCompressedTexImage1DARB
$LN5@GL_Texture:

; 1035 : 	}

	jmp	$LN1@GL_Texture
$LN2@GL_Texture:

; 1036 : 	else if( tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN6@GL_Texture

; 1037 : 	{
; 1038 : 		if( subImage ) pglCompressedTexSubImage2DARB( cubeTarget + side, level, 0, 0, width, height, tex->format, size, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN8@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cubeTarget$[ebp]
	add	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	DWORD PTR _pglCompressedTexSubImage2DARB
	jmp	SHORT $LN9@GL_Texture
$LN8@GL_Texture:

; 1039 : 		else pglCompressedTexImage2DARB( cubeTarget + side, level, tex->format, width, height, 0, size, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cubeTarget$[ebp]
	add	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	DWORD PTR _pglCompressedTexImage2DARB
$LN9@GL_Texture:

; 1040 : 	}

	jmp	$LN1@GL_Texture
$LN6@GL_Texture:

; 1041 : 	else if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_2D_ARRAY_EXT )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN12@GL_Texture
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 35866		; 00008c1aH
	jne	SHORT $LN10@GL_Texture
$LN12@GL_Texture:

; 1042 : 	{
; 1043 : 		if( subImage ) pglCompressedTexSubImage3DARB( tex->target, level, 0, 0, 0, width, height, depth, tex->format, size, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN13@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglCompressedTexSubImage3DARB
	jmp	SHORT $LN14@GL_Texture
$LN13@GL_Texture:

; 1044 : 		else pglCompressedTexImage3DARB( tex->target, level, tex->format, width, height, depth, 0, size, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglCompressedTexImage3DARB
$LN14@GL_Texture:

; 1045 : 	}

	jmp	SHORT $LN1@GL_Texture
$LN10@GL_Texture:

; 1046 : 	else // 2D or RECT
; 1047 : 	{
; 1048 : 		if( subImage ) pglCompressedTexSubImage2DARB( tex->target, level, 0, 0, width, height, tex->format, size, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN15@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglCompressedTexSubImage2DARB
	jmp	SHORT $LN1@GL_Texture
$LN15@GL_Texture:

; 1049 : 		else pglCompressedTexImage2DARB( tex->target, level, tex->format, width, height, 0, size, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglCompressedTexImage2DARB
$LN1@GL_Texture:

; 1050 : 	}
; 1051 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureImageDXT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_TextureImageRAW
_TEXT	SEGMENT
tv75 = -84						; size = 4
_dataType$ = -16					; size = 4
_inFormat$ = -12					; size = 4
_subImage$ = -8						; size = 4
_cubeTarget$ = -4					; size = 4
_tex$ = 8						; size = 4
_side$ = 12						; size = 4
_level$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_depth$ = 28						; size = 4
_type$ = 32						; size = 4
_data$ = 36						; size = 4
_GL_TextureImageRAW PROC				; COMDAT

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 987  : 	GLuint	cubeTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB;

	mov	DWORD PTR _cubeTarget$[ebp], 34069	; 00008515H

; 988  : 	qboolean	subImage = FBitSet( tex->flags, TF_IMG_UPLOADED );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 33554432				; 02000000H
	mov	DWORD PTR _subImage$[ebp], ecx

; 989  : 	GLenum	inFormat = PFDesc[type].glFormat;

	imul	eax, DWORD PTR _type$[ebp], 28
	mov	ecx, DWORD PTR _PFDesc[eax+20]
	mov	DWORD PTR _inFormat$[ebp], ecx

; 990  : 	GLint	dataType = GL_UNSIGNED_BYTE;

	mov	DWORD PTR _dataType$[ebp], 5121		; 00001401H

; 991  : 
; 992  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN22@GL_Texture
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN23@GL_Texture
$LN22@GL_Texture:
	mov	DWORD PTR tv75[ebp], 0
$LN23@GL_Texture:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_TextureImageRAW@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv75[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 993  : 
; 994  : 	if( FBitSet( tex->flags, TF_DEPTHMAP ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN2@GL_Texture

; 995  : 		inFormat = GL_DEPTH_COMPONENT;

	mov	DWORD PTR _inFormat$[ebp], 6402		; 00001902H
$LN2@GL_Texture:

; 996  : 
; 997  : 	if( FBitSet( tex->flags, TF_ARB_16BIT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN3@GL_Texture

; 998  : 		dataType = GL_HALF_FLOAT_ARB;

	mov	DWORD PTR _dataType$[ebp], 5131		; 0000140bH
	jmp	SHORT $LN4@GL_Texture
$LN3@GL_Texture:

; 999  : 	else if( FBitSet( tex->flags, TF_ARB_FLOAT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 67108864				; 04000000H
	je	SHORT $LN4@GL_Texture

; 1000 : 		dataType = GL_FLOAT;

	mov	DWORD PTR _dataType$[ebp], 5126		; 00001406H
$LN4@GL_Texture:

; 1001 : 
; 1002 : 	if( tex->target == GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	jne	SHORT $LN6@GL_Texture

; 1003 : 	{
; 1004 : 		if( subImage ) pglTexSubImage1D( tex->target, level, 0, width, inFormat, dataType, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN8@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglTexSubImage1D
	jmp	SHORT $LN9@GL_Texture
$LN8@GL_Texture:

; 1005 : 		else pglTexImage1D( tex->target, level, tex->format, width, 0, inFormat, dataType, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexImage1D
$LN9@GL_Texture:

; 1006 : 	}

	jmp	$LN1@GL_Texture
$LN6@GL_Texture:

; 1007 : 	else if( tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN10@GL_Texture

; 1008 : 	{
; 1009 : 		if( subImage ) pglTexSubImage2D( cubeTarget + side, level, 0, 0, width, height, inFormat, dataType, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN12@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _cubeTarget$[ebp]
	add	eax, DWORD PTR _side$[ebp]
	push	eax
	call	DWORD PTR _pglTexSubImage2D
	jmp	SHORT $LN13@GL_Texture
$LN12@GL_Texture:

; 1010 : 		else pglTexImage2D( cubeTarget + side, level, tex->format, width, height, 0, inFormat, dataType, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cubeTarget$[ebp]
	add	edx, DWORD PTR _side$[ebp]
	push	edx
	call	DWORD PTR _pglTexImage2D
$LN13@GL_Texture:

; 1011 : 	}

	jmp	$LN1@GL_Texture
$LN10@GL_Texture:

; 1012 : 	else if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_2D_ARRAY_EXT )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN16@GL_Texture
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 35866		; 00008c1aH
	jne	SHORT $LN14@GL_Texture
$LN16@GL_Texture:

; 1013 : 	{
; 1014 : 		if( subImage ) pglTexSubImage3D( tex->target, level, 0, 0, 0, width, height, depth, inFormat, dataType, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN17@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexSubImage3D
	jmp	SHORT $LN18@GL_Texture
$LN17@GL_Texture:

; 1015 : 		else pglTexImage3D( tex->target, level, tex->format, width, height, depth, 0, inFormat, dataType, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexImage3D
$LN18@GL_Texture:

; 1016 : 	}

	jmp	SHORT $LN1@GL_Texture
$LN14@GL_Texture:

; 1017 : 	else // 2D or RECT
; 1018 : 	{
; 1019 : 		if( subImage ) pglTexSubImage2D( tex->target, level, 0, 0, width, height, inFormat, dataType, data );

	cmp	DWORD PTR _subImage$[ebp], 0
	je	SHORT $LN19@GL_Texture
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexSubImage2D
	jmp	SHORT $LN1@GL_Texture
$LN19@GL_Texture:

; 1020 : 		else pglTexImage2D( tex->target, level, tex->format, width, height, 0, inFormat, dataType, data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+276]
	push	eax
	mov	ecx, DWORD PTR _level$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglTexImage2D
$LN1@GL_Texture:

; 1021 : 	}
; 1022 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TextureImageRAW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_BuildMipMap
_TEXT	SEGMENT
tv588 = -128						; size = 4
tv375 = -128						; size = 4
tv130 = -128						; size = 4
tv73 = -128						; size = 4
tv69 = -128						; size = 4
_next$1 = -60						; size = 4
_next$2 = -56						; size = 4
_normal$ = -52						; size = 12
_z$ = -40						; size = 4
_y$ = -36						; size = 4
_x$ = -32						; size = 4
_row$ = -28						; size = 4
_outpadding$ = -24					; size = 4
_mipHeight$ = -20					; size = 4
_mipWidth$ = -16					; size = 4
_instride$ = -12					; size = 4
_out$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_srcWidth$ = 12						; size = 4
_srcHeight$ = 16					; size = 4
_srcDepth$ = 20						; size = 4
_flags$ = 24						; size = 4
_GL_BuildMipMap PROC					; COMDAT

; 902  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 903  : 	byte	*out = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 904  : 	int	instride = ALIGN( srcWidth * 4, 1 );

	mov	eax, DWORD PTR _srcWidth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _instride$[ebp], eax

; 905  : 	int	mipWidth, mipHeight, outpadding;
; 906  : 	int	row, x, y, z;
; 907  : 	vec3_t	normal;
; 908  : 
; 909  : 	if( !in ) return;

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $LN17@GL_BuildMi
	jmp	$LN3@GL_BuildMi
$LN17@GL_BuildMi:

; 910  : 
; 911  : 	mipWidth = Q_max( 1, ( srcWidth >> 1 ));

	mov	eax, DWORD PTR _srcWidth$[ebp]
	sar	eax, 1
	cmp	eax, 1
	jge	SHORT $LN27@GL_BuildMi
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN28@GL_BuildMi
$LN27@GL_BuildMi:
	mov	ecx, DWORD PTR _srcWidth$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv69[ebp], ecx
$LN28@GL_BuildMi:
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _mipWidth$[ebp], edx

; 912  : 	mipHeight = Q_max( 1, ( srcHeight >> 1 ));

	mov	eax, DWORD PTR _srcHeight$[ebp]
	sar	eax, 1
	cmp	eax, 1
	jge	SHORT $LN29@GL_BuildMi
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN30@GL_BuildMi
$LN29@GL_BuildMi:
	mov	ecx, DWORD PTR _srcHeight$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
$LN30@GL_BuildMi:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _mipHeight$[ebp], edx

; 913  : 	outpadding = ALIGN( mipWidth * 4, 1 ) - mipWidth * 4;

	mov	eax, DWORD PTR _mipWidth$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _mipWidth$[ebp]
	shl	ecx, 2
	sub	eax, ecx
	mov	DWORD PTR _outpadding$[ebp], eax

; 914  : 	row = srcWidth << 2;

	mov	eax, DWORD PTR _srcWidth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _row$[ebp], eax

; 915  : 
; 916  : 	if( FBitSet( flags, TF_ALPHACONTRAST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4194304				; 00400000H
	je	SHORT $LN18@GL_BuildMi

; 917  : 	{
; 918  : 		memset( in, mipWidth, mipWidth * mipHeight * 4 );

	mov	eax, DWORD PTR _mipWidth$[ebp]
	imul	eax, DWORD PTR _mipHeight$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _mipWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 919  : 		return;

	jmp	$LN3@GL_BuildMi
$LN18@GL_BuildMi:

; 920  : 	}
; 921  : 
; 922  : 	// move through all layers
; 923  : 	for( z = 0; z < srcDepth; z++ )

	mov	DWORD PTR _z$[ebp], 0
	jmp	SHORT $LN4@GL_BuildMi
$LN2@GL_BuildMi:
	mov	eax, DWORD PTR _z$[ebp]
	add	eax, 1
	mov	DWORD PTR _z$[ebp], eax
$LN4@GL_BuildMi:
	mov	eax, DWORD PTR _z$[ebp]
	cmp	eax, DWORD PTR _srcDepth$[ebp]
	jge	$LN3@GL_BuildMi

; 924  : 	{
; 925  : 		if( FBitSet( flags, TF_NORMALMAP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32768				; 00008000H
	je	$LN19@GL_BuildMi

; 926  : 		{
; 927  : 			for( y = 0; y < mipHeight; y++, in += instride * 2, out += outpadding )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN7@GL_BuildMi
$LN5@GL_BuildMi:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _instride$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _in$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _outpadding$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN7@GL_BuildMi:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _mipHeight$[ebp]
	jge	$LN6@GL_BuildMi

; 928  : 			{
; 929  : 				byte *next = ((( y << 1 ) + 1 ) < srcHeight ) ? ( in + instride ) : in;

	mov	eax, DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	cmp	ecx, DWORD PTR _srcHeight$[ebp]
	jge	SHORT $LN31@GL_BuildMi
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _instride$[ebp]
	mov	DWORD PTR tv130[ebp], edx
	jmp	SHORT $LN32@GL_BuildMi
$LN31@GL_BuildMi:
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR tv130[ebp], eax
$LN32@GL_BuildMi:
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR _next$2[ebp], ecx

; 930  : 				for( x = 0, row = 0; x < mipWidth; x++, row += 8, out += 4 )

	mov	DWORD PTR _x$[ebp], 0
	mov	DWORD PTR _row$[ebp], 0
	jmp	SHORT $LN10@GL_BuildMi
$LN8@GL_BuildMi:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _row$[ebp]
	add	ecx, 8
	mov	DWORD PTR _row$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 4
	mov	DWORD PTR _out$[ebp], edx
$LN10@GL_BuildMi:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _mipWidth$[ebp]
	jge	$LN9@GL_BuildMi

; 931  : 				{
; 932  : 					if((( x << 1 ) + 1 ) < srcWidth )

	mov	eax, DWORD PTR _x$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	cmp	ecx, DWORD PTR _srcWidth$[ebp]
	jge	$LN21@GL_BuildMi

; 933  : 					{
; 934  : 						normal[0] = MAKE_SIGNED( in[row+0] ) + MAKE_SIGNED( in[row+4] )

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _next$2[ebp]
	add	ecx, DWORD PTR _row$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _next$2[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _normal$[ebp+eax], xmm0

; 935  : 						+ MAKE_SIGNED( next[row+0] ) + MAKE_SIGNED( next[row+4] );
; 936  : 						normal[1] = MAKE_SIGNED( in[row+1] ) + MAKE_SIGNED( in[row+5] )

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+5]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _next$2[ebp]
	add	ecx, DWORD PTR _row$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _next$2[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 937  : 						+ MAKE_SIGNED( next[row+1] ) + MAKE_SIGNED( next[row+5] );
; 938  : 						normal[2] = MAKE_SIGNED( in[row+2] ) + MAKE_SIGNED( in[row+6] )

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+6]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _next$2[ebp]
	add	ecx, DWORD PTR _row$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _next$2[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	edx, 4
	shl	edx, 1
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 939  : 						+ MAKE_SIGNED( next[row+2] ) + MAKE_SIGNED( next[row+6] );
; 940  : 					}

	jmp	$LN22@GL_BuildMi
$LN21@GL_BuildMi:

; 941  : 					else
; 942  : 					{
; 943  : 						normal[0] = MAKE_SIGNED( in[row+0] ) + MAKE_SIGNED( next[row+0] );

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _next$2[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 944  : 						normal[1] = MAKE_SIGNED( in[row+1] ) + MAKE_SIGNED( next[row+1] );

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _next$2[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _normal$[ebp+ecx], xmm0

; 945  : 						normal[2] = MAKE_SIGNED( in[row+2] ) + MAKE_SIGNED( next[row+2] );

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2ss xmm0, ecx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _next$2[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _normal$[ebp+ecx], xmm0
$LN22@GL_BuildMi:

; 946  : 					}
; 947  : 
; 948  : 					if( !VectorNormalizeLength( normal ))

	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR tv588[ebp]
	movss	xmm0, DWORD PTR tv588[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@GL_BuildMi

; 949  : 						VectorSet( normal, 0.5f, 0.5f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _normal$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _normal$[ebp+eax], xmm0
$LN23@GL_BuildMi:

; 950  : 
; 951  : 					out[0] = 128 + (byte)(127.0f * normal[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+ecx]
	cvttss2si edx, xmm0
	movzx	eax, dl
	add	eax, 128				; 00000080H
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 952  : 					out[1] = 128 + (byte)(127.0f * normal[1]);

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	cvttss2si ecx, xmm0
	movzx	edx, cl
	add	edx, 128				; 00000080H
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 953  : 					out[2] = 128 + (byte)(127.0f * normal[2]);

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	cvttss2si ecx, xmm0
	movzx	edx, cl
	add	edx, 128				; 00000080H
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 954  : 					out[3] = 255;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 955  : 				}

	jmp	$LN8@GL_BuildMi
$LN9@GL_BuildMi:

; 956  : 			}

	jmp	$LN5@GL_BuildMi
$LN6@GL_BuildMi:

; 957  : 		}

	jmp	$LN12@GL_BuildMi
$LN19@GL_BuildMi:

; 958  : 		else
; 959  : 		{
; 960  : 			for( y = 0; y < mipHeight; y++, in += instride * 2, out += outpadding )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN13@GL_BuildMi
$LN11@GL_BuildMi:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _instride$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _in$[ebp], eax
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, DWORD PTR _outpadding$[ebp]
	mov	DWORD PTR _out$[ebp], ecx
$LN13@GL_BuildMi:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _mipHeight$[ebp]
	jge	$LN12@GL_BuildMi

; 961  : 			{
; 962  : 				byte *next = ((( y << 1 ) + 1 ) < srcHeight ) ? ( in + instride ) : in;

	mov	eax, DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	cmp	ecx, DWORD PTR _srcHeight$[ebp]
	jge	SHORT $LN33@GL_BuildMi
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _instride$[ebp]
	mov	DWORD PTR tv375[ebp], edx
	jmp	SHORT $LN34@GL_BuildMi
$LN33@GL_BuildMi:
	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR tv375[ebp], eax
$LN34@GL_BuildMi:
	mov	ecx, DWORD PTR tv375[ebp]
	mov	DWORD PTR _next$1[ebp], ecx

; 963  : 				for( x = 0, row = 0; x < mipWidth; x++, row += 8, out += 4 )

	mov	DWORD PTR _x$[ebp], 0
	mov	DWORD PTR _row$[ebp], 0
	jmp	SHORT $LN16@GL_BuildMi
$LN14@GL_BuildMi:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _row$[ebp]
	add	ecx, 8
	mov	DWORD PTR _row$[ebp], ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 4
	mov	DWORD PTR _out$[ebp], edx
$LN16@GL_BuildMi:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _mipWidth$[ebp]
	jge	$LN15@GL_BuildMi

; 964  : 				{
; 965  : 					if((( x << 1 ) + 1 ) < srcWidth )

	mov	eax, DWORD PTR _x$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	cmp	ecx, DWORD PTR _srcWidth$[ebp]
	jge	$LN24@GL_BuildMi

; 966  : 					{
; 967  : 						out[0] = (in[row+0] + in[row+4] + next[row+0] + next[row+4]) >> 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	add	ecx, eax
	sar	ecx, 2
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 968  : 						out[1] = (in[row+1] + in[row+5] + next[row+1] + next[row+5]) >> 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+5]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+5]
	add	ecx, eax
	sar	ecx, 2
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 969  : 						out[2] = (in[row+2] + in[row+6] + next[row+2] + next[row+6]) >> 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+6]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+6]
	add	ecx, eax
	sar	ecx, 2
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 970  : 						out[3] = (in[row+3] + in[row+7] + next[row+3] + next[row+7]) >> 2;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+7]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	add	ecx, eax
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+7]
	add	ecx, eax
	sar	ecx, 2
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 971  : 					}

	jmp	$LN25@GL_BuildMi
$LN24@GL_BuildMi:

; 972  : 					else
; 973  : 					{
; 974  : 						out[0] = (in[row+0] + next[row+0]) >> 1;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx]
	add	ecx, eax
	sar	ecx, 1
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 975  : 						out[1] = (in[row+1] + next[row+1]) >> 1;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	add	ecx, eax
	sar	ecx, 1
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 976  : 						out[2] = (in[row+2] + next[row+2]) >> 1;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+2]
	add	ecx, eax
	sar	ecx, 1
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 977  : 						out[3] = (in[row+3] + next[row+3]) >> 1;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, DWORD PTR _row$[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _next$1[ebp]
	add	edx, DWORD PTR _row$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	add	ecx, eax
	sar	ecx, 1
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+eax], cl
$LN25@GL_BuildMi:

; 978  : 					}
; 979  : 				}

	jmp	$LN14@GL_BuildMi
$LN15@GL_BuildMi:

; 980  : 			}

	jmp	$LN11@GL_BuildMi
$LN12@GL_BuildMi:

; 981  : 		}
; 982  : 	}

	jmp	$LN2@GL_BuildMi
$LN3@GL_BuildMi:

; 983  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BuildMipMap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_ApplyFilter
_TEXT	SEGMENT
_i$ = -12						; size = 4
_out$ = -8						; size = 4
_in$ = -4						; size = 4
_source$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_GL_ApplyFilter PROC					; COMDAT

; 877  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 878  : 	byte	*in = (byte *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _in$[ebp], eax

; 879  : 	byte	*out = (byte *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 880  : 	int	i;
; 881  : 
; 882  : 	if( CL_IsQuakeCompatible() || glConfig.max_multisamples > 1 )

	call	_CL_IsQuakeCompatible
	test	eax, eax
	jne	SHORT $LN6@GL_ApplyFi
	cmp	DWORD PTR _glConfig+96, 1
	jle	SHORT $LN5@GL_ApplyFi
$LN6@GL_ApplyFi:

; 883  : 		return in;

	mov	eax, DWORD PTR _in$[ebp]
	jmp	$LN1@GL_ApplyFi
$LN5@GL_ApplyFi:

; 884  : 
; 885  : 	for( i = 0; source && i < width * height; i++, in += 4 )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_ApplyFi
$LN2@GL_ApplyFi:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 4
	mov	DWORD PTR _in$[ebp], ecx
$LN4@GL_ApplyFi:
	cmp	DWORD PTR _source$[ebp], 0
	je	$LN3@GL_ApplyFi
	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@GL_ApplyFi

; 886  : 	{
; 887  : 		if( in[0] == 0 && in[1] == 0 && in[2] == 0 && in[3] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN7@GL_ApplyFi
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@GL_ApplyFi
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@GL_ApplyFi
	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN7@GL_ApplyFi

; 888  : 			GL_BoxFilter3x3( in, source, width, height, i % width, i / width );

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _width$[ebp]
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	_GL_BoxFilter3x3
	add	esp, 24					; 00000018H
$LN7@GL_ApplyFi:

; 889  : 	}

	jmp	$LN2@GL_ApplyFi
$LN3@GL_ApplyFi:

; 890  : 
; 891  : 	return out;

	mov	eax, DWORD PTR _out$[ebp]
$LN1@GL_ApplyFi:

; 892  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ApplyFilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_BoxFilter3x3
_TEXT	SEGMENT
_pixel$ = -44						; size = 4
_v$ = -40						; size = 4
_u$ = -36						; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_acount$ = -24						; size = 4
_count$ = -20						; size = 4
_a$ = -16						; size = 4
_b$ = -12						; size = 4
_g$ = -8						; size = 4
_r$ = -4						; size = 4
_out$ = 8						; size = 4
_in$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
_GL_BoxFilter3x3 PROC					; COMDAT

; 830  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi

; 831  : 	int		r = 0, g = 0, b = 0, a = 0;

	mov	DWORD PTR _r$[ebp], 0
	mov	DWORD PTR _g$[ebp], 0
	mov	DWORD PTR _b$[ebp], 0
	mov	DWORD PTR _a$[ebp], 0

; 832  : 	int		count = 0, acount = 0;

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _acount$[ebp], 0

; 833  : 	int		i, j, u, v;
; 834  : 	const byte	*pixel;
; 835  : 
; 836  : 	for( i = 0; i < 3; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_BoxFilt
$LN2@GL_BoxFilt:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_BoxFilt:
	cmp	DWORD PTR _i$[ebp], 3
	jge	$LN3@GL_BoxFilt

; 837  : 	{
; 838  : 		u = ( i - 1 ) + x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _u$[ebp], edx

; 839  : 
; 840  : 		for( j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@GL_BoxFilt
$LN5@GL_BoxFilt:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@GL_BoxFilt:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$LN6@GL_BoxFilt

; 841  : 		{
; 842  : 			v = ( j - 1 ) + y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _v$[ebp], edx

; 843  : 
; 844  : 			if( u >= 0 && u < w && v >= 0 && v < h )

	cmp	DWORD PTR _u$[ebp], 0
	jl	$LN8@GL_BoxFilt
	mov	eax, DWORD PTR _u$[ebp]
	cmp	eax, DWORD PTR _w$[ebp]
	jge	$LN8@GL_BoxFilt
	cmp	DWORD PTR _v$[ebp], 0
	jl	$LN8@GL_BoxFilt
	mov	eax, DWORD PTR _v$[ebp]
	cmp	eax, DWORD PTR _h$[ebp]
	jge	$LN8@GL_BoxFilt

; 845  : 			{
; 846  : 				pixel = &in[( u + v * w ) * 4];

	mov	eax, DWORD PTR _v$[ebp]
	imul	eax, DWORD PTR _w$[ebp]
	add	eax, DWORD PTR _u$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pixel$[ebp], edx

; 847  : 
; 848  : 				if( pixel[3] != 0 )

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN8@GL_BoxFilt

; 849  : 				{
; 850  : 					r += pixel[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pixel$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _r$[ebp], eax

; 851  : 					g += pixel[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pixel$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _g$[ebp]
	mov	DWORD PTR _g$[ebp], edx

; 852  : 					b += pixel[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pixel$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	add	edx, DWORD PTR _b$[ebp]
	mov	DWORD PTR _b$[ebp], edx

; 853  : 					a += pixel[3];

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pixel$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 854  : 					acount++;

	mov	eax, DWORD PTR _acount$[ebp]
	add	eax, 1
	mov	DWORD PTR _acount$[ebp], eax
$LN8@GL_BoxFilt:

; 855  : 				}
; 856  : 			}
; 857  : 		}

	jmp	$LN5@GL_BoxFilt
$LN6@GL_BoxFilt:

; 858  : 	}

	jmp	$LN2@GL_BoxFilt
$LN3@GL_BoxFilt:

; 859  : 
; 860  : 	if(  acount == 0 )

	cmp	DWORD PTR _acount$[ebp], 0
	jne	SHORT $LN10@GL_BoxFilt

; 861  : 		acount = 1;

	mov	DWORD PTR _acount$[ebp], 1
$LN10@GL_BoxFilt:

; 862  : 
; 863  : 	out[0] = r / acount;

	mov	eax, DWORD PTR _r$[ebp]
	cdq
	idiv	DWORD PTR _acount$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 864  : 	out[1] = g / acount;

	mov	eax, DWORD PTR _g$[ebp]
	cdq
	idiv	DWORD PTR _acount$[ebp]
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 865  : 	out[2] = b / acount;

	mov	eax, DWORD PTR _b$[ebp]
	cdq
	idiv	DWORD PTR _acount$[ebp]
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 866  : //	out[3] = (int)( SimpleSpline( ( a / 12.0f ) / 255.0f ) * 255 );
; 867  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_BoxFilter3x3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_SetTextureFormat
_TEXT	SEGMENT
tv181 = -80						; size = 4
tv175 = -80						; size = 4
tv168 = -80						; size = 4
tv78 = -80						; size = 4
tv72 = -80						; size = 4
_bits$1 = -12						; size = 4
_haveAlpha$ = -8					; size = 4
_haveColor$ = -4					; size = 4
_tex$ = 8						; size = 4
_format$ = 12						; size = 4
_channelMask$ = 16					; size = 4
_GL_SetTextureFormat PROC				; COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 646  : 	qboolean	haveColor = ( channelMask & IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _channelMask$[ebp]
	and	eax, 4
	mov	DWORD PTR _haveColor$[ebp], eax

; 647  : 	qboolean	haveAlpha = ( channelMask & IMAGE_HAS_ALPHA );

	mov	eax, DWORD PTR _channelMask$[ebp]
	and	eax, 2
	mov	DWORD PTR _haveAlpha$[ebp], eax

; 648  : 
; 649  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN57@GL_SetText
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN58@GL_SetText
$LN57@GL_SetText:
	mov	DWORD PTR tv72[ebp], 0
$LN58@GL_SetText:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_SetTextureFormat@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 650  : 
; 651  : 	if( ImageDXT( format ))

	cmp	DWORD PTR _format$[ebp], 7
	je	SHORT $LN12@GL_SetText
	cmp	DWORD PTR _format$[ebp], 8
	je	SHORT $LN12@GL_SetText
	cmp	DWORD PTR _format$[ebp], 9
	je	SHORT $LN12@GL_SetText
	cmp	DWORD PTR _format$[ebp], 10		; 0000000aH
	jne	SHORT $LN10@GL_SetText
$LN12@GL_SetText:

; 652  : 	{
; 653  : 		switch( format )

	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	sub	ecx, 7
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 3
	ja	SHORT $LN2@GL_SetText
	mov	edx, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN59@GL_SetText[edx*4]
$LN13@GL_SetText:

; 654  : 		{
; 655  : 		case PF_DXT1: tex->format = GL_COMPRESSED_RGB_S3TC_DXT1_EXT; break;	// never use DXT1 with 1-bit alpha

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33776		; 000083f0H
	jmp	SHORT $LN2@GL_SetText
$LN14@GL_SetText:

; 656  : 		case PF_DXT3: tex->format = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33778		; 000083f2H
	jmp	SHORT $LN2@GL_SetText
$LN15@GL_SetText:

; 657  : 		case PF_DXT5: tex->format = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33779		; 000083f3H
	jmp	SHORT $LN2@GL_SetText
$LN16@GL_SetText:

; 658  : 		case PF_ATI2: tex->format = GL_COMPRESSED_RED_GREEN_RGTC2_EXT; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 36285		; 00008dbdH
$LN2@GL_SetText:

; 659  : 		}
; 660  : 		return;

	jmp	$LN1@GL_SetText

; 661  : 	}

	jmp	$LN1@GL_SetText
$LN10@GL_SetText:

; 662  : 	else if( FBitSet( tex->flags, TF_DEPTHMAP ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN17@GL_SetText

; 663  : 	{
; 664  : 		if( FBitSet( tex->flags, TF_ARB_16BIT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	je	SHORT $LN19@GL_SetText

; 665  : 			tex->format = GL_DEPTH_COMPONENT16;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33189		; 000081a5H
	jmp	SHORT $LN20@GL_SetText
$LN19@GL_SetText:

; 666  : 		else if( FBitSet( tex->flags, TF_ARB_FLOAT ) && GL_Support( GL_ARB_DEPTH_FLOAT_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 67108864				; 04000000H
	je	SHORT $LN21@GL_SetText
	push	17					; 00000011H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@GL_SetText

; 667  : 			tex->format = GL_DEPTH_COMPONENT32F;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 36012		; 00008cacH
	jmp	SHORT $LN20@GL_SetText
$LN21@GL_SetText:

; 668  : 		else tex->format = GL_DEPTH_COMPONENT24;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33190		; 000081a6H
$LN20@GL_SetText:

; 669  : 	}

	jmp	$LN1@GL_SetText
$LN17@GL_SetText:

; 670  : 	else if( FBitSet( tex->flags, TF_ARB_FLOAT|TF_ARB_16BIT ) && GL_Support( GL_ARB_TEXTURE_FLOAT_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 335544320				; 14000000H
	je	$LN23@GL_SetText
	push	16					; 00000010H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	$LN23@GL_SetText

; 671  : 	{
; 672  : 		if( haveColor && haveAlpha )

	cmp	DWORD PTR _haveColor$[ebp], 0
	je	SHORT $LN25@GL_SetText
	cmp	DWORD PTR _haveAlpha$[ebp], 0
	je	SHORT $LN25@GL_SetText

; 673  : 		{
; 674  : 			if( FBitSet( tex->flags, TF_ARB_16BIT ) || glw_state.desktopBitsPixel == 16 )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	jne	SHORT $LN29@GL_SetText
	cmp	DWORD PTR _glw_state+8, 16		; 00000010H
	jne	SHORT $LN27@GL_SetText
$LN29@GL_SetText:

; 675  : 				tex->format = GL_RGBA16F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34842		; 0000881aH
	jmp	SHORT $LN28@GL_SetText
$LN27@GL_SetText:

; 676  : 			else tex->format = GL_RGBA32F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34836		; 00008814H
$LN28@GL_SetText:

; 677  : 		}

	jmp	$LN26@GL_SetText
$LN25@GL_SetText:

; 678  : 		else if( haveColor )

	cmp	DWORD PTR _haveColor$[ebp], 0
	je	SHORT $LN30@GL_SetText

; 679  : 		{
; 680  : 			if( FBitSet( tex->flags, TF_ARB_16BIT ) || glw_state.desktopBitsPixel == 16 )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	jne	SHORT $LN34@GL_SetText
	cmp	DWORD PTR _glw_state+8, 16		; 00000010H
	jne	SHORT $LN32@GL_SetText
$LN34@GL_SetText:

; 681  : 				tex->format = GL_RGB16F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34843		; 0000881bH
	jmp	SHORT $LN33@GL_SetText
$LN32@GL_SetText:

; 682  : 			else tex->format = GL_RGB32F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34837		; 00008815H
$LN33@GL_SetText:

; 683  : 		}

	jmp	SHORT $LN26@GL_SetText
$LN30@GL_SetText:

; 684  : 		else if( haveAlpha )

	cmp	DWORD PTR _haveAlpha$[ebp], 0
	je	SHORT $LN35@GL_SetText

; 685  : 		{
; 686  : 			if( FBitSet( tex->flags, TF_ARB_16BIT ) || glw_state.desktopBitsPixel == 16 )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	jne	SHORT $LN39@GL_SetText
	cmp	DWORD PTR _glw_state+8, 16		; 00000010H
	jne	SHORT $LN37@GL_SetText
$LN39@GL_SetText:

; 687  : 				tex->format = GL_RG16F;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33327		; 0000822fH
	jmp	SHORT $LN38@GL_SetText
$LN37@GL_SetText:

; 688  : 			else tex->format = GL_RG32F;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 33328		; 00008230H
$LN38@GL_SetText:

; 689  : 		}

	jmp	SHORT $LN26@GL_SetText
$LN35@GL_SetText:

; 690  : 		else
; 691  : 		{
; 692  : 			if( FBitSet( tex->flags, TF_ARB_16BIT ) || glw_state.desktopBitsPixel == 16 )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 268435456				; 10000000H
	jne	SHORT $LN42@GL_SetText
	cmp	DWORD PTR _glw_state+8, 16		; 00000010H
	jne	SHORT $LN40@GL_SetText
$LN42@GL_SetText:

; 693  : 				tex->format = GL_LUMINANCE16F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34846		; 0000881eH
	jmp	SHORT $LN26@GL_SetText
$LN40@GL_SetText:

; 694  : 			else tex->format = GL_LUMINANCE32F_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 34840		; 00008818H
$LN26@GL_SetText:

; 695  : 		}
; 696  : 	}

	jmp	$LN1@GL_SetText
$LN23@GL_SetText:

; 697  : 	else
; 698  : 	{
; 699  : 		// NOTE: not all the types will be compressed
; 700  : 		int	bits = glw_state.desktopBitsPixel;

	mov	eax, DWORD PTR _glw_state+8
	mov	DWORD PTR _bits$1[ebp], eax

; 701  : 
; 702  : 		switch( GL_CalcTextureSamples( channelMask ))

	mov	eax, DWORD PTR _channelMask$[ebp]
	push	eax
	call	_GL_CalcTextureSamples
	add	esp, 4
	mov	DWORD PTR tv168[ebp], eax
	mov	ecx, DWORD PTR tv168[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	cmp	DWORD PTR tv168[ebp], 3
	ja	$LN52@GL_SetText
	mov	edx, DWORD PTR tv168[ebp]
	jmp	DWORD PTR $LN60@GL_SetText[edx*4]
$LN43@GL_SetText:

; 703  : 		{
; 704  : 		case 1: 
; 705  : 			if( FBitSet( tex->flags, TF_ALPHACONTRAST ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4194304				; 00400000H
	je	SHORT $LN44@GL_SetText

; 706  : 				tex->format = GL_INTENSITY8;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32843		; 0000804bH
	jmp	SHORT $LN45@GL_SetText
$LN44@GL_SetText:

; 707  : 			else tex->format = GL_LUMINANCE8;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32832		; 00008040H
$LN45@GL_SetText:

; 708  : 			break;

	jmp	$LN1@GL_SetText
$LN46@GL_SetText:

; 709  : 		case 2: tex->format = GL_LUMINANCE8_ALPHA8; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32837		; 00008045H
	jmp	$LN1@GL_SetText
$LN47@GL_SetText:

; 710  : 		case 3:
; 711  : 			switch( bits )

	mov	eax, DWORD PTR _bits$1[ebp]
	mov	DWORD PTR tv175[ebp], eax
	cmp	DWORD PTR tv175[ebp], 16		; 00000010H
	je	SHORT $LN48@GL_SetText
	cmp	DWORD PTR tv175[ebp], 32		; 00000020H
	je	SHORT $LN49@GL_SetText
	jmp	SHORT $LN50@GL_SetText
$LN48@GL_SetText:

; 712  : 			{
; 713  : 			case 16: tex->format = GL_RGB5; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32848		; 00008050H
	jmp	SHORT $LN6@GL_SetText
$LN49@GL_SetText:

; 714  : 			case 32: tex->format = GL_RGB8; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32849		; 00008051H
	jmp	SHORT $LN6@GL_SetText
$LN50@GL_SetText:

; 715  : 			default: tex->format = GL_RGB; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 6407		; 00001907H
$LN6@GL_SetText:

; 716  : 			}
; 717  : 			break;	

	jmp	SHORT $LN1@GL_SetText
$LN52@GL_SetText:

; 718  : 		case 4:
; 719  : 		default:
; 720  : 			switch( bits )

	mov	eax, DWORD PTR _bits$1[ebp]
	mov	DWORD PTR tv181[ebp], eax
	cmp	DWORD PTR tv181[ebp], 16		; 00000010H
	je	SHORT $LN53@GL_SetText
	cmp	DWORD PTR tv181[ebp], 32		; 00000020H
	je	SHORT $LN54@GL_SetText
	jmp	SHORT $LN55@GL_SetText
$LN53@GL_SetText:

; 721  : 			{
; 722  : 			case 16: tex->format = GL_RGBA4; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32854		; 00008056H
	jmp	SHORT $LN1@GL_SetText
$LN54@GL_SetText:

; 723  : 			case 32: tex->format = GL_RGBA8; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 32856		; 00008058H
	jmp	SHORT $LN1@GL_SetText
$LN55@GL_SetText:

; 724  : 			default: tex->format = GL_RGBA; break;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+276], 6408		; 00001908H
$LN1@GL_SetText:

; 725  : 			}
; 726  : 			break;
; 727  : 		}
; 728  : 	}
; 729  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN59@GL_SetText:
	DD	$LN13@GL_SetText
	DD	$LN14@GL_SetText
	DD	$LN15@GL_SetText
	DD	$LN16@GL_SetText
$LN60@GL_SetText:
	DD	$LN43@GL_SetText
	DD	$LN46@GL_SetText
	DD	$LN47@GL_SetText
	DD	$LN52@GL_SetText
_GL_SetTextureFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_SetTextureTarget
_TEXT	SEGMENT
tv95 = -68						; size = 4
tv86 = -68						; size = 4
tv78 = -68						; size = 4
tv70 = -68						; size = 4
_tex$ = 8						; size = 4
_pic$ = 12						; size = 4
_GL_SetTextureTarget PROC				; COMDAT

; 593  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 594  : 	Assert( pic != NULL );

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN19@GL_SetText
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN20@GL_SetText
$LN19@GL_SetText:
	mov	DWORD PTR tv70[ebp], 0
$LN20@GL_SetText:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_SetTextureTarget@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@PGEAODHA@pic?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 595  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN21@GL_SetText
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN22@GL_SetText
$LN21@GL_SetText:
	mov	DWORD PTR tv78[ebp], 0
$LN22@GL_SetText:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_SetTextureTarget@@9@9
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 596  : 
; 597  : 	// correct depth size
; 598  : 	pic->depth = Q_max( 1, pic->depth );

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	jge	SHORT $LN23@GL_SetText
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN24@GL_SetText
$LN23@GL_SetText:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx+4]
	mov	DWORD PTR tv86[ebp], eax
$LN24@GL_SetText:
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	dx, WORD PTR tv86[ebp]
	mov	WORD PTR [ecx+4], dx

; 599  : 	tex->numMips = 0; // begin counting

	mov	eax, DWORD PTR _tex$[ebp]
	mov	BYTE PTR [eax+266], 0

; 600  : 
; 601  : 	// correct mip count
; 602  : 	pic->numMips = Q_max( 1, pic->numMips );

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	cmp	ecx, 1
	jge	SHORT $LN25@GL_SetText
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN26@GL_SetText
$LN25@GL_SetText:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	mov	DWORD PTR tv95[ebp], eax
$LN26@GL_SetText:
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	dl, BYTE PTR tv95[ebp]
	mov	BYTE PTR [ecx+18], dl

; 603  : 
; 604  : 	// trying to determine texture type
; 605  : 	if( pic->width > 1 && pic->height <= 1 )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 1
	jle	SHORT $LN2@GL_SetText
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	cmp	ecx, 1
	jg	SHORT $LN2@GL_SetText

; 606  : 		tex->target = GL_TEXTURE_1D;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 3552		; 00000de0H
	jmp	$LN3@GL_SetText
$LN2@GL_SetText:

; 607  : 	else if( FBitSet( pic->flags, IMAGE_CUBEMAP ))

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	SHORT $LN4@GL_SetText

; 608  : 		tex->target = GL_TEXTURE_CUBE_MAP_ARB;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 34067		; 00008513H
	jmp	$LN3@GL_SetText
$LN4@GL_SetText:

; 609  : 	else if( FBitSet( pic->flags, IMAGE_MULTILAYER ) && pic->depth >= 1 )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 256				; 00000100H
	je	SHORT $LN6@GL_SetText
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	jl	SHORT $LN6@GL_SetText

; 610  : 		tex->target = GL_TEXTURE_2D_ARRAY_EXT;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 35866		; 00008c1aH
	jmp	SHORT $LN3@GL_SetText
$LN6@GL_SetText:

; 611  : 	else if( pic->width > 1 && pic->height > 1 && pic->depth > 1 )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 1
	jle	SHORT $LN8@GL_SetText
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	cmp	ecx, 1
	jle	SHORT $LN8@GL_SetText
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	ecx, 1
	jle	SHORT $LN8@GL_SetText

; 612  : 		tex->target = GL_TEXTURE_3D;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 32879		; 0000806fH
	jmp	SHORT $LN3@GL_SetText
$LN8@GL_SetText:

; 613  : 	else if( FBitSet( tex->flags, TF_RECTANGLE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 32					; 00000020H
	je	SHORT $LN10@GL_SetText

; 614  : 		tex->target = GL_TEXTURE_RECTANGLE_EXT;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 34037		; 000084f5H
	jmp	SHORT $LN3@GL_SetText
$LN10@GL_SetText:

; 615  : 	else tex->target = GL_TEXTURE_2D; // default case

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 3553		; 00000de1H
$LN3@GL_SetText:

; 616  : 
; 617  : 	// check for hardware support
; 618  : 	if(( tex->target == GL_TEXTURE_CUBE_MAP_ARB ) && !GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN12@GL_SetText
	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@GL_SetText

; 619  : 		tex->target = GL_NONE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 0
$LN12@GL_SetText:

; 620  : 
; 621  : 	if(( tex->target == GL_TEXTURE_RECTANGLE_EXT ) && !GL_Support( GL_TEXTURE_2D_RECT_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34037		; 000084f5H
	jne	SHORT $LN13@GL_SetText
	push	10					; 0000000aH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN13@GL_SetText

; 622  : 		tex->target = GL_TEXTURE_2D;	// fallback

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 3553		; 00000de1H
$LN13@GL_SetText:

; 623  : 
; 624  : 	if(( tex->target == GL_TEXTURE_2D_ARRAY_EXT ) && !GL_Support( GL_TEXTURE_ARRAY_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 35866		; 00008c1aH
	jne	SHORT $LN14@GL_SetText
	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@GL_SetText

; 625  : 		tex->target = GL_NONE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 0
$LN14@GL_SetText:

; 626  : 
; 627  : 	if(( tex->target == GL_TEXTURE_3D ) && !GL_Support( GL_TEXTURE_3D_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	jne	SHORT $LN15@GL_SetText
	push	12					; 0000000cH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@GL_SetText

; 628  : 		tex->target = GL_NONE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 0
$LN15@GL_SetText:

; 629  : 
; 630  : 	// check if depth textures are not supported
; 631  : 	if( FBitSet( tex->flags, TF_DEPTHMAP ) && !GL_Support( GL_DEPTH_TEXTURE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN16@GL_SetText
	push	20					; 00000014H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@GL_SetText

; 632  : 		tex->target = GL_NONE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 0
$LN16@GL_SetText:

; 633  : 
; 634  : 	// depth cubemaps only allowed when GL_EXT_gpu_shader4 is supported
; 635  : 	if( tex->target == GL_TEXTURE_CUBE_MAP_ARB && !GL_Support( GL_EXT_GPU_SHADER4 ) && FBitSet( tex->flags, TF_DEPTHMAP ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN1@GL_SetText
	push	19					; 00000013H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@GL_SetText
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	SHORT $LN1@GL_SetText

; 636  : 		tex->target = GL_NONE;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+268], 0
$LN1@GL_SetText:

; 637  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetTextureTarget ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_SetTextureDimensions
_TEXT	SEGMENT
tv169 = -88						; size = 4
tv165 = -88						; size = 4
tv161 = -88						; size = 4
tv73 = -88						; size = 4
tv70 = -88						; size = 4
_scaled_height$1 = -20					; size = 4
_scaled_width$2 = -16					; size = 4
_step$3 = -12						; size = 4
_maxDepthSize$ = -8					; size = 4
_maxTextureSize$ = -4					; size = 4
_tex$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_GL_SetTextureDimensions PROC				; COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 505  : 	int	maxTextureSize;
; 506  : 	int	maxDepthSize = 1;

	mov	DWORD PTR _maxDepthSize$[ebp], 1

; 507  : 
; 508  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN37@GL_SetText
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN38@GL_SetText
$LN37@GL_SetText:
	mov	DWORD PTR tv70[ebp], 0
$LN38@GL_SetText:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_SetTextureDimensions@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 509  : 
; 510  : 	switch( tex->target )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 34037		; 000084f5H
	ja	SHORT $LN39@GL_SetText
	cmp	DWORD PTR tv73[ebp], 34037		; 000084f5H
	je	SHORT $LN19@GL_SetText
	cmp	DWORD PTR tv73[ebp], 3552		; 00000de0H
	je	SHORT $LN16@GL_SetText
	cmp	DWORD PTR tv73[ebp], 3553		; 00000de1H
	je	SHORT $LN16@GL_SetText
	cmp	DWORD PTR tv73[ebp], 32879		; 0000806fH
	je	SHORT $LN21@GL_SetText
	jmp	SHORT $LN2@GL_SetText
$LN39@GL_SetText:
	cmp	DWORD PTR tv73[ebp], 34067		; 00008513H
	je	SHORT $LN20@GL_SetText
	cmp	DWORD PTR tv73[ebp], 35866		; 00008c1aH
	je	SHORT $LN18@GL_SetText
	jmp	SHORT $LN2@GL_SetText
$LN16@GL_SetText:

; 511  : 	{
; 512  : 	case GL_TEXTURE_1D:
; 513  : 	case GL_TEXTURE_2D:
; 514  : 		maxTextureSize = glConfig.max_2d_texture_size;

	mov	eax, DWORD PTR _glConfig+60
	mov	DWORD PTR _maxTextureSize$[ebp], eax

; 515  : 		break;

	jmp	SHORT $LN2@GL_SetText
$LN18@GL_SetText:

; 516  : 	case GL_TEXTURE_2D_ARRAY_EXT:
; 517  : 		maxDepthSize = glConfig.max_2d_texture_layers;

	mov	eax, DWORD PTR _glConfig+68
	mov	DWORD PTR _maxDepthSize$[ebp], eax

; 518  : 		maxTextureSize = glConfig.max_2d_texture_size;

	mov	eax, DWORD PTR _glConfig+60
	mov	DWORD PTR _maxTextureSize$[ebp], eax

; 519  : 		break;

	jmp	SHORT $LN2@GL_SetText
$LN19@GL_SetText:

; 520  : 	case GL_TEXTURE_RECTANGLE_EXT:
; 521  : 		maxTextureSize = glConfig.max_2d_rectangle_size;

	mov	eax, DWORD PTR _glConfig+64
	mov	DWORD PTR _maxTextureSize$[ebp], eax

; 522  : 		break;

	jmp	SHORT $LN2@GL_SetText
$LN20@GL_SetText:

; 523  : 	case GL_TEXTURE_CUBE_MAP_ARB:
; 524  : 		maxTextureSize = glConfig.max_cubemap_size;

	mov	eax, DWORD PTR _glConfig+76
	mov	DWORD PTR _maxTextureSize$[ebp], eax

; 525  : 		break;

	jmp	SHORT $LN2@GL_SetText
$LN21@GL_SetText:

; 526  : 	case GL_TEXTURE_3D:
; 527  : 		maxDepthSize = glConfig.max_3d_texture_size;

	mov	eax, DWORD PTR _glConfig+72
	mov	DWORD PTR _maxDepthSize$[ebp], eax

; 528  : 		maxTextureSize = glConfig.max_3d_texture_size;

	mov	eax, DWORD PTR _glConfig+72
	mov	DWORD PTR _maxTextureSize$[ebp], eax
$LN2@GL_SetText:

; 529  : 		break;
; 530  : 	}
; 531  : 
; 532  : 	// store original sizes
; 533  : 	tex->srcWidth = width;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _width$[ebp]
	mov	WORD PTR [eax+256], cx

; 534  : 	tex->srcHeight = height;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _height$[ebp]
	mov	WORD PTR [eax+258], cx

; 535  : 
; 536  : 	if( !GL_Support( GL_ARB_TEXTURE_NPOT_EXT ))

	push	14					; 0000000eH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	$LN22@GL_SetText

; 537  : 	{
; 538  : 		int	step = (int)gl_round_down->value;

	mov	eax, DWORD PTR _gl_round_down
	cvttss2si ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _step$3[ebp], ecx

; 539  : 		int	scaled_width, scaled_height;
; 540  : 
; 541  : 		for( scaled_width = 1; scaled_width < width; scaled_width <<= 1 );

	mov	DWORD PTR _scaled_width$2[ebp], 1
	jmp	SHORT $LN6@GL_SetText
$LN4@GL_SetText:
	mov	eax, DWORD PTR _scaled_width$2[ebp]
	shl	eax, 1
	mov	DWORD PTR _scaled_width$2[ebp], eax
$LN6@GL_SetText:
	mov	eax, DWORD PTR _scaled_width$2[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jge	SHORT $LN5@GL_SetText
	jmp	SHORT $LN4@GL_SetText
$LN5@GL_SetText:

; 542  : 
; 543  : 		if( step > 0 && width < scaled_width && ( step == 1 || ( scaled_width - width ) > ( scaled_width >> step )))

	cmp	DWORD PTR _step$3[ebp], 0
	jle	SHORT $LN23@GL_SetText
	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _scaled_width$2[ebp]
	jge	SHORT $LN23@GL_SetText
	cmp	DWORD PTR _step$3[ebp], 1
	je	SHORT $LN24@GL_SetText
	mov	eax, DWORD PTR _scaled_width$2[ebp]
	sub	eax, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _scaled_width$2[ebp]
	mov	ecx, DWORD PTR _step$3[ebp]
	sar	edx, cl
	cmp	eax, edx
	jle	SHORT $LN23@GL_SetText
$LN24@GL_SetText:

; 544  : 			scaled_width >>= 1;

	mov	eax, DWORD PTR _scaled_width$2[ebp]
	sar	eax, 1
	mov	DWORD PTR _scaled_width$2[ebp], eax
$LN23@GL_SetText:

; 545  : 
; 546  : 		for( scaled_height = 1; scaled_height < height; scaled_height <<= 1 );

	mov	DWORD PTR _scaled_height$1[ebp], 1
	jmp	SHORT $LN9@GL_SetText
$LN7@GL_SetText:
	mov	eax, DWORD PTR _scaled_height$1[ebp]
	shl	eax, 1
	mov	DWORD PTR _scaled_height$1[ebp], eax
$LN9@GL_SetText:
	mov	eax, DWORD PTR _scaled_height$1[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	SHORT $LN8@GL_SetText
	jmp	SHORT $LN7@GL_SetText
$LN8@GL_SetText:

; 547  : 
; 548  : 		if( step > 0 && height < scaled_height && ( step == 1 || ( scaled_height - height ) > ( scaled_height >> step )))

	cmp	DWORD PTR _step$3[ebp], 0
	jle	SHORT $LN25@GL_SetText
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _scaled_height$1[ebp]
	jge	SHORT $LN25@GL_SetText
	cmp	DWORD PTR _step$3[ebp], 1
	je	SHORT $LN26@GL_SetText
	mov	eax, DWORD PTR _scaled_height$1[ebp]
	sub	eax, DWORD PTR _height$[ebp]
	mov	edx, DWORD PTR _scaled_height$1[ebp]
	mov	ecx, DWORD PTR _step$3[ebp]
	sar	edx, cl
	cmp	eax, edx
	jle	SHORT $LN25@GL_SetText
$LN26@GL_SetText:

; 549  : 			scaled_height >>= 1;

	mov	eax, DWORD PTR _scaled_height$1[ebp]
	sar	eax, 1
	mov	DWORD PTR _scaled_height$1[ebp], eax
$LN25@GL_SetText:

; 550  : 
; 551  : 		width = scaled_width;

	mov	eax, DWORD PTR _scaled_width$2[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 552  : 		height = scaled_height;

	mov	eax, DWORD PTR _scaled_height$1[ebp]
	mov	DWORD PTR _height$[ebp], eax
$LN22@GL_SetText:

; 553  : 	}
; 554  : 
; 555  : 	if( width > maxTextureSize || height > maxTextureSize || depth > maxDepthSize )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jg	SHORT $LN28@GL_SetText
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jg	SHORT $LN28@GL_SetText
	mov	eax, DWORD PTR _depth$[ebp]
	cmp	eax, DWORD PTR _maxDepthSize$[ebp]
	jle	$LN15@GL_SetText
$LN28@GL_SetText:

; 556  : 	{
; 557  : 		if( tex->target == GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	jne	SHORT $LN29@GL_SetText
$LN10@GL_SetText:

; 558  : 		{
; 559  : 			while( width > maxTextureSize )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jle	SHORT $LN11@GL_SetText

; 560  : 				width >>= 1;

	mov	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _width$[ebp], eax
	jmp	SHORT $LN10@GL_SetText
$LN11@GL_SetText:

; 561  : 		}

	jmp	SHORT $LN15@GL_SetText
$LN29@GL_SetText:

; 562  : 		else if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_2D_ARRAY_EXT )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN33@GL_SetText
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 35866		; 00008c1aH
	jne	SHORT $LN31@GL_SetText
$LN33@GL_SetText:

; 563  : 		{
; 564  : 			while( width > maxTextureSize || height > maxTextureSize || depth > maxDepthSize )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jg	SHORT $LN34@GL_SetText
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jg	SHORT $LN34@GL_SetText
	mov	eax, DWORD PTR _depth$[ebp]
	cmp	eax, DWORD PTR _maxDepthSize$[ebp]
	jle	SHORT $LN13@GL_SetText
$LN34@GL_SetText:

; 565  : 			{
; 566  : 				width >>= 1;

	mov	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _width$[ebp], eax

; 567  : 				height >>= 1;

	mov	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	mov	DWORD PTR _height$[ebp], eax

; 568  : 				depth >>= 1;

	mov	eax, DWORD PTR _depth$[ebp]
	sar	eax, 1
	mov	DWORD PTR _depth$[ebp], eax

; 569  : 			}

	jmp	SHORT $LN33@GL_SetText
$LN13@GL_SetText:

; 570  : 		}

	jmp	SHORT $LN15@GL_SetText
$LN31@GL_SetText:

; 571  : 		else // all remaining cases
; 572  : 		{
; 573  : 			while( width > maxTextureSize || height > maxTextureSize )

	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jg	SHORT $LN35@GL_SetText
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _maxTextureSize$[ebp]
	jle	SHORT $LN15@GL_SetText
$LN35@GL_SetText:

; 574  : 			{
; 575  : 				width >>= 1;

	mov	eax, DWORD PTR _width$[ebp]
	sar	eax, 1
	mov	DWORD PTR _width$[ebp], eax

; 576  : 				height >>= 1;

	mov	eax, DWORD PTR _height$[ebp]
	sar	eax, 1
	mov	DWORD PTR _height$[ebp], eax

; 577  : 			}

	jmp	SHORT $LN31@GL_SetText
$LN15@GL_SetText:

; 578  : 		}
; 579  : 	}
; 580  : 
; 581  : 	// set the texture dimensions
; 582  : 	tex->width = Q_max( 1, width );

	cmp	DWORD PTR _width$[ebp], 1
	jge	SHORT $LN40@GL_SetText
	mov	DWORD PTR tv161[ebp], 1
	jmp	SHORT $LN41@GL_SetText
$LN40@GL_SetText:
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv161[ebp], eax
$LN41@GL_SetText:
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	dx, WORD PTR tv161[ebp]
	mov	WORD PTR [ecx+260], dx

; 583  : 	tex->height = Q_max( 1, height );

	cmp	DWORD PTR _height$[ebp], 1
	jge	SHORT $LN42@GL_SetText
	mov	DWORD PTR tv165[ebp], 1
	jmp	SHORT $LN43@GL_SetText
$LN42@GL_SetText:
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv165[ebp], eax
$LN43@GL_SetText:
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	dx, WORD PTR tv165[ebp]
	mov	WORD PTR [ecx+262], dx

; 584  : 	tex->depth = Q_max( 1, depth );

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN44@GL_SetText
	mov	DWORD PTR tv169[ebp], 1
	jmp	SHORT $LN45@GL_SetText
$LN44@GL_SetText:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv169[ebp], eax
$LN45@GL_SetText:
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	dx, WORD PTR tv169[ebp]
	mov	WORD PTR [ecx+264], dx

; 585  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_SetTextureDimensions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CalcMipmapCount
_TEXT	SEGMENT
tv95 = -80						; size = 4
tv87 = -80						; size = 4
tv70 = -80						; size = 4
_mipcount$ = -12					; size = 4
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_tex$ = 8						; size = 4
_haveBuffer$ = 12					; size = 4
_GL_CalcMipmapCount PROC				; COMDAT

; 473  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 474  : 	int	width, height;
; 475  : 	int	mipcount;
; 476  : 
; 477  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN10@GL_CalcMip
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN11@GL_CalcMip
$LN10@GL_CalcMip:
	mov	DWORD PTR tv70[ebp], 0
$LN11@GL_CalcMip:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_CalcMipmapCount@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 478  : 
; 479  : 	if( !haveBuffer || tex->target == GL_TEXTURE_3D )

	cmp	DWORD PTR _haveBuffer$[ebp], 0
	je	SHORT $LN6@GL_CalcMip
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	jne	SHORT $LN5@GL_CalcMip
$LN6@GL_CalcMip:

; 480  : 		return 1;

	mov	eax, 1
	jmp	$LN1@GL_CalcMip
$LN5@GL_CalcMip:

; 481  : 
; 482  : 	// generate mip-levels by user request
; 483  : 	if( FBitSet( tex->flags, TF_NOMIPMAP ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN7@GL_CalcMip

; 484  : 		return 1;

	mov	eax, 1
	jmp	$LN1@GL_CalcMip
$LN7@GL_CalcMip:

; 485  : 		
; 486  : 	// mip-maps can't exceeds 16
; 487  : 	for( mipcount = 0; mipcount < 16; mipcount++ )

	mov	DWORD PTR _mipcount$[ebp], 0
	jmp	SHORT $LN4@GL_CalcMip
$LN2@GL_CalcMip:
	mov	eax, DWORD PTR _mipcount$[ebp]
	add	eax, 1
	mov	DWORD PTR _mipcount$[ebp], eax
$LN4@GL_CalcMip:
	cmp	DWORD PTR _mipcount$[ebp], 16		; 00000010H
	jge	SHORT $LN3@GL_CalcMip

; 488  : 	{
; 489  : 		width = Q_max( 1, ( tex->width >> mipcount ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _mipcount$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN12@GL_CalcMip
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN13@GL_CalcMip
$LN12@GL_CalcMip:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _mipcount$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv87[ebp], edx
$LN13@GL_CalcMip:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 490  : 		height = Q_max( 1, ( tex->height >> mipcount ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _mipcount$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN14@GL_CalcMip
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN15@GL_CalcMip
$LN14@GL_CalcMip:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _mipcount$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv95[ebp], edx
$LN15@GL_CalcMip:
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 491  : 		if( width == 1 && height == 1 )

	cmp	DWORD PTR _width$[ebp], 1
	jne	SHORT $LN8@GL_CalcMip
	cmp	DWORD PTR _height$[ebp], 1
	jne	SHORT $LN8@GL_CalcMip

; 492  : 			break;

	jmp	SHORT $LN3@GL_CalcMip
$LN8@GL_CalcMip:

; 493  : 	}

	jmp	$LN2@GL_CalcMip
$LN3@GL_CalcMip:

; 494  : 
; 495  : 	return mipcount + 1;

	mov	eax, DWORD PTR _mipcount$[ebp]
	add	eax, 1
$LN1@GL_CalcMip:

; 496  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CalcMipmapCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CalcTextureSize
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv65 = -72						; size = 4
_size$ = -4						; size = 4
_format$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_GL_CalcTextureSize PROC				; COMDAT

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 379  : 	size_t	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 380  : 
; 381  : 	// check the depth error
; 382  : 	depth = Q_max( 1, depth );

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN42@GL_CalcTex
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN43@GL_CalcTex
$LN42@GL_CalcTex:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv65[ebp], eax
$LN43@GL_CalcTex:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _depth$[ebp], ecx

; 383  : 
; 384  : 	switch( format )

	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 32832		; 00008040H
	ja	SHORT $LN44@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 32832		; 00008040H
	je	$LN18@GL_CalcTex
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 6407				; 00001907H
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 3
	ja	$LN40@GL_CalcTex
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN50@GL_CalcTex[edx*4]
$LN44@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 33189		; 000081a5H
	ja	SHORT $LN45@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 33189		; 000081a5H
	je	$LN37@GL_CalcTex
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 32837				; 00008045H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 19			; 00000013H
	ja	$LN40@GL_CalcTex
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN51@GL_CalcTex[ecx]
	jmp	DWORD PTR $LN52@GL_CalcTex[edx*4]
$LN45@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 33776		; 000083f0H
	ja	SHORT $LN46@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 33776		; 000083f0H
	je	$LN5@GL_CalcTex
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 33190				; 000081a6H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 138		; 0000008aH
	ja	$LN40@GL_CalcTex
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN53@GL_CalcTex[ecx]
	jmp	DWORD PTR $LN54@GL_CalcTex[edx*4]
$LN46@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 34836		; 00008814H
	ja	SHORT $LN47@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 34836		; 00008814H
	je	$LN36@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 33777		; 000083f1H
	je	$LN5@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 33778		; 000083f2H
	je	$LN8@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 33779		; 000083f3H
	je	$LN8@GL_CalcTex
	jmp	$LN40@GL_CalcTex
$LN47@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 34840		; 00008818H
	ja	SHORT $LN48@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 34840		; 00008818H
	je	$LN28@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 34837		; 00008815H
	je	$LN36@GL_CalcTex
	jmp	$LN40@GL_CalcTex
$LN48@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 36012		; 00008cacH
	ja	SHORT $LN49@GL_CalcTex
	cmp	DWORD PTR tv66[ebp], 36012		; 00008cacH
	je	$LN39@GL_CalcTex
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 34841				; 00008819H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 6
	ja	$LN40@GL_CalcTex
	mov	ecx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN55@GL_CalcTex[ecx*4]
$LN49@GL_CalcTex:
	cmp	DWORD PTR tv66[ebp], 36285		; 00008dbdH
	je	SHORT $LN8@GL_CalcTex
	jmp	$LN40@GL_CalcTex
$LN5@GL_CalcTex:

; 385  : 	{
; 386  : 	case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
; 387  : 	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
; 388  : 		size = (((width + 3) >> 2) * ((height + 3) >> 2) * 8) * depth;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	sar	eax, 2
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 3
	sar	ecx, 2
	imul	eax, ecx
	shl	eax, 3
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 389  : 		break;

	jmp	$LN2@GL_CalcTex
$LN8@GL_CalcTex:

; 390  : 	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
; 391  : 	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
; 392  : 	case GL_COMPRESSED_RED_GREEN_RGTC2_EXT:
; 393  : 		size = (((width + 3) >> 2) * ((height + 3) >> 2) * 16) * depth;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	sar	eax, 2
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 3
	sar	ecx, 2
	imul	eax, ecx
	shl	eax, 4
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 394  : 		break;

	jmp	$LN2@GL_CalcTex
$LN10@GL_CalcTex:

; 395  : 	case GL_RGBA8:
; 396  : 	case GL_RGBA:
; 397  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 398  : 		break;

	jmp	$LN2@GL_CalcTex
$LN12@GL_CalcTex:

; 399  : 	case GL_RGB8:
; 400  : 	case GL_RGB:
; 401  : 		size = width * height * depth * 3;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	imul	ecx, eax, 3
	mov	DWORD PTR _size$[ebp], ecx

; 402  : 		break;

	jmp	$LN2@GL_CalcTex
$LN13@GL_CalcTex:

; 403  : 	case GL_RGB5:
; 404  : 		size = (width * height * depth * 3) / 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	imul	eax, eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 405  : 		break;

	jmp	$LN2@GL_CalcTex
$LN14@GL_CalcTex:

; 406  : 	case GL_RGBA4:
; 407  : 		size = (width * height * depth * 4) / 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 408  : 		break;

	jmp	$LN2@GL_CalcTex
$LN18@GL_CalcTex:

; 409  : 	case GL_INTENSITY:
; 410  : 	case GL_LUMINANCE:
; 411  : 	case GL_INTENSITY8:
; 412  : 	case GL_LUMINANCE8:
; 413  : 		size = (width * height * depth);

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 414  : 		break;

	jmp	$LN2@GL_CalcTex
$LN20@GL_CalcTex:

; 415  : 	case GL_LUMINANCE_ALPHA:
; 416  : 	case GL_LUMINANCE8_ALPHA8:
; 417  : 		size = width * height * depth * 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 418  : 		break;

	jmp	$LN2@GL_CalcTex
$LN21@GL_CalcTex:

; 419  : 	case GL_R8:
; 420  : 		size = width * height * depth;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 421  : 		break;

	jmp	$LN2@GL_CalcTex
$LN22@GL_CalcTex:

; 422  : 	case GL_RG8:
; 423  : 		size = width * height * depth * 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 424  : 		break;

	jmp	$LN2@GL_CalcTex
$LN23@GL_CalcTex:

; 425  : 	case GL_R16:
; 426  : 		size = width * height * depth * 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 427  : 		break;

	jmp	$LN2@GL_CalcTex
$LN24@GL_CalcTex:

; 428  : 	case GL_RG16:
; 429  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 430  : 		break;

	jmp	$LN2@GL_CalcTex
$LN26@GL_CalcTex:

; 431  : 	case GL_R16F:
; 432  : 	case GL_LUMINANCE16F_ARB:
; 433  : 		size = width * height * depth * 2;	// half-floats

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 434  : 		break;

	jmp	$LN2@GL_CalcTex
$LN28@GL_CalcTex:

; 435  : 	case GL_R32F:
; 436  : 	case GL_LUMINANCE32F_ARB:
; 437  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 438  : 		break;

	jmp	$LN2@GL_CalcTex
$LN30@GL_CalcTex:

; 439  : 	case GL_RG16F:
; 440  : 	case GL_LUMINANCE_ALPHA16F_ARB:
; 441  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 442  : 		break;

	jmp	$LN2@GL_CalcTex
$LN32@GL_CalcTex:

; 443  : 	case GL_RG32F:
; 444  : 	case GL_LUMINANCE_ALPHA32F_ARB:
; 445  : 		size = width * height * depth * 8;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 3
	mov	DWORD PTR _size$[ebp], eax

; 446  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN34@GL_CalcTex:

; 447  : 	case GL_RGB16F_ARB:
; 448  : 	case GL_RGBA16F_ARB:
; 449  : 		size = width * height * depth * 8;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 3
	mov	DWORD PTR _size$[ebp], eax

; 450  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN36@GL_CalcTex:

; 451  : 	case GL_RGB32F_ARB:
; 452  : 	case GL_RGBA32F_ARB:
; 453  : 		size = width * height * depth * 16;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 4
	mov	DWORD PTR _size$[ebp], eax

; 454  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN37@GL_CalcTex:

; 455  : 	case GL_DEPTH_COMPONENT16:
; 456  : 		size = width * height * depth * 2;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 457  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN38@GL_CalcTex:

; 458  : 	case GL_DEPTH_COMPONENT24:
; 459  : 		size = width * height * depth * 3;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	imul	ecx, eax, 3
	mov	DWORD PTR _size$[ebp], ecx

; 460  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN39@GL_CalcTex:

; 461  : 	case GL_DEPTH_COMPONENT32F:
; 462  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 463  : 		break;

	jmp	SHORT $LN2@GL_CalcTex
$LN40@GL_CalcTex:

; 464  : 	default:
; 465  : 		Host_Error( "GL_CalcTextureSize: bad texture internal format (%u)\n", format );

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@JMKCEBIO@GL_CalcTextureSize?3?5bad?5texture@
	call	_Host_Error
	add	esp, 8
$LN2@GL_CalcTex:

; 466  : 		break;
; 467  : 	}
; 468  : 
; 469  : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 470  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN50@GL_CalcTex:
	DD	$LN12@GL_CalcTex
	DD	$LN10@GL_CalcTex
	DD	$LN18@GL_CalcTex
	DD	$LN20@GL_CalcTex
$LN52@GL_CalcTex:
	DD	$LN20@GL_CalcTex
	DD	$LN18@GL_CalcTex
	DD	$LN13@GL_CalcTex
	DD	$LN12@GL_CalcTex
	DD	$LN14@GL_CalcTex
	DD	$LN10@GL_CalcTex
	DD	$LN40@GL_CalcTex
$LN51@GL_CalcTex:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
$LN54@GL_CalcTex:
	DD	$LN38@GL_CalcTex
	DD	$LN21@GL_CalcTex
	DD	$LN23@GL_CalcTex
	DD	$LN22@GL_CalcTex
	DD	$LN24@GL_CalcTex
	DD	$LN26@GL_CalcTex
	DD	$LN28@GL_CalcTex
	DD	$LN30@GL_CalcTex
	DD	$LN32@GL_CalcTex
	DD	$LN40@GL_CalcTex
$LN53@GL_CalcTex:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	npad	1
$LN55@GL_CalcTex:
	DD	$LN32@GL_CalcTex
	DD	$LN34@GL_CalcTex
	DD	$LN34@GL_CalcTex
	DD	$LN40@GL_CalcTex
	DD	$LN40@GL_CalcTex
	DD	$LN26@GL_CalcTex
	DD	$LN30@GL_CalcTex
_GL_CalcTextureSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CalcImageSize
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv65 = -72						; size = 4
_size$ = -4						; size = 4
_format$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_GL_CalcImageSize PROC					; COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 344  : 	size_t	size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 345  : 
; 346  : 	// check the depth error
; 347  : 	depth = Q_max( 1, depth );

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN13@GL_CalcIma
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN14@GL_CalcIma
$LN13@GL_CalcIma:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv65[ebp], eax
$LN14@GL_CalcIma:
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _depth$[ebp], ecx

; 348  : 
; 349  : 	switch( format )

	mov	eax, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 7
	ja	SHORT $LN2@GL_CalcIma
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN15@GL_CalcIma[edx*4]
$LN5@GL_CalcIma:

; 350  : 	{
; 351  : 	case PF_RGB_24:
; 352  : 	case PF_BGR_24:
; 353  : 		size = width * height * depth * 3;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	imul	ecx, eax, 3
	mov	DWORD PTR _size$[ebp], ecx

; 354  : 		break;

	jmp	SHORT $LN2@GL_CalcIma
$LN7@GL_CalcIma:

; 355  : 	case PF_BGRA_32:
; 356  : 	case PF_RGBA_32:
; 357  : 		size = width * height * depth * 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _depth$[ebp]
	shl	eax, 2
	mov	DWORD PTR _size$[ebp], eax

; 358  : 		break;

	jmp	SHORT $LN2@GL_CalcIma
$LN8@GL_CalcIma:

; 359  : 	case PF_DXT1:
; 360  : 		size = (((width + 3) >> 2) * ((height + 3) >> 2) * 8) * depth;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	sar	eax, 2
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 3
	sar	ecx, 2
	imul	eax, ecx
	shl	eax, 3
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 361  : 		break;

	jmp	SHORT $LN2@GL_CalcIma
$LN11@GL_CalcIma:

; 362  : 	case PF_DXT3:
; 363  : 	case PF_DXT5:
; 364  : 	case PF_ATI2:
; 365  : 		size = (((width + 3) >> 2) * ((height + 3) >> 2) * 16) * depth;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	sar	eax, 2
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 3
	sar	ecx, 2
	imul	eax, ecx
	shl	eax, 4
	imul	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR _size$[ebp], eax
$LN2@GL_CalcIma:

; 366  : 		break;
; 367  : 	}
; 368  : 
; 369  : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 370  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@GL_CalcIma:
	DD	$LN7@GL_CalcIma
	DD	$LN7@GL_CalcIma
	DD	$LN5@GL_CalcIma
	DD	$LN5@GL_CalcIma
	DD	$LN8@GL_CalcIma
	DD	$LN11@GL_CalcIma
	DD	$LN11@GL_CalcIma
	DD	$LN11@GL_CalcIma
_GL_CalcImageSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CalcTextureSamples
_TEXT	SEGMENT
tv71 = -68						; size = 4
tv68 = -68						; size = 4
_flags$ = 8						; size = 4
_GL_CalcTextureSamples PROC				; COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 332  : 	if( FBitSet( flags, IMAGE_HAS_COLOR ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN2@GL_CalcTex

; 333  : 		return FBitSet( flags, IMAGE_HAS_ALPHA ) ? 4 : 3;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@GL_CalcTex
	mov	DWORD PTR tv68[ebp], 4
	jmp	SHORT $LN5@GL_CalcTex
$LN4@GL_CalcTex:
	mov	DWORD PTR tv68[ebp], 3
$LN5@GL_CalcTex:
	mov	eax, DWORD PTR tv68[ebp]
	jmp	SHORT $LN1@GL_CalcTex
$LN2@GL_CalcTex:

; 334  : 	return FBitSet( flags, IMAGE_HAS_ALPHA ) ? 2 : 1;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN6@GL_CalcTex
	mov	DWORD PTR tv71[ebp], 2
	jmp	SHORT $LN7@GL_CalcTex
$LN6@GL_CalcTex:
	mov	DWORD PTR tv71[ebp], 1
$LN7@GL_CalcTex:
	mov	eax, DWORD PTR tv71[ebp]
$LN1@GL_CalcTex:

; 335  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CalcTextureSamples ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_UpdateTextureParams
_TEXT	SEGMENT
tv72 = -72						; size = 4
_tex$ = -4						; size = 4
_iTexture$ = 8						; size = 4
_GL_UpdateTextureParams PROC				; COMDAT

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 246  : 	gl_texture_t	*tex = &gl_textures[iTexture];

	imul	eax, DWORD PTR _iTexture$[ebp], 320
	add	eax, OFFSET _gl_textures
	mov	DWORD PTR _tex$[ebp], eax

; 247  : 
; 248  : 	Assert( tex != NULL );

	je	SHORT $LN13@GL_UpdateT
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN14@GL_UpdateT
$LN13@GL_UpdateT:
	mov	DWORD PTR tv72[ebp], 0
$LN14@GL_UpdateT:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_UpdateTextureParams@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 249  : 
; 250  : 	if( !tex->texnum ) return; // free slot

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+272], 0
	jne	SHORT $LN2@GL_UpdateT
	jmp	$LN10@GL_UpdateT
$LN2@GL_UpdateT:

; 251  : 
; 252  : 	GL_Bind( GL_TEXTURE0, iTexture );

	mov	eax, DWORD PTR _iTexture$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 253  : 
; 254  : 	// set texture anisotropy if available
; 255  : 	if( GL_Support( GL_ANISOTROPY_EXT ) && ( tex->numMips > 1 ) && !FBitSet( tex->flags, TF_DEPTHMAP|TF_ALPHACONTRAST ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@GL_UpdateT
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jle	SHORT $LN3@GL_UpdateT
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4194432				; 00400080H
	jne	SHORT $LN3@GL_UpdateT

; 256  : 		pglTexParameterf( tex->target, GL_TEXTURE_MAX_ANISOTROPY_EXT, gl_texture_anisotropy->value );

	mov	eax, DWORD PTR _gl_texture_anisotropy
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	push	34046					; 000084feH
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexParameterf
$LN3@GL_UpdateT:

; 257  : 
; 258  : 	// set texture LOD bias if available
; 259  : 	if( GL_Support( GL_TEXTURE_LOD_BIAS ) && ( tex->numMips > 1 ) && !FBitSet( tex->flags, TF_DEPTHMAP ))

	push	7
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN4@GL_UpdateT
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jle	SHORT $LN4@GL_UpdateT
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	jne	SHORT $LN4@GL_UpdateT

; 260  : 		pglTexParameterf( tex->target, GL_TEXTURE_LOD_BIAS_EXT, gl_texture_lodbias->value );

	mov	eax, DWORD PTR _gl_texture_lodbias
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	push	34049					; 00008501H
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexParameterf
$LN4@GL_UpdateT:

; 261  : 
; 262  : 	if( IsLightMap( tex ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 2097152				; 00200000H
	je	$LN7@GL_UpdateT

; 263  : 	{
; 264  : 		if( gl_lightmap_nearest->value )

	mov	eax, DWORD PTR _gl_lightmap_nearest
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@GL_UpdateT

; 265  : 		{
; 266  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 267  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 268  : 		}

	jmp	SHORT $LN7@GL_UpdateT
$LN6@GL_UpdateT:

; 269  : 		else
; 270  : 		{
; 271  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 272  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN7@GL_UpdateT:

; 273  : 		}
; 274  : 	}
; 275  : 
; 276  : 	if( tex->numMips <= 1 ) return;

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jg	SHORT $LN8@GL_UpdateT
	jmp	$LN10@GL_UpdateT
$LN8@GL_UpdateT:

; 277  : 
; 278  : 	if( FBitSet( tex->flags, TF_NEAREST ) || gl_texture_nearest->value )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 1
	jne	SHORT $LN11@GL_UpdateT
	mov	eax, DWORD PTR _gl_texture_nearest
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@GL_UpdateT
$LN11@GL_UpdateT:

; 279  : 	{
; 280  : 		pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST );

	push	9984					; 00002700H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 281  : 		pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 282  : 	}

	jmp	SHORT $LN10@GL_UpdateT
$LN9@GL_UpdateT:

; 283  : 	else
; 284  : 	{
; 285  : 		pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );

	push	9987					; 00002703H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 286  : 		pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN10@GL_UpdateT:

; 287  : 	}
; 288  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UpdateTextureParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_TargetToString
_TEXT	SEGMENT
tv64 = -68						; size = 4
_target$ = 8						; size = 4
_GL_TargetToString PROC					; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 47   : 	switch( target )

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 34037		; 000084f5H
	ja	SHORT $LN11@GL_TargetT
	cmp	DWORD PTR tv64[ebp], 34037		; 000084f5H
	je	SHORT $LN9@GL_TargetT
	cmp	DWORD PTR tv64[ebp], 3552		; 00000de0H
	je	SHORT $LN4@GL_TargetT
	cmp	DWORD PTR tv64[ebp], 3553		; 00000de1H
	je	SHORT $LN5@GL_TargetT
	cmp	DWORD PTR tv64[ebp], 32879		; 0000806fH
	je	SHORT $LN6@GL_TargetT
	jmp	SHORT $LN2@GL_TargetT
$LN11@GL_TargetT:
	cmp	DWORD PTR tv64[ebp], 34067		; 00008513H
	je	SHORT $LN7@GL_TargetT
	cmp	DWORD PTR tv64[ebp], 35866		; 00008c1aH
	je	SHORT $LN8@GL_TargetT
	jmp	SHORT $LN2@GL_TargetT
$LN4@GL_TargetT:

; 48   : 	{
; 49   : 	case GL_TEXTURE_1D:
; 50   : 		return "1D";

	mov	eax, OFFSET ??_C@_02LBACCDEL@1D@
	jmp	SHORT $LN1@GL_TargetT
$LN5@GL_TargetT:

; 51   : 	case GL_TEXTURE_2D:
; 52   : 		return "2D";

	mov	eax, OFFSET ??_C@_02LDEEJNBC@2D@
	jmp	SHORT $LN1@GL_TargetT
$LN6@GL_TargetT:

; 53   : 	case GL_TEXTURE_3D:
; 54   : 		return "3D";

	mov	eax, OFFSET ??_C@_02LCIGPHCF@3D@
	jmp	SHORT $LN1@GL_TargetT
$LN7@GL_TargetT:

; 55   : 	case GL_TEXTURE_CUBE_MAP_ARB:
; 56   : 		return "Cube";

	mov	eax, OFFSET ??_C@_04CJLGPKHJ@Cube@
	jmp	SHORT $LN1@GL_TargetT
$LN8@GL_TargetT:

; 57   : 	case GL_TEXTURE_2D_ARRAY_EXT:
; 58   : 		return "Array";

	mov	eax, OFFSET ??_C@_05HPPFDPIF@Array@
	jmp	SHORT $LN1@GL_TargetT
$LN9@GL_TargetT:

; 59   : 	case GL_TEXTURE_RECTANGLE_EXT:
; 60   : 		return "Rect";

	mov	eax, OFFSET ??_C@_04HGDEFKPD@Rect@
	jmp	SHORT $LN1@GL_TargetT
$LN2@GL_TargetT:

; 61   : 	}
; 62   : 	return "??";

	mov	eax, OFFSET ??_C@_02HHFHKOHM@?$DP?$DP@
$LN1@GL_TargetT:

; 63   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_TargetToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_ShutdownImages
_TEXT	SEGMENT
_i$ = -8						; size = 4
_tex$ = -4						; size = 4
_R_ShutdownImages PROC					; COMDAT

; 2209 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2210 : 	gl_texture_t	*tex;
; 2211 : 	int		i;
; 2212 : 
; 2213 : 	Cmd_RemoveCommand( "texturelist" );

	push	OFFSET ??_C@_0M@KECGGPF@texturelist@
	call	_Cmd_RemoveCommand
	add	esp, 4

; 2214 : 	GL_CleanupAllTextureUnits();

	call	_GL_CleanupAllTextureUnits

; 2215 : 
; 2216 : 	for( i = 0, tex = gl_textures; i < gl_numTextures; i++, tex++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _tex$[ebp], OFFSET _gl_textures
	jmp	SHORT $LN4@R_Shutdown
$LN2@R_Shutdown:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _tex$[ebp]
	add	ecx, 320				; 00000140H
	mov	DWORD PTR _tex$[ebp], ecx
$LN4@R_Shutdown:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gl_numTextures
	jae	SHORT $LN3@R_Shutdown

; 2217 : 		GL_DeleteTexture( tex );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_DeleteTexture
	add	esp, 4
	jmp	SHORT $LN2@R_Shutdown
$LN3@R_Shutdown:

; 2218 : 
; 2219 : 	memset( tr.lightmapTextures, 0, sizeof( tr.lightmapTextures ));

	push	1024					; 00000400H
	push	0
	push	OFFSET _tr+28
	call	_memset
	add	esp, 12					; 0000000cH

; 2220 : 	memset( gl_texturesHashTable, 0, sizeof( gl_texturesHashTable ));

	push	4096					; 00001000H
	push	0
	push	OFFSET _gl_texturesHashTable
	call	_memset
	add	esp, 12					; 0000000cH

; 2221 : 	memset( gl_textures, 0, sizeof( gl_textures ));

	push	1310720					; 00140000H
	push	0
	push	OFFSET _gl_textures
	call	_memset
	add	esp, 12					; 0000000cH

; 2222 : 	gl_numTextures = 0;

	mov	DWORD PTR _gl_numTextures, 0

; 2223 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_ShutdownImages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_InitImages
_TEXT	SEGMENT
_R_InitImages PROC					; COMDAT

; 2184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2185 : 	memset( gl_textures, 0, sizeof( gl_textures ));

	push	1310720					; 00140000H
	push	0
	push	OFFSET _gl_textures
	call	_memset
	add	esp, 12					; 0000000cH

; 2186 : 	memset( gl_texturesHashTable, 0, sizeof( gl_texturesHashTable ));

	push	4096					; 00001000H
	push	0
	push	OFFSET _gl_texturesHashTable
	call	_memset
	add	esp, 12					; 0000000cH

; 2187 : 	gl_numTextures = 0;

	mov	DWORD PTR _gl_numTextures, 0

; 2188 : 
; 2189 : 	// create unused 0-entry
; 2190 : 	Q_strncpy( gl_textures->name, "*unused*", sizeof( gl_textures->name ));

	push	256					; 00000100H
	push	OFFSET ??_C@_08PIMAOFKI@?$CKunused?$CK@
	push	OFFSET _gl_textures
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2191 : 	gl_textures->hashValue = COM_HashKey( gl_textures->name, TEXTURES_HASH_SIZE );

	push	1024					; 00000400H
	push	OFFSET _gl_textures
	call	_COM_HashKey
	add	esp, 8
	mov	DWORD PTR _gl_textures+312, eax

; 2192 : 	gl_textures->nextHash = gl_texturesHashTable[gl_textures->hashValue];

	mov	eax, DWORD PTR _gl_textures+312
	mov	ecx, DWORD PTR _gl_texturesHashTable[eax*4]
	mov	DWORD PTR _gl_textures+316, ecx

; 2193 : 	gl_texturesHashTable[gl_textures->hashValue] = gl_textures;

	mov	eax, DWORD PTR _gl_textures+312
	mov	DWORD PTR _gl_texturesHashTable[eax*4], OFFSET _gl_textures

; 2194 : 	gl_numTextures = 1;

	mov	DWORD PTR _gl_numTextures, 1

; 2195 : 
; 2196 : 	// validate cvars
; 2197 : 	R_SetTextureParameters();

	call	_R_SetTextureParameters

; 2198 : 	GL_CreateInternalTextures();

	call	_GL_CreateInternalTextures

; 2199 : 
; 2200 : 	Cmd_AddCommand( "texturelist", R_TextureList_f, "display loaded textures list" );

	push	OFFSET ??_C@_0BN@GENJBCGG@display?5loaded?5textures?5list@
	push	OFFSET _R_TextureList_f
	push	OFFSET ??_C@_0M@KECGGPF@texturelist@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 2201 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_InitImages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_TextureList_f
_TEXT	SEGMENT
tv329 = -92						; size = 8
tv325 = -84						; size = 4
tv244 = -84						; size = 4
tv223 = -84						; size = 4
tv91 = -84						; size = 4
_bytes$ = -16						; size = 4
_texCount$ = -12					; size = 4
_i$ = -8						; size = 4
_image$ = -4						; size = 4
_R_TextureList_f PROC					; COMDAT

; 1976 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1977 : 	gl_texture_t	*image;
; 1978 : 	int		i, texCount, bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 1979 : 
; 1980 : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 1981 : 	Con_Printf( " -id-   -w-  -h-     -size- -fmt- -type- -data-  -encode- -wrap- -depth- -name--------\n" );

	push	OFFSET ??_C@_0FI@DHCNGGFA@?5?9id?9?5?5?5?9w?9?5?5?9h?9?5?5?5?5?5?9size?9?5?9fm@
	call	_Con_Printf
	add	esp, 4

; 1982 : 
; 1983 : 	for( i = texCount = 0, image = gl_textures; i < gl_numTextures; i++, image++ )

	mov	DWORD PTR _texCount$[ebp], 0
	mov	eax, DWORD PTR _texCount$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _image$[ebp], OFFSET _gl_textures
	jmp	SHORT $LN4@R_TextureL
$LN2@R_TextureL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _image$[ebp]
	add	ecx, 320				; 00000140H
	mov	DWORD PTR _image$[ebp], ecx
$LN4@R_TextureL:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gl_numTextures
	jae	$LN3@R_TextureL

; 1984 : 	{
; 1985 : 		if( !image->texnum ) continue;

	mov	eax, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [eax+272], 0
	jne	SHORT $LN11@R_TextureL
	jmp	SHORT $LN2@R_TextureL
$LN11@R_TextureL:

; 1986 : 
; 1987 : 		bytes += image->size;

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR _bytes$[ebp]
	add	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR _bytes$[ebp], ecx

; 1988 : 		texCount++;

	mov	eax, DWORD PTR _texCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _texCount$[ebp], eax

; 1989 : 
; 1990 : 		Con_Printf( "%4i: ", i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_05LHKLCIPC@?$CF4i?3?5@
	call	_Con_Printf
	add	esp, 8

; 1991 : 		Con_Printf( "%4i %4i ", image->width, image->height );

	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	push	ecx
	mov	edx, DWORD PTR _image$[ebp]
	movzx	eax, WORD PTR [edx+260]
	push	eax
	push	OFFSET ??_C@_08GNHPGGLF@?$CF4i?5?$CF4i?5@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1992 : 		Con_Printf( "%12s ", Q_memprint( image->size ));

	push	2
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR tv325[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv325[ebp]
	mov	edx, DWORD PTR tv325[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv329[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv329[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_05BMAMJJGO@?$CF12s?5@
	call	_Con_Printf
	add	esp, 8

; 1993 : 
; 1994 : 		switch( image->format )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	mov	DWORD PTR tv91[ebp], ecx
	cmp	DWORD PTR tv91[ebp], 33776		; 000083f0H
	jg	$LN72@R_TextureL
	cmp	DWORD PTR tv91[ebp], 33776		; 000083f0H
	je	$LN18@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32828		; 0000803cH
	jg	SHORT $LN73@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32828		; 0000803cH
	je	$LN35@R_TextureL
	mov	edx, DWORD PTR tv91[ebp]
	sub	edx, 6402				; 00001902H
	mov	DWORD PTR tv91[ebp], edx
	cmp	DWORD PTR tv91[ebp], 8
	ja	$LN50@R_TextureL
	mov	eax, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN80@R_TextureL[eax*4]
$LN73@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 32843		; 0000804bH
	jg	SHORT $LN74@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32843		; 0000804bH
	je	$LN36@R_TextureL
	mov	ecx, DWORD PTR tv91[ebp]
	sub	ecx, 32831				; 0000803fH
	mov	DWORD PTR tv91[ebp], ecx
	cmp	DWORD PTR tv91[ebp], 6
	ja	$LN50@R_TextureL
	mov	edx, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN81@R_TextureL[edx*4]
$LN74@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 32856		; 00008058H
	jg	SHORT $LN75@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32856		; 00008058H
	je	$LN24@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32848		; 00008050H
	je	$LN28@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32849		; 00008051H
	je	$LN27@R_TextureL
	cmp	DWORD PTR tv91[ebp], 32854		; 00008056H
	je	$LN25@R_TextureL
	jmp	$LN50@R_TextureL
$LN75@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 33190		; 000081a6H
	je	$LN37@R_TextureL
	cmp	DWORD PTR tv91[ebp], 33327		; 0000822fH
	je	$LN44@R_TextureL
	cmp	DWORD PTR tv91[ebp], 33328		; 00008230H
	je	$LN45@R_TextureL
	jmp	$LN50@R_TextureL
$LN72@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 34836		; 00008814H
	jg	SHORT $LN76@R_TextureL
	cmp	DWORD PTR tv91[ebp], 34836		; 00008814H
	je	$LN49@R_TextureL
	mov	eax, DWORD PTR tv91[ebp]
	sub	eax, 33777				; 000083f1H
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 253		; 000000fdH
	ja	$LN50@R_TextureL
	mov	ecx, DWORD PTR tv91[ebp]
	movzx	edx, BYTE PTR $LN82@R_TextureL[ecx]
	jmp	DWORD PTR $LN83@R_TextureL[edx*4]
$LN76@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 34840		; 00008818H
	jg	SHORT $LN77@R_TextureL
	cmp	DWORD PTR tv91[ebp], 34840		; 00008818H
	je	$LN41@R_TextureL
	cmp	DWORD PTR tv91[ebp], 34837		; 00008815H
	je	$LN47@R_TextureL
	jmp	$LN50@R_TextureL
$LN77@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 36012		; 00008cacH
	jg	SHORT $LN78@R_TextureL
	cmp	DWORD PTR tv91[ebp], 36012		; 00008cacH
	je	$LN39@R_TextureL
	mov	eax, DWORD PTR tv91[ebp]
	sub	eax, 34841				; 00008819H
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 6
	ja	$LN50@R_TextureL
	mov	ecx, DWORD PTR tv91[ebp]
	jmp	DWORD PTR $LN84@R_TextureL[ecx*4]
$LN78@R_TextureL:
	cmp	DWORD PTR tv91[ebp], 36285		; 00008dbdH
	je	$LN22@R_TextureL
	jmp	$LN50@R_TextureL
$LN12@R_TextureL:

; 1995 : 		{
; 1996 : 		case GL_COMPRESSED_RGBA_ARB:
; 1997 : 			Con_Printf( "CRGBA " );

	push	OFFSET ??_C@_06GJCEDBCD@CRGBA?5@
	call	_Con_Printf
	add	esp, 4

; 1998 : 			break;

	jmp	$LN5@R_TextureL
$LN13@R_TextureL:

; 1999 : 		case GL_COMPRESSED_RGB_ARB:
; 2000 : 			Con_Printf( "CRGB  " );

	push	OFFSET ??_C@_06CADBJADE@CRGB?5?5@
	call	_Con_Printf
	add	esp, 4

; 2001 : 			break;

	jmp	$LN5@R_TextureL
$LN14@R_TextureL:

; 2002 : 		case GL_COMPRESSED_LUMINANCE_ALPHA_ARB:
; 2003 : 			Con_Printf( "CLA   " );

	push	OFFSET ??_C@_06HICDJPH@CLA?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2004 : 			break;

	jmp	$LN5@R_TextureL
$LN15@R_TextureL:

; 2005 : 		case GL_COMPRESSED_LUMINANCE_ARB:
; 2006 : 			Con_Printf( "CL    " );

	push	OFFSET ??_C@_06KDNAGHAK@CL?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2007 : 			break;

	jmp	$LN5@R_TextureL
$LN16@R_TextureL:

; 2008 : 		case GL_COMPRESSED_ALPHA_ARB:
; 2009 : 			Con_Printf( "CA    " );

	push	OFFSET ??_C@_06BPEOHENE@CA?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2010 : 			break;

	jmp	$LN5@R_TextureL
$LN17@R_TextureL:

; 2011 : 		case GL_COMPRESSED_INTENSITY_ARB:
; 2012 : 			Con_Printf( "CI    " );

	push	OFFSET ??_C@_06PDBNPGLJ@CI?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2013 : 			break;

	jmp	$LN5@R_TextureL
$LN18@R_TextureL:

; 2014 : 		case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
; 2015 : 			Con_Printf( "DXT1c " );

	push	OFFSET ??_C@_06GIBLFMGF@DXT1c?5@
	call	_Con_Printf
	add	esp, 4

; 2016 : 			break;

	jmp	$LN5@R_TextureL
$LN19@R_TextureL:

; 2017 : 		case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
; 2018 : 			Con_Printf( "DXT1a " );

	push	OFFSET ??_C@_06GLJPIIAL@DXT1a?5@
	call	_Con_Printf
	add	esp, 4

; 2019 : 			break;

	jmp	$LN5@R_TextureL
$LN20@R_TextureL:

; 2020 : 		case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
; 2021 : 			Con_Printf( "DXT3  " );

	push	OFFSET ??_C@_06LAMOKHHH@DXT3?5?5@
	call	_Con_Printf
	add	esp, 4

; 2022 : 			break;

	jmp	$LN5@R_TextureL
$LN21@R_TextureL:

; 2023 : 		case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
; 2024 : 			Con_Printf( "DXT5  " );

	push	OFFSET ??_C@_06JFKFPIKL@DXT5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2025 : 			break;

	jmp	$LN5@R_TextureL
$LN22@R_TextureL:

; 2026 : 		case GL_COMPRESSED_RED_GREEN_RGTC2_EXT:
; 2027 : 			Con_Printf( "ATI2  " );

	push	OFFSET ??_C@_06LFPIHMPN@ATI2?5?5@
	call	_Con_Printf
	add	esp, 4

; 2028 : 			break;

	jmp	$LN5@R_TextureL
$LN23@R_TextureL:

; 2029 : 		case GL_RGBA:
; 2030 : 			Con_Printf( "RGBA  " );

	push	OFFSET ??_C@_06GINGLEPI@RGBA?5?5@
	call	_Con_Printf
	add	esp, 4

; 2031 : 			break;

	jmp	$LN5@R_TextureL
$LN24@R_TextureL:

; 2032 : 		case GL_RGBA8:
; 2033 : 			Con_Printf( "RGBA8 " );

	push	OFFSET ??_C@_06HKODEGDA@RGBA8?5@
	call	_Con_Printf
	add	esp, 4

; 2034 : 			break;

	jmp	$LN5@R_TextureL
$LN25@R_TextureL:

; 2035 : 		case GL_RGBA4:
; 2036 : 			Con_Printf( "RGBA4 " );

	push	OFFSET ??_C@_06HDPJLPFE@RGBA4?5@
	call	_Con_Printf
	add	esp, 4

; 2037 : 			break;

	jmp	$LN5@R_TextureL
$LN26@R_TextureL:

; 2038 : 		case GL_RGB:
; 2039 : 			Con_Printf( "RGB   " );

	push	OFFSET ??_C@_06OLEMCEJO@RGB?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2040 : 			break;

	jmp	$LN5@R_TextureL
$LN27@R_TextureL:

; 2041 : 		case GL_RGB8:
; 2042 : 			Con_Printf( "RGB8  " );

	push	OFFSET ??_C@_06HOOBFLOO@RGB8?5?5@
	call	_Con_Printf
	add	esp, 4

; 2043 : 			break;

	jmp	$LN5@R_TextureL
$LN28@R_TextureL:

; 2044 : 		case GL_RGB5:
; 2045 : 			Con_Printf( "RGB5  " );

	push	OFFSET ??_C@_06IMILIDDD@RGB5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2046 : 			break;

	jmp	$LN5@R_TextureL
$LN29@R_TextureL:

; 2047 : 		case GL_LUMINANCE4_ALPHA4:
; 2048 : 			Con_Printf( "L4A4  " );

	push	OFFSET ??_C@_06MJMAAGHK@L4A4?5?5@
	call	_Con_Printf
	add	esp, 4

; 2049 : 			break;

	jmp	$LN5@R_TextureL
$LN30@R_TextureL:

; 2050 : 		case GL_LUMINANCE_ALPHA:
; 2051 : 		case GL_LUMINANCE8_ALPHA8:
; 2052 : 			Con_Printf( "L8A8  " );

	push	OFFSET ??_C@_06PENEHJLJ@L8A8?5?5@
	call	_Con_Printf
	add	esp, 4

; 2053 : 			break;

	jmp	$LN5@R_TextureL
$LN32@R_TextureL:

; 2054 : 		case GL_LUMINANCE4:
; 2055 : 			Con_Printf( "L4    " );

	push	OFFSET ??_C@_06LCOJJIEP@L4?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2056 : 			break;

	jmp	$LN5@R_TextureL
$LN33@R_TextureL:

; 2057 : 		case GL_LUMINANCE:
; 2058 : 		case GL_LUMINANCE8:
; 2059 : 			Con_Printf( "L8    " );

	push	OFFSET ??_C@_06MFCLFIDE@L8?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2060 : 			break;

	jmp	$LN5@R_TextureL
$LN35@R_TextureL:

; 2061 : 		case GL_ALPHA8:
; 2062 : 			Con_Printf( "A8    " );

	push	OFFSET ??_C@_06KEPMDJPE@A8?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2063 : 			break;

	jmp	$LN5@R_TextureL
$LN36@R_TextureL:

; 2064 : 		case GL_INTENSITY8:
; 2065 : 			Con_Printf( "I8    " );

	push	OFFSET ??_C@_06JHBDHHJD@I8?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2066 : 			break;

	jmp	$LN5@R_TextureL
$LN37@R_TextureL:

; 2067 : 		case GL_DEPTH_COMPONENT:
; 2068 : 		case GL_DEPTH_COMPONENT24:
; 2069 : 			Con_Printf( "DPTH24" );

	push	OFFSET ??_C@_06NBKPKCMM@DPTH24@
	call	_Con_Printf
	add	esp, 4

; 2070 : 			break;			

	jmp	$LN5@R_TextureL
$LN39@R_TextureL:

; 2071 : 		case GL_DEPTH_COMPONENT32F:
; 2072 : 			Con_Printf( "DPTH32" );

	push	OFFSET ??_C@_06IGDHGPHN@DPTH32@
	call	_Con_Printf
	add	esp, 4

; 2073 : 			break;

	jmp	$LN5@R_TextureL
$LN40@R_TextureL:

; 2074 : 		case GL_LUMINANCE16F_ARB:
; 2075 : 			Con_Printf( "L16F  " );

	push	OFFSET ??_C@_06BDMJMDAB@L16F?5?5@
	call	_Con_Printf
	add	esp, 4

; 2076 : 			break;

	jmp	$LN5@R_TextureL
$LN41@R_TextureL:

; 2077 : 		case GL_LUMINANCE32F_ARB:
; 2078 : 			Con_Printf( "L32F  " );

	push	OFFSET ??_C@_06KLIBMEMK@L32F?5?5@
	call	_Con_Printf
	add	esp, 4

; 2079 : 			break;

	jmp	$LN5@R_TextureL
$LN42@R_TextureL:

; 2080 : 		case GL_LUMINANCE_ALPHA16F_ARB:
; 2081 : 			Con_Printf( "LA16F " );

	push	OFFSET ??_C@_06INKOAFNO@LA16F?5@
	call	_Con_Printf
	add	esp, 4

; 2082 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN43@R_TextureL:

; 2083 : 		case GL_LUMINANCE_ALPHA32F_ARB:
; 2084 : 			Con_Printf( "LA32F " );

	push	OFFSET ??_C@_06HIAMMBOJ@LA32F?5@
	call	_Con_Printf
	add	esp, 4

; 2085 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN44@R_TextureL:

; 2086 : 		case GL_RG16F:
; 2087 : 			Con_Printf( "RG16F " );

	push	OFFSET ??_C@_06GMBGABFA@RG16F?5@
	call	_Con_Printf
	add	esp, 4

; 2088 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN45@R_TextureL:

; 2089 : 		case GL_RG32F:
; 2090 : 			Con_Printf( "RG32F " );

	push	OFFSET ??_C@_06JJLEMFGH@RG32F?5@
	call	_Con_Printf
	add	esp, 4

; 2091 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN46@R_TextureL:

; 2092 : 		case GL_RGB16F_ARB:
; 2093 : 			Con_Printf( "RGB16F" );

	push	OFFSET ??_C@_06CIOFAHIH@RGB16F@
	call	_Con_Printf
	add	esp, 4

; 2094 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN47@R_TextureL:

; 2095 : 		case GL_RGB32F_ARB:
; 2096 : 			Con_Printf( "RGB32F" );

	push	OFFSET ??_C@_06IFOFGHNA@RGB32F@
	call	_Con_Printf
	add	esp, 4

; 2097 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN48@R_TextureL:

; 2098 : 		case GL_RGBA16F_ARB:
; 2099 : 			Con_Printf( "RGBA16F" );

	push	OFFSET ??_C@_07OFCDKLCB@RGBA16F@
	call	_Con_Printf
	add	esp, 4

; 2100 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN49@R_TextureL:

; 2101 : 		case GL_RGBA32F_ARB:
; 2102 : 			Con_Printf( "RGBA32F" );

	push	OFFSET ??_C@_07EICDMLHG@RGBA32F@
	call	_Con_Printf
	add	esp, 4

; 2103 : 			break;

	jmp	SHORT $LN5@R_TextureL
$LN50@R_TextureL:

; 2104 : 		default:
; 2105 : 			Con_Printf( " ^1ERROR^7 " );

	push	OFFSET ??_C@_0M@CFABDMBF@?5?$FO1ERROR?$FO7?5@
	call	_Con_Printf
	add	esp, 4
$LN5@R_TextureL:

; 2106 : 			break;
; 2107 : 		}
; 2108 : 
; 2109 : 		switch( image->target )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR tv223[ebp], ecx
	cmp	DWORD PTR tv223[ebp], 34037		; 000084f5H
	ja	SHORT $LN79@R_TextureL
	cmp	DWORD PTR tv223[ebp], 34037		; 000084f5H
	je	SHORT $LN55@R_TextureL
	cmp	DWORD PTR tv223[ebp], 3552		; 00000de0H
	je	SHORT $LN51@R_TextureL
	cmp	DWORD PTR tv223[ebp], 3553		; 00000de1H
	je	SHORT $LN52@R_TextureL
	cmp	DWORD PTR tv223[ebp], 32879		; 0000806fH
	je	SHORT $LN53@R_TextureL
	jmp	SHORT $LN57@R_TextureL
$LN79@R_TextureL:
	cmp	DWORD PTR tv223[ebp], 34067		; 00008513H
	je	SHORT $LN54@R_TextureL
	cmp	DWORD PTR tv223[ebp], 35866		; 00008c1aH
	je	SHORT $LN56@R_TextureL
	jmp	SHORT $LN57@R_TextureL
$LN51@R_TextureL:

; 2110 : 		{
; 2111 : 		case GL_TEXTURE_1D:
; 2112 : 			Con_Printf( " 1D   " );

	push	OFFSET ??_C@_06MCIAPOOA@?51D?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2113 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN52@R_TextureL:

; 2114 : 		case GL_TEXTURE_2D:
; 2115 : 			Con_Printf( " 2D   " );

	push	OFFSET ??_C@_06EEBEIMEO@?52D?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2116 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN53@R_TextureL:

; 2117 : 		case GL_TEXTURE_3D:
; 2118 : 			Con_Printf( " 3D   " );

	push	OFFSET ??_C@_06IPEIFPOL@?53D?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2119 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN54@R_TextureL:

; 2120 : 		case GL_TEXTURE_CUBE_MAP_ARB:
; 2121 : 			Con_Printf( "CUBE  " );

	push	OFFSET ??_C@_06GIADBHEF@CUBE?5?5@
	call	_Con_Printf
	add	esp, 4

; 2122 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN55@R_TextureL:

; 2123 : 		case GL_TEXTURE_RECTANGLE_EXT:
; 2124 : 			Con_Printf( "RECT  " );

	push	OFFSET ??_C@_06HPLJJLOO@RECT?5?5@
	call	_Con_Printf
	add	esp, 4

; 2125 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN56@R_TextureL:

; 2126 : 		case GL_TEXTURE_2D_ARRAY_EXT:
; 2127 : 			Con_Printf( "ARRAY " );

	push	OFFSET ??_C@_06FGDLGFNO@ARRAY?5@
	call	_Con_Printf
	add	esp, 4

; 2128 : 			break;

	jmp	SHORT $LN7@R_TextureL
$LN57@R_TextureL:

; 2129 : 		default:
; 2130 : 			Con_Printf( "????  " );

	push	OFFSET ??_C@_06OPGEOFKA@?$DP?$DP?$DP?$DP?5?5@
	call	_Con_Printf
	add	esp, 4
$LN7@R_TextureL:

; 2131 : 			break;
; 2132 : 		}
; 2133 : 
; 2134 : 		if( image->flags & TF_NORMALMAP )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 32768				; 00008000H
	je	SHORT $LN58@R_TextureL

; 2135 : 			Con_Printf( "normal  " );

	push	OFFSET ??_C@_08DDGKKKPC@normal?5?5@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN59@R_TextureL
$LN58@R_TextureL:

; 2136 : 		else Con_Printf( "diffuse " );

	push	OFFSET ??_C@_08HCDGFIFF@diffuse?5@
	call	_Con_Printf
	add	esp, 4
$LN59@R_TextureL:

; 2137 : 
; 2138 : 		switch( image->encode )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	DWORD PTR tv244[ebp], ecx
	mov	edx, DWORD PTR tv244[ebp]
	sub	edx, 6657				; 00001a01H
	mov	DWORD PTR tv244[ebp], edx
	cmp	DWORD PTR tv244[ebp], 8
	ja	SHORT $LN66@R_TextureL
	mov	eax, DWORD PTR tv244[ebp]
	jmp	DWORD PTR $LN85@R_TextureL[eax*4]
$LN60@R_TextureL:

; 2139 : 		{
; 2140 : 		case DXT_ENCODE_COLOR_YCoCg:
; 2141 : 			Con_Printf( "YCoCg     " );

	push	OFFSET ??_C@_0L@EDEJAPEP@YCoCg?5?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2142 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN61@R_TextureL:

; 2143 : 		case DXT_ENCODE_NORMAL_AG_ORTHO:
; 2144 : 			Con_Printf( "ortho     " );

	push	OFFSET ??_C@_0L@LNMBILNN@ortho?5?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2145 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN62@R_TextureL:

; 2146 : 		case DXT_ENCODE_NORMAL_AG_STEREO:
; 2147 : 			Con_Printf( "stereo    " );

	push	OFFSET ??_C@_0L@BIINDBLA@stereo?5?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2148 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN63@R_TextureL:

; 2149 : 		case DXT_ENCODE_NORMAL_AG_PARABOLOID:
; 2150 : 			Con_Printf( "parabolic " );

	push	OFFSET ??_C@_0L@LGBJKLIF@parabolic?5@
	call	_Con_Printf
	add	esp, 4

; 2151 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN64@R_TextureL:

; 2152 : 		case DXT_ENCODE_NORMAL_AG_QUARTIC:
; 2153 : 			Con_Printf( "quartic   " );

	push	OFFSET ??_C@_0L@PKGMOELN@quartic?5?5?5@
	call	_Con_Printf
	add	esp, 4

; 2154 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN65@R_TextureL:

; 2155 : 		case DXT_ENCODE_NORMAL_AG_AZIMUTHAL:
; 2156 : 			Con_Printf( "azimuthal " );

	push	OFFSET ??_C@_0L@IPBFJKHI@azimuthal?5@
	call	_Con_Printf
	add	esp, 4

; 2157 : 			break;

	jmp	SHORT $LN9@R_TextureL
$LN66@R_TextureL:

; 2158 : 		default:
; 2159 : 			Con_Printf( "default   " );

	push	OFFSET ??_C@_0L@LAEMIHEI@default?5?5?5@
	call	_Con_Printf
	add	esp, 4
$LN9@R_TextureL:

; 2160 : 			break;
; 2161 : 		}
; 2162 : 
; 2163 : 		if( image->flags & TF_CLAMP )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN67@R_TextureL

; 2164 : 			Con_Printf( "clamp  " );

	push	OFFSET ??_C@_07OMFDAMIC@clamp?5?5@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN70@R_TextureL
$LN67@R_TextureL:

; 2165 : 		else if( image->flags & TF_BORDER )

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN69@R_TextureL

; 2166 : 			Con_Printf( "border " );

	push	OFFSET ??_C@_07JBLMFJLG@border?5@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN70@R_TextureL
$LN69@R_TextureL:

; 2167 : 		else Con_Printf( "repeat " );

	push	OFFSET ??_C@_07LCDAFEIN@repeat?5@
	call	_Con_Printf
	add	esp, 4
$LN70@R_TextureL:

; 2168 : 		Con_Printf( "   %d  ", image->depth );

	mov	eax, DWORD PTR _image$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	push	OFFSET ??_C@_07LLBGNMAI@?5?5?5?$CFd?5?5@
	call	_Con_Printf
	add	esp, 8

; 2169 : 		Con_Printf( "  %s\n", image->name );

	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	push	OFFSET ??_C@_05LDOEBFOB@?5?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 2170 : 	}

	jmp	$LN2@R_TextureL
$LN3@R_TextureL:

; 2171 : 
; 2172 : 	Con_Printf( "---------------------------------------------------------\n" );

	push	OFFSET ??_C@_0DL@PHAADJIH@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
	call	_Con_Printf
	add	esp, 4

; 2173 : 	Con_Printf( "%i total textures\n", texCount );

	mov	eax, DWORD PTR _texCount$[ebp]
	push	eax
	push	OFFSET ??_C@_0BD@GMIIEODJ@?$CFi?5total?5textures?6@
	call	_Con_Printf
	add	esp, 8

; 2174 : 	Con_Printf( "%s total memory used\n", Q_memprint( bytes ));

	push	2
	cvtsi2ss xmm0, DWORD PTR _bytes$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BG@KLOGNFAM@?$CFs?5total?5memory?5used?6@
	call	_Con_Printf
	add	esp, 8

; 2175 : 	Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4

; 2176 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN80@R_TextureL:
	DD	$LN37@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN26@R_TextureL
	DD	$LN23@R_TextureL
	DD	$LN33@R_TextureL
	DD	$LN30@R_TextureL
$LN81@R_TextureL:
	DD	$LN32@R_TextureL
	DD	$LN33@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN29@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN30@R_TextureL
$LN83@R_TextureL:
	DD	$LN19@R_TextureL
	DD	$LN20@R_TextureL
	DD	$LN21@R_TextureL
	DD	$LN16@R_TextureL
	DD	$LN15@R_TextureL
	DD	$LN14@R_TextureL
	DD	$LN17@R_TextureL
	DD	$LN13@R_TextureL
	DD	$LN12@R_TextureL
	DD	$LN50@R_TextureL
$LN82@R_TextureL:
	DB	0
	DB	1
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	npad	2
$LN84@R_TextureL:
	DD	$LN43@R_TextureL
	DD	$LN48@R_TextureL
	DD	$LN46@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN50@R_TextureL
	DD	$LN40@R_TextureL
	DD	$LN42@R_TextureL
$LN85@R_TextureL:
	DD	$LN60@R_TextureL
	DD	$LN66@R_TextureL
	DD	$LN66@R_TextureL
	DD	$LN66@R_TextureL
	DD	$LN61@R_TextureL
	DD	$LN62@R_TextureL
	DD	$LN63@R_TextureL
	DD	$LN64@R_TextureL
	DD	$LN65@R_TextureL
_R_TextureList_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_InitDlightTexture
_TEXT	SEGMENT
_r_image$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_R_InitDlightTexture PROC				; COMDAT

; 1887 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1888 : 	rgbdata_t	r_image;
; 1889 : 
; 1890 : 	if( tr.dlightTexture != 0 )

	cmp	DWORD PTR _tr+1052, 0
	je	SHORT $LN2@R_InitDlig

; 1891 : 		return; // already initialized

	jmp	SHORT $LN1@R_InitDlig
$LN2@R_InitDlig:

; 1892 : 
; 1893 : 	memset( &r_image, 0, sizeof( r_image ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _r_image$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1894 : 	r_image.width = BLOCK_SIZE; 

	mov	ax, WORD PTR _tr+87580
	mov	WORD PTR _r_image$[ebp], ax

; 1895 : 	r_image.height = BLOCK_SIZE;

	mov	ax, WORD PTR _tr+87580
	mov	WORD PTR _r_image$[ebp+2], ax

; 1896 : 	r_image.flags = IMAGE_HAS_COLOR;

	mov	DWORD PTR _r_image$[ebp+12], 4

; 1897 : 	r_image.type = PF_RGBA_32;

	mov	DWORD PTR _r_image$[ebp+8], 3

; 1898 : 	r_image.size = r_image.width * r_image.height * 4;

	movzx	eax, WORD PTR _r_image$[ebp]
	movzx	ecx, WORD PTR _r_image$[ebp+2]
	imul	eax, ecx
	shl	eax, 2
	mov	DWORD PTR _r_image$[ebp+32], eax

; 1899 : 
; 1900 : 	tr.dlightTexture = GL_LoadTextureInternal( "*dlight", &r_image, TF_NOMIPMAP|TF_CLAMP|TF_ATLAS_PAGE );

	push	0
	push	2103296					; 00201800H
	lea	eax, DWORD PTR _r_image$[ebp]
	push	eax
	push	OFFSET ??_C@_07MNOAAFDD@?$CKdlight@
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tr+1052, eax
$LN1@R_InitDlig:

; 1901 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_R_InitDlightTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_FreeTexture
_TEXT	SEGMENT
_texnum$ = 8						; size = 4
_GL_FreeTexture PROC					; COMDAT

; 1785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1786 : 	// number 0 it's already freed
; 1787 : 	if( texnum <= 0 || !glw_state.initialized )

	cmp	DWORD PTR _texnum$[ebp], 0
	jbe	SHORT $LN3@GL_FreeTex
	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN2@GL_FreeTex
$LN3@GL_FreeTex:

; 1788 : 		return;

	jmp	SHORT $LN1@GL_FreeTex
$LN2@GL_FreeTex:

; 1789 : 
; 1790 : 	GL_DeleteTexture( &gl_textures[texnum] );

	imul	eax, DWORD PTR _texnum$[ebp], 320
	add	eax, OFFSET _gl_textures
	push	eax
	call	_GL_DeleteTexture
	add	esp, 4
$LN1@GL_FreeTex:

; 1791 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FreeTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_FindTexture
_TEXT	SEGMENT
_tex$ = -4						; size = 4
_name$ = 8						; size = 4
_GL_FindTexture PROC					; COMDAT

; 1751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1752 : 	gl_texture_t	*tex;
; 1753 : 
; 1754 : 	if( !GL_CheckTexName( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_CheckTexName
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_FindTex

; 1755 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_FindTex
$LN2@GL_FindTex:

; 1756 : 
; 1757 : 	// see if already loaded
; 1758 : 	if(( tex = GL_TextureForName( name )))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_TextureForName
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN3@GL_FindTex

; 1759 : 		return (tex - gl_textures);

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
	jmp	SHORT $LN1@GL_FindTex
$LN3@GL_FindTex:

; 1760 : 
; 1761 : 	return 0;

	xor	eax, eax
$LN1@GL_FindTex:

; 1762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FindTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_ApplyTextureParams
_TEXT	SEGMENT
tv70 = -88						; size = 4
_border$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_tex$ = 8						; size = 4
_GL_ApplyTextureParams PROC				; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 113  : 	vec4_t	border = { 0.0f, 0.0f, 0.0f, 1.0f };

	xorps	xmm0, xmm0
	movss	DWORD PTR _border$[ebp], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _border$[ebp+4], xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _border$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _border$[ebp+12], xmm0

; 114  : 
; 115  : 	Assert( tex != NULL );

	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN42@GL_ApplyTe
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN43@GL_ApplyTe
$LN42@GL_ApplyTe:
	mov	DWORD PTR tv70[ebp], 0
$LN43@GL_ApplyTe:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_ApplyTextureParams@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0M@CABCDANH@tex?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 116  : 
; 117  : 	// set texture filter
; 118  : 	if( FBitSet( tex->flags, TF_DEPTHMAP ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 128				; 00000080H
	je	$LN2@GL_ApplyTe

; 119  : 	{
; 120  : 		if( !FBitSet( tex->flags, TF_NOCOMPARE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN4@GL_ApplyTe

; 121  : 		{
; 122  : 			pglTexParameteri( tex->target, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE_ARB );

	push	34894					; 0000884eH
	push	34892					; 0000884cH
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 123  : 			pglTexParameteri( tex->target, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL );

	push	515					; 00000203H
	push	34893					; 0000884dH
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN4@GL_ApplyTe:

; 124  : 		}
; 125  : 
; 126  : 		if( FBitSet( tex->flags, TF_LUMINANCE ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 512				; 00000200H
	je	SHORT $LN5@GL_ApplyTe

; 127  : 			pglTexParameteri( tex->target, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE );

	push	6409					; 00001909H
	push	34891					; 0000884bH
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
	jmp	SHORT $LN6@GL_ApplyTe
$LN5@GL_ApplyTe:

; 128  : 		else pglTexParameteri( tex->target, GL_DEPTH_TEXTURE_MODE_ARB, GL_INTENSITY );

	push	32841					; 00008049H
	push	34891					; 0000884bH
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN6@GL_ApplyTe:

; 129  : 
; 130  : 		if( FBitSet( tex->flags, TF_NEAREST ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 1
	je	SHORT $LN7@GL_ApplyTe

; 131  : 		{
; 132  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 133  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 134  : 		}

	jmp	SHORT $LN8@GL_ApplyTe
$LN7@GL_ApplyTe:

; 135  : 		else
; 136  : 		{
; 137  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 138  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN8@GL_ApplyTe:

; 139  : 		}
; 140  : 
; 141  : 		// allow max anisotropy as 1.0f on depth textures
; 142  : 		if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@GL_ApplyTe

; 143  : 			pglTexParameterf( tex->target, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	34046					; 000084feH
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameterf
$LN9@GL_ApplyTe:

; 144  : 	}

	jmp	$LN20@GL_ApplyTe
$LN2@GL_ApplyTe:

; 145  : 	else if( FBitSet( tex->flags, TF_NOMIPMAP ) || tex->numMips <= 1 )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4096				; 00001000H
	jne	SHORT $LN12@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jg	$LN10@GL_ApplyTe
$LN12@GL_ApplyTe:

; 146  : 	{
; 147  : 		if( FBitSet( tex->flags, TF_NEAREST ) || ( IsLightMap( tex ) && gl_lightmap_nearest->value ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 1
	jne	SHORT $LN15@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 2097152				; 00200000H
	je	SHORT $LN13@GL_ApplyTe
	mov	eax, DWORD PTR _gl_lightmap_nearest
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@GL_ApplyTe
$LN15@GL_ApplyTe:

; 148  : 		{
; 149  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 150  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 151  : 		}

	jmp	SHORT $LN14@GL_ApplyTe
$LN13@GL_ApplyTe:

; 152  : 		else
; 153  : 		{
; 154  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 155  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN14@GL_ApplyTe:

; 156  : 		}
; 157  : 	}

	jmp	$LN20@GL_ApplyTe
$LN10@GL_ApplyTe:

; 158  : 	else
; 159  : 	{
; 160  : 		if( FBitSet( tex->flags, TF_NEAREST ) || gl_texture_nearest->value )

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 1
	jne	SHORT $LN18@GL_ApplyTe
	mov	eax, DWORD PTR _gl_texture_nearest
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@GL_ApplyTe
$LN18@GL_ApplyTe:

; 161  : 		{
; 162  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST );

	push	9984					; 00002700H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 163  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

	push	9728					; 00002600H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 164  : 		}

	jmp	SHORT $LN17@GL_ApplyTe
$LN16@GL_ApplyTe:

; 165  : 		else
; 166  : 		{
; 167  : 			pglTexParameteri( tex->target, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );

	push	9987					; 00002703H
	push	10241					; 00002801H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 168  : 			pglTexParameteri( tex->target, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	push	9729					; 00002601H
	push	10240					; 00002800H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN17@GL_ApplyTe:

; 169  : 		}
; 170  : 
; 171  : 		// set texture anisotropy if available
; 172  : 		if( GL_Support( GL_ANISOTROPY_EXT ) && ( tex->numMips > 1 ) && !FBitSet( tex->flags, TF_ALPHACONTRAST ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jle	SHORT $LN19@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 4194304				; 00400000H
	jne	SHORT $LN19@GL_ApplyTe

; 173  : 			pglTexParameterf( tex->target, GL_TEXTURE_MAX_ANISOTROPY_EXT, gl_texture_anisotropy->value );

	mov	eax, DWORD PTR _gl_texture_anisotropy
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	push	34046					; 000084feH
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexParameterf
$LN19@GL_ApplyTe:

; 174  : 
; 175  : 		// set texture LOD bias if available
; 176  : 		if( GL_Support( GL_TEXTURE_LOD_BIAS ) && ( tex->numMips > 1 ))

	push	7
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jle	SHORT $LN20@GL_ApplyTe

; 177  : 			pglTexParameterf( tex->target, GL_TEXTURE_LOD_BIAS_EXT, gl_texture_lodbias->value );

	mov	eax, DWORD PTR _gl_texture_lodbias
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	push	34049					; 00008501H
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexParameterf
$LN20@GL_ApplyTe:

; 178  : 	}
; 179  : 
; 180  : 	// check if border is not supported
; 181  : 	if( FBitSet( tex->flags, TF_BORDER ) && !GL_Support( GL_CLAMP_TEXBORDER_EXT ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN21@GL_ApplyTe
	push	15					; 0000000fH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@GL_ApplyTe

; 182  : 	{
; 183  : 		ClearBits( tex->flags, TF_BORDER );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, -524289				; fff7ffffH
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx

; 184  : 		SetBits( tex->flags, TF_CLAMP );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN21@GL_ApplyTe:

; 185  : 	}
; 186  : 
; 187  : 	// only seamless cubemaps allows wrap 'clamp_to_border"
; 188  : 	if( tex->target == GL_TEXTURE_CUBE_MAP_ARB && !GL_Support( GL_ARB_SEAMLESS_CUBEMAP ) && FBitSet( tex->flags, TF_BORDER ))

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN22@GL_ApplyTe
	push	18					; 00000012H
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 524288				; 00080000H
	je	SHORT $LN22@GL_ApplyTe

; 189  : 		ClearBits( tex->flags, TF_BORDER );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, -524289				; fff7ffffH
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN22@GL_ApplyTe:

; 190  : 
; 191  : 	// set texture wrap
; 192  : 	if( FBitSet( tex->flags, TF_BORDER ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 524288				; 00080000H
	je	$LN23@GL_ApplyTe

; 193  : 	{
; 194  : 		pglTexParameteri( tex->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER );

	push	33069					; 0000812dH
	push	10242					; 00002802H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 195  : 
; 196  : 		if( tex->target != GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	je	SHORT $LN25@GL_ApplyTe

; 197  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER );

	push	33069					; 0000812dH
	push	10243					; 00002803H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN25@GL_ApplyTe:

; 198  : 
; 199  : 		if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN27@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN26@GL_ApplyTe
$LN27@GL_ApplyTe:

; 200  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER );

	push	33069					; 0000812dH
	push	32882					; 00008072H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN26@GL_ApplyTe:

; 201  : 
; 202  : 		pglTexParameterfv( tex->target, GL_TEXTURE_BORDER_COLOR, border );

	lea	eax, DWORD PTR _border$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	DWORD PTR _pglTexParameterfv

; 203  : 	}

	jmp	$LN39@GL_ApplyTe
$LN23@GL_ApplyTe:

; 204  : 	else if( FBitSet( tex->flags, TF_CLAMP ))

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 2048				; 00000800H
	je	$LN28@GL_ApplyTe

; 205  : 	{
; 206  : 		if( GL_Support( GL_CLAMPTOEDGE_EXT ))

	push	13					; 0000000dH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN30@GL_ApplyTe

; 207  : 		{
; 208  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );

	push	33071					; 0000812fH
	push	10242					; 00002802H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 209  : 
; 210  : 			if( tex->target != GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	je	SHORT $LN32@GL_ApplyTe

; 211  : 				pglTexParameteri( tex->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );

	push	33071					; 0000812fH
	push	10243					; 00002803H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN32@GL_ApplyTe:

; 212  : 
; 213  : 			if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN34@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN33@GL_ApplyTe
$LN34@GL_ApplyTe:

; 214  : 				pglTexParameteri( tex->target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE );

	push	33071					; 0000812fH
	push	32882					; 00008072H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN33@GL_ApplyTe:

; 215  : 		}

	jmp	SHORT $LN36@GL_ApplyTe
$LN30@GL_ApplyTe:

; 216  : 		else
; 217  : 		{
; 218  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_S, GL_CLAMP );

	push	10496					; 00002900H
	push	10242					; 00002802H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 219  : 
; 220  : 			if( tex->target != GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	je	SHORT $LN35@GL_ApplyTe

; 221  : 				pglTexParameteri( tex->target, GL_TEXTURE_WRAP_T, GL_CLAMP );

	push	10496					; 00002900H
	push	10243					; 00002803H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN35@GL_ApplyTe:

; 222  : 
; 223  : 			if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN37@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN36@GL_ApplyTe
$LN37@GL_ApplyTe:

; 224  : 				pglTexParameteri( tex->target, GL_TEXTURE_WRAP_R, GL_CLAMP );

	push	10496					; 00002900H
	push	32882					; 00008072H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN36@GL_ApplyTe:

; 225  : 		}
; 226  : 	}

	jmp	SHORT $LN39@GL_ApplyTe
$LN28@GL_ApplyTe:

; 227  : 	else
; 228  : 	{
; 229  : 		pglTexParameteri( tex->target, GL_TEXTURE_WRAP_S, GL_REPEAT );

	push	10497					; 00002901H
	push	10242					; 00002802H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri

; 230  : 
; 231  : 		if( tex->target != GL_TEXTURE_1D )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 3552		; 00000de0H
	je	SHORT $LN38@GL_ApplyTe

; 232  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_T, GL_REPEAT );

	push	10497					; 00002901H
	push	10243					; 00002803H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN38@GL_ApplyTe:

; 233  : 
; 234  : 		if( tex->target == GL_TEXTURE_3D || tex->target == GL_TEXTURE_CUBE_MAP_ARB )

	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 32879		; 0000806fH
	je	SHORT $LN40@GL_ApplyTe
	mov	eax, DWORD PTR _tex$[ebp]
	cmp	DWORD PTR [eax+268], 34067		; 00008513H
	jne	SHORT $LN39@GL_ApplyTe
$LN40@GL_ApplyTe:

; 235  : 			pglTexParameteri( tex->target, GL_TEXTURE_WRAP_R, GL_REPEAT );

	push	10497					; 00002901H
	push	32882					; 00008072H
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	DWORD PTR _pglTexParameteri
$LN39@GL_ApplyTe:

; 236  : 	}
; 237  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ApplyTextureParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_UpdateTexSize
_TEXT	SEGMENT
tv134 = -88						; size = 4
tv94 = -88						; size = 4
tv85 = -88						; size = 4
tv71 = -88						; size = 4
_tex$ = -20						; size = 4
_numSides$ = -16					; size = 4
_texsize$ = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_texnum$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_GL_UpdateTexSize PROC					; COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1401 : 	int		i, j, texsize;
; 1402 : 	int		numSides;
; 1403 : 	gl_texture_t	*tex;
; 1404 : 
; 1405 : 	if( texnum <= 0 || texnum >= MAX_TEXTURES )

	cmp	DWORD PTR _texnum$[ebp], 0
	jle	SHORT $LN9@GL_UpdateT
	cmp	DWORD PTR _texnum$[ebp], 4096		; 00001000H
	jl	SHORT $LN8@GL_UpdateT
$LN9@GL_UpdateT:

; 1406 : 		return;

	jmp	$LN1@GL_UpdateT
$LN8@GL_UpdateT:

; 1407 : 
; 1408 : 	tex = &gl_textures[texnum];

	imul	eax, DWORD PTR _texnum$[ebp], 320
	add	eax, OFFSET _gl_textures
	mov	DWORD PTR _tex$[ebp], eax

; 1409 : 	numSides = FBitSet( tex->flags, TF_CUBEMAP ) ? 6 : 1;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	and	ecx, 64					; 00000040H
	je	SHORT $LN11@GL_UpdateT
	mov	DWORD PTR tv71[ebp], 6
	jmp	SHORT $LN12@GL_UpdateT
$LN11@GL_UpdateT:
	mov	DWORD PTR tv71[ebp], 1
$LN12@GL_UpdateT:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _numSides$[ebp], edx

; 1410 : 	GL_SetTextureDimensions( tex, width, height, depth );

	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_SetTextureDimensions
	add	esp, 16					; 00000010H

; 1411 : 	tex->size = 0; // recompute now

	mov	eax, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [eax+296], 0

; 1412 : 
; 1413 : 	for( i = 0; i < numSides; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_UpdateT
$LN2@GL_UpdateT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_UpdateT:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numSides$[ebp]
	jge	$LN1@GL_UpdateT

; 1414 : 	{
; 1415 : 		for( j = 0; j < Q_max( 1, tex->numMips ); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@GL_UpdateT
$LN5@GL_UpdateT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@GL_UpdateT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, BYTE PTR [eax+266]
	cmp	ecx, 1
	jge	SHORT $LN13@GL_UpdateT
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN14@GL_UpdateT
$LN13@GL_UpdateT:
	mov	edx, DWORD PTR _tex$[ebp]
	movzx	eax, BYTE PTR [edx+266]
	mov	DWORD PTR tv85[ebp], eax
$LN14@GL_UpdateT:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR tv85[ebp]
	jge	$LN6@GL_UpdateT

; 1416 : 		{
; 1417 : 			width = Q_max( 1, ( tex->width >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN15@GL_UpdateT
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN16@GL_UpdateT
$LN15@GL_UpdateT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+260]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv94[ebp], edx
$LN16@GL_UpdateT:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR _width$[ebp], eax

; 1418 : 			height = Q_max( 1, ( tex->height >> j ));

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN17@GL_UpdateT
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN18@GL_UpdateT
$LN17@GL_UpdateT:
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	edx, WORD PTR [eax+262]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv134[ebp], edx
$LN18@GL_UpdateT:
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR _height$[ebp], eax

; 1419 : 			texsize = GL_CalcTextureSize( tex->format, width, height, tex->depth );

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	edx, DWORD PTR [ecx+276]
	push	edx
	call	_GL_CalcTextureSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _texsize$[ebp], eax

; 1420 : 			tex->size += texsize;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+296]
	add	ecx, DWORD PTR _texsize$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+296], ecx

; 1421 : 		}

	jmp	$LN5@GL_UpdateT
$LN6@GL_UpdateT:

; 1422 : 	}

	jmp	$LN2@GL_UpdateT
$LN1@GL_UpdateT:

; 1423 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_UpdateTexSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_ProcessTexture
_TEXT	SEGMENT
_flags$ = -12						; size = 4
_pic$ = -8						; size = 4
_image$ = -4						; size = 4
_texnum$ = 8						; size = 4
_gamma$ = 12						; size = 4
_topColor$ = 16						; size = 4
_bottomColor$ = 20					; size = 4
_GL_ProcessTexture PROC					; COMDAT

; 1799 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1800 : 	gl_texture_t	*image;
; 1801 : 	rgbdata_t		*pic;
; 1802 : 	int		flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1803 : 
; 1804 : 	if( texnum <= 0 || texnum >= MAX_TEXTURES )

	cmp	DWORD PTR _texnum$[ebp], 0
	jle	SHORT $LN3@GL_Process
	cmp	DWORD PTR _texnum$[ebp], 4096		; 00001000H
	jl	SHORT $LN2@GL_Process
$LN3@GL_Process:

; 1805 : 		return; // missed image

	jmp	$LN1@GL_Process
$LN2@GL_Process:

; 1806 : 	image = &gl_textures[texnum];

	imul	eax, DWORD PTR _texnum$[ebp], 320
	add	eax, OFFSET _gl_textures
	mov	DWORD PTR _image$[ebp], eax

; 1807 : 
; 1808 : 	// select mode
; 1809 : 	if( gamma != -1.0f )

	movss	xmm0, DWORD PTR _gamma$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@GL_Process

; 1810 : 	{
; 1811 : 		flags = IMAGE_LIGHTGAMMA;

	mov	DWORD PTR _flags$[ebp], 67108864	; 04000000H

; 1812 : 	}

	jmp	SHORT $LN7@GL_Process
$LN4@GL_Process:

; 1813 : 	else if( topColor != -1 && bottomColor != -1 )

	cmp	DWORD PTR _topColor$[ebp], -1
	je	SHORT $LN6@GL_Process
	cmp	DWORD PTR _bottomColor$[ebp], -1
	je	SHORT $LN6@GL_Process

; 1814 : 	{
; 1815 : 		flags = IMAGE_REMAP;

	mov	DWORD PTR _flags$[ebp], 134217728	; 08000000H

; 1816 : 	}

	jmp	SHORT $LN7@GL_Process
$LN6@GL_Process:

; 1817 : 	else
; 1818 : 	{
; 1819 : 		Con_Printf( S_ERROR "GL_ProcessTexture: bad operation for %s\n", image->name );

	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@DAELPBJM@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5b@
	call	_Con_Printf
	add	esp, 8

; 1820 : 		return;

	jmp	$LN1@GL_Process
$LN7@GL_Process:

; 1821 : 	}
; 1822 : 
; 1823 : 	if( !image->original )

	mov	eax, DWORD PTR _image$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	SHORT $LN8@GL_Process

; 1824 : 	{
; 1825 : 		Con_Printf( S_ERROR "GL_ProcessTexture: no input data for %s\n", image->name );

	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@NHNGPALK@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5n@
	call	_Con_Printf
	add	esp, 8

; 1826 : 		return;

	jmp	$LN1@GL_Process
$LN8@GL_Process:

; 1827 : 	}
; 1828 : 
; 1829 : 	if( ImageDXT( image->original->type ))

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	cmp	DWORD PTR [ecx+8], 7
	je	SHORT $LN10@GL_Process
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	cmp	DWORD PTR [ecx+8], 8
	je	SHORT $LN10@GL_Process
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	cmp	DWORD PTR [ecx+8], 9
	je	SHORT $LN10@GL_Process
	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	cmp	DWORD PTR [ecx+8], 10			; 0000000aH
	jne	SHORT $LN9@GL_Process
$LN10@GL_Process:

; 1830 : 	{
; 1831 : 		Con_Printf( S_ERROR "GL_ProcessTexture: can't process compressed texture %s\n", image->name );

	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@IPLDKKAL@?$FO1Error?3?$FO7?5GL_ProcessTexture?3?5c@
	call	_Con_Printf
	add	esp, 8

; 1832 : 		return;

	jmp	SHORT $LN1@GL_Process
$LN9@GL_Process:

; 1833 : 	}
; 1834 : 
; 1835 : 	// all the operations makes over the image copy not an original
; 1836 : 	pic = FS_CopyImage( image->original );

	mov	eax, DWORD PTR _image$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	call	_FS_CopyImage
	add	esp, 4
	mov	DWORD PTR _pic$[ebp], eax

; 1837 : 	Image_Process( &pic, topColor, bottomColor, flags, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bottomColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _topColor$[ebp]
	push	edx
	lea	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_Image_Process
	add	esp, 20					; 00000014H

; 1838 : 
; 1839 : 	GL_UploadTexture( image, pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _image$[ebp]
	push	ecx
	call	_GL_UploadTexture
	add	esp, 8

; 1840 : 	GL_ApplyTextureParams( image ); // update texture filter, wrap etc

	mov	eax, DWORD PTR _image$[ebp]
	push	eax
	call	_GL_ApplyTextureParams
	add	esp, 4

; 1841 : 
; 1842 : 	FS_FreeImage( pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4
$LN1@GL_Process:

; 1843 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ProcessTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CreateTextureArray
_TEXT	SEGMENT
tv74 = -108						; size = 4
tv71 = -108						; size = 4
tv68 = -108						; size = 4
_r_empty$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_depth$ = 20						; size = 4
_buffer$ = 24						; size = 4
_flags$ = 28						; size = 4
_GL_CreateTextureArray PROC				; COMDAT

; 1709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1710 : 	rgbdata_t	r_empty;
; 1711 : 
; 1712 : 	memset( &r_empty, 0, sizeof( r_empty ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _r_empty$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1713 : 	r_empty.width = Q_max( width, 1 );

	cmp	DWORD PTR _width$[ebp], 1
	jle	SHORT $LN9@GL_CreateT
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN10@GL_CreateT
$LN9@GL_CreateT:
	mov	DWORD PTR tv68[ebp], 1
$LN10@GL_CreateT:
	mov	cx, WORD PTR tv68[ebp]
	mov	WORD PTR _r_empty$[ebp], cx

; 1714 : 	r_empty.height = Q_max( height, 1 );

	cmp	DWORD PTR _height$[ebp], 1
	jle	SHORT $LN11@GL_CreateT
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN12@GL_CreateT
$LN11@GL_CreateT:
	mov	DWORD PTR tv71[ebp], 1
$LN12@GL_CreateT:
	mov	cx, WORD PTR tv71[ebp]
	mov	WORD PTR _r_empty$[ebp+2], cx

; 1715 : 	r_empty.depth = Q_max( depth, 1 );

	cmp	DWORD PTR _depth$[ebp], 1
	jle	SHORT $LN13@GL_CreateT
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN14@GL_CreateT
$LN13@GL_CreateT:
	mov	DWORD PTR tv74[ebp], 1
$LN14@GL_CreateT:
	mov	cx, WORD PTR tv74[ebp]
	mov	WORD PTR _r_empty$[ebp+4], cx

; 1716 : 	r_empty.type = PF_RGBA_32;

	mov	DWORD PTR _r_empty$[ebp+8], 3

; 1717 : 	r_empty.size = r_empty.width * r_empty.height * r_empty.depth * 4;

	movzx	eax, WORD PTR _r_empty$[ebp]
	movzx	ecx, WORD PTR _r_empty$[ebp+2]
	imul	eax, ecx
	movzx	edx, WORD PTR _r_empty$[ebp+4]
	imul	eax, edx
	shl	eax, 2
	mov	DWORD PTR _r_empty$[ebp+32], eax

; 1718 : 	r_empty.buffer = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _r_empty$[ebp+24], eax

; 1719 : 
; 1720 : 	// clear invalid combinations
; 1721 : 	ClearBits( flags, TF_CUBEMAP|TF_SKYSIDE|TF_HAS_LUMA|TF_MAKELUMA|TF_ALPHACONTRAST );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -4219969				; ffbf9bbfH
	mov	DWORD PTR _flags$[ebp], eax

; 1722 : 
; 1723 : 	// if image not luminance it will have color
; 1724 : 	if( !FBitSet( flags, TF_LUMINANCE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 512				; 00000200H
	jne	SHORT $LN2@GL_CreateT

; 1725 : 		SetBits( r_empty.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 4
	mov	DWORD PTR _r_empty$[ebp+12], eax
$LN2@GL_CreateT:

; 1726 : 
; 1727 : 	if( FBitSet( flags, TF_HAS_ALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN3@GL_CreateT

; 1728 : 		SetBits( r_empty.flags, IMAGE_HAS_ALPHA );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 2
	mov	DWORD PTR _r_empty$[ebp+12], eax
$LN3@GL_CreateT:

; 1729 : 
; 1730 : 	if( FBitSet( flags, TF_TEXTURE_3D ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN4@GL_CreateT

; 1731 : 	{
; 1732 : 		if( !GL_Support( GL_TEXTURE_3D_EXT ))

	push	12					; 0000000cH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@GL_CreateT

; 1733 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_CreateT
$LN6@GL_CreateT:

; 1734 : 	}

	jmp	SHORT $LN5@GL_CreateT
$LN4@GL_CreateT:

; 1735 : 	else
; 1736 : 	{
; 1737 : 		if( !GL_Support( GL_TEXTURE_ARRAY_EXT ))

	push	11					; 0000000bH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@GL_CreateT

; 1738 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_CreateT
$LN7@GL_CreateT:

; 1739 : 		SetBits( r_empty.flags, IMAGE_MULTILAYER );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 256				; 00000100H
	mov	DWORD PTR _r_empty$[ebp+12], eax
$LN5@GL_CreateT:

; 1740 : 	}
; 1741 : 
; 1742 : 	return GL_LoadTextureInternal( name, &r_empty, flags );

	push	0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r_empty$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
$LN1@GL_CreateT:

; 1743 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateTextureArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_CreateTexture
_TEXT	SEGMENT
_r_empty$ = -44						; size = 36
_datasize$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_buffer$ = 20						; size = 4
_flags$ = 24						; size = 4
_GL_CreateTexture PROC					; COMDAT

; 1664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1665 : 	int	datasize = 1;

	mov	DWORD PTR _datasize$[ebp], 1

; 1666 : 	rgbdata_t	r_empty;
; 1667 : 
; 1668 : 	if( FBitSet( flags, TF_ARB_16BIT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN2@GL_CreateT

; 1669 : 		datasize = 2;

	mov	DWORD PTR _datasize$[ebp], 2
	jmp	SHORT $LN3@GL_CreateT
$LN2@GL_CreateT:

; 1670 : 	else if( FBitSet( flags, TF_ARB_FLOAT ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN3@GL_CreateT

; 1671 : 		datasize = 4;

	mov	DWORD PTR _datasize$[ebp], 4
$LN3@GL_CreateT:

; 1672 : 
; 1673 : 	memset( &r_empty, 0, sizeof( r_empty ));

	push	36					; 00000024H
	push	0
	lea	eax, DWORD PTR _r_empty$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1674 : 	r_empty.width = width;

	mov	ax, WORD PTR _width$[ebp]
	mov	WORD PTR _r_empty$[ebp], ax

; 1675 : 	r_empty.height = height;

	mov	ax, WORD PTR _height$[ebp]
	mov	WORD PTR _r_empty$[ebp+2], ax

; 1676 : 	r_empty.type = PF_RGBA_32;

	mov	DWORD PTR _r_empty$[ebp+8], 3

; 1677 : 	r_empty.size = r_empty.width * r_empty.height * datasize * 4;

	movzx	eax, WORD PTR _r_empty$[ebp]
	movzx	ecx, WORD PTR _r_empty$[ebp+2]
	imul	eax, ecx
	imul	eax, DWORD PTR _datasize$[ebp]
	shl	eax, 2
	mov	DWORD PTR _r_empty$[ebp+32], eax

; 1678 : 	r_empty.buffer = (byte *)buffer;

	mov	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _r_empty$[ebp+24], eax

; 1679 : 
; 1680 : 	// clear invalid combinations
; 1681 : 	ClearBits( flags, TF_TEXTURE_3D );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -1048577				; ffefffffH
	mov	DWORD PTR _flags$[ebp], eax

; 1682 : 
; 1683 : 	// if image not luminance and not alphacontrast it will have color
; 1684 : 	if( !FBitSet( flags, TF_LUMINANCE ) && !FBitSet( flags, TF_ALPHACONTRAST ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 512				; 00000200H
	jne	SHORT $LN5@GL_CreateT
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4194304				; 00400000H
	jne	SHORT $LN5@GL_CreateT

; 1685 : 		SetBits( r_empty.flags, IMAGE_HAS_COLOR );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 4
	mov	DWORD PTR _r_empty$[ebp+12], eax
$LN5@GL_CreateT:

; 1686 : 
; 1687 : 	if( FBitSet( flags, TF_HAS_ALPHA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN6@GL_CreateT

; 1688 : 		SetBits( r_empty.flags, IMAGE_HAS_ALPHA );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 2
	mov	DWORD PTR _r_empty$[ebp+12], eax
$LN6@GL_CreateT:

; 1689 : 
; 1690 : 	if( FBitSet( flags, TF_CUBEMAP ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN7@GL_CreateT

; 1691 : 	{
; 1692 : 		if( !GL_Support( GL_TEXTURE_CUBEMAP_EXT ))

	push	5
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@GL_CreateT

; 1693 : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_CreateT
$LN8@GL_CreateT:

; 1694 : 		SetBits( r_empty.flags, IMAGE_CUBEMAP );

	mov	eax, DWORD PTR _r_empty$[ebp+12]
	or	eax, 1
	mov	DWORD PTR _r_empty$[ebp+12], eax

; 1695 : 		r_empty.size *= 6;

	imul	eax, DWORD PTR _r_empty$[ebp+32], 6
	mov	DWORD PTR _r_empty$[ebp+32], eax
$LN7@GL_CreateT:

; 1696 : 	}
; 1697 : 
; 1698 : 	return GL_LoadTextureInternal( name, &r_empty, flags );

	push	0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r_empty$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_GL_LoadTextureFromBuffer
	add	esp, 16					; 00000010H
$LN1@GL_CreateT:

; 1699 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_CreateTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_ResampleTexture
_TEXT	SEGMENT
tv539 = -33352						; size = 4
_y$ = -32836						; size = 4
_x$ = -32832						; size = 4
_i$ = -32828						; size = 4
_normal$ = -32824					; size = 12
_inRow2$ = -32812					; size = 4
_inRow1$ = -32808					; size = 4
_out$ = -32804						; size = 4
_pix4$ = -32800						; size = 4
_pix3$ = -32796						; size = 4
_pix2$ = -32792						; size = 4
_pix1$ = -32788						; size = 4
_p2$ = -32784						; size = 16384
_p1$ = -16400						; size = 16384
_in$ = -16						; size = 4
_fracStep$ = -12					; size = 4
_frac$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
_inWidth$ = 12						; size = 4
_inHeight$ = 16						; size = 4
_outWidth$ = 20						; size = 4
_outHeight$ = 24					; size = 4
_isNormalMap$ = 28					; size = 4
_GL_ResampleTexture PROC				; COMDAT

; 739  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 33352				; 00008248H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 740  : 	uint		frac, fracStep;
; 741  : 	uint		*in = (uint *)source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _in$[ebp], eax

; 742  : 	uint		p1[0x1000], p2[0x1000];
; 743  : 	byte		*pix1, *pix2, *pix3, *pix4;
; 744  : 	uint		*out, *inRow1, *inRow2;
; 745  : 	static byte	*scaledImage = NULL;	// pointer to a scaled image
; 746  : 	vec3_t		normal;
; 747  : 	int		i, x, y;
; 748  : 
; 749  : 	if( !source ) return NULL;

	cmp	DWORD PTR _source$[ebp], 0
	jne	SHORT $LN20@GL_Resampl
	xor	eax, eax
	jmp	$LN1@GL_Resampl
$LN20@GL_Resampl:

; 750  : 
; 751  : 	scaledImage = Mem_Realloc( r_temppool, scaledImage, outWidth * outHeight * 4 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_ResampleTexture@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _outWidth$[ebp]
	imul	ecx, DWORD PTR _outHeight$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR ?scaledImage@?1??GL_ResampleTexture@@9@9
	push	edx
	mov	eax, DWORD PTR _r_temppool
	push	eax
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	DWORD PTR ?scaledImage@?1??GL_ResampleTexture@@9@9, eax

; 752  : 	fracStep = inWidth * 0x10000 / outWidth;

	mov	eax, DWORD PTR _inWidth$[ebp]
	shl	eax, 16					; 00000010H
	cdq
	idiv	DWORD PTR _outWidth$[ebp]
	mov	DWORD PTR _fracStep$[ebp], eax

; 753  : 	out = (uint *)scaledImage;

	mov	eax, DWORD PTR ?scaledImage@?1??GL_ResampleTexture@@9@9
	mov	DWORD PTR _out$[ebp], eax

; 754  : 
; 755  : 	frac = fracStep >> 2;

	mov	eax, DWORD PTR _fracStep$[ebp]
	shr	eax, 2
	mov	DWORD PTR _frac$[ebp], eax

; 756  : 	for( i = 0; i < outWidth; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_Resampl
$LN2@GL_Resampl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_Resampl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outWidth$[ebp]
	jge	SHORT $LN3@GL_Resampl

; 757  : 	{
; 758  : 		p1[i] = 4 * (frac >> 16);

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	shl	eax, 2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _p1$[ebp+ecx*4], eax

; 759  : 		frac += fracStep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracStep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 760  : 	}

	jmp	SHORT $LN2@GL_Resampl
$LN3@GL_Resampl:

; 761  : 
; 762  : 	frac = (fracStep >> 2) * 3;

	mov	eax, DWORD PTR _fracStep$[ebp]
	shr	eax, 2
	imul	ecx, eax, 3
	mov	DWORD PTR _frac$[ebp], ecx

; 763  : 	for( i = 0; i < outWidth; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GL_Resampl
$LN5@GL_Resampl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GL_Resampl:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _outWidth$[ebp]
	jge	SHORT $LN6@GL_Resampl

; 764  : 	{
; 765  : 		p2[i] = 4 * (frac >> 16);

	mov	eax, DWORD PTR _frac$[ebp]
	shr	eax, 16					; 00000010H
	shl	eax, 2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _p2$[ebp+ecx*4], eax

; 766  : 		frac += fracStep;

	mov	eax, DWORD PTR _frac$[ebp]
	add	eax, DWORD PTR _fracStep$[ebp]
	mov	DWORD PTR _frac$[ebp], eax

; 767  : 	}

	jmp	SHORT $LN5@GL_Resampl
$LN6@GL_Resampl:

; 768  : 
; 769  : 	if( isNormalMap )

	cmp	DWORD PTR _isNormalMap$[ebp], 0
	je	$LN21@GL_Resampl

; 770  : 	{
; 771  : 		for( y = 0; y < outHeight; y++, out += outWidth )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN10@GL_Resampl
$LN8@GL_Resampl:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _outWidth$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _out$[ebp], eax
$LN10@GL_Resampl:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _outHeight$[ebp]
	jge	$LN9@GL_Resampl

; 772  : 		{
; 773  : 			inRow1 = in + inWidth * (int)(((float)y + 0.25f) * inHeight / outHeight);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR __real@3e800000
	cvtsi2ss xmm1, DWORD PTR _inHeight$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _outHeight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	imul	eax, DWORD PTR _inWidth$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inRow1$[ebp], edx

; 774  : 			inRow2 = in + inWidth * (int)(((float)y + 0.75f) * inHeight / outHeight);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR __real@3f400000
	cvtsi2ss xmm1, DWORD PTR _inHeight$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _outHeight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	imul	eax, DWORD PTR _inWidth$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inRow2$[ebp], edx

; 775  : 
; 776  : 			for( x = 0; x < outWidth; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN13@GL_Resampl
$LN11@GL_Resampl:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN13@GL_Resampl:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _outWidth$[ebp]
	jge	$LN12@GL_Resampl

; 777  : 			{
; 778  : 				pix1 = (byte *)inRow1 + p1[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow1$[ebp]
	add	ecx, DWORD PTR _p1$[ebp+eax*4]
	mov	DWORD PTR _pix1$[ebp], ecx

; 779  : 				pix2 = (byte *)inRow1 + p2[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow1$[ebp]
	add	ecx, DWORD PTR _p2$[ebp+eax*4]
	mov	DWORD PTR _pix2$[ebp], ecx

; 780  : 				pix3 = (byte *)inRow2 + p1[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow2$[ebp]
	add	ecx, DWORD PTR _p1$[ebp+eax*4]
	mov	DWORD PTR _pix3$[ebp], ecx

; 781  : 				pix4 = (byte *)inRow2 + p2[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow2$[ebp]
	add	ecx, DWORD PTR _p2$[ebp+eax*4]
	mov	DWORD PTR _pix4$[ebp], ecx

; 782  : 
; 783  : 				normal[0] = MAKE_SIGNED( pix1[0] ) + MAKE_SIGNED( pix2[0] ) + MAKE_SIGNED( pix3[0] ) + MAKE_SIGNED( pix4[0] );

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pix1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pix2$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pix3$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pix4$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cvtsi2ss xmm1, eax
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	ecx, 4
	imul	edx, ecx, 0
	movss	DWORD PTR _normal$[ebp+edx], xmm0

; 784  : 				normal[1] = MAKE_SIGNED( pix1[1] ) + MAKE_SIGNED( pix2[1] ) + MAKE_SIGNED( pix3[1] ) + MAKE_SIGNED( pix4[1] );

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix3$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	movss	DWORD PTR _normal$[ebp+eax], xmm0

; 785  : 				normal[2] = MAKE_SIGNED( pix1[2] ) + MAKE_SIGNED( pix2[2] ) + MAKE_SIGNED( pix3[2] ) + MAKE_SIGNED( pix4[2] );

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR __real@3c010204
	subss	xmm0, DWORD PTR __real@3f800000
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix3$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cvtsi2ss xmm1, edx
	mulss	xmm1, DWORD PTR __real@3c010204
	subss	xmm1, DWORD PTR __real@3f800000
	addss	xmm0, xmm1
	mov	eax, 4
	shl	eax, 1
	movss	DWORD PTR _normal$[ebp+eax], xmm0

; 786  : 
; 787  : 				if( !VectorNormalizeLength( normal ))

	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	call	_VectorNormalizeLength2
	add	esp, 8
	fstp	DWORD PTR tv539[ebp]
	movss	xmm0, DWORD PTR tv539[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@GL_Resampl

; 788  : 					VectorSet( normal, 0.5f, 0.5f, 1.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _normal$[ebp+ecx], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _normal$[ebp+edx], xmm0
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _normal$[ebp+eax], xmm0
$LN23@GL_Resampl:

; 789  : 
; 790  : 				((byte *)(out+x))[0] = 128 + (byte)(127.0f * normal[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+ecx]
	cvttss2si edx, xmm0
	movzx	eax, dl
	add	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	imul	edx, edx, 0
	mov	BYTE PTR [ecx+edx], al

; 791  : 				((byte *)(out+x))[1] = 128 + (byte)(127.0f * normal[1]);

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	cvttss2si ecx, xmm0
	movzx	edx, cl
	add	edx, 128				; 00000080H
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, 1
	shl	ecx, 0
	mov	BYTE PTR [eax+ecx], dl

; 792  : 				((byte *)(out+x))[2] = 128 + (byte)(127.0f * normal[2]);

	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR __real@42fe0000
	mulss	xmm0, DWORD PTR _normal$[ebp+eax]
	cvttss2si ecx, xmm0
	movzx	edx, cl
	add	edx, 128				; 00000080H
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR [eax+ecx], dl

; 793  : 				((byte *)(out+x))[3] = 255;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR [edx+ecx], 255			; 000000ffH

; 794  : 			}

	jmp	$LN11@GL_Resampl
$LN12@GL_Resampl:

; 795  : 		}

	jmp	$LN8@GL_Resampl
$LN9@GL_Resampl:

; 796  : 	}

	jmp	$LN15@GL_Resampl
$LN21@GL_Resampl:

; 797  : 	else
; 798  : 	{
; 799  : 		for( y = 0; y < outHeight; y++, out += outWidth )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN16@GL_Resampl
$LN14@GL_Resampl:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
	mov	ecx, DWORD PTR _outWidth$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _out$[ebp], eax
$LN16@GL_Resampl:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _outHeight$[ebp]
	jge	$LN15@GL_Resampl

; 800  : 		{
; 801  : 			inRow1 = in + inWidth * (int)(((float)y + 0.25f) * inHeight / outHeight);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR __real@3e800000
	cvtsi2ss xmm1, DWORD PTR _inHeight$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _outHeight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	imul	eax, DWORD PTR _inWidth$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inRow1$[ebp], edx

; 802  : 			inRow2 = in + inWidth * (int)(((float)y + 0.75f) * inHeight / outHeight);

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR __real@3f400000
	cvtsi2ss xmm1, DWORD PTR _inHeight$[ebp]
	mulss	xmm0, xmm1
	cvtsi2ss xmm1, DWORD PTR _outHeight$[ebp]
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
	imul	eax, DWORD PTR _inWidth$[ebp]
	mov	ecx, DWORD PTR _in$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _inRow2$[ebp], edx

; 803  : 
; 804  : 			for( x = 0; x < outWidth; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN19@GL_Resampl
$LN17@GL_Resampl:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN19@GL_Resampl:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _outWidth$[ebp]
	jge	$LN18@GL_Resampl

; 805  : 			{
; 806  : 				pix1 = (byte *)inRow1 + p1[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow1$[ebp]
	add	ecx, DWORD PTR _p1$[ebp+eax*4]
	mov	DWORD PTR _pix1$[ebp], ecx

; 807  : 				pix2 = (byte *)inRow1 + p2[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow1$[ebp]
	add	ecx, DWORD PTR _p2$[ebp+eax*4]
	mov	DWORD PTR _pix2$[ebp], ecx

; 808  : 				pix3 = (byte *)inRow2 + p1[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow2$[ebp]
	add	ecx, DWORD PTR _p1$[ebp+eax*4]
	mov	DWORD PTR _pix3$[ebp], ecx

; 809  : 				pix4 = (byte *)inRow2 + p2[x];

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _inRow2$[ebp]
	add	ecx, DWORD PTR _p2$[ebp+eax*4]
	mov	DWORD PTR _pix4$[ebp], ecx

; 810  : 
; 811  : 				((byte *)(out+x))[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0]) >> 2;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pix1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pix3$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	sar	eax, 2
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	imul	edx, edx, 0
	mov	BYTE PTR [ecx+edx], al

; 812  : 				((byte *)(out+x))[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1]) >> 2;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 0
	mov	eax, DWORD PTR _pix3$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	add	edx, eax
	sar	edx, 2
	mov	ecx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR [ecx+eax], dl

; 813  : 				((byte *)(out+x))[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2]) >> 2;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix1$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	add	edx, eax
	mov	ecx, 1
	shl	ecx, 1
	mov	eax, DWORD PTR _pix3$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	add	edx, ecx
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	add	edx, eax
	sar	edx, 2
	mov	ecx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR [ecx+eax], dl

; 814  : 				((byte *)(out+x))[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3]) >> 2;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pix1$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _pix2$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _pix3$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _pix4$[ebp]
	movzx	edx, BYTE PTR [ecx+edx]
	add	eax, edx
	sar	eax, 2
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, 1
	imul	edx, edx, 3
	mov	BYTE PTR [ecx+edx], al

; 815  : 			}

	jmp	$LN17@GL_Resampl
$LN18@GL_Resampl:

; 816  : 		}

	jmp	$LN14@GL_Resampl
$LN15@GL_Resampl:

; 817  : 	}
; 818  : 
; 819  : 	return scaledImage;

	mov	eax, DWORD PTR ?scaledImage@?1??GL_ResampleTexture@@9@9
$LN1@GL_Resampl:

; 820  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_ResampleTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_LoadTextureFromBuffer
_TEXT	SEGMENT
_tex$ = -4						; size = 4
_name$ = 8						; size = 4
_pic$ = 12						; size = 4
_flags$ = 16						; size = 4
_update$ = 20						; size = 4
_GL_LoadTextureFromBuffer PROC				; COMDAT

; 1620 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1621 : 	gl_texture_t	*tex;
; 1622 : 
; 1623 : 	if( !GL_CheckTexName( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_CheckTexName
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_LoadTex

; 1624 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN2@GL_LoadTex:

; 1625 : 
; 1626 : 	// see if already loaded
; 1627 : 	if(( tex = GL_TextureForName( name )) && !update )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_TextureForName
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN3@GL_LoadTex
	cmp	DWORD PTR _update$[ebp], 0
	jne	SHORT $LN3@GL_LoadTex

; 1628 : 		return (tex - gl_textures);

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
	jmp	$LN1@GL_LoadTex
$LN3@GL_LoadTex:

; 1629 : 
; 1630 : 	// couldn't loading image
; 1631 : 	if( !pic ) return 0;

	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN4@GL_LoadTex
	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN4@GL_LoadTex:

; 1632 : 
; 1633 : 	if( update )

	cmp	DWORD PTR _update$[ebp], 0
	je	SHORT $LN5@GL_LoadTex

; 1634 : 	{
; 1635 : 		if( tex == NULL )

	cmp	DWORD PTR _tex$[ebp], 0
	jne	SHORT $LN7@GL_LoadTex

; 1636 : 			Host_Error( "GL_LoadTextureFromBuffer: couldn't find texture %s for update\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@KMJLBDPK@GL_LoadTextureFromBuffer?3?5could@
	call	_Host_Error
	add	esp, 8
$LN7@GL_LoadTex:

; 1637 : 		SetBits( tex->flags, flags );

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	or	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+284], ecx

; 1638 : 	}

	jmp	SHORT $LN6@GL_LoadTex
$LN5@GL_LoadTex:

; 1639 : 	else
; 1640 : 	{
; 1641 : 		// allocate the new one
; 1642 : 		tex = GL_AllocTexture( name, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_GL_AllocTexture
	add	esp, 8
	mov	DWORD PTR _tex$[ebp], eax
$LN6@GL_LoadTex:

; 1643 : 	}
; 1644 : 
; 1645 : 	GL_ProcessImage( tex, pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_ProcessImage
	add	esp, 8

; 1646 : 	if( !GL_UploadTexture( tex, pic ))

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_UploadTexture
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@GL_LoadTex

; 1647 : 	{
; 1648 : 		memset( tex, 0, sizeof( gl_texture_t ));

	push	320					; 00000140H
	push	0
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1649 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_LoadTex
$LN8@GL_LoadTex:

; 1650 : 	}
; 1651 : 
; 1652 : 	GL_ApplyTextureParams( tex ); // update texture filter, wrap etc

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_ApplyTextureParams
	add	esp, 4

; 1653 : 	return (tex - gl_textures);

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
$LN1@GL_LoadTex:

; 1654 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTextureFromBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_LoadTextureArray
_TEXT	SEGMENT
tv277 = -700						; size = 4
tv269 = -700						; size = 4
tv260 = -700						; size = 4
$T1 = -696						; size = 4
_height$2 = -564					; size = 4
_width$3 = -560						; size = 4
_mipsize$4 = -556					; size = 4
_dstsize$5 = -552					; size = 4
_srcsize$6 = -548					; size = 4
_j$ = -544						; size = 4
_i$ = -540						; size = 4
_tex$ = -536						; size = 4
_name$ = -532						; size = 256
_picFlags$ = -276					; size = 4
_numLayers$ = -272					; size = 4
_basename$ = -268					; size = 256
_src$ = -12						; size = 4
_pic$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_names$ = 8						; size = 4
_flags$ = 12						; size = 4
_GL_LoadTextureArray PROC				; COMDAT

; 1479 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 700				; 000002bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1480 : 	rgbdata_t		*pic, *src;
; 1481 : 	char		basename[256];
; 1482 : 	uint		numLayers = 0;

	mov	DWORD PTR _numLayers$[ebp], 0

; 1483 : 	uint		picFlags = 0;

	mov	DWORD PTR _picFlags$[ebp], 0

; 1484 : 	char		name[256];
; 1485 : 	gl_texture_t	*tex;
; 1486 : 	uint		i, j;
; 1487 : 
; 1488 : 	if( !names || !names[0] || !glw_state.initialized )

	cmp	DWORD PTR _names$[ebp], 0
	je	SHORT $LN15@GL_LoadTex
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _names$[ebp]
	cmp	DWORD PTR [edx+ecx], 0
	je	SHORT $LN15@GL_LoadTex
	cmp	DWORD PTR _glw_state+20, 0
	jne	SHORT $LN14@GL_LoadTex
$LN15@GL_LoadTex:

; 1489 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN14@GL_LoadTex:

; 1490 : 
; 1491 : 	// count layers (g-cont. this is pontentially unsafe loop)
; 1492 : 	for( i = 0; i < glConfig.max_2d_texture_layers && ( *names[i] != '\0' ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GL_LoadTex
$LN2@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _glConfig+68
	jae	SHORT $LN3@GL_LoadTex
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@GL_LoadTex

; 1493 : 		numLayers++;

	mov	eax, DWORD PTR _numLayers$[ebp]
	add	eax, 1
	mov	DWORD PTR _numLayers$[ebp], eax
	jmp	SHORT $LN2@GL_LoadTex
$LN3@GL_LoadTex:

; 1494 : 	name[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN36@GL_LoadTex
	jmp	SHORT $LN37@GL_LoadTex
$LN36@GL_LoadTex:
	call	___report_rangecheckfailure
$LN37@GL_LoadTex:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _name$[ebp+edx], 0

; 1495 : 
; 1496 : 	if( numLayers <= 0 ) return 0;

	cmp	DWORD PTR _numLayers$[ebp], 0
	ja	SHORT $LN16@GL_LoadTex
	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN16@GL_LoadTex:

; 1497 : 
; 1498 : 	// create complexname from layer names
; 1499 : 	for( i = 0; i < numLayers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GL_LoadTex
$LN5@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numLayers$[ebp]
	jae	SHORT $LN6@GL_LoadTex

; 1500 : 	{
; 1501 : 		COM_FileBase( names[i], basename );

	lea	eax, DWORD PTR _basename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_COM_FileBase
	add	esp, 8

; 1502 : 		Q_strncat( name, va( "%s", basename ), sizeof( name ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _basename$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1503 : 		if( i != ( numLayers - 1 )) Q_strncat( name, "|", sizeof( name ));

	mov	eax, DWORD PTR _numLayers$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $LN17@GL_LoadTex
	push	256					; 00000100H
	push	OFFSET ??_C@_01DNKMNLPK@?$HM@
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH
$LN17@GL_LoadTex:

; 1504 : 	}

	jmp	$LN5@GL_LoadTex
$LN6@GL_LoadTex:

; 1505 : 
; 1506 : 	Q_strncat( name, va( "[%i]", numLayers ), sizeof( name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _numLayers$[ebp]
	push	eax
	push	OFFSET ??_C@_04KJOBHKIC@?$FL?$CFi?$FN@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1507 : 
; 1508 : 	if( !GL_CheckTexName( name ))

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_CheckTexName
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@GL_LoadTex

; 1509 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN18@GL_LoadTex:

; 1510 : 
; 1511 : 	// see if already loaded
; 1512 : 	if(( tex = GL_TextureForName( name )))

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_TextureForName
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN19@GL_LoadTex

; 1513 : 		return (tex - gl_textures);

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
	jmp	$LN1@GL_LoadTex
$LN19@GL_LoadTex:

; 1514 : 
; 1515 : 	// load all the images and pack it into single image
; 1516 : 	for( i = 0, pic = NULL; i < numLayers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _pic$[ebp], 0
	jmp	SHORT $LN10@GL_LoadTex
$LN8@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@GL_LoadTex:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numLayers$[ebp]
	jae	$LN9@GL_LoadTex

; 1517 : 	{
; 1518 : 		size_t	srcsize, dstsize, mipsize;
; 1519 : 
; 1520 : 		src = FS_LoadImage( names[i], NULL, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _src$[ebp], eax

; 1521 : 		if( !src ) break; // coldn't find layer

	cmp	DWORD PTR _src$[ebp], 0
	jne	SHORT $LN20@GL_LoadTex
	jmp	$LN9@GL_LoadTex
$LN20@GL_LoadTex:

; 1522 : 
; 1523 : 		if( pic )

	cmp	DWORD PTR _pic$[ebp], 0
	je	$LN21@GL_LoadTex

; 1524 : 		{
; 1525 : 			// mixed mode: DXT + RGB
; 1526 : 			if( pic->type != src->type )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN23@GL_LoadTex

; 1527 : 			{
; 1528 : 				Con_Printf( S_ERROR "GL_LoadTextureArray: mismatch image format for %s and %s\n", names[0], names[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0EF@DOCILBDF@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1529 : 				break;

	jmp	$LN9@GL_LoadTex
$LN23@GL_LoadTex:

; 1530 : 			}
; 1531 : 
; 1532 : 			// different mipcount
; 1533 : 			if( pic->numMips != src->numMips )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	cmp	ecx, eax
	je	SHORT $LN24@GL_LoadTex

; 1534 : 			{
; 1535 : 				Con_Printf( S_ERROR "GL_LoadTextureArray: mismatch mip count for %s and %s\n", names[0], names[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0EC@GJAFFJKB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1536 : 				break;

	jmp	$LN9@GL_LoadTex
$LN24@GL_LoadTex:

; 1537 : 			}
; 1538 : 
; 1539 : 			if( pic->encode != src->encode )

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+16]
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+16]
	cmp	ecx, eax
	je	SHORT $LN25@GL_LoadTex

; 1540 : 			{
; 1541 : 				Con_Printf( S_ERROR "GL_LoadTextureArray: mismatch custom encoding for %s and %s\n", names[0], names[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0EI@EBJDPNMO@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1542 : 				break;

	jmp	$LN9@GL_LoadTex
$LN25@GL_LoadTex:

; 1543 : 			}
; 1544 : 
; 1545 : 			// but allow to rescale raw images
; 1546 : 			if( ImageRAW( pic->type ) && ImageRAW( src->type ) && ( pic->width != src->width || pic->height != src->height ))

	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 3
	je	SHORT $LN27@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 4
	je	SHORT $LN27@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 5
	je	SHORT $LN27@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	cmp	DWORD PTR [eax+8], 6
	jne	SHORT $LN26@GL_LoadTex
$LN27@GL_LoadTex:
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+8], 3
	je	SHORT $LN28@GL_LoadTex
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+8], 4
	je	SHORT $LN28@GL_LoadTex
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+8], 5
	je	SHORT $LN28@GL_LoadTex
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+8], 6
	jne	SHORT $LN26@GL_LoadTex
$LN28@GL_LoadTex:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN29@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+2]
	cmp	ecx, eax
	je	SHORT $LN26@GL_LoadTex
$LN29@GL_LoadTex:

; 1547 : 				Image_Process( &src, pic->width, pic->height, IMAGE_RESAMPLE, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	1048576					; 00100000H
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	_Image_Process
	add	esp, 20					; 00000014H
$LN26@GL_LoadTex:

; 1548 : 
; 1549 : 			if( pic->size != src->size )

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+32]
	je	SHORT $LN30@GL_LoadTex

; 1550 : 			{
; 1551 : 				Con_Printf( S_ERROR "GL_LoadTextureArray: mismatch image size for %s and %s\n", names[0], names[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0ED@HMAKJHB@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1552 : 				break;

	jmp	$LN9@GL_LoadTex
$LN30@GL_LoadTex:

; 1553 : 			}
; 1554 : 		}

	jmp	SHORT $LN22@GL_LoadTex
$LN21@GL_LoadTex:

; 1555 : 		else
; 1556 : 		{
; 1557 : 			// create new image
; 1558 : 			pic = Mem_Malloc( host.imagepool, sizeof( rgbdata_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_LoadTextureArray@@9@9
	add	eax, 79					; 0000004fH
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	36					; 00000024H
	mov	ecx, DWORD PTR _host+34744
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pic$[ebp], eax

; 1559 : 			memcpy( pic, src, sizeof( rgbdata_t ));

	push	36					; 00000024H
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pic$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1560 : 
; 1561 : 			// expand pic buffer for all layers
; 1562 : 			pic->buffer = Mem_Malloc( host.imagepool, pic->size * numLayers );

	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_LoadTextureArray@@9@9
	add	eax, 83					; 00000053H
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, DWORD PTR _numLayers$[ebp]
	push	edx
	mov	eax, DWORD PTR _host+34744
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1563 : 			pic->depth = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _pic$[ebp]
	mov	WORD PTR [ecx+4], ax
$LN22@GL_LoadTex:

; 1564 : 		}
; 1565 : 
; 1566 : 		mipsize = srcsize = dstsize = 0;

	mov	DWORD PTR _dstsize$5[ebp], 0
	mov	eax, DWORD PTR _dstsize$5[ebp]
	mov	DWORD PTR _srcsize$6[ebp], eax
	mov	ecx, DWORD PTR _srcsize$6[ebp]
	mov	DWORD PTR _mipsize$4[ebp], ecx

; 1567 : 
; 1568 : 		for( j = 0; j < max( 1, pic->numMips ); j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN13@GL_LoadTex
$LN11@GL_LoadTex:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN13@GL_LoadTex:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	cmp	ecx, 1
	jge	SHORT $LN38@GL_LoadTex
	mov	DWORD PTR tv260[ebp], 1
	jmp	SHORT $LN39@GL_LoadTex
$LN38@GL_LoadTex:
	mov	edx, DWORD PTR _pic$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	mov	DWORD PTR tv260[ebp], eax
$LN39@GL_LoadTex:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR tv260[ebp]
	jae	$LN12@GL_LoadTex

; 1569 : 		{
; 1570 : 			int width = Q_max( 1, ( pic->width >> j ));

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [eax]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN40@GL_LoadTex
	mov	DWORD PTR tv269[ebp], 1
	jmp	SHORT $LN41@GL_LoadTex
$LN40@GL_LoadTex:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [eax]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv269[ebp], edx
$LN41@GL_LoadTex:
	mov	eax, DWORD PTR tv269[ebp]
	mov	DWORD PTR _width$3[ebp], eax

; 1571 : 			int height = Q_max( 1, ( pic->height >> j ));

	mov	eax, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [eax+2]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	cmp	edx, 1
	jge	SHORT $LN42@GL_LoadTex
	mov	DWORD PTR tv277[ebp], 1
	jmp	SHORT $LN43@GL_LoadTex
$LN42@GL_LoadTex:
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	edx, WORD PTR [eax+2]
	mov	ecx, DWORD PTR _j$[ebp]
	sar	edx, cl
	mov	DWORD PTR tv277[ebp], edx
$LN43@GL_LoadTex:
	mov	eax, DWORD PTR tv277[ebp]
	mov	DWORD PTR _height$2[ebp], eax

; 1572 : 			mipsize = GL_CalcImageSize( pic->type, width, height, 1 );

	push	1
	mov	eax, DWORD PTR _height$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_GL_CalcImageSize
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mipsize$4[ebp], eax

; 1573 : 			memcpy( pic->buffer + dstsize + mipsize * i, src->buffer + srcsize, mipsize );

	mov	eax, DWORD PTR _mipsize$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _srcsize$6[ebp]
	push	edx
	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _dstsize$5[ebp]
	mov	edx, DWORD PTR _mipsize$4[ebp]
	imul	edx, DWORD PTR _i$[ebp]
	add	ecx, edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1574 : 			dstsize += mipsize * numLayers;

	mov	eax, DWORD PTR _mipsize$4[ebp]
	imul	eax, DWORD PTR _numLayers$[ebp]
	add	eax, DWORD PTR _dstsize$5[ebp]
	mov	DWORD PTR _dstsize$5[ebp], eax

; 1575 : 			srcsize += mipsize;

	mov	eax, DWORD PTR _srcsize$6[ebp]
	add	eax, DWORD PTR _mipsize$4[ebp]
	mov	DWORD PTR _srcsize$6[ebp], eax

; 1576 : 		}

	jmp	$LN11@GL_LoadTex
$LN12@GL_LoadTex:

; 1577 : 
; 1578 : 		FS_FreeImage( src );

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1579 : 
; 1580 : 		// increase layers
; 1581 : 		pic->depth++;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	cx, WORD PTR [eax+4]
	add	cx, 1
	mov	edx, DWORD PTR _pic$[ebp]
	mov	WORD PTR [edx+4], cx

; 1582 : 	}

	jmp	$LN8@GL_LoadTex
$LN9@GL_LoadTex:

; 1583 : 
; 1584 : 	// there were errors
; 1585 : 	if( !pic || ( pic->depth != numLayers ))

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN32@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	ecx, DWORD PTR _numLayers$[ebp]
	je	SHORT $LN31@GL_LoadTex
$LN32@GL_LoadTex:

; 1586 : 	{
; 1587 : 		Con_Printf( S_ERROR "GL_LoadTextureArray: not all layers were loaded. Texture array is not created\n" );

	push	OFFSET ??_C@_0FK@GJHFFGAI@?$FO1Error?3?$FO7?5GL_LoadTextureArray?3@
	call	_Con_Printf
	add	esp, 4

; 1588 : 		if( pic ) FS_FreeImage( pic );

	cmp	DWORD PTR _pic$[ebp], 0
	je	SHORT $LN33@GL_LoadTex
	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4
$LN33@GL_LoadTex:

; 1589 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN31@GL_LoadTex:

; 1590 : 	}	
; 1591 : 
; 1592 : 	// it's multilayer image!
; 1593 : 	SetBits( pic->flags, IMAGE_MULTILAYER );

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1594 : 	pic->size *= numLayers;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, DWORD PTR _numLayers$[ebp]
	mov	edx, DWORD PTR _pic$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 1595 : 
; 1596 : 	// allocate the new one
; 1597 : 	tex = GL_AllocTexture( name, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_GL_AllocTexture
	add	esp, 8
	mov	DWORD PTR _tex$[ebp], eax

; 1598 : 	GL_ProcessImage( tex, pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_ProcessImage
	add	esp, 8

; 1599 : 
; 1600 : 	if( !GL_UploadTexture( tex, pic ))

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_UploadTexture
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@GL_LoadTex

; 1601 : 	{
; 1602 : 		memset( tex, 0, sizeof( gl_texture_t ));

	push	320					; 00000140H
	push	0
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1603 : 		FS_FreeImage( pic ); // release source texture

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1604 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_LoadTex
$LN34@GL_LoadTex:

; 1605 : 	}
; 1606 : 
; 1607 : 	GL_ApplyTextureParams( tex ); // update texture filter, wrap etc

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_ApplyTextureParams
	add	esp, 4

; 1608 : 	FS_FreeImage( pic ); // release source texture

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1609 : 
; 1610 : 	// NOTE: always return texnum as index in array or engine will stop work !!!
; 1611 : 	return tex - gl_textures;

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
$LN1@GL_LoadTex:

; 1612 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTextureArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_LoadTexture
_TEXT	SEGMENT
_picFlags$ = -12					; size = 4
_pic$ = -8						; size = 4
_tex$ = -4						; size = 4
_name$ = 8						; size = 4
_buf$ = 12						; size = 4
_size$ = 16						; size = 4
_flags$ = 20						; size = 4
_GL_LoadTexture PROC					; COMDAT

; 1431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1432 : 	gl_texture_t	*tex;
; 1433 : 	rgbdata_t		*pic;
; 1434 : 	uint		picFlags = 0;

	mov	DWORD PTR _picFlags$[ebp], 0

; 1435 : 
; 1436 : 	if( !GL_CheckTexName( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_CheckTexName
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@GL_LoadTex

; 1437 : 		return 0;

	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN2@GL_LoadTex:

; 1438 : 
; 1439 : 	// see if already loaded
; 1440 : 	if(( tex = GL_TextureForName( name )))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_TextureForName
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax
	cmp	DWORD PTR _tex$[ebp], 0
	je	SHORT $LN3@GL_LoadTex

; 1441 : 		return (tex - gl_textures);

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
	jmp	$LN1@GL_LoadTex
$LN3@GL_LoadTex:

; 1442 : 
; 1443 : 	if( FBitSet( flags, TF_NOFLIP_TGA ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 4
	je	SHORT $LN4@GL_LoadTex

; 1444 : 		SetBits( picFlags, IL_DONTFLIP_TGA );

	mov	eax, DWORD PTR _picFlags$[ebp]
	or	eax, 8
	mov	DWORD PTR _picFlags$[ebp], eax
$LN4@GL_LoadTex:

; 1445 : 
; 1446 : 	if( FBitSet( flags, TF_KEEP_SOURCE ) && !FBitSet( flags, TF_EXPAND_SOURCE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN5@GL_LoadTex
	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 8
	jne	SHORT $LN5@GL_LoadTex

; 1447 : 		SetBits( picFlags, IL_KEEP_8BIT );	

	mov	eax, DWORD PTR _picFlags$[ebp]
	or	eax, 2
	mov	DWORD PTR _picFlags$[ebp], eax
$LN5@GL_LoadTex:

; 1448 : 
; 1449 : 	// set some image flags
; 1450 : 	Image_SetForceFlags( picFlags );

	mov	eax, DWORD PTR _picFlags$[ebp]
	push	eax
	call	_Image_SetForceFlags
	add	esp, 4

; 1451 : 
; 1452 : 	pic = FS_LoadImage( name, buf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_LoadImage
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pic$[ebp], eax

; 1453 : 	if( !pic ) return 0; // couldn't loading image

	cmp	DWORD PTR _pic$[ebp], 0
	jne	SHORT $LN6@GL_LoadTex
	xor	eax, eax
	jmp	$LN1@GL_LoadTex
$LN6@GL_LoadTex:

; 1454 : 
; 1455 : 	// allocate the new one
; 1456 : 	tex = GL_AllocTexture( name, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_GL_AllocTexture
	add	esp, 8
	mov	DWORD PTR _tex$[ebp], eax

; 1457 : 	GL_ProcessImage( tex, pic );

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_ProcessImage
	add	esp, 8

; 1458 : 
; 1459 : 	if( !GL_UploadTexture( tex, pic ))

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tex$[ebp]
	push	ecx
	call	_GL_UploadTexture
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@GL_LoadTex

; 1460 : 	{
; 1461 : 		memset( tex, 0, sizeof( gl_texture_t ));

	push	320					; 00000140H
	push	0
	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1462 : 		FS_FreeImage( pic ); // release source texture

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1463 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GL_LoadTex
$LN7@GL_LoadTex:

; 1464 : 	}
; 1465 : 
; 1466 : 	GL_ApplyTextureParams( tex ); // update texture filter, wrap etc

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_ApplyTextureParams
	add	esp, 4

; 1467 : 	FS_FreeImage( pic ); // release source texture

	mov	eax, DWORD PTR _pic$[ebp]
	push	eax
	call	_FS_FreeImage
	add	esp, 4

; 1468 : 
; 1469 : 	// NOTE: always return texnum as index in array or engine will stop work !!!
; 1470 : 	return tex - gl_textures;

	mov	eax, DWORD PTR _tex$[ebp]
	sub	eax, OFFSET _gl_textures
	cdq
	mov	ecx, 320				; 00000140H
	idiv	ecx
$LN1@GL_LoadTex:

; 1471 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_LoadTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_GetTexture
_TEXT	SEGMENT
_texnum$ = 8						; size = 4
_R_GetTexture PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 36   : 	ASSERT( texnum >= 0 && texnum < MAX_TEXTURES );

	cmp	DWORD PTR _texnum$[ebp], 0
	jb	SHORT $LN3@R_GetTextu
	cmp	DWORD PTR _texnum$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@R_GetTextu
$LN3@R_GetTextu:
	mov	eax, DWORD PTR ?__LINE__Var@?0??R_GetTexture@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BI@FECCGOFJ@assert?5failed?5at?5?$CFs?3?$CFi?6@
	call	_Sys_Error
	add	esp, 12					; 0000000cH
$LN2@R_GetTextu:

; 37   : 	return &gl_textures[texnum];

	imul	eax, DWORD PTR _texnum$[ebp], 320
	add	eax, OFFSET _gl_textures

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _R_SetTextureParameters
_TEXT	SEGMENT
_i$ = -4						; size = 4
_R_SetTextureParameters PROC				; COMDAT

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 297  : 	int	i;
; 298  : 
; 299  : 	if( GL_Support( GL_ANISOTROPY_EXT ))

	push	6
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@R_SetTextu

; 300  : 	{
; 301  : 		if( gl_texture_anisotropy->value > glConfig.max_texture_anisotropy )

	mov	eax, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _glConfig+80
	jbe	SHORT $LN6@R_SetTextu

; 302  : 			Cvar_SetValue( "gl_anisotropy", glConfig.max_texture_anisotropy );

	push	ecx
	movss	xmm0, DWORD PTR _glConfig+80
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@DGIPFEHA@gl_anisotropy@
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN8@R_SetTextu
$LN6@R_SetTextu:

; 303  : 		else if( gl_texture_anisotropy->value < 1.0f )

	mov	eax, DWORD PTR _gl_texture_anisotropy
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN8@R_SetTextu

; 304  : 			Cvar_SetValue( "gl_anisotropy", 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@DGIPFEHA@gl_anisotropy@
	call	_Cvar_SetValue
	add	esp, 8
$LN8@R_SetTextu:

; 305  : 	}
; 306  : 
; 307  : 	if( GL_Support( GL_TEXTURE_LOD_BIAS ))

	push	7
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@R_SetTextu

; 308  : 	{
; 309  : 		if( gl_texture_lodbias->value < -glConfig.max_texture_lod_bias )

	movss	xmm0, DWORD PTR _glConfig+84
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	eax, DWORD PTR _gl_texture_lodbias
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN10@R_SetTextu

; 310  : 			Cvar_SetValue( "gl_texture_lodbias", -glConfig.max_texture_lod_bias );

	movss	xmm0, DWORD PTR _glConfig+84
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BD@KLPBGJAB@gl_texture_lodbias@
	call	_Cvar_SetValue
	add	esp, 8
	jmp	SHORT $LN12@R_SetTextu
$LN10@R_SetTextu:

; 311  : 		else if( gl_texture_lodbias->value > glConfig.max_texture_lod_bias )

	mov	eax, DWORD PTR _gl_texture_lodbias
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR _glConfig+84
	jbe	SHORT $LN12@R_SetTextu

; 312  : 			Cvar_SetValue( "gl_texture_lodbias", glConfig.max_texture_lod_bias );

	push	ecx
	movss	xmm0, DWORD PTR _glConfig+84
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BD@KLPBGJAB@gl_texture_lodbias@
	call	_Cvar_SetValue
	add	esp, 8
$LN12@R_SetTextu:

; 313  : 	}
; 314  : 
; 315  : 	ClearBits( gl_texture_anisotropy->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_texture_anisotropy
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_texture_anisotropy
	mov	DWORD PTR [edx+8], ecx

; 316  : 	ClearBits( gl_texture_lodbias->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_texture_lodbias
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_texture_lodbias
	mov	DWORD PTR [edx+8], ecx

; 317  : 	ClearBits( gl_texture_nearest->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_texture_nearest
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_texture_nearest
	mov	DWORD PTR [edx+8], ecx

; 318  : 	ClearBits( gl_lightmap_nearest->flags, FCVAR_CHANGED );

	mov	eax, DWORD PTR _gl_lightmap_nearest
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -8193				; ffffdfffH
	mov	edx, DWORD PTR _gl_lightmap_nearest
	mov	DWORD PTR [edx+8], ecx

; 319  : 
; 320  : 	// change all the existing mipmapped texture objects
; 321  : 	for( i = 0; i < gl_numTextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_SetTextu
$LN2@R_SetTextu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_SetTextu:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _gl_numTextures
	jae	SHORT $LN3@R_SetTextu

; 322  : 		GL_UpdateTextureParams( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_GL_UpdateTextureParams
	add	esp, 4
	jmp	SHORT $LN2@R_SetTextu
$LN3@R_SetTextu:

; 323  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_SetTextureParameters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_Bind
_TEXT	SEGMENT
tv71 = -76						; size = 4
_glTarget$ = -8						; size = 4
_texture$ = -4						; size = 4
_tmu$ = 8						; size = 4
_texnum$ = 12						; size = 4
_GL_Bind PROC						; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 72   : 	gl_texture_t	*texture;
; 73   : 	GLuint		glTarget;
; 74   : 
; 75   : 	Assert( texnum >= 0 && texnum < MAX_TEXTURES );

	cmp	DWORD PTR _texnum$[ebp], 0
	jb	SHORT $LN11@GL_Bind
	cmp	DWORD PTR _texnum$[ebp], 4096		; 00001000H
	jae	SHORT $LN11@GL_Bind
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN12@GL_Bind
$LN11@GL_Bind:
	mov	DWORD PTR tv71[ebp], 0
$LN12@GL_Bind:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??GL_Bind@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DF@PHODLOMG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CF@MPKGELAE@texnum?5?$DO?$DN?50?5?$CG?$CG?5texnum?5?$DM?5MAX_TEX@
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 76   : 
; 77   : 	// missed or invalid texture?
; 78   : 	if( texnum <= 0 || texnum >= MAX_TEXTURES )

	cmp	DWORD PTR _texnum$[ebp], 0
	jbe	SHORT $LN3@GL_Bind
	cmp	DWORD PTR _texnum$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@GL_Bind
$LN3@GL_Bind:

; 79   : 		texnum = tr.defaultTexture;

	mov	eax, DWORD PTR _tr
	mov	DWORD PTR _texnum$[ebp], eax
$LN2@GL_Bind:

; 80   : 
; 81   : 	if( tmu != GL_KEEP_UNIT )

	cmp	DWORD PTR _tmu$[ebp], -1
	je	SHORT $LN4@GL_Bind

; 82   : 		GL_SelectTexture( tmu );

	mov	eax, DWORD PTR _tmu$[ebp]
	push	eax
	call	_GL_SelectTexture
	add	esp, 4
	jmp	SHORT $LN5@GL_Bind
$LN4@GL_Bind:

; 83   : 	else tmu = glState.activeTMU;

	mov	eax, DWORD PTR _glState+16
	mov	DWORD PTR _tmu$[ebp], eax
$LN5@GL_Bind:

; 84   : 
; 85   : 	texture = &gl_textures[texnum];

	imul	eax, DWORD PTR _texnum$[ebp], 320
	add	eax, OFFSET _gl_textures
	mov	DWORD PTR _texture$[ebp], eax

; 86   : 	glTarget = texture->target;

	mov	eax, DWORD PTR _texture$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _glTarget$[ebp], ecx

; 87   : 
; 88   : 	if( glTarget == GL_TEXTURE_2D_ARRAY_EXT )

	cmp	DWORD PTR _glTarget$[ebp], 35866	; 00008c1aH
	jne	SHORT $LN6@GL_Bind

; 89   : 		glTarget = GL_TEXTURE_2D;

	mov	DWORD PTR _glTarget$[ebp], 3553		; 00000de1H
$LN6@GL_Bind:

; 90   : 
; 91   : 	if( glState.currentTextureTargets[tmu] != glTarget )

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+148]
	cmp	ecx, DWORD PTR _glTarget$[ebp]
	je	SHORT $LN7@GL_Bind

; 92   : 	{
; 93   : 		if( glState.currentTextureTargets[tmu] != GL_NONE )

	mov	eax, DWORD PTR _tmu$[ebp]
	cmp	DWORD PTR _glState[eax*4+148], 0
	je	SHORT $LN8@GL_Bind

; 94   : 			pglDisable( glState.currentTextureTargets[tmu] );

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+148]
	push	ecx
	call	DWORD PTR _pglDisable
$LN8@GL_Bind:

; 95   : 		glState.currentTextureTargets[tmu] = glTarget;

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glTarget$[ebp]
	mov	DWORD PTR _glState[eax*4+148], ecx

; 96   : 		pglEnable( glState.currentTextureTargets[tmu] );

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _glState[eax*4+148]
	push	ecx
	call	DWORD PTR _pglEnable
$LN7@GL_Bind:

; 97   : 	}
; 98   : 
; 99   : 	if( glState.currentTextures[tmu] == texture->texnum )

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp]
	mov	edx, DWORD PTR _glState[eax*4+20]
	cmp	edx, DWORD PTR [ecx+272]
	jne	SHORT $LN9@GL_Bind

; 100  : 		return;

	jmp	SHORT $LN1@GL_Bind
$LN9@GL_Bind:

; 101  : 
; 102  : 	pglBindTexture( texture->target, texture->texnum );

	mov	eax, DWORD PTR _texture$[ebp]
	mov	ecx, DWORD PTR [eax+272]
	push	ecx
	mov	edx, DWORD PTR _texture$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	DWORD PTR _pglBindTexture

; 103  : 	glState.currentTextures[tmu] = texture->texnum;

	mov	eax, DWORD PTR _tmu$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR _glState[eax*4+20], edx
$LN1@GL_Bind:

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_Bind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_image.c
;	COMDAT _GL_FreeImage
_TEXT	SEGMENT
_texnum$ = -4						; size = 4
_name$ = 8						; size = 4
_GL_FreeImage PROC					; COMDAT

; 1772 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1773 : 	int	texnum;
; 1774 : 
; 1775 : 	if(( texnum = GL_FindTexture( name )) != 0 )

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_GL_FindTexture
	add	esp, 4
	mov	DWORD PTR _texnum$[ebp], eax
	cmp	DWORD PTR _texnum$[ebp], 0
	je	SHORT $LN1@GL_FreeIma

; 1776 : 		 GL_FreeTexture( texnum );

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_GL_FreeTexture
	add	esp, 4
$LN1@GL_FreeIma:

; 1777 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GL_FreeImage ENDP
_TEXT	ENDS
END
