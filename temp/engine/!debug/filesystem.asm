; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\filesystem.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_fs_searchpaths
PUBLIC	_fs_ext_path
PUBLIC	??_C@_03DFNJAFMD@pal@				; `string'
PUBLIC	??_C@_03CBDDAJHO@dds@				; `string'
PUBLIC	??_C@_03MAHLEJNN@lmp@				; `string'
PUBLIC	??_C@_03MJOMNCOE@fnt@				; `string'
PUBLIC	??_C@_03HPMOIGGE@mip@				; `string'
PUBLIC	??_C@_03CLFHJCDC@txt@				; `string'
_DATA	SEGMENT
COMM	_fs_mempool:DWORD
_DATA	ENDS
_BSS	SEGMENT
_fs_searchpaths DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_fs_directpath:BYTE:0110H
COMM	_fs_basedir:BYTE:0400H
COMM	_fs_gamedir:BYTE:0400H
COMM	_fs_writedir:BYTE:0400H
_DATA	ENDS
_BSS	SEGMENT
_fs_ext_path DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03CLFHJCDC@txt@
CONST	SEGMENT
??_C@_03CLFHJCDC@txt@ DB 'txt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HPMOIGGE@mip@
CONST	SEGMENT
??_C@_03HPMOIGGE@mip@ DB 'mip', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MJOMNCOE@fnt@
CONST	SEGMENT
??_C@_03MJOMNCOE@fnt@ DB 'fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAHLEJNN@lmp@
CONST	SEGMENT
??_C@_03MAHLEJNN@lmp@ DB 'lmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CBDDAJHO@dds@
CONST	SEGMENT
??_C@_03CBDDAJHO@dds@ DB 'dds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFNJAFMD@pal@
CONST	SEGMENT
??_C@_03DFNJAFMD@pal@ DB 'pal', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
_wad_types DD	FLAT:??_C@_03DFNJAFMD@pal@
	DB	040H
	ORG $+3
	DD	FLAT:??_C@_03CBDDAJHO@dds@
	DB	041H
	ORG $+3
	DD	FLAT:??_C@_03MAHLEJNN@lmp@
	DB	042H
	ORG $+3
	DD	FLAT:??_C@_03MJOMNCOE@fnt@
	DB	046H
	ORG $+3
	DD	FLAT:??_C@_03HPMOIGGE@mip@
	DB	043H
	ORG $+3
	DD	FLAT:??_C@_03CLFHJCDC@txt@
	DB	044H
	ORG $+3
	DD	00H
	DB	00H
	ORG $+3
CONST	ENDS
PUBLIC	_FS_Init
PUBLIC	_FS_Rescan
PUBLIC	_FS_Shutdown
PUBLIC	_FS_ClearSearchPath
PUBLIC	_FS_AllowDirectPaths
PUBLIC	_FS_AddGameDirectory
PUBLIC	_FS_AddGameHierarchy
PUBLIC	_FS_LoadGameInfo
PUBLIC	_FS_GetDiskPath
PUBLIC	_W_Close
PUBLIC	_FS_LoadFile
PUBLIC	_FS_WriteFile
PUBLIC	_FS_Search
PUBLIC	_FS_Open
PUBLIC	_FS_Write
PUBLIC	_FS_Read
PUBLIC	_FS_VPrintf
PUBLIC	_FS_Seek
PUBLIC	_FS_Gets
PUBLIC	_FS_Printf
PUBLIC	_FS_FileSize
PUBLIC	_FS_FileTime
PUBLIC	_FS_Print
PUBLIC	_FS_Rename
PUBLIC	_FS_FileExists
PUBLIC	_FS_FileCopy
PUBLIC	_FS_Delete
PUBLIC	_FS_UnGetc
PUBLIC	_FS_Tell
PUBLIC	_FS_Eof
PUBLIC	_FS_Close
PUBLIC	_FS_Getc
PUBLIC	_FS_FileLength
PUBLIC	_FS_FindLibrary
PUBLIC	_FS_CreatePath
PUBLIC	_FS_Path_f
PUBLIC	_FS_ClearPaths_f
PUBLIC	_FS_LoadPackPAK
PUBLIC	_FS_CheckNastyPath
PUBLIC	_FS_Rescan_f
PUBLIC	_FS_CreateDefaultGameInfo
PUBLIC	_FS_ConvertGameInfo
PUBLIC	_FS_OpenPackedFile
PUBLIC	_FS_OpenReadFile
PUBLIC	_FS_CheckForCrypt
PUBLIC	_W_ReadLump
PUBLIC	?__LINE__Var@?0??stringlistfreecontents@@9@9	; `stringlistfreecontents'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??stringlistappend@@9@9		; `stringlistappend'::`1'::__LINE__Var
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_C@_0DM@MIMLIMFB@?$FO3Warning?3?$FO7?5package?5?$CFs?5contain@ ; `string'
PUBLIC	??_C@_0BG@HPKHMA@Current?5search?5path?3?6@	; `string'
PUBLIC	??_C@_0O@GBEHFLEC@?$CFs?5?$CI?$CFi?5files?$CJ@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0O@LJLKKPKG@?5?$FO2gamedir?$FO7?6@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	?__LINE__Var@?0??FS_LoadPackPAK@@9@9		; `FS_LoadPackPAK'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@JIPKDBIA@?$CFs?5couldn?8t?5open?6@	; `string'
PUBLIC	??_C@_0CA@LADEPGED@?$CFs?5is?5not?5a?5packfile?4?5Ignored?4?6@ ; `string'
PUBLIC	??_C@_0CM@FFLJPGIM@?$CFs?5has?5an?5invalid?5directory?5siz@ ; `string'
PUBLIC	??_C@_0DD@OEIIDGKH@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5file@ ; `string'
PUBLIC	??_C@_0BL@KDGPBPGC@?$CFs?5has?5no?5files?4?5Ignored?4?6@ ; `string'
PUBLIC	??_C@_0CG@MPMJLKCJ@?$CFs?5is?5an?5incomplete?5PAK?0?5not?5lo@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_AddWad_Fullpath@@9@9	; `FS_AddWad_Fullpath'::`1'::__LINE__Var
PUBLIC	??_C@_03GANHLHHC@wad@				; `string'
PUBLIC	??_C@_0BP@PEBJBKDC@Adding?5wadfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@ ; `string'
PUBLIC	??_C@_0DI@BHOLMLCD@?$FO1Error?3?$FO7?5FS_AddWad_Fullpath?3?5@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_AddPak_Fullpath@@9@9	; `FS_AddPak_Fullpath'::`1'::__LINE__Var
PUBLIC	??_C@_03HKJIJDAE@pak@				; `string'
PUBLIC	??_C@_0BP@BJJLDFAF@Adding?5pakfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@ ; `string'
PUBLIC	??_C@_05GFOLEBJA@?$CFs?1?$CFs@			; `string'
PUBLIC	??_C@_0DI@PGENDCEJ@?$FO1Error?3?$FO7?5FS_AddPak_Fullpath?3?5@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_AddGameDirectory@@9@9	; `FS_AddGameDirectory'::`1'::__LINE__Var
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs@			; `string'
PUBLIC	??_C@_03NPMJBIL@?$CFs?1@			; `string'
PUBLIC	?__LINE__Var@?0??FS_ClearSearchPath@@9@9	; `FS_ClearSearchPath'::`1'::__LINE__Var
PUBLIC	??_C@_01JLIPDDHJ@?3@				; `string'
PUBLIC	??_C@_02CBLDBPFN@?1?1@				; `string'
PUBLIC	??_C@_02DIKICOBM@?1?4@				; `string'
PUBLIC	??_C@_0BB@HDEBADIB@FS_Rescan?$CI?5?$CFs?5?$CJ?6@ ; `string'
PUBLIC	??_C@_05POGGAMJB@?$CFs?4rc@			; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CC@DJANCFLM@FS_WriteGameInfo?3?5can?8t?5write?5?$CF@ ; `string'
PUBLIC	??_C@_0BK@PKJNFFLK@?1?1?5generated?5by?5Xash3D?6?6?6@ ; `string'
PUBLIC	??_C@_0P@GBNGDPD@basedir?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0P@HLHLHHBC@gamedir?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BD@PBLNEELD@fallback_dir?7?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0N@NNNHNHFF@title?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BA@KBAEEJPG@startmap?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BA@MLOGHJJF@trainmap?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0N@MJFNDPFP@version?7?7?$CFg?6@		; `string'
PUBLIC	??_C@_09BFMPAEGH@size?7?7?$CFi?6@		; `string'
PUBLIC	??_C@_0BA@JDHLDPK@url_info?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BC@LHNCJDKE@url_update?7?7?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0M@LHIKIBNJ@type?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0M@KGEMOJNB@date?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0P@ODIEAKM@dllpath?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0P@PJFACFLF@gamedll?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0M@DNJELFDM@icon?7?7?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BP@PICPAFDH@gamemode?7?7?$CCsingleplayer_only?$CC?6@ ; `string'
PUBLIC	??_C@_0BO@KCLFKGLF@gamemode?7?7?$CCmultiplayer_only?$CC?6@ ; `string'
PUBLIC	??_C@_0BB@CGGLFFDE@sp_entity?7?7?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BB@HABODENP@mp_entity?7?7?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BB@FEEDHBJJ@mp_filter?7?7?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0O@NBPNDANA@secure?7?7?$CC?$CFi?$CC?6@	; `string'
PUBLIC	??_C@_0BA@EICNFHDO@nomodels?7?7?$CC?$CFi?$CC?6@	; `string'
PUBLIC	??_C@_0P@MMHJGPOE@max_edicts?7?$CFi?6@		; `string'
PUBLIC	??_C@_0BB@LOIMAEMI@max_tempents?7?$CFi?6@	; `string'
PUBLIC	??_C@_0P@MLMMLBFK@max_beams?7?7?$CFi?6@		; `string'
PUBLIC	??_C@_0BC@NFGDAGD@max_particles?7?$CFi?6@	; `string'
PUBLIC	??_C@_0P@MOGLAPLP@ambient?$CFi?7?7?$CFs?6@	; `string'
PUBLIC	??_C@_03EGHOKNNL@?6?6?6@			; `string'
PUBLIC	??_C@_08IIACKFCG@New?5Game@			; `string'
PUBLIC	??_C@_0BC@IHPKIKNE@info_player_start@		; `string'
PUBLIC	??_C@_0BH@IGAFCIL@info_player_deathmatch@	; `string'
PUBLIC	??_C@_07CNOKJKDK@cl_dlls@			; `string'
PUBLIC	??_C@_0M@FCEMCLHB@dlls?1hl?4dll@		; `string'
PUBLIC	??_C@_06FLHECDA@newmap@				; `string'
PUBLIC	??_C@_08BPMGDPCI@game?4ico@			; `string'
PUBLIC	?__LINE__Var@?0??FS_ParseLiblistGam@@9@9	; `FS_ParseLiblistGam'::`1'::__LINE__Var
PUBLIC	??_C@_04MJNAPEEI@game@				; `string'
PUBLIC	??_C@_07GGMBKBFD@gamedir@			; `string'
PUBLIC	??_C@_0N@JOMOAPOL@fallback_dir@			; `string'
PUBLIC	??_C@_08DANNNBIA@startmap@			; `string'
PUBLIC	??_C@_08NBJCMILF@trainmap@			; `string'
PUBLIC	??_C@_0M@KGAILJGP@trainingmap@			; `string'
PUBLIC	??_C@_08BNJNDCGD@url_info@			; `string'
PUBLIC	??_C@_06NDBDLBCI@url_dl@			; `string'
PUBLIC	??_C@_07LEELFMGH@gamedll@			; `string'
PUBLIC	??_C@_04DMJJIPAH@icon@				; `string'
PUBLIC	??_C@_04KJPGCDBP@?4ico@				; `string'
PUBLIC	??_C@_04GPMDFGEJ@type@				; `string'
PUBLIC	??_C@_0BC@KBHPDGLE@singleplayer_only@		; `string'
PUBLIC	??_C@_06IGOBCGAJ@Single@			; `string'
PUBLIC	??_C@_0BB@PCDEEONN@multiplayer_only@		; `string'
PUBLIC	??_C@_0M@HOINAANG@Multiplayer@			; `string'
PUBLIC	??_C@_07CPCPJPKL@version@			; `string'
PUBLIC	??_C@_04IAGNFIBA@size@				; `string'
PUBLIC	??_C@_06MCCDKJOH@edicts@			; `string'
PUBLIC	??_C@_08BEIDONOP@mpentity@			; `string'
PUBLIC	??_C@_08DEJNIEEH@mpfilter@			; `string'
PUBLIC	??_C@_06CKKGAKDB@secure@			; `string'
PUBLIC	??_C@_08LCMKFNBH@nomodels@			; `string'
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs@			; `string'
PUBLIC	??_C@_0BC@LBDHMDCA@Convert?5?$CFs?5to?5?$CFs?6@	; `string'
PUBLIC	?__LINE__Var@?0??FS_ReadGameInfo@@9@9		; `FS_ReadGameInfo'::`1'::__LINE__Var
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07BHPNMMNM@basedir@			; `string'
PUBLIC	??_C@_05PHLGJONK@title@				; `string'
PUBLIC	??_C@_09HBKHHKHA@sp_entity@			; `string'
PUBLIC	??_C@_09EIMAMLCL@mp_entity@			; `string'
PUBLIC	??_C@_09GINOKCID@mp_filter@			; `string'
PUBLIC	??_C@_07HJMIDGON@dllpath@			; `string'
PUBLIC	??_C@_0L@MOMIJKBF@url_update@			; `string'
PUBLIC	??_C@_04JNIHBGGH@date@				; `string'
PUBLIC	??_C@_0L@FGNAPDKD@max_edicts@			; `string'
PUBLIC	??_C@_0N@PJLMDBP@max_tempents@			; `string'
PUBLIC	??_C@_09KDFCKJJ@max_beams@			; `string'
PUBLIC	??_C@_0O@IOJCOOJJ@max_particles@		; `string'
PUBLIC	??_C@_08NKFOLMGC@gamemode@			; `string'
PUBLIC	??_C@_08JLCCHDKJ@noskills@			; `string'
PUBLIC	??_C@_07LIABELBC@ambient@			; `string'
PUBLIC	??_C@_0O@FLLMCNCO@?$CFs?1config?4cfg@		; `string'
PUBLIC	??_C@_0N@DCOJFEIC@?$CFs?1progs?4dat@		; `string'
PUBLIC	??_C@_0M@GGNFKHBH@?$CFs?1pak0?4pak@		; `string'
PUBLIC	??_C@_0BA@DBHCOEMC@?$CFs?1gameinfo?4txt@	; `string'
PUBLIC	??_C@_0P@DLDLIPEJ@?$CFs?1liblist?4gam@		; `string'
PUBLIC	??_C@_0BH@JLKJEDOD@FS_LoadGameInfo?$CI?5?$CFs?5?$CJ?6@ ; `string'
PUBLIC	??_C@_0CD@LMLILLCA@Couldn?8t?5find?5game?5directory?5?8?$CF@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_Init@@9@9			; `FS_Init'::`1'::__LINE__Var
PUBLIC	??_C@_0CA@EIAOIINE@rescan?5filesystem?5search?5pathes@ ; `string'
PUBLIC	??_C@_09IDOAIHOD@fs_rescan@			; `string'
PUBLIC	??_C@_0BO@PHBKKHIG@show?5filesystem?5search?5pathes@ ; `string'
PUBLIC	??_C@_07CIJFKILE@fs_path@			; `string'
PUBLIC	??_C@_0BP@OFHIELJN@clear?5filesystem?5search?5pathes@ ; `string'
PUBLIC	??_C@_0O@GJNOPCMB@fs_clearpaths@		; `string'
PUBLIC	??_C@_02CAHBHFGK@?4?1@				; `string'
PUBLIC	??_C@_05FACLEBO@?9game@				; `string'
PUBLIC	??_C@_0BN@NAFMHBKB@invalid?5base?5directory?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0CI@LFHJFHBE@?$FO1Error?3?$FO7?5invalid?5game?5directo@ ; `string'
PUBLIC	??_C@_0CK@JLLJKMCN@?$FO1Error?3?$FO7?5game?5directory?5?$CC?$CFs?$CC?5@ ; `string'
PUBLIC	??_C@_0P@KGNFGICB@FS_Init?3?5done?6@		; `string'
PUBLIC	?__LINE__Var@?0??FS_Shutdown@@9@9		; `FS_Shutdown'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_SysOpen@@9@9		; `FS_SysOpen'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_OpenPackedFile@@9@9		; `FS_OpenPackedFile'::`1'::__LINE__Var
PUBLIC	??_C@_04PJEAAOBG@?4wad@				; `string'
PUBLIC	??_C@_04HMIIHGGM@Path@				; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	?__LINE__Var@?0??FS_Close@@9@9			; `FS_Close'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_VPrintf@@9@9		; `FS_VPrintf'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??FS_LoadFile@@9@9		; `FS_LoadFile'::`1'::__LINE__Var
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0CH@GDMAKCLD@?$FO1Error?3?$FO7?5FS_WriteFile?3?5failed@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_FindLibrary@@9@9		; `FS_FindLibrary'::`1'::__LINE__Var
PUBLIC	??_C@_09DMPFMCD@?4?4?2valve?2@			; `string'
PUBLIC	??_C@_09CFACOAGF@?4?4?1valve?1@			; `string'
PUBLIC	??_C@_04HLONOPDM@?4dll@				; `string'
PUBLIC	?__LINE__Var@?0??FS_FileCopy@@9@9		; `FS_FileCopy'::`1'::__LINE__Var
PUBLIC	??_C@_0EA@KLBAKJBF@?$FO1Error?3?$FO7?5FS_FileCopy?3?5unexpec@ ; `string'
PUBLIC	?__LINE__Var@?0??FS_Search@@9@9			; `FS_Search'::`1'::__LINE__Var
PUBLIC	??_C@_03KEMCFGNA@?4?$CFs@			; `string'
PUBLIC	?__LINE__Var@?0??FS_InitMemory@@9@9		; `FS_InitMemory'::`1'::__LINE__Var
PUBLIC	??_C@_0BA@DFPLEAFN@FileSystem?5Pool@		; `string'
PUBLIC	??_C@_0DI@CDLODMBO@?$FO3Warning?3?$FO7?5Wad?5?$CFs?5contains?5th@ ; `string'
PUBLIC	?__LINE__Var@?0??W_ReadLump@@9@9		; `W_ReadLump'::`1'::__LINE__Var
PUBLIC	??_C@_0CI@KKBIJNIM@?$FO1Error?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5co@ ; `string'
PUBLIC	??_C@_0DD@JBDLBDGJ@?$FO3Warning?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5@ ; `string'
PUBLIC	?__LINE__Var@?0??W_Open@@9@9			; `W_Open'::`1'::__LINE__Var
PUBLIC	??_C@_0CF@PKAMBGCM@?$FO1Error?3?$FO7?5W_Open?3?5couldn?8t?5ope@ ; `string'
PUBLIC	??_C@_0CJ@EHANGNHD@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5rea@ ; `string'
PUBLIC	??_C@_0DC@CBDAMJEM@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5is?5not?5a?5@ ; `string'
PUBLIC	??_C@_0CM@OECBKKFN@?$FO3Warning?3?$FO7?5W_Open?3?5?$CFs?5is?5full@ ; `string'
PUBLIC	??_C@_0CE@CCELBKNC@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5has?5no?5lu@ ; `string'
PUBLIC	??_C@_0DI@FIBBLIHJ@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5fin@ ; `string'
PUBLIC	??_C@_0EE@HFFLALIL@?$FO1Error?3?$FO7?5W_ReadLumpTable?3?5?$CFs?5@ ; `string'
PUBLIC	??_C@_08FJIFJEIK@conchars@			; `string'
PUBLIC	?__LINE__Var@?0??W_Close@@9@9			; `W_Close'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___mkdir:PROC
EXTRN	__imp___stat64i32:PROC
EXTRN	__imp___findclose:PROC
EXTRN	__imp__remove:PROC
EXTRN	__imp__rename:PROC
EXTRN	__imp___findfirst64i32:PROC
EXTRN	__imp___findnext64i32:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__dup:PROC
EXTRN	__imp__lseek:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__write:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__getenv:PROC
EXTRN	_Sys_Error:PROC
EXTRN	__Sys_GetParmFromCmdLine:PROC
EXTRN	_Cmd_AddCommand:PROC
EXTRN	_Q_strnlwr:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strchr:PROC
EXTRN	_Q_strrchr:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_strncmp:PROC
EXTRN	_Q_strstr:PROC
EXTRN	_Q_vsnprintf:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Realloc:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_AllocPool:PROC
EXTRN	__Mem_FreePool:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_COM_FileBase:PROC
EXTRN	_COM_FileExtension:PROC
EXTRN	_COM_DefaultExtension:PROC
EXTRN	_COM_ExtractFilePath:PROC
EXTRN	_COM_FileWithoutPath:PROC
EXTRN	_COM_FixSlashes:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_Image_CheckPaletteQ1:PROC
EXTRN	_Host_InitDecals:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??W_Close@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??W_Close@@9@9 DD 0c28H			; `W_Close'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08FJIFJEIK@conchars@
CONST	SEGMENT
??_C@_08FJIFJEIK@conchars@ DB 'conchars', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@HFFLALIL@?$FO1Error?3?$FO7?5W_ReadLumpTable?3?5?$CFs?5@
CONST	SEGMENT
??_C@_0EE@HFFLALIL@?$FO1Error?3?$FO7?5W_ReadLumpTable?3?5?$CFs?5@ DB '^1E'
	DB	'rror:^7 W_ReadLumpTable: %s has corrupted lump allocation tab'
	DB	'le', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FIBBLIHJ@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5fin@
CONST	SEGMENT
??_C@_0DI@FIBBLIHJ@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5fin@ DB '^'
	DB	'1Error:^7 W_Open: %s can''t find lump allocation table', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CCELBKNC@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5has?5no?5lu@
CONST	SEGMENT
??_C@_0CE@CCELBKNC@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5has?5no?5lu@ DB '^'
	DB	'1Error:^7 W_Open: %s has no lumps', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OECBKKFN@?$FO3Warning?3?$FO7?5W_Open?3?5?$CFs?5is?5full@
CONST	SEGMENT
??_C@_0CM@OECBKKFN@?$FO3Warning?3?$FO7?5W_Open?3?5?$CFs?5is?5full@ DB '^3'
	DB	'Warning:^7 W_Open: %s is full (%i lumps)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CBDAMJEM@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5is?5not?5a?5@
CONST	SEGMENT
??_C@_0DC@CBDAMJEM@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5is?5not?5a?5@ DB '^'
	DB	'1Error:^7 W_Open: %s is not a WAD2 or WAD3 file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EHANGNHD@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5rea@
CONST	SEGMENT
??_C@_0CJ@EHANGNHD@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5rea@ DB '^'
	DB	'1Error:^7 W_Open: %s can''t read header', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PKAMBGCM@?$FO1Error?3?$FO7?5W_Open?3?5couldn?8t?5ope@
CONST	SEGMENT
??_C@_0CF@PKAMBGCM@?$FO1Error?3?$FO7?5W_Open?3?5couldn?8t?5ope@ DB '^1Err'
	DB	'or:^7 W_Open: couldn''t open %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??W_Open@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??W_Open@@9@9 DD 0bb1H			; `W_Open'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DD@JBDLBDGJ@?$FO3Warning?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5@
CONST	SEGMENT
??_C@_0DD@JBDLBDGJ@?$FO3Warning?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5@ DB '^3'
	DB	'Warning:^7 W_ReadLump: %s is probably corrupted', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KKBIJNIM@?$FO1Error?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5co@
CONST	SEGMENT
??_C@_0CI@KKBIJNIM@?$FO1Error?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5co@ DB '^1'
	DB	'Error:^7 W_ReadLump: %s is corrupted', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??W_ReadLump@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??W_ReadLump@@9@9 DD 0b7eH		; `W_ReadLump'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@CDLODMBO@?$FO3Warning?3?$FO7?5Wad?5?$CFs?5contains?5th@
CONST	SEGMENT
??_C@_0DI@CDLODMBO@?$FO3Warning?3?$FO7?5Wad?5?$CFs?5contains?5th@ DB '^3W'
	DB	'arning:^7 Wad %s contains the file %s several times', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DFPLEAFN@FileSystem?5Pool@
CONST	SEGMENT
??_C@_0BA@DFPLEAFN@FileSystem?5Pool@ DB 'FileSystem Pool', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_InitMemory@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_InitMemory@@9@9 DD 0ad6H		; `FS_InitMemory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03KEMCFGNA@?4?$CFs@
CONST	SEGMENT
??_C@_03KEMCFGNA@?4?$CFs@ DB '.%s', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_Search@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_Search@@9@9 DD 0a04H		; `FS_Search'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EA@KLBAKJBF@?$FO1Error?3?$FO7?5FS_FileCopy?3?5unexpec@
CONST	SEGMENT
??_C@_0EA@KLBAKJBF@?$FO1Error?3?$FO7?5FS_FileCopy?3?5unexpec@ DB '^1Error'
	DB	':^7 FS_FileCopy: unexpected end of input file (%d < %d)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_FileCopy@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_FileCopy@@9@9 DD 09e1H		; `FS_FileCopy'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04HLONOPDM@?4dll@
CONST	SEGMENT
??_C@_04HLONOPDM@?4dll@ DB '.dll', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFACOAGF@?4?4?1valve?1@
CONST	SEGMENT
??_C@_09CFACOAGF@?4?4?1valve?1@ DB '../valve/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DMPFMCD@?4?4?2valve?2@
CONST	SEGMENT
??_C@_09DMPFMCD@?4?4?2valve?2@ DB '..\valve\', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_FindLibrary@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_FindLibrary@@9@9 DD 0923H		; `FS_FindLibrary'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CH@GDMAKCLD@?$FO1Error?3?$FO7?5FS_WriteFile?3?5failed@
CONST	SEGMENT
??_C@_0CH@GDMAKCLD@?$FO1Error?3?$FO7?5FS_WriteFile?3?5failed@ DB '^1Error'
	DB	':^7 FS_WriteFile: failed on %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_LoadFile@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_LoadFile@@9@9 DD 08a3H		; `FS_LoadFile'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_VPrintf@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_VPrintf@@9@9 DD 07e8H		; `FS_VPrintf'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_Close@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_Close@@9@9 DD 0744H			; `FS_Close'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMIIHGGM@Path@
CONST	SEGMENT
??_C@_04HMIIHGGM@Path@ DB 'Path', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJEAAOBG@?4wad@
CONST	SEGMENT
??_C@_04PJEAAOBG@?4wad@ DB '.wad', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_OpenPackedFile@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_OpenPackedFile@@9@9 DD 061eH	; `FS_OpenPackedFile'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_SysOpen@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_SysOpen@@9@9 DD 05d6H		; `FS_SysOpen'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??FS_Shutdown@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_Shutdown@@9@9 DD 05b0H		; `FS_Shutdown'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0P@KGNFGICB@FS_Init?3?5done?6@
CONST	SEGMENT
??_C@_0P@KGNFGICB@FS_Init?3?5done?6@ DB 'FS_Init: done', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JLLJKMCN@?$FO1Error?3?$FO7?5game?5directory?5?$CC?$CFs?$CC?5@
CONST	SEGMENT
??_C@_0CK@JLLJKMCN@?$FO1Error?3?$FO7?5game?5directory?5?$CC?$CFs?$CC?5@ DB '^'
	DB	'1Error:^7 game directory "%s" not exist', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LFHJFHBE@?$FO1Error?3?$FO7?5invalid?5game?5directo@
CONST	SEGMENT
??_C@_0CI@LFHJFHBE@?$FO1Error?3?$FO7?5invalid?5game?5directo@ DB '^1Error'
	DB	':^7 invalid game directory "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NAFMHBKB@invalid?5base?5directory?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BN@NAFMHBKB@invalid?5base?5directory?5?$CC?$CFs?$CC?6@ DB 'invalid'
	DB	' base directory "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FACLEBO@?9game@
CONST	SEGMENT
??_C@_05FACLEBO@?9game@ DB '-game', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CAHBHFGK@?4?1@
CONST	SEGMENT
??_C@_02CAHBHFGK@?4?1@ DB './', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GJNOPCMB@fs_clearpaths@
CONST	SEGMENT
??_C@_0O@GJNOPCMB@fs_clearpaths@ DB 'fs_clearpaths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFHIELJN@clear?5filesystem?5search?5pathes@
CONST	SEGMENT
??_C@_0BP@OFHIELJN@clear?5filesystem?5search?5pathes@ DB 'clear filesyste'
	DB	'm search pathes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIJFKILE@fs_path@
CONST	SEGMENT
??_C@_07CIJFKILE@fs_path@ DB 'fs_path', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PHBKKHIG@show?5filesystem?5search?5pathes@
CONST	SEGMENT
??_C@_0BO@PHBKKHIG@show?5filesystem?5search?5pathes@ DB 'show filesystem '
	DB	'search pathes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDOAIHOD@fs_rescan@
CONST	SEGMENT
??_C@_09IDOAIHOD@fs_rescan@ DB 'fs_rescan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EIAOIINE@rescan?5filesystem?5search?5pathes@
CONST	SEGMENT
??_C@_0CA@EIAOIINE@rescan?5filesystem?5search?5pathes@ DB 'rescan filesys'
	DB	'tem search pathes', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_Init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_Init@@9@9 DD 055fH			; `FS_Init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CD@LMLILLCA@Couldn?8t?5find?5game?5directory?5?8?$CF@
CONST	SEGMENT
??_C@_0CD@LMLILLCA@Couldn?8t?5find?5game?5directory?5?8?$CF@ DB 'Couldn'''
	DB	't find game directory ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JLKJEDOD@FS_LoadGameInfo?$CI?5?$CFs?5?$CJ?6@
CONST	SEGMENT
??_C@_0BH@JLKJEDOD@FS_LoadGameInfo?$CI?5?$CFs?5?$CJ?6@ DB 'FS_LoadGameInf'
	DB	'o( %s )', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLDLIPEJ@?$CFs?1liblist?4gam@
CONST	SEGMENT
??_C@_0P@DLDLIPEJ@?$CFs?1liblist?4gam@ DB '%s/liblist.gam', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DBHCOEMC@?$CFs?1gameinfo?4txt@
CONST	SEGMENT
??_C@_0BA@DBHCOEMC@?$CFs?1gameinfo?4txt@ DB '%s/gameinfo.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGNFKHBH@?$CFs?1pak0?4pak@
CONST	SEGMENT
??_C@_0M@GGNFKHBH@?$CFs?1pak0?4pak@ DB '%s/pak0.pak', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCOJFEIC@?$CFs?1progs?4dat@
CONST	SEGMENT
??_C@_0N@DCOJFEIC@?$CFs?1progs?4dat@ DB '%s/progs.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLLMCNCO@?$CFs?1config?4cfg@
CONST	SEGMENT
??_C@_0O@FLLMCNCO@?$CFs?1config?4cfg@ DB '%s/config.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIABELBC@ambient@
CONST	SEGMENT
??_C@_07LIABELBC@ambient@ DB 'ambient', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLCCHDKJ@noskills@
CONST	SEGMENT
??_C@_08JLCCHDKJ@noskills@ DB 'noskills', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NKFOLMGC@gamemode@
CONST	SEGMENT
??_C@_08NKFOLMGC@gamemode@ DB 'gamemode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IOJCOOJJ@max_particles@
CONST	SEGMENT
??_C@_0O@IOJCOOJJ@max_particles@ DB 'max_particles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDFCKJJ@max_beams@
CONST	SEGMENT
??_C@_09KDFCKJJ@max_beams@ DB 'max_beams', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJLMDBP@max_tempents@
CONST	SEGMENT
??_C@_0N@PJLMDBP@max_tempents@ DB 'max_tempents', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FGNAPDKD@max_edicts@
CONST	SEGMENT
??_C@_0L@FGNAPDKD@max_edicts@ DB 'max_edicts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNIHBGGH@date@
CONST	SEGMENT
??_C@_04JNIHBGGH@date@ DB 'date', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOMIJKBF@url_update@
CONST	SEGMENT
??_C@_0L@MOMIJKBF@url_update@ DB 'url_update', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HJMIDGON@dllpath@
CONST	SEGMENT
??_C@_07HJMIDGON@dllpath@ DB 'dllpath', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GINOKCID@mp_filter@
CONST	SEGMENT
??_C@_09GINOKCID@mp_filter@ DB 'mp_filter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EIMAMLCL@mp_entity@
CONST	SEGMENT
??_C@_09EIMAMLCL@mp_entity@ DB 'mp_entity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBKHHKHA@sp_entity@
CONST	SEGMENT
??_C@_09HBKHHKHA@sp_entity@ DB 'sp_entity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title@
CONST	SEGMENT
??_C@_05PHLGJONK@title@ DB 'title', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHPNMMNM@basedir@
CONST	SEGMENT
??_C@_07BHPNMMNM@basedir@ DB 'basedir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_ReadGameInfo@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_ReadGameInfo@@9@9 DD 043fH		; `FS_ReadGameInfo'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@LBDHMDCA@Convert?5?$CFs?5to?5?$CFs?6@
CONST	SEGMENT
??_C@_0BC@LBDHMDCA@Convert?5?$CFs?5to?5?$CFs?6@ DB 'Convert %s to %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs@ DB '%s\%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LCMKFNBH@nomodels@
CONST	SEGMENT
??_C@_08LCMKFNBH@nomodels@ DB 'nomodels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKKGAKDB@secure@
CONST	SEGMENT
??_C@_06CKKGAKDB@secure@ DB 'secure', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DEJNIEEH@mpfilter@
CONST	SEGMENT
??_C@_08DEJNIEEH@mpfilter@ DB 'mpfilter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BEIDONOP@mpentity@
CONST	SEGMENT
??_C@_08BEIDONOP@mpentity@ DB 'mpentity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MCCDKJOH@edicts@
CONST	SEGMENT
??_C@_06MCCDKJOH@edicts@ DB 'edicts', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size@
CONST	SEGMENT
??_C@_04IAGNFIBA@size@ DB 'size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version@
CONST	SEGMENT
??_C@_07CPCPJPKL@version@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOINAANG@Multiplayer@
CONST	SEGMENT
??_C@_0M@HOINAANG@Multiplayer@ DB 'Multiplayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCDEEONN@multiplayer_only@
CONST	SEGMENT
??_C@_0BB@PCDEEONN@multiplayer_only@ DB 'multiplayer_only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGOBCGAJ@Single@
CONST	SEGMENT
??_C@_06IGOBCGAJ@Single@ DB 'Single', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBHPDGLE@singleplayer_only@
CONST	SEGMENT
??_C@_0BC@KBHPDGLE@singleplayer_only@ DB 'singleplayer_only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type@ DB 'type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJPGCDBP@?4ico@
CONST	SEGMENT
??_C@_04KJPGCDBP@?4ico@ DB '.ico', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMJJIPAH@icon@
CONST	SEGMENT
??_C@_04DMJJIPAH@icon@ DB 'icon', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEELFMGH@gamedll@
CONST	SEGMENT
??_C@_07LEELFMGH@gamedll@ DB 'gamedll', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDBDLBCI@url_dl@
CONST	SEGMENT
??_C@_06NDBDLBCI@url_dl@ DB 'url_dl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNJNDCGD@url_info@
CONST	SEGMENT
??_C@_08BNJNDCGD@url_info@ DB 'url_info', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGAILJGP@trainingmap@
CONST	SEGMENT
??_C@_0M@KGAILJGP@trainingmap@ DB 'trainingmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NBJCMILF@trainmap@
CONST	SEGMENT
??_C@_08NBJCMILF@trainmap@ DB 'trainmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DANNNBIA@startmap@
CONST	SEGMENT
??_C@_08DANNNBIA@startmap@ DB 'startmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOMOAPOL@fallback_dir@
CONST	SEGMENT
??_C@_0N@JOMOAPOL@fallback_dir@ DB 'fallback_dir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGMBKBFD@gamedir@
CONST	SEGMENT
??_C@_07GGMBKBFD@gamedir@ DB 'gamedir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MJNAPEEI@game@
CONST	SEGMENT
??_C@_04MJNAPEEI@game@ DB 'game', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_ParseLiblistGam@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_ParseLiblistGam@@9@9 DD 039dH	; `FS_ParseLiblistGam'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08BPMGDPCI@game?4ico@
CONST	SEGMENT
??_C@_08BPMGDPCI@game?4ico@ DB 'game.ico', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FLHECDA@newmap@
CONST	SEGMENT
??_C@_06FLHECDA@newmap@ DB 'newmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCEMCLHB@dlls?1hl?4dll@
CONST	SEGMENT
??_C@_0M@FCEMCLHB@dlls?1hl?4dll@ DB 'dlls/hl.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNOKJKDK@cl_dlls@
CONST	SEGMENT
??_C@_07CNOKJKDK@cl_dlls@ DB 'cl_dlls', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IGAFCIL@info_player_deathmatch@
CONST	SEGMENT
??_C@_0BH@IGAFCIL@info_player_deathmatch@ DB 'info_player_deathmatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHPKIKNE@info_player_start@
CONST	SEGMENT
??_C@_0BC@IHPKIKNE@info_player_start@ DB 'info_player_start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIACKFCG@New?5Game@
CONST	SEGMENT
??_C@_08IIACKFCG@New?5Game@ DB 'New Game', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EGHOKNNL@?6?6?6@
CONST	SEGMENT
??_C@_03EGHOKNNL@?6?6?6@ DB 0aH, 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOGLAPLP@ambient?$CFi?7?7?$CFs?6@
CONST	SEGMENT
??_C@_0P@MOGLAPLP@ambient?$CFi?7?7?$CFs?6@ DB 'ambient%i', 09H, 09H, '%s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NFGDAGD@max_particles?7?$CFi?6@
CONST	SEGMENT
??_C@_0BC@NFGDAGD@max_particles?7?$CFi?6@ DB 'max_particles', 09H, '%i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLMMLBFK@max_beams?7?7?$CFi?6@
CONST	SEGMENT
??_C@_0P@MLMMLBFK@max_beams?7?7?$CFi?6@ DB 'max_beams', 09H, 09H, '%i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LOIMAEMI@max_tempents?7?$CFi?6@
CONST	SEGMENT
??_C@_0BB@LOIMAEMI@max_tempents?7?$CFi?6@ DB 'max_tempents', 09H, '%i', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MMHJGPOE@max_edicts?7?$CFi?6@
CONST	SEGMENT
??_C@_0P@MMHJGPOE@max_edicts?7?$CFi?6@ DB 'max_edicts', 09H, '%i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EICNFHDO@nomodels?7?7?$CC?$CFi?$CC?6@
CONST	SEGMENT
??_C@_0BA@EICNFHDO@nomodels?7?7?$CC?$CFi?$CC?6@ DB 'nomodels', 09H, 09H, '"'
	DB	'%i"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBPNDANA@secure?7?7?$CC?$CFi?$CC?6@
CONST	SEGMENT
??_C@_0O@NBPNDANA@secure?7?7?$CC?$CFi?$CC?6@ DB 'secure', 09H, 09H, '"%i"'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FEEDHBJJ@mp_filter?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BB@FEEDHBJJ@mp_filter?7?7?$CC?$CFs?$CC?6@ DB 'mp_filter', 09H, 09H
	DB	'"%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HABODENP@mp_entity?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BB@HABODENP@mp_entity?7?7?$CC?$CFs?$CC?6@ DB 'mp_entity', 09H, 09H
	DB	'"%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CGGLFFDE@sp_entity?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BB@CGGLFFDE@sp_entity?7?7?$CC?$CFs?$CC?6@ DB 'sp_entity', 09H, 09H
	DB	'"%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KCLFKGLF@gamemode?7?7?$CCmultiplayer_only?$CC?6@
CONST	SEGMENT
??_C@_0BO@KCLFKGLF@gamemode?7?7?$CCmultiplayer_only?$CC?6@ DB 'gamemode', 09H
	DB	09H, '"multiplayer_only"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PICPAFDH@gamemode?7?7?$CCsingleplayer_only?$CC?6@
CONST	SEGMENT
??_C@_0BP@PICPAFDH@gamemode?7?7?$CCsingleplayer_only?$CC?6@ DB 'gamemode', 09H
	DB	09H, '"singleplayer_only"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DNJELFDM@icon?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0M@DNJELFDM@icon?7?7?$CC?$CFs?$CC?6@ DB 'icon', 09H, 09H, '"%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PJFACFLF@gamedll?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@PJFACFLF@gamedll?7?7?$CC?$CFs?$CC?6@ DB 'gamedll', 09H, 09H, '"%'
	DB	's"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ODIEAKM@dllpath?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@ODIEAKM@dllpath?7?7?$CC?$CFs?$CC?6@ DB 'dllpath', 09H, 09H, '"%s'
	DB	'"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KGEMOJNB@date?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0M@KGEMOJNB@date?7?7?$CC?$CFs?$CC?6@ DB 'date', 09H, 09H, '"%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHIKIBNJ@type?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0M@LHIKIBNJ@type?7?7?$CC?$CFs?$CC?6@ DB 'type', 09H, 09H, '"%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LHNCJDKE@url_update?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BC@LHNCJDKE@url_update?7?7?$CC?$CFs?$CC?6@ DB 'url_update', 09H, 09H
	DB	'"%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDHLDPK@url_info?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BA@JDHLDPK@url_info?7?7?$CC?$CFs?$CC?6@ DB 'url_info', 09H, 09H, '"'
	DB	'%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFMPAEGH@size?7?7?$CFi?6@
CONST	SEGMENT
??_C@_09BFMPAEGH@size?7?7?$CFi?6@ DB 'size', 09H, 09H, '%i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MJFNDPFP@version?7?7?$CFg?6@
CONST	SEGMENT
??_C@_0N@MJFNDPFP@version?7?7?$CFg?6@ DB 'version', 09H, 09H, '%g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MLOGHJJF@trainmap?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BA@MLOGHJJF@trainmap?7?7?$CC?$CFs?$CC?6@ DB 'trainmap', 09H, 09H, '"'
	DB	'%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KBAEEJPG@startmap?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BA@KBAEEJPG@startmap?7?7?$CC?$CFs?$CC?6@ DB 'startmap', 09H, 09H, '"'
	DB	'%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NNNHNHFF@title?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0N@NNNHNHFF@title?7?7?$CC?$CFs?$CC?6@ DB 'title', 09H, 09H, '"%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PBLNEELD@fallback_dir?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BD@PBLNEELD@fallback_dir?7?$CC?$CFs?$CC?6@ DB 'fallback_dir', 09H, '"'
	DB	'%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLHLHHBC@gamedir?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@HLHLHHBC@gamedir?7?7?$CC?$CFs?$CC?6@ DB 'gamedir', 09H, 09H, '"%'
	DB	's"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBNGDPD@basedir?7?7?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0P@GBNGDPD@basedir?7?7?$CC?$CFs?$CC?6@ DB 'basedir', 09H, 09H, '"%s'
	DB	'"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PKJNFFLK@?1?1?5generated?5by?5Xash3D?6?6?6@
CONST	SEGMENT
??_C@_0BK@PKJNFFLK@?1?1?5generated?5by?5Xash3D?6?6?6@ DB '// generated by'
	DB	' Xash3D', 0aH, 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DJANCFLM@FS_WriteGameInfo?3?5can?8t?5write?5?$CF@
CONST	SEGMENT
??_C@_0CC@DJANCFLM@FS_WriteGameInfo?3?5can?8t?5write?5?$CF@ DB 'FS_WriteG'
	DB	'ameInfo: can''t write %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05POGGAMJB@?$CFs?4rc@
CONST	SEGMENT
??_C@_05POGGAMJB@?$CFs?4rc@ DB '%s.rc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HDEBADIB@FS_Rescan?$CI?5?$CFs?5?$CJ?6@
CONST	SEGMENT
??_C@_0BB@HDEBADIB@FS_Rescan?$CI?5?$CFs?5?$CJ?6@ DB 'FS_Rescan( %s )', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DIKICOBM@?1?4@
CONST	SEGMENT
??_C@_02DIKICOBM@?1?4@ DB '/.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_ClearSearchPath@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_ClearSearchPath@@9@9 DD 02a2H	; `FS_ClearSearchPath'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03NPMJBIL@?$CFs?1@
CONST	SEGMENT
??_C@_03NPMJBIL@?$CFs?1@ DB '%s/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_AddGameDirectory@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_AddGameDirectory@@9@9 DD 0261H	; `FS_AddGameDirectory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@PGENDCEJ@?$FO1Error?3?$FO7?5FS_AddPak_Fullpath?3?5@
CONST	SEGMENT
??_C@_0DI@PGENDCEJ@?$FO1Error?3?$FO7?5FS_AddPak_Fullpath?3?5@ DB '^1Error'
	DB	':^7 FS_AddPak_Fullpath: unable to load pak "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
CONST	SEGMENT
??_C@_05GFOLEBJA@?$CFs?1?$CFs@ DB '%s/%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BJJLDFAF@Adding?5pakfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@
CONST	SEGMENT
??_C@_0BP@BJJLDFAF@Adding?5pakfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@ DB 'A'
	DB	'dding pakfile: %s (%i files)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HKJIJDAE@pak@
CONST	SEGMENT
??_C@_03HKJIJDAE@pak@ DB 'pak', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_AddPak_Fullpath@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_AddPak_Fullpath@@9@9 DD 0223H	; `FS_AddPak_Fullpath'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DI@BHOLMLCD@?$FO1Error?3?$FO7?5FS_AddWad_Fullpath?3?5@
CONST	SEGMENT
??_C@_0DI@BHOLMLCD@?$FO1Error?3?$FO7?5FS_AddWad_Fullpath?3?5@ DB '^1Error'
	DB	':^7 FS_AddWad_Fullpath: unable to load wad "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PEBJBKDC@Adding?5wadfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@
CONST	SEGMENT
??_C@_0BP@PEBJBKDC@Adding?5wadfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@ DB 'A'
	DB	'dding wadfile: %s (%i files)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GANHLHHC@wad@
CONST	SEGMENT
??_C@_03GANHLHHC@wad@ DB 'wad', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_AddWad_Fullpath@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_AddWad_Fullpath@@9@9 DD 01ecH	; `FS_AddWad_Fullpath'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@MPMJLKCJ@?$CFs?5is?5an?5incomplete?5PAK?0?5not?5lo@
CONST	SEGMENT
??_C@_0CG@MPMJLKCJ@?$CFs?5is?5an?5incomplete?5PAK?0?5not?5lo@ DB '%s is a'
	DB	'n incomplete PAK, not loading', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KDGPBPGC@?$CFs?5has?5no?5files?4?5Ignored?4?6@
CONST	SEGMENT
??_C@_0BL@KDGPBPGC@?$CFs?5has?5no?5files?4?5Ignored?4?6@ DB '%s has no fi'
	DB	'les. Ignored.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OEIIDGKH@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5file@
CONST	SEGMENT
??_C@_0DD@OEIIDGKH@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5file@ DB '^1'
	DB	'Error:^7 %s has too many files ( %i ). Ignored.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FFLJPGIM@?$CFs?5has?5an?5invalid?5directory?5siz@
CONST	SEGMENT
??_C@_0CM@FFLJPGIM@?$CFs?5has?5an?5invalid?5directory?5siz@ DB '%s has an'
	DB	' invalid directory size. Ignored.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LADEPGED@?$CFs?5is?5not?5a?5packfile?4?5Ignored?4?6@
CONST	SEGMENT
??_C@_0CA@LADEPGED@?$CFs?5is?5not?5a?5packfile?4?5Ignored?4?6@ DB '%s is '
	DB	'not a packfile. Ignored.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIPKDBIA@?$CFs?5couldn?8t?5open?6@
CONST	SEGMENT
??_C@_0BC@JIPKDBIA@?$CFs?5couldn?8t?5open?6@ DB '%s couldn''t open', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??FS_LoadPackPAK@@9@9 DD 0195H		; `FS_LoadPackPAK'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJLKKPKG@?5?$FO2gamedir?$FO7?6@
CONST	SEGMENT
??_C@_0O@LJLKKPKG@?5?$FO2gamedir?$FO7?6@ DB ' ^2gamedir^7', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GBEHFLEC@?$CFs?5?$CI?$CFi?5files?$CJ@
CONST	SEGMENT
??_C@_0O@GBEHFLEC@?$CFs?5?$CI?$CFi?5files?$CJ@ DB '%s (%i files)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HPKHMA@Current?5search?5path?3?6@
CONST	SEGMENT
??_C@_0BG@HPKHMA@Current?5search?5path?3?6@ DB 'Current search path:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MIMLIMFB@?$FO3Warning?3?$FO7?5package?5?$CFs?5contain@
CONST	SEGMENT
??_C@_0DM@MIMLIMFB@?$FO3Warning?3?$FO7?5package?5?$CFs?5contain@ DB '^3Wa'
	DB	'rning:^7 package %s contains the file %s several times', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stringlistappend@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??stringlistappend@@9@9 DD 0cfH		; `stringlistappend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\filesystem.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??stringlistfreecontents@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??stringlistfreecontents@@9@9 DD 0bcH	; `stringlistfreecontents'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0abH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0c41H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	072H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	079cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0144H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	020fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	032eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	014H
	DB	0dbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	033H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	045bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0478H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02edH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	099H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0e4H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0afH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0137H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0956H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0202H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_ReadLump
_TEXT	SEGMENT
_buf$ = -12						; size = 4
_size$ = -8						; size = 4
_oldpos$ = -4						; size = 4
_wad$ = 8						; size = 4
_lump$ = 12						; size = 4
_lumpsizeptr$ = 16					; size = 4
_W_ReadLump PROC					; COMDAT

; 2942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2943 : 	size_t	oldpos, size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 2944 : 	byte	*buf;
; 2945 : 
; 2946 : 	// assume error
; 2947 : 	if( lumpsizeptr ) *lumpsizeptr = 0;

	cmp	DWORD PTR _lumpsizeptr$[ebp], 0
	je	SHORT $LN2@W_ReadLump
	mov	eax, DWORD PTR _lumpsizeptr$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@W_ReadLump:

; 2948 : 
; 2949 : 	// no wads loaded
; 2950 : 	if( !wad || !lump ) return NULL;

	cmp	DWORD PTR _wad$[ebp], 0
	je	SHORT $LN4@W_ReadLump
	cmp	DWORD PTR _lump$[ebp], 0
	jne	SHORT $LN3@W_ReadLump
$LN4@W_ReadLump:
	xor	eax, eax
	jmp	$LN1@W_ReadLump
$LN3@W_ReadLump:

; 2951 : 
; 2952 : 	oldpos = FS_Tell( wad->handle ); // don't forget restore original position

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _oldpos$[ebp], eax

; 2953 : 
; 2954 : 	if( FS_Seek( wad->handle, lump->filepos, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN5@W_ReadLump

; 2955 : 	{
; 2956 : 		Con_DPrintf( S_ERROR "W_ReadLump: %s is corrupted\n", lump->name );

	mov	eax, DWORD PTR _lump$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0CI@KKBIJNIM@?$FO1Error?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5co@
	call	_Con_DPrintf
	add	esp, 8

; 2957 : 		FS_Seek( wad->handle, oldpos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _oldpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2958 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_ReadLump
$LN5@W_ReadLump:

; 2959 : 	}
; 2960 : 
; 2961 : 	buf = (byte *)Mem_Malloc( wad->mempool, lump->disksize );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_ReadLump@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buf$[ebp], eax

; 2962 : 	size = FS_Read( wad->handle, buf, lump->disksize );

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _size$[ebp], eax

; 2963 : 
; 2964 : 	if( size < lump->disksize )

	mov	eax, DWORD PTR _lump$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN6@W_ReadLump

; 2965 : 	{
; 2966 : 		Con_DPrintf( S_WARN "W_ReadLump: %s is probably corrupted\n", lump->name );

	mov	eax, DWORD PTR _lump$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET ??_C@_0DD@JBDLBDGJ@?$FO3Warning?3?$FO7?5W_ReadLump?3?5?$CFs?5is?5@
	call	_Con_DPrintf
	add	esp, 8

; 2967 : 		FS_Seek( wad->handle, oldpos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _oldpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2968 : 		Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_ReadLump@@9@9
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2969 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@W_ReadLump
$LN6@W_ReadLump:

; 2970 : 	}
; 2971 : 
; 2972 : 	if( lumpsizeptr ) *lumpsizeptr = lump->disksize;

	cmp	DWORD PTR _lumpsizeptr$[ebp], 0
	je	SHORT $LN7@W_ReadLump
	mov	eax, DWORD PTR _lumpsizeptr$[ebp]
	mov	ecx, DWORD PTR _lump$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN7@W_ReadLump:

; 2973 : 	FS_Seek( wad->handle, oldpos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _oldpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2974 : 
; 2975 : 	return buf;

	mov	eax, DWORD PTR _buf$[ebp]
$LN1@W_ReadLump:

; 2976 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_ReadLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_AddFileToWad
_TEXT	SEGMENT
_diff$1 = -20						; size = 4
_middle$2 = -16						; size = 4
_plump$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_name$ = 8						; size = 4
_wad$ = 12						; size = 4
_newlump$ = 16						; size = 4
_W_AddFileToWad PROC					; COMDAT

; 2896 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2897 : 	int		left, right;
; 2898 : 	dlumpinfo_t	*plump;
; 2899 : 
; 2900 : 	// look for the slot we should put that file into (binary search)
; 2901 : 	left = 0;

	mov	DWORD PTR _left$[ebp], 0

; 2902 : 	right = wad->numlumps - 1;

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, 1
	mov	DWORD PTR _right$[ebp], ecx
$LN2@W_AddFileT:

; 2903 : 
; 2904 : 	while( left <= right )

	mov	eax, DWORD PTR _left$[ebp]
	cmp	eax, DWORD PTR _right$[ebp]
	jg	$LN3@W_AddFileT

; 2905 : 	{
; 2906 : 		int	middle = ( left + right ) / 2;

	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$2[ebp], eax

; 2907 : 		int	diff = Q_stricmp( wad->lumps[middle].name, name );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _middle$2[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR [eax+ecx+16]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _diff$1[ebp], eax

; 2908 : 
; 2909 : 		if( !diff )

	cmp	DWORD PTR _diff$1[ebp], 0
	jne	SHORT $LN4@W_AddFileT

; 2910 : 		{
; 2911 : 			if( wad->lumps[middle].type < newlump->type )

	mov	eax, DWORD PTR _middle$2[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movsx	eax, BYTE PTR [edx+eax+12]
	mov	ecx, DWORD PTR _newlump$[ebp]
	movsx	edx, BYTE PTR [ecx+12]
	cmp	eax, edx
	jge	SHORT $LN5@W_AddFileT

; 2912 : 				diff = 1;

	mov	DWORD PTR _diff$1[ebp], 1
	jmp	SHORT $LN4@W_AddFileT
$LN5@W_AddFileT:

; 2913 : 			else if( wad->lumps[middle].type > newlump->type )

	mov	eax, DWORD PTR _middle$2[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movsx	eax, BYTE PTR [edx+eax+12]
	mov	ecx, DWORD PTR _newlump$[ebp]
	movsx	edx, BYTE PTR [ecx+12]
	cmp	eax, edx
	jle	SHORT $LN7@W_AddFileT

; 2914 : 				diff = -1;

	mov	DWORD PTR _diff$1[ebp], -1
	jmp	SHORT $LN4@W_AddFileT
$LN7@W_AddFileT:

; 2915 : 			else Con_Reportf( S_WARN "Wad %s contains the file %s several times\n", wad->filename, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DI@CDLODMBO@?$FO3Warning?3?$FO7?5Wad?5?$CFs?5contains?5th@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH
$LN4@W_AddFileT:

; 2916 : 		}
; 2917 : 
; 2918 : 		// If we're too far in the list
; 2919 : 		if( diff > 0 ) right = middle - 1;

	cmp	DWORD PTR _diff$1[ebp], 0
	jle	SHORT $LN9@W_AddFileT
	mov	eax, DWORD PTR _middle$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _right$[ebp], eax
	jmp	SHORT $LN10@W_AddFileT
$LN9@W_AddFileT:

; 2920 : 		else left = middle + 1;

	mov	eax, DWORD PTR _middle$2[ebp]
	add	eax, 1
	mov	DWORD PTR _left$[ebp], eax
$LN10@W_AddFileT:

; 2921 : 	}

	jmp	$LN2@W_AddFileT
$LN3@W_AddFileT:

; 2922 : 
; 2923 : 	// we have to move the right of the list by one slot to free the one we need
; 2924 : 	plump = &wad->lumps[left];

	mov	eax, DWORD PTR _left$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	add	eax, DWORD PTR [ecx+272]
	mov	DWORD PTR _plump$[ebp], eax

; 2925 : 	memmove( plump + 1, plump, ( wad->numlumps - left ) * sizeof( *plump ));

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, DWORD PTR _left$[ebp]
	shl	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _plump$[ebp]
	push	edx
	mov	eax, DWORD PTR _plump$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 2926 : 	wad->numlumps++;

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	add	ecx, 1
	mov	edx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 2927 : 
; 2928 : 	*plump = *newlump;

	mov	ecx, 8
	mov	esi, DWORD PTR _newlump$[ebp]
	mov	edi, DWORD PTR _plump$[ebp]
	rep movsd

; 2929 : 	memcpy( plump->name, name, sizeof( plump->name ));

	push	16					; 00000010H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plump$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2930 : 
; 2931 : 	return plump;

	mov	eax, DWORD PTR _plump$[ebp]

; 2932 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_AddFileToWad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_CheckForCrypt
_TEXT	SEGMENT
tv77 = -76						; size = 4
_key$ = -8						; size = 4
_f$ = -4						; size = 4
_dllname$ = 8						; size = 4
_FS_CheckForCrypt PROC					; COMDAT

; 2316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2317 : 	file_t	*f;
; 2318 : 	int	key;
; 2319 : 
; 2320 : 	f = FS_Open( dllname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 2321 : 	if( !f ) return false;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@FS_CheckFo
	xor	eax, eax
	jmp	SHORT $LN1@FS_CheckFo
$LN2@FS_CheckFo:

; 2322 : 
; 2323 : 	FS_Seek( f, 64, SEEK_SET );	// skip first 64 bytes

	push	0
	push	64					; 00000040H
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2324 : 	FS_Read( f, &key, sizeof( key ));

	push	4
	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2325 : 	FS_Close( f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2326 : 
; 2327 : 	return ( key == 0x12345678 ) ? true : false;

	cmp	DWORD PTR _key$[ebp], 305419896		; 12345678H
	jne	SHORT $LN4@FS_CheckFo
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN5@FS_CheckFo
$LN4@FS_CheckFo:
	mov	DWORD PTR tv77[ebp], 0
$LN5@FS_CheckFo:
	mov	eax, DWORD PTR tv77[ebp]
$LN1@FS_CheckFo:

; 2328 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CheckForCrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_OpenReadFile
_TEXT	SEGMENT
_path$1 = -1036						; size = 1024
_pack_ind$ = -12					; size = 4
_search$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_FS_OpenReadFile PROC					; COMDAT

; 1785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1228				; 000004ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1786 : 	searchpath_t	*search;
; 1787 : 	int		pack_ind;
; 1788 : 
; 1789 : 	search = FS_FindFile( filename, &pack_ind, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pack_ind$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 1790 : 
; 1791 : 	// not found?
; 1792 : 	if( search == NULL )

	cmp	DWORD PTR _search$[ebp], 0
	jne	SHORT $LN2@FS_OpenRea

; 1793 : 		return NULL; 

	xor	eax, eax
	jmp	SHORT $LN1@FS_OpenRea
$LN2@FS_OpenRea:

; 1794 : 
; 1795 : 	if( search->pack )

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN3@FS_OpenRea

; 1796 : 		return FS_OpenPackedFile( search->pack, pack_ind );

	mov	eax, DWORD PTR _pack_ind$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	call	_FS_OpenPackedFile
	add	esp, 8
	jmp	SHORT $LN1@FS_OpenRea
	jmp	SHORT $LN4@FS_OpenRea
$LN3@FS_OpenRea:

; 1797 : 	else if( search->wad )

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN5@FS_OpenRea

; 1798 : 		return NULL; // let W_LoadFile get lump correctly

	xor	eax, eax
	jmp	SHORT $LN1@FS_OpenRea
	jmp	SHORT $LN4@FS_OpenRea
$LN5@FS_OpenRea:

; 1799 : 	else if( pack_ind < 0 )

	cmp	DWORD PTR _pack_ind$[ebp], 0
	jge	SHORT $LN4@FS_OpenRea

; 1800 : 	{
; 1801 : 		char	path [MAX_SYSPATH];
; 1802 : 
; 1803 : 		// found in the filesystem?
; 1804 : 		Q_sprintf( path, "%s%s", search->filename, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	edx, DWORD PTR _path$1[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 1805 : 		return FS_SysOpen( path, mode );

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$1[ebp]
	push	ecx
	call	_FS_SysOpen
	add	esp, 8
	jmp	SHORT $LN1@FS_OpenRea
$LN4@FS_OpenRea:

; 1806 : 	} 
; 1807 : 
; 1808 : 	return NULL;

	xor	eax, eax
$LN1@FS_OpenRea:

; 1809 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_OpenReadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_OpenPackedFile
_TEXT	SEGMENT
_file$ = -12						; size = 4
_dup_handle$ = -8					; size = 4
_pfile$ = -4						; size = 4
_pack$ = 8						; size = 4
_pack_ind$ = 12						; size = 4
_FS_OpenPackedFile PROC					; COMDAT

; 1566 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1567 : 	dpackfile_t	*pfile;
; 1568 : 	int		dup_handle;
; 1569 : 	file_t		*file;
; 1570 : 
; 1571 : 	pfile = &pack->files[pack_ind];

	mov	eax, DWORD PTR _pack_ind$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pack$[ebp]
	add	eax, DWORD PTR [ecx+272]
	mov	DWORD PTR _pfile$[ebp], eax

; 1572 : 
; 1573 : 	if( lseek( pack->handle, pfile->filepos, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN2@FS_OpenPac

; 1574 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FS_OpenPac
$LN2@FS_OpenPac:

; 1575 : 
; 1576 : 	dup_handle = dup( pack->handle );

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	call	DWORD PTR __imp__dup
	add	esp, 4
	mov	DWORD PTR _dup_handle$[ebp], eax

; 1577 : 
; 1578 : 	if( dup_handle < 0 )

	cmp	DWORD PTR _dup_handle$[ebp], 0
	jge	SHORT $LN3@FS_OpenPac

; 1579 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FS_OpenPac
$LN3@FS_OpenPac:

; 1580 : 
; 1581 : 	file = (file_t *)Mem_Calloc( fs_mempool, sizeof( *file ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_OpenPackedFile@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	2088					; 00000828H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _file$[ebp], eax

; 1582 : 	file->handle = dup_handle;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _dup_handle$[ebp]
	mov	DWORD PTR [eax], ecx

; 1583 : 	file->real_length = pfile->filelen;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+4], edx

; 1584 : 	file->offset = pfile->filepos;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _pfile$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+12], edx

; 1585 : 	file->position = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1586 : 	file->ungetc = EOF;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+16], -1

; 1587 : 
; 1588 : 	return file;

	mov	eax, DWORD PTR _file$[ebp]
$LN1@FS_OpenPac:

; 1589 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_OpenPackedFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_SysOpen
_TEXT	SEGMENT
tv78 = -84						; size = 4
tv67 = -84						; size = 4
_ind$ = -16						; size = 4
_opt$ = -12						; size = 4
_mod$ = -8						; size = 4
_file$ = -4						; size = 4
_filepath$ = 8						; size = 4
_mode$ = 12						; size = 4
_FS_SysOpen PROC					; COMDAT

; 1494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1495 : 	file_t	*file;
; 1496 : 	int	mod, opt;
; 1497 : 	uint	ind;
; 1498 : 
; 1499 : 	// Parse the mode string
; 1500 : 	switch( mode[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mode$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	sub	ecx, 97					; 00000061H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 22			; 00000016H
	ja	SHORT $LN13@FS_SysOpen
	mov	edx, DWORD PTR tv67[ebp]
	movzx	eax, BYTE PTR $LN21@FS_SysOpen[edx]
	jmp	DWORD PTR $LN22@FS_SysOpen[eax*4]
$LN9@FS_SysOpen:

; 1501 : 	{
; 1502 : 	case 'r':	// read
; 1503 : 		mod = O_RDONLY;

	mov	DWORD PTR _mod$[ebp], 0

; 1504 : 		opt = 0;

	mov	DWORD PTR _opt$[ebp], 0

; 1505 : 		break;

	jmp	SHORT $LN2@FS_SysOpen
$LN10@FS_SysOpen:

; 1506 : 	case 'w': // write
; 1507 : 		mod = O_WRONLY;

	mov	DWORD PTR _mod$[ebp], 1

; 1508 : 		opt = O_CREAT | O_TRUNC;

	mov	DWORD PTR _opt$[ebp], 768		; 00000300H

; 1509 : 		break;

	jmp	SHORT $LN2@FS_SysOpen
$LN11@FS_SysOpen:

; 1510 : 	case 'a': // append
; 1511 : 		mod = O_WRONLY;

	mov	DWORD PTR _mod$[ebp], 1

; 1512 : 		opt = O_CREAT | O_APPEND;

	mov	DWORD PTR _opt$[ebp], 264		; 00000108H

; 1513 : 		break;

	jmp	SHORT $LN2@FS_SysOpen
$LN12@FS_SysOpen:

; 1514 : 	case 'e': // edit
; 1515 : 		mod = O_WRONLY;

	mov	DWORD PTR _mod$[ebp], 1

; 1516 : 		opt = O_CREAT;

	mov	DWORD PTR _opt$[ebp], 256		; 00000100H

; 1517 : 		break;

	jmp	SHORT $LN2@FS_SysOpen
$LN13@FS_SysOpen:

; 1518 : 	default:
; 1519 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_SysOpen
$LN2@FS_SysOpen:

; 1520 : 	}
; 1521 : 
; 1522 : 	for( ind = 1; mode[ind] != '\0'; ind++ )

	mov	DWORD PTR _ind$[ebp], 1
	jmp	SHORT $LN6@FS_SysOpen
$LN4@FS_SysOpen:
	mov	eax, DWORD PTR _ind$[ebp]
	add	eax, 1
	mov	DWORD PTR _ind$[ebp], eax
$LN6@FS_SysOpen:
	mov	eax, DWORD PTR _mode$[ebp]
	add	eax, DWORD PTR _ind$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@FS_SysOpen

; 1523 : 	{
; 1524 : 		switch( mode[ind] )

	mov	eax, DWORD PTR _mode$[ebp]
	add	eax, DWORD PTR _ind$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv78[ebp], cl
	cmp	BYTE PTR tv78[ebp], 43			; 0000002bH
	je	SHORT $LN14@FS_SysOpen
	cmp	BYTE PTR tv78[ebp], 98			; 00000062H
	je	SHORT $LN15@FS_SysOpen
	jmp	SHORT $LN7@FS_SysOpen
$LN14@FS_SysOpen:

; 1525 : 		{
; 1526 : 		case '+':
; 1527 : 			mod = O_RDWR;

	mov	DWORD PTR _mod$[ebp], 2

; 1528 : 			break;

	jmp	SHORT $LN7@FS_SysOpen
$LN15@FS_SysOpen:

; 1529 : 		case 'b':
; 1530 : 			opt |= O_BINARY;

	mov	eax, DWORD PTR _opt$[ebp]
	or	eax, 32768				; 00008000H
	mov	DWORD PTR _opt$[ebp], eax
$LN7@FS_SysOpen:

; 1531 : 			break;
; 1532 : 		default:
; 1533 : 			break;
; 1534 : 		}
; 1535 : 	}

	jmp	SHORT $LN4@FS_SysOpen
$LN5@FS_SysOpen:

; 1536 : 
; 1537 : 	file = (file_t *)Mem_Calloc( fs_mempool, sizeof( *file ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_SysOpen@@9@9
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	2088					; 00000828H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _file$[ebp], eax

; 1538 : 	file->filetime = FS_SysFileTime( filepath );

	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_SysFileTime
	add	esp, 4
	cdq
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [ecx+28], edx

; 1539 : 	file->ungetc = EOF;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+16], -1

; 1540 : 
; 1541 : 	file->handle = open( filepath, mod|opt, 0666 );

	push	438					; 000001b6H
	mov	eax, DWORD PTR _mod$[ebp]
	or	eax, DWORD PTR _opt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filepath$[ebp]
	push	ecx
	call	DWORD PTR __imp__open
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx], eax

; 1542 : 
; 1543 : 	if( file->handle < 0 )

	mov	eax, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN17@FS_SysOpen

; 1544 : 	{
; 1545 : 		Mem_Free( file );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_SysOpen@@9@9
	add	eax, 51					; 00000033H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1546 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FS_SysOpen
$LN17@FS_SysOpen:

; 1547 : 	}
; 1548 : 
; 1549 : 	file->real_length = lseek( file->handle, 0, SEEK_END );

	push	2
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1550 : 
; 1551 : 	// For files opened in append mode, we start at the end of the file
; 1552 : 	if( mod & O_APPEND ) file->position = file->real_length;

	mov	eax, DWORD PTR _mod$[ebp]
	and	eax, 8
	je	SHORT $LN18@FS_SysOpen
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN19@FS_SysOpen
$LN18@FS_SysOpen:

; 1553 : 	else lseek( file->handle, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
$LN19@FS_SysOpen:

; 1554 : 
; 1555 : 	return file;

	mov	eax, DWORD PTR _file$[ebp]
$LN1@FS_SysOpen:

; 1556 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@FS_SysOpen:
	DD	$LN11@FS_SysOpen
	DD	$LN12@FS_SysOpen
	DD	$LN9@FS_SysOpen
	DD	$LN10@FS_SysOpen
	DD	$LN13@FS_SysOpen
$LN21@FS_SysOpen:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_FS_SysOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ParseGameInfo
_TEXT	SEGMENT
_tmpGameInfo$ = -2444					; size = 1672
_default_gameinfo_path$ = -772				; size = 256
_gameinfo_path$ = -516					; size = 256
_liblist_path$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_gamedir$ = 8						; size = 4
_GameInfo$ = 12						; size = 4
_FS_ParseGameInfo PROC					; COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2764				; 00000accH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1297 : 	string		liblist_path, gameinfo_path;
; 1298 : 	string		default_gameinfo_path;
; 1299 : 	gameinfo_t	tmpGameInfo;
; 1300 : 
; 1301 : 	Q_snprintf( default_gameinfo_path, sizeof( default_gameinfo_path ), "%s/gameinfo.txt", fs_basedir );

	push	OFFSET _fs_basedir
	push	OFFSET ??_C@_0BA@DBHCOEMC@?$CFs?1gameinfo?4txt@
	push	256					; 00000100H
	lea	eax, DWORD PTR _default_gameinfo_path$[ebp]
	push	eax
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1302 : 	Q_snprintf( gameinfo_path, sizeof( gameinfo_path ), "%s/gameinfo.txt", gamedir );

	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@DBHCOEMC@?$CFs?1gameinfo?4txt@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _gameinfo_path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1303 : 	Q_snprintf( liblist_path, sizeof( liblist_path ), "%s/liblist.gam", gamedir );

	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@DLDLIPEJ@?$CFs?1liblist?4gam@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _liblist_path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1304 : 
; 1305 : 	// if user change liblist.gam update the gameinfo.txt
; 1306 : 	if( FS_FileTime( liblist_path, false ) > FS_FileTime( gameinfo_path, false ))

	push	0
	lea	eax, DWORD PTR _liblist_path$[ebp]
	push	eax
	call	_FS_FileTime
	add	esp, 8
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _gameinfo_path$[ebp]
	push	ecx
	call	_FS_FileTime
	add	esp, 8
	cmp	esi, eax
	jle	SHORT $LN2@FS_ParseGa

; 1307 : 		FS_ConvertGameInfo( gamedir, gameinfo_path, liblist_path );

	lea	eax, DWORD PTR _liblist_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gameinfo_path$[ebp]
	push	ecx
	mov	edx, DWORD PTR _gamedir$[ebp]
	push	edx
	call	_FS_ConvertGameInfo
	add	esp, 12					; 0000000cH
$LN2@FS_ParseGa:

; 1308 : 
; 1309 : 	// force to create gameinfo for specified game if missing
; 1310 : 	if(( FS_CheckForGameDir( gamedir ) || !Q_stricmp( fs_gamedir, gamedir )) && !FS_FileExists( gameinfo_path, false ))

	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	call	_FS_CheckForGameDir
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@FS_ParseGa
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET _fs_gamedir
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN3@FS_ParseGa
$LN4@FS_ParseGa:
	push	0
	lea	eax, DWORD PTR _gameinfo_path$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	$LN3@FS_ParseGa

; 1311 : 	{
; 1312 : 		memset( &tmpGameInfo, 0, sizeof( tmpGameInfo ));

	push	1672					; 00000688H
	push	0
	lea	eax, DWORD PTR _tmpGameInfo$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1313 : 
; 1314 : 		if( FS_ReadGameInfo( default_gameinfo_path, gamedir, &tmpGameInfo ))

	lea	eax, DWORD PTR _tmpGameInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gamedir$[ebp]
	push	ecx
	lea	edx, DWORD PTR _default_gameinfo_path$[ebp]
	push	edx
	call	_FS_ReadGameInfo
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@FS_ParseGa

; 1315 : 		{
; 1316 : 			// now we have copy of game info from basedir but needs to change gamedir
; 1317 : 			Con_DPrintf( "Convert %s to %s\n", default_gameinfo_path, gameinfo_path );

	lea	eax, DWORD PTR _gameinfo_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _default_gameinfo_path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@LBDHMDCA@Convert?5?$CFs?5to?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1318 : 			Q_strncpy( tmpGameInfo.gamedir, gamedir, sizeof( tmpGameInfo.gamedir ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpGameInfo$[ebp+128]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1319 : 			FS_WriteGameInfo( gameinfo_path, &tmpGameInfo );

	lea	eax, DWORD PTR _tmpGameInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gameinfo_path$[ebp]
	push	ecx
	call	_FS_WriteGameInfo
	add	esp, 8

; 1320 : 		}

	jmp	SHORT $LN3@FS_ParseGa
$LN5@FS_ParseGa:

; 1321 : 		else FS_CreateDefaultGameInfo( gameinfo_path );

	lea	eax, DWORD PTR _gameinfo_path$[ebp]
	push	eax
	call	_FS_CreateDefaultGameInfo
	add	esp, 4
$LN3@FS_ParseGa:

; 1322 : 	}
; 1323 : 
; 1324 : 	if( !GameInfo || !FS_FileExists( gameinfo_path, false ))

	cmp	DWORD PTR _GameInfo$[ebp], 0
	je	SHORT $LN8@FS_ParseGa
	push	0
	lea	eax, DWORD PTR _gameinfo_path$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@FS_ParseGa
$LN8@FS_ParseGa:

; 1325 : 		return false; // no dest

	xor	eax, eax
	jmp	SHORT $LN1@FS_ParseGa
$LN7@FS_ParseGa:

; 1326 : 
; 1327 : 	if( FS_ReadGameInfo( gameinfo_path, gamedir, GameInfo ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gamedir$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gameinfo_path$[ebp]
	push	edx
	call	_FS_ReadGameInfo
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN9@FS_ParseGa

; 1328 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_ParseGa
$LN9@FS_ParseGa:

; 1329 : 	return false;

	xor	eax, eax
$LN1@FS_ParseGa:

; 1330 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ParseGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_CheckForGameDir
_TEXT	SEGMENT
_gamedir$ = 8						; size = 4
_FS_CheckForGameDir PROC				; COMDAT

; 1272 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1273 : 	// if directory contain config.cfg it's 100% gamedir
; 1274 : 	if( FS_FileExists( va( "%s/config.cfg", gamedir ), false ))

	push	0
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@FLLMCNCO@?$CFs?1config?4cfg@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@FS_CheckFo

; 1275 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_CheckFo
$LN2@FS_CheckFo:

; 1276 : 
; 1277 : 	// if directory contain progs.dat it's 100% gamedir
; 1278 : 	if( FS_FileExists( va( "%s/progs.dat", gamedir ), false ))

	push	0
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@DCOJFEIC@?$CFs?1progs?4dat@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@FS_CheckFo

; 1279 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_CheckFo
$LN3@FS_CheckFo:

; 1280 : 
; 1281 : 	// quake mods probably always archived but can missed config.cfg before first running
; 1282 : 	if( FS_FileExists( va( "%s/pak0.pak", gamedir ), false ))

	push	0
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@GGNFKHBH@?$CFs?1pak0?4pak@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@FS_CheckFo

; 1283 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_CheckFo
$LN4@FS_CheckFo:

; 1284 : 
; 1285 : 	// NOTE; adds here some additional checks if you wished
; 1286 : 
; 1287 : 	return false;

	xor	eax, eax
$LN1@FS_CheckFo:

; 1288 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CheckForGameDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ReadGameInfo
_TEXT	SEGMENT
tv438 = -1676						; size = 4
tv419 = -1676						; size = 4
tv400 = -1676						; size = 4
tv381 = -1676						; size = 4
tv437 = -1672						; size = 4
tv418 = -1672						; size = 4
tv399 = -1672						; size = 4
tv380 = -1672						; size = 4
_ambientNum$1 = -1476					; size = 4
_fs_path$ = -1472					; size = 256
_token$ = -1216						; size = 1204
_pfile$ = -12						; size = 4
_afile$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filepath$ = 8						; size = 4
_gamedir$ = 12						; size = 4
_GameInfo$ = 16						; size = 4
_FS_ReadGameInfo PROC					; COMDAT

; 1087 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1676				; 0000068cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1088 : 	char	*afile, *pfile;
; 1089 : 	char	token[1204];
; 1090 : 	string	fs_path;
; 1091 : 
; 1092 : 	afile = FS_LoadFile( filepath, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 1093 : 	if( !afile ) return false;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN4@FS_ReadGam
	xor	eax, eax
	jmp	$LN1@FS_ReadGam
$LN4@FS_ReadGam:

; 1094 : 
; 1095 : 	// setup default values
; 1096 : 	Q_strncpy( GameInfo->gamefolder, gamedir, sizeof( GameInfo->gamefolder ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1097 : 	GameInfo->max_edicts = 900;	// default value if not specified

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1656], 900		; 00000384H

; 1098 : 	GameInfo->max_tents = 500;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1660], 500		; 000001f4H

; 1099 : 	GameInfo->max_beams = 128;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1664], 128		; 00000080H

; 1100 : 	GameInfo->max_particles = 4096;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1668], 4096		; 00001000H

; 1101 : 	GameInfo->version = 1.0f;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+448], xmm0

; 1102 : 	GameInfo->falldir[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _GameInfo$[ebp]
	mov	BYTE PTR [edx+ecx+192], 0

; 1103 : 	
; 1104 : 	Q_strncpy( GameInfo->title, "New Game", sizeof( GameInfo->title ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08IIACKFCG@New?5Game@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1105 : 	Q_strncpy( GameInfo->sp_entity, "info_player_start", sizeof( GameInfo->sp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BC@IHPKIKNE@info_player_start@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1304				; 00000518H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1106 : 	Q_strncpy( GameInfo->mp_entity, "info_player_deathmatch", sizeof( GameInfo->mp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BH@IGAFCIL@info_player_deathmatch@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1107 : 	Q_strncpy( GameInfo->dll_path, "cl_dlls", sizeof( GameInfo->dll_path ));

	push	64					; 00000040H
	push	OFFSET ??_C@_07CNOKJKDK@cl_dlls@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1108 : 	Q_strncpy( GameInfo->game_dll, "dlls/hl.dll", sizeof( GameInfo->game_dll ));

	push	64					; 00000040H
	push	OFFSET ??_C@_0M@FCEMCLHB@dlls?1hl?4dll@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1109 : 	Q_strncpy( GameInfo->startmap, "", sizeof( GameInfo->startmap ));

	push	64					; 00000040H
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1110 : 	Q_strncpy( GameInfo->iconpath, "game.ico", sizeof( GameInfo->iconpath ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08BPMGDPCI@game?4ico@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1111 : 
; 1112 : 	pfile = afile;

	mov	eax, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@FS_ReadGam:

; 1113 : 
; 1114 : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@FS_ReadGam

; 1115 : 	{
; 1116 : 		if( !Q_stricmp( token, "basedir" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07BHPNMMNM@basedir@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@FS_ReadGam

; 1117 : 		{
; 1118 : 			pfile = COM_ParseFile( pfile, fs_path );

	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1119 : 			if( Q_stricmp( fs_path, GameInfo->basedir ) || Q_stricmp( fs_path, GameInfo->gamedir ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@FS_ReadGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@FS_ReadGam
$LN8@FS_ReadGam:

; 1120 : 				Q_strncpy( GameInfo->basedir, fs_path, sizeof( GameInfo->basedir ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN7@FS_ReadGam:

; 1121 : 		}

	jmp	$LN66@FS_ReadGam
$LN5@FS_ReadGam:

; 1122 : 		else if( !Q_stricmp( token, "fallback_dir" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@JOMOAPOL@fallback_dir@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@FS_ReadGam

; 1123 : 		{
; 1124 : 			pfile = COM_ParseFile( pfile, fs_path );

	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1125 : 			if( Q_stricmp( fs_path, GameInfo->basedir ) || Q_stricmp( fs_path, GameInfo->falldir ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@FS_ReadGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN11@FS_ReadGam
$LN12@FS_ReadGam:

; 1126 : 				Q_strncpy( GameInfo->falldir, fs_path, sizeof( GameInfo->falldir ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 192				; 000000c0H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN11@FS_ReadGam:

; 1127 : 		}

	jmp	$LN66@FS_ReadGam
$LN9@FS_ReadGam:

; 1128 : 		else if( !Q_stricmp( token, "gamedir" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@FS_ReadGam

; 1129 : 		{
; 1130 : 			pfile = COM_ParseFile( pfile, fs_path );

	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1131 : 			if( Q_stricmp( fs_path, GameInfo->basedir ) || Q_stricmp( fs_path, GameInfo->gamedir ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@FS_ReadGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	lea	ecx, DWORD PTR _fs_path$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@FS_ReadGam
$LN16@FS_ReadGam:

; 1132 : 				Q_strncpy( GameInfo->gamedir, fs_path, sizeof( GameInfo->gamedir ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _fs_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN15@FS_ReadGam:

; 1133 : 		}

	jmp	$LN66@FS_ReadGam
$LN13@FS_ReadGam:

; 1134 : 		else if( !Q_stricmp( token, "title" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_05PHLGJONK@title@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@FS_ReadGam

; 1135 : 		{
; 1136 : 			pfile = COM_ParseFile( pfile, GameInfo->title );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1137 : 		}

	jmp	$LN66@FS_ReadGam
$LN17@FS_ReadGam:

; 1138 : 		else if( !Q_stricmp( token, "sp_entity" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09HBKHHKHA@sp_entity@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@FS_ReadGam

; 1139 : 		{
; 1140 : 			pfile = COM_ParseFile( pfile, GameInfo->sp_entity );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1304				; 00000518H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1141 : 		}

	jmp	$LN66@FS_ReadGam
$LN19@FS_ReadGam:

; 1142 : 		else if( !Q_stricmp( token, "mp_entity" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09EIMAMLCL@mp_entity@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_ReadGam

; 1143 : 		{
; 1144 : 			pfile = COM_ParseFile( pfile, GameInfo->mp_entity );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1145 : 		}

	jmp	$LN66@FS_ReadGam
$LN21@FS_ReadGam:

; 1146 : 		else if( !Q_stricmp( token, "mp_filter" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09GINOKCID@mp_filter@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@FS_ReadGam

; 1147 : 		{
; 1148 : 			pfile = COM_ParseFile( pfile, GameInfo->mp_filter );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1368				; 00000558H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1149 : 		}

	jmp	$LN66@FS_ReadGam
$LN23@FS_ReadGam:

; 1150 : 		else if( !Q_stricmp( token, "gamedll" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07LEELFMGH@gamedll@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@FS_ReadGam

; 1151 : 		{
; 1152 : 			pfile = COM_ParseFile( pfile, GameInfo->game_dll );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1153 : 		}

	jmp	$LN66@FS_ReadGam
$LN25@FS_ReadGam:

; 1154 : 		else if( !Q_stricmp( token, "dllpath" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07HJMIDGON@dllpath@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@FS_ReadGam

; 1155 : 		{
; 1156 : 			pfile = COM_ParseFile( pfile, GameInfo->dll_path );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1157 : 		}

	jmp	$LN66@FS_ReadGam
$LN27@FS_ReadGam:

; 1158 : 		else if( !Q_stricmp( token, "startmap" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08DANNNBIA@startmap@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@FS_ReadGam

; 1159 : 		{
; 1160 : 			pfile = COM_ParseFile( pfile, GameInfo->startmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1161 : 			COM_StripExtension( GameInfo->startmap ); // HQ2:Amen has extension .bsp

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 1162 : 		}

	jmp	$LN66@FS_ReadGam
$LN29@FS_ReadGam:

; 1163 : 		else if( !Q_stricmp( token, "trainmap" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08NBJCMILF@trainmap@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@FS_ReadGam

; 1164 : 		{
; 1165 : 			pfile = COM_ParseFile( pfile, GameInfo->trainmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1166 : 			COM_StripExtension( GameInfo->trainmap ); // HQ2:Amen has extension .bsp

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 1167 : 		}

	jmp	$LN66@FS_ReadGam
$LN31@FS_ReadGam:

; 1168 : 		else if( !Q_stricmp( token, "icon" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04DMJJIPAH@icon@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@FS_ReadGam

; 1169 : 		{
; 1170 : 			pfile = COM_ParseFile( pfile, GameInfo->iconpath );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1171 : 			COM_DefaultExtension( GameInfo->iconpath, ".ico" );

	push	OFFSET ??_C@_04KJPGCDBP@?4ico@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 1172 : 		}

	jmp	$LN66@FS_ReadGam
$LN33@FS_ReadGam:

; 1173 : 		else if( !Q_stricmp( token, "url_info" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08BNJNDCGD@url_info@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@FS_ReadGam

; 1174 : 		{
; 1175 : 			pfile = COM_ParseFile( pfile, GameInfo->game_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 644				; 00000284H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1176 : 		}

	jmp	$LN66@FS_ReadGam
$LN35@FS_ReadGam:

; 1177 : 		else if( !Q_stricmp( token, "url_update" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@MOMIJKBF@url_update@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN37@FS_ReadGam

; 1178 : 		{
; 1179 : 			pfile = COM_ParseFile( pfile, GameInfo->update_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1180 : 		}

	jmp	$LN66@FS_ReadGam
$LN37@FS_ReadGam:

; 1181 : 		else if( !Q_stricmp( token, "date" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04JNIHBGGH@date@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@FS_ReadGam

; 1182 : 		{
; 1183 : 			pfile = COM_ParseFile( pfile, GameInfo->date );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1220				; 000004c4H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1184 : 		}

	jmp	$LN66@FS_ReadGam
$LN39@FS_ReadGam:

; 1185 : 		else if( !Q_stricmp( token, "type" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN41@FS_ReadGam

; 1186 : 		{
; 1187 : 			pfile = COM_ParseFile( pfile, GameInfo->type );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1188 : 		}

	jmp	$LN66@FS_ReadGam
$LN41@FS_ReadGam:

; 1189 : 		else if( !Q_stricmp( token, "version" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07CPCPJPKL@version@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN43@FS_ReadGam

; 1190 : 		{
; 1191 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1192 : 			GameInfo->version = Q_atof( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	fstp	DWORD PTR [ecx+448]

; 1193 : 		}

	jmp	$LN66@FS_ReadGam
$LN43@FS_ReadGam:

; 1194 : 		else if( !Q_stricmp( token, "size" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04IAGNFIBA@size@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN45@FS_ReadGam

; 1195 : 		{
; 1196 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1197 : 			GameInfo->size = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1284], eax

; 1198 : 		}

	jmp	$LN66@FS_ReadGam
$LN45@FS_ReadGam:

; 1199 : 		else if( !Q_stricmp( token, "max_edicts" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0L@FGNAPDKD@max_edicts@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN47@FS_ReadGam

; 1200 : 		{
; 1201 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1202 : 			GameInfo->max_edicts = bound( 600, Q_atoi( token ), MAX_EDICTS );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 600				; 00000258H
	jl	SHORT $LN75@FS_ReadGam
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 8192				; 00002000H
	jge	SHORT $LN73@FS_ReadGam
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv380[ebp], eax
	jmp	SHORT $LN74@FS_ReadGam
$LN73@FS_ReadGam:
	mov	DWORD PTR tv380[ebp], 8192		; 00002000H
$LN74@FS_ReadGam:
	mov	eax, DWORD PTR tv380[ebp]
	mov	DWORD PTR tv381[ebp], eax
	jmp	SHORT $LN76@FS_ReadGam
$LN75@FS_ReadGam:
	mov	DWORD PTR tv381[ebp], 600		; 00000258H
$LN76@FS_ReadGam:
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	edx, DWORD PTR tv381[ebp]
	mov	DWORD PTR [ecx+1656], edx

; 1203 : 		}

	jmp	$LN66@FS_ReadGam
$LN47@FS_ReadGam:

; 1204 : 		else if( !Q_stricmp( token, "max_tempents" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@PJLMDBP@max_tempents@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN49@FS_ReadGam

; 1205 : 		{
; 1206 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1207 : 			GameInfo->max_tents = bound( 300, Q_atoi( token ), 2048 );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 300				; 0000012cH
	jl	SHORT $LN79@FS_ReadGam
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 2048				; 00000800H
	jge	SHORT $LN77@FS_ReadGam
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv399[ebp], eax
	jmp	SHORT $LN78@FS_ReadGam
$LN77@FS_ReadGam:
	mov	DWORD PTR tv399[ebp], 2048		; 00000800H
$LN78@FS_ReadGam:
	mov	eax, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv400[ebp], eax
	jmp	SHORT $LN80@FS_ReadGam
$LN79@FS_ReadGam:
	mov	DWORD PTR tv400[ebp], 300		; 0000012cH
$LN80@FS_ReadGam:
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	edx, DWORD PTR tv400[ebp]
	mov	DWORD PTR [ecx+1660], edx

; 1208 : 		}

	jmp	$LN66@FS_ReadGam
$LN49@FS_ReadGam:

; 1209 : 		else if( !Q_stricmp( token, "max_beams" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_09KDFCKJJ@max_beams@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN51@FS_ReadGam

; 1210 : 		{
; 1211 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1212 : 			GameInfo->max_beams = bound( 64, Q_atoi( token ), 512 );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jl	SHORT $LN83@FS_ReadGam
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 512				; 00000200H
	jge	SHORT $LN81@FS_ReadGam
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv418[ebp], eax
	jmp	SHORT $LN82@FS_ReadGam
$LN81@FS_ReadGam:
	mov	DWORD PTR tv418[ebp], 512		; 00000200H
$LN82@FS_ReadGam:
	mov	eax, DWORD PTR tv418[ebp]
	mov	DWORD PTR tv419[ebp], eax
	jmp	SHORT $LN84@FS_ReadGam
$LN83@FS_ReadGam:
	mov	DWORD PTR tv419[ebp], 64		; 00000040H
$LN84@FS_ReadGam:
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	edx, DWORD PTR tv419[ebp]
	mov	DWORD PTR [ecx+1664], edx

; 1213 : 		}

	jmp	$LN66@FS_ReadGam
$LN51@FS_ReadGam:

; 1214 : 		else if( !Q_stricmp( token, "max_particles" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0O@IOJCOOJJ@max_particles@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN53@FS_ReadGam

; 1215 : 		{
; 1216 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1217 : 			GameInfo->max_particles = bound( 1024, Q_atoi( token ), 131072 );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 1024				; 00000400H
	jl	SHORT $LN87@FS_ReadGam
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	call	_Q_atoi
	add	esp, 4
	cmp	eax, 131072				; 00020000H
	jge	SHORT $LN85@FS_ReadGam
	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR tv437[ebp], eax
	jmp	SHORT $LN86@FS_ReadGam
$LN85@FS_ReadGam:
	mov	DWORD PTR tv437[ebp], 131072		; 00020000H
$LN86@FS_ReadGam:
	mov	eax, DWORD PTR tv437[ebp]
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN88@FS_ReadGam
$LN87@FS_ReadGam:
	mov	DWORD PTR tv438[ebp], 1024		; 00000400H
$LN88@FS_ReadGam:
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	edx, DWORD PTR tv438[ebp]
	mov	DWORD PTR [ecx+1668], edx

; 1218 : 		}

	jmp	$LN66@FS_ReadGam
$LN53@FS_ReadGam:

; 1219 : 		else if( !Q_stricmp( token, "gamemode" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08NKFOLMGC@gamemode@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN55@FS_ReadGam

; 1220 : 		{
; 1221 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1222 : 			if( !Q_stricmp( token, "singleplayer_only" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0BC@KBHPDGLE@singleplayer_only@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN57@FS_ReadGam

; 1223 : 				GameInfo->gamemode = 1;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1288], 1
	jmp	SHORT $LN59@FS_ReadGam
$LN57@FS_ReadGam:

; 1224 : 			else if( !Q_stricmp( token, "multiplayer_only" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0BB@PCDEEONN@multiplayer_only@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN59@FS_ReadGam

; 1225 : 				GameInfo->gamemode = 2;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1288], 2
$LN59@FS_ReadGam:

; 1226 : 		}

	jmp	$LN66@FS_ReadGam
$LN55@FS_ReadGam:

; 1227 : 		else if( !Q_stricmp( token, "secure" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06CKKGAKDB@secure@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN60@FS_ReadGam

; 1228 : 		{
; 1229 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1230 : 			GameInfo->secure = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1292], eax

; 1231 : 		}

	jmp	$LN66@FS_ReadGam
$LN60@FS_ReadGam:

; 1232 : 		else if( !Q_stricmp( token, "nomodels" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08LCMKFNBH@nomodels@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN62@FS_ReadGam

; 1233 : 		{
; 1234 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1235 : 			GameInfo->nomodels = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1296], eax

; 1236 : 		}

	jmp	$LN66@FS_ReadGam
$LN62@FS_ReadGam:

; 1237 : 		else if( !Q_stricmp( token, "noskills" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08JLCCHDKJ@noskills@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN64@FS_ReadGam

; 1238 : 		{
; 1239 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1240 : 			GameInfo->noskills = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1300], eax

; 1241 : 		}

	jmp	SHORT $LN66@FS_ReadGam
$LN64@FS_ReadGam:

; 1242 : 		else if( !Q_strnicmp( token, "ambient", 7 ))

	push	7
	push	OFFSET ??_C@_07LIABELBC@ambient@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN66@FS_ReadGam

; 1243 : 		{
; 1244 : 			int	ambientNum = Q_atoi( token + 7 );

	lea	eax, DWORD PTR _token$[ebp+7]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _ambientNum$1[ebp], eax

; 1245 : 
; 1246 : 			if( ambientNum < 0 || ambientNum > ( NUM_AMBIENTS - 1 ))

	cmp	DWORD PTR _ambientNum$1[ebp], 0
	jl	SHORT $LN68@FS_ReadGam
	cmp	DWORD PTR _ambientNum$1[ebp], 3
	jle	SHORT $LN67@FS_ReadGam
$LN68@FS_ReadGam:

; 1247 : 				ambientNum = 0;

	mov	DWORD PTR _ambientNum$1[ebp], 0
$LN67@FS_ReadGam:

; 1248 : 			pfile = COM_ParseFile( pfile, GameInfo->ambientsound[ambientNum] );

	mov	eax, DWORD PTR _ambientNum$1[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1400]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	push	eax
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
$LN66@FS_ReadGam:

; 1249 : 		}
; 1250 : 	}

	jmp	$LN2@FS_ReadGam
$LN3@FS_ReadGam:

; 1251 : 
; 1252 : 	// make sure what gamedir is really exist
; 1253 : 	if( !FS_SysFolderExists( va( "%s\\%s", host.rootdir, GameInfo->gamedir )))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_SysFolderExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN69@FS_ReadGam

; 1254 : 		Q_strncpy( GameInfo->gamedir, gamedir, sizeof( GameInfo->gamedir ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN69@FS_ReadGam:

; 1255 : 
; 1256 : 	// make sure what fallback_dir is really exist
; 1257 : 	if( !FS_SysFolderExists( va( "%s\\%s", host.rootdir, GameInfo->falldir )))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_SysFolderExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN70@FS_ReadGam

; 1258 : 		GameInfo->falldir[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _GameInfo$[ebp]
	mov	BYTE PTR [edx+ecx+192], 0
$LN70@FS_ReadGam:

; 1259 : 
; 1260 : 	if( afile != NULL )

	cmp	DWORD PTR _afile$[ebp], 0
	je	SHORT $LN71@FS_ReadGam

; 1261 : 		Mem_Free( afile );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_ReadGameInfo@@9@9
	add	eax, 174				; 000000aeH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _afile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN71@FS_ReadGam:

; 1262 : 
; 1263 : 	return true;

	mov	eax, 1
$LN1@FS_ReadGam:

; 1264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ReadGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ConvertGameInfo
_TEXT	SEGMENT
_GameInfo$ = -1676					; size = 1672
__$ArrayPad$ = -4					; size = 4
_gamedir$ = 8						; size = 4
_gameinfo_path$ = 12					; size = 4
_liblist_path$ = 16					; size = 4
_FS_ConvertGameInfo PROC				; COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1932				; 0000078cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1070 : 	gameinfo_t	GameInfo;
; 1071 : 
; 1072 : 	memset( &GameInfo, 0, sizeof( GameInfo ));

	push	1672					; 00000688H
	push	0
	lea	eax, DWORD PTR _GameInfo$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1073 : 
; 1074 : 	if( FS_ParseLiblistGam( liblist_path, gamedir, &GameInfo ))

	lea	eax, DWORD PTR _GameInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gamedir$[ebp]
	push	ecx
	mov	edx, DWORD PTR _liblist_path$[ebp]
	push	edx
	call	_FS_ParseLiblistGam
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN1@FS_Convert

; 1075 : 	{
; 1076 : 		Con_DPrintf( "Convert %s to %s\n", liblist_path, gameinfo_path );

	mov	eax, DWORD PTR _gameinfo_path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _liblist_path$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@LBDHMDCA@Convert?5?$CFs?5to?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 1077 : 		FS_WriteGameInfo( gameinfo_path, &GameInfo );

	lea	eax, DWORD PTR _GameInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gameinfo_path$[ebp]
	push	ecx
	call	_FS_WriteGameInfo
	add	esp, 8
$LN1@FS_Convert:

; 1078 : 	}
; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ConvertGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ParseLiblistGam
_TEXT	SEGMENT
_token$ = -268						; size = 256
_pfile$ = -12						; size = 4
_afile$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_gamedir$ = 12						; size = 4
_GameInfo$ = 16						; size = 4
_FS_ParseLiblistGam PROC				; COMDAT

; 925  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 926  : 	char	*afile, *pfile;
; 927  : 	string	token;
; 928  : 
; 929  : 	if( !GameInfo ) return false;	

	cmp	DWORD PTR _GameInfo$[ebp], 0
	jne	SHORT $LN4@FS_ParseLi
	xor	eax, eax
	jmp	$LN1@FS_ParseLi
$LN4@FS_ParseLi:

; 930  : 	afile = FS_LoadFile( filename, NULL, false );

	push	0
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _afile$[ebp], eax

; 931  : 	if( !afile ) return false;

	cmp	DWORD PTR _afile$[ebp], 0
	jne	SHORT $LN5@FS_ParseLi
	xor	eax, eax
	jmp	$LN1@FS_ParseLi
$LN5@FS_ParseLi:

; 932  : 
; 933  : 	// setup default values
; 934  : 	GameInfo->max_edicts = 900;	// default value if not specified

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1656], 900		; 00000384H

; 935  : 	GameInfo->max_tents = 500;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1660], 500		; 000001f4H

; 936  : 	GameInfo->max_beams = 128;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1664], 128		; 00000080H

; 937  : 	GameInfo->max_particles = 4096;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1668], 4096		; 00001000H

; 938  : 	GameInfo->version = 1.0f;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+448], xmm0

; 939  : 	GameInfo->falldir[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _GameInfo$[ebp]
	mov	BYTE PTR [edx+ecx+192], 0

; 940  : 	
; 941  : 	Q_strncpy( GameInfo->title, "New Game", sizeof( GameInfo->title ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08IIACKFCG@New?5Game@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 942  : 	Q_strncpy( GameInfo->gamedir, gamedir, sizeof( GameInfo->gamedir ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 943  : 	Q_strncpy( GameInfo->basedir, fs_basedir, sizeof( GameInfo->basedir ));

	push	64					; 00000040H
	push	OFFSET _fs_basedir
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 944  : 	Q_strncpy( GameInfo->sp_entity, "info_player_start", sizeof( GameInfo->sp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BC@IHPKIKNE@info_player_start@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1304				; 00000518H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 945  : 	Q_strncpy( GameInfo->mp_entity, "info_player_deathmatch", sizeof( GameInfo->mp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BH@IGAFCIL@info_player_deathmatch@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 946  : 	Q_strncpy( GameInfo->game_dll, "dlls/hl.dll", sizeof( GameInfo->game_dll ));

	push	64					; 00000040H
	push	OFFSET ??_C@_0M@FCEMCLHB@dlls?1hl?4dll@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 947  : 	Q_strncpy( GameInfo->startmap, "newmap", sizeof( GameInfo->startmap ));

	push	64					; 00000040H
	push	OFFSET ??_C@_06FLHECDA@newmap@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 948  : 	Q_strncpy( GameInfo->dll_path, "cl_dlls", sizeof( GameInfo->dll_path ));

	push	64					; 00000040H
	push	OFFSET ??_C@_07CNOKJKDK@cl_dlls@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 949  : 	Q_strncpy( GameInfo->iconpath, "game.ico", sizeof( GameInfo->iconpath ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08BPMGDPCI@game?4ico@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 950  : 
; 951  : 	pfile = afile;

	mov	eax, DWORD PTR _afile$[ebp]
	mov	DWORD PTR _pfile$[ebp], eax
$LN2@FS_ParseLi:

; 952  : 
; 953  : 	while(( pfile = COM_ParseFile( pfile, token )) != NULL )

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
	cmp	DWORD PTR _pfile$[ebp], 0
	je	$LN3@FS_ParseLi

; 954  : 	{
; 955  : 		if( !Q_stricmp( token, "game" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04MJNAPEEI@game@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FS_ParseLi

; 956  : 		{
; 957  : 			pfile = COM_ParseFile( pfile, GameInfo->title );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
$LN6@FS_ParseLi:

; 958  : 		}
; 959  : 		if( !Q_stricmp( token, "gamedir" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07GGMBKBFD@gamedir@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@FS_ParseLi

; 960  : 		{
; 961  : 			pfile = COM_ParseFile( pfile, GameInfo->gamedir );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax
$LN7@FS_ParseLi:

; 962  : 		}
; 963  : 		if( !Q_stricmp( token, "fallback_dir" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@JOMOAPOL@fallback_dir@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@FS_ParseLi

; 964  : 		{
; 965  : 			pfile = COM_ParseFile( pfile, GameInfo->falldir );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 966  : 		}

	jmp	$LN41@FS_ParseLi
$LN8@FS_ParseLi:

; 967  : 		else if( !Q_stricmp( token, "startmap" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08DANNNBIA@startmap@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@FS_ParseLi

; 968  : 		{
; 969  : 			pfile = COM_ParseFile( pfile, GameInfo->startmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 970  : 			COM_StripExtension( GameInfo->startmap ); // HQ2:Amen has extension .bsp

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 971  : 		}

	jmp	$LN41@FS_ParseLi
$LN10@FS_ParseLi:

; 972  : 		else if( !Q_stricmp( token, "trainmap" ) || !Q_stricmp( token, "trainingmap" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08NBJCMILF@trainmap@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN14@FS_ParseLi
	push	99999					; 0001869fH
	push	OFFSET ??_C@_0M@KGAILJGP@trainingmap@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@FS_ParseLi
$LN14@FS_ParseLi:

; 973  : 		{
; 974  : 			pfile = COM_ParseFile( pfile, GameInfo->trainmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 975  : 			COM_StripExtension( GameInfo->trainmap ); // HQ2:Amen has extension .bsp

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 976  : 		}

	jmp	$LN41@FS_ParseLi
$LN12@FS_ParseLi:

; 977  : 		else if( !Q_stricmp( token, "url_info" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08BNJNDCGD@url_info@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@FS_ParseLi

; 978  : 		{
; 979  : 			pfile = COM_ParseFile( pfile, GameInfo->game_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 644				; 00000284H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 980  : 		}

	jmp	$LN41@FS_ParseLi
$LN15@FS_ParseLi:

; 981  : 		else if( !Q_stricmp( token, "url_dl" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06NDBDLBCI@url_dl@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@FS_ParseLi

; 982  : 		{
; 983  : 			pfile = COM_ParseFile( pfile, GameInfo->update_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 984  : 		}

	jmp	$LN41@FS_ParseLi
$LN17@FS_ParseLi:

; 985  : 		else if( !Q_stricmp( token, "gamedll" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07LEELFMGH@gamedll@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@FS_ParseLi

; 986  : 		{
; 987  : 			pfile = COM_ParseFile( pfile, GameInfo->game_dll );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 988  : 			COM_FixSlashes( GameInfo->game_dll );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 989  : 		}

	jmp	$LN41@FS_ParseLi
$LN19@FS_ParseLi:

; 990  : 		else if( !Q_stricmp( token, "icon" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04DMJJIPAH@icon@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@FS_ParseLi

; 991  : 		{
; 992  : 			pfile = COM_ParseFile( pfile, GameInfo->iconpath );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 993  : 			COM_FixSlashes( GameInfo->iconpath );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 994  : 			COM_DefaultExtension( GameInfo->iconpath, ".ico" );

	push	OFFSET ??_C@_04KJPGCDBP@?4ico@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 995  : 		}

	jmp	$LN41@FS_ParseLi
$LN21@FS_ParseLi:

; 996  : 		else if( !Q_stricmp( token, "type" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04GPMDFGEJ@type@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN23@FS_ParseLi

; 997  : 		{
; 998  : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 999  : 
; 1000 : 			if( !Q_stricmp( token, "singleplayer_only" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0BC@KBHPDGLE@singleplayer_only@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@FS_ParseLi

; 1001 : 			{
; 1002 : 				GameInfo->gamemode = 1;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1288], 1

; 1003 : 				Q_strncpy( GameInfo->type, "Single", sizeof( GameInfo->type ));

	push	64					; 00000040H
	push	OFFSET ??_C@_06IGOBCGAJ@Single@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1004 : 			}

	jmp	SHORT $LN28@FS_ParseLi
$LN25@FS_ParseLi:

; 1005 : 			else if( !Q_stricmp( token, "multiplayer_only" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0BB@PCDEEONN@multiplayer_only@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN27@FS_ParseLi

; 1006 : 			{
; 1007 : 				GameInfo->gamemode = 2;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1288], 2

; 1008 : 				Q_strncpy( GameInfo->type, "Multiplayer", sizeof( GameInfo->type ));

	push	64					; 00000040H
	push	OFFSET ??_C@_0M@HOINAANG@Multiplayer@
	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1009 : 			}

	jmp	SHORT $LN28@FS_ParseLi
$LN27@FS_ParseLi:

; 1010 : 			else
; 1011 : 			{
; 1012 : 				// pass type without changes
; 1013 : 				GameInfo->gamemode = 0;

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [eax+1288], 0

; 1014 : 				Q_strncpy( GameInfo->type, token, sizeof( GameInfo->type ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 1156				; 00000484H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN28@FS_ParseLi:

; 1015 : 			}
; 1016 : 		}

	jmp	$LN41@FS_ParseLi
$LN23@FS_ParseLi:

; 1017 : 		else if( !Q_stricmp( token, "version" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_07CPCPJPKL@version@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@FS_ParseLi

; 1018 : 		{
; 1019 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1020 : 			GameInfo->version = Q_atof( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	fstp	DWORD PTR [ecx+448]

; 1021 : 		}

	jmp	$LN41@FS_ParseLi
$LN29@FS_ParseLi:

; 1022 : 		else if( !Q_stricmp( token, "size" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04IAGNFIBA@size@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@FS_ParseLi

; 1023 : 		{
; 1024 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1025 : 			GameInfo->size = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1284], eax

; 1026 : 		}

	jmp	$LN41@FS_ParseLi
$LN31@FS_ParseLi:

; 1027 : 		else if( !Q_stricmp( token, "edicts" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06MCCDKJOH@edicts@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@FS_ParseLi

; 1028 : 		{
; 1029 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1030 : 			GameInfo->max_edicts = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1656], eax

; 1031 : 		}

	jmp	$LN41@FS_ParseLi
$LN33@FS_ParseLi:

; 1032 : 		else if( !Q_stricmp( token, "mpentity" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08BEIDONOP@mpentity@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@FS_ParseLi

; 1033 : 		{
; 1034 : 			pfile = COM_ParseFile( pfile, GameInfo->mp_entity );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1035 : 		}

	jmp	$LN41@FS_ParseLi
$LN35@FS_ParseLi:

; 1036 : 		else if( !Q_stricmp( token, "mpfilter" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08DEJNIEEH@mpfilter@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN37@FS_ParseLi

; 1037 : 		{
; 1038 : 			pfile = COM_ParseFile( pfile, GameInfo->mp_filter );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1368				; 00000558H
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1039 : 		}

	jmp	$LN41@FS_ParseLi
$LN37@FS_ParseLi:

; 1040 : 		else if( !Q_stricmp( token, "secure" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_06CKKGAKDB@secure@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@FS_ParseLi

; 1041 : 		{
; 1042 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1043 : 			GameInfo->secure = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1292], eax

; 1044 : 		}

	jmp	SHORT $LN41@FS_ParseLi
$LN39@FS_ParseLi:

; 1045 : 		else if( !Q_stricmp( token, "nomodels" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08LCMKFNBH@nomodels@
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN41@FS_ParseLi

; 1046 : 		{
; 1047 : 			pfile = COM_ParseFile( pfile, token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _pfile$[ebp], eax

; 1048 : 			GameInfo->nomodels = Q_atoi( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	mov	DWORD PTR [ecx+1296], eax
$LN41@FS_ParseLi:

; 1049 : 		}
; 1050 : 	}

	jmp	$LN2@FS_ParseLi
$LN3@FS_ParseLi:

; 1051 : 
; 1052 : 	if( !FS_SysFolderExists( va( "%s\\%s", host.rootdir, GameInfo->gamedir )))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_SysFolderExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN42@FS_ParseLi

; 1053 : 		Q_strncpy( GameInfo->gamedir, gamedir, sizeof( GameInfo->gamedir ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _gamedir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN42@FS_ParseLi:

; 1054 : 
; 1055 : 	if( !FS_SysFolderExists( va( "%s\\%s", host.rootdir, GameInfo->falldir )))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	push	OFFSET _host+34424
	push	OFFSET ??_C@_05BMGBEOOC@?$CFs?2?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	call	_FS_SysFolderExists
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN43@FS_ParseLi

; 1056 : 		GameInfo->falldir[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _GameInfo$[ebp]
	mov	BYTE PTR [edx+ecx+192], 0
$LN43@FS_ParseLi:

; 1057 : 
; 1058 : 	Mem_Free( afile );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_ParseLiblistGam@@9@9
	add	eax, 133				; 00000085H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _afile$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1059 : 
; 1060 : 	return true;

	mov	eax, 1
$LN1@FS_ParseLi:

; 1061 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ParseLiblistGam ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_CreateDefaultGameInfo
_TEXT	SEGMENT
_defGI$ = -1676						; size = 1672
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_FS_CreateDefaultGameInfo PROC				; COMDAT

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1932				; 0000078cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 893  : 	gameinfo_t	defGI;
; 894  : 
; 895  : 	memset( &defGI, 0, sizeof( defGI ));

	push	1672					; 00000688H
	push	0
	lea	eax, DWORD PTR _defGI$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 896  : 
; 897  : 	// setup default values
; 898  : 	defGI.max_edicts = 900;	// default value if not specified

	mov	DWORD PTR _defGI$[ebp+1656], 900	; 00000384H

; 899  : 	defGI.max_tents = 500;

	mov	DWORD PTR _defGI$[ebp+1660], 500	; 000001f4H

; 900  : 	defGI.max_beams = 128;

	mov	DWORD PTR _defGI$[ebp+1664], 128	; 00000080H

; 901  : 	defGI.max_particles = 4096;

	mov	DWORD PTR _defGI$[ebp+1668], 4096	; 00001000H

; 902  : 	defGI.version = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _defGI$[ebp+448], xmm0

; 903  : 	defGI.falldir[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _defGI$[ebp+ecx+192], 0

; 904  : 
; 905  : 	Q_strncpy( defGI.title, "New Game", sizeof( defGI.title ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08IIACKFCG@New?5Game@
	lea	eax, DWORD PTR _defGI$[ebp+384]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 906  : 	Q_strncpy( defGI.gamedir, fs_gamedir, sizeof( defGI.gamedir ));

	push	64					; 00000040H
	push	OFFSET _fs_gamedir
	lea	eax, DWORD PTR _defGI$[ebp+128]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 907  : 	Q_strncpy( defGI.basedir, fs_basedir, sizeof( defGI.basedir ));

	push	64					; 00000040H
	push	OFFSET _fs_basedir
	lea	eax, DWORD PTR _defGI$[ebp+64]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 908  : 	Q_strncpy( defGI.sp_entity, "info_player_start", sizeof( defGI.sp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BC@IHPKIKNE@info_player_start@
	lea	eax, DWORD PTR _defGI$[ebp+1304]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 909  : 	Q_strncpy( defGI.mp_entity, "info_player_deathmatch", sizeof( defGI.mp_entity ));

	push	32					; 00000020H
	push	OFFSET ??_C@_0BH@IGAFCIL@info_player_deathmatch@
	lea	eax, DWORD PTR _defGI$[ebp+1336]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 910  : 	Q_strncpy( defGI.dll_path, "cl_dlls", sizeof( defGI.dll_path ));

	push	64					; 00000040H
	push	OFFSET ??_C@_07CNOKJKDK@cl_dlls@
	lea	eax, DWORD PTR _defGI$[ebp+452]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 911  : 	Q_strncpy( defGI.game_dll, "dlls/hl.dll", sizeof( defGI.game_dll ));

	push	64					; 00000040H
	push	OFFSET ??_C@_0M@FCEMCLHB@dlls?1hl?4dll@
	lea	eax, DWORD PTR _defGI$[ebp+516]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 912  : 	Q_strncpy( defGI.startmap, "newmap", sizeof( defGI.startmap ));

	push	64					; 00000040H
	push	OFFSET ??_C@_06FLHECDA@newmap@
	lea	eax, DWORD PTR _defGI$[ebp+256]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 913  : 	Q_strncpy( defGI.iconpath, "game.ico", sizeof( defGI.iconpath ));

	push	64					; 00000040H
	push	OFFSET ??_C@_08BPMGDPCI@game?4ico@
	lea	eax, DWORD PTR _defGI$[ebp+580]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 914  : 
; 915  : 	// make simple gameinfo.txt
; 916  : 	FS_WriteGameInfo( filename, &defGI );

	lea	eax, DWORD PTR _defGI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_WriteGameInfo
	add	esp, 8

; 917  : } 

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CreateDefaultGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_WriteGameInfo
_TEXT	SEGMENT
tv223 = -80						; size = 4
_write_ambients$ = -12					; size = 4
_i$ = -8						; size = 4
_f$ = -4						; size = 4
_filepath$ = 8						; size = 4
_GameInfo$ = 12						; size = 4
_FS_WriteGameInfo PROC					; COMDAT

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 790  : 	file_t	*f = FS_Open( filepath, "w", false ); // we in binary-mode

	push	0
	push	OFFSET ??_C@_01NOFIACDB@w@
	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _f$[ebp], eax

; 791  : 	int	i, write_ambients = false;

	mov	DWORD PTR _write_ambients$[ebp], 0

; 792  : 
; 793  : 	if( !f ) Sys_Error( "FS_WriteGameInfo: can't write %s\n", filepath );	// may be disk-space is out?

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN7@FS_WriteGa
	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@DJANCFLM@FS_WriteGameInfo?3?5can?8t?5write?5?$CF@
	call	_Sys_Error
	add	esp, 8
$LN7@FS_WriteGa:

; 794  : 
; 795  : 	FS_Print( f, "// generated by Xash3D\n\n\n" );

	push	OFFSET ??_C@_0BK@PKJNFFLK@?1?1?5generated?5by?5Xash3D?6?6?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 796  : 
; 797  : 	if( Q_strlen( GameInfo->basedir ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@FS_WriteGa

; 798  : 		FS_Printf( f, "basedir\t\t\"%s\"\n", GameInfo->basedir );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	push	OFFSET ??_C@_0P@GBNGDPD@basedir?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN8@FS_WriteGa:

; 799  : 
; 800  : 	if( Q_strlen( GameInfo->gamedir ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@FS_WriteGa

; 801  : 		FS_Printf( f, "gamedir\t\t\"%s\"\n", GameInfo->gamedir );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET ??_C@_0P@HLHLHHBC@gamedir?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN9@FS_WriteGa:

; 802  : 
; 803  : 	if( Q_strlen( GameInfo->falldir ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@FS_WriteGa

; 804  : 		FS_Printf( f, "fallback_dir\t\"%s\"\n", GameInfo->falldir );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 192				; 000000c0H
	push	eax
	push	OFFSET ??_C@_0BD@PBLNEELD@fallback_dir?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN10@FS_WriteGa:

; 805  : 
; 806  : 	if( Q_strlen( GameInfo->title ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@FS_WriteGa

; 807  : 		FS_Printf( f, "title\t\t\"%s\"\n", GameInfo->title );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 384				; 00000180H
	push	eax
	push	OFFSET ??_C@_0N@NNNHNHFF@title?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN11@FS_WriteGa:

; 808  : 
; 809  : 	if( Q_strlen( GameInfo->startmap ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN12@FS_WriteGa

; 810  : 		FS_Printf( f, "startmap\t\t\"%s\"\n", GameInfo->startmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	push	OFFSET ??_C@_0BA@KBAEEJPG@startmap?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN12@FS_WriteGa:

; 811  : 
; 812  : 	if( Q_strlen( GameInfo->trainmap ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@FS_WriteGa

; 813  : 		FS_Printf( f, "trainmap\t\t\"%s\"\n", GameInfo->trainmap );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 320				; 00000140H
	push	eax
	push	OFFSET ??_C@_0BA@MLOGHJJF@trainmap?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN13@FS_WriteGa:

; 814  : 
; 815  : 	if( GameInfo->version != 0.0f )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	movss	xmm0, DWORD PTR [eax+448]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@FS_WriteGa

; 816  : 		FS_Printf( f, "version\t\t%g\n", GameInfo->version );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+448]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0N@MJFNDPFP@version?7?7?$CFg?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN14@FS_WriteGa:

; 817  : 
; 818  : 	if( GameInfo->size != 0 )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1284], 0
	je	SHORT $LN15@FS_WriteGa

; 819  : 		FS_Printf( f, "size\t\t%i\n", GameInfo->size );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1284]
	push	ecx
	push	OFFSET ??_C@_09BFMPAEGH@size?7?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN15@FS_WriteGa:

; 820  : 
; 821  : 	if( Q_strlen( GameInfo->game_url ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 644				; 00000284H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@FS_WriteGa

; 822  : 		FS_Printf( f, "url_info\t\t\"%s\"\n", GameInfo->game_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 644				; 00000284H
	push	eax
	push	OFFSET ??_C@_0BA@JDHLDPK@url_info?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN16@FS_WriteGa:

; 823  : 
; 824  : 	if( Q_strlen( GameInfo->update_url ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@FS_WriteGa

; 825  : 		FS_Printf( f, "url_update\t\t\"%s\"\n", GameInfo->update_url );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	push	OFFSET ??_C@_0BC@LHNCJDKE@url_update?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN17@FS_WriteGa:

; 826  : 
; 827  : 	if( Q_strlen( GameInfo->type ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN18@FS_WriteGa

; 828  : 		FS_Printf( f, "type\t\t\"%s\"\n", GameInfo->type );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1156				; 00000484H
	push	eax
	push	OFFSET ??_C@_0M@LHIKIBNJ@type?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN18@FS_WriteGa:

; 829  : 
; 830  : 	if( Q_strlen( GameInfo->date ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1220				; 000004c4H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@FS_WriteGa

; 831  : 		FS_Printf( f, "date\t\t\"%s\"\n", GameInfo->date );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1220				; 000004c4H
	push	eax
	push	OFFSET ??_C@_0M@KGEMOJNB@date?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN19@FS_WriteGa:

; 832  : 
; 833  : 	if( Q_strlen( GameInfo->dll_path ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN20@FS_WriteGa

; 834  : 		FS_Printf( f, "dllpath\t\t\"%s\"\n", GameInfo->dll_path );	

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	push	OFFSET ??_C@_0P@ODIEAKM@dllpath?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN20@FS_WriteGa:

; 835  : 	if( Q_strlen( GameInfo->game_dll ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN21@FS_WriteGa

; 836  : 		FS_Printf( f, "gamedll\t\t\"%s\"\n", GameInfo->game_dll );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	push	OFFSET ??_C@_0P@PJFACFLF@gamedll?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN21@FS_WriteGa:

; 837  : 
; 838  : 	if( Q_strlen( GameInfo->iconpath ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN22@FS_WriteGa

; 839  : 		FS_Printf( f, "icon\t\t\"%s\"\n", GameInfo->iconpath );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	push	OFFSET ??_C@_0M@DNJELFDM@icon?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN22@FS_WriteGa:

; 840  : 
; 841  : 	switch( GameInfo->gamemode )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1288]
	mov	DWORD PTR tv223[ebp], ecx
	cmp	DWORD PTR tv223[ebp], 1
	je	SHORT $LN23@FS_WriteGa
	cmp	DWORD PTR tv223[ebp], 2
	je	SHORT $LN24@FS_WriteGa
	jmp	SHORT $LN2@FS_WriteGa
$LN23@FS_WriteGa:

; 842  : 	{
; 843  : 	case 1: FS_Print( f, "gamemode\t\t\"singleplayer_only\"\n" ); break;

	push	OFFSET ??_C@_0BP@PICPAFDH@gamemode?7?7?$CCsingleplayer_only?$CC?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8
	jmp	SHORT $LN2@FS_WriteGa
$LN24@FS_WriteGa:

; 844  : 	case 2: FS_Print( f, "gamemode\t\t\"multiplayer_only\"\n" ); break;

	push	OFFSET ??_C@_0BO@KCLFKGLF@gamemode?7?7?$CCmultiplayer_only?$CC?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8
$LN2@FS_WriteGa:

; 845  : 	}
; 846  : 
; 847  : 	if( Q_strlen( GameInfo->sp_entity ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1304				; 00000518H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN25@FS_WriteGa

; 848  : 		FS_Printf( f, "sp_entity\t\t\"%s\"\n", GameInfo->sp_entity );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1304				; 00000518H
	push	eax
	push	OFFSET ??_C@_0BB@CGGLFFDE@sp_entity?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN25@FS_WriteGa:

; 849  : 	if( Q_strlen( GameInfo->mp_entity ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN26@FS_WriteGa

; 850  : 		FS_Printf( f, "mp_entity\t\t\"%s\"\n", GameInfo->mp_entity );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1336				; 00000538H
	push	eax
	push	OFFSET ??_C@_0BB@HABODENP@mp_entity?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN26@FS_WriteGa:

; 851  : 	if( Q_strlen( GameInfo->mp_filter ))

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1368				; 00000558H
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN27@FS_WriteGa

; 852  : 		FS_Printf( f, "mp_filter\t\t\"%s\"\n", GameInfo->mp_filter );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	add	eax, 1368				; 00000558H
	push	eax
	push	OFFSET ??_C@_0BB@FEEDHBJJ@mp_filter?7?7?$CC?$CFs?$CC?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN27@FS_WriteGa:

; 853  : 
; 854  : 	if( GameInfo->secure )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1292], 0
	je	SHORT $LN28@FS_WriteGa

; 855  : 		FS_Printf( f, "secure\t\t\"%i\"\n", GameInfo->secure );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1292]
	push	ecx
	push	OFFSET ??_C@_0O@NBPNDANA@secure?7?7?$CC?$CFi?$CC?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN28@FS_WriteGa:

; 856  : 
; 857  : 	if( GameInfo->nomodels )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1296], 0
	je	SHORT $LN29@FS_WriteGa

; 858  : 		FS_Printf( f, "nomodels\t\t\"%i\"\n", GameInfo->nomodels );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1296]
	push	ecx
	push	OFFSET ??_C@_0BA@EICNFHDO@nomodels?7?7?$CC?$CFi?$CC?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN29@FS_WriteGa:

; 859  : 
; 860  : 	if( GameInfo->max_edicts > 0 )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1656], 0
	jle	SHORT $LN30@FS_WriteGa

; 861  : 		FS_Printf( f, "max_edicts\t%i\n", GameInfo->max_edicts );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1656]
	push	ecx
	push	OFFSET ??_C@_0P@MMHJGPOE@max_edicts?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN30@FS_WriteGa:

; 862  : 	if( GameInfo->max_tents > 0 )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1660], 0
	jle	SHORT $LN31@FS_WriteGa

; 863  : 		FS_Printf( f, "max_tempents\t%i\n", GameInfo->max_tents );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1660]
	push	ecx
	push	OFFSET ??_C@_0BB@LOIMAEMI@max_tempents?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN31@FS_WriteGa:

; 864  : 	if( GameInfo->max_beams > 0 )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1664], 0
	jle	SHORT $LN32@FS_WriteGa

; 865  : 		FS_Printf( f, "max_beams\t\t%i\n", GameInfo->max_beams );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1664]
	push	ecx
	push	OFFSET ??_C@_0P@MLMMLBFK@max_beams?7?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN32@FS_WriteGa:

; 866  : 	if( GameInfo->max_particles > 0 )

	mov	eax, DWORD PTR _GameInfo$[ebp]
	cmp	DWORD PTR [eax+1668], 0
	jle	SHORT $LN33@FS_WriteGa

; 867  : 		FS_Printf( f, "max_particles\t%i\n", GameInfo->max_particles );

	mov	eax, DWORD PTR _GameInfo$[ebp]
	mov	ecx, DWORD PTR [eax+1668]
	push	ecx
	push	OFFSET ??_C@_0BC@NFGDAGD@max_particles?7?$CFi?6@
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_FS_Printf
	add	esp, 12					; 0000000cH
$LN33@FS_WriteGa:

; 868  : 
; 869  : 	for( i = 0; i < NUM_AMBIENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@FS_WriteGa
$LN4@FS_WriteGa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@FS_WriteGa:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN5@FS_WriteGa

; 870  : 	{
; 871  : 		if( *GameInfo->ambientsound[i] )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1400]
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR [edx+ecx]
	test	edx, edx
	je	SHORT $LN34@FS_WriteGa

; 872  : 		{
; 873  : 			if( !write_ambients )

	cmp	DWORD PTR _write_ambients$[ebp], 0
	jne	SHORT $LN35@FS_WriteGa

; 874  : 			{
; 875  : 				FS_Print( f, "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 876  : 				write_ambients = true;

	mov	DWORD PTR _write_ambients$[ebp], 1
$LN35@FS_WriteGa:

; 877  : 			}
; 878  : 			FS_Printf( f, "ambient%i\t\t%s\n", i, GameInfo->ambientsound[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _GameInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1400]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@MOGLAPLP@ambient?$CFi?7?7?$CFs?6@
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN34@FS_WriteGa:

; 879  : 		}
; 880  : 	}

	jmp	SHORT $LN4@FS_WriteGa
$LN5@FS_WriteGa:

; 881  : 
; 882  : 	FS_Print( f, "\n\n\n" );

	push	OFFSET ??_C@_03EGHOKNNL@?6?6?6@
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Print
	add	esp, 8

; 883  : 	FS_Close( f );	// all done

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 884  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_WriteGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Rescan_f
_TEXT	SEGMENT
_FS_Rescan_f PROC					; COMDAT

; 777  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 778  : 	FS_Rescan();

	call	_FS_Rescan

; 779  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Rescan_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_CheckNastyPath
_TEXT	SEGMENT
_path$ = 8						; size = 4
_isgamedir$ = 12					; size = 4
_FS_CheckNastyPath PROC					; COMDAT

; 717  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 718  : 	// all: never allow an empty path, as for gamedir it would access the parent directory and a non-gamedir path it is just useless
; 719  : 	if( !COM_CheckString( path )) return 2;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@FS_CheckNa
	mov	eax, 2
	jmp	$LN1@FS_CheckNa
$LN2@FS_CheckNa:

; 720  : 
; 721  : 	if( fs_ext_path ) return 0;	// allow any path

	cmp	DWORD PTR _fs_ext_path, 0
	je	SHORT $LN3@FS_CheckNa
	xor	eax, eax
	jmp	$LN1@FS_CheckNa
$LN3@FS_CheckNa:

; 722  : 
; 723  : 	// Mac: don't allow Mac-only filenames - : is a directory separator
; 724  : 	// instead of /, but we rely on / working already, so there's no reason to
; 725  : 	// support a Mac-only path
; 726  : 	// Amiga and Windows: : tries to go to root of drive
; 727  : 	if( Q_strstr( path, ":" )) return 1; // non-portable attempt to go to root of drive

	push	OFFSET ??_C@_01JLIPDDHJ@?3@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@FS_CheckNa
	mov	eax, 1
	jmp	$LN1@FS_CheckNa
$LN4@FS_CheckNa:

; 728  : 
; 729  : 	// Amiga: // is parent directory
; 730  : 	if( Q_strstr( path, "//" )) return 1; // non-portable attempt to go to parent directory

	push	OFFSET ??_C@_02CBLDBPFN@?1?1@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@FS_CheckNa
	mov	eax, 1
	jmp	SHORT $LN1@FS_CheckNa
$LN5@FS_CheckNa:

; 731  : 
; 732  : 	// all: don't allow going to parent directory (../ or /../)
; 733  : 	if( Q_strstr( path, ".." )) return 2; // attempt to go outside the game directory

	push	OFFSET ??_C@_02DJGKEECL@?4?4@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@FS_CheckNa
	mov	eax, 2
	jmp	SHORT $LN1@FS_CheckNa
$LN6@FS_CheckNa:

; 734  : 
; 735  : 	// Windows and UNIXes: don't allow absolute paths
; 736  : 	if( path[0] == '/' ) return 2; // attempt to go outside the game directory

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _path$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN7@FS_CheckNa
	mov	eax, 2
	jmp	SHORT $LN1@FS_CheckNa
$LN7@FS_CheckNa:

; 737  : 
; 738  : 	// all: forbid trailing slash on gamedir
; 739  : 	if( isgamedir && path[Q_strlen( path )-1] == '/' ) return 2;

	cmp	DWORD PTR _isgamedir$[ebp], 0
	je	SHORT $LN8@FS_CheckNa
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _path$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 47					; 0000002fH
	jne	SHORT $LN8@FS_CheckNa
	mov	eax, 2
	jmp	SHORT $LN1@FS_CheckNa
$LN8@FS_CheckNa:

; 740  : 
; 741  : 	// all: forbid leading dot on any filename for any reason
; 742  : 	if( Q_strstr( path, "/." )) return 2; // attempt to go outside the game directory

	push	OFFSET ??_C@_02DIKICOBM@?1?4@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_Q_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@FS_CheckNa
	mov	eax, 2
	jmp	SHORT $LN1@FS_CheckNa
$LN9@FS_CheckNa:

; 743  : 
; 744  : 	// after all these checks we're pretty sure it's a / separated filename
; 745  : 	// and won't do much if any harm
; 746  : 	return 0;

	xor	eax, eax
$LN1@FS_CheckNa:

; 747  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CheckNastyPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AddPak_Fullpath
_TEXT	SEGMENT
_fullpath$1 = -280					; size = 256
_errorcode$ = -24					; size = 4
_i$ = -20						; size = 4
_ext$ = -16						; size = 4
_pak$ = -12						; size = 4
_search$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pakfile$ = 8						; size = 4
_already_loaded$ = 12					; size = 4
_flags$ = 16						; size = 4
_FS_AddPak_Fullpath PROC				; COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 548  : 	searchpath_t	*search;
; 549  : 	pack_t		*pak = NULL;

	mov	DWORD PTR _pak$[ebp], 0

; 550  : 	const char	*ext = COM_FileExtension( pakfile );

	mov	eax, DWORD PTR _pakfile$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 551  : 	int		i, errorcode = PAK_LOAD_COULDNT_OPEN;

	mov	DWORD PTR _errorcode$[ebp], 1

; 552  : 	
; 553  : 	for( search = fs_searchpaths; search; search = search->next )

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _search$[ebp], eax
	jmp	SHORT $LN4@FS_AddPak_
$LN2@FS_AddPak_:
	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _search$[ebp], ecx
$LN4@FS_AddPak_:
	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN3@FS_AddPak_

; 554  : 	{
; 555  : 		if( search->pack && !Q_stricmp( search->pack->filename, pakfile ))

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN8@FS_AddPak_
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pakfile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@FS_AddPak_

; 556  : 		{
; 557  : 			if( already_loaded ) *already_loaded = true;

	cmp	DWORD PTR _already_loaded$[ebp], 0
	je	SHORT $LN9@FS_AddPak_
	mov	eax, DWORD PTR _already_loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN9@FS_AddPak_:

; 558  : 			return true; // already loaded

	mov	eax, 1
	jmp	$LN1@FS_AddPak_
$LN8@FS_AddPak_:

; 559  : 		}
; 560  : 	}

	jmp	SHORT $LN2@FS_AddPak_
$LN3@FS_AddPak_:

; 561  : 
; 562  : 	if( already_loaded )

	cmp	DWORD PTR _already_loaded$[ebp], 0
	je	SHORT $LN10@FS_AddPak_

; 563  : 		*already_loaded = false;

	mov	eax, DWORD PTR _already_loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN10@FS_AddPak_:

; 564  : 
; 565  : 	if( !Q_stricmp( ext, "pak" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03HKJIJDAE@pak@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@FS_AddPak_

; 566  : 		pak = FS_LoadPackPAK( pakfile, &errorcode );

	lea	eax, DWORD PTR _errorcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pakfile$[ebp]
	push	ecx
	call	_FS_LoadPackPAK
	add	esp, 8
	mov	DWORD PTR _pak$[ebp], eax
$LN11@FS_AddPak_:

; 567  : 
; 568  : 	if( pak )

	cmp	DWORD PTR _pak$[ebp], 0
	je	$LN12@FS_AddPak_

; 569  : 	{
; 570  : 		string	fullpath;
; 571  : 
; 572  : 		search = (searchpath_t *)Mem_Calloc( fs_mempool, sizeof( searchpath_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_AddPak_Fullpath@@9@9
	add	eax, 25					; 00000019H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	272					; 00000110H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _search$[ebp], eax

; 573  : 		search->pack = pak;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _pak$[ebp]
	mov	DWORD PTR [eax+256], ecx

; 574  : 		search->next = fs_searchpaths;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _fs_searchpaths
	mov	DWORD PTR [eax+268], ecx

; 575  : 		search->flags |= flags;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	or	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _search$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 576  : 		fs_searchpaths = search;

	mov	eax, DWORD PTR _search$[ebp]
	mov	DWORD PTR _fs_searchpaths, eax

; 577  : 
; 578  : 		Con_Reportf( "Adding pakfile: %s (%i files)\n", pakfile, pak->numfiles );

	mov	eax, DWORD PTR _pak$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	mov	edx, DWORD PTR _pakfile$[ebp]
	push	edx
	push	OFFSET ??_C@_0BP@BJJLDFAF@Adding?5pakfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 579  : 
; 580  : 		// time to add in search list all the wads that contains in current pakfile (if do)
; 581  : 		for( i = 0; i < pak->numfiles; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@FS_AddPak_
$LN5@FS_AddPak_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@FS_AddPak_:
	mov	eax, DWORD PTR _pak$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+260]
	jge	SHORT $LN6@FS_AddPak_

; 582  : 		{
; 583  : 			if( !Q_stricmp( COM_FileExtension( pak->files[i].name ), "wad" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03GANHLHHC@wad@
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pak$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	add	edx, eax
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@FS_AddPak_

; 584  : 			{
; 585  : 				Q_sprintf( fullpath, "%s/%s", pakfile, pak->files[i].name );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pak$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	add	edx, eax
	push	edx
	mov	eax, DWORD PTR _pakfile$[ebp]
	push	eax
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	ecx, DWORD PTR _fullpath$1[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 586  : 				FS_AddWad_Fullpath( fullpath, NULL, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fullpath$1[ebp]
	push	ecx
	call	_FS_AddWad_Fullpath
	add	esp, 12					; 0000000cH
$LN14@FS_AddPak_:

; 587  : 			}
; 588  : 		}

	jmp	$LN5@FS_AddPak_
$LN6@FS_AddPak_:

; 589  : 
; 590  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_AddPak_

; 591  : 	}

	jmp	SHORT $LN1@FS_AddPak_
$LN12@FS_AddPak_:

; 592  : 	else
; 593  : 	{
; 594  : 		if( errorcode != PAK_LOAD_NO_FILES )

	cmp	DWORD PTR _errorcode$[ebp], 5
	je	SHORT $LN15@FS_AddPak_

; 595  : 			Con_DPrintf( S_ERROR "FS_AddPak_Fullpath: unable to load pak \"%s\"\n", pakfile );

	mov	eax, DWORD PTR _pakfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@PGENDCEJ@?$FO1Error?3?$FO7?5FS_AddPak_Fullpath?3?5@
	call	_Con_DPrintf
	add	esp, 8
$LN15@FS_AddPak_:

; 596  : 		return false;

	xor	eax, eax
$LN1@FS_AddPak_:

; 597  : 	}
; 598  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddPak_Fullpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AddWad_Fullpath
_TEXT	SEGMENT
_errorcode$ = -16					; size = 4
_ext$ = -12						; size = 4
_wad$ = -8						; size = 4
_search$ = -4						; size = 4
_wadfile$ = 8						; size = 4
_already_loaded$ = 12					; size = 4
_flags$ = 16						; size = 4
_FS_AddWad_Fullpath PROC				; COMDAT

; 492  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 493  : 	searchpath_t	*search;
; 494  : 	wfile_t		*wad = NULL;

	mov	DWORD PTR _wad$[ebp], 0

; 495  : 	const char	*ext = COM_FileExtension( wadfile );

	mov	eax, DWORD PTR _wadfile$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 496  : 	int		errorcode = WAD_LOAD_COULDNT_OPEN;

	mov	DWORD PTR _errorcode$[ebp], 1

; 497  : 
; 498  : 	for( search = fs_searchpaths; search; search = search->next )

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _search$[ebp], eax
	jmp	SHORT $LN4@FS_AddWad_
$LN2@FS_AddWad_:
	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _search$[ebp], ecx
$LN4@FS_AddWad_:
	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN3@FS_AddWad_

; 499  : 	{
; 500  : 		if( search->wad && !Q_stricmp( search->wad->filename, wadfile ))

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN5@FS_AddWad_
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _wadfile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@FS_AddWad_

; 501  : 		{
; 502  : 			if( already_loaded ) *already_loaded = true;

	cmp	DWORD PTR _already_loaded$[ebp], 0
	je	SHORT $LN6@FS_AddWad_
	mov	eax, DWORD PTR _already_loaded$[ebp]
	mov	DWORD PTR [eax], 1
$LN6@FS_AddWad_:

; 503  : 			return true; // already loaded

	mov	eax, 1
	jmp	$LN1@FS_AddWad_
$LN5@FS_AddWad_:

; 504  : 		}
; 505  : 	}

	jmp	SHORT $LN2@FS_AddWad_
$LN3@FS_AddWad_:

; 506  :           
; 507  : 	if( already_loaded )

	cmp	DWORD PTR _already_loaded$[ebp], 0
	je	SHORT $LN7@FS_AddWad_

; 508  : 		*already_loaded = false;

	mov	eax, DWORD PTR _already_loaded$[ebp]
	mov	DWORD PTR [eax], 0
$LN7@FS_AddWad_:

; 509  : 
; 510  : 	if( !Q_stricmp( ext, "wad" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03GANHLHHC@wad@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@FS_AddWad_

; 511  : 		wad = W_Open( wadfile, &errorcode );

	lea	eax, DWORD PTR _errorcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wadfile$[ebp]
	push	ecx
	call	_W_Open
	add	esp, 8
	mov	DWORD PTR _wad$[ebp], eax
$LN8@FS_AddWad_:

; 512  : 
; 513  : 	if( wad )

	cmp	DWORD PTR _wad$[ebp], 0
	je	$LN9@FS_AddWad_

; 514  : 	{
; 515  : 		search = (searchpath_t *)Mem_Calloc( fs_mempool, sizeof( searchpath_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_AddWad_Fullpath@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	272					; 00000110H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _search$[ebp], eax

; 516  : 		search->wad = wad;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [eax+260], ecx

; 517  : 		search->next = fs_searchpaths;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _fs_searchpaths
	mov	DWORD PTR [eax+268], ecx

; 518  : 		search->flags |= flags;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	or	ecx, DWORD PTR _flags$[ebp]
	mov	edx, DWORD PTR _search$[ebp]
	mov	DWORD PTR [edx+264], ecx

; 519  : 		fs_searchpaths = search;

	mov	eax, DWORD PTR _search$[ebp]
	mov	DWORD PTR _fs_searchpaths, eax

; 520  : 
; 521  : 		Con_Reportf( "Adding wadfile: %s (%i files)\n", wadfile, wad->numlumps );

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	push	ecx
	mov	edx, DWORD PTR _wadfile$[ebp]
	push	edx
	push	OFFSET ??_C@_0BP@PEBJBKDC@Adding?5wadfile?3?5?$CFs?5?$CI?$CFi?5files?$CJ?6@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 522  : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_AddWad_

; 523  : 	}

	jmp	SHORT $LN1@FS_AddWad_
$LN9@FS_AddWad_:

; 524  : 	else
; 525  : 	{
; 526  : 		if( errorcode != WAD_LOAD_NO_FILES )

	cmp	DWORD PTR _errorcode$[ebp], 5
	je	SHORT $LN11@FS_AddWad_

; 527  : 			Con_DPrintf( S_ERROR "FS_AddWad_Fullpath: unable to load wad \"%s\"\n", wadfile );

	mov	eax, DWORD PTR _wadfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@BHOLMLCD@?$FO1Error?3?$FO7?5FS_AddWad_Fullpath?3?5@
	call	_Con_DPrintf
	add	esp, 8
$LN11@FS_AddWad_:

; 528  : 		return false;

	xor	eax, eax
$LN1@FS_AddWad_:

; 529  : 	}
; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddWad_Fullpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_LoadPackPAK
_TEXT	SEGMENT
_info$ = -36						; size = 4
_pack$ = -32						; size = 4
_numpackfiles$ = -28					; size = 4
_i$ = -24						; size = 4
_packhandle$ = -20					; size = 4
_header$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_packfile$ = 8						; size = 4
_error$ = 12						; size = 4
_FS_LoadPackPAK PROC					; COMDAT

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 406  : 	dpackheader_t	header;
; 407  : 	int		packhandle;
; 408  : 	int		i, numpackfiles;
; 409  : 	pack_t		*pack;
; 410  : 	dpackfile_t	*info;
; 411  : 
; 412  : 	packhandle = open( packfile, O_RDONLY|O_BINARY );

	push	32768					; 00008000H
	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	call	DWORD PTR __imp__open
	add	esp, 8
	mov	DWORD PTR _packhandle$[ebp], eax

; 413  : 
; 414  : 	if( packhandle < 0 )

	cmp	DWORD PTR _packhandle$[ebp], 0
	jge	SHORT $LN5@FS_LoadPac

; 415  : 	{
; 416  : 		Con_Reportf( "%s couldn't open\n", packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@JIPKDBIA@?$CFs?5couldn?8t?5open?6@
	call	_Con_Reportf
	add	esp, 8

; 417  : 		if( error ) *error = PAK_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN6@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 1
$LN6@FS_LoadPac:

; 418  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN5@FS_LoadPac:

; 419  : 	}
; 420  : 
; 421  : 	read( packhandle, (void *)&header, sizeof( header ));

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packhandle$[ebp]
	push	ecx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH

; 422  : 
; 423  : 	if( header.ident != IDPACKV1HEADER )

	cmp	DWORD PTR _header$[ebp], 1262698832	; 4b434150H
	je	SHORT $LN7@FS_LoadPac

; 424  : 	{
; 425  : 		Con_Reportf( "%s is not a packfile. Ignored.\n", packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@LADEPGED@?$CFs?5is?5not?5a?5packfile?4?5Ignored?4?6@
	call	_Con_Reportf
	add	esp, 8

; 426  : 		if( error ) *error = PAK_LOAD_BAD_HEADER;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN8@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 2
$LN8@FS_LoadPac:

; 427  : 		close( packhandle );

	mov	eax, DWORD PTR _packhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 428  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN7@FS_LoadPac:

; 429  : 	}
; 430  : 
; 431  : 	if( header.dirlen % sizeof( dpackfile_t ))

	mov	eax, DWORD PTR _header$[ebp+8]
	xor	edx, edx
	mov	ecx, 64					; 00000040H
	div	ecx
	test	edx, edx
	je	SHORT $LN9@FS_LoadPac

; 432  : 	{
; 433  : 		Con_Reportf( "%s has an invalid directory size. Ignored.\n", packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@FFLJPGIM@?$CFs?5has?5an?5invalid?5directory?5siz@
	call	_Con_Reportf
	add	esp, 8

; 434  : 		if( error ) *error = PAK_LOAD_BAD_FOLDERS;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN10@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 3
$LN10@FS_LoadPac:

; 435  : 		close( packhandle );

	mov	eax, DWORD PTR _packhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 436  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN9@FS_LoadPac:

; 437  : 	}
; 438  : 
; 439  : 	numpackfiles = header.dirlen / sizeof( dpackfile_t );

	mov	eax, DWORD PTR _header$[ebp+8]
	shr	eax, 6
	mov	DWORD PTR _numpackfiles$[ebp], eax

; 440  : 
; 441  : 	if( numpackfiles > MAX_FILES_IN_PACK )

	cmp	DWORD PTR _numpackfiles$[ebp], 65536	; 00010000H
	jle	SHORT $LN11@FS_LoadPac

; 442  : 	{
; 443  : 		Con_DPrintf( S_ERROR "%s has too many files ( %i ). Ignored.\n", packfile, numpackfiles );

	mov	eax, DWORD PTR _numpackfiles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packfile$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DD@OEIIDGKH@?$FO1Error?3?$FO7?5?$CFs?5has?5too?5many?5file@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 444  : 		if( error ) *error = PAK_LOAD_TOO_MANY_FILES;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN12@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 4
$LN12@FS_LoadPac:

; 445  : 		close( packhandle );

	mov	eax, DWORD PTR _packhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 446  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN11@FS_LoadPac:

; 447  : 	}
; 448  : 
; 449  : 	if( numpackfiles <= 0 )

	cmp	DWORD PTR _numpackfiles$[ebp], 0
	jg	SHORT $LN13@FS_LoadPac

; 450  : 	{
; 451  : 		Con_Reportf( "%s has no files. Ignored.\n", packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@KDGPBPGC@?$CFs?5has?5no?5files?4?5Ignored?4?6@
	call	_Con_Reportf
	add	esp, 8

; 452  : 		if( error ) *error = PAK_LOAD_NO_FILES;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN14@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 5
$LN14@FS_LoadPac:

; 453  : 		close( packhandle );

	mov	eax, DWORD PTR _packhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 454  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN13@FS_LoadPac:

; 455  : 	}
; 456  : 
; 457  : 	info = (dpackfile_t *)Mem_Malloc( fs_mempool, sizeof( *info ) * numpackfiles );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
	add	eax, 52					; 00000034H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _numpackfiles$[ebp]
	shl	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _info$[ebp], eax

; 458  : 	lseek( packhandle, header.dirofs, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _header$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _packhandle$[ebp]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH

; 459  : 
; 460  : 	if( header.dirlen != read( packhandle, (void *)info, header.dirlen ))

	mov	eax, DWORD PTR _header$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packhandle$[ebp]
	push	edx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _header$[ebp+8], eax
	je	SHORT $LN15@FS_LoadPac

; 461  : 	{
; 462  : 		Con_Reportf( "%s is an incomplete PAK, not loading\n", packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	push	OFFSET ??_C@_0CG@MPMJLKCJ@?$CFs?5is?5an?5incomplete?5PAK?0?5not?5lo@
	call	_Con_Reportf
	add	esp, 8

; 463  : 		if( error ) *error = PAK_LOAD_CORRUPTED;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN16@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 6
$LN16@FS_LoadPac:

; 464  : 		close( packhandle );

	mov	eax, DWORD PTR _packhandle$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 465  : 		Mem_Free( info );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 466  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_LoadPac
$LN15@FS_LoadPac:

; 467  : 	}
; 468  : 
; 469  : 	pack = (pack_t *)Mem_Calloc( fs_mempool, sizeof( pack_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
	add	eax, 64					; 00000040H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	280					; 00000118H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pack$[ebp], eax

; 470  : 	Q_strncpy( pack->filename, packfile, sizeof( pack->filename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pack$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 471  : 	pack->files = (dpackfile_t *)Mem_Calloc( fs_mempool, numpackfiles * sizeof( dpackfile_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
	add	eax, 66					; 00000042H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _numpackfiles$[ebp]
	shl	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 472  : 	pack->filetime = FS_SysFileTime( packfile );

	mov	eax, DWORD PTR _packfile$[ebp]
	push	eax
	call	_FS_SysFileTime
	add	esp, 4
	cdq
	mov	ecx, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [ecx+264], eax
	mov	DWORD PTR [ecx+268], edx

; 473  : 	pack->handle = packhandle;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR _packhandle$[ebp]
	mov	DWORD PTR [eax+256], ecx

; 474  : 	pack->numfiles = 0;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [eax+260], 0

; 475  : 
; 476  : 	// parse the directory
; 477  : 	for( i = 0; i < numpackfiles; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_LoadPac
$LN2@FS_LoadPac:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_LoadPac:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numpackfiles$[ebp]
	jge	SHORT $LN3@FS_LoadPac

; 478  : 		FS_AddFileToPack( info[i].name, pack, info[i].filepos, info[i].filelen );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+eax+60]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+eax+56]
	push	edx
	mov	eax, DWORD PTR _pack$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_FS_AddFileToPack
	add	esp, 16					; 00000010H
	jmp	SHORT $LN2@FS_LoadPac
$LN3@FS_LoadPac:

; 479  : 
; 480  : 	if( error ) *error = PAK_LOAD_OK;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN17@FS_LoadPac
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 0
$LN17@FS_LoadPac:

; 481  : 	Mem_Free( info );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadPackPAK@@9@9
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 482  : 
; 483  : 	return pack;

	mov	eax, DWORD PTR _pack$[ebp]
$LN1@FS_LoadPac:

; 484  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadPackPAK ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ClearPaths_f
_TEXT	SEGMENT
_FS_ClearPaths_f PROC					; COMDAT

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 391  : 	FS_ClearSearchPath();

	call	_FS_ClearSearchPath

; 392  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ClearPaths_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Path_f
_TEXT	SEGMENT
_s$ = -4						; size = 4
_FS_Path_f PROC						; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 366  : 	searchpath_t	*s;
; 367  : 
; 368  : 	Con_Printf( "Current search path:\n" );

	push	OFFSET ??_C@_0BG@HPKHMA@Current?5search?5path?3?6@
	call	_Con_Printf
	add	esp, 4

; 369  : 
; 370  : 	for( s = fs_searchpaths; s; s = s->next )

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _s$[ebp], eax
	jmp	SHORT $LN4@FS_Path_f
$LN2@FS_Path_f:
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _s$[ebp], ecx
$LN4@FS_Path_f:
	cmp	DWORD PTR _s$[ebp], 0
	je	$LN1@FS_Path_f

; 371  : 	{
; 372  : 		if( s->pack ) Con_Printf( "%s (%i files)", s->pack->filename, s->pack->numfiles );

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN5@FS_Path_f
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	push	OFFSET ??_C@_0O@GBEHFLEC@?$CFs?5?$CI?$CFi?5files?$CJ@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@FS_Path_f
$LN5@FS_Path_f:

; 373  : 		else if( s->wad ) Con_Printf( "%s (%i files)", s->wad->filename, s->wad->numlumps );

	mov	eax, DWORD PTR _s$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN7@FS_Path_f
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	edx, DWORD PTR [ecx+264]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	push	OFFSET ??_C@_0O@GBEHFLEC@?$CFs?5?$CI?$CFi?5files?$CJ@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@FS_Path_f
$LN7@FS_Path_f:

; 374  : 		else Con_Printf( "%s", s->filename );

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_Con_Printf
	add	esp, 8
$LN6@FS_Path_f:

; 375  : 
; 376  : 		if( FBitSet( s->flags, FS_GAMEDIR_PATH ))

	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	and	ecx, 4
	je	SHORT $LN9@FS_Path_f

; 377  : 			Con_Printf( " ^2gamedir^7\n" );

	push	OFFSET ??_C@_0O@LJLKKPKG@?5?$FO2gamedir?$FO7?6@
	call	_Con_Printf
	add	esp, 4
	jmp	SHORT $LN10@FS_Path_f
$LN9@FS_Path_f:

; 378  : 		else Con_Printf( "\n" );

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	call	_Con_Printf
	add	esp, 4
$LN10@FS_Path_f:

; 379  : 	}

	jmp	$LN2@FS_Path_f
$LN1@FS_Path_f:

; 380  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Path_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_CreatePath
_TEXT	SEGMENT
_save$ = -5						; size = 1
_ofs$ = -4						; size = 4
_path$ = 8						; size = 4
_FS_CreatePath PROC					; COMDAT

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 342  : 	char	*ofs, save;
; 343  : 
; 344  : 	for( ofs = path + 1; *ofs; ofs++ )

	mov	eax, DWORD PTR _path$[ebp]
	add	eax, 1
	mov	DWORD PTR _ofs$[ebp], eax
	jmp	SHORT $LN4@FS_CreateP
$LN2@FS_CreateP:
	mov	eax, DWORD PTR _ofs$[ebp]
	add	eax, 1
	mov	DWORD PTR _ofs$[ebp], eax
$LN4@FS_CreateP:
	mov	eax, DWORD PTR _ofs$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@FS_CreateP

; 345  : 	{
; 346  : 		if( *ofs == '/' || *ofs == '\\' )

	mov	eax, DWORD PTR _ofs$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN6@FS_CreateP
	mov	eax, DWORD PTR _ofs$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN5@FS_CreateP
$LN6@FS_CreateP:

; 347  : 		{
; 348  : 			// create the directory
; 349  : 			save = *ofs;

	mov	eax, DWORD PTR _ofs$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _save$[ebp], cl

; 350  : 			*ofs = 0;

	mov	eax, DWORD PTR _ofs$[ebp]
	mov	BYTE PTR [eax], 0

; 351  : 			_mkdir( path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp___mkdir
	add	esp, 4

; 352  : 			*ofs = save;

	mov	eax, DWORD PTR _ofs$[ebp]
	mov	cl, BYTE PTR _save$[ebp]
	mov	BYTE PTR [eax], cl
$LN5@FS_CreateP:

; 353  : 		}
; 354  : 	}

	jmp	SHORT $LN2@FS_CreateP
$LN1@FS_CreateP:

; 355  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_CreatePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _listdirectory
_TEXT	SEGMENT
_hFile$ = -4400						; size = 4
_n_file$ = -4396					; size = 296
_pattern$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_list$ = 8						; size = 4
_path$ = 12						; size = 4
_lower$ = 16						; size = 4
_listdirectory PROC					; COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4912				; 00001330H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 260  : 	char		pattern[4096];
; 261  : 	struct _finddata_t	n_file;
; 262  : 	long		hFile;
; 263  : 
; 264  : 	Q_strncpy( pattern, path, sizeof( pattern ));

	push	4096					; 00001000H
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 265  : 	Q_strncat( pattern, "*", sizeof( pattern ));

	push	4096					; 00001000H
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	lea	eax, DWORD PTR _pattern$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 266  : 
; 267  : 	// ask for the directory listing handle
; 268  : 	hFile = _findfirst( pattern, &n_file );

	lea	eax, DWORD PTR _n_file$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	DWORD PTR __imp___findfirst64i32
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax

; 269  : 	if( hFile == -1 ) return;

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN4@listdirect
	jmp	SHORT $LN1@listdirect
$LN4@listdirect:

; 270  : 
; 271  : 	// start a new chain with the the first name
; 272  : 	stringlistappend( list, n_file.name );

	lea	eax, DWORD PTR _n_file$[ebp+36]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_stringlistappend
	add	esp, 8
$LN2@listdirect:

; 273  : 
; 274  : 	// iterate through the directory
; 275  : 	while( _findnext( hFile, &n_file ) == 0 )

	lea	eax, DWORD PTR _n_file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp___findnext64i32
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@listdirect

; 276  : 		stringlistappend( list, n_file.name );

	lea	eax, DWORD PTR _n_file$[ebp+36]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_stringlistappend
	add	esp, 8
	jmp	SHORT $LN2@listdirect
$LN3@listdirect:

; 277  : 	_findclose( hFile );

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp___findclose
	add	esp, 4

; 278  : 
; 279  : 	// g-cont. disabled for some reasons
; 280  : 	if( lower ) listlowercase( list );

	cmp	DWORD PTR _lower$[ebp], 0
	je	SHORT $LN1@listdirect
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_listlowercase
	add	esp, 4
$LN1@listdirect:

; 281  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_listdirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _listlowercase
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = -4						; size = 4
_list$ = 8						; size = 4
_listlowercase PROC					; COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 248  : 	char	*c;
; 249  : 	int	i;
; 250  : 
; 251  : 	for( i = 0; i < list->numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@listlowerc
$LN2@listlowerc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@listlowerc:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN1@listlowerc

; 252  : 	{
; 253  : 		for( c = list->strings[i]; *c; c++ )

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _c$[ebp], eax
	jmp	SHORT $LN7@listlowerc
$LN5@listlowerc:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax
$LN7@listlowerc:
	mov	eax, DWORD PTR _c$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@listlowerc

; 254  : 			*c = Q_tolower( *c );

	mov	eax, DWORD PTR _c$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	mov	edx, DWORD PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $LN5@listlowerc
$LN6@listlowerc:

; 255  : 	}

	jmp	SHORT $LN2@listlowerc
$LN1@listlowerc:

; 256  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_listlowercase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _stringlistsort
_TEXT	SEGMENT
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_temp$ = -4						; size = 4
_list$ = 8						; size = 4
_stringlistsort PROC					; COMDAT

; 226  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 227  : 	char	*temp;
; 228  : 	int	i, j;
; 229  : 
; 230  : 	// this is a selection sort (finds the best entry for each slot)
; 231  : 	for( i = 0; i < list->numstrings - 1; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stringlist
$LN2@stringlist:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stringlist:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN1@stringlist

; 232  : 	{
; 233  : 		for( j = i + 1; j < list->numstrings; j++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@stringlist
$LN5@stringlist:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@stringlist:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN6@stringlist

; 234  : 		{
; 235  : 			if( Q_strcmp( list->strings[i], list->strings[j] ) > 0 )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN8@stringlist

; 236  : 			{
; 237  : 				temp = list->strings[i];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _temp$[ebp], eax

; 238  : 				list->strings[i] = list->strings[j];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 239  : 				list->strings[j] = temp;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN8@stringlist:

; 240  : 			}
; 241  : 		}

	jmp	SHORT $LN5@stringlist
$LN6@stringlist:

; 242  : 	}

	jmp	$LN2@stringlist
$LN1@stringlist:

; 243  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stringlistsort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _stringlistappend
_TEXT	SEGMENT
_textlen$ = -4						; size = 4
_list$ = 8						; size = 4
_text$ = 12						; size = 4
_stringlistappend PROC					; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 208  : 	size_t	textlen;
; 209  : 
; 210  : 	if( !Q_stricmp( text, "." ) || !Q_stricmp( text, ".." ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01LFCBOECM@?4@
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@stringlist
	push	99999					; 0001869fH
	push	OFFSET ??_C@_02DJGKEECL@?4?4@
	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@stringlist
$LN3@stringlist:

; 211  : 		return; // ignore the virtual directories

	jmp	$LN1@stringlist
$LN2@stringlist:

; 212  : 
; 213  : 	if( list->numstrings >= list->maxstrings )

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@stringlist

; 214  : 	{
; 215  : 		list->maxstrings += 4096;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4096				; 00001000H
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx], ecx

; 216  : 		list->strings = Mem_Realloc( fs_mempool, list->strings, list->maxstrings * sizeof( *list->strings ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??stringlistappend@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Realloc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN4@stringlist:

; 217  : 	}
; 218  : 
; 219  : 	textlen = Q_strlen( text ) + 1;

	mov	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _textlen$[ebp], eax

; 220  : 	list->strings[list->numstrings] = Mem_Calloc( fs_mempool, textlen );

	mov	eax, DWORD PTR ?__LINE__Var@?0??stringlistappend@@9@9
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _textlen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+edx*4], eax

; 221  : 	memcpy( list->strings[list->numstrings], text, textlen );

	mov	eax, DWORD PTR _textlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 222  : 	list->numstrings++;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN1@stringlist:

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stringlistappend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _stringlistfreecontents
_TEXT	SEGMENT
_i$ = -4						; size = 4
_list$ = 8						; size = 4
_stringlistfreecontents PROC				; COMDAT

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 189  : 	int	i;
; 190  : 
; 191  : 	for( i = 0; i < list->numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@stringlist
$LN2@stringlist:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@stringlist:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN3@stringlist

; 192  : 	{
; 193  : 		if( list->strings[i] )

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN5@stringlist

; 194  : 			Mem_Free( list->strings[i] );

	mov	eax, DWORD PTR ?__LINE__Var@?0??stringlistfreecontents@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@stringlist:

; 195  : 		list->strings[i] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 196  : 	}

	jmp	SHORT $LN2@stringlist
$LN3@stringlist:

; 197  : 
; 198  : 	if( list->strings )

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN6@stringlist

; 199  : 		Mem_Free( list->strings );

	mov	eax, DWORD PTR ?__LINE__Var@?0??stringlistfreecontents@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN6@stringlist:

; 200  : 
; 201  : 	list->numstrings = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+4], 0

; 202  : 	list->maxstrings = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax], 0

; 203  : 	list->strings = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+8], 0

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stringlistfreecontents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _stringlistinit
_TEXT	SEGMENT
_list$ = 8						; size = 4
_stringlistinit PROC					; COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 184  : 	memset( list, 0, sizeof( *list ));

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 185  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stringlistinit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _matchpattern
_TEXT	SEGMENT
tv147 = -76						; size = 4
tv67 = -76						; size = 4
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_str$ = 8						; size = 4
_cmp$ = 12						; size = 4
_caseinsensitive$ = 16					; size = 4
_matchpattern PROC					; COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
$LN2@matchpatte:

; 135  : 	int	c1, c2;
; 136  : 
; 137  : 	while( *cmp )

	mov	eax, DWORD PTR _cmp$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@matchpatte

; 138  : 	{
; 139  : 		switch( *cmp )

	mov	eax, DWORD PTR _cmp$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv67[ebp], cl
	cmp	BYTE PTR tv67[ebp], 0
	je	SHORT $LN8@matchpatte
	cmp	BYTE PTR tv67[ebp], 42			; 0000002aH
	je	SHORT $LN12@matchpatte
	cmp	BYTE PTR tv67[ebp], 63			; 0000003fH
	je	SHORT $LN9@matchpatte
	jmp	$LN17@matchpatte
$LN8@matchpatte:

; 140  : 		{
; 141  : 		case 0:   return 1; // end of pattern

	mov	eax, 1
	jmp	$LN1@matchpatte
$LN9@matchpatte:

; 142  : 		case '?': // match any single character
; 143  : 			if( *str == 0 || *str == '/' || *str == '\\' || *str == ':' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@matchpatte
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN11@matchpatte
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN11@matchpatte
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN10@matchpatte
$LN11@matchpatte:

; 144  : 				return 0; // no match

	xor	eax, eax
	jmp	$LN1@matchpatte
$LN10@matchpatte:

; 145  : 			str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 146  : 			cmp++;

	mov	eax, DWORD PTR _cmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _cmp$[ebp], eax

; 147  : 			break;

	jmp	$LN4@matchpatte
$LN12@matchpatte:

; 148  : 		case '*': // match anything until following string
; 149  : 			if( !*str ) return 1; // match

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN13@matchpatte
	mov	eax, 1
	jmp	$LN1@matchpatte
$LN13@matchpatte:

; 150  : 			cmp++;

	mov	eax, DWORD PTR _cmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _cmp$[ebp], eax
$LN6@matchpatte:

; 151  : 			while( *str )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@matchpatte

; 152  : 			{
; 153  : 				if( *str == '/' || *str == '\\' || *str == ':' )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN15@matchpatte
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN15@matchpatte
	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN14@matchpatte
$LN15@matchpatte:

; 154  : 					break;

	jmp	SHORT $LN7@matchpatte
$LN14@matchpatte:

; 155  : 				// see if pattern matches at this offset
; 156  : 				if( matchpattern( str, cmp, caseinsensitive ))

	mov	eax, DWORD PTR _caseinsensitive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	_matchpattern
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN16@matchpatte

; 157  : 					return 1;

	mov	eax, 1
	jmp	$LN1@matchpatte
$LN16@matchpatte:

; 158  : 				// nope, advance to next offset
; 159  : 				str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 160  : 			}

	jmp	SHORT $LN6@matchpatte
$LN7@matchpatte:

; 161  : 			break;

	jmp	SHORT $LN4@matchpatte
$LN17@matchpatte:

; 162  : 		default:
; 163  : 			if( *str != *cmp )

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cmp$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	je	SHORT $LN18@matchpatte

; 164  : 			{
; 165  : 				if( !caseinsensitive )

	cmp	DWORD PTR _caseinsensitive$[ebp], 0
	jne	SHORT $LN19@matchpatte

; 166  : 					return 0; // no match

	xor	eax, eax
	jmp	SHORT $LN1@matchpatte
$LN19@matchpatte:

; 167  : 				c1 = Q_tolower( *str );

	mov	eax, DWORD PTR _str$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR _c1$[ebp], edx

; 168  : 				c2 = Q_tolower( *cmp );

	mov	eax, DWORD PTR _cmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	movsx	edx, al
	mov	DWORD PTR _c2$[ebp], edx

; 169  : 				if( c1 != c2 ) return 0; // no match

	mov	eax, DWORD PTR _c1$[ebp]
	cmp	eax, DWORD PTR _c2$[ebp]
	je	SHORT $LN18@matchpatte
	xor	eax, eax
	jmp	SHORT $LN1@matchpatte
$LN18@matchpatte:

; 170  : 			}
; 171  : 
; 172  : 			str++;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax

; 173  : 			cmp++;

	mov	eax, DWORD PTR _cmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _cmp$[ebp], eax
$LN4@matchpatte:

; 174  : 			break;
; 175  : 		}
; 176  : 	}

	jmp	$LN2@matchpatte
$LN3@matchpatte:

; 177  : 
; 178  : 	// reached end of pattern but not end of input?
; 179  : 	return (*str) ? 0 : 1;

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN22@matchpatte
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $LN23@matchpatte
$LN22@matchpatte:
	mov	DWORD PTR tv147[ebp], 1
$LN23@matchpatte:
	mov	eax, DWORD PTR tv147[ebp]
$LN1@matchpatte:

; 180  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_matchpattern ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Purge
_TEXT	SEGMENT
_file$ = 8						; size = 4
_FS_Purge PROC						; COMDAT

; 2196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2197 : 	file->buff_len = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+36], 0

; 2198 : 	file->buff_ind = 0;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+32], 0

; 2199 : 	file->ungetc = EOF;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+16], -1

; 2200 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Purge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_ExtFromType
_TEXT	SEGMENT
_type$ = -4						; size = 4
_lumptype$ = 8						; size = 1
_W_ExtFromType PROC					; COMDAT

; 2830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2831 : 	const wadtype_t	*type;
; 2832 : 
; 2833 : 	// we not known aboyt filetype, so match only by filename
; 2834 : 	if( lumptype == TYP_NONE || lumptype == TYP_ANY )

	movsx	eax, BYTE PTR _lumptype$[ebp]
	test	eax, eax
	je	SHORT $LN6@W_ExtFromT
	movsx	eax, BYTE PTR _lumptype$[ebp]
	cmp	eax, -1
	jne	SHORT $LN5@W_ExtFromT
$LN6@W_ExtFromT:

; 2835 : 		return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN1@W_ExtFromT
$LN5@W_ExtFromT:

; 2836 : 
; 2837 : 	for( type = wad_types; type->ext; type++ )

	mov	DWORD PTR _type$[ebp], OFFSET _wad_types
	jmp	SHORT $LN4@W_ExtFromT
$LN2@W_ExtFromT:
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, 8
	mov	DWORD PTR _type$[ebp], eax
$LN4@W_ExtFromT:
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@W_ExtFromT

; 2838 : 	{
; 2839 : 		if( lumptype == type->type )

	movsx	eax, BYTE PTR _lumptype$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	eax, edx
	jne	SHORT $LN7@W_ExtFromT

; 2840 : 			return type->ext;

	mov	eax, DWORD PTR _type$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1@W_ExtFromT
$LN7@W_ExtFromT:

; 2841 : 	}

	jmp	SHORT $LN2@W_ExtFromT
$LN3@W_ExtFromT:

; 2842 : 	return "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
$LN1@W_ExtFromT:

; 2843 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_ExtFromType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_TypeFromExt
_TEXT	SEGMENT
_type$ = -8						; size = 4
_ext$ = -4						; size = 4
_lumpname$ = 8						; size = 4
_W_TypeFromExt PROC					; COMDAT

; 2806 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2807 : 	const char	*ext = COM_FileExtension( lumpname );

	mov	eax, DWORD PTR _lumpname$[ebp]
	push	eax
	call	_COM_FileExtension
	add	esp, 4
	mov	DWORD PTR _ext$[ebp], eax

; 2808 : 	const wadtype_t	*type;
; 2809 : 
; 2810 : 	// we not known about filetype, so match only by filename
; 2811 : 	if( !Q_strcmp( ext, "*" ) || !Q_strcmp( ext, "" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN6@W_TypeFrom
	push	99999					; 0001869fH
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _ext$[ebp]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@W_TypeFrom
$LN6@W_TypeFrom:

; 2812 : 		return TYP_ANY;

	or	al, -1
	jmp	SHORT $LN1@W_TypeFrom
$LN5@W_TypeFrom:

; 2813 : 	
; 2814 : 	for( type = wad_types; type->ext; type++ )

	mov	DWORD PTR _type$[ebp], OFFSET _wad_types
	jmp	SHORT $LN4@W_TypeFrom
$LN2@W_TypeFrom:
	mov	eax, DWORD PTR _type$[ebp]
	add	eax, 8
	mov	DWORD PTR _type$[ebp], eax
$LN4@W_TypeFrom:
	mov	eax, DWORD PTR _type$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@W_TypeFrom

; 2815 : 	{
; 2816 : 		if( !Q_stricmp( ext, type->ext ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _type$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ext$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@W_TypeFrom

; 2817 : 			return type->type;

	mov	eax, DWORD PTR _type$[ebp]
	mov	al, BYTE PTR [eax+4]
	jmp	SHORT $LN1@W_TypeFrom
$LN7@W_TypeFrom:

; 2818 : 	}

	jmp	SHORT $LN2@W_TypeFrom
$LN3@W_TypeFrom:

; 2819 : 	return TYP_NONE;

	xor	al, al
$LN1@W_TypeFrom:

; 2820 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_TypeFromExt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_SysFileTime
_TEXT	SEGMENT
_buf$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_FS_SysFileTime PROC					; COMDAT

; 1477 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1478 : 	struct stat buf;
; 1479 : 	
; 1480 : 	if( stat( filename, &buf ) == -1 )

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_stat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@FS_SysFile

; 1481 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_SysFile
$LN2@FS_SysFile:

; 1482 : 
; 1483 : 	return buf.st_mtime;

	mov	eax, DWORD PTR _buf$[ebp+32]
$LN1@FS_SysFile:

; 1484 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SysFileTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_SysFolderExists
_TEXT	SEGMENT
tv69 = -72						; size = 4
_dwFlags$ = -4						; size = 4
_path$ = 8						; size = 4
_FS_SysFolderExists PROC				; COMDAT

; 1617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 1618 : 	DWORD	dwFlags = GetFileAttributes( path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFileAttributesA@4
	mov	DWORD PTR _dwFlags$[ebp], eax

; 1619 : 
; 1620 : 	return ( dwFlags != -1 ) && FBitSet( dwFlags, FILE_ATTRIBUTE_DIRECTORY );

	cmp	DWORD PTR _dwFlags$[ebp], -1
	je	SHORT $LN3@FS_SysFold
	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN3@FS_SysFold
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@FS_SysFold
$LN3@FS_SysFold:
	mov	DWORD PTR tv69[ebp], 0
$LN4@FS_SysFold:
	mov	eax, DWORD PTR tv69[ebp]

; 1621 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SysFolderExists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_SysFileExists
_TEXT	SEGMENT
_desc$ = -4						; size = 4
_path$ = 8						; size = 4
_FS_SysFileExists PROC					; COMDAT

; 1599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1600 : 	int desc;
; 1601 : 
; 1602 : 	if(( desc = open( path, O_RDONLY|O_BINARY )) < 0 )

	push	32768					; 00008000H
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp__open
	add	esp, 8
	mov	DWORD PTR _desc$[ebp], eax
	cmp	DWORD PTR _desc$[ebp], 0
	jge	SHORT $LN2@FS_SysFile

; 1603 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@FS_SysFile
$LN2@FS_SysFile:

; 1604 : 
; 1605 : 	close( desc );

	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	call	DWORD PTR __imp__close
	add	esp, 4

; 1606 : 	return true;

	mov	eax, 1
$LN1@FS_SysFile:

; 1607 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_SysFileExists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_Open
_TEXT	SEGMENT
_k$1 = -56						; size = 4
_name$2 = -52						; size = 16
_header$ = -36						; size = 12
_lat_size$ = -24					; size = 4
_srclumps$ = -20					; size = 4
_lumpcount$ = -16					; size = 4
_i$ = -12						; size = 4
_wad$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_error$ = 12						; size = 4
_W_Open	PROC						; COMDAT

; 2993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2994 : 	wfile_t		*wad = (wfile_t *)Mem_Calloc( fs_mempool, sizeof( wfile_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	288					; 00000120H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _wad$[ebp], eax

; 2995 : 	int		i, lumpcount;
; 2996 : 	dlumpinfo_t	*srclumps;
; 2997 : 	size_t		lat_size;
; 2998 : 	dwadinfo_t	header;
; 2999 : 
; 3000 : 	// NOTE: FS_Open is load wad file from the first pak in the list (while fs_ext_path is false)
; 3001 : 	if( fs_ext_path ) wad->handle = FS_Open( filename, "rb", false );

	cmp	DWORD PTR _fs_ext_path, 0
	je	SHORT $LN5@W_Open
	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [ecx+268], eax
	jmp	SHORT $LN6@W_Open
$LN5@W_Open:

; 3002 : 	else wad->handle = FS_Open( COM_FileWithoutPath( filename ), "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_COM_FileWithoutPath
	add	esp, 4
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [ecx+268], eax
$LN6@W_Open:

; 3003 : 
; 3004 : 	if( wad->handle == NULL )

	mov	eax, DWORD PTR _wad$[ebp]
	cmp	DWORD PTR [eax+268], 0
	jne	SHORT $LN7@W_Open

; 3005 : 	{
; 3006 : 		Con_DPrintf( S_ERROR "W_Open: couldn't open %s\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@PKAMBGCM@?$FO1Error?3?$FO7?5W_Open?3?5couldn?8t?5ope@
	call	_Con_DPrintf
	add	esp, 8

; 3007 : 		if( error ) *error = WAD_LOAD_COULDNT_OPEN;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN8@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 1
$LN8@W_Open:

; 3008 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3009 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open
$LN7@W_Open:

; 3010 : 	}
; 3011 : 
; 3012 : 	// copy wad name
; 3013 : 	Q_strncpy( wad->filename, filename, sizeof( wad->filename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 3014 : 	wad->filetime = FS_SysFileTime( filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_SysFileTime
	add	esp, 4
	cdq
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [ecx+280], eax
	mov	DWORD PTR [ecx+284], edx

; 3015 : 	wad->mempool = Mem_AllocPool( filename );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [edx+260], eax

; 3016 : 
; 3017 : 	if( FS_Read( wad->handle, &header, sizeof( dwadinfo_t )) != sizeof( dwadinfo_t ))

	push	12					; 0000000cH
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 12					; 0000000cH
	je	SHORT $LN9@W_Open

; 3018 : 	{
; 3019 : 		Con_DPrintf( S_ERROR "W_Open: %s can't read header\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@EHANGNHD@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5rea@
	call	_Con_DPrintf
	add	esp, 8

; 3020 : 		if( error ) *error = WAD_LOAD_BAD_HEADER;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN10@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 2
$LN10@W_Open:

; 3021 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3022 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open
$LN9@W_Open:

; 3023 : 	}
; 3024 : 
; 3025 : 	if( header.ident != IDWAD2HEADER && header.ident != IDWAD3HEADER )

	cmp	DWORD PTR _header$[ebp], 843333975	; 32444157H
	je	SHORT $LN11@W_Open
	cmp	DWORD PTR _header$[ebp], 860111191	; 33444157H
	je	SHORT $LN11@W_Open

; 3026 : 	{
; 3027 : 		Con_DPrintf( S_ERROR "W_Open: %s is not a WAD2 or WAD3 file\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DC@CBDAMJEM@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5is?5not?5a?5@
	call	_Con_DPrintf
	add	esp, 8

; 3028 : 		if( error ) *error = WAD_LOAD_BAD_HEADER;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN12@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 2
$LN12@W_Open:

; 3029 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3030 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open
$LN11@W_Open:

; 3031 : 	}
; 3032 : 
; 3033 : 	lumpcount = header.numlumps;

	mov	eax, DWORD PTR _header$[ebp+4]
	mov	DWORD PTR _lumpcount$[ebp], eax

; 3034 : 
; 3035 : 	if( lumpcount >= MAX_FILES_IN_WAD )

	cmp	DWORD PTR _lumpcount$[ebp], 65535	; 0000ffffH
	jl	SHORT $LN13@W_Open

; 3036 : 	{
; 3037 : 		Con_DPrintf( S_WARN "W_Open: %s is full (%i lumps)\n", filename, lumpcount );

	mov	eax, DWORD PTR _lumpcount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CM@OECBKKFN@?$FO3Warning?3?$FO7?5W_Open?3?5?$CFs?5is?5full@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 3038 : 		if( error ) *error = WAD_LOAD_TOO_MANY_FILES;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN15@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 4
$LN15@W_Open:

; 3039 : 	}

	jmp	SHORT $LN14@W_Open
$LN13@W_Open:

; 3040 : 	else if( lumpcount <= 0 )

	cmp	DWORD PTR _lumpcount$[ebp], 0
	jg	SHORT $LN16@W_Open

; 3041 : 	{
; 3042 : 		Con_DPrintf( S_ERROR "W_Open: %s has no lumps\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@CCELBKNC@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5has?5no?5lu@
	call	_Con_DPrintf
	add	esp, 8

; 3043 : 		if( error ) *error = WAD_LOAD_NO_FILES;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN18@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 5
$LN18@W_Open:

; 3044 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3045 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open

; 3046 : 	}

	jmp	SHORT $LN14@W_Open
$LN16@W_Open:

; 3047 : 	else if( error ) *error = WAD_LOAD_OK;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN14@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 0
$LN14@W_Open:

; 3048 : 
; 3049 : 	wad->infotableofs = header.infotableofs; // save infotableofs position

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR _header$[ebp+8]
	mov	DWORD PTR [eax+256], ecx

; 3050 : 
; 3051 : 	if( FS_Seek( wad->handle, wad->infotableofs, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN20@W_Open

; 3052 : 	{
; 3053 : 		Con_DPrintf( S_ERROR "W_Open: %s can't find lump allocation table\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@FIBBLIHJ@?$FO1Error?3?$FO7?5W_Open?3?5?$CFs?5can?8t?5fin@
	call	_Con_DPrintf
	add	esp, 8

; 3054 : 		if( error ) *error = WAD_LOAD_BAD_FOLDERS;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN21@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 3
$LN21@W_Open:

; 3055 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3056 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open
$LN20@W_Open:

; 3057 : 	}
; 3058 : 
; 3059 : 	lat_size = lumpcount * sizeof( dlumpinfo_t );

	mov	eax, DWORD PTR _lumpcount$[ebp]
	shl	eax, 5
	mov	DWORD PTR _lat_size$[ebp], eax

; 3060 : 
; 3061 : 	// NOTE: lumps table can be reallocated for O_APPEND mode
; 3062 : 	srclumps = (dlumpinfo_t *)Mem_Malloc( wad->mempool, lat_size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _lat_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _srclumps$[ebp], eax

; 3063 : 
; 3064 : 	if( FS_Read( wad->handle, srclumps, lat_size ) != lat_size )

	mov	eax, DWORD PTR _lat_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srclumps$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+268]
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _lat_size$[ebp]
	je	SHORT $LN22@W_Open

; 3065 : 	{
; 3066 : 		Con_DPrintf( S_ERROR "W_ReadLumpTable: %s has corrupted lump allocation table\n", wad->filename );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	push	OFFSET ??_C@_0EE@HFFLALIL@?$FO1Error?3?$FO7?5W_ReadLumpTable?3?5?$CFs?5@
	call	_Con_DPrintf
	add	esp, 8

; 3067 : 		if( error ) *error = WAD_LOAD_CORRUPTED;

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN23@W_Open
	mov	eax, DWORD PTR _error$[ebp]
	mov	DWORD PTR [eax], 6
$LN23@W_Open:

; 3068 : 		Mem_Free( srclumps );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 75					; 0000004bH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _srclumps$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 3069 : 		W_Close( wad );

	mov	eax, DWORD PTR _wad$[ebp]
	push	eax
	call	_W_Close
	add	esp, 4

; 3070 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_Open
$LN22@W_Open:

; 3071 : 	}
; 3072 : 
; 3073 : 	// starting to add lumps
; 3074 : 	wad->lumps = (dlumpinfo_t *)Mem_Calloc( wad->mempool, lat_size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 81					; 00000051H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _lat_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 3075 : 	wad->numlumps = 0;

	mov	eax, DWORD PTR _wad$[ebp]
	mov	DWORD PTR [eax+264], 0

; 3076 : 
; 3077 : 	// sort lumps for binary search
; 3078 : 	for( i = 0; i < lumpcount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@W_Open
$LN2@W_Open:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@W_Open:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _lumpcount$[ebp]
	jge	$LN3@W_Open

; 3079 : 	{
; 3080 : 		char	name[16];
; 3081 : 		int	k;
; 3082 : 
; 3083 : 		// cleanup lumpname
; 3084 : 		Q_strnlwr( srclumps[i].name, name, sizeof( srclumps[i].name ));

	push	16					; 00000010H
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _srclumps$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	push	eax
	call	_Q_strnlwr
	add	esp, 12					; 0000000cH

; 3085 : 
; 3086 : 		// check for '*' symbol issues (quake1)
; 3087 : 		k = Q_strlen( Q_strrchr( name, '*' ));

	push	42					; 0000002aH
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	DWORD PTR _k$1[ebp], eax

; 3088 : 		if( k ) name[Q_strlen( name ) - k] = '!';

	cmp	DWORD PTR _k$1[ebp], 0
	je	SHORT $LN24@W_Open
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	sub	eax, DWORD PTR _k$1[ebp]
	mov	BYTE PTR _name$2[ebp+eax], 33		; 00000021H
$LN24@W_Open:

; 3089 : 
; 3090 : 		// check for Quake 'conchars' issues (only lmp loader really allows to read this lame pic)
; 3091 : 		if( srclumps[i].type == 68 && !Q_stricmp( srclumps[i].name, "conchars" ))

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _srclumps$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+12]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN25@W_Open
	push	99999					; 0001869fH
	push	OFFSET ??_C@_08FJIFJEIK@conchars@
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _srclumps$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@W_Open

; 3092 : 			srclumps[i].type = TYP_GFXPIC; 

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _srclumps$[ebp]
	mov	BYTE PTR [ecx+eax+12], 66		; 00000042H
$LN25@W_Open:

; 3093 : 
; 3094 : 		W_AddFileToWad( name, wad, &srclumps[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _srclumps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wad$[ebp]
	push	ecx
	lea	edx, DWORD PTR _name$2[ebp]
	push	edx
	call	_W_AddFileToWad
	add	esp, 12					; 0000000cH

; 3095 : 	}

	jmp	$LN2@W_Open
$LN3@W_Open:

; 3096 : 
; 3097 : 	// release source lumps
; 3098 : 	Mem_Free( srclumps );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Open@@9@9
	add	eax, 105				; 00000069H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _srclumps$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 3099 : 
; 3100 : 	// and leave the file open
; 3101 : 	return wad;

	mov	eax, DWORD PTR _wad$[ebp]
$LN1@W_Open:

; 3102 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_W_Open	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_LoadFile
_TEXT	SEGMENT
_index$ = -8						; size = 4
_search$ = -4						; size = 4
_path$ = 8						; size = 4
_lumpsizeptr$ = 12					; size = 4
_gamedironly$ = 16					; size = 4
_W_LoadFile PROC					; COMDAT

; 3136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 3137 : 	searchpath_t	*search;
; 3138 : 	int		index;
; 3139 : 
; 3140 : 	search = FS_FindFile( path, &index, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 3141 : 	if( search && search->wad )

	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN2@W_LoadFile
	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN2@W_LoadFile

; 3142 : 		return W_ReadLump( search->wad, &search->wad->lumps[index], lumpsizeptr ); 

	mov	eax, DWORD PTR _lumpsizeptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [edx+272]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_W_ReadLump
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@W_LoadFile
$LN2@W_LoadFile:

; 3143 : 	return NULL;

	xor	eax, eax
$LN1@W_LoadFile:

; 3144 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_LoadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AddFileToPack
_TEXT	SEGMENT
_diff$1 = -20						; size = 4
_pfile$ = -16						; size = 4
_middle$ = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_name$ = 8						; size = 4
_pack$ = 12						; size = 4
_offset$ = 16						; size = 4
_size$ = 20						; size = 4
_FS_AddFileToPack PROC					; COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 299  : 	int		left, right, middle;
; 300  : 	dpackfile_t	*pfile;
; 301  : 
; 302  : 	// look for the slot we should put that file into (binary search)
; 303  : 	left = 0;

	mov	DWORD PTR _left$[ebp], 0

; 304  : 	right = pack->numfiles - 1;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	sub	ecx, 1
	mov	DWORD PTR _right$[ebp], ecx
$LN2@FS_AddFile:

; 305  : 
; 306  : 	while( left <= right )

	mov	eax, DWORD PTR _left$[ebp]
	cmp	eax, DWORD PTR _right$[ebp]
	jg	SHORT $LN3@FS_AddFile

; 307  : 	{
; 308  : 		int diff;
; 309  : 
; 310  : 		middle = (left + right) / 2;

	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$[ebp], eax

; 311  : 		diff = Q_stricmp( pack->files[middle].name, name );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _middle$[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pack$[ebp]
	mov	eax, DWORD PTR [edx+272]
	add	eax, ecx
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _diff$1[ebp], eax

; 312  : 
; 313  : 		// If we found the file, there's a problem (but don't confuse the users)
; 314  : 		if( !diff ) Con_Reportf( S_WARN "package %s contains the file %s several times\n", pack->filename, name );

	cmp	DWORD PTR _diff$1[ebp], 0
	jne	SHORT $LN4@FS_AddFile
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pack$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@MIMLIMFB@?$FO3Warning?3?$FO7?5package?5?$CFs?5contain@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH
$LN4@FS_AddFile:

; 315  : 
; 316  : 		// If we're too far in the list
; 317  : 		if( diff > 0 ) right = middle - 1;

	cmp	DWORD PTR _diff$1[ebp], 0
	jle	SHORT $LN5@FS_AddFile
	mov	eax, DWORD PTR _middle$[ebp]
	sub	eax, 1
	mov	DWORD PTR _right$[ebp], eax
	jmp	SHORT $LN6@FS_AddFile
$LN5@FS_AddFile:

; 318  : 		else left = middle + 1;

	mov	eax, DWORD PTR _middle$[ebp]
	add	eax, 1
	mov	DWORD PTR _left$[ebp], eax
$LN6@FS_AddFile:

; 319  : 	}

	jmp	SHORT $LN2@FS_AddFile
$LN3@FS_AddFile:

; 320  : 
; 321  : 	// We have to move the right of the list by one slot to free the one we need
; 322  : 	pfile = &pack->files[left];

	mov	eax, DWORD PTR _left$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pack$[ebp]
	add	eax, DWORD PTR [ecx+272]
	mov	DWORD PTR _pfile$[ebp], eax

; 323  : 	memmove( pfile + 1, pfile, (pack->numfiles - left) * sizeof( *pfile ));

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	sub	ecx, DWORD PTR _left$[ebp]
	shl	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _pfile$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfile$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 324  : 	pack->numfiles++;

	mov	eax, DWORD PTR _pack$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, 1
	mov	edx, DWORD PTR _pack$[ebp]
	mov	DWORD PTR [edx+260], ecx

; 325  : 
; 326  : 	Q_strncpy( pfile->name, name, sizeof( pfile->name ));

	push	56					; 00000038H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfile$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 327  : 	pfile->filepos = offset;

	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 328  : 	pfile->filelen = size;

	mov	eax, DWORD PTR _pfile$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 329  : 
; 330  : 	return pfile;

	mov	eax, DWORD PTR _pfile$[ebp]

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddFileToPack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_FindLump
_TEXT	SEGMENT
_diff$1 = -16						; size = 4
_middle$2 = -12						; size = 4
_right$ = -8						; size = 4
_left$ = -4						; size = 4
_wad$ = 8						; size = 4
_name$ = 12						; size = 4
_matchtype$ = 16					; size = 1
_W_FindLump PROC					; COMDAT

; 2853 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2854 : 	int	left, right;
; 2855 : 
; 2856 : 	if( !wad || !wad->lumps || matchtype == TYP_NONE )

	cmp	DWORD PTR _wad$[ebp], 0
	je	SHORT $LN5@W_FindLump
	mov	eax, DWORD PTR _wad$[ebp]
	cmp	DWORD PTR [eax+272], 0
	je	SHORT $LN5@W_FindLump
	movsx	eax, BYTE PTR _matchtype$[ebp]
	test	eax, eax
	jne	SHORT $LN4@W_FindLump
$LN5@W_FindLump:

; 2857 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@W_FindLump
$LN4@W_FindLump:

; 2858 : 
; 2859 : 	// look for the file (binary search)
; 2860 : 	left = 0;

	mov	DWORD PTR _left$[ebp], 0

; 2861 : 	right = wad->numlumps - 1;

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	sub	ecx, 1
	mov	DWORD PTR _right$[ebp], ecx
$LN2@W_FindLump:

; 2862 : 	
; 2863 : 	while( left <= right )

	mov	eax, DWORD PTR _left$[ebp]
	cmp	eax, DWORD PTR _right$[ebp]
	jg	$LN3@W_FindLump

; 2864 : 	{
; 2865 : 		int	middle = (left + right) / 2;

	mov	eax, DWORD PTR _left$[ebp]
	add	eax, DWORD PTR _right$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$2[ebp], eax

; 2866 : 		int	diff = Q_stricmp( wad->lumps[middle].name, name );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _middle$2[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _wad$[ebp]
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR [eax+ecx+16]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _diff$1[ebp], eax

; 2867 : 
; 2868 : 		if( !diff )

	cmp	DWORD PTR _diff$1[ebp], 0
	jne	$LN6@W_FindLump

; 2869 : 		{
; 2870 : 			if(( matchtype == TYP_ANY ) || ( matchtype == wad->lumps[middle].type ))

	movsx	eax, BYTE PTR _matchtype$[ebp]
	cmp	eax, -1
	je	SHORT $LN9@W_FindLump
	movsx	eax, BYTE PTR _matchtype$[ebp]
	mov	ecx, DWORD PTR _middle$2[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [edx+272]
	movsx	ecx, BYTE PTR [edx+ecx+12]
	cmp	eax, ecx
	jne	SHORT $LN7@W_FindLump
$LN9@W_FindLump:

; 2871 : 				return &wad->lumps[middle]; // found

	mov	eax, DWORD PTR _middle$2[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	add	eax, DWORD PTR [ecx+272]
	jmp	SHORT $LN1@W_FindLump
	jmp	SHORT $LN6@W_FindLump
$LN7@W_FindLump:

; 2872 : 			else if( wad->lumps[middle].type < matchtype )

	mov	eax, DWORD PTR _middle$2[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movsx	eax, BYTE PTR [edx+eax+12]
	movsx	ecx, BYTE PTR _matchtype$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN10@W_FindLump

; 2873 : 				diff = 1;

	mov	DWORD PTR _diff$1[ebp], 1
	jmp	SHORT $LN6@W_FindLump
$LN10@W_FindLump:

; 2874 : 			else if( wad->lumps[middle].type > matchtype )

	mov	eax, DWORD PTR _middle$2[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movsx	eax, BYTE PTR [edx+eax+12]
	movsx	ecx, BYTE PTR _matchtype$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN12@W_FindLump

; 2875 : 				diff = -1;

	mov	DWORD PTR _diff$1[ebp], -1
	jmp	SHORT $LN6@W_FindLump
$LN12@W_FindLump:

; 2876 : 			else break; // not found

	jmp	SHORT $LN3@W_FindLump
$LN6@W_FindLump:

; 2877 : 		}
; 2878 : 
; 2879 : 		// if we're too far in the list
; 2880 : 		if( diff > 0 ) right = middle - 1;

	cmp	DWORD PTR _diff$1[ebp], 0
	jle	SHORT $LN14@W_FindLump
	mov	eax, DWORD PTR _middle$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _right$[ebp], eax
	jmp	SHORT $LN15@W_FindLump
$LN14@W_FindLump:

; 2881 : 		else left = middle + 1;

	mov	eax, DWORD PTR _middle$2[ebp]
	add	eax, 1
	mov	DWORD PTR _left$[ebp], eax
$LN15@W_FindLump:

; 2882 : 	}

	jmp	$LN2@W_FindLump
$LN3@W_FindLump:

; 2883 : 
; 2884 : 	return NULL;

	xor	eax, eax
$LN1@W_FindLump:

; 2885 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_FindLump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FindFile
_TEXT	SEGMENT
tv69 = -3256						; size = 4
$T1 = -3252						; size = 4
_end$2 = -2864						; size = 4
_netpath$3 = -2860					; size = 1024
_netpath$4 = -1836					; size = 1024
_shortname$5 = -812					; size = 256
_wadfolder$6 = -556					; size = 256
_wadname$7 = -300					; size = 256
_anywadname$8 = -44					; size = 4
_type$9 = -37						; size = 1
_lump$10 = -36						; size = 4
_diff$11 = -32						; size = 4
_pak$12 = -28						; size = 4
_middle$13 = -24					; size = 4
_right$14 = -20						; size = 4
_left$15 = -16						; size = 4
_pEnvPath$ = -12					; size = 4
_search$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_index$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_FS_FindFile PROC					; COMDAT

; 1634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3256				; 00000cb8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1635 : 	searchpath_t	*search;
; 1636 : 	char		*pEnvPath;
; 1637 : 
; 1638 : 	// search through the path, one element at a time
; 1639 : 	for( search = fs_searchpaths; search; search = search->next )

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _search$[ebp], eax
	jmp	SHORT $LN4@FS_FindFil
$LN2@FS_FindFil:
	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _search$[ebp], ecx
$LN4@FS_FindFil:
	cmp	DWORD PTR _search$[ebp], 0
	je	$LN3@FS_FindFil

; 1640 : 	{
; 1641 : 		if( gamedironly & !FBitSet( search->flags, FS_GAMEDIR_PATH ))

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	and	ecx, 4
	jne	SHORT $LN33@FS_FindFil
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN34@FS_FindFil
$LN33@FS_FindFil:
	mov	DWORD PTR tv69[ebp], 0
$LN34@FS_FindFil:
	mov	edx, DWORD PTR _gamedironly$[ebp]
	and	edx, DWORD PTR tv69[ebp]
	je	SHORT $LN9@FS_FindFil

; 1642 : 			continue;

	jmp	SHORT $LN2@FS_FindFil
$LN9@FS_FindFil:

; 1643 : 
; 1644 : 		// is the element a pak file?
; 1645 : 		if( search->pack )

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	$LN10@FS_FindFil

; 1646 : 		{
; 1647 : 			int	left, right, middle;
; 1648 : 			pack_t	*pak;
; 1649 : 
; 1650 : 			pak = search->pack;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	DWORD PTR _pak$12[ebp], ecx

; 1651 : 
; 1652 : 			// look for the file (binary search)
; 1653 : 			left = 0;

	mov	DWORD PTR _left$15[ebp], 0

; 1654 : 			right = pak->numfiles - 1;

	mov	eax, DWORD PTR _pak$12[ebp]
	mov	ecx, DWORD PTR [eax+260]
	sub	ecx, 1
	mov	DWORD PTR _right$14[ebp], ecx
$LN5@FS_FindFil:

; 1655 : 			while( left <= right )

	mov	eax, DWORD PTR _left$15[ebp]
	cmp	eax, DWORD PTR _right$14[ebp]
	jg	SHORT $LN6@FS_FindFil

; 1656 : 			{
; 1657 : 				int	diff;
; 1658 : 
; 1659 : 				middle = (left + right) / 2;

	mov	eax, DWORD PTR _left$15[ebp]
	add	eax, DWORD PTR _right$14[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$13[ebp], eax

; 1660 : 				diff = Q_stricmp( pak->files[middle].name, name );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _middle$13[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _pak$12[ebp]
	mov	eax, DWORD PTR [edx+272]
	add	eax, ecx
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _diff$11[ebp], eax

; 1661 : 
; 1662 : 				// Found it
; 1663 : 				if( !diff )

	cmp	DWORD PTR _diff$11[ebp], 0
	jne	SHORT $LN12@FS_FindFil

; 1664 : 				{
; 1665 : 					if( index ) *index = middle;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN13@FS_FindFil
	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _middle$13[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@FS_FindFil:

; 1666 : 					return search;

	mov	eax, DWORD PTR _search$[ebp]
	jmp	$LN32@FS_FindFil
$LN12@FS_FindFil:

; 1667 : 				}
; 1668 : 
; 1669 : 				// if we're too far in the list
; 1670 : 				if( diff > 0 )

	cmp	DWORD PTR _diff$11[ebp], 0
	jle	SHORT $LN14@FS_FindFil

; 1671 : 					right = middle - 1;

	mov	eax, DWORD PTR _middle$13[ebp]
	sub	eax, 1
	mov	DWORD PTR _right$14[ebp], eax
	jmp	SHORT $LN15@FS_FindFil
$LN14@FS_FindFil:

; 1672 : 				else left = middle + 1;

	mov	eax, DWORD PTR _middle$13[ebp]
	add	eax, 1
	mov	DWORD PTR _left$15[ebp], eax
$LN15@FS_FindFil:

; 1673 : 			}

	jmp	SHORT $LN5@FS_FindFil
$LN6@FS_FindFil:

; 1674 : 		}

	jmp	$LN11@FS_FindFil
$LN10@FS_FindFil:

; 1675 : 		else if( search->wad )

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	$LN16@FS_FindFil

; 1676 : 		{
; 1677 : 			dlumpinfo_t	*lump;	
; 1678 : 			char		type = W_TypeFromExt( name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_W_TypeFromExt
	add	esp, 4
	mov	BYTE PTR _type$9[ebp], al

; 1679 : 			qboolean		anywadname = true;

	mov	DWORD PTR _anywadname$8[ebp], 1

; 1680 : 			string		wadname, wadfolder;
; 1681 : 			string		shortname;
; 1682 : 
; 1683 : 			// quick reject by filetype
; 1684 : 			if( type == TYP_NONE ) continue;

	movsx	eax, BYTE PTR _type$9[ebp]
	test	eax, eax
	jne	SHORT $LN18@FS_FindFil
	jmp	$LN2@FS_FindFil
$LN18@FS_FindFil:

; 1685 : 			COM_ExtractFilePath( name, wadname );

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_ExtractFilePath
	add	esp, 8

; 1686 : 			wadfolder[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN35@FS_FindFil
	jmp	SHORT $LN36@FS_FindFil
$LN35@FS_FindFil:
	call	___report_rangecheckfailure
$LN36@FS_FindFil:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _wadfolder$6[ebp+edx], 0

; 1687 : 
; 1688 : 			if( Q_strlen( wadname ))

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@FS_FindFil

; 1689 : 			{
; 1690 : 				COM_FileBase( wadname, wadname );

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadname$7[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1691 : 				Q_strncpy( wadfolder, wadname, sizeof( wadfolder ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadfolder$6[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1692 : 				COM_DefaultExtension( wadname, ".wad" );

	push	OFFSET ??_C@_04PJEAAOBG@?4wad@
	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 1693 : 				anywadname = false;

	mov	DWORD PTR _anywadname$8[ebp], 0
$LN19@FS_FindFil:

; 1694 : 			}
; 1695 : 
; 1696 : 			// make wadname from wad fullpath
; 1697 : 			COM_FileBase( search->wad->filename, shortname );

	lea	eax, DWORD PTR _shortname$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 1698 : 			COM_DefaultExtension( shortname, ".wad" );

	push	OFFSET ??_C@_04PJEAAOBG@?4wad@
	lea	eax, DWORD PTR _shortname$5[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 1699 : 
; 1700 : 			// quick reject by wadname
; 1701 : 			if( !anywadname && Q_stricmp( wadname, shortname ))

	cmp	DWORD PTR _anywadname$8[ebp], 0
	jne	SHORT $LN20@FS_FindFil
	push	99999					; 0001869fH
	lea	eax, DWORD PTR _shortname$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadname$7[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN20@FS_FindFil

; 1702 : 				continue;

	jmp	$LN2@FS_FindFil
$LN20@FS_FindFil:

; 1703 : 
; 1704 : 			// NOTE: we can't using long names for wad,
; 1705 : 			// because we using original wad names[16];
; 1706 : 			COM_FileBase( name, shortname );

	lea	eax, DWORD PTR _shortname$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 1707 : 
; 1708 : 			lump = W_FindLump( search->wad, shortname, type );

	movzx	eax, BYTE PTR _type$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _shortname$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _search$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	call	_W_FindLump
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lump$10[ebp], eax

; 1709 : 
; 1710 : 			if( lump )

	cmp	DWORD PTR _lump$10[ebp], 0
	je	SHORT $LN21@FS_FindFil

; 1711 : 			{
; 1712 : 				if( index )

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN22@FS_FindFil

; 1713 : 					*index = lump - search->wad->lumps;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	edx, DWORD PTR _lump$10[ebp]
	sub	edx, DWORD PTR [ecx+272]
	sar	edx, 5
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], edx
$LN22@FS_FindFil:

; 1714 : 				return search;

	mov	eax, DWORD PTR _search$[ebp]
	jmp	$LN32@FS_FindFil
$LN21@FS_FindFil:

; 1715 : 			}
; 1716 : 		}

	jmp	SHORT $LN11@FS_FindFil
$LN16@FS_FindFil:

; 1717 : 		else
; 1718 : 		{
; 1719 : 			char	netpath[MAX_SYSPATH];
; 1720 : 
; 1721 : 			Q_sprintf( netpath, "%s%s", search->filename, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	edx, DWORD PTR _netpath$4[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 1722 : 
; 1723 : 			if( FS_SysFileExists( netpath ))

	lea	eax, DWORD PTR _netpath$4[ebp]
	push	eax
	call	_FS_SysFileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@FS_FindFil

; 1724 : 			{
; 1725 : 				if( index != NULL ) *index = -1;

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN24@FS_FindFil
	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN24@FS_FindFil:

; 1726 : 				return search;

	mov	eax, DWORD PTR _search$[ebp]
	jmp	$LN32@FS_FindFil
$LN11@FS_FindFil:

; 1727 : 			}
; 1728 : 		}
; 1729 : 	}

	jmp	$LN2@FS_FindFil
$LN3@FS_FindFil:

; 1730 : 
; 1731 : 	if( fs_ext_path && ( pEnvPath = getenv( "Path" )))

	cmp	DWORD PTR _fs_ext_path, 0
	je	$LN25@FS_FindFil
	push	OFFSET ??_C@_04HMIIHGGM@Path@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	mov	DWORD PTR _pEnvPath$[ebp], eax
	cmp	DWORD PTR _pEnvPath$[ebp], 0
	je	$LN25@FS_FindFil

; 1732 : 	{
; 1733 : 		char	netpath[MAX_SYSPATH];
; 1734 : 
; 1735 : 		// clear searchpath
; 1736 : 		search = &fs_directpath;

	mov	DWORD PTR _search$[ebp], OFFSET _fs_directpath

; 1737 : 		memset( search, 0, sizeof( searchpath_t ));

	push	272					; 00000110H
	push	0
	mov	eax, DWORD PTR _search$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1738 : 
; 1739 : 		// root folder has a more priority than netpath
; 1740 : 		Q_strncpy( search->filename, host.rootdir, sizeof( search->filename ));

	push	256					; 00000100H
	push	OFFSET _host+34424
	mov	eax, DWORD PTR _search$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1741 : 		Q_strcat( search->filename, "\\" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01KICIPPFI@?2@
	mov	eax, DWORD PTR _search$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1742 : 		Q_snprintf( netpath, MAX_SYSPATH, "%s%s", search->filename, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	1024					; 00000400H
	lea	edx, DWORD PTR _netpath$3[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1743 : 
; 1744 : 		if( FS_SysFileExists( netpath ))

	lea	eax, DWORD PTR _netpath$3[ebp]
	push	eax
	call	_FS_SysFileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@FS_FindFil

; 1745 : 		{
; 1746 : 			if( index != NULL )

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN27@FS_FindFil

; 1747 : 				*index = -1;

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN27@FS_FindFil:

; 1748 : 			return search;

	mov	eax, DWORD PTR _search$[ebp]
	jmp	$LN32@FS_FindFil
$LN7@FS_FindFil:

; 1749 : 		}
; 1750 : 
; 1751 : 		// search for environment path
; 1752 : 		while( pEnvPath )

	cmp	DWORD PTR _pEnvPath$[ebp], 0
	je	$LN25@FS_FindFil

; 1753 : 		{
; 1754 : 			char *end = Q_strchr( pEnvPath, ';' );

	push	59					; 0000003bH
	mov	eax, DWORD PTR _pEnvPath$[ebp]
	push	eax
	call	_Q_strchr
	add	esp, 8
	mov	DWORD PTR _end$2[ebp], eax

; 1755 : 			if( !end ) break;

	cmp	DWORD PTR _end$2[ebp], 0
	jne	SHORT $LN28@FS_FindFil
	jmp	$LN25@FS_FindFil
$LN28@FS_FindFil:

; 1756 : 			Q_strncpy( search->filename, pEnvPath, (end - pEnvPath) + 1 );

	mov	eax, DWORD PTR _end$2[ebp]
	sub	eax, DWORD PTR _pEnvPath$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pEnvPath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _search$[ebp]
	push	edx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1757 : 			Q_strcat( search->filename, "\\" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_01KICIPPFI@?2@
	mov	eax, DWORD PTR _search$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 1758 : 			Q_snprintf( netpath, MAX_SYSPATH, "%s%s", search->filename, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	1024					; 00000400H
	lea	edx, DWORD PTR _netpath$3[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 1759 : 
; 1760 : 			if( FS_SysFileExists( netpath ))

	lea	eax, DWORD PTR _netpath$3[ebp]
	push	eax
	call	_FS_SysFileExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@FS_FindFil

; 1761 : 			{
; 1762 : 				if( index != NULL )

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN30@FS_FindFil

; 1763 : 					*index = -1;

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN30@FS_FindFil:

; 1764 : 				return search;

	mov	eax, DWORD PTR _search$[ebp]
	jmp	SHORT $LN32@FS_FindFil
$LN29@FS_FindFil:

; 1765 : 			}
; 1766 : 			pEnvPath += (end - pEnvPath) + 1; // move pointer

	mov	eax, DWORD PTR _end$2[ebp]
	sub	eax, DWORD PTR _pEnvPath$[ebp]
	mov	ecx, DWORD PTR _pEnvPath$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pEnvPath$[ebp], edx

; 1767 : 		}

	jmp	$LN7@FS_FindFil
$LN25@FS_FindFil:

; 1768 : 	}
; 1769 : 
; 1770 : 	if( index != NULL )

	cmp	DWORD PTR _index$[ebp], 0
	je	SHORT $LN31@FS_FindFil

; 1771 : 		*index = -1;

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], -1
$LN31@FS_FindFil:

; 1772 : 
; 1773 : 	return NULL;

	xor	eax, eax
$LN32@FS_FindFil:

; 1774 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FindFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_InitMemory
_TEXT	SEGMENT
_FS_InitMemory PROC					; COMDAT

; 2774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2775 : 	fs_mempool = Mem_AllocPool( "FileSystem Pool" );	

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_InitMemory@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BA@DFPLEAFN@FileSystem?5Pool@
	call	__Mem_AllocPool
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fs_mempool, eax

; 2776 : 	fs_searchpaths = NULL;

	mov	DWORD PTR _fs_searchpaths, 0

; 2777 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_InitMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FindLibrary
_TEXT	SEGMENT
tv182 = -352						; size = 4
$T1 = -348						; size = 4
_start$ = -280						; size = 4
_index$ = -276						; size = 4
_i$ = -272						; size = 4
_hInst$ = -268						; size = 4
_search$ = -264						; size = 4
_dllpath$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_dllname$ = 8						; size = 4
_directpath$ = 12					; size = 4
_FS_FindLibrary PROC					; COMDAT

; 2339 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2340 : 	string		dllpath;
; 2341 : 	searchpath_t	*search;
; 2342 : 	dll_user_t	*hInst;
; 2343 : 	int		i, index;
; 2344 : 	int		start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 2345 : 
; 2346 : 	// check for bad exports
; 2347 : 	if( !COM_CheckString( dllname ))

	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@FS_FindLib

; 2348 : 		return NULL;

	xor	eax, eax
	jmp	$LN14@FS_FindLib
$LN5@FS_FindLib:

; 2349 : 
; 2350 : 	fs_ext_path = directpath;

	mov	eax, DWORD PTR _directpath$[ebp]
	mov	DWORD PTR _fs_ext_path, eax

; 2351 : 
; 2352 : 	// HACKHACK remove absoulte path to valve folder
; 2353 : 	if( !Q_strnicmp( dllname, "..\\valve\\", 9 ) || !Q_strnicmp( dllname, "../valve/", 9 ))

	push	9
	push	OFFSET ??_C@_09DMPFMCD@?4?4?2valve?2@
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@FS_FindLib
	push	9
	push	OFFSET ??_C@_09CFACOAGF@?4?4?1valve?1@
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FS_FindLib
$LN7@FS_FindLib:

; 2354 : 		start += 9;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, 9
	mov	DWORD PTR _start$[ebp], eax
$LN6@FS_FindLib:

; 2355 : 
; 2356 : 	// replace all backward slashes
; 2357 : 	for( i = 0; i < Q_strlen( dllname ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_FindLib
$LN2@FS_FindLib:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_FindLib:
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@FS_FindLib

; 2358 : 	{
; 2359 : 		if( dllname[i+start] == '\\' ) dllpath[i] = '/';

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR _dllname$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN8@FS_FindLib
	mov	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR _dllpath$[ebp+eax], 47		; 0000002fH
	jmp	SHORT $LN9@FS_FindLib
$LN8@FS_FindLib:

; 2360 : 		else dllpath[i] = Q_tolower( dllname[i+start] );

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _start$[ebp]
	mov	ecx, DWORD PTR _dllname$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	_Q_tolower
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _dllpath$[ebp+ecx], al
$LN9@FS_FindLib:

; 2361 : 	}

	jmp	SHORT $LN2@FS_FindLib
$LN3@FS_FindLib:

; 2362 : 	dllpath[i] = '\0';

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN15@FS_FindLib
	jmp	SHORT $LN16@FS_FindLib
$LN15@FS_FindLib:
	call	___report_rangecheckfailure
$LN16@FS_FindLib:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _dllpath$[ebp+ecx], 0

; 2363 : 
; 2364 : 	COM_DefaultExtension( dllpath, ".dll" );	// apply ext if forget

	push	OFFSET ??_C@_04HLONOPDM@?4dll@
	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 2365 : 	search = FS_FindFile( dllpath, &index, false );

	push	0
	lea	eax, DWORD PTR _index$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllpath$[ebp]
	push	ecx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 2366 : 
; 2367 : 	if( !search && !directpath )

	cmp	DWORD PTR _search$[ebp], 0
	jne	SHORT $LN10@FS_FindLib
	cmp	DWORD PTR _directpath$[ebp], 0
	jne	SHORT $LN10@FS_FindLib

; 2368 : 	{
; 2369 : 		fs_ext_path = false;

	mov	DWORD PTR _fs_ext_path, 0

; 2370 : 
; 2371 : 		// trying check also 'bin' folder for indirect paths
; 2372 : 		Q_strncpy( dllpath, dllname, sizeof( dllpath ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllpath$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2373 : 		search = FS_FindFile( dllpath, &index, false );

	push	0
	lea	eax, DWORD PTR _index$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllpath$[ebp]
	push	ecx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 2374 : 		if( !search ) return NULL; // unable to find

	cmp	DWORD PTR _search$[ebp], 0
	jne	SHORT $LN10@FS_FindLib
	xor	eax, eax
	jmp	$LN14@FS_FindLib
$LN10@FS_FindLib:

; 2375 : 	}
; 2376 : 
; 2377 : 	// NOTE: for libraries we not fail even if search is NULL
; 2378 : 	// let the OS find library himself
; 2379 : 	hInst = Mem_Calloc( host.mempool, sizeof( dll_user_t ));	

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FindLibrary@@9@9
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	16956					; 0000423cH
	mov	ecx, DWORD PTR _host+236
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hInst$[ebp], eax

; 2380 : 
; 2381 : 	// save dllname for debug purposes
; 2382 : 	Q_strncpy( hInst->dllName, dllname, sizeof( hInst->dllName ));

	push	32					; 00000020H
	mov	eax, DWORD PTR _dllname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2383 : 
; 2384 : 	// shortPath is used for LibraryLoadSymbols only
; 2385 : 	Q_strncpy( hInst->shortPath, dllpath, sizeof( hInst->shortPath ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2386 : 
; 2387 : 	hInst->encrypted = FS_CheckForCrypt( dllpath );

	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	call	_FS_CheckForCrypt
	add	esp, 4
	mov	ecx, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2388 : 
; 2389 : 	if( index < 0 && !hInst->encrypted && search )

	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $LN12@FS_FindLib
	mov	eax, DWORD PTR _hInst$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN12@FS_FindLib
	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN12@FS_FindLib

; 2390 : 	{
; 2391 : 		Q_snprintf( hInst->fullPath, sizeof( hInst->fullPath ), "%s%s", search->filename, dllpath );

	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	256					; 00000100H
	mov	edx, DWORD PTR _hInst$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2392 : 		hInst->custom_loader = false;	// we can loading from disk and use normal debugging

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR [eax+4], 0

; 2393 : 	}

	jmp	SHORT $LN13@FS_FindLib
$LN12@FS_FindLib:

; 2394 : 	else
; 2395 : 	{
; 2396 : 		// NOTE: if search is NULL let the OS found library himself
; 2397 : 		Q_strncpy( hInst->fullPath, dllpath, sizeof( hInst->fullPath ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _dllpath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2398 : 		hInst->custom_loader = (search) ? true : false;

	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN17@FS_FindLib
	mov	DWORD PTR tv182[ebp], 1
	jmp	SHORT $LN18@FS_FindLib
$LN17@FS_FindLib:
	mov	DWORD PTR tv182[ebp], 0
$LN18@FS_FindLib:
	mov	eax, DWORD PTR _hInst$[ebp]
	mov	ecx, DWORD PTR tv182[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN13@FS_FindLib:

; 2399 : 	}
; 2400 : 	fs_ext_path = false; // always reset direct paths

	mov	DWORD PTR _fs_ext_path, 0

; 2401 : 		
; 2402 : 	return hInst;

	mov	eax, DWORD PTR _hInst$[ebp]
$LN14@FS_FindLib:

; 2403 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FindLibrary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FileLength
_TEXT	SEGMENT
_f$ = 8							; size = 4
_FS_FileLength PROC					; COMDAT

; 2438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2439 : 	if( !f ) return 0;

	cmp	DWORD PTR _f$[ebp], 0
	jne	SHORT $LN2@FS_FileLen
	xor	eax, eax
	jmp	SHORT $LN1@FS_FileLen
$LN2@FS_FileLen:

; 2440 : 	return f->real_length;

	mov	eax, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN1@FS_FileLen:

; 2441 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FileLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Getc
_TEXT	SEGMENT
_c$ = -1						; size = 1
_file$ = 8						; size = 4
_FS_Getc PROC						; COMDAT

; 2057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2058 : 	char	c;
; 2059 : 
; 2060 : 	if( FS_Read( file, &c, 1 ) != 1 )

	push	1
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN2@FS_Getc

; 2061 : 		return EOF;

	or	eax, -1
	jmp	SHORT $LN1@FS_Getc
$LN2@FS_Getc:

; 2062 : 
; 2063 : 	return c;

	movsx	eax, BYTE PTR _c$[ebp]
$LN1@FS_Getc:

; 2064 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Getc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Close
_TEXT	SEGMENT
_file$ = 8						; size = 4
_FS_Close PROC						; COMDAT

; 1860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1861 : 	if( !file ) return 0;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_Close
	xor	eax, eax
	jmp	SHORT $LN1@FS_Close
$LN2@FS_Close:

; 1862 : 
; 1863 : 	if( close( file->handle ))

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__close
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@FS_Close

; 1864 : 		return EOF;

	or	eax, -1
	jmp	SHORT $LN1@FS_Close
$LN3@FS_Close:

; 1865 : 
; 1866 : 	Mem_Free( file );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Close@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 1867 : 	return 0;

	xor	eax, eax
$LN1@FS_Close:

; 1868 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Eof
_TEXT	SEGMENT
tv72 = -68						; size = 4
_file$ = 8						; size = 4
_FS_Eof	PROC						; COMDAT

; 2183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2184 : 	if( !file ) return true;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_Eof
	mov	eax, 1
	jmp	SHORT $LN1@FS_Eof
$LN2@FS_Eof:

; 2185 : 	return (( file->position - file->buff_len + file->buff_ind ) == file->real_length ) ? true : false;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _file$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _file$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@FS_Eof
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN5@FS_Eof
$LN4@FS_Eof:
	mov	DWORD PTR tv72[ebp], 0
$LN5@FS_Eof:
	mov	eax, DWORD PTR tv72[ebp]
$LN1@FS_Eof:

; 2186 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Eof	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Tell
_TEXT	SEGMENT
_file$ = 8						; size = 4
_FS_Tell PROC						; COMDAT

; 2170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2171 : 	if( !file ) return 0;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_Tell
	xor	eax, eax
	jmp	SHORT $LN1@FS_Tell
$LN2@FS_Tell:

; 2172 : 	return file->position - file->buff_len + file->buff_ind;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR _file$[ebp]
	add	eax, DWORD PTR [edx+32]
$LN1@FS_Tell:

; 2173 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Tell ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_UnGetc
_TEXT	SEGMENT
_file$ = 8						; size = 4
_c$ = 12						; size = 1
_FS_UnGetc PROC						; COMDAT

; 2074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2075 : 	// If there's already a character waiting to be read
; 2076 : 	if( file->ungetc != EOF )

	mov	eax, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [eax+16], -1
	je	SHORT $LN2@FS_UnGetc

; 2077 : 		return EOF;

	or	eax, -1
	jmp	SHORT $LN1@FS_UnGetc
$LN2@FS_UnGetc:

; 2078 : 
; 2079 : 	file->ungetc = c;

	movzx	eax, BYTE PTR _c$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 2080 : 	return c;

	movzx	eax, BYTE PTR _c$[ebp]
$LN1@FS_UnGetc:

; 2081 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_UnGetc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Delete
_TEXT	SEGMENT
tv76 = -1228						; size = 4
_iRet$ = -1032						; size = 4
_real_path$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
_FS_Delete PROC						; COMDAT

; 2508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1228				; 000004ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2509 : 	char	real_path[MAX_SYSPATH];
; 2510 : 	qboolean	iRet;
; 2511 : 
; 2512 : 	if( !path || !*path )

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN3@FS_Delete
	mov	eax, DWORD PTR _path$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@FS_Delete
$LN3@FS_Delete:

; 2513 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@FS_Delete
$LN2@FS_Delete:

; 2514 : 
; 2515 : 	Q_snprintf( real_path, sizeof( real_path ), "%s%s", fs_writedir, path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	push	OFFSET _fs_writedir
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _real_path$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2516 : 	COM_FixSlashes( real_path );

	lea	eax, DWORD PTR _real_path$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2517 : 	iRet = remove( real_path );

	lea	eax, DWORD PTR _real_path$[ebp]
	push	eax
	call	DWORD PTR __imp__remove
	add	esp, 4
	mov	DWORD PTR _iRet$[ebp], eax

; 2518 : 
; 2519 : 	return (iRet == 0);

	cmp	DWORD PTR _iRet$[ebp], 0
	jne	SHORT $LN5@FS_Delete
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN6@FS_Delete
$LN5@FS_Delete:
	mov	DWORD PTR tv76[ebp], 0
$LN6@FS_Delete:
	mov	eax, DWORD PTR tv76[ebp]
$LN1@FS_Delete:

; 2520 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Delete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FileCopy
_TEXT	SEGMENT
_done$ = -16						; size = 4
_readSize$ = -12					; size = 4
_size$ = -8						; size = 4
_buf$ = -4						; size = 4
_pOutput$ = 8						; size = 4
_pInput$ = 12						; size = 4
_fileSize$ = 16						; size = 4
_FS_FileCopy PROC					; COMDAT

; 2529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 2530 : 	char	*buf = Mem_Malloc( fs_mempool, FILE_COPY_SIZE );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FileCopy@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	push	1048576					; 00100000H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buf$[ebp], eax

; 2531 : 	int	size, readSize;
; 2532 : 	qboolean	done = true;

	mov	DWORD PTR _done$[ebp], 1
$LN2@FS_FileCop:

; 2533 : 
; 2534 : 	while( fileSize > 0 )

	cmp	DWORD PTR _fileSize$[ebp], 0
	jle	SHORT $LN3@FS_FileCop

; 2535 : 	{
; 2536 : 		if( fileSize > FILE_COPY_SIZE )

	cmp	DWORD PTR _fileSize$[ebp], 1048576	; 00100000H
	jle	SHORT $LN4@FS_FileCop

; 2537 : 			size = FILE_COPY_SIZE;

	mov	DWORD PTR _size$[ebp], 1048576		; 00100000H
	jmp	SHORT $LN5@FS_FileCop
$LN4@FS_FileCop:

; 2538 : 		else size = fileSize;

	mov	eax, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR _size$[ebp], eax
$LN5@FS_FileCop:

; 2539 : 
; 2540 : 		if(( readSize = FS_Read( pInput, buf, size )) < size )

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pInput$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _readSize$[ebp], eax
	mov	eax, DWORD PTR _readSize$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN6@FS_FileCop

; 2541 : 		{
; 2542 : 			Con_DPrintf( S_ERROR "FS_FileCopy: unexpected end of input file (%d < %d)\n", readSize, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readSize$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EA@KLBAKJBF@?$FO1Error?3?$FO7?5FS_FileCopy?3?5unexpec@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 2543 : 			fileSize = 0;

	mov	DWORD PTR _fileSize$[ebp], 0

; 2544 : 			done = false;

	mov	DWORD PTR _done$[ebp], 0

; 2545 : 			break;

	jmp	SHORT $LN3@FS_FileCop
$LN6@FS_FileCop:

; 2546 : 		}
; 2547 : 
; 2548 : 		FS_Write( pOutput, buf, readSize );

	mov	eax, DWORD PTR _readSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOutput$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 2549 : 		fileSize -= size;

	mov	eax, DWORD PTR _fileSize$[ebp]
	sub	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _fileSize$[ebp], eax

; 2550 : 	}

	jmp	$LN2@FS_FileCop
$LN3@FS_FileCop:

; 2551 : 
; 2552 : 	Mem_Free( buf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_FileCopy@@9@9
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2553 : 	return done;

	mov	eax, DWORD PTR _done$[ebp]

; 2554 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FileCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FileExists
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_gamedironly$ = 12					; size = 4
_FS_FileExists PROC					; COMDAT

; 2277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2278 : 	if( FS_FindFile( filename, NULL, gamedironly ))

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@FS_FileExi

; 2279 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@FS_FileExi
$LN2@FS_FileExi:

; 2280 : 	return false;

	xor	eax, eax
$LN1@FS_FileExi:

; 2281 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FileExists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Rename
_TEXT	SEGMENT
tv86 = -2380						; size = 4
_iRet$ = -2056						; size = 4
_newpath$ = -2052					; size = 1024
_oldpath$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_oldname$ = 8						; size = 4
_newname$ = 12						; size = 4
_FS_Rename PROC						; COMDAT

; 2482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2380				; 0000094cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2483 : 	char	oldpath[MAX_SYSPATH], newpath[MAX_SYSPATH];
; 2484 : 	qboolean	iRet;
; 2485 : 
; 2486 : 	if( !oldname || !newname || !*oldname || !*newname )

	cmp	DWORD PTR _oldname$[ebp], 0
	je	SHORT $LN3@FS_Rename
	cmp	DWORD PTR _newname$[ebp], 0
	je	SHORT $LN3@FS_Rename
	mov	eax, DWORD PTR _oldname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@FS_Rename
	mov	eax, DWORD PTR _newname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@FS_Rename
$LN3@FS_Rename:

; 2487 : 		return false;

	xor	eax, eax
	jmp	$LN1@FS_Rename
$LN2@FS_Rename:

; 2488 : 
; 2489 : 	Q_snprintf( oldpath, sizeof( oldpath ), "%s%s", fs_writedir, oldname );

	mov	eax, DWORD PTR _oldname$[ebp]
	push	eax
	push	OFFSET _fs_writedir
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _oldpath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2490 : 	Q_snprintf( newpath, sizeof( newpath ), "%s%s", fs_writedir, newname );

	mov	eax, DWORD PTR _newname$[ebp]
	push	eax
	push	OFFSET _fs_writedir
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _newpath$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2491 : 
; 2492 : 	COM_FixSlashes( oldpath );

	lea	eax, DWORD PTR _oldpath$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2493 : 	COM_FixSlashes( newpath );

	lea	eax, DWORD PTR _newpath$[ebp]
	push	eax
	call	_COM_FixSlashes
	add	esp, 4

; 2494 : 
; 2495 : 	iRet = rename( oldpath, newpath );

	lea	eax, DWORD PTR _newpath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldpath$[ebp]
	push	ecx
	call	DWORD PTR __imp__rename
	add	esp, 8
	mov	DWORD PTR _iRet$[ebp], eax

; 2496 : 
; 2497 : 	return (iRet == 0);

	cmp	DWORD PTR _iRet$[ebp], 0
	jne	SHORT $LN5@FS_Rename
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN6@FS_Rename
$LN5@FS_Rename:
	mov	DWORD PTR tv86[ebp], 0
$LN6@FS_Rename:
	mov	eax, DWORD PTR tv86[ebp]
$LN1@FS_Rename:

; 2498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Rename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Print
_TEXT	SEGMENT
_file$ = 8						; size = 4
_msg$ = 12						; size = 4
_FS_Print PROC						; COMDAT

; 1993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1994 : 	return FS_Write( file, msg, Q_strlen( msg ));

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 1995 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FileTime
_TEXT	SEGMENT
_path$1 = -1036						; size = 1024
_pack_ind$ = -12					; size = 4
_search$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_filename$ = 8						; size = 4
_gamedironly$ = 12					; size = 4
_FS_FileTime PROC					; COMDAT

; 2451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1228				; 000004ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2452 : 	searchpath_t	*search;
; 2453 : 	int		pack_ind;
; 2454 : 	
; 2455 : 	search = FS_FindFile( filename, &pack_ind, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pack_ind$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 2456 : 	if( !search ) return -1; // doesn't exist

	cmp	DWORD PTR _search$[ebp], 0
	jne	SHORT $LN2@FS_FileTim
	or	eax, -1
	jmp	SHORT $LN1@FS_FileTim
$LN2@FS_FileTim:

; 2457 : 
; 2458 : 	if( search->pack ) // grab pack filetime

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN3@FS_FileTim

; 2459 : 		return search->pack->filetime;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	eax, DWORD PTR [ecx+264]
	jmp	SHORT $LN1@FS_FileTim
	jmp	SHORT $LN4@FS_FileTim
$LN3@FS_FileTim:

; 2460 : 	else if( search->wad ) // grab wad filetime

	mov	eax, DWORD PTR _search$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN5@FS_FileTim

; 2461 : 		return search->wad->filetime;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [ecx+280]
	jmp	SHORT $LN1@FS_FileTim
	jmp	SHORT $LN4@FS_FileTim
$LN5@FS_FileTim:

; 2462 : 	else if( pack_ind < 0 )

	cmp	DWORD PTR _pack_ind$[ebp], 0
	jge	SHORT $LN4@FS_FileTim

; 2463 : 	{
; 2464 : 		// found in the filesystem?
; 2465 : 		char	path [MAX_SYSPATH];
; 2466 : 
; 2467 : 		Q_sprintf( path, "%s%s", search->filename, filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	edx, DWORD PTR _path$1[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 2468 : 		return FS_SysFileTime( path );

	lea	eax, DWORD PTR _path$1[ebp]
	push	eax
	call	_FS_SysFileTime
	add	esp, 4
	jmp	SHORT $LN1@FS_FileTim
$LN4@FS_FileTim:

; 2469 : 	}
; 2470 : 
; 2471 : 	return -1; // doesn't exist

	or	eax, -1
$LN1@FS_FileTim:

; 2472 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FileTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_FileSize
_TEXT	SEGMENT
_fp$ = -8						; size = 4
_length$ = -4						; size = 4
_filename$ = 8						; size = 4
_gamedironly$ = 12					; size = 4
_FS_FileSize PROC					; COMDAT

; 2413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2414 : 	int	length = -1; // in case file was missed

	mov	DWORD PTR _length$[ebp], -1

; 2415 : 	file_t	*fp;	
; 2416 : 
; 2417 : 	fp = FS_Open( filename, "rb", gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	OFFSET ??_C@_02JDPG@rb@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 2418 : 
; 2419 : 	if( fp )

	cmp	DWORD PTR _fp$[ebp], 0
	je	SHORT $LN2@FS_FileSiz

; 2420 : 	{
; 2421 : 		// it exists
; 2422 : 		FS_Seek( fp, 0, SEEK_END );

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 2423 : 		length = FS_Tell( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 2424 : 		FS_Close( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4
$LN2@FS_FileSiz:

; 2425 : 	}
; 2426 : 
; 2427 : 	return length;

	mov	eax, DWORD PTR _length$[ebp]

; 2428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_FileSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Printf
_TEXT	SEGMENT
_args$ = -8						; size = 4
_result$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_FS_Printf PROC						; COMDAT

; 2005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2006 : 	int	result;
; 2007 : 	va_list	args;
; 2008 : 
; 2009 : 	va_start( args, format );

	lea	eax, DWORD PTR _format$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 2010 : 	result = FS_VPrintf( file, format, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_VPrintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 2011 : 	va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 2012 : 
; 2013 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]

; 2014 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Printf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Gets
_TEXT	SEGMENT
_end$ = -8						; size = 4
_c$ = -4						; size = 4
_file$ = 8						; size = 4
_string$ = 12						; size = 4
_bufsize$ = 16						; size = 4
_FS_Gets PROC						; COMDAT

; 2091 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2092 : 	int	c, end = 0;

	mov	DWORD PTR _end$[ebp], 0
$LN2@FS_Gets:

; 2093 : 
; 2094 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@FS_Gets

; 2095 : 	{
; 2096 : 		c = FS_Getc( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Getc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 2097 : 
; 2098 : 		if( c == '\r' || c == '\n' || c < 0 )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN5@FS_Gets
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN5@FS_Gets
	cmp	DWORD PTR _c$[ebp], 0
	jge	SHORT $LN4@FS_Gets
$LN5@FS_Gets:

; 2099 : 			break;

	jmp	SHORT $LN3@FS_Gets
$LN4@FS_Gets:

; 2100 : 
; 2101 : 		if( end < bufsize - 1 )

	mov	eax, DWORD PTR _bufsize$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _end$[ebp], eax
	jae	SHORT $LN6@FS_Gets

; 2102 : 			string[end++] = c;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _end$[ebp]
	add	edx, 1
	mov	DWORD PTR _end$[ebp], edx
$LN6@FS_Gets:

; 2103 : 	}

	jmp	SHORT $LN2@FS_Gets
$LN3@FS_Gets:

; 2104 : 	string[end] = 0;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	mov	BYTE PTR [eax], 0

; 2105 : 
; 2106 : 	// remove \n following \r
; 2107 : 	if( c == '\r' )

	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	jne	SHORT $LN7@FS_Gets

; 2108 : 	{
; 2109 : 		c = FS_Getc( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Getc
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 2110 : 
; 2111 : 		if( c != '\n' )

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN7@FS_Gets

; 2112 : 			FS_UnGetc( file, (byte)c );

	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_UnGetc
	add	esp, 8
$LN7@FS_Gets:

; 2113 : 	}
; 2114 : 
; 2115 : 	return c;

	mov	eax, DWORD PTR _c$[ebp]

; 2116 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Gets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Seek
_TEXT	SEGMENT
tv64 = -68						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_FS_Seek PROC						; COMDAT

; 2126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2127 : 	// compute the file offset
; 2128 : 	switch( whence )

	mov	eax, DWORD PTR _whence$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN5@FS_Seek
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN4@FS_Seek
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN6@FS_Seek
	jmp	SHORT $LN7@FS_Seek
$LN4@FS_Seek:

; 2129 : 	{
; 2130 : 	case SEEK_CUR:
; 2131 : 		offset += file->position - file->buff_len + file->buff_ind;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _file$[ebp]
	add	edx, DWORD PTR [eax+32]
	add	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _offset$[ebp], edx

; 2132 : 		break;

	jmp	SHORT $LN2@FS_Seek
$LN5@FS_Seek:

; 2133 : 	case SEEK_SET:
; 2134 : 		break;

	jmp	SHORT $LN2@FS_Seek
$LN6@FS_Seek:

; 2135 : 	case SEEK_END:
; 2136 : 		offset += file->real_length;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _offset$[ebp], ecx

; 2137 : 		break;

	jmp	SHORT $LN2@FS_Seek
$LN7@FS_Seek:

; 2138 : 	default: 
; 2139 : 		return -1;

	or	eax, -1
	jmp	$LN1@FS_Seek
$LN2@FS_Seek:

; 2140 : 	}
; 2141 : 	
; 2142 : 	if( offset < 0 || offset > file->real_length )

	cmp	DWORD PTR _offset$[ebp], 0
	jl	SHORT $LN9@FS_Seek
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN8@FS_Seek
$LN9@FS_Seek:

; 2143 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_Seek
$LN8@FS_Seek:

; 2144 : 
; 2145 : 	// if we have the data in our read buffer, we don't need to actually seek
; 2146 : 	if( file->position - file->buff_len <= offset && offset <= file->position )

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR _offset$[ebp]
	jg	SHORT $LN10@FS_Seek
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jg	SHORT $LN10@FS_Seek

; 2147 : 	{
; 2148 : 		file->buff_ind = offset + file->buff_len - file->position;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _file$[ebp]
	sub	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2149 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_Seek
$LN10@FS_Seek:

; 2150 : 	}
; 2151 : 
; 2152 : 	// Purge cached data
; 2153 : 	FS_Purge( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Purge
	add	esp, 4

; 2154 : 
; 2155 : 	if( lseek( file->handle, file->offset + offset, SEEK_SET ) == -1 )

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $LN11@FS_Seek

; 2156 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@FS_Seek
$LN11@FS_Seek:

; 2157 : 	file->position = offset;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 2158 : 
; 2159 : 	return 0;

	xor	eax, eax
$LN1@FS_Seek:

; 2160 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_VPrintf
_TEXT	SEGMENT
_tempbuff$ = -12					; size = 4
_buff_size$ = -8					; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_ap$ = 16						; size = 4
_FS_VPrintf PROC					; COMDAT

; 2024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2025 : 	int	len;
; 2026 : 	long	buff_size = MAX_SYSPATH;

	mov	DWORD PTR _buff_size$[ebp], 1024	; 00000400H

; 2027 : 	char	*tempbuff;
; 2028 : 
; 2029 : 	if( !file ) return 0;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_VPrintf
	xor	eax, eax
	jmp	$LN1@FS_VPrintf
$LN2@FS_VPrintf:

; 2030 : 
; 2031 : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@FS_VPrintf

; 2032 : 	{
; 2033 : 		tempbuff = (char *)Mem_Malloc( fs_mempool, buff_size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_VPrintf@@9@9
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _buff_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tempbuff$[ebp], eax

; 2034 : 		len = Q_vsprintf( tempbuff, format, ap );

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	push	99999					; 0001869fH
	mov	edx, DWORD PTR _tempbuff$[ebp]
	push	edx
	call	_Q_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 2035 : 
; 2036 : 		if( len >= 0 && len < buff_size )

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN5@FS_VPrintf
	mov	eax, DWORD PTR _len$[ebp]
	cmp	eax, DWORD PTR _buff_size$[ebp]
	jge	SHORT $LN5@FS_VPrintf

; 2037 : 			break;

	jmp	SHORT $LN3@FS_VPrintf
$LN5@FS_VPrintf:

; 2038 : 
; 2039 : 		Mem_Free( tempbuff );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_VPrintf@@9@9
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _tempbuff$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2040 : 		buff_size *= 2;

	mov	eax, DWORD PTR _buff_size$[ebp]
	shl	eax, 1
	mov	DWORD PTR _buff_size$[ebp], eax

; 2041 : 	}

	jmp	SHORT $LN2@FS_VPrintf
$LN3@FS_VPrintf:

; 2042 : 
; 2043 : 	len = write( file->handle, tempbuff, len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tempbuff$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__write
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _len$[ebp], eax

; 2044 : 	Mem_Free( tempbuff );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_VPrintf@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _tempbuff$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2045 : 
; 2046 : 	return len;

	mov	eax, DWORD PTR _len$[ebp]
$LN1@FS_VPrintf:

; 2047 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_VPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Read
_TEXT	SEGMENT
tv172 = -80						; size = 4
tv79 = -80						; size = 4
_nb$ = -12						; size = 4
_done$ = -8						; size = 4
_count$ = -4						; size = 4
_file$ = 8						; size = 4
_buffer$ = 12						; size = 4
_buffersize$ = 16					; size = 4
_FS_Read PROC						; COMDAT

; 1910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1911 : 	long	count, done;
; 1912 : 	long	nb;
; 1913 : 
; 1914 : 	// nothing to copy
; 1915 : 	if( buffersize == 0 ) return 1;

	cmp	DWORD PTR _buffersize$[ebp], 0
	jne	SHORT $LN2@FS_Read
	mov	eax, 1
	jmp	$LN1@FS_Read
$LN2@FS_Read:

; 1916 : 
; 1917 : 	// Get rid of the ungetc character
; 1918 : 	if( file->ungetc != EOF )

	mov	eax, DWORD PTR _file$[ebp]
	cmp	DWORD PTR [eax+16], -1
	je	SHORT $LN3@FS_Read

; 1919 : 	{
; 1920 : 		((char*)buffer)[0] = file->ungetc;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	eax, DWORD PTR _file$[ebp]
	mov	al, BYTE PTR [eax+16]
	mov	BYTE PTR [edx+ecx], al

; 1921 : 		buffersize--;

	mov	eax, DWORD PTR _buffersize$[ebp]
	sub	eax, 1
	mov	DWORD PTR _buffersize$[ebp], eax

; 1922 : 		file->ungetc = EOF;

	mov	eax, DWORD PTR _file$[ebp]
	mov	DWORD PTR [eax+16], -1

; 1923 : 		done = 1;

	mov	DWORD PTR _done$[ebp], 1

; 1924 : 	}

	jmp	SHORT $LN4@FS_Read
$LN3@FS_Read:

; 1925 : 	else done = 0;

	mov	DWORD PTR _done$[ebp], 0
$LN4@FS_Read:

; 1926 : 
; 1927 : 	// first, we copy as many bytes as we can from "buff"
; 1928 : 	if( file->buff_ind < file->buff_len )

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+36]
	jge	SHORT $LN5@FS_Read

; 1929 : 	{
; 1930 : 		count = file->buff_len - file->buff_ind;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+36]
	sub	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _count$[ebp], edx

; 1931 : 
; 1932 : 		done += ((long)buffersize > count ) ? count : (long)buffersize;

	mov	eax, DWORD PTR _buffersize$[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jle	SHORT $LN14@FS_Read
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN15@FS_Read
$LN14@FS_Read:
	mov	edx, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN15@FS_Read:
	mov	eax, DWORD PTR _done$[ebp]
	add	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _done$[ebp], eax

; 1933 : 		memcpy( buffer, &file->buff[file->buff_ind], done );

	mov	eax, DWORD PTR _done$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _file$[ebp]
	lea	ecx, DWORD PTR [eax+edx+40]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1934 : 		file->buff_ind += done;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _done$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 1935 : 
; 1936 : 		buffersize -= done;

	mov	eax, DWORD PTR _buffersize$[ebp]
	sub	eax, DWORD PTR _done$[ebp]
	mov	DWORD PTR _buffersize$[ebp], eax

; 1937 : 		if( buffersize == 0 )

	jne	SHORT $LN5@FS_Read

; 1938 : 			return done;

	mov	eax, DWORD PTR _done$[ebp]
	jmp	$LN1@FS_Read
$LN5@FS_Read:

; 1939 : 	}
; 1940 : 
; 1941 : 	// NOTE: at this point, the read buffer is always empty
; 1942 : 
; 1943 : 	// we must take care to not read after the end of the file
; 1944 : 	count = file->real_length - file->position;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _count$[ebp], edx

; 1945 : 
; 1946 : 	// if we have a lot of data to get, put them directly into "buffer"
; 1947 : 	if( buffersize > sizeof( file->buff ) / 2 )

	cmp	DWORD PTR _buffersize$[ebp], 1024	; 00000400H
	jbe	SHORT $LN7@FS_Read

; 1948 : 	{
; 1949 : 		if( count > (long)buffersize )

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _buffersize$[ebp]
	jle	SHORT $LN9@FS_Read

; 1950 : 			count = (long)buffersize;

	mov	eax, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN9@FS_Read:

; 1951 : 		lseek( file->handle, file->offset + file->position, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _file$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH

; 1952 : 		nb = read (file->handle, &((byte *)buffer)[done], count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	add	ecx, DWORD PTR _done$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nb$[ebp], eax

; 1953 : 
; 1954 : 		if( nb > 0 )

	cmp	DWORD PTR _nb$[ebp], 0
	jle	SHORT $LN10@FS_Read

; 1955 : 		{
; 1956 : 			done += nb;

	mov	eax, DWORD PTR _done$[ebp]
	add	eax, DWORD PTR _nb$[ebp]
	mov	DWORD PTR _done$[ebp], eax

; 1957 : 			file->position += nb;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1958 : 			// purge cached data
; 1959 : 			FS_Purge( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Purge
	add	esp, 4
$LN10@FS_Read:

; 1960 : 		}
; 1961 : 	}

	jmp	$LN8@FS_Read
$LN7@FS_Read:

; 1962 : 	else
; 1963 : 	{
; 1964 : 		if( count > (long)sizeof( file->buff ))

	cmp	DWORD PTR _count$[ebp], 2048		; 00000800H
	jle	SHORT $LN11@FS_Read

; 1965 : 			count = (long)sizeof( file->buff );

	mov	DWORD PTR _count$[ebp], 2048		; 00000800H
$LN11@FS_Read:

; 1966 : 		lseek( file->handle, file->offset + file->position, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _file$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH

; 1967 : 		nb = read( file->handle, file->buff, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _nb$[ebp], eax

; 1968 : 
; 1969 : 		if( nb > 0 )

	cmp	DWORD PTR _nb$[ebp], 0
	jle	SHORT $LN8@FS_Read

; 1970 : 		{
; 1971 : 			file->buff_len = nb;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _nb$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 1972 : 			file->position += nb;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nb$[ebp]
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1973 : 
; 1974 : 			// copy the requested data in "buffer" (as much as we can)
; 1975 : 			count = (long)buffersize > file->buff_len ? file->buff_len : (long)buffersize;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _buffersize$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jle	SHORT $LN16@FS_Read
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN17@FS_Read
$LN16@FS_Read:
	mov	ecx, DWORD PTR _buffersize$[ebp]
	mov	DWORD PTR tv172[ebp], ecx
$LN17@FS_Read:
	mov	edx, DWORD PTR tv172[ebp]
	mov	DWORD PTR _count$[ebp], edx

; 1976 : 			memcpy( &((byte *)buffer)[done], file->buff, count );

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	add	edx, DWORD PTR _done$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1977 : 			file->buff_ind = count;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 1978 : 			done += count;

	mov	eax, DWORD PTR _done$[ebp]
	add	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _done$[ebp], eax
$LN8@FS_Read:

; 1979 : 		}
; 1980 : 	}
; 1981 : 
; 1982 : 	return done;

	mov	eax, DWORD PTR _done$[ebp]
$LN1@FS_Read:

; 1983 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Write
_TEXT	SEGMENT
_result$ = -4						; size = 4
_file$ = 8						; size = 4
_data$ = 12						; size = 4
_datasize$ = 16						; size = 4
_FS_Write PROC						; COMDAT

; 1878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1879 : 	long	result;
; 1880 : 
; 1881 : 	if( !file ) return 0;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_Write
	xor	eax, eax
	jmp	$LN1@FS_Write
$LN2@FS_Write:

; 1882 : 
; 1883 : 	// if necessary, seek to the exact file position we're supposed to be
; 1884 : 	if( file->buff_ind != file->buff_len )

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [ecx+36]
	je	SHORT $LN3@FS_Write

; 1885 : 		lseek( file->handle, file->buff_ind - file->buff_len, SEEK_CUR );

	push	1
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+32]
	sub	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
$LN3@FS_Write:

; 1886 : 
; 1887 : 	// purge cached data
; 1888 : 	FS_Purge( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Purge
	add	esp, 4

; 1889 : 
; 1890 : 	// write the buffer and update the position
; 1891 : 	result = write( file->handle, data, (long)datasize );

	mov	eax, DWORD PTR _datasize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__write
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax

; 1892 : 	file->position = lseek( file->handle, 0, SEEK_CUR );

	push	1
	push	0
	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _file$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1893 : 
; 1894 : 	if( file->real_length < file->position )

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN4@FS_Write

; 1895 : 		file->real_length = file->position;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
$LN4@FS_Write:

; 1896 : 
; 1897 : 	if( result < 0 )

	cmp	DWORD PTR _result$[ebp], 0
	jge	SHORT $LN5@FS_Write

; 1898 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FS_Write
$LN5@FS_Write:

; 1899 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN1@FS_Write:

; 1900 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Open
_TEXT	SEGMENT
_real_path$1 = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_filepath$ = 8						; size = 4
_mode$ = 12						; size = 4
_gamedironly$ = 16					; size = 4
_FS_Open PROC						; COMDAT

; 1826 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1220				; 000004c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1827 : 	// some stupid mappers used leading '/' or '\' in path to models or sounds
; 1828 : 	if( filepath[0] == '/' || filepath[0] == '\\' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filepath$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN3@FS_Open
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filepath$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN2@FS_Open
$LN3@FS_Open:

; 1829 : 		filepath++;

	mov	eax, DWORD PTR _filepath$[ebp]
	add	eax, 1
	mov	DWORD PTR _filepath$[ebp], eax
$LN2@FS_Open:

; 1830 : 
; 1831 : 	if( filepath[0] == '/' || filepath[0] == '\\' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filepath$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN5@FS_Open
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _filepath$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN4@FS_Open
$LN5@FS_Open:

; 1832 : 		filepath++;

	mov	eax, DWORD PTR _filepath$[ebp]
	add	eax, 1
	mov	DWORD PTR _filepath$[ebp], eax
$LN4@FS_Open:

; 1833 : 
; 1834 : 	if( FS_CheckNastyPath( filepath, false ))

	push	0
	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_FS_CheckNastyPath
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@FS_Open

; 1835 : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FS_Open
$LN6@FS_Open:

; 1836 : 
; 1837 : 	// if the file is opened in "write", "append", or "read/write" mode
; 1838 : 	if( mode[0] == 'w' || mode[0] == 'a'|| mode[0] == 'e' || Q_strchr( mode, '+' ))

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mode$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 119				; 00000077H
	je	SHORT $LN8@FS_Open
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mode$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 97					; 00000061H
	je	SHORT $LN8@FS_Open
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _mode$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN8@FS_Open
	push	43					; 0000002bH
	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	call	_Q_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@FS_Open
$LN8@FS_Open:

; 1839 : 	{
; 1840 : 		char	real_path[MAX_SYSPATH];
; 1841 : 
; 1842 : 		// open the file on disk directly
; 1843 : 		Q_sprintf( real_path, "%s/%s", fs_writedir, filepath );

	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	push	OFFSET _fs_writedir
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	lea	ecx, DWORD PTR _real_path$1[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 1844 : 		FS_CreatePath( real_path );// Create directories up to the file

	lea	eax, DWORD PTR _real_path$1[ebp]
	push	eax
	call	_FS_CreatePath
	add	esp, 4

; 1845 : 		return FS_SysOpen( real_path, mode );

	mov	eax, DWORD PTR _mode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _real_path$1[ebp]
	push	ecx
	call	_FS_SysOpen
	add	esp, 8
	jmp	SHORT $LN1@FS_Open
$LN7@FS_Open:

; 1846 : 	}
; 1847 : 	
; 1848 : 	// else, we look at the various search paths and open the file in read-only mode
; 1849 : 	return FS_OpenReadFile( filepath, mode, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filepath$[ebp]
	push	edx
	call	_FS_OpenReadFile
	add	esp, 12					; 0000000cH
$LN1@FS_Open:

; 1850 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Search
_TEXT	SEGMENT
tv130 = -1900						; size = 4
tv94 = -1900						; size = 4
tv92 = -1900						; size = 4
$T1 = -1896						; size = 4
_textlen$2 = -1636					; size = 4
_wadfolder$3 = -1632					; size = 256
_anywadname$4 = -1376					; size = 4
_type$5 = -1369						; size = 1
_temp2$6 = -1368					; size = 256
_wadname$7 = -1112					; size = 256
_wadpattern$8 = -856					; size = 256
_basepath$ = -600					; size = 4
_dirlist$ = -596					; size = 12
_resultlist$ = -584					; size = 12
_temp$ = -572						; size = 256
_netpath$ = -316					; size = 256
_separator$ = -60					; size = 4
_colon$ = -56						; size = 4
_backslash$ = -52					; size = 4
_slash$ = -48						; size = 4
_dirlistindex$ = -44					; size = 4
_resultlistindex$ = -40					; size = 4
_numchars$ = -36					; size = 4
_numfiles$ = -32					; size = 4
_basepathlength$ = -28					; size = 4
_i$ = -24						; size = 4
_wad$ = -20						; size = 4
_pak$ = -16						; size = 4
_searchpath$ = -12					; size = 4
_search$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_pattern$ = 8						; size = 4
_caseinsensitive$ = 12					; size = 4
_gamedironly$ = 16					; size = 4
_FS_Search PROC						; COMDAT

; 2564 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1900				; 0000076cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 2565 : 	search_t		*search = NULL;

	mov	DWORD PTR _search$[ebp], 0

; 2566 : 	searchpath_t	*searchpath;
; 2567 : 	pack_t		*pak;
; 2568 : 	wfile_t		*wad;
; 2569 : 	int		i, basepathlength, numfiles, numchars;
; 2570 : 	int		resultlistindex, dirlistindex;
; 2571 : 	const char	*slash, *backslash, *colon, *separator;
; 2572 : 	string		netpath, temp;
; 2573 : 	stringlist_t	resultlist;
; 2574 : 	stringlist_t	dirlist;
; 2575 : 	char		*basepath;
; 2576 : 
; 2577 : 	if( pattern[0] == '.' || pattern[0] == ':' || pattern[0] == '/' || pattern[0] == '\\' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pattern$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN34@FS_Search
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pattern$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN34@FS_Search
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pattern$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN34@FS_Search
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pattern$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN33@FS_Search
$LN34@FS_Search:

; 2578 : 		return NULL; // punctuation issues

	xor	eax, eax
	jmp	$LN61@FS_Search
$LN33@FS_Search:

; 2579 : 
; 2580 : 	stringlistinit( &resultlist );

	lea	eax, DWORD PTR _resultlist$[ebp]
	push	eax
	call	_stringlistinit
	add	esp, 4

; 2581 : 	stringlistinit( &dirlist );

	lea	eax, DWORD PTR _dirlist$[ebp]
	push	eax
	call	_stringlistinit
	add	esp, 4

; 2582 : 	slash = Q_strrchr( pattern, '/' );

	push	47					; 0000002fH
	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _slash$[ebp], eax

; 2583 : 	backslash = Q_strrchr( pattern, '\\' );

	push	92					; 0000005cH
	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 2584 : 	colon = Q_strrchr( pattern, ':' );

	push	58					; 0000003aH
	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 2585 : 	separator = max( slash, backslash );

	mov	eax, DWORD PTR _slash$[ebp]
	cmp	eax, DWORD PTR _backslash$[ebp]
	jbe	SHORT $LN62@FS_Search
	mov	ecx, DWORD PTR _slash$[ebp]
	mov	DWORD PTR tv92[ebp], ecx
	jmp	SHORT $LN63@FS_Search
$LN62@FS_Search:
	mov	edx, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR tv92[ebp], edx
$LN63@FS_Search:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR _separator$[ebp], eax

; 2586 : 	separator = max( separator, colon );

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _colon$[ebp]
	jbe	SHORT $LN64@FS_Search
	mov	ecx, DWORD PTR _separator$[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN65@FS_Search
$LN64@FS_Search:
	mov	edx, DWORD PTR _colon$[ebp]
	mov	DWORD PTR tv94[ebp], edx
$LN65@FS_Search:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR _separator$[ebp], eax

; 2587 : 	basepathlength = separator ? (separator + 1 - pattern) : 0;

	cmp	DWORD PTR _separator$[ebp], 0
	je	SHORT $LN66@FS_Search
	mov	eax, DWORD PTR _separator$[ebp]
	add	eax, 1
	sub	eax, DWORD PTR _pattern$[ebp]
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN67@FS_Search
$LN66@FS_Search:
	mov	DWORD PTR tv130[ebp], 0
$LN67@FS_Search:
	mov	ecx, DWORD PTR tv130[ebp]
	mov	DWORD PTR _basepathlength$[ebp], ecx

; 2588 : 	basepath = Mem_Calloc( fs_mempool, basepathlength + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Search@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _basepathlength$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _basepath$[ebp], eax

; 2589 : 	if( basepathlength ) memcpy( basepath, pattern, basepathlength );

	cmp	DWORD PTR _basepathlength$[ebp], 0
	je	SHORT $LN35@FS_Search
	mov	eax, DWORD PTR _basepathlength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	mov	edx, DWORD PTR _basepath$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN35@FS_Search:

; 2590 : 	basepath[basepathlength] = 0;

	mov	eax, DWORD PTR _basepath$[ebp]
	add	eax, DWORD PTR _basepathlength$[ebp]
	mov	BYTE PTR [eax], 0

; 2591 : 
; 2592 : 	// search through the path, one element at a time
; 2593 : 	for( searchpath = fs_searchpaths; searchpath; searchpath = searchpath->next )

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _searchpath$[ebp], eax
	jmp	SHORT $LN4@FS_Search
$LN2@FS_Search:
	mov	eax, DWORD PTR _searchpath$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _searchpath$[ebp], ecx
$LN4@FS_Search:
	cmp	DWORD PTR _searchpath$[ebp], 0
	je	$LN3@FS_Search

; 2594 : 	{
; 2595 : 		if( gamedironly && !FBitSet( searchpath->flags, FS_GAMEDIR_PATH ))

	cmp	DWORD PTR _gamedironly$[ebp], 0
	je	SHORT $LN36@FS_Search
	mov	eax, DWORD PTR _searchpath$[ebp]
	mov	ecx, DWORD PTR [eax+264]
	and	ecx, 4
	jne	SHORT $LN36@FS_Search

; 2596 : 			continue;

	jmp	SHORT $LN2@FS_Search
$LN36@FS_Search:

; 2597 : 
; 2598 : 		// is the element a pak file?
; 2599 : 		if( searchpath->pack )

	mov	eax, DWORD PTR _searchpath$[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	$LN37@FS_Search

; 2600 : 		{
; 2601 : 			// look through all the pak file elements
; 2602 : 			pak = searchpath->pack;

	mov	eax, DWORD PTR _searchpath$[ebp]
	mov	ecx, DWORD PTR [eax+256]
	mov	DWORD PTR _pak$[ebp], ecx

; 2603 : 			for( i = 0; i < pak->numfiles; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@FS_Search
$LN5@FS_Search:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@FS_Search:
	mov	eax, DWORD PTR _pak$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+260]
	jge	$LN6@FS_Search

; 2604 : 			{
; 2605 : 				Q_strncpy( temp, pak->files[i].name, sizeof( temp ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _pak$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	add	edx, eax
	push	edx
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@FS_Search:

; 2606 : 				while( temp[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _temp$[ebp+ecx]
	test	edx, edx
	je	$LN9@FS_Search

; 2607 : 				{
; 2608 : 					if( matchpattern( temp, (char *)pattern, true ))

	push	1
	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_matchpattern
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN39@FS_Search

; 2609 : 					{
; 2610 : 						for( resultlistindex = 0; resultlistindex < resultlist.numstrings; resultlistindex++ )

	mov	DWORD PTR _resultlistindex$[ebp], 0
	jmp	SHORT $LN12@FS_Search
$LN10@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultlistindex$[ebp], eax
$LN12@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jge	SHORT $LN11@FS_Search

; 2611 : 						{
; 2612 : 							if( !Q_strcmp( resultlist.strings[resultlistindex], temp ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resultlistindex$[ebp]
	mov	edx, DWORD PTR _resultlist$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN40@FS_Search

; 2613 : 								break;

	jmp	SHORT $LN11@FS_Search
$LN40@FS_Search:

; 2614 : 						}

	jmp	SHORT $LN10@FS_Search
$LN11@FS_Search:

; 2615 : 
; 2616 : 						if( resultlistindex == resultlist.numstrings )

	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jne	SHORT $LN39@FS_Search

; 2617 : 							stringlistappend( &resultlist, temp );

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _resultlist$[ebp]
	push	ecx
	call	_stringlistappend
	add	esp, 8
$LN39@FS_Search:

; 2618 : 					}
; 2619 : 
; 2620 : 					// strip off one path element at a time until empty
; 2621 : 					// this way directories are added to the listing if they match the pattern
; 2622 : 					slash = Q_strrchr( temp, '/' );

	push	47					; 0000002fH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _slash$[ebp], eax

; 2623 : 					backslash = Q_strrchr( temp, '\\' );

	push	92					; 0000005cH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 2624 : 					colon = Q_strrchr( temp, ':' );

	push	58					; 0000003aH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 2625 : 					separator = temp;

	lea	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _separator$[ebp], eax

; 2626 : 					if( separator < slash )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _slash$[ebp]
	jae	SHORT $LN42@FS_Search

; 2627 : 						separator = slash;

	mov	eax, DWORD PTR _slash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN42@FS_Search:

; 2628 : 					if( separator < backslash )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN43@FS_Search

; 2629 : 						separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN43@FS_Search:

; 2630 : 					if( separator < colon )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _colon$[ebp]
	jae	SHORT $LN44@FS_Search

; 2631 : 						separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN44@FS_Search:

; 2632 : 					*((char *)separator) = 0;

	mov	eax, DWORD PTR _separator$[ebp]
	mov	BYTE PTR [eax], 0

; 2633 : 				}

	jmp	$LN8@FS_Search
$LN9@FS_Search:

; 2634 : 			}

	jmp	$LN5@FS_Search
$LN6@FS_Search:

; 2635 : 		}

	jmp	$LN38@FS_Search
$LN37@FS_Search:

; 2636 : 		else if( searchpath->wad )

	mov	eax, DWORD PTR _searchpath$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	$LN45@FS_Search

; 2637 : 		{
; 2638 : 			string	wadpattern, wadname, temp2;
; 2639 : 			char	type = W_TypeFromExt( pattern );

	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	call	_W_TypeFromExt
	add	esp, 4
	mov	BYTE PTR _type$5[ebp], al

; 2640 : 			qboolean	anywadname = true;

	mov	DWORD PTR _anywadname$4[ebp], 1

; 2641 : 			string	wadfolder;
; 2642 : 
; 2643 : 			// quick reject by filetype
; 2644 : 			if( type == TYP_NONE ) continue;

	movsx	eax, BYTE PTR _type$5[ebp]
	test	eax, eax
	jne	SHORT $LN47@FS_Search
	jmp	$LN2@FS_Search
$LN47@FS_Search:

; 2645 : 			COM_ExtractFilePath( pattern, wadname );

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_COM_ExtractFilePath
	add	esp, 8

; 2646 : 			COM_FileBase( pattern, wadpattern );

	lea	eax, DWORD PTR _wadpattern$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _pattern$[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 2647 : 			wadfolder[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN68@FS_Search
	jmp	SHORT $LN69@FS_Search
$LN68@FS_Search:
	call	___report_rangecheckfailure
$LN69@FS_Search:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _wadfolder$3[ebp+edx], 0

; 2648 : 
; 2649 : 			if( Q_strlen( wadname ))

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	je	SHORT $LN48@FS_Search

; 2650 : 			{
; 2651 : 				COM_FileBase( wadname, wadname );

	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadname$7[ebp]
	push	ecx
	call	_COM_FileBase
	add	esp, 8

; 2652 : 				Q_strncpy( wadfolder, wadname, sizeof( wadfolder ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadfolder$3[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 2653 : 				COM_DefaultExtension( wadname, ".wad" );

	push	OFFSET ??_C@_04PJEAAOBG@?4wad@
	lea	eax, DWORD PTR _wadname$7[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 2654 : 				anywadname = false;

	mov	DWORD PTR _anywadname$4[ebp], 0
$LN48@FS_Search:

; 2655 : 			}
; 2656 : 
; 2657 : 			// make wadname from wad fullpath
; 2658 : 			COM_FileBase( searchpath->wad->filename, temp2 );

	lea	eax, DWORD PTR _temp2$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _searchpath$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	call	_COM_FileBase
	add	esp, 8

; 2659 : 			COM_DefaultExtension( temp2, ".wad" );

	push	OFFSET ??_C@_04PJEAAOBG@?4wad@
	lea	eax, DWORD PTR _temp2$6[ebp]
	push	eax
	call	_COM_DefaultExtension
	add	esp, 8

; 2660 : 
; 2661 : 			// quick reject by wadname
; 2662 : 			if( !anywadname && Q_stricmp( wadname, temp2 ))

	cmp	DWORD PTR _anywadname$4[ebp], 0
	jne	SHORT $LN49@FS_Search
	push	99999					; 0001869fH
	lea	eax, DWORD PTR _temp2$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadname$7[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN49@FS_Search

; 2663 : 				continue;

	jmp	$LN2@FS_Search
$LN49@FS_Search:

; 2664 : 
; 2665 : 			// look through all the wad file elements
; 2666 : 			wad = searchpath->wad;

	mov	eax, DWORD PTR _searchpath$[ebp]
	mov	ecx, DWORD PTR [eax+260]
	mov	DWORD PTR _wad$[ebp], ecx

; 2667 : 
; 2668 : 			for( i = 0; i < wad->numlumps; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@FS_Search
$LN13@FS_Search:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@FS_Search:
	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+264]
	jge	$LN14@FS_Search

; 2669 : 			{
; 2670 : 				// if type not matching, we already have no chance ...
; 2671 : 				if( type != TYP_ANY && wad->lumps[i].type != type )

	movsx	eax, BYTE PTR _type$5[ebp]
	cmp	eax, -1
	je	SHORT $LN50@FS_Search
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movsx	eax, BYTE PTR [edx+eax+12]
	movsx	ecx, BYTE PTR _type$5[ebp]
	cmp	eax, ecx
	je	SHORT $LN50@FS_Search

; 2672 : 					continue;

	jmp	SHORT $LN13@FS_Search
$LN50@FS_Search:

; 2673 : 
; 2674 : 				// build the lumpname with image suffix (if present)
; 2675 : 				Q_strncpy( temp, wad->lumps[i].name, sizeof( temp ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	lea	eax, DWORD PTR [edx+eax+16]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN16@FS_Search:

; 2676 : 
; 2677 : 				while( temp[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _temp$[ebp+ecx]
	test	edx, edx
	je	$LN17@FS_Search

; 2678 : 				{
; 2679 : 					if( matchpattern( temp, wadpattern, true ))

	push	1
	lea	eax, DWORD PTR _wadpattern$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_matchpattern
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN51@FS_Search

; 2680 : 					{
; 2681 : 						for( resultlistindex = 0; resultlistindex < resultlist.numstrings; resultlistindex++ )

	mov	DWORD PTR _resultlistindex$[ebp], 0
	jmp	SHORT $LN20@FS_Search
$LN18@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultlistindex$[ebp], eax
$LN20@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jge	SHORT $LN19@FS_Search

; 2682 : 						{
; 2683 : 							if( !Q_strcmp( resultlist.strings[resultlistindex], temp ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resultlistindex$[ebp]
	mov	edx, DWORD PTR _resultlist$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN52@FS_Search

; 2684 : 								break;

	jmp	SHORT $LN19@FS_Search
$LN52@FS_Search:

; 2685 : 						}

	jmp	SHORT $LN18@FS_Search
$LN19@FS_Search:

; 2686 : 
; 2687 : 						if( resultlistindex == resultlist.numstrings )

	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jne	SHORT $LN51@FS_Search

; 2688 : 						{
; 2689 : 							// build path: wadname/lumpname.ext
; 2690 : 							Q_snprintf( temp2, sizeof(temp2), "%s/%s", wadfolder, temp );

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wadfolder$3[ebp]
	push	ecx
	push	OFFSET ??_C@_05GFOLEBJA@?$CFs?1?$CFs@
	push	256					; 00000100H
	lea	edx, DWORD PTR _temp2$6[ebp]
	push	edx
	call	_Q_snprintf
	add	esp, 20					; 00000014H

; 2691 : 							COM_DefaultExtension( temp2, va(".%s", W_ExtFromType( wad->lumps[i].type )));

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _wad$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	movzx	eax, BYTE PTR [edx+eax+12]
	push	eax
	call	_W_ExtFromType
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_03KEMCFGNA@?4?$CFs@
	call	_va
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _temp2$6[ebp]
	push	ecx
	call	_COM_DefaultExtension
	add	esp, 8

; 2692 : 							stringlistappend( &resultlist, temp2 );

	lea	eax, DWORD PTR _temp2$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _resultlist$[ebp]
	push	ecx
	call	_stringlistappend
	add	esp, 8
$LN51@FS_Search:

; 2693 : 						}
; 2694 : 					}
; 2695 : 
; 2696 : 					// strip off one path element at a time until empty
; 2697 : 					// this way directories are added to the listing if they match the pattern
; 2698 : 					slash = Q_strrchr( temp, '/' );

	push	47					; 0000002fH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _slash$[ebp], eax

; 2699 : 					backslash = Q_strrchr( temp, '\\' );

	push	92					; 0000005cH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _backslash$[ebp], eax

; 2700 : 					colon = Q_strrchr( temp, ':' );

	push	58					; 0000003aH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_Q_strrchr
	add	esp, 8
	mov	DWORD PTR _colon$[ebp], eax

; 2701 : 					separator = temp;

	lea	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _separator$[ebp], eax

; 2702 : 					if( separator < slash )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _slash$[ebp]
	jae	SHORT $LN54@FS_Search

; 2703 : 						separator = slash;

	mov	eax, DWORD PTR _slash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN54@FS_Search:

; 2704 : 					if( separator < backslash )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _backslash$[ebp]
	jae	SHORT $LN55@FS_Search

; 2705 : 						separator = backslash;

	mov	eax, DWORD PTR _backslash$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN55@FS_Search:

; 2706 : 					if( separator < colon )

	mov	eax, DWORD PTR _separator$[ebp]
	cmp	eax, DWORD PTR _colon$[ebp]
	jae	SHORT $LN56@FS_Search

; 2707 : 						separator = colon;

	mov	eax, DWORD PTR _colon$[ebp]
	mov	DWORD PTR _separator$[ebp], eax
$LN56@FS_Search:

; 2708 : 					*((char *)separator) = 0;

	mov	eax, DWORD PTR _separator$[ebp]
	mov	BYTE PTR [eax], 0

; 2709 : 				}

	jmp	$LN16@FS_Search
$LN17@FS_Search:

; 2710 : 			}

	jmp	$LN13@FS_Search
$LN14@FS_Search:

; 2711 : 		}

	jmp	$LN38@FS_Search
$LN45@FS_Search:

; 2712 : 		else
; 2713 : 		{
; 2714 : 			// get a directory listing and look at each name
; 2715 : 			Q_sprintf( netpath, "%s%s", searchpath->filename, basepath );

	mov	eax, DWORD PTR _basepath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _searchpath$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	edx, DWORD PTR _netpath$[ebp]
	push	edx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 2716 : 			stringlistinit( &dirlist );

	lea	eax, DWORD PTR _dirlist$[ebp]
	push	eax
	call	_stringlistinit
	add	esp, 4

; 2717 : 			listdirectory( &dirlist, netpath, false );

	push	0
	lea	eax, DWORD PTR _netpath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dirlist$[ebp]
	push	ecx
	call	_listdirectory
	add	esp, 12					; 0000000cH

; 2718 : 
; 2719 : 			for( dirlistindex = 0; dirlistindex < dirlist.numstrings; dirlistindex++ )

	mov	DWORD PTR _dirlistindex$[ebp], 0
	jmp	SHORT $LN23@FS_Search
$LN21@FS_Search:
	mov	eax, DWORD PTR _dirlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _dirlistindex$[ebp], eax
$LN23@FS_Search:
	mov	eax, DWORD PTR _dirlistindex$[ebp]
	cmp	eax, DWORD PTR _dirlist$[ebp+4]
	jge	$LN22@FS_Search

; 2720 : 			{
; 2721 : 				Q_sprintf( temp, "%s%s", basepath, dirlist.strings[dirlistindex] );

	mov	eax, DWORD PTR _dirlistindex$[ebp]
	mov	ecx, DWORD PTR _dirlist$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _basepath$[ebp]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 2722 : 
; 2723 : 				if( matchpattern( temp, (char *)pattern, true ))

	push	1
	mov	eax, DWORD PTR _pattern$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_matchpattern
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN57@FS_Search

; 2724 : 				{
; 2725 : 					for( resultlistindex = 0; resultlistindex < resultlist.numstrings; resultlistindex++ )

	mov	DWORD PTR _resultlistindex$[ebp], 0
	jmp	SHORT $LN26@FS_Search
$LN24@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultlistindex$[ebp], eax
$LN26@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jge	SHORT $LN25@FS_Search

; 2726 : 					{
; 2727 : 						if( !Q_strcmp( resultlist.strings[resultlistindex], temp ))

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _resultlistindex$[ebp]
	mov	edx, DWORD PTR _resultlist$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_Q_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN58@FS_Search

; 2728 : 							break;

	jmp	SHORT $LN25@FS_Search
$LN58@FS_Search:

; 2729 : 					}

	jmp	SHORT $LN24@FS_Search
$LN25@FS_Search:

; 2730 : 
; 2731 : 					if( resultlistindex == resultlist.numstrings )

	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jne	SHORT $LN57@FS_Search

; 2732 : 						stringlistappend( &resultlist, temp );

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _resultlist$[ebp]
	push	ecx
	call	_stringlistappend
	add	esp, 8
$LN57@FS_Search:

; 2733 : 				}
; 2734 : 			}

	jmp	$LN21@FS_Search
$LN22@FS_Search:

; 2735 : 
; 2736 : 			stringlistfreecontents( &dirlist );

	lea	eax, DWORD PTR _dirlist$[ebp]
	push	eax
	call	_stringlistfreecontents
	add	esp, 4
$LN38@FS_Search:

; 2737 : 		}
; 2738 : 	}

	jmp	$LN2@FS_Search
$LN3@FS_Search:

; 2739 : 
; 2740 : 	if( resultlist.numstrings )

	cmp	DWORD PTR _resultlist$[ebp+4], 0
	je	$LN60@FS_Search

; 2741 : 	{
; 2742 : 		stringlistsort( &resultlist );

	lea	eax, DWORD PTR _resultlist$[ebp]
	push	eax
	call	_stringlistsort
	add	esp, 4

; 2743 : 		numfiles = resultlist.numstrings;

	mov	eax, DWORD PTR _resultlist$[ebp+4]
	mov	DWORD PTR _numfiles$[ebp], eax

; 2744 : 		numchars = 0;

	mov	DWORD PTR _numchars$[ebp], 0

; 2745 : 
; 2746 : 		for( resultlistindex = 0; resultlistindex < resultlist.numstrings; resultlistindex++ )

	mov	DWORD PTR _resultlistindex$[ebp], 0
	jmp	SHORT $LN29@FS_Search
$LN27@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultlistindex$[ebp], eax
$LN29@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jge	SHORT $LN28@FS_Search

; 2747 : 			numchars += (int)Q_strlen( resultlist.strings[resultlistindex]) + 1;

	mov	eax, DWORD PTR _resultlistindex$[ebp]
	mov	ecx, DWORD PTR _resultlist$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _numchars$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _numchars$[ebp], edx
	jmp	SHORT $LN27@FS_Search
$LN28@FS_Search:

; 2748 : 		search = Mem_Calloc( fs_mempool, sizeof(search_t) + numchars + numfiles * sizeof( char* ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Search@@9@9
	add	eax, 184				; 000000b8H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	mov	ecx, DWORD PTR _numfiles$[ebp]
	mov	edx, DWORD PTR _numchars$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+12]
	push	eax
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _search$[ebp], eax

; 2749 : 		search->filenames = (char **)((char *)search + sizeof( search_t ));

	mov	eax, DWORD PTR _search$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _search$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2750 : 		search->filenamesbuffer = (char *)((char *)search + sizeof( search_t ) + numfiles * sizeof( char* ));

	mov	eax, DWORD PTR _numfiles$[ebp]
	mov	ecx, DWORD PTR _search$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+12]
	mov	eax, DWORD PTR _search$[ebp]
	mov	DWORD PTR [eax+8], edx

; 2751 : 		search->numfilenames = (int)numfiles;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _numfiles$[ebp]
	mov	DWORD PTR [eax], ecx

; 2752 : 		numfiles = numchars = 0;

	mov	DWORD PTR _numchars$[ebp], 0
	mov	eax, DWORD PTR _numchars$[ebp]
	mov	DWORD PTR _numfiles$[ebp], eax

; 2753 : 
; 2754 : 		for( resultlistindex = 0; resultlistindex < resultlist.numstrings; resultlistindex++ )

	mov	DWORD PTR _resultlistindex$[ebp], 0
	jmp	SHORT $LN32@FS_Search
$LN30@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	add	eax, 1
	mov	DWORD PTR _resultlistindex$[ebp], eax
$LN32@FS_Search:
	mov	eax, DWORD PTR _resultlistindex$[ebp]
	cmp	eax, DWORD PTR _resultlist$[ebp+4]
	jge	SHORT $LN60@FS_Search

; 2755 : 		{
; 2756 : 			size_t	textlen;
; 2757 : 
; 2758 : 			search->filenames[numfiles] = search->filenamesbuffer + numchars;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _numchars$[ebp]
	mov	edx, DWORD PTR _search$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _numfiles$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 2759 : 			textlen = Q_strlen(resultlist.strings[resultlistindex]) + 1;

	mov	eax, DWORD PTR _resultlistindex$[ebp]
	mov	ecx, DWORD PTR _resultlist$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_Q_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _textlen$2[ebp], eax

; 2760 : 			memcpy( search->filenames[numfiles], resultlist.strings[resultlistindex], textlen );

	mov	eax, DWORD PTR _textlen$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _resultlistindex$[ebp]
	mov	edx, DWORD PTR _resultlist$[ebp+8]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _numfiles$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2761 : 			numfiles++;

	mov	eax, DWORD PTR _numfiles$[ebp]
	add	eax, 1
	mov	DWORD PTR _numfiles$[ebp], eax

; 2762 : 			numchars += (int)textlen;

	mov	eax, DWORD PTR _numchars$[ebp]
	add	eax, DWORD PTR _textlen$2[ebp]
	mov	DWORD PTR _numchars$[ebp], eax

; 2763 : 		}

	jmp	$LN30@FS_Search
$LN60@FS_Search:

; 2764 : 	}
; 2765 : 
; 2766 : 	stringlistfreecontents( &resultlist );

	lea	eax, DWORD PTR _resultlist$[ebp]
	push	eax
	call	_stringlistfreecontents
	add	esp, 4

; 2767 : 
; 2768 : 	Mem_Free( basepath );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Search@@9@9
	add	eax, 204				; 000000ccH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _basepath$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 2769 : 
; 2770 : 	return search;

	mov	eax, DWORD PTR _search$[ebp]
$LN61@FS_Search:

; 2771 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_WriteFile
_TEXT	SEGMENT
_file$ = -4						; size = 4
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_len$ = 16						; size = 4
_FS_WriteFile PROC					; COMDAT

; 2245 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2246 : 	file_t *file;
; 2247 : 
; 2248 : 	file = FS_Open( filename, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 2249 : 
; 2250 : 	if( !file )

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@FS_WriteFi

; 2251 : 	{
; 2252 : 		Con_DPrintf( S_ERROR "FS_WriteFile: failed on %s\n", filename );

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@GDMAKCLD@?$FO1Error?3?$FO7?5FS_WriteFile?3?5failed@
	call	_Con_DPrintf
	add	esp, 8

; 2253 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@FS_WriteFi
$LN2@FS_WriteFi:

; 2254 : 	}
; 2255 : 
; 2256 : 	FS_Write( file, data, len );

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 2257 : 	FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2258 : 
; 2259 : 	return true;

	mov	eax, 1
$LN1@FS_WriteFi:

; 2260 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_WriteFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_LoadFile
_TEXT	SEGMENT
_filesize$ = -12					; size = 4
_buf$ = -8						; size = 4
_file$ = -4						; size = 4
_path$ = 8						; size = 4
_filesizeptr$ = 12					; size = 4
_gamedironly$ = 16					; size = 4
_FS_LoadFile PROC					; COMDAT

; 2211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 2212 : 	file_t	*file;
; 2213 : 	byte	*buf = NULL;

	mov	DWORD PTR _buf$[ebp], 0

; 2214 : 	long	filesize = 0;

	mov	DWORD PTR _filesize$[ebp], 0

; 2215 : 
; 2216 : 	file = FS_Open( path, "rb", gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	push	OFFSET ??_C@_02JDPG@rb@
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _file$[ebp], eax

; 2217 : 
; 2218 : 	if( file )

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $LN2@FS_LoadFil

; 2219 : 	{
; 2220 : 		filesize = file->real_length;

	mov	eax, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _filesize$[ebp], ecx

; 2221 : 		buf = (byte *)Mem_Malloc( fs_mempool, filesize + 1 );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_LoadFile@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _filesize$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _fs_mempool
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _buf$[ebp], eax

; 2222 : 		buf[filesize] = '\0';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _filesize$[ebp]
	mov	BYTE PTR [eax], 0

; 2223 : 		FS_Read( file, buf, filesize );

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 2224 : 		FS_Close( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 2225 : 	}

	jmp	SHORT $LN3@FS_LoadFil
$LN2@FS_LoadFil:

; 2226 : 	else
; 2227 : 	{
; 2228 : 		buf = W_LoadFile( path, &filesize, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	call	_W_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _buf$[ebp], eax
$LN3@FS_LoadFil:

; 2229 : 	}
; 2230 : 
; 2231 : 	if( filesizeptr )

	cmp	DWORD PTR _filesizeptr$[ebp], 0
	je	SHORT $LN4@FS_LoadFil

; 2232 : 		*filesizeptr = filesize;

	mov	eax, DWORD PTR _filesizeptr$[ebp]
	mov	ecx, DWORD PTR _filesize$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@FS_LoadFil:

; 2233 : 
; 2234 : 	return buf;

	mov	eax, DWORD PTR _buf$[ebp]

; 2235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _W_Close
_TEXT	SEGMENT
_wad$ = 8						; size = 4
_W_Close PROC						; COMDAT

; 3112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3113 : 	if( !wad ) return;

	cmp	DWORD PTR _wad$[ebp], 0
	jne	SHORT $LN2@W_Close
	jmp	SHORT $LN1@W_Close
$LN2@W_Close:

; 3114 : 
; 3115 : 	Mem_FreePool( &wad->mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Close@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _wad$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 3116 : 	if( wad->handle != NULL )

	mov	eax, DWORD PTR _wad$[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN3@W_Close

; 3117 : 		FS_Close( wad->handle );	

	mov	eax, DWORD PTR _wad$[ebp]
	mov	ecx, DWORD PTR [eax+268]
	push	ecx
	call	_FS_Close
	add	esp, 4
$LN3@W_Close:

; 3118 : 	Mem_Free( wad ); // free himself

	mov	eax, DWORD PTR ?__LINE__Var@?0??W_Close@@9@9
	add	eax, 6
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _wad$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN1@W_Close:

; 3119 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_W_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_GetDiskPath
_TEXT	SEGMENT
_search$ = -8						; size = 4
_index$ = -4						; size = 4
_name$ = 8						; size = 4
_gamedironly$ = 12					; size = 4
_FS_GetDiskPath PROC					; COMDAT

; 2292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 2293 : 	int		index;
; 2294 : 	searchpath_t	*search;
; 2295 : 
; 2296 : 	search = FS_FindFile( name, &index, gamedironly );

	mov	eax, DWORD PTR _gamedironly$[ebp]
	push	eax
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_FS_FindFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _search$[ebp], eax

; 2297 : 
; 2298 : 	if( search )

	cmp	DWORD PTR _search$[ebp], 0
	je	SHORT $LN2@FS_GetDisk

; 2299 : 	{
; 2300 : 		if( index != -1 ) // file in pack or wad

	cmp	DWORD PTR _index$[ebp], -1
	je	SHORT $LN3@FS_GetDisk

; 2301 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@FS_GetDisk
$LN3@FS_GetDisk:

; 2302 : 		return va( "%s%s", search->filename, name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	call	_va
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@FS_GetDisk
$LN2@FS_GetDisk:

; 2303 : 	}
; 2304 : 
; 2305 : 	return NULL;

	xor	eax, eax
$LN1@FS_GetDisk:

; 2306 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_GetDiskPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_LoadGameInfo
_TEXT	SEGMENT
_i$ = -4						; size = 4
_rootfolder$ = 8					; size = 4
_FS_LoadGameInfo PROC					; COMDAT

; 1340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1341 : 	int	i;
; 1342 : 
; 1343 : 	// lock uplevel of gamedir for read\write
; 1344 : 	fs_ext_path = false;

	mov	DWORD PTR _fs_ext_path, 0

; 1345 : 
; 1346 : 	if( rootfolder ) Q_strcpy( fs_gamedir, rootfolder );

	cmp	DWORD PTR _rootfolder$[ebp], 0
	je	SHORT $LN5@FS_LoadGam
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _rootfolder$[ebp]
	push	eax
	push	OFFSET _fs_gamedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN5@FS_LoadGam:

; 1347 : 	Con_Reportf( "FS_LoadGameInfo( %s )\n", fs_gamedir );

	push	OFFSET _fs_gamedir
	push	OFFSET ??_C@_0BH@JLKJEDOD@FS_LoadGameInfo?$CI?5?$CFs?5?$CJ?6@
	call	_Con_Reportf
	add	esp, 8

; 1348 : 
; 1349 : 	// clear any old pathes
; 1350 : 	FS_ClearSearchPath();

	call	_FS_ClearSearchPath

; 1351 : 
; 1352 : 	// validate gamedir
; 1353 : 	for( i = 0; i < SI.numgames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_LoadGam
$LN2@FS_LoadGam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_LoadGam:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SI+2820
	jge	SHORT $LN3@FS_LoadGam

; 1354 : 	{
; 1355 : 		if( !Q_stricmp( SI.games[i]->gamefolder, fs_gamedir ))

	push	99999					; 0001869fH
	push	OFFSET _fs_gamedir
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SI[eax*4+772]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@FS_LoadGam

; 1356 : 			break;

	jmp	SHORT $LN3@FS_LoadGam
$LN6@FS_LoadGam:

; 1357 : 	}

	jmp	SHORT $LN2@FS_LoadGam
$LN3@FS_LoadGam:

; 1358 : 
; 1359 : 	if( i == SI.numgames )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SI+2820
	jne	SHORT $LN7@FS_LoadGam

; 1360 : 		Sys_Error( "Couldn't find game directory '%s'\n", fs_gamedir );

	push	OFFSET _fs_gamedir
	push	OFFSET ??_C@_0CD@LMLILLCA@Couldn?8t?5find?5game?5directory?5?8?$CF@
	call	_Sys_Error
	add	esp, 8
$LN7@FS_LoadGam:

; 1361 : 
; 1362 : 	SI.GameInfo = SI.games[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _SI[eax*4+772]
	mov	DWORD PTR _SI+768, ecx

; 1363 : 	FS_Rescan(); // create new filesystem

	call	_FS_Rescan

; 1364 : 
; 1365 : 	Image_CheckPaletteQ1 ();

	call	_Image_CheckPaletteQ1

; 1366 : 	Host_InitDecals ();	// reload decals

	call	_Host_InitDecals

; 1367 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_LoadGameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AddGameHierarchy
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_flags$ = 12						; size = 4
_FS_AddGameHierarchy PROC				; COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 663  : 	// Add the common game directory
; 664  : 	if( COM_CheckString( dir ))

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@FS_AddGame

; 665  : 		FS_AddGameDirectory( va( "%s/", dir ), flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	push	OFFSET ??_C@_03NPMJBIL@?$CFs?1@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_AddGameDirectory
	add	esp, 8
$LN1@FS_AddGame:

; 666  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddGameHierarchy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AddGameDirectory
_TEXT	SEGMENT
_i$ = -280						; size = 4
_fullpath$ = -276					; size = 256
_search$ = -20						; size = 4
_list$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_dir$ = 8						; size = 4
_flags$ = 12						; size = 4
_FS_AddGameDirectory PROC				; COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 610  : 	stringlist_t	list;
; 611  : 	searchpath_t	*search;
; 612  : 	string		fullpath;
; 613  : 	int		i;
; 614  : 
; 615  : 	if( !FBitSet( flags, FS_NOWRITE_PATH ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	jne	SHORT $LN8@FS_AddGame

; 616  : 		Q_strncpy( fs_writedir, dir, sizeof( fs_writedir ));

	push	1024					; 00000400H
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	push	OFFSET _fs_writedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@FS_AddGame:

; 617  : 
; 618  : 	stringlistinit( &list );

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_stringlistinit
	add	esp, 4

; 619  : 	listdirectory( &list, dir, true );

	push	1
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	lea	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_listdirectory
	add	esp, 12					; 0000000cH

; 620  : 	stringlistsort( &list );

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_stringlistsort
	add	esp, 4

; 621  : 
; 622  : 	// add any PAK package in the directory
; 623  : 	for( i = 0; i < list.numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_AddGame
$LN2@FS_AddGame:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_AddGame:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _list$[ebp+4]
	jge	SHORT $LN3@FS_AddGame

; 624  : 	{
; 625  : 		if( !Q_stricmp( COM_FileExtension( list.strings[i] ), "pak" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03HKJIJDAE@pak@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _list$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@FS_AddGame

; 626  : 		{
; 627  : 			Q_sprintf( fullpath, "%s%s", dir, list.strings[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _list$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 628  : 			FS_AddPak_Fullpath( fullpath, NULL, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_FS_AddPak_Fullpath
	add	esp, 12					; 0000000cH
$LN9@FS_AddGame:

; 629  : 		}
; 630  : 	}

	jmp	$LN2@FS_AddGame
$LN3@FS_AddGame:

; 631  : 
; 632  : 	FS_AllowDirectPaths( true );

	push	1
	call	_FS_AllowDirectPaths
	add	esp, 4

; 633  : 
; 634  : 	// add any WAD package in the directory
; 635  : 	for( i = 0; i < list.numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@FS_AddGame
$LN5@FS_AddGame:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@FS_AddGame:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _list$[ebp+4]
	jge	SHORT $LN6@FS_AddGame

; 636  : 	{
; 637  : 		if( !Q_stricmp( COM_FileExtension( list.strings[i] ), "wad" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03GANHLHHC@wad@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _list$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_COM_FileExtension
	add	esp, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@FS_AddGame

; 638  : 		{
; 639  : 			Q_sprintf( fullpath, "%s%s", dir, list.strings[i] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _list$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	push	OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs@
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 16					; 00000010H

; 640  : 			FS_AddWad_Fullpath( fullpath, NULL, flags );

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	_FS_AddWad_Fullpath
	add	esp, 12					; 0000000cH
$LN10@FS_AddGame:

; 641  : 		}
; 642  : 	}

	jmp	$LN5@FS_AddGame
$LN6@FS_AddGame:

; 643  : 
; 644  : 	stringlistfreecontents( &list );

	lea	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_stringlistfreecontents
	add	esp, 4

; 645  : 	FS_AllowDirectPaths( false );

	push	0
	call	_FS_AllowDirectPaths
	add	esp, 4

; 646  : 
; 647  : 	// add the directory to the search path
; 648  : 	// (unpacked files have the priority over packed files)
; 649  : 	search = (searchpath_t *)Mem_Calloc( fs_mempool, sizeof( searchpath_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_AddGameDirectory@@9@9
	add	eax, 40					; 00000028H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	272					; 00000110H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _search$[ebp], eax

; 650  : 	Q_strncpy( search->filename, dir, sizeof ( search->filename ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _search$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 651  : 	search->next = fs_searchpaths;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _fs_searchpaths
	mov	DWORD PTR [eax+268], ecx

; 652  : 	search->flags = flags;

	mov	eax, DWORD PTR _search$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+264], ecx

; 653  : 	fs_searchpaths = search;

	mov	eax, DWORD PTR _search$[ebp]
	mov	DWORD PTR _fs_searchpaths, eax

; 654  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AddGameDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_AllowDirectPaths
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_FS_AllowDirectPaths PROC				; COMDAT

; 1446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1447 : 	fs_ext_path = enable;

	mov	eax, DWORD PTR _enable$[ebp]
	mov	DWORD PTR _fs_ext_path, eax

; 1448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_AllowDirectPaths ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_ClearSearchPath
_TEXT	SEGMENT
_search$1 = -4						; size = 4
_FS_ClearSearchPath PROC				; COMDAT

; 674  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
$LN2@FS_ClearSe:

; 675  : 	while( fs_searchpaths )

	cmp	DWORD PTR _fs_searchpaths, 0
	je	$LN1@FS_ClearSe

; 676  : 	{
; 677  : 		searchpath_t	*search = fs_searchpaths;

	mov	eax, DWORD PTR _fs_searchpaths
	mov	DWORD PTR _search$1[ebp], eax

; 678  : 
; 679  : 		if( !search ) break;

	cmp	DWORD PTR _search$1[ebp], 0
	jne	SHORT $LN4@FS_ClearSe
	jmp	$LN1@FS_ClearSe
$LN4@FS_ClearSe:

; 680  : 
; 681  : 		if( FBitSet( search->flags, FS_STATIC_PATH ))

	mov	eax, DWORD PTR _search$1[ebp]
	mov	ecx, DWORD PTR [eax+264]
	and	ecx, 1
	je	SHORT $LN5@FS_ClearSe

; 682  : 		{
; 683  : 			// skip read-only pathes
; 684  : 			if( search->next )

	mov	eax, DWORD PTR _search$1[ebp]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $LN7@FS_ClearSe

; 685  : 				fs_searchpaths = search->next->next;

	mov	eax, DWORD PTR _search$1[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	edx, DWORD PTR [ecx+268]
	mov	DWORD PTR _fs_searchpaths, edx
	jmp	SHORT $LN8@FS_ClearSe
$LN7@FS_ClearSe:

; 686  : 			else break;

	jmp	$LN1@FS_ClearSe
$LN8@FS_ClearSe:

; 687  : 		}

	jmp	SHORT $LN6@FS_ClearSe
$LN5@FS_ClearSe:

; 688  : 		else fs_searchpaths = search->next;

	mov	eax, DWORD PTR _search$1[ebp]
	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR _fs_searchpaths, ecx
$LN6@FS_ClearSe:

; 689  : 
; 690  : 		if( search->pack )

	mov	eax, DWORD PTR _search$1[ebp]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $LN9@FS_ClearSe

; 691  : 		{
; 692  : 			if( search->pack->files ) 

	mov	eax, DWORD PTR _search$1[ebp]
	mov	ecx, DWORD PTR [eax+256]
	cmp	DWORD PTR [ecx+272], 0
	je	SHORT $LN10@FS_ClearSe

; 693  : 				Mem_Free( search->pack->files );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_ClearSearchPath@@9@9
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _search$1[ebp]
	mov	edx, DWORD PTR [ecx+256]
	mov	eax, DWORD PTR [edx+272]
	push	eax
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN10@FS_ClearSe:

; 694  : 			Mem_Free( search->pack );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_ClearSearchPath@@9@9
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _search$1[ebp]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN9@FS_ClearSe:

; 695  : 		}
; 696  : 
; 697  : 		if( search->wad )

	mov	eax, DWORD PTR _search$1[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN11@FS_ClearSe

; 698  : 		{
; 699  : 			W_Close( search->wad );

	mov	eax, DWORD PTR _search$1[ebp]
	mov	ecx, DWORD PTR [eax+260]
	push	ecx
	call	_W_Close
	add	esp, 4
$LN11@FS_ClearSe:

; 700  : 		}
; 701  : 
; 702  : 		Mem_Free( search );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_ClearSearchPath@@9@9
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _search$1[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 703  : 	}

	jmp	$LN2@FS_ClearSe
$LN1@FS_ClearSe:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_ClearSearchPath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Shutdown
_TEXT	SEGMENT
_i$ = -4						; size = 4
_FS_Shutdown PROC					; COMDAT

; 1456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1457 : 	int	i;
; 1458 : 
; 1459 : 	// release gamedirs
; 1460 : 	for( i = 0; i < SI.numgames; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_Shutdow
$LN2@FS_Shutdow:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_Shutdow:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _SI+2820
	jge	SHORT $LN3@FS_Shutdow

; 1461 : 		if( SI.games[i] ) Mem_Free( SI.games[i] );

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _SI[eax*4+772], 0
	je	SHORT $LN5@FS_Shutdow
	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Shutdown@@9@9
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _SI[ecx*4+772]
	push	edx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN5@FS_Shutdow:
	jmp	SHORT $LN2@FS_Shutdow
$LN3@FS_Shutdow:

; 1462 : 
; 1463 : 	memset( &SI, 0, sizeof( sysinfo_t ));

	push	2824					; 00000b08H
	push	0
	push	OFFSET _SI
	call	_memset
	add	esp, 12					; 0000000cH

; 1464 : 
; 1465 : 	FS_ClearSearchPath(); // release all wad files too

	call	_FS_ClearSearchPath

; 1466 : 	Mem_FreePool( &fs_mempool );

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Shutdown@@9@9
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET _fs_mempool
	call	__Mem_FreePool
	add	esp, 12					; 0000000cH

; 1467 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Rescan
_TEXT	SEGMENT
_FS_Rescan PROC						; COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 756  : 	Con_Reportf( "FS_Rescan( %s )\n", GI->title );

	mov	eax, DWORD PTR _SI+768
	add	eax, 384				; 00000180H
	push	eax
	push	OFFSET ??_C@_0BB@HDEBADIB@FS_Rescan?$CI?5?$CFs?5?$CJ?6@
	call	_Con_Reportf
	add	esp, 8

; 757  : 
; 758  : 	FS_ClearSearchPath();

	call	_FS_ClearSearchPath

; 759  : 
; 760  : 	if( Q_stricmp( GI->basedir, GI->gamedir ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@FS_Rescan

; 761  : 		FS_AddGameHierarchy( GI->basedir, 0 );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 64					; 00000040H
	push	eax
	call	_FS_AddGameHierarchy
	add	esp, 8
$LN2@FS_Rescan:

; 762  : 	if( Q_stricmp( GI->basedir, GI->falldir ) && Q_stricmp( GI->gamedir, GI->falldir ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _SI+768
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@FS_Rescan
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _SI+768
	add	eax, 192				; 000000c0H
	push	eax
	mov	ecx, DWORD PTR _SI+768
	add	ecx, 128				; 00000080H
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@FS_Rescan

; 763  : 		FS_AddGameHierarchy( GI->falldir, 0 );

	push	0
	mov	eax, DWORD PTR _SI+768
	add	eax, 192				; 000000c0H
	push	eax
	call	_FS_AddGameHierarchy
	add	esp, 8
$LN3@FS_Rescan:

; 764  : 	FS_AddGameHierarchy( GI->gamedir, FS_GAMEDIR_PATH );

	push	4
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	call	_FS_AddGameHierarchy
	add	esp, 8

; 765  : 
; 766  : 	if( FS_FileExists( va( "%s.rc", SI.basedirName ), false ))

	push	0
	push	OFFSET _SI+512
	push	OFFSET ??_C@_05POGGAMJB@?$CFs?4rc@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@FS_Rescan

; 767  : 		Q_strncpy( SI.rcName, SI.basedirName, sizeof( SI.rcName ));	// e.g. valve.rc

	push	256					; 00000100H
	push	OFFSET _SI+512
	push	OFFSET _SI+256
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@FS_Rescan
$LN4@FS_Rescan:

; 768  : 	else Q_strncpy( SI.rcName, SI.exeName, sizeof( SI.rcName ));	// e.g. quake.rc

	push	256					; 00000100H
	push	OFFSET _SI
	push	OFFSET _SI+256
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@FS_Rescan:

; 769  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Rescan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\filesystem.c
;	COMDAT _FS_Init
_TEXT	SEGMENT
_i$ = -24						; size = 4
_hasGameDir$ = -20					; size = 4
_hasBaseDir$ = -16					; size = 4
_dirs$ = -12						; size = 12
_FS_Init PROC						; COMDAT

; 1375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 1376 : 	stringlist_t	dirs;
; 1377 : 	qboolean		hasBaseDir = false;

	mov	DWORD PTR _hasBaseDir$[ebp], 0

; 1378 : 	qboolean		hasGameDir = false;

	mov	DWORD PTR _hasGameDir$[ebp], 0

; 1379 : 	int		i;
; 1380 : 	
; 1381 : 	FS_InitMemory();

	call	_FS_InitMemory

; 1382 : 
; 1383 : 	Cmd_AddCommand( "fs_rescan", FS_Rescan_f, "rescan filesystem search pathes" );

	push	OFFSET ??_C@_0CA@EIAOIINE@rescan?5filesystem?5search?5pathes@
	push	OFFSET _FS_Rescan_f
	push	OFFSET ??_C@_09IDOAIHOD@fs_rescan@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1384 : 	Cmd_AddCommand( "fs_path", FS_Path_f, "show filesystem search pathes" );

	push	OFFSET ??_C@_0BO@PHBKKHIG@show?5filesystem?5search?5pathes@
	push	OFFSET _FS_Path_f
	push	OFFSET ??_C@_07CIJFKILE@fs_path@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1385 : 	Cmd_AddCommand( "fs_clearpaths", FS_ClearPaths_f, "clear filesystem search pathes" );

	push	OFFSET ??_C@_0BP@OFHIELJN@clear?5filesystem?5search?5pathes@
	push	OFFSET _FS_ClearPaths_f
	push	OFFSET ??_C@_0O@GJNOPCMB@fs_clearpaths@
	call	_Cmd_AddCommand
	add	esp, 12					; 0000000cH

; 1386 : 
; 1387 : 	// ignore commandlineoption "-game" for other stuff
; 1388 : 	stringlistinit( &dirs );

	lea	eax, DWORD PTR _dirs$[ebp]
	push	eax
	call	_stringlistinit
	add	esp, 4

; 1389 : 	listdirectory( &dirs, "./", true );

	push	1
	push	OFFSET ??_C@_02CAHBHFGK@?4?1@
	lea	eax, DWORD PTR _dirs$[ebp]
	push	eax
	call	_listdirectory
	add	esp, 12					; 0000000cH

; 1390 : 	stringlistsort( &dirs );

	lea	eax, DWORD PTR _dirs$[ebp]
	push	eax
	call	_stringlistsort
	add	esp, 4

; 1391 : 	SI.numgames = 0;

	mov	DWORD PTR _SI+2820, 0

; 1392 : 
; 1393 : 	Q_strncpy( fs_basedir, SI.basedirName, sizeof( fs_basedir )); // default dir

	push	1024					; 00000400H
	push	OFFSET _SI+512
	push	OFFSET _fs_basedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1394 : 	
; 1395 : 	if( !Sys_GetParmFromCmdLine( "-game", fs_gamedir ))

	push	1024					; 00000400H
	push	OFFSET _fs_gamedir
	push	OFFSET ??_C@_05FACLEBO@?9game@
	call	__Sys_GetParmFromCmdLine
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@FS_Init

; 1396 : 		Q_strncpy( fs_gamedir, fs_basedir, sizeof( fs_gamedir )); // gamedir == basedir

	push	1024					; 00000400H
	push	OFFSET _fs_basedir
	push	OFFSET _fs_gamedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN8@FS_Init:

; 1397 : 
; 1398 : 	if( FS_CheckNastyPath( fs_basedir, true ))

	push	1
	push	OFFSET _fs_basedir
	call	_FS_CheckNastyPath
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@FS_Init

; 1399 : 	{
; 1400 : 		// this is completely fatal...
; 1401 : 		Sys_Error( "invalid base directory \"%s\"\n", fs_basedir );

	push	OFFSET _fs_basedir
	push	OFFSET ??_C@_0BN@NAFMHBKB@invalid?5base?5directory?5?$CC?$CFs?$CC?6@
	call	_Sys_Error
	add	esp, 8
$LN9@FS_Init:

; 1402 : 	}
; 1403 : 
; 1404 : 	if( FS_CheckNastyPath( fs_gamedir, true ))

	push	1
	push	OFFSET _fs_gamedir
	call	_FS_CheckNastyPath
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@FS_Init

; 1405 : 	{
; 1406 : 		Con_Printf( S_ERROR "invalid game directory \"%s\"\n", fs_gamedir );

	push	OFFSET _fs_gamedir
	push	OFFSET ??_C@_0CI@LFHJFHBE@?$FO1Error?3?$FO7?5invalid?5game?5directo@
	call	_Con_Printf
	add	esp, 8

; 1407 : 		Q_strncpy( fs_gamedir, fs_basedir, sizeof( fs_gamedir )); // default dir

	push	1024					; 00000400H
	push	OFFSET _fs_basedir
	push	OFFSET _fs_gamedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN10@FS_Init:

; 1408 : 	}
; 1409 : 
; 1410 : 	// validate directories
; 1411 : 	for( i = 0; i < dirs.numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@FS_Init
$LN2@FS_Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@FS_Init:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dirs$[ebp+4]
	jge	SHORT $LN3@FS_Init

; 1412 : 	{
; 1413 : 		if( !Q_stricmp( fs_basedir, dirs.strings[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dirs$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET _fs_basedir
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@FS_Init

; 1414 : 			hasBaseDir = true;

	mov	DWORD PTR _hasBaseDir$[ebp], 1
$LN11@FS_Init:

; 1415 : 
; 1416 : 		if( !Q_stricmp( fs_gamedir, dirs.strings[i] ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dirs$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET _fs_gamedir
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@FS_Init

; 1417 : 			hasGameDir = true;

	mov	DWORD PTR _hasGameDir$[ebp], 1
$LN12@FS_Init:

; 1418 : 	}

	jmp	SHORT $LN2@FS_Init
$LN3@FS_Init:

; 1419 : 
; 1420 : 	if( !hasGameDir )

	cmp	DWORD PTR _hasGameDir$[ebp], 0
	jne	SHORT $LN13@FS_Init

; 1421 : 	{
; 1422 : 		Con_Printf( S_ERROR "game directory \"%s\" not exist\n", fs_gamedir );

	push	OFFSET _fs_gamedir
	push	OFFSET ??_C@_0CK@JLLJKMCN@?$FO1Error?3?$FO7?5game?5directory?5?$CC?$CFs?$CC?5@
	call	_Con_Printf
	add	esp, 8

; 1423 : 		if( hasBaseDir ) Q_strncpy( fs_gamedir, fs_basedir, sizeof( fs_gamedir ));

	cmp	DWORD PTR _hasBaseDir$[ebp], 0
	je	SHORT $LN13@FS_Init
	push	1024					; 00000400H
	push	OFFSET _fs_basedir
	push	OFFSET _fs_gamedir
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN13@FS_Init:

; 1424 : 	}
; 1425 : 
; 1426 : 	// build list of game directories here
; 1427 : 	FS_AddGameDirectory( "./", 0 );

	push	0
	push	OFFSET ??_C@_02CAHBHFGK@?4?1@
	call	_FS_AddGameDirectory
	add	esp, 8

; 1428 : 
; 1429 : 	for( i = 0; i < dirs.numstrings; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@FS_Init
$LN5@FS_Init:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@FS_Init:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dirs$[ebp+4]
	jge	$LN6@FS_Init

; 1430 : 	{
; 1431 : 		if( !FS_SysFolderExists( dirs.strings[i] ) || ( !Q_stricmp( dirs.strings[i], ".." ) && !fs_ext_path ))

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dirs$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_FS_SysFolderExists
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@FS_Init
	push	99999					; 0001869fH
	push	OFFSET ??_C@_02DJGKEECL@?4?4@
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _dirs$[ebp+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@FS_Init
	cmp	DWORD PTR _fs_ext_path, 0
	jne	SHORT $LN15@FS_Init
$LN16@FS_Init:

; 1432 : 			continue;

	jmp	SHORT $LN5@FS_Init
$LN15@FS_Init:

; 1433 : 
; 1434 : 		if( SI.games[SI.numgames] == NULL )

	mov	eax, DWORD PTR _SI+2820
	cmp	DWORD PTR _SI[eax*4+772], 0
	jne	SHORT $LN17@FS_Init

; 1435 : 			SI.games[SI.numgames] = (gameinfo_t *)Mem_Calloc( fs_mempool, sizeof( gameinfo_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??FS_Init@@9@9
	add	eax, 60					; 0000003cH
	push	eax
	push	OFFSET ??_C@_0DH@LPKLIACE@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	1672					; 00000688H
	mov	ecx, DWORD PTR _fs_mempool
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _SI+2820
	mov	DWORD PTR _SI[edx*4+772], eax
$LN17@FS_Init:

; 1436 : 
; 1437 : 		if( FS_ParseGameInfo( dirs.strings[i], SI.games[SI.numgames] ))

	mov	eax, DWORD PTR _SI+2820
	mov	ecx, DWORD PTR _SI[eax*4+772]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _dirs$[ebp+8]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_FS_ParseGameInfo
	add	esp, 8
	test	eax, eax
	je	SHORT $LN18@FS_Init

; 1438 : 			SI.numgames++; // added

	mov	eax, DWORD PTR _SI+2820
	add	eax, 1
	mov	DWORD PTR _SI+2820, eax
$LN18@FS_Init:

; 1439 : 	}

	jmp	$LN5@FS_Init
$LN6@FS_Init:

; 1440 : 
; 1441 : 	stringlistfreecontents( &dirs );

	lea	eax, DWORD PTR _dirs$[ebp]
	push	eax
	call	_stringlistfreecontents
	add	esp, 4

; 1442 : 	Con_Reportf( "FS_Init: done\n" );

	push	OFFSET ??_C@_0P@KGNFGICB@FS_Init?3?5done?6@
	call	_Con_Reportf
	add	esp, 4

; 1443 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_FS_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\sys\stat.h
;	COMDAT _stat
_TEXT	SEGMENT
__FileName$ = 8						; size = 4
__Stat$ = 12						; size = 4
_stat	PROC						; COMDAT

; 239  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 240  :             _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
; 241  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

	mov	eax, DWORD PTR __Stat$[ebp]
	push	eax
	mov	ecx, DWORD PTR __FileName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stat64i32
	add	esp, 8

; 242  :         }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_stat	ENDP
_TEXT	ENDS
END
