; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\s_vox.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_g_Sentences:QWORD:01000H
_DATA	ENDS
PUBLIC	_VOX_LoadWord
PUBLIC	_VOX_FreeWord
PUBLIC	_VOX_Init
PUBLIC	_VOX_Shutdown
PUBLIC	_VOX_SetChanVol
PUBLIC	_VOX_LoadSound
PUBLIC	_VOX_ModifyPitch
PUBLIC	_VOX_MixDataToDevice
PUBLIC	_VOX_LookupString
PUBLIC	_VOX_ParseString
PUBLIC	_VOX_GetVolumeScale
PUBLIC	_VOX_ParseWordParams
PUBLIC	_VOX_LoadFirstWord
PUBLIC	_VOX_ParseLineCommands
PUBLIC	_VOX_ReadSentenceFile
PUBLIC	??_C@_04GEPEPLFN@vox?1@				; `string'
PUBLIC	??_C@_0CP@ICFMONLG@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5no?5su@ ; `string'
PUBLIC	??_C@_0DD@FJOGIFJO@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5sente@ ; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav@				; `string'
PUBLIC	??_C@_0BP@ILKADKEE@?$FO1Error?3?$FO7?5sentence?5too?5long?$CB?6@ ; `string'
PUBLIC	??_C@_03BKCJCHLK@len@				; `string'
PUBLIC	??_C@_0DD@PLEHFDFD@?$FO1Error?3?$FO7?5VOX_Init?3?5too?5many?5s@ ; `string'
PUBLIC	??_C@_0BE@LOFIHEDB@sound?1sentences?4txt@	; `string'
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f800000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_Q_strlen:PROC
EXTRN	_Q_tolower:PROC
EXTRN	_Q_strncat:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_isdigit:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_FreeSound:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_S_LoadSound:PROC
EXTRN	_S_MixDataToDevice:PROC
EXTRN	_S_FindName:PROC
EXTRN	_S_SetSampleStart:PROC
EXTRN	_S_SetSampleEnd:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_g_numSentences DD 01H DUP (?)
_rgpparseword DD 040H DUP (?)
?voxwordDefault@?1??VOX_ParseWordParams@@9@9 DB 024H DUP (?) ; `VOX_ParseWordParams'::`2'::voxwordDefault
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT ??_C@_0BE@LOFIHEDB@sound?1sentences?4txt@
CONST	SEGMENT
??_C@_0BE@LOFIHEDB@sound?1sentences?4txt@ DB 'sound/sentences.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@PLEHFDFD@?$FO1Error?3?$FO7?5VOX_Init?3?5too?5many?5s@
CONST	SEGMENT
??_C@_0DD@PLEHFDFD@?$FO1Error?3?$FO7?5VOX_Init?3?5too?5many?5s@ DB '^1Err'
	DB	'or:^7 VOX_Init: too many sentences specified', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BKCJCHLK@len@
CONST	SEGMENT
??_C@_03BKCJCHLK@len@ DB 'len', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ILKADKEE@?$FO1Error?3?$FO7?5sentence?5too?5long?$CB?6@
CONST	SEGMENT
??_C@_0BP@ILKADKEE@?$FO1Error?3?$FO7?5sentence?5too?5long?$CB?6@ DB '^1Er'
	DB	'ror:^7 sentence too long!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav@ DB '.wav', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FJOGIFJO@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5sente@
CONST	SEGMENT
??_C@_0DD@FJOGIFJO@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5sente@ DB '^1Error'
	DB	':^7 VOX_LoadSound: sentence is too long %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ICFMONLG@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5no?5su@
CONST	SEGMENT
??_C@_0CP@ICFMONLG@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5no?5su@ DB '^1Erro'
	DB	'r:^7 VOX_LoadSound: no such sentence %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GEPEPLFN@vox?1@
CONST	SEGMENT
??_C@_04GEPEPLFN@vox?1@ DB 'vox/', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_voxperiod DB	'_period', 00H
_voxcomma DB	'_comma', 00H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01e9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	024aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	025aH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_ReadSentenceFile
_TEXT	SEGMENT
_index$1 = -32						; size = 4
_pSentence$2 = -28					; size = 4
_fileSize$ = -24					; size = 4
_pSentenceData$ = -20					; size = 4
_pchlast$ = -16						; size = 4
_pFileData$ = -12					; size = 4
_pch$ = -8						; size = 4
_c$ = -1						; size = 1
_psentenceFileName$ = 8					; size = 4
_VOX_ReadSentenceFile PROC				; COMDAT

; 606  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 607  : 	char	c, *pch, *pFileData;
; 608  : 	char	*pchlast, *pSentenceData;
; 609  : 	int	fileSize;
; 610  : 
; 611  : 	// load file
; 612  : 	pFileData = (char *)FS_LoadFile( psentenceFileName, &fileSize, false );

	push	0
	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psentenceFileName$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFileData$[ebp], eax

; 613  : 	if( !pFileData ) return; // this game just doesn't used vox sound system

	cmp	DWORD PTR _pFileData$[ebp], 0
	jne	SHORT $LN10@VOX_ReadSe
	jmp	$LN3@VOX_ReadSe
$LN10@VOX_ReadSe:

; 614  : 
; 615  : 	pch = pFileData;

	mov	eax, DWORD PTR _pFileData$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 616  : 	pchlast = pch + fileSize;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR _pchlast$[ebp], eax
$LN2@VOX_ReadSe:

; 617  : 
; 618  : 	while( pch < pchlast )

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	$LN3@VOX_ReadSe

; 619  : 	{
; 620  : 		if( g_numSentences >= MAX_SENTENCES )

	cmp	DWORD PTR _g_numSentences, 4096		; 00001000H
	jb	SHORT $LN11@VOX_ReadSe

; 621  : 		{
; 622  : 			Con_Printf( S_ERROR "VOX_Init: too many sentences specified\n" );

	push	OFFSET ??_C@_0DD@PLEHFDFD@?$FO1Error?3?$FO7?5VOX_Init?3?5too?5many?5s@
	call	_Con_Printf
	add	esp, 4

; 623  : 			break;

	jmp	$LN3@VOX_ReadSe
$LN11@VOX_ReadSe:

; 624  : 		}
; 625  : 
; 626  : 		// only process this pass on sentences
; 627  : 		pSentenceData = NULL;

	mov	DWORD PTR _pSentenceData$[ebp], 0

; 628  : 
; 629  : 		// skip newline, cr, tab, space
; 630  : 
; 631  : 		c = *pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN4@VOX_ReadSe:

; 632  : 		while( pch < pchlast && IsWhiteSpace( c ))

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN5@VOX_ReadSe
	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_IsWhiteSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@VOX_ReadSe

; 633  : 			c = *(++pch);

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl
	jmp	SHORT $LN4@VOX_ReadSe
$LN5@VOX_ReadSe:

; 634  : 
; 635  : 		// skip entire line if first char is /
; 636  : 		if( *pch != '/' )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN12@VOX_ReadSe

; 637  : 		{
; 638  : 			sentence_t *pSentence = &g_Sentences[g_numSentences++];

	mov	eax, DWORD PTR _g_numSentences
	lea	ecx, DWORD PTR _g_Sentences[eax*8]
	mov	DWORD PTR _pSentence$2[ebp], ecx
	mov	edx, DWORD PTR _g_numSentences
	add	edx, 1
	mov	DWORD PTR _g_numSentences, edx

; 639  : 
; 640  : 			pSentence->pName = pch;

	mov	eax, DWORD PTR _pSentence$2[ebp]
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	DWORD PTR [eax], ecx

; 641  : 			pSentence->length = 0;

	mov	eax, DWORD PTR _pSentence$2[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+4], xmm0

; 642  : 
; 643  : 			// scan forward to first space, insert null terminator
; 644  : 			// after sentence name
; 645  : 
; 646  : 			c = *pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN6@VOX_ReadSe:

; 647  : 			while( pch < pchlast && c != ' ' )

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN7@VOX_ReadSe
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN7@VOX_ReadSe

; 648  : 				c = *(++pch);

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl
	jmp	SHORT $LN6@VOX_ReadSe
$LN7@VOX_ReadSe:

; 649  : 
; 650  : 			if( pch < pchlast )

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN13@VOX_ReadSe

; 651  : 				*pch++ = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN13@VOX_ReadSe:

; 652  : 
; 653  : 			// a sentence may have some line commands, make an extra pass
; 654  : 			pSentenceData = pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pSentenceData$[ebp], eax
$LN12@VOX_ReadSe:

; 655  : 		}
; 656  : 
; 657  : 		// scan forward to end of sentence or eof
; 658  : 		while( pch < pchlast && pch[0] != '\n' && pch[0] != '\r' )

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN9@VOX_ReadSe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@VOX_ReadSe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN9@VOX_ReadSe

; 659  : 			pch++;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN12@VOX_ReadSe
$LN9@VOX_ReadSe:

; 660  : 	
; 661  : 		// insert null terminator
; 662  : 		if( pch < pchlast ) *pch++ = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN14@VOX_ReadSe
	mov	eax, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN14@VOX_ReadSe:

; 663  : 
; 664  : 		// If we have some sentence data, parse out any line commands
; 665  : 		if( pSentenceData && pSentenceData < pchlast )

	cmp	DWORD PTR _pSentenceData$[ebp], 0
	je	SHORT $LN15@VOX_ReadSe
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	cmp	eax, DWORD PTR _pchlast$[ebp]
	jae	SHORT $LN15@VOX_ReadSe

; 666  : 		{
; 667  : 			int	index = g_numSentences - 1;

	mov	eax, DWORD PTR _g_numSentences
	sub	eax, 1
	mov	DWORD PTR _index$1[ebp], eax

; 668  : 
; 669  : 			// the current sentence has an index of count-1
; 670  : 			VOX_ParseLineCommands( pSentenceData, index );

	mov	eax, DWORD PTR _index$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSentenceData$[ebp]
	push	ecx
	call	_VOX_ParseLineCommands
	add	esp, 8
$LN15@VOX_ReadSe:

; 671  : 		}
; 672  : 	}

	jmp	$LN2@VOX_ReadSe
$LN3@VOX_ReadSe:

; 673  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_ReadSentenceFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_ParseLineCommands
_TEXT	SEGMENT
tv90 = -668						; size = 4
$T1 = -664						; size = 4
_tempBufferPos$ = -532					; size = 4
_length$ = -528						; size = 4
_pStart$ = -524						; size = 4
_pNext$ = -520						; size = 4
_tempBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_pSentenceData$ = 8					; size = 4
_sentenceIndex$ = 12					; size = 4
_VOX_ParseLineCommands PROC				; COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 668				; 0000029cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 531  : 	char	tempBuffer[512];
; 532  : 	char	*pNext, *pStart;
; 533  : 	int	length, tempBufferPos = 0;

	mov	DWORD PTR _tempBufferPos$[ebp], 0

; 534  : 
; 535  : 	if( !pSentenceData )

	cmp	DWORD PTR _pSentenceData$[ebp], 0
	jne	SHORT $LN10@VOX_ParseL

; 536  : 		return;

	jmp	$LN18@VOX_ParseL
$LN10@VOX_ParseL:

; 537  : 
; 538  : 	pStart = pSentenceData;

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	mov	DWORD PTR _pStart$[ebp], eax
$LN2@VOX_ParseL:

; 539  : 
; 540  : 	while( *pSentenceData )

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@VOX_ParseL

; 541  : 	{
; 542  : 		pNext = ScanForwardUntil( pSentenceData, '{' );

	push	123					; 0000007bH
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	push	eax
	call	_ScanForwardUntil
	add	esp, 8
	mov	DWORD PTR _pNext$[ebp], eax

; 543  : 
; 544  : 		// find length of "good" portion of the string (not a {} command)
; 545  : 		length = pNext - pSentenceData;

	mov	eax, DWORD PTR _pNext$[ebp]
	sub	eax, DWORD PTR _pSentenceData$[ebp]
	mov	DWORD PTR _length$[ebp], eax

; 546  : 		if( tempBufferPos + length > sizeof( tempBuffer ))

	mov	eax, DWORD PTR _tempBufferPos$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	cmp	eax, 512				; 00000200H
	jbe	SHORT $LN11@VOX_ParseL

; 547  : 		{
; 548  : 			Con_Printf( S_ERROR "sentence too long!\n" );

	push	OFFSET ??_C@_0BP@ILKADKEE@?$FO1Error?3?$FO7?5sentence?5too?5long?$CB?6@
	call	_Con_Printf
	add	esp, 4

; 549  : 			return;

	jmp	$LN18@VOX_ParseL
$LN11@VOX_ParseL:

; 550  : 		}
; 551  : 
; 552  : 		// Copy good string to temp buffer
; 553  : 		memcpy( tempBuffer + tempBufferPos, pSentenceData, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSentenceData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tempBufferPos$[ebp]
	lea	eax, DWORD PTR _tempBuffer$[ebp+edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 554  : 		
; 555  : 		// move the copy position
; 556  : 		tempBufferPos += length;

	mov	eax, DWORD PTR _tempBufferPos$[ebp]
	add	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR _tempBufferPos$[ebp], eax

; 557  : 
; 558  : 		pSentenceData = pNext;

	mov	eax, DWORD PTR _pNext$[ebp]
	mov	DWORD PTR _pSentenceData$[ebp], eax

; 559  : 		
; 560  : 		// skip ahead of the opening brace
; 561  : 		if( *pSentenceData ) pSentenceData++;

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@VOX_ParseL
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	add	eax, 1
	mov	DWORD PTR _pSentenceData$[ebp], eax
$LN12@VOX_ParseL:

; 562  : 		
; 563  : 		// skip whitespace
; 564  : 		while( *pSentenceData && *pSentenceData <= 32 )

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@VOX_ParseL
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN5@VOX_ParseL

; 565  : 			pSentenceData++;

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	add	eax, 1
	mov	DWORD PTR _pSentenceData$[ebp], eax
	jmp	SHORT $LN12@VOX_ParseL
$LN5@VOX_ParseL:

; 566  : 
; 567  : 		// simple comparison of string commands:
; 568  : 		switch( Q_tolower( *pSentenceData ))

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_Q_tolower
	add	esp, 4
	mov	BYTE PTR tv90[ebp], al
	cmp	BYTE PTR tv90[ebp], 108			; 0000006cH
	je	SHORT $LN13@VOX_ParseL
	jmp	SHORT $LN15@VOX_ParseL
$LN13@VOX_ParseL:

; 569  : 		{
; 570  : 		case 'l':
; 571  : 			// all commands starting with the letter 'l' here
; 572  : 			if( !Q_strnicmp( pSentenceData, "len", 3 ))

	push	3
	push	OFFSET ??_C@_03BKCJCHLK@len@
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@VOX_ParseL

; 573  : 			{
; 574  : 				g_Sentences[sentenceIndex].length = Q_atof( pSentenceData + 3 );

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	add	eax, 3
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _sentenceIndex$[ebp]
	fstp	DWORD PTR _g_Sentences[ecx*8+4]
$LN14@VOX_ParseL:
$LN15@VOX_ParseL:

; 575  : 			}
; 576  : 			break;
; 577  : 		case 0:
; 578  : 		default:
; 579  : 			break;
; 580  : 		}
; 581  : 
; 582  : 		pSentenceData = ScanForwardUntil( pSentenceData, '}' );

	push	125					; 0000007dH
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	push	eax
	call	_ScanForwardUntil
	add	esp, 8
	mov	DWORD PTR _pSentenceData$[ebp], eax

; 583  : 		
; 584  : 		// skip the closing brace
; 585  : 		if( *pSentenceData ) pSentenceData++;

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@VOX_ParseL
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	add	eax, 1
	mov	DWORD PTR _pSentenceData$[ebp], eax
$LN17@VOX_ParseL:

; 586  : 
; 587  : 		// skip trailing whitespace
; 588  : 		while( *pSentenceData && *pSentenceData <= 32 )

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN9@VOX_ParseL
	mov	eax, DWORD PTR _pSentenceData$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN9@VOX_ParseL

; 589  : 			pSentenceData++;

	mov	eax, DWORD PTR _pSentenceData$[ebp]
	add	eax, 1
	mov	DWORD PTR _pSentenceData$[ebp], eax
	jmp	SHORT $LN17@VOX_ParseL
$LN9@VOX_ParseL:

; 590  : 	}

	jmp	$LN2@VOX_ParseL
$LN3@VOX_ParseL:

; 591  : 
; 592  : 	if( tempBufferPos < sizeof( tempBuffer ))

	cmp	DWORD PTR _tempBufferPos$[ebp], 512	; 00000200H
	jae	SHORT $LN18@VOX_ParseL

; 593  : 	{
; 594  : 		// terminate cleaned up copy
; 595  : 		tempBuffer[tempBufferPos] = 0;

	mov	eax, DWORD PTR _tempBufferPos$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN20@VOX_ParseL
	jmp	SHORT $LN21@VOX_ParseL
$LN20@VOX_ParseL:
	call	___report_rangecheckfailure
$LN21@VOX_ParseL:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _tempBuffer$[ebp+ecx], 0

; 596  : 		
; 597  : 		// copy it over the original data
; 598  : 		Q_strcpy( pStart, tempBuffer );

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _tempBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStart$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN18@VOX_ParseL:

; 599  : 	}
; 600  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_ParseLineCommands ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_LoadFirstWord
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pchan$ = 8						; size = 4
_pwords$ = 12						; size = 4
_VOX_LoadFirstWord PROC					; COMDAT

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 401  : 	int	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN2@VOX_LoadFi:

; 402  : 
; 403  : 	// copy each pointer in the sfx temp array into the
; 404  : 	// sentence array, and set the channel to point to the
; 405  : 	// sentence array
; 406  : 	while( pwords[i].sfx != NULL )

	imul	eax, DWORD PTR _i$[ebp], 36
	mov	ecx, DWORD PTR _pwords$[ebp]
	cmp	DWORD PTR [ecx+eax+32], 0
	je	SHORT $LN3@VOX_LoadFi

; 407  : 	{
; 408  : 		pchan->words[i] = pwords[i];

	imul	esi, DWORD PTR _i$[ebp], 36
	add	esi, DWORD PTR _pwords$[ebp]
	imul	eax, DWORD PTR _i$[ebp], 36
	mov	ecx, DWORD PTR _pchan$[ebp]
	lea	edi, DWORD PTR [ecx+eax+172]
	mov	ecx, 9
	rep movsd

; 409  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 410  : 	}		

	jmp	SHORT $LN2@VOX_LoadFi
$LN3@VOX_LoadFi:

; 411  : 	pchan->words[i].sfx = NULL;

	imul	eax, DWORD PTR _i$[ebp], 36
	mov	ecx, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [ecx+eax+204], 0

; 412  : 
; 413  : 	pchan->wordIndex = 0;

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [eax+164], 0

; 414  : 	VOX_LoadWord( pchan );

	mov	eax, DWORD PTR _pchan$[ebp]
	push	eax
	call	_VOX_LoadWord
	add	esp, 4

; 415  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_LoadFirstWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_ParseWordParams
_TEXT	SEGMENT
tv139 = -92						; size = 4
_i$ = -24						; size = 4
_sznum$ = -20						; size = 8
_ct$ = -10						; size = 1
_c$ = -9						; size = 1
_pszsave$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_psz$ = 8						; size = 4
_pvoxword$ = 12						; size = 4
_fFirst$ = 16						; size = 4
_VOX_ParseWordParams PROC				; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 257  : 	char		*pszsave = psz;

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR _pszsave$[ebp], eax

; 258  : 	char		c, ct, sznum[8];
; 259  : 	static voxword_t	voxwordDefault;
; 260  : 	int		i;
; 261  : 			
; 262  : 	// init to defaults if this is the first word in string.
; 263  : 	if( fFirst )

	cmp	DWORD PTR _fFirst$[ebp], 0
	je	SHORT $LN12@VOX_ParseW

; 264  : 	{
; 265  : 		voxwordDefault.pitch = -1;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9+4, -1

; 266  : 		voxwordDefault.volume = 100;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9, 100 ; 00000064H

; 267  : 		voxwordDefault.start = 0;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9+8, 0

; 268  : 		voxwordDefault.end = 100;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9+12, 100 ; 00000064H

; 269  : 		voxwordDefault.fKeepCached = 0;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9+20, 0

; 270  : 		voxwordDefault.timecompress = 0;

	mov	DWORD PTR ?voxwordDefault@?1??VOX_ParseWordParams@@9@9+28, 0
$LN12@VOX_ParseW:

; 271  : 	}
; 272  : 
; 273  : 	*pvoxword = voxwordDefault;

	mov	ecx, 9
	mov	esi, OFFSET ?voxwordDefault@?1??VOX_ParseWordParams@@9@9
	mov	edi, DWORD PTR _pvoxword$[ebp]
	rep movsd

; 274  : 
; 275  : 	// look at next to last char to see if we have a 
; 276  : 	// valid format:
; 277  : 	c = *( psz + Q_strlen( psz ) - 1 );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx+eax-1]
	mov	BYTE PTR _c$[ebp], dl

; 278  : 
; 279  : 	// no formatting, return
; 280  : 	if( c != ')' ) return 1; 

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN13@VOX_ParseW
	mov	eax, 1
	jmp	$LN1@VOX_ParseW
$LN13@VOX_ParseW:

; 281  : 
; 282  : 	// scan forward to first '('
; 283  : 	c = *psz;

	mov	eax, DWORD PTR _psz$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN2@VOX_ParseW:

; 284  : 	while( !IsDelimitChar( c ))

	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_IsDelimitChar
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@VOX_ParseW

; 285  : 		c = *(++psz);

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl
	jmp	SHORT $LN2@VOX_ParseW
$LN3@VOX_ParseW:

; 286  : 
; 287  : 	// bogus formatting
; 288  : 	if( c == ')' ) return 0;

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN14@VOX_ParseW
	xor	eax, eax
	jmp	$LN1@VOX_ParseW
$LN14@VOX_ParseW:

; 289  : 	
; 290  : 	// null terminate
; 291  : 	*psz = 0;

	mov	eax, DWORD PTR _psz$[ebp]
	mov	BYTE PTR [eax], 0

; 292  : 	ct = *(++psz);

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ct$[ebp], dl
$LN4@VOX_ParseW:

; 293  : 
; 294  : 	while( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN5@VOX_ParseW
$LN6@VOX_ParseW:

; 295  : 	{
; 296  : 		// scan until we hit a character in the commandSet
; 297  : 		while( ct && !IsCommandChar( ct ))

	movsx	eax, BYTE PTR _ct$[ebp]
	test	eax, eax
	je	SHORT $LN7@VOX_ParseW
	movzx	eax, BYTE PTR _ct$[ebp]
	push	eax
	call	_IsCommandChar
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@VOX_ParseW

; 298  : 			ct = *(++psz);

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ct$[ebp], dl
	jmp	SHORT $LN6@VOX_ParseW
$LN7@VOX_ParseW:

; 299  : 		
; 300  : 		if( ct == ')' )

	movsx	eax, BYTE PTR _ct$[ebp]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN15@VOX_ParseW

; 301  : 			break;

	jmp	$LN5@VOX_ParseW
$LN15@VOX_ParseW:

; 302  : 
; 303  : 		memset( sznum, 0, sizeof( sznum ));

	push	8
	push	0
	lea	eax, DWORD PTR _sznum$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 304  : 		i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 305  : 
; 306  : 		c = *(++psz);

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 307  : 		
; 308  : 		if( !isdigit( c ))

	movsx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@VOX_ParseW

; 309  : 			break;

	jmp	$LN5@VOX_ParseW
$LN8@VOX_ParseW:

; 310  : 
; 311  : 		// read number
; 312  : 		while( isdigit( c ) && i < sizeof( sznum ) - 1 )

	movsx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN9@VOX_ParseW
	cmp	DWORD PTR _i$[ebp], 7
	jae	SHORT $LN9@VOX_ParseW

; 313  : 		{
; 314  : 			sznum[i++] = c;

	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR _sznum$[ebp+eax], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 315  : 			c = *(++psz);

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 316  : 		}

	jmp	SHORT $LN8@VOX_ParseW
$LN9@VOX_ParseW:

; 317  : 
; 318  : 		// get value of number
; 319  : 		i = Q_atoi( sznum );

	lea	eax, DWORD PTR _sznum$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 320  : 
; 321  : 		switch( ct )

	movsx	eax, BYTE PTR _ct$[ebp]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	sub	ecx, 101				; 00000065H
	mov	DWORD PTR tv139[ebp], ecx
	cmp	DWORD PTR tv139[ebp], 17		; 00000011H
	ja	SHORT $LN10@VOX_ParseW
	mov	edx, DWORD PTR tv139[ebp]
	movzx	eax, BYTE PTR $LN24@VOX_ParseW[edx]
	jmp	DWORD PTR $LN25@VOX_ParseW[eax*4]
$LN17@VOX_ParseW:

; 322  : 		{
; 323  : 		case 'v': pvoxword->volume = i; break;

	mov	eax, DWORD PTR _pvoxword$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN10@VOX_ParseW
$LN18@VOX_ParseW:

; 324  : 		case 'p': pvoxword->pitch = i; break;

	mov	eax, DWORD PTR _pvoxword$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN10@VOX_ParseW
$LN19@VOX_ParseW:

; 325  : 		case 's': pvoxword->start = i; break;

	mov	eax, DWORD PTR _pvoxword$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN10@VOX_ParseW
$LN20@VOX_ParseW:

; 326  : 		case 'e': pvoxword->end = i; break;

	mov	eax, DWORD PTR _pvoxword$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+12], ecx
	jmp	SHORT $LN10@VOX_ParseW
$LN21@VOX_ParseW:

; 327  : 		case 't': pvoxword->timecompress = i; break;

	mov	eax, DWORD PTR _pvoxword$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN10@VOX_ParseW:

; 328  : 		}
; 329  : 
; 330  : 		ct = c;

	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR _ct$[ebp], al

; 331  : 	}

	jmp	$LN4@VOX_ParseW
$LN5@VOX_ParseW:

; 332  : 
; 333  : 	// if the string has zero length, this was an isolated
; 334  : 	// parameter block.  Set default voxword to these
; 335  : 	// values
; 336  : 	if( Q_strlen( pszsave ) == 0 )

	mov	eax, DWORD PTR _pszsave$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@VOX_ParseW

; 337  : 	{
; 338  : 		voxwordDefault = *pvoxword;

	mov	ecx, 9
	mov	esi, DWORD PTR _pvoxword$[ebp]
	mov	edi, OFFSET ?voxwordDefault@?1??VOX_ParseWordParams@@9@9
	rep movsd

; 339  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@VOX_ParseW
$LN22@VOX_ParseW:

; 340  : 	}
; 341  : 
; 342  : 	return 1;

	mov	eax, 1
$LN1@VOX_ParseW:

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@VOX_ParseW:
	DD	$LN20@VOX_ParseW
	DD	$LN18@VOX_ParseW
	DD	$LN19@VOX_ParseW
	DD	$LN21@VOX_ParseW
	DD	$LN17@VOX_ParseW
	DD	$LN10@VOX_ParseW
$LN24@VOX_ParseW:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	3
	DB	5
	DB	4
_VOX_ParseWordParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_GetVolumeScale
_TEXT	SEGMENT
_volume$1 = -4						; size = 4
_pchan$ = 8						; size = 4
_VOX_GetVolumeScale PROC				; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 194  : 	if( pchan->currentWord )

	mov	eax, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN4@VOX_GetVol

; 195  : 	{
; 196  : 		if ( pchan->words[pchan->wordIndex].volume )

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [edx+ecx+172], 0
	je	SHORT $LN4@VOX_GetVol

; 197  : 		{
; 198  : 			float	volume = pchan->words[pchan->wordIndex].volume * 0.01f;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx+ecx+172]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _volume$1[ebp], xmm0

; 199  : 			if( volume < 1.0f ) return volume;

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR _volume$1[ebp]
	jbe	SHORT $LN4@VOX_GetVol
	fld	DWORD PTR _volume$1[ebp]
	jmp	SHORT $LN1@VOX_GetVol
$LN4@VOX_GetVol:

; 200  : 		}
; 201  : 	}
; 202  : 
; 203  : 	return 1.0f;

	fld1
$LN1@VOX_GetVol:

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_GetVolumeScale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_ParseString
_TEXT	SEGMENT
_p$ = -16						; size = 4
_c$ = -9						; size = 1
_fdone$ = -8						; size = 4
_i$ = -4						; size = 4
_psz$ = 8						; size = 4
_VOX_ParseString PROC					; COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 134  : 	int	i, fdone = 0;

	mov	DWORD PTR _fdone$[ebp], 0

; 135  : 	char	c, *p = psz;

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 136  : 
; 137  : 	memset( rgpparseword, 0, sizeof( char* ) * CVOXWORDMAX );

	push	256					; 00000100H
	push	0
	push	OFFSET _rgpparseword
	call	_memset
	add	esp, 12					; 0000000cH

; 138  : 
; 139  : 	if( !psz ) return NULL;

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $LN8@VOX_ParseS
	xor	eax, eax
	jmp	$LN1@VOX_ParseS
$LN8@VOX_ParseS:

; 140  : 
; 141  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 142  : 	rgpparseword[i++] = psz;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _psz$[ebp]
	mov	DWORD PTR _rgpparseword[eax*4], ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN2@VOX_ParseS:

; 143  : 
; 144  : 	while( !fdone && i < CVOXWORDMAX )

	cmp	DWORD PTR _fdone$[ebp], 0
	jne	$LN3@VOX_ParseS
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN3@VOX_ParseS

; 145  : 	{
; 146  : 		// scan up to next word
; 147  : 		c = *p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN4@VOX_ParseS:

; 148  : 		while( c && !IsNextWord( c ))

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $LN5@VOX_ParseS
	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_IsNextWord
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@VOX_ParseS

; 149  : 			c = *(++p);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl
	jmp	SHORT $LN4@VOX_ParseS
$LN5@VOX_ParseS:

; 150  : 			
; 151  : 		// if '(' then scan for matching ')'
; 152  : 		if( c == '(' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN9@VOX_ParseS

; 153  : 		{
; 154  : 			p = ScanForwardUntil( p, ')' );

	push	41					; 00000029H
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_ScanForwardUntil
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 155  : 			c = *(++p);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 156  : 			if( !c ) fdone = 1;

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN9@VOX_ParseS
	mov	DWORD PTR _fdone$[ebp], 1
$LN9@VOX_ParseS:

; 157  : 		}
; 158  : 
; 159  : 		if( fdone || !c )

	cmp	DWORD PTR _fdone$[ebp], 0
	jne	SHORT $LN13@VOX_ParseS
	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN11@VOX_ParseS
$LN13@VOX_ParseS:

; 160  : 		{
; 161  : 			fdone = 1;

	mov	DWORD PTR _fdone$[ebp], 1

; 162  : 		}

	jmp	$LN12@VOX_ParseS
$LN11@VOX_ParseS:

; 163  : 		else
; 164  : 		{	
; 165  : 			// if . or , insert pause into rgpparseword,
; 166  : 			// unless this is the last character
; 167  : 			if(( c == '.' || c == ',' ) && *(p+1) != '\n' && *(p+1) != '\r' && *(p+1) != 0 )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN15@VOX_ParseS
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN14@VOX_ParseS
$LN15@VOX_ParseS:
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN14@VOX_ParseS
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN14@VOX_ParseS
	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN14@VOX_ParseS

; 168  : 			{
; 169  : 				if( c == '.' ) rgpparseword[i++] = voxperiod;

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN16@VOX_ParseS
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _rgpparseword[eax*4], OFFSET _voxperiod
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN17@VOX_ParseS
$LN16@VOX_ParseS:

; 170  : 				else rgpparseword[i++] = voxcomma;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _rgpparseword[eax*4], OFFSET _voxcomma
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN17@VOX_ParseS:

; 171  : 
; 172  : 				if( i >= CVOXWORDMAX )

	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jl	SHORT $LN14@VOX_ParseS

; 173  : 					break;

	jmp	SHORT $LN3@VOX_ParseS
$LN14@VOX_ParseS:

; 174  : 			}
; 175  : 
; 176  : 			// null terminate substring
; 177  : 			*p++ = 0;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 178  : 
; 179  : 			// skip whitespace
; 180  : 			c = *p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN6@VOX_ParseS:

; 181  : 			while( c && IsSkipSpace( c ))

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $LN7@VOX_ParseS
	movzx	eax, BYTE PTR _c$[ebp]
	push	eax
	call	_IsSkipSpace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@VOX_ParseS

; 182  : 				c = *(++p);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl
	jmp	SHORT $LN6@VOX_ParseS
$LN7@VOX_ParseS:

; 183  : 
; 184  : 			if( !c ) fdone = 1;

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN19@VOX_ParseS
	mov	DWORD PTR _fdone$[ebp], 1
	jmp	SHORT $LN12@VOX_ParseS
$LN19@VOX_ParseS:

; 185  : 			else rgpparseword[i++] = p;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _rgpparseword[eax*4], ecx
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN12@VOX_ParseS:

; 186  : 		}
; 187  : 	}

	jmp	$LN2@VOX_ParseS
$LN3@VOX_ParseS:

; 188  : 
; 189  : 	return rgpparseword;

	mov	eax, OFFSET _rgpparseword
$LN1@VOX_ParseS:

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_ParseString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_LookupString
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSentenceName$ = 8					; size = 4
_psentencenum$ = 12					; size = 4
_VOX_LookupString PROC					; COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 109  : 	int	i;
; 110  : 
; 111  : 	if( Q_isdigit( pSentenceName ) && (i = Q_atoi( pSentenceName )) < g_numSentences )

	mov	eax, DWORD PTR _pSentenceName$[ebp]
	push	eax
	call	_Q_isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@VOX_Lookup
	mov	eax, DWORD PTR _pSentenceName$[ebp]
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _g_numSentences
	jae	SHORT $LN5@VOX_Lookup

; 112  : 	{
; 113  : 		if( psentencenum ) *psentencenum = i;

	cmp	DWORD PTR _psentencenum$[ebp], 0
	je	SHORT $LN6@VOX_Lookup
	mov	eax, DWORD PTR _psentencenum$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx
$LN6@VOX_Lookup:

; 114  : 		return (g_Sentences[i].pName + Q_strlen( g_Sentences[i].pName ) + 1 );		

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_Sentences[eax*8]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_Sentences[edx*8]
	lea	eax, DWORD PTR [ecx+eax+1]
	jmp	SHORT $LN1@VOX_Lookup
$LN5@VOX_Lookup:

; 115  : 	}
; 116  : 
; 117  : 	for( i = 0; i < g_numSentences; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@VOX_Lookup
$LN2@VOX_Lookup:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@VOX_Lookup:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _g_numSentences
	jae	SHORT $LN3@VOX_Lookup

; 118  : 	{
; 119  : 		if( !Q_stricmp( pSentenceName, g_Sentences[i].pName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_Sentences[eax*8]
	push	ecx
	mov	edx, DWORD PTR _pSentenceName$[ebp]
	push	edx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@VOX_Lookup

; 120  : 		{
; 121  : 			if( psentencenum ) *psentencenum = i;

	cmp	DWORD PTR _psentencenum$[ebp], 0
	je	SHORT $LN8@VOX_Lookup
	mov	eax, DWORD PTR _psentencenum$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax], ecx
$LN8@VOX_Lookup:

; 122  : 			return (g_Sentences[i].pName + Q_strlen( g_Sentences[i].pName ) + 1 );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_Sentences[eax*8]
	push	ecx
	call	_Q_strlen
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_Sentences[edx*8]
	lea	eax, DWORD PTR [ecx+eax+1]
	jmp	SHORT $LN1@VOX_Lookup
$LN7@VOX_Lookup:

; 123  : 		}
; 124  : 	}

	jmp	SHORT $LN2@VOX_Lookup
$LN3@VOX_Lookup:

; 125  : 
; 126  : 	return NULL;

	xor	eax, eax
$LN1@VOX_Lookup:

; 127  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_LookupString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_GetDirectory
_TEXT	SEGMENT
_p$ = -12						; size = 4
_cb$ = -8						; size = 4
_c$ = -1						; size = 1
_szpath$ = 8						; size = 4
_psz$ = 12						; size = 4
_VOX_GetDirectory PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 77   : 	char	c;
; 78   : 	int	cb = 0;

	mov	DWORD PTR _cb$[ebp], 0

; 79   : 	char	*p = psz + Q_strlen( psz ) - 1;

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _psz$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _p$[ebp], edx

; 80   : 
; 81   : 	// scan backwards until first '/' or start of string
; 82   : 	c = *p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$[ebp], cl
$LN2@VOX_GetDir:

; 83   : 	while( p > psz && c != '/' )

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _psz$[ebp]
	jbe	SHORT $LN3@VOX_GetDir
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN3@VOX_GetDir

; 84   : 	{
; 85   : 		c = *( --p );

	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, 1
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 86   : 		cb++;

	mov	eax, DWORD PTR _cb$[ebp]
	add	eax, 1
	mov	DWORD PTR _cb$[ebp], eax

; 87   : 	}

	jmp	SHORT $LN2@VOX_GetDir
$LN3@VOX_GetDir:

; 88   : 
; 89   : 	if( c != '/' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN4@VOX_GetDir

; 90   : 	{
; 91   : 		// didn't find '/', return default directory
; 92   : 		Q_strcpy( szpath, "vox/" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_04GEPEPLFN@vox?1@
	mov	eax, DWORD PTR _szpath$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 93   : 		return psz;

	mov	eax, DWORD PTR _psz$[ebp]
	jmp	SHORT $LN1@VOX_GetDir
$LN4@VOX_GetDir:

; 94   : 	}
; 95   : 
; 96   : 	cb = Q_strlen( psz ) - cb;

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	sub	eax, DWORD PTR _cb$[ebp]
	mov	DWORD PTR _cb$[ebp], eax

; 97   : 	memcpy( szpath, psz, cb );

	mov	eax, DWORD PTR _cb$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szpath$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 98   : 	szpath[cb] = 0;

	mov	eax, DWORD PTR _szpath$[ebp]
	add	eax, DWORD PTR _cb$[ebp]
	mov	BYTE PTR [eax], 0

; 99   : 
; 100  : 	return p + 1;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
$LN1@VOX_GetDir:

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_GetDirectory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _ScanForwardUntil
_TEXT	SEGMENT
_string$ = 8						; size = 4
_scan$ = 12						; size = 1
_ScanForwardUntil PROC					; COMDAT

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$LN2@ScanForwar:

; 63   : 	while( string[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN3@ScanForwar

; 64   : 	{
; 65   : 		if( string[0] == scan )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _string$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _scan$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN4@ScanForwar

; 66   : 			return string;

	mov	eax, DWORD PTR _string$[ebp]
	jmp	SHORT $LN1@ScanForwar
$LN4@ScanForwar:

; 67   : 		string++;

	mov	eax, DWORD PTR _string$[ebp]
	add	eax, 1
	mov	DWORD PTR _string$[ebp], eax

; 68   : 	}

	jmp	SHORT $LN2@ScanForwar
$LN3@ScanForwar:

; 69   : 	return string;

	mov	eax, DWORD PTR _string$[ebp]
$LN1@ScanForwar:

; 70   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ScanForwardUntil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _IsDelimitChar
_TEXT	SEGMENT
_c$ = 8							; size = 1
_IsDelimitChar PROC					; COMDAT

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 56   : 	if( c == '(' || c == ')' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN3@IsDelimitC
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN2@IsDelimitC
$LN3@IsDelimitC:

; 57   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsDelimitC
$LN2@IsDelimitC:

; 58   : 	return 0;

	xor	eax, eax
$LN1@IsDelimitC:

; 59   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsDelimitChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _IsCommandChar
_TEXT	SEGMENT
_c$ = 8							; size = 1
_IsCommandChar PROC					; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 49   : 	if( c == 'v' || c == 'p' || c == 's' || c == 'e' || c == 't' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 118				; 00000076H
	je	SHORT $LN3@IsCommandC
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN3@IsCommandC
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 115				; 00000073H
	je	SHORT $LN3@IsCommandC
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN3@IsCommandC
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 116				; 00000074H
	jne	SHORT $LN2@IsCommandC
$LN3@IsCommandC:

; 50   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsCommandC
$LN2@IsCommandC:

; 51   : 	return 0;

	xor	eax, eax
$LN1@IsCommandC:

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsCommandChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _IsWhiteSpace
_TEXT	SEGMENT
_space$ = 8						; size = 1
_IsWhiteSpace PROC					; COMDAT

; 41   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 42   : 	if( space == ' ' || space == '\t' || space == '\r' || space == '\n' )

	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 9
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@IsWhiteSpa
	movsx	eax, BYTE PTR _space$[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@IsWhiteSpa
$LN3@IsWhiteSpa:

; 43   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsWhiteSpa
$LN2@IsWhiteSpa:

; 44   : 	return 0;

	xor	eax, eax
$LN1@IsWhiteSpa:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsWhiteSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _IsSkipSpace
_TEXT	SEGMENT
_c$ = 8							; size = 1
_IsSkipSpace PROC					; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	if( c == ',' || c == '.' || c == ' ' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN3@IsSkipSpac
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN3@IsSkipSpac
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@IsSkipSpac
$LN3@IsSkipSpac:

; 36   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsSkipSpac
$LN2@IsSkipSpac:

; 37   : 	return 0;

	xor	eax, eax
$LN1@IsSkipSpac:

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsSkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _IsNextWord
_TEXT	SEGMENT
_c$ = 8							; size = 1
_IsNextWord PROC					; COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 28   : 	if( c == '.' || c == ',' || c == ' ' || c == '(' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN3@IsNextWord
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN3@IsNextWord
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@IsNextWord
	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN2@IsNextWord
$LN3@IsNextWord:

; 29   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@IsNextWord
$LN2@IsNextWord:

; 30   : 	return 0;

	xor	eax, eax
$LN1@IsNextWord:

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_IsNextWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_MixDataToDevice
_TEXT	SEGMENT
_outputCount$1 = -12					; size = 4
_timeCompress$2 = -8					; size = 4
_startingOffset$ = -4					; size = 4
_pchan$ = 8						; size = 4
_sampleCount$ = 12					; size = 4
_outputRate$ = 16					; size = 4
_outputOffset$ = 20					; size = 4
_VOX_MixDataToDevice PROC				; COMDAT

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 420  : 	// save this to compute total output
; 421  : 	int	startingOffset = outputOffset;

	mov	eax, DWORD PTR _outputOffset$[ebp]
	mov	DWORD PTR _startingOffset$[ebp], eax

; 422  : 
; 423  : 	if( !pchan->currentWord )

	mov	eax, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [eax+168], 0
	jne	SHORT $LN2@VOX_MixDat

; 424  : 		return 0;

	xor	eax, eax
	jmp	$LN1@VOX_MixDat
$LN2@VOX_MixDat:

; 425  : 
; 426  : 	while( sampleCount > 0 && pchan->currentWord )

	cmp	DWORD PTR _sampleCount$[ebp], 0
	jle	$LN3@VOX_MixDat
	mov	eax, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	$LN3@VOX_MixDat

; 427  : 	{
; 428  : 		int	timeCompress = pchan->words[pchan->wordIndex].timecompress;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+200]
	mov	DWORD PTR _timeCompress$2[ebp], eax

; 429  : 		int	outputCount = S_MixDataToDevice( pchan, sampleCount, outputRate, outputOffset, timeCompress );

	mov	eax, DWORD PTR _timeCompress$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outputRate$[ebp]
	push	edx
	mov	eax, DWORD PTR _sampleCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchan$[ebp]
	push	ecx
	call	_S_MixDataToDevice
	add	esp, 20					; 00000014H
	mov	DWORD PTR _outputCount$1[ebp], eax

; 430  : 
; 431  : 		outputOffset += outputCount;

	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, DWORD PTR _outputCount$1[ebp]
	mov	DWORD PTR _outputOffset$[ebp], eax

; 432  : 		sampleCount -= outputCount;

	mov	eax, DWORD PTR _sampleCount$[ebp]
	sub	eax, DWORD PTR _outputCount$1[ebp]
	mov	DWORD PTR _sampleCount$[ebp], eax

; 433  : 
; 434  : 		// if we finished load a next word
; 435  : 		if( pchan->currentWord->finished )

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN5@VOX_MixDat

; 436  : 		{
; 437  : 			VOX_FreeWord( pchan );

	mov	eax, DWORD PTR _pchan$[ebp]
	push	eax
	call	_VOX_FreeWord
	add	esp, 4

; 438  : 			pchan->wordIndex++;

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	add	ecx, 1
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [edx+164], ecx

; 439  : 			VOX_LoadWord( pchan );

	mov	eax, DWORD PTR _pchan$[ebp]
	push	eax
	call	_VOX_LoadWord
	add	esp, 4

; 440  : 
; 441  : 			if( pchan->currentWord )

	mov	eax, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN5@VOX_MixDat

; 442  : 			{
; 443  : 				pchan->sfx = pchan->words[pchan->wordIndex].sfx;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR _pchan$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+204]
	mov	DWORD PTR [edx+16], ecx
$LN5@VOX_MixDat:

; 444  : 			}
; 445  : 		}
; 446  : 	}

	jmp	$LN2@VOX_MixDat
$LN3@VOX_MixDat:

; 447  : 	return outputOffset - startingOffset;

	mov	eax, DWORD PTR _outputOffset$[ebp]
	sub	eax, DWORD PTR _startingOffset$[ebp]
$LN1@VOX_MixDat:

; 448  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_MixDataToDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_ModifyPitch
_TEXT	SEGMENT
_ch$ = 8						; size = 4
_pitch$ = 12						; size = 4
_VOX_ModifyPitch PROC					; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 222  : 	if( ch->currentWord )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+168], 0
	je	SHORT $LN3@VOX_Modify

; 223  : 	{
; 224  : 		if( ch->words[ch->wordIndex].pitch > 0 )

	mov	eax, DWORD PTR _ch$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+ecx+176], 0
	jle	SHORT $LN3@VOX_Modify

; 225  : 		{
; 226  : 			pitch += ( ch->words[ch->wordIndex].pitch - PITCH_NORM ) * 0.01f;

	mov	eax, DWORD PTR _ch$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+ecx+176]
	sub	eax, 100				; 00000064H
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3c23d70a
	addss	xmm0, DWORD PTR _pitch$[ebp]
	movss	DWORD PTR _pitch$[ebp], xmm0
$LN3@VOX_Modify:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 	return pitch;

	fld	DWORD PTR _pitch$[ebp]

; 231  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_ModifyPitch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_LoadSound
_TEXT	SEGMENT
tv128 = -3316						; size = 4
_psz$ = -2928						; size = 4
_rgvoxword$ = -2924					; size = 2304
_szpath$ = -620						; size = 32
_pathbuffer$ = -588					; size = 64
_cword$ = -524						; size = 4
_i$ = -520						; size = 4
_buffer$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_pchan$ = 8						; size = 4
_pszin$ = 12						; size = 4
_VOX_LoadSound PROC					; COMDAT

; 452  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3316				; 00000cf4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 453  : 	char	buffer[512];
; 454  : 	int	i, cword;
; 455  : 	char	pathbuffer[64];
; 456  : 	char	szpath[32];
; 457  : 	voxword_t	rgvoxword[CVOXWORDMAX];
; 458  : 	char	*psz;
; 459  : 
; 460  : 	if( !pszin || !*pszin )

	cmp	DWORD PTR _pszin$[ebp], 0
	je	SHORT $LN5@VOX_LoadSo
	mov	eax, DWORD PTR _pszin$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@VOX_LoadSo
$LN5@VOX_LoadSo:

; 461  : 		return;

	jmp	$LN1@VOX_LoadSo
$LN4@VOX_LoadSo:

; 462  : 
; 463  : 	memset( rgvoxword, 0, sizeof( voxword_t ) * CVOXWORDMAX );

	push	2304					; 00000900H
	push	0
	lea	eax, DWORD PTR _rgvoxword$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 464  : 	memset( buffer, 0, sizeof( buffer ));

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 465  : 
; 466  : 	// lookup actual string in g_Sentences, 
; 467  : 	// set pointer to string data
; 468  : 	psz = VOX_LookupString( pszin, NULL );

	push	0
	mov	eax, DWORD PTR _pszin$[ebp]
	push	eax
	call	_VOX_LookupString
	add	esp, 8
	mov	DWORD PTR _psz$[ebp], eax

; 469  : 
; 470  : 	if( !psz )

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $LN6@VOX_LoadSo

; 471  : 	{
; 472  : 		Con_DPrintf( S_ERROR "VOX_LoadSound: no such sentence %s\n", pszin );

	mov	eax, DWORD PTR _pszin$[ebp]
	push	eax
	push	OFFSET ??_C@_0CP@ICFMONLG@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5no?5su@
	call	_Con_DPrintf
	add	esp, 8

; 473  : 		return;

	jmp	$LN1@VOX_LoadSo
$LN6@VOX_LoadSo:

; 474  : 	}
; 475  : 
; 476  : 	// get directory from string, advance psz
; 477  : 	psz = VOX_GetDirectory( szpath, psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szpath$[ebp]
	push	ecx
	call	_VOX_GetDirectory
	add	esp, 8
	mov	DWORD PTR _psz$[ebp], eax

; 478  : 
; 479  : 	if( Q_strlen( psz ) > sizeof( buffer ) - 1 )

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_Q_strlen
	add	esp, 4
	cmp	eax, 511				; 000001ffH
	jbe	SHORT $LN7@VOX_LoadSo

; 480  : 	{
; 481  : 		Con_Printf( S_ERROR "VOX_LoadSound: sentence is too long %s\n", psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@FJOGIFJO@?$FO1Error?3?$FO7?5VOX_LoadSound?3?5sente@
	call	_Con_Printf
	add	esp, 8

; 482  : 		return;

	jmp	$LN1@VOX_LoadSo
$LN7@VOX_LoadSo:

; 483  : 	}
; 484  : 
; 485  : 	// copy into buffer
; 486  : 	Q_strcpy( buffer, psz );

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 487  : 	psz = buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _psz$[ebp], eax

; 488  : 
; 489  : 	// parse sentence (also inserts null terminators between words)
; 490  : 	VOX_ParseString( psz );

	mov	eax, DWORD PTR _psz$[ebp]
	push	eax
	call	_VOX_ParseString
	add	esp, 4

; 491  : 
; 492  : 	// for each word in the sentence, construct the filename,
; 493  : 	// lookup the sfx and save each pointer in a temp array	
; 494  : 
; 495  : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 496  : 	cword = 0;

	mov	DWORD PTR _cword$[ebp], 0
$LN2@VOX_LoadSo:

; 497  : 	while( rgpparseword[i] )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _rgpparseword[eax*4], 0
	je	$LN3@VOX_LoadSo

; 498  : 	{
; 499  : 		// Get any pitch, volume, start, end params into voxword
; 500  : 		if( VOX_ParseWordParams( rgpparseword[i], &rgvoxword[cword], i == 0 ))

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $LN10@VOX_LoadSo
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN11@VOX_LoadSo
$LN10@VOX_LoadSo:
	mov	DWORD PTR tv128[ebp], 0
$LN11@VOX_LoadSo:
	mov	eax, DWORD PTR tv128[ebp]
	push	eax
	imul	ecx, DWORD PTR _cword$[ebp], 36
	lea	edx, DWORD PTR _rgvoxword$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _rgpparseword[eax*4]
	push	ecx
	call	_VOX_ParseWordParams
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN8@VOX_LoadSo

; 501  : 		{
; 502  : 			// this is a valid word (as opposed to a parameter block)
; 503  : 			Q_strcpy( pathbuffer, szpath );

	push	99999					; 0001869fH
	lea	eax, DWORD PTR _szpath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pathbuffer$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 504  : 			Q_strncat( pathbuffer, rgpparseword[i], sizeof( pathbuffer ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _rgpparseword[eax*4]
	push	ecx
	lea	edx, DWORD PTR _pathbuffer$[ebp]
	push	edx
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 505  : 			Q_strncat( pathbuffer, ".wav", sizeof( pathbuffer ));

	push	64					; 00000040H
	push	OFFSET ??_C@_04IBLEHOMF@?4wav@
	lea	eax, DWORD PTR _pathbuffer$[ebp]
	push	eax
	call	_Q_strncat
	add	esp, 12					; 0000000cH

; 506  : 
; 507  : 			// find name, if already in cache, mark voxword
; 508  : 			// so we don't discard when word is done playing
; 509  : 			rgvoxword[cword].sfx = S_FindName( pathbuffer, &( rgvoxword[cword].fKeepCached ));

	imul	eax, DWORD PTR _cword$[ebp], 36
	lea	ecx, DWORD PTR _rgvoxword$[ebp+eax+20]
	push	ecx
	lea	edx, DWORD PTR _pathbuffer$[ebp]
	push	edx
	call	_S_FindName
	add	esp, 8
	imul	ecx, DWORD PTR _cword$[ebp], 36
	mov	DWORD PTR _rgvoxword$[ebp+ecx+32], eax

; 510  : 			cword++;

	mov	eax, DWORD PTR _cword$[ebp]
	add	eax, 1
	mov	DWORD PTR _cword$[ebp], eax
$LN8@VOX_LoadSo:

; 511  : 		}
; 512  : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 513  : 	}

	jmp	$LN2@VOX_LoadSo
$LN3@VOX_LoadSo:

; 514  : 
; 515  : 	VOX_LoadFirstWord( pchan, rgvoxword );

	lea	eax, DWORD PTR _rgvoxword$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchan$[ebp]
	push	ecx
	call	_VOX_LoadFirstWord
	add	esp, 8

; 516  : 
; 517  : 	pchan->isSentence = true;

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [eax+56], 1

; 518  : 	pchan->sfx = rgvoxword[0].sfx;

	mov	eax, 36					; 00000024H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR _rgvoxword$[ebp+ecx+32]
	mov	DWORD PTR [edx+16], eax
$LN1@VOX_LoadSo:

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_LoadSound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_SetChanVol
_TEXT	SEGMENT
_scale$ = -4						; size = 4
_ch$ = 8						; size = 4
_VOX_SetChanVol PROC					; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 208  : 	float	scale;
; 209  : 
; 210  : 	if( !ch->currentWord )

	mov	eax, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [eax+168], 0
	jne	SHORT $LN2@VOX_SetCha

; 211  : 		return;

	jmp	SHORT $LN1@VOX_SetCha
$LN2@VOX_SetCha:

; 212  : 
; 213  : 	scale = VOX_GetVolumeScale( ch );

	mov	eax, DWORD PTR _ch$[ebp]
	push	eax
	call	_VOX_GetVolumeScale
	add	esp, 4
	fstp	DWORD PTR _scale$[ebp]

; 214  : 	if( scale == 1.0f ) return;

	movss	xmm0, DWORD PTR _scale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@VOX_SetCha
	jmp	SHORT $LN1@VOX_SetCha
$LN3@VOX_SetCha:

; 215  : 
; 216  : 	ch->rightvol = (int)(ch->rightvol * scale);

	mov	eax, DWORD PTR _ch$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 217  : 	ch->leftvol = (int)(ch->leftvol * scale);

	mov	eax, DWORD PTR _ch$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _ch$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN1@VOX_SetCha:

; 218  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_SetChanVol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_Shutdown
_TEXT	SEGMENT
_VOX_Shutdown PROC					; COMDAT

; 685  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 686  : 	g_numSentences = 0;

	mov	DWORD PTR _g_numSentences, 0

; 687  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_Init
_TEXT	SEGMENT
_VOX_Init PROC						; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 677  : 	memset( g_Sentences, 0, sizeof( g_Sentences ));

	push	32768					; 00008000H
	push	0
	push	OFFSET _g_Sentences
	call	_memset
	add	esp, 12					; 0000000cH

; 678  : 	g_numSentences = 0;

	mov	DWORD PTR _g_numSentences, 0

; 679  : 
; 680  : 	VOX_ReadSentenceFile( DEFAULT_SOUNDPATH "sentences.txt" );

	push	OFFSET ??_C@_0BE@LOFIHEDB@sound?1sentences?4txt@
	call	_VOX_ReadSentenceFile
	add	esp, 4

; 681  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_FreeWord
_TEXT	SEGMENT
_pchan$ = 8						; size = 4
_VOX_FreeWord PROC					; COMDAT

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 383  : 	pchan->currentWord = NULL; // sentence is finished

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [eax+168], 0

; 384  : 	memset( &pchan->pMixer, 0, sizeof( pchan->pMixer ));

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _pchan$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 385  : 
; 386  : 	// release unused sounds
; 387  : 	if( pchan->words[pchan->wordIndex].sfx )

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [edx+ecx+204], 0
	je	SHORT $LN1@VOX_FreeWo

; 388  : 	{
; 389  : 		// If this wave wasn't precached by the game code
; 390  : 		if( !pchan->words[pchan->wordIndex].fKeepCached )

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [edx+ecx+192], 0
	jne	SHORT $LN1@VOX_FreeWo

; 391  : 		{
; 392  : 			FS_FreeSound( pchan->words[pchan->wordIndex].sfx->cache );

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+204]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_FS_FreeSound
	add	esp, 4

; 393  : 			pchan->words[pchan->wordIndex].sfx->cache = NULL;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+204]
	mov	DWORD PTR [eax+64], 0

; 394  : 			pchan->words[pchan->wordIndex].sfx = NULL;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [edx+ecx+204], 0
$LN1@VOX_FreeWo:

; 395  : 		}
; 396  : 	}
; 397  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_FreeWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_vox.c
;	COMDAT _VOX_LoadWord
_TEXT	SEGMENT
_sampleCount$1 = -16					; size = 4
_end$2 = -12						; size = 4
_start$3 = -8						; size = 4
_pSource$4 = -4						; size = 4
_pchan$ = 8						; size = 4
_VOX_LoadWord PROC					; COMDAT

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 347  : 	if( pchan->words[pchan->wordIndex].sfx )

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	cmp	DWORD PTR [edx+ecx+204], 0
	je	$LN8@VOX_LoadWo

; 348  : 	{
; 349  : 		wavdata_t	*pSource = S_LoadSound( pchan->words[pchan->wordIndex].sfx );

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+204]
	push	eax
	call	_S_LoadSound
	add	esp, 4
	mov	DWORD PTR _pSource$4[ebp], eax

; 350  : 
; 351  : 		if( pSource )

	cmp	DWORD PTR _pSource$4[ebp], 0
	je	$LN8@VOX_LoadWo

; 352  : 		{
; 353  : 			int start = pchan->words[pchan->wordIndex].start;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+180]
	mov	DWORD PTR _start$3[ebp], eax

; 354  : 			int end = pchan->words[pchan->wordIndex].end;

	mov	eax, DWORD PTR _pchan$[ebp]
	imul	ecx, DWORD PTR [eax+164], 36
	mov	edx, DWORD PTR _pchan$[ebp]
	mov	eax, DWORD PTR [edx+ecx+184]
	mov	DWORD PTR _end$2[ebp], eax

; 355  : 
; 356  : 			// apply mixer
; 357  : 			pchan->currentWord = &pchan->pMixer;

	mov	eax, DWORD PTR _pchan$[ebp]
	add	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _pchan$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 358  : 			pchan->currentWord->pData = pSource; 

	mov	eax, DWORD PTR _pchan$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _pSource$4[ebp]
	mov	DWORD PTR [ecx+8], edx

; 359  : 				
; 360  : 			// don't allow overlapped ranges
; 361  : 			if( end <= start ) end = 0;

	mov	eax, DWORD PTR _end$2[ebp]
	cmp	eax, DWORD PTR _start$3[ebp]
	jg	SHORT $LN4@VOX_LoadWo
	mov	DWORD PTR _end$2[ebp], 0
$LN4@VOX_LoadWo:

; 362  : 
; 363  : 			if( start || end )

	cmp	DWORD PTR _start$3[ebp], 0
	jne	SHORT $LN6@VOX_LoadWo
	cmp	DWORD PTR _end$2[ebp], 0
	je	SHORT $LN8@VOX_LoadWo
$LN6@VOX_LoadWo:

; 364  : 			{
; 365  : 				int	sampleCount = pSource->samples;

	mov	eax, DWORD PTR _pSource$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _sampleCount$1[ebp], ecx

; 366  : 
; 367  : 				if( start )

	cmp	DWORD PTR _start$3[ebp], 0
	je	SHORT $LN7@VOX_LoadWo

; 368  : 				{
; 369  : 					S_SetSampleStart( pchan, pSource, (int)(sampleCount * 0.01f * start));

	cvtsi2ss xmm0, DWORD PTR _sampleCount$1[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	cvtsi2ss xmm1, DWORD PTR _start$3[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _pSource$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchan$[ebp]
	push	edx
	call	_S_SetSampleStart
	add	esp, 12					; 0000000cH
$LN7@VOX_LoadWo:

; 370  : 				}
; 371  : 
; 372  : 				if( end )

	cmp	DWORD PTR _end$2[ebp], 0
	je	SHORT $LN8@VOX_LoadWo

; 373  : 				{
; 374  : 					S_SetSampleEnd( pchan, pSource, (int)(sampleCount * 0.01f * end));

	cvtsi2ss xmm0, DWORD PTR _sampleCount$1[ebp]
	mulss	xmm0, DWORD PTR __real@3c23d70a
	cvtsi2ss xmm1, DWORD PTR _end$2[ebp]
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	push	eax
	mov	ecx, DWORD PTR _pSource$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchan$[ebp]
	push	edx
	call	_S_SetSampleEnd
	add	esp, 12					; 0000000cH
$LN8@VOX_LoadWo:

; 375  : 				}
; 376  : 			}
; 377  : 		}
; 378  : 	}
; 379  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_VOX_LoadWord ENDP
_TEXT	ENDS
END
