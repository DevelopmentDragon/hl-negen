; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cfgscript.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_cvartypes
PUBLIC	??_C@_04PPJDIBFE@BOOL@				; `string'
PUBLIC	??_C@_06EFEGMLFC@NUMBER@			; `string'
PUBLIC	??_C@_04PCOPKCKE@LIST@				; `string'
PUBLIC	??_C@_06IGECGLFO@STRING@			; `string'
;	COMDAT ??_C@_06IGECGLFO@STRING@
CONST	SEGMENT
??_C@_06IGECGLFO@STRING@ DB 'STRING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCOPKCKE@LIST@
CONST	SEGMENT
??_C@_04PCOPKCKE@LIST@ DB 'LIST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFEGMLFC@NUMBER@
CONST	SEGMENT
??_C@_06EFEGMLFC@NUMBER@ DB 'NUMBER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPJDIBFE@BOOL@
CONST	SEGMENT
??_C@_04PPJDIBFE@BOOL@ DB 'BOOL', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_cvartypes DD	00H
	DD	FLAT:??_C@_04PPJDIBFE@BOOL@
	DD	FLAT:??_C@_06EFEGMLFC@NUMBER@
	DD	FLAT:??_C@_04PCOPKCKE@LIST@
	DD	FLAT:??_C@_06IGECGLFO@STRING@
_DATA	ENDS
PUBLIC	_CSCR_LoadDefaultCVars
PUBLIC	_CSCR_WriteGameCVars
PUBLIC	_CSCR_ExpectString
PUBLIC	_CSCR_ParseType
PUBLIC	_CSCR_ParseSingleCvar
PUBLIC	_CSCR_ParseHeader
PUBLIC	??_C@_0DJ@LDAHKPMO@?$FO1Error?3?$FO7?5Syntax?5error?5in?5?$CFs?3?5@ ; `string'
PUBLIC	??_C@_0CJ@OGCHCMOK@?$FO1Error?3?$FO7?5Cannot?5parse?5?$CFs?3?5Bad@ ; `string'
PUBLIC	??_C@_01HCONENDN@?$HL@				; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN@				; `string'
PUBLIC	??_C@_07CIGMICNE@SetInfo@			; `string'
PUBLIC	??_C@_07NCHCCDCP@VERSION@			; `string'
PUBLIC	??_C@_0CK@LDBHODJF@?$FO1Error?3?$FO7?5File?5?$CFs?5has?5wrong?5ve@ ; `string'
PUBLIC	??_C@_0M@FBMBBIBH@DESCRIPTION@			; `string'
PUBLIC	??_C@_0N@NGBHOIOP@INFO_OPTIONS@			; `string'
PUBLIC	??_C@_0P@EGCGFEHP@SERVER_OPTIONS@		; `string'
PUBLIC	??_C@_0DP@NAKBELK@?$FO1Error?3?$FO7?5DESCRIPTION?5must?5be?5@ ; `string'
PUBLIC	?__LINE__Var@?0??CSCR_WriteGameCVars@@9@9	; `CSCR_WriteGameCVars'::`1'::__LINE__Var
PUBLIC	??_C@_0BP@NPFBPPC@Reading?5config?5script?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_0BO@FDDGDFMI@?$FO1Error?3?$FO7?5Got?5extra?5tokens?$CB?6@ ; `string'
PUBLIC	??_C@_0DB@KMFEMFKE@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5b@ ; `string'
PUBLIC	??_C@_0CI@DFHOHJNK@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5t@ ; `string'
PUBLIC	??_C@_0DG@HFOEJBMM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	?__LINE__Var@?0??CSCR_LoadDefaultCVars@@9@9	; `CSCR_LoadDefaultCVars'::`1'::__LINE__Var
PUBLIC	__real@3f800000
EXTRN	_Q_atof:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FindVarExt:PROC
EXTRN	_Cvar_Get:PROC
EXTRN	_FS_LoadFile:PROC
EXTRN	_FS_Printf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_COM_ParseFile:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CSCR_LoadDefaultCVars@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CSCR_LoadDefaultCVars@@9@9 DD 011bH	; `CSCR_LoadDefaultCVars'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@HFOEJBMM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@HFOEJBMM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\common\cfgscript.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DFHOHJNK@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5t@
CONST	SEGMENT
??_C@_0CI@DFHOHJNK@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5t@ DB '^'
	DB	'1Error:^7 Parse error in %s, token %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KMFEMFKE@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5b@
CONST	SEGMENT
??_C@_0DB@KMFEMFKE@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5b@ DB '^'
	DB	'1Error:^7 Parse error in %s, byte %d, token %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FDDGDFMI@?$FO1Error?3?$FO7?5Got?5extra?5tokens?$CB?6@
CONST	SEGMENT
??_C@_0BO@FDDGDFMI@?$FO1Error?3?$FO7?5Got?5extra?5tokens?$CB?6@ DB '^1Err'
	DB	'or:^7 Got extra tokens!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@ DB '%s "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NPFBPPC@Reading?5config?5script?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BP@NPFBPPC@Reading?5config?5script?5file?5?$CFs?6@ DB 'Reading con'
	DB	'fig script file %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CSCR_WriteGameCVars@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CSCR_WriteGameCVars@@9@9 DD 0d5H	; `CSCR_WriteGameCVars'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DP@NAKBELK@?$FO1Error?3?$FO7?5DESCRIPTION?5must?5be?5@
CONST	SEGMENT
??_C@_0DP@NAKBELK@?$FO1Error?3?$FO7?5DESCRIPTION?5must?5be?5@ DB '^1Error'
	DB	':^7 DESCRIPTION must be INFO_OPTIONS or SERVER_OPTIONS', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EGCGFEHP@SERVER_OPTIONS@
CONST	SEGMENT
??_C@_0P@EGCGFEHP@SERVER_OPTIONS@ DB 'SERVER_OPTIONS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NGBHOIOP@INFO_OPTIONS@
CONST	SEGMENT
??_C@_0N@NGBHOIOP@INFO_OPTIONS@ DB 'INFO_OPTIONS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FBMBBIBH@DESCRIPTION@
CONST	SEGMENT
??_C@_0M@FBMBBIBH@DESCRIPTION@ DB 'DESCRIPTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LDBHODJF@?$FO1Error?3?$FO7?5File?5?$CFs?5has?5wrong?5ve@
CONST	SEGMENT
??_C@_0CK@LDBHODJF@?$FO1Error?3?$FO7?5File?5?$CFs?5has?5wrong?5ve@ DB '^1'
	DB	'Error:^7 File %s has wrong version %s!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NCHCCDCP@VERSION@
CONST	SEGMENT
??_C@_07NCHCCDCP@VERSION@ DB 'VERSION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIGMICNE@SetInfo@
CONST	SEGMENT
??_C@_07CIGMICNE@SetInfo@ DB 'SetInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OGCHCMOK@?$FO1Error?3?$FO7?5Cannot?5parse?5?$CFs?3?5Bad@
CONST	SEGMENT
??_C@_0CJ@OGCHCMOK@?$FO1Error?3?$FO7?5Cannot?5parse?5?$CFs?3?5Bad@ DB '^1'
	DB	'Error:^7 Cannot parse %s: Bad type %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LDAHKPMO@?$FO1Error?3?$FO7?5Syntax?5error?5in?5?$CFs?3?5@
CONST	SEGMENT
??_C@_0DJ@LDAHKPMO@?$FO1Error?3?$FO7?5Syntax?5error?5in?5?$CFs?3?5@ DB '^'
	DB	'1Error:^7 Syntax error in %s: got "%s" instead of "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0281H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0228H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_ParseHeader
_TEXT	SEGMENT
tv160 = -68						; size = 4
_ps$ = 8						; size = 4
_CSCR_ParseHeader PROC					; COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 175  : 	if( !CSCR_ExpectString( ps, "VERSION", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_07NCHCCDCP@VERSION@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@CSCR_Parse

; 176  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN2@CSCR_Parse:

; 177  : 
; 178  : 	// Parse in the version #
; 179  : 	// Get the first token.
; 180  : 	ps->buf = COM_ParseFile( ps->buf, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 181  : 
; 182  : 	if( Q_atof( ps->token ) != 1 )

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	fstp	DWORD PTR tv160[ebp]
	movss	xmm0, DWORD PTR tv160[ebp]
	ucomiss	xmm0, DWORD PTR __real@3f800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CSCR_Parse

; 183  : 	{
; 184  : 		Con_DPrintf( S_ERROR "File %s has wrong version %s!\n", ps->filename, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	push	OFFSET ??_C@_0CK@LDBHODJF@?$FO1Error?3?$FO7?5File?5?$CFs?5has?5wrong?5ve@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 185  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN3@CSCR_Parse:

; 186  : 	}
; 187  : 
; 188  : 	if( !CSCR_ExpectString( ps, "DESCRIPTION", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_0M@FBMBBIBH@DESCRIPTION@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@CSCR_Parse

; 189  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN4@CSCR_Parse:

; 190  : 
; 191  : 	ps->buf = COM_ParseFile( ps->buf, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 192  : 
; 193  : 	if( Q_stricmp( ps->token, "INFO_OPTIONS") && Q_stricmp( ps->token, "SERVER_OPTIONS" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_0N@NGBHOIOP@INFO_OPTIONS@
	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@CSCR_Parse
	push	99999					; 0001869fH
	push	OFFSET ??_C@_0P@EGCGFEHP@SERVER_OPTIONS@
	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN5@CSCR_Parse

; 194  : 	{
; 195  : 		Con_DPrintf( S_ERROR "DESCRIPTION must be INFO_OPTIONS or SERVER_OPTIONS\n");

	push	OFFSET ??_C@_0DP@NAKBELK@?$FO1Error?3?$FO7?5DESCRIPTION?5must?5be?5@
	call	_Con_DPrintf
	add	esp, 4

; 196  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CSCR_Parse
$LN5@CSCR_Parse:

; 197  : 	}
; 198  : 
; 199  : 	if( !CSCR_ExpectString( ps, "{", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01HCONENDN@?$HL@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN6@CSCR_Parse

; 200  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CSCR_Parse
$LN6@CSCR_Parse:

; 201  : 
; 202  : 	return true;

	mov	eax, 1
$LN1@CSCR_Parse:

; 203  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CSCR_ParseHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_ParseSingleCvar
_TEXT	SEGMENT
tv92 = -68						; size = 4
_ps$ = 8						; size = 4
_result$ = 12						; size = 4
_CSCR_ParseSingleCvar PROC				; COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 101  : 	// read the name
; 102  : 	ps->buf = COM_ParseFile( ps->buf, result->name );

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 103  : 
; 104  : 	if( !CSCR_ExpectString( ps, "{", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01HCONENDN@?$HL@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN6@CSCR_Parse

; 105  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN6@CSCR_Parse:

; 106  : 
; 107  : 	// read description
; 108  : 	ps->buf = COM_ParseFile( ps->buf, result->desc );

	mov	eax, DWORD PTR _result$[ebp]
	add	eax, 512				; 00000200H
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 109  : 
; 110  : 	if( !CSCR_ExpectString( ps, "{", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01HCONENDN@?$HL@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN7@CSCR_Parse

; 111  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN7@CSCR_Parse:

; 112  : 
; 113  : 	result->type = CSCR_ParseType( ps );

	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ParseType
	add	esp, 4
	mov	ecx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ecx+776], eax

; 114  : 
; 115  : 	switch( result->type )

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR [eax+776]
	mov	DWORD PTR tv92[ebp], ecx
	mov	edx, DWORD PTR tv92[ebp]
	sub	edx, 1
	mov	DWORD PTR tv92[ebp], edx
	cmp	DWORD PTR tv92[ebp], 3
	ja	$LN15@CSCR_Parse
	mov	eax, DWORD PTR tv92[ebp]
	jmp	DWORD PTR $LN21@CSCR_Parse[eax*4]
$LN8@CSCR_Parse:

; 116  : 	{
; 117  : 	case T_BOOL:
; 118  : 		// bool only has description
; 119  : 		if( !CSCR_ExpectString( ps, "}", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN9@CSCR_Parse

; 120  : 			return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN9@CSCR_Parse:

; 121  : 		break;

	jmp	$LN2@CSCR_Parse
$LN10@CSCR_Parse:

; 122  : 	case T_NUMBER:
; 123  : 		// min
; 124  : 		ps->buf = COM_ParseFile( ps->buf, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 125  : 		result->fMin = Q_atof( ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _result$[ebp]
	fstp	DWORD PTR [ecx+768]

; 126  : 
; 127  : 		// max
; 128  : 		ps->buf = COM_ParseFile( ps->buf, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 129  : 		result->fMax = Q_atof( ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	call	_Q_atof
	add	esp, 4
	mov	ecx, DWORD PTR _result$[ebp]
	fstp	DWORD PTR [ecx+772]

; 130  : 
; 131  : 		if( !CSCR_ExpectString( ps, "}", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN11@CSCR_Parse

; 132  : 			return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN11@CSCR_Parse:

; 133  : 		break;

	jmp	SHORT $LN2@CSCR_Parse
$LN12@CSCR_Parse:

; 134  : 	case T_STRING:
; 135  : 		if( !CSCR_ExpectString( ps, "}", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN13@CSCR_Parse

; 136  : 			return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN13@CSCR_Parse:

; 137  : 		break;

	jmp	SHORT $LN2@CSCR_Parse
$LN14@CSCR_Parse:

; 138  : 	case T_LIST:
; 139  : 		while( !CSCR_ExpectString( ps, "}", true, false ))

	push	0
	push	1
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN5@CSCR_Parse

; 140  : 		{
; 141  : 			// read token for each item here
; 142  : 		}

	jmp	SHORT $LN14@CSCR_Parse
$LN5@CSCR_Parse:

; 143  : 		break;

	jmp	SHORT $LN2@CSCR_Parse
$LN15@CSCR_Parse:

; 144  : 	default:
; 145  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN2@CSCR_Parse:

; 146  : 	}
; 147  : 
; 148  : 	if( !CSCR_ExpectString( ps, "{", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01HCONENDN@?$HL@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN16@CSCR_Parse

; 149  : 		return false;

	xor	eax, eax
	jmp	$LN1@CSCR_Parse
$LN16@CSCR_Parse:

; 150  : 
; 151  : 	// default value
; 152  : 	ps->buf = COM_ParseFile( ps->buf, result->value );

	mov	eax, DWORD PTR _result$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	DWORD PTR [ecx], eax

; 153  : 
; 154  : 	if( !CSCR_ExpectString( ps, "}", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN17@CSCR_Parse

; 155  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CSCR_Parse
$LN17@CSCR_Parse:

; 156  : 
; 157  : 	if( CSCR_ExpectString( ps, "SetInfo", false, false ))

	push	0
	push	0
	push	OFFSET ??_C@_07CIGMICNE@SetInfo@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN18@CSCR_Parse

; 158  : 		result->flags |= FCVAR_USERINFO;

	mov	eax, DWORD PTR _result$[ebp]
	mov	ecx, DWORD PTR [eax+780]
	or	ecx, 2
	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx+780], ecx
$LN18@CSCR_Parse:

; 159  : 
; 160  : 	if( !CSCR_ExpectString( ps, "}", false, true ))

	push	1
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	mov	eax, DWORD PTR _ps$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN19@CSCR_Parse

; 161  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CSCR_Parse
$LN19@CSCR_Parse:

; 162  : 
; 163  : 	return true;

	mov	eax, 1
$LN1@CSCR_Parse:

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@CSCR_Parse:
	DD	$LN8@CSCR_Parse
	DD	$LN10@CSCR_Parse
	DD	$LN14@CSCR_Parse
	DD	$LN12@CSCR_Parse
_CSCR_ParseSingleCvar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_ParseType
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ps$ = 8						; size = 4
_CSCR_ParseType PROC					; COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 80   : 	int	i;
; 81   : 
; 82   : 	for( i = 1; i < T_COUNT; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CSCR_Parse
$LN2@CSCR_Parse:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CSCR_Parse:
	cmp	DWORD PTR _i$[ebp], 5
	jge	SHORT $LN3@CSCR_Parse

; 83   : 	{
; 84   : 		if( CSCR_ExpectString( ps, cvartypes[i], false, false ))

	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cvartypes[eax*4]
	push	ecx
	mov	edx, DWORD PTR _ps$[ebp]
	push	edx
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@CSCR_Parse

; 85   : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN1@CSCR_Parse
$LN5@CSCR_Parse:

; 86   : 	}

	jmp	SHORT $LN2@CSCR_Parse
$LN3@CSCR_Parse:

; 87   : 
; 88   : 	Con_DPrintf( S_ERROR "Cannot parse %s: Bad type %s\n", ps->filename, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	push	edx
	push	OFFSET ??_C@_0CJ@OGCHCMOK@?$FO1Error?3?$FO7?5Cannot?5parse?5?$CFs?3?5Bad@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH

; 89   : 	return T_NONE;

	xor	eax, eax
$LN1@CSCR_Parse:

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CSCR_ParseType ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_ExpectString
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_ps$ = 8						; size = 4
_pExpect$ = 12						; size = 4
_skip$ = 16						; size = 4
_error$ = 20						; size = 4
_CSCR_ExpectString PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 57   : 	char	*tmp = COM_ParseFile( ps->buf, ps->token );

	mov	eax, DWORD PTR _ps$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_COM_ParseFile
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax

; 58   : 
; 59   : 	if( !Q_stricmp( ps->token, pExpect ) )

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _pExpect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	add	ecx, 4
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@CSCR_Expec

; 60   : 	{
; 61   : 		ps->buf = tmp;

	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], ecx

; 62   : 		return true;

	mov	eax, 1
	jmp	SHORT $LN1@CSCR_Expec
$LN2@CSCR_Expec:

; 63   : 	}
; 64   : 
; 65   : 	if( skip ) ps->buf = tmp;

	cmp	DWORD PTR _skip$[ebp], 0
	je	SHORT $LN3@CSCR_Expec
	mov	eax, DWORD PTR _ps$[ebp]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@CSCR_Expec:

; 66   : 	if( error ) Con_DPrintf( S_ERROR "Syntax error in %s: got \"%s\" instead of \"%s\"\n", ps->filename, ps->token, pExpect );

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN4@CSCR_Expec
	mov	eax, DWORD PTR _pExpect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ps$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _ps$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	push	OFFSET ??_C@_0DJ@LDAHKPMO@?$FO1Error?3?$FO7?5Syntax?5error?5in?5?$CFs?3?5@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
$LN4@CSCR_Expec:

; 67   : 
; 68   : 	return false;

	xor	eax, eax
$LN1@CSCR_Expec:

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CSCR_ExpectString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_WriteGameCVars
_TEXT	SEGMENT
_cvar$1 = -1076						; size = 4
_var$2 = -1072						; size = 788
_start$ = -284						; size = 4
_length$ = -280						; size = 4
_count$ = -276						; size = 4
_success$ = -272					; size = 4
_state$ = -268						; size = 264
__$ArrayPad$ = -4					; size = 4
_cfg$ = 8						; size = 4
_scriptfilename$ = 12					; size = 4
_CSCR_WriteGameCVars PROC				; COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1268				; 000004f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 214  : 	parserstate_t	state = { 0 };

	push	264					; 00000108H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 215  : 	qboolean		success = false;

	mov	DWORD PTR _success$[ebp], 0

; 216  : 	int		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 217  : 	long		length = 0;

	mov	DWORD PTR _length$[ebp], 0

; 218  : 	char		*start;
; 219  : 
; 220  : 	state.filename = scriptfilename;

	mov	eax, DWORD PTR _scriptfilename$[ebp]
	mov	DWORD PTR _state$[ebp+260], eax

; 221  : 	state.buf = start = (char *)FS_LoadFile( scriptfilename, &length, true );

	push	1
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scriptfilename$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _start$[ebp], eax
	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _state$[ebp], edx

; 222  : 
; 223  : 	if( !state.buf || !length )

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN5@CSCR_Write
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN4@CSCR_Write
$LN5@CSCR_Write:

; 224  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CSCR_Write
$LN4@CSCR_Write:

; 225  : 
; 226  : 	Con_DPrintf( "Reading config script file %s\n", scriptfilename );

	mov	eax, DWORD PTR _scriptfilename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@NPFBPPC@Reading?5config?5script?5file?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8

; 227  : 
; 228  : 	if( !CSCR_ParseHeader( &state ))

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_CSCR_ParseHeader
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CSCR_Write

; 229  : 		goto finish;

	jmp	$finish$20
$LN2@CSCR_Write:

; 230  : 
; 231  : 	while( !CSCR_ExpectString( &state, "}", false, false ))

	push	0
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN3@CSCR_Write

; 232  : 	{
; 233  : 		scrvardef_t	var = { 0 };

	push	788					; 00000314H
	push	0
	lea	eax, DWORD PTR _var$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 234  : 
; 235  : 		if( CSCR_ParseSingleCvar( &state, &var ) )

	lea	eax, DWORD PTR _var$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_CSCR_ParseSingleCvar
	add	esp, 8
	test	eax, eax
	je	$LN7@CSCR_Write

; 236  : 		{
; 237  : 			convar_t	*cvar = Cvar_FindVar( var.name );

	push	0
	lea	eax, DWORD PTR _var$2[ebp]
	push	eax
	call	_Cvar_FindVarExt
	add	esp, 8
	mov	DWORD PTR _cvar$1[ebp], eax

; 238  : 
; 239  : 			if( cvar && !FBitSet( cvar->flags, FCVAR_SERVER|FCVAR_ARCHIVE ))

	cmp	DWORD PTR _cvar$1[ebp], 0
	je	SHORT $LN9@CSCR_Write
	mov	eax, DWORD PTR _cvar$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 5
	jne	SHORT $LN9@CSCR_Write

; 240  : 			{
; 241  : 				// cvars will be placed in game.cfg and restored on map start
; 242  : 				if( var.flags & FCVAR_USERINFO )

	mov	eax, DWORD PTR _var$2[ebp+780]
	and	eax, 2
	je	SHORT $LN10@CSCR_Write

; 243  : 					FS_Printf( cfg, "%s \"%s\"\n", var.name, cvar->string );

	mov	eax, DWORD PTR _cvar$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _var$2[ebp]
	push	edx
	push	OFFSET ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN9@CSCR_Write
$LN10@CSCR_Write:

; 244  : 				else FS_Printf( cfg, "%s \"%s\"\n", var.name, cvar->string );

	mov	eax, DWORD PTR _cvar$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR _var$2[ebp]
	push	edx
	push	OFFSET ??_C@_08MHBLPCGN@?$CFs?5?$CC?$CFs?$CC?6@
	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	_FS_Printf
	add	esp, 16					; 00000010H
$LN9@CSCR_Write:

; 245  : 			}
; 246  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 247  : 		}

	jmp	SHORT $LN8@CSCR_Write
$LN7@CSCR_Write:

; 248  : 		else
; 249  : 		{
; 250  : 			break;

	jmp	SHORT $LN3@CSCR_Write
$LN8@CSCR_Write:

; 251  : 		}
; 252  : 
; 253  : 		if( count > 1024 )

	cmp	DWORD PTR _count$[ebp], 1024		; 00000400H
	jle	SHORT $LN12@CSCR_Write

; 254  : 			break;

	jmp	SHORT $LN3@CSCR_Write
$LN12@CSCR_Write:

; 255  : 	}

	jmp	$LN2@CSCR_Write
$LN3@CSCR_Write:

; 256  : 
; 257  : 	if( COM_ParseFile( state.buf, state.token ))

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@CSCR_Write

; 258  : 		Con_DPrintf( S_ERROR "Got extra tokens!\n" );

	push	OFFSET ??_C@_0BO@FDDGDFMI@?$FO1Error?3?$FO7?5Got?5extra?5tokens?$CB?6@
	call	_Con_DPrintf
	add	esp, 4
	jmp	SHORT $finish$20
$LN13@CSCR_Write:

; 259  : 	else success = true;

	mov	DWORD PTR _success$[ebp], 1
$finish$20:

; 260  : finish:
; 261  : 	if( !success )

	cmp	DWORD PTR _success$[ebp], 0
	jne	SHORT $LN15@CSCR_Write

; 262  : 	{
; 263  : 		state.token[sizeof( state.token ) - 1] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	BYTE PTR _state$[ebp+ecx+4], 0

; 264  : 
; 265  : 		if( start && state.buf )

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN16@CSCR_Write
	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN16@CSCR_Write

; 266  : 			Con_DPrintf( S_ERROR "Parse error in %s, byte %d, token %s\n", scriptfilename, (int)( state.buf - start ), state.token );

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _scriptfilename$[ebp]
	push	edx
	push	OFFSET ??_C@_0DB@KMFEMFKE@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5b@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN15@CSCR_Write
$LN16@CSCR_Write:

; 267  : 		else Con_DPrintf( S_ERROR "Parse error in %s, token %s\n", scriptfilename, state.token );

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _scriptfilename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@DFHOHJNK@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5t@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN15@CSCR_Write:

; 268  : 	}
; 269  : 
; 270  : 	if( start ) Mem_Free( start );

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN18@CSCR_Write
	mov	eax, DWORD PTR ?__LINE__Var@?0??CSCR_WriteGameCVars@@9@9
	add	eax, 57					; 00000039H
	push	eax
	push	OFFSET ??_C@_0DG@HFOEJBMM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN18@CSCR_Write:

; 271  : 
; 272  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@CSCR_Write:

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CSCR_WriteGameCVars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\cfgscript.c
;	COMDAT _CSCR_LoadDefaultCVars
_TEXT	SEGMENT
_var$1 = -1072						; size = 788
_start$ = -284						; size = 4
_length$ = -280						; size = 4
_count$ = -276						; size = 4
_success$ = -272					; size = 4
_state$ = -268						; size = 264
__$ArrayPad$ = -4					; size = 4
_scriptfilename$ = 8					; size = 4
_CSCR_LoadDefaultCVars PROC				; COMDAT

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1264				; 000004f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 284  : 	parserstate_t	state = { 0 };

	push	264					; 00000108H
	push	0
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 285  : 	qboolean		success = false;

	mov	DWORD PTR _success$[ebp], 0

; 286  : 	int		count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 287  : 	long		length = 0;

	mov	DWORD PTR _length$[ebp], 0

; 288  : 	char		*start;
; 289  : 
; 290  : 	state.filename = scriptfilename;

	mov	eax, DWORD PTR _scriptfilename$[ebp]
	mov	DWORD PTR _state$[ebp+260], eax

; 291  : 	state.buf = start = (char *)FS_LoadFile( scriptfilename, &length, true );

	push	1
	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scriptfilename$[ebp]
	push	ecx
	call	_FS_LoadFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _start$[ebp], eax
	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _state$[ebp], edx

; 292  : 
; 293  : 	if( !state.buf || !length )

	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN5@CSCR_LoadD
	cmp	DWORD PTR _length$[ebp], 0
	jne	SHORT $LN4@CSCR_LoadD
$LN5@CSCR_LoadD:

; 294  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CSCR_LoadD
$LN4@CSCR_LoadD:

; 295  : 
; 296  : 	Con_DPrintf( "Reading config script file %s\n", scriptfilename );

	mov	eax, DWORD PTR _scriptfilename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@NPFBPPC@Reading?5config?5script?5file?5?$CFs?6@
	call	_Con_DPrintf
	add	esp, 8

; 297  : 
; 298  : 	if( !CSCR_ParseHeader( &state ))

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_CSCR_ParseHeader
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@CSCR_LoadD

; 299  : 		goto finish;

	jmp	$finish$17
$LN2@CSCR_LoadD:

; 300  : 
; 301  : 	while( !CSCR_ExpectString( &state, "}", false, false ))

	push	0
	push	0
	push	OFFSET ??_C@_01CELHOKLL@?$HN@
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_CSCR_ExpectString
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN3@CSCR_LoadD

; 302  : 	{
; 303  : 		scrvardef_t	var = { 0 };

	push	788					; 00000314H
	push	0
	lea	eax, DWORD PTR _var$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 304  : 
; 305  : 		// Create a new object
; 306  : 		if( CSCR_ParseSingleCvar( &state, &var ) )

	lea	eax, DWORD PTR _var$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_CSCR_ParseSingleCvar
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@CSCR_LoadD

; 307  : 		{
; 308  : 			Cvar_Get( var.name, var.value, var.flags|FCVAR_TEMPORARY, var.desc );

	lea	eax, DWORD PTR _var$1[ebp+512]
	push	eax
	mov	ecx, DWORD PTR _var$1[ebp+780]
	or	ecx, 2097152				; 00200000H
	push	ecx
	lea	edx, DWORD PTR _var$1[ebp+256]
	push	edx
	lea	eax, DWORD PTR _var$1[ebp]
	push	eax
	call	_Cvar_Get
	add	esp, 16					; 00000010H

; 309  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 310  : 		}

	jmp	SHORT $LN8@CSCR_LoadD
$LN7@CSCR_LoadD:

; 311  : 		else
; 312  : 			break;

	jmp	SHORT $LN3@CSCR_LoadD
$LN8@CSCR_LoadD:

; 313  : 
; 314  : 		if( count > 1024 )

	cmp	DWORD PTR _count$[ebp], 1024		; 00000400H
	jle	SHORT $LN9@CSCR_LoadD

; 315  : 			break;

	jmp	SHORT $LN3@CSCR_LoadD
$LN9@CSCR_LoadD:

; 316  : 	}

	jmp	$LN2@CSCR_LoadD
$LN3@CSCR_LoadD:

; 317  : 
; 318  : 	if( COM_ParseFile( state.buf, state.token ))

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_COM_ParseFile
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@CSCR_LoadD

; 319  : 		Con_DPrintf( S_ERROR "Got extra tokens!\n" );

	push	OFFSET ??_C@_0BO@FDDGDFMI@?$FO1Error?3?$FO7?5Got?5extra?5tokens?$CB?6@
	call	_Con_DPrintf
	add	esp, 4
	jmp	SHORT $finish$17
$LN10@CSCR_LoadD:

; 320  : 	else success = true;

	mov	DWORD PTR _success$[ebp], 1
$finish$17:

; 321  : finish:
; 322  : 	if( !success )

	cmp	DWORD PTR _success$[ebp], 0
	jne	SHORT $LN12@CSCR_LoadD

; 323  : 	{
; 324  : 		state.token[sizeof( state.token ) - 1] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	BYTE PTR _state$[ebp+ecx+4], 0

; 325  : 		if( start && state.buf )

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN13@CSCR_LoadD
	cmp	DWORD PTR _state$[ebp], 0
	je	SHORT $LN13@CSCR_LoadD

; 326  : 			Con_DPrintf( S_ERROR "Parse error in %s, byte %d, token %s\n", scriptfilename, (int)( state.buf - start ), state.token );

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _scriptfilename$[ebp]
	push	edx
	push	OFFSET ??_C@_0DB@KMFEMFKE@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5b@
	call	_Con_DPrintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN12@CSCR_LoadD
$LN13@CSCR_LoadD:

; 327  : 		else Con_DPrintf( S_ERROR "Parse error in %s, token %s\n", scriptfilename, state.token );

	lea	eax, DWORD PTR _state$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _scriptfilename$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@DFHOHJNK@?$FO1Error?3?$FO7?5Parse?5error?5in?5?$CFs?0?5t@
	call	_Con_DPrintf
	add	esp, 12					; 0000000cH
$LN12@CSCR_LoadD:

; 328  : 	}
; 329  : 
; 330  : 	if( start ) Mem_Free( start );

	cmp	DWORD PTR _start$[ebp], 0
	je	SHORT $LN15@CSCR_LoadD
	mov	eax, DWORD PTR ?__LINE__Var@?0??CSCR_LoadDefaultCVars@@9@9
	add	eax, 47					; 0000002fH
	push	eax
	push	OFFSET ??_C@_0DG@HFOEJBMM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN15@CSCR_LoadD:

; 331  : 
; 332  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]
$LN1@CSCR_LoadD:

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CSCR_LoadDefaultCVars ENDP
_TEXT	ENDS
END
