; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\gl_draw.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
_DATA	ENDS
PUBLIC	_R_Set2DMode
PUBLIC	_R_DrawTileClear
PUBLIC	_R_UploadStretchRaw
PUBLIC	_R_GetTextureParms
PUBLIC	_R_GetSpriteParms
PUBLIC	_R_DrawStretchRaw
PUBLIC	_R_DrawStretchPic
PUBLIC	_R_DrawStretchPicRotate
PUBLIC	_R_DrawStretchPicCircleRotate
PUBLIC	_R_GetSpriteTexture
PUBLIC	??_C@_0DD@JCGDALO@R_DrawStretchRaw?3?5size?5?$CFi?5excee@ ; `string'
PUBLIC	??_C@_0DF@MJPKKANO@R_UploadStretchRaw?3?5size?5?$CFi?5exc@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40f869f000000000
PUBLIC	__real@43b40000
PUBLIC	__real@bf800000
PUBLIC	__real@c0f869f000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_Host_Error:PROC
EXTRN	_cos:PROC
EXTRN	_fabs:PROC
EXTRN	_sin:PROC
EXTRN	__imp__ceil:PROC
EXTRN	_NearestPOW:PROC
EXTRN	_GL_Bind:PROC
EXTRN	_GL_LoadMatrix:PROC
EXTRN	_GL_SetRenderMode:PROC
EXTRN	_GL_Cull:PROC
EXTRN	_R_GetTexture:PROC
EXTRN	_GL_ResampleTexture:PROC
EXTRN	_GL_ApplyTextureParams:PROC
EXTRN	_R_GetSpriteFrame:PROC
EXTRN	_GL_Support:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_cls:BYTE
EXTRN	_RI:BYTE
EXTRN	_tr:BYTE
EXTRN	_glConfig:BYTE
EXTRN	_glState:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0f869f000000000
CONST	SEGMENT
__real@c0f869f000000000 DQ 0c0f869f000000000r	; -99999
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@40f869f000000000
CONST	SEGMENT
__real@40f869f000000000 DQ 040f869f000000000r	; 99999
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DF@MJPKKANO@R_UploadStretchRaw?3?5size?5?$CFi?5exc@
CONST	SEGMENT
??_C@_0DF@MJPKKANO@R_UploadStretchRaw?3?5size?5?$CFi?5exc@ DB 'R_UploadSt'
	DB	'retchRaw: size %i exceeds hardware limits', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JCGDALO@R_DrawStretchRaw?3?5size?5?$CFi?5excee@
CONST	SEGMENT
??_C@_0DD@JCGDALO@R_DrawStretchRaw?3?5size?5?$CFi?5excee@ DB 'R_DrawStret'
	DB	'chRaw: size %i exceeds hardware limits', 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_GetSpriteTexture
_TEXT	SEGMENT
_m_pSpriteModel$ = 8					; size = 4
_frame$ = 12						; size = 4
_R_GetSpriteTexture PROC				; COMDAT

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 56   : 	if( !m_pSpriteModel || m_pSpriteModel->type != mod_sprite || !m_pSpriteModel->cache.data )

	cmp	DWORD PTR _m_pSpriteModel$[ebp], 0
	je	SHORT $LN3@R_GetSprit
	mov	eax, DWORD PTR _m_pSpriteModel$[ebp]
	cmp	DWORD PTR [eax+68], 1
	jne	SHORT $LN3@R_GetSprit
	mov	eax, DWORD PTR _m_pSpriteModel$[ebp]
	cmp	DWORD PTR [eax+388], 0
	jne	SHORT $LN2@R_GetSprit
$LN3@R_GetSprit:

; 57   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@R_GetSprit
$LN2@R_GetSprit:

; 58   : 
; 59   : 	return R_GetSpriteFrame( m_pSpriteModel, frame, 0.0f )->gl_texturenum;

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _frame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_pSpriteModel$[ebp]
	push	ecx
	call	_R_GetSpriteFrame
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+24]
$LN1@R_GetSprit:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetSpriteTexture ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_DrawStretchPicCircleRotate
_TEXT	SEGMENT
tv370 = -144						; size = 8
tv382 = -136						; size = 8
tv380 = -128						; size = 8
tv364 = -120						; size = 8
tv378 = -112						; size = 8
tv376 = -104						; size = 8
tv167 = -104						; size = 4
tv78 = -104						; size = 4
tv170 = -100						; size = 4
tv166 = -100						; size = 4
tv76 = -100						; size = 4
_i_drawcenter$ = -32					; size = 4
_i_gldrawstyle$ = -28					; size = 4
_adjusted_numshapes$ = -24				; size = 4
_adjusted_twicepi$ = -20				; size = 4
_draw_ratio$ = -16					; size = 4
_total_draw$ = -12					; size = 4
_twicePi$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_radius$ = 16						; size = 4
_numshapes$ = 20					; size = 4
_type$ = 24						; size = 4
_thickness$ = 28					; size = 4
_angle_start$ = 32					; size = 4
_angle_end$ = 36					; size = 4
_texnum$ = 40						; size = 4
_xscale$ = 44						; size = 4
_yscale$ = 48						; size = 4
_selfangle$ = 52					; size = 4
_angle$ = 56						; size = 4
_xpivot$ = 60						; size = 4
_ypivot$ = 64						; size = 4
_R_DrawStretchPicCircleRotate PROC			; COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 140  : 	GL_Bind(GL_TEXTURE0, texnum);

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 141  : 
; 142  : 	// Prepare vars
; 143  : 	if (!xscale) xscale = 1.0;

	movss	xmm0, DWORD PTR _xscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@R_DrawStre
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _xscale$[ebp], xmm0
$LN5@R_DrawStre:

; 144  : 	if (!yscale) yscale = 1.0;

	movss	xmm0, DWORD PTR _yscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@R_DrawStre
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _yscale$[ebp], xmm0
$LN6@R_DrawStre:

; 145  : 
; 146  : 	// Initialize increment and pi
; 147  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 148  : 	float twicePi = 2.0f * M_PI;

	movss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _twicePi$[ebp], xmm0

; 149  : 
; 150  : 	// To ensure scaling works properly
; 151  : 	x *= (1.0f / xscale);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _xscale$[ebp]
	mulss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _x$[ebp], xmm0

; 152  : 	y *= (1.0f / yscale);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _yscale$[ebp]
	mulss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _y$[ebp], xmm0

; 153  : 
; 154  : 	// Adjustements happen here
; 155  : 	float total_draw = fabs(max(angle_start, angle_end) - min(angle_start, angle_end));

	movss	xmm0, DWORD PTR _angle_start$[ebp]
	comiss	xmm0, DWORD PTR _angle_end$[ebp]
	jbe	SHORT $LN10@R_DrawStre
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR tv76[ebp], xmm0
	jmp	SHORT $LN11@R_DrawStre
$LN10@R_DrawStre:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	movss	DWORD PTR tv76[ebp], xmm0
$LN11@R_DrawStre:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	comiss	xmm0, DWORD PTR _angle_start$[ebp]
	jbe	SHORT $LN12@R_DrawStre
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR tv78[ebp], xmm0
	jmp	SHORT $LN13@R_DrawStre
$LN12@R_DrawStre:
	movss	xmm0, DWORD PTR _angle_end$[ebp]
	movss	DWORD PTR tv78[ebp], xmm0
$LN13@R_DrawStre:
	movss	xmm0, DWORD PTR tv76[ebp]
	subss	xmm0, DWORD PTR tv78[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _total_draw$[ebp]

; 156  : 	float draw_ratio = total_draw / 360.0f;

	movss	xmm0, DWORD PTR _total_draw$[ebp]
	divss	xmm0, DWORD PTR __real@43b40000
	movss	DWORD PTR _draw_ratio$[ebp], xmm0

; 157  : 	float adjusted_twicepi = twicePi * draw_ratio;

	movss	xmm0, DWORD PTR _twicePi$[ebp]
	mulss	xmm0, DWORD PTR _draw_ratio$[ebp]
	movss	DWORD PTR _adjusted_twicepi$[ebp], xmm0

; 158  : 	int adjusted_numshapes = numshapes;

	mov	eax, DWORD PTR _numshapes$[ebp]
	mov	DWORD PTR _adjusted_numshapes$[ebp], eax

; 159  : 	if (total_draw < 360.0f) adjusted_numshapes = (int)ceil(draw_ratio * (float)adjusted_numshapes);

	movss	xmm0, DWORD PTR __real@43b40000
	comiss	xmm0, DWORD PTR _total_draw$[ebp]
	jbe	SHORT $LN7@R_DrawStre
	cvtsi2ss xmm0, DWORD PTR _adjusted_numshapes$[ebp]
	mulss	xmm0, DWORD PTR _draw_ratio$[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR _adjusted_numshapes$[ebp], eax
$LN7@R_DrawStre:

; 160  : 
; 161  : 	// Push matrix
; 162  : 	pglPushMatrix();

	call	DWORD PTR _pglPushMatrix

; 163  : 
; 164  : 	// draw angle adjustement
; 165  : 	pglTranslatef(x, y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 166  : 	pglRotatef(angle_start, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle_start$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 167  : 	pglTranslatef(-x, -y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 168  : 
; 169  : 	// Rotation around itself
; 170  : 	pglTranslatef(x, y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 171  : 	pglRotatef(selfangle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 172  : 	pglTranslatef(-x, -y, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 173  : 
; 174  : 	// Rotation around defined pivot
; 175  : 	pglTranslatef(xpivot, ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 176  : 	pglRotatef(angle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 177  : 	pglTranslatef(-xpivot, -ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 178  : 
; 179  : 	// Overall scale
; 180  : 	pglScalef(xscale, yscale, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglScalef

; 181  : 
; 182  : 	// Computer GL draw style and whether or not we draw the center
; 183  : 	// type 0 is either a full circle or arc, depending on start and end angle
; 184  : 	// type 1 is a hollow segment
; 185  : 	// type 2 is a hollow sector
; 186  : 	// type 3 is a filled sector or full disc, depending on start and end angle
; 187  : 	// type 4 is a filled segment
; 188  : 	int i_gldrawstyle = (type == 3 || type == 4) ? GL_TRIANGLE_FAN : ((type != 0) ? GL_LINE_LOOP : GL_LINE_STRIP);

	cmp	DWORD PTR _type$[ebp], 3
	je	SHORT $LN14@R_DrawStre
	cmp	DWORD PTR _type$[ebp], 4
	je	SHORT $LN14@R_DrawStre
	cmp	DWORD PTR _type$[ebp], 0
	je	SHORT $LN15@R_DrawStre
	mov	DWORD PTR tv166[ebp], 2
	jmp	SHORT $LN16@R_DrawStre
$LN15@R_DrawStre:
	mov	DWORD PTR tv166[ebp], 3
$LN16@R_DrawStre:
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv167[ebp], eax
	jmp	SHORT $LN17@R_DrawStre
$LN14@R_DrawStre:
	mov	DWORD PTR tv167[ebp], 6
$LN17@R_DrawStre:
	mov	ecx, DWORD PTR tv167[ebp]
	mov	DWORD PTR _i_gldrawstyle$[ebp], ecx

; 189  : 	int i_drawcenter = (type % 2) ? 1 : 0;

	mov	eax, DWORD PTR _type$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN20@R_DrawStre
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN20@R_DrawStre:
	test	eax, eax
	je	SHORT $LN18@R_DrawStre
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN19@R_DrawStre
$LN18@R_DrawStre:
	mov	DWORD PTR tv170[ebp], 0
$LN19@R_DrawStre:
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _i_drawcenter$[ebp], ecx

; 190  : 
; 191  : 	// Draw the thing
; 192  : 	pglLineWidth(thickness);

	push	ecx
	movss	xmm0, DWORD PTR _thickness$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 193  : 	pglBegin(i_gldrawstyle);

	mov	eax, DWORD PTR _i_gldrawstyle$[ebp]
	push	eax
	call	DWORD PTR _pglBegin

; 194  : 	if (i_drawcenter) pglVertex2f(x, y); // draw center of circle

	cmp	DWORD PTR _i_drawcenter$[ebp], 0
	je	SHORT $LN8@R_DrawStre
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f
$LN8@R_DrawStre:

; 195  : 	for (i = 0; i <= adjusted_numshapes; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@R_DrawStre
$LN2@R_DrawStre:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@R_DrawStre:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _adjusted_numshapes$[ebp]
	jg	$LN3@R_DrawStre

; 196  : 		pglVertex2f(

	cvtss2sd xmm0, DWORD PTR _y$[ebp]
	movss	xmm1, DWORD PTR _radius$[ebp]
	mulss	xmm1, DWORD PTR _yscale$[ebp]
	cvtss2sd xmm1, xmm1
	cvtsi2ss xmm2, DWORD PTR _i$[ebp]
	mulss	xmm2, DWORD PTR _adjusted_twicepi$[ebp]
	cvtsi2ss xmm3, DWORD PTR _adjusted_numshapes$[ebp]
	divss	xmm2, xmm3
	cvtss2sd xmm2, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv376[ebp], xmm0
	movsd	QWORD PTR tv378[ebp], xmm1
	call	_sin
	add	esp, 8
	fstp	QWORD PTR tv364[ebp]
	movsd	xmm0, QWORD PTR tv378[ebp]
	mulsd	xmm0, QWORD PTR tv364[ebp]
	movsd	xmm1, QWORD PTR tv376[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _x$[ebp]
	movss	xmm1, DWORD PTR _radius$[ebp]
	mulss	xmm1, DWORD PTR _xscale$[ebp]
	cvtss2sd xmm1, xmm1
	cvtsi2ss xmm2, DWORD PTR _i$[ebp]
	mulss	xmm2, DWORD PTR _adjusted_twicepi$[ebp]
	cvtsi2ss xmm3, DWORD PTR _adjusted_numshapes$[ebp]
	divss	xmm2, xmm3
	cvtss2sd xmm2, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm2
	movsd	QWORD PTR tv380[ebp], xmm0
	movsd	QWORD PTR tv382[ebp], xmm1
	call	_cos
	add	esp, 8
	fstp	QWORD PTR tv370[ebp]
	movsd	xmm0, QWORD PTR tv382[ebp]
	mulsd	xmm0, QWORD PTR tv370[ebp]
	movsd	xmm1, QWORD PTR tv380[ebp]
	addsd	xmm1, xmm0
	cvtsd2ss xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 197  : 			x + (radius * xscale * cos(i * adjusted_twicepi / adjusted_numshapes)),
; 198  : 			y + (radius * yscale * sin(i * adjusted_twicepi / adjusted_numshapes))
; 199  : 		);
; 200  : 	}

	jmp	$LN2@R_DrawStre
$LN3@R_DrawStre:

; 201  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 202  : 	pglLineWidth(1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglLineWidth

; 203  : 	// Return to normal
; 204  : 	pglPopMatrix();

	call	DWORD PTR _pglPopMatrix

; 205  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStretchPicCircleRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_DrawStretchPicRotate
_TEXT	SEGMENT
_invyscale$ = -8					; size = 4
_invxscale$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_s1$ = 24						; size = 4
_t1$ = 28						; size = 4
_s2$ = 32						; size = 4
_t2$ = 36						; size = 4
_texnum$ = 40						; size = 4
_xscale$ = 44						; size = 4
_yscale$ = 48						; size = 4
_selfangle$ = 52					; size = 4
_angle$ = 56						; size = 4
_xpivot$ = 60						; size = 4
_ypivot$ = 64						; size = 4
_selfxpivot$ = 68					; size = 4
_selfypivot$ = 72					; size = 4
_R_DrawStretchPicRotate PROC				; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 93   : 	GL_Bind(GL_TEXTURE0, texnum);

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 94   : 
; 95   : 	if (!xscale) xscale = 1.0;

	movss	xmm0, DWORD PTR _xscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@R_DrawStre
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _xscale$[ebp], xmm0
$LN2@R_DrawStre:

; 96   : 	if (!yscale) yscale = 1.0;

	movss	xmm0, DWORD PTR _yscale$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@R_DrawStre
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _yscale$[ebp], xmm0
$LN3@R_DrawStre:

; 97   : 
; 98   : 	float invxscale = 1 / xscale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _xscale$[ebp]
	movss	DWORD PTR _invxscale$[ebp], xmm0

; 99   : 	float invyscale = 1 / yscale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _yscale$[ebp]
	movss	DWORD PTR _invyscale$[ebp], xmm0

; 100  : 
; 101  : 	// Self pivot check
; 102  : 	if (selfxpivot == -1 || selfypivot == -1)

	movss	xmm0, DWORD PTR _selfxpivot$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@R_DrawStre
	movss	xmm0, DWORD PTR _selfypivot$[ebp]
	ucomiss	xmm0, DWORD PTR __real@bf800000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@R_DrawStre
$LN5@R_DrawStre:

; 103  : 	{
; 104  : 		selfxpivot = x + w / 2;

	movss	xmm0, DWORD PTR _w$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _selfxpivot$[ebp], xmm0

; 105  : 		selfypivot = y + h / 2;

	movss	xmm0, DWORD PTR _h$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _selfypivot$[ebp], xmm0
$LN4@R_DrawStre:

; 106  : 	}
; 107  : 
; 108  : 	pglPushMatrix();

	call	DWORD PTR _pglPushMatrix

; 109  : 	pglTranslatef(xpivot, ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 110  : 	pglRotatef(angle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _angle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 111  : 	pglTranslatef(-xpivot, -ypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _ypivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _xpivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 112  : 	pglTranslatef(selfxpivot, selfypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfypivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfxpivot$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 113  : 	pglRotatef(selfangle, 0.0, 0.0, 1.0);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _selfangle$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglRotatef

; 114  : 	pglTranslatef(-selfxpivot, -selfypivot, 0.0);

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _selfypivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _selfxpivot$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTranslatef

; 115  : 
; 116  : 	pglBegin(GL_QUADS);

	push	7
	call	DWORD PTR _pglBegin

; 117  : 		pglTexCoord2f(s1, t1);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 118  : 		pglVertex2f(x, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 119  : 
; 120  : 		pglTexCoord2f(s2, t1);

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 121  : 		pglVertex2f(x + w, y);

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 122  : 
; 123  : 		pglTexCoord2f(s2, t2);

	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 124  : 		pglVertex2f(x + w, y + h);

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 125  : 
; 126  : 		pglTexCoord2f(s1, t2);

	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 127  : 		pglVertex2f(x, y + h);

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 128  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 129  : 
; 130  : 	pglPopMatrix();

	call	DWORD PTR _pglPopMatrix

; 131  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStretchPicRotate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_DrawStretchPic
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_s1$ = 24						; size = 4
_t1$ = 28						; size = 4
_s2$ = 32						; size = 4
_t2$ = 36						; size = 4
_texnum$ = 40						; size = 4
_R_DrawStretchPic PROC					; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 69   : 	GL_Bind( GL_TEXTURE0, texnum );

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 70   : 
; 71   : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 72   : 		pglTexCoord2f( s1, t1 );

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 73   : 		pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 74   : 
; 75   : 		pglTexCoord2f( s2, t1 );

	push	ecx
	movss	xmm0, DWORD PTR _t1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 76   : 		pglVertex2f( x + w, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 77   : 
; 78   : 		pglTexCoord2f( s2, t2 );

	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s2$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 79   : 		pglVertex2f( x + w, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 80   : 
; 81   : 		pglTexCoord2f( s1, t2 );

	push	ecx
	movss	xmm0, DWORD PTR _t2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _s1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 82   : 		pglVertex2f( x, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 83   : 	pglEnd();

	call	DWORD PTR _pglEnd

; 84   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStretchPic ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_DrawStretchRaw
_TEXT	SEGMENT
_height$1 = -16						; size = 4
_width$2 = -12						; size = 4
_tex$ = -8						; size = 4
_raw$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_cols$ = 24						; size = 4
_rows$ = 28						; size = 4
_data$ = 32						; size = 4
_dirty$ = 36						; size = 4
_R_DrawStretchRaw PROC					; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 247  : 	byte		*raw = NULL;

	mov	DWORD PTR _raw$[ebp], 0

; 248  : 	gl_texture_t	*tex;
; 249  : 
; 250  : 	if( !GL_Support( GL_ARB_TEXTURE_NPOT_EXT ))

	push	14					; 0000000eH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_DrawStre

; 251  : 	{
; 252  : 		int	width = 1, height = 1;

	mov	DWORD PTR _width$2[ebp], 1
	mov	DWORD PTR _height$1[ebp], 1

; 253  : 	
; 254  : 		// check the dimensions
; 255  : 		width = NearestPOW( cols, true );

	push	1
	mov	eax, DWORD PTR _cols$[ebp]
	push	eax
	call	_NearestPOW
	add	esp, 8
	mov	DWORD PTR _width$2[ebp], eax

; 256  : 		height = NearestPOW( rows, false );

	push	0
	mov	eax, DWORD PTR _rows$[ebp]
	push	eax
	call	_NearestPOW
	add	esp, 8
	mov	DWORD PTR _height$1[ebp], eax

; 257  : 
; 258  : 		if( cols != width || rows != height )

	mov	eax, DWORD PTR _cols$[ebp]
	cmp	eax, DWORD PTR _width$2[ebp]
	jne	SHORT $LN5@R_DrawStre
	mov	eax, DWORD PTR _rows$[ebp]
	cmp	eax, DWORD PTR _height$1[ebp]
	je	SHORT $LN4@R_DrawStre
$LN5@R_DrawStre:

; 259  : 		{
; 260  : 			raw = GL_ResampleTexture( data, cols, rows, width, height, false );

	push	0
	mov	eax, DWORD PTR _height$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _rows$[ebp]
	push	edx
	mov	eax, DWORD PTR _cols$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_GL_ResampleTexture
	add	esp, 24					; 00000018H
	mov	DWORD PTR _raw$[ebp], eax

; 261  : 			cols = width;

	mov	eax, DWORD PTR _width$2[ebp]
	mov	DWORD PTR _cols$[ebp], eax

; 262  : 			rows = height;

	mov	eax, DWORD PTR _height$1[ebp]
	mov	DWORD PTR _rows$[ebp], eax
$LN4@R_DrawStre:

; 263  : 		}
; 264  : 	}

	jmp	SHORT $LN3@R_DrawStre
$LN2@R_DrawStre:

; 265  : 	else
; 266  : 	{
; 267  : 		raw = (byte *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _raw$[ebp], eax
$LN3@R_DrawStre:

; 268  : 	}
; 269  : 
; 270  : 	if( cols > glConfig.max_2d_texture_size )

	mov	eax, DWORD PTR _cols$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jle	SHORT $LN6@R_DrawStre

; 271  : 		Host_Error( "R_DrawStretchRaw: size %i exceeds hardware limits\n", cols );

	mov	eax, DWORD PTR _cols$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@JCGDALO@R_DrawStretchRaw?3?5size?5?$CFi?5excee@
	call	_Host_Error
	add	esp, 8
$LN6@R_DrawStre:

; 272  : 	if( rows > glConfig.max_2d_texture_size )

	mov	eax, DWORD PTR _rows$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jle	SHORT $LN7@R_DrawStre

; 273  : 		Host_Error( "R_DrawStretchRaw: size %i exceeds hardware limits\n", rows );

	mov	eax, DWORD PTR _rows$[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@JCGDALO@R_DrawStretchRaw?3?5size?5?$CFi?5excee@
	call	_Host_Error
	add	esp, 8
$LN7@R_DrawStre:

; 274  : 
; 275  : 	pglDisable( GL_BLEND );

	push	3042					; 00000be2H
	call	DWORD PTR _pglDisable

; 276  : 	pglDisable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglDisable

; 277  : 	pglTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE );

	push	7681					; 00001e01H
	push	8704					; 00002200H
	push	8960					; 00002300H
	call	DWORD PTR _pglTexEnvi

; 278  : 
; 279  : 	tex = R_GetTexture( tr.cinTexture );

	mov	eax, DWORD PTR _tr+1080
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax

; 280  : 	GL_Bind( GL_TEXTURE0, tr.cinTexture );

	mov	eax, DWORD PTR _tr+1080
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 281  : 
; 282  : 	if( cols == tex->width && rows == tex->height )

	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+260]
	cmp	DWORD PTR _cols$[ebp], ecx
	jne	SHORT $LN8@R_DrawStre
	mov	eax, DWORD PTR _tex$[ebp]
	movzx	ecx, WORD PTR [eax+262]
	cmp	DWORD PTR _rows$[ebp], ecx
	jne	SHORT $LN8@R_DrawStre

; 283  : 	{
; 284  : 		if( dirty )

	cmp	DWORD PTR _dirty$[ebp], 0
	je	SHORT $LN10@R_DrawStre

; 285  : 		{
; 286  : 			pglTexSubImage2D( GL_TEXTURE_2D, 0, 0, 0, cols, rows, GL_BGRA, GL_UNSIGNED_BYTE, raw );

	mov	eax, DWORD PTR _raw$[ebp]
	push	eax
	push	5121					; 00001401H
	push	32993					; 000080e1H
	mov	ecx, DWORD PTR _rows$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cols$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglTexSubImage2D
$LN10@R_DrawStre:

; 287  : 		}
; 288  : 	}

	jmp	SHORT $LN11@R_DrawStre
$LN8@R_DrawStre:

; 289  : 	else
; 290  : 	{
; 291  : 		tex->size = cols * rows * 4;

	mov	eax, DWORD PTR _cols$[ebp]
	imul	eax, DWORD PTR _rows$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 292  : 		tex->width = cols;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _cols$[ebp]
	mov	WORD PTR [eax+260], cx

; 293  : 		tex->height = rows;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _rows$[ebp]
	mov	WORD PTR [eax+262], cx

; 294  : 		if( dirty )

	cmp	DWORD PTR _dirty$[ebp], 0
	je	SHORT $LN11@R_DrawStre

; 295  : 		{
; 296  : 			pglTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, cols, rows, 0, GL_BGRA, GL_UNSIGNED_BYTE, raw );

	mov	eax, DWORD PTR _raw$[ebp]
	push	eax
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	mov	ecx, DWORD PTR _rows$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cols$[ebp]
	push	edx
	push	6408					; 00001908H
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglTexImage2D
$LN11@R_DrawStre:

; 297  : 		}
; 298  : 	}
; 299  : 
; 300  : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 301  : 	pglTexCoord2f( 0, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 302  : 	pglVertex2f( x, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 303  : 	pglTexCoord2f( 1, 0 );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 304  : 	pglVertex2f( x + w, y );

	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 305  : 	pglTexCoord2f( 1, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 306  : 	pglVertex2f( x + w, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR _w$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 307  : 	pglTexCoord2f( 0, 1 );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 308  : 	pglVertex2f( x, y + h );

	movss	xmm0, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR _h$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 309  : 	pglEnd();

	call	DWORD PTR _pglEnd

; 310  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawStretchRaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_GetSpriteParms
_TEXT	SEGMENT
_pFrame$ = -4						; size = 4
_frameWidth$ = 8					; size = 4
_frameHeight$ = 12					; size = 4
_numFrames$ = 16					; size = 4
_currentFrame$ = 20					; size = 4
_pSprite$ = 24						; size = 4
_R_GetSpriteParms PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 44   : 	mspriteframe_t	*pFrame;
; 45   : 
; 46   : 	if( !pSprite || pSprite->type != mod_sprite ) return; // bad model ?

	cmp	DWORD PTR _pSprite$[ebp], 0
	je	SHORT $LN3@R_GetSprit
	mov	eax, DWORD PTR _pSprite$[ebp]
	cmp	DWORD PTR [eax+68], 1
	je	SHORT $LN2@R_GetSprit
$LN3@R_GetSprit:
	jmp	SHORT $LN6@R_GetSprit
$LN2@R_GetSprit:

; 47   : 	pFrame = R_GetSpriteFrame( pSprite, currentFrame, 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _currentFrame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSprite$[ebp]
	push	ecx
	call	_R_GetSpriteFrame
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFrame$[ebp], eax

; 48   : 
; 49   : 	if( frameWidth ) *frameWidth = pFrame->width;

	cmp	DWORD PTR _frameWidth$[ebp], 0
	je	SHORT $LN4@R_GetSprit
	mov	eax, DWORD PTR _frameWidth$[ebp]
	mov	ecx, DWORD PTR _pFrame$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN4@R_GetSprit:

; 50   : 	if( frameHeight ) *frameHeight = pFrame->height;

	cmp	DWORD PTR _frameHeight$[ebp], 0
	je	SHORT $LN5@R_GetSprit
	mov	eax, DWORD PTR _frameHeight$[ebp]
	mov	ecx, DWORD PTR _pFrame$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN5@R_GetSprit:

; 51   : 	if( numFrames ) *numFrames = pSprite->numframes;

	cmp	DWORD PTR _numFrames$[ebp], 0
	je	SHORT $LN6@R_GetSprit
	mov	eax, DWORD PTR _numFrames$[ebp]
	mov	ecx, DWORD PTR _pSprite$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax], edx
$LN6@R_GetSprit:

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetSpriteParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_GetTextureParms
_TEXT	SEGMENT
_glt$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_texnum$ = 16						; size = 4
_R_GetTextureParms PROC					; COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 27   : 	gl_texture_t	*glt;
; 28   : 
; 29   : 	glt = R_GetTexture( texnum );

	mov	eax, DWORD PTR _texnum$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 30   : 	if( w ) *w = glt->srcWidth;

	cmp	DWORD PTR _w$[ebp], 0
	je	SHORT $LN2@R_GetTextu
	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+256]
	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@R_GetTextu:

; 31   : 	if( h ) *h = glt->srcHeight;

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN1@R_GetTextu
	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+258]
	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@R_GetTextu:

; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_GetTextureParms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_UploadStretchRaw
_TEXT	SEGMENT
tv80 = -80						; size = 4
tv76 = -80						; size = 4
tv79 = -76						; size = 4
tv75 = -76						; size = 4
_tex$ = -8						; size = 4
_raw$ = -4						; size = 4
_texture$ = 8						; size = 4
_cols$ = 12						; size = 4
_rows$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_data$ = 28						; size = 4
_R_UploadStretchRaw PROC				; COMDAT

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 319  : 	byte		*raw = NULL;

	mov	DWORD PTR _raw$[ebp], 0

; 320  : 	gl_texture_t	*tex;
; 321  : 
; 322  : 	if( !GL_Support( GL_ARB_TEXTURE_NPOT_EXT ))

	push	14					; 0000000eH
	call	_GL_Support
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@R_UploadSt

; 323  : 	{
; 324  : 		// check the dimensions
; 325  : 		width = NearestPOW( width, true );

	push	1
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	_NearestPOW
	add	esp, 8
	mov	DWORD PTR _width$[ebp], eax

; 326  : 		height = NearestPOW( height, false );

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	call	_NearestPOW
	add	esp, 8
	mov	DWORD PTR _height$[ebp], eax

; 327  : 	}

	jmp	SHORT $LN3@R_UploadSt
$LN2@R_UploadSt:

; 328  : 	else
; 329  : 	{
; 330  : 		width = bound( 128, width, glConfig.max_2d_texture_size );

	cmp	DWORD PTR _width$[ebp], 128		; 00000080H
	jl	SHORT $LN12@R_UploadSt
	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jge	SHORT $LN10@R_UploadSt
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $LN11@R_UploadSt
$LN10@R_UploadSt:
	mov	edx, DWORD PTR _glConfig+60
	mov	DWORD PTR tv75[ebp], edx
$LN11@R_UploadSt:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN13@R_UploadSt
$LN12@R_UploadSt:
	mov	DWORD PTR tv76[ebp], 128		; 00000080H
$LN13@R_UploadSt:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _width$[ebp], ecx

; 331  : 		height = bound( 128, height, glConfig.max_2d_texture_size );

	cmp	DWORD PTR _height$[ebp], 128		; 00000080H
	jl	SHORT $LN16@R_UploadSt
	mov	eax, DWORD PTR _height$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jge	SHORT $LN14@R_UploadSt
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN15@R_UploadSt
$LN14@R_UploadSt:
	mov	edx, DWORD PTR _glConfig+60
	mov	DWORD PTR tv79[ebp], edx
$LN15@R_UploadSt:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN17@R_UploadSt
$LN16@R_UploadSt:
	mov	DWORD PTR tv80[ebp], 128		; 00000080H
$LN17@R_UploadSt:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _height$[ebp], ecx
$LN3@R_UploadSt:

; 332  : 	}
; 333  : 
; 334  : 	if( cols != width || rows != height )

	mov	eax, DWORD PTR _cols$[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jne	SHORT $LN6@R_UploadSt
	mov	eax, DWORD PTR _rows$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	je	SHORT $LN4@R_UploadSt
$LN6@R_UploadSt:

; 335  : 	{
; 336  : 		raw = GL_ResampleTexture( data, cols, rows, width, height, false );

	push	0
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rows$[ebp]
	push	edx
	mov	eax, DWORD PTR _cols$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_GL_ResampleTexture
	add	esp, 24					; 00000018H
	mov	DWORD PTR _raw$[ebp], eax

; 337  : 		cols = width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cols$[ebp], eax

; 338  : 		rows = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _rows$[ebp], eax

; 339  : 	}

	jmp	SHORT $LN5@R_UploadSt
$LN4@R_UploadSt:

; 340  : 	else
; 341  : 	{
; 342  : 		raw = (byte *)data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _raw$[ebp], eax
$LN5@R_UploadSt:

; 343  : 	}
; 344  : 
; 345  : 	if( cols > glConfig.max_2d_texture_size )

	mov	eax, DWORD PTR _cols$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jle	SHORT $LN7@R_UploadSt

; 346  : 		Host_Error( "R_UploadStretchRaw: size %i exceeds hardware limits\n", cols );

	mov	eax, DWORD PTR _cols$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@MJPKKANO@R_UploadStretchRaw?3?5size?5?$CFi?5exc@
	call	_Host_Error
	add	esp, 8
$LN7@R_UploadSt:

; 347  : 	if( rows > glConfig.max_2d_texture_size )

	mov	eax, DWORD PTR _rows$[ebp]
	cmp	eax, DWORD PTR _glConfig+60
	jle	SHORT $LN8@R_UploadSt

; 348  : 		Host_Error( "R_UploadStretchRaw: size %i exceeds hardware limits\n", rows );

	mov	eax, DWORD PTR _rows$[ebp]
	push	eax
	push	OFFSET ??_C@_0DF@MJPKKANO@R_UploadStretchRaw?3?5size?5?$CFi?5exc@
	call	_Host_Error
	add	esp, 8
$LN8@R_UploadSt:

; 349  : 
; 350  : 	tex = R_GetTexture( texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _tex$[ebp], eax

; 351  : 	GL_Bind( GL_KEEP_UNIT, texture );

	mov	eax, DWORD PTR _texture$[ebp]
	push	eax
	push	-1
	call	_GL_Bind
	add	esp, 8

; 352  : 	tex->width = cols;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _cols$[ebp]
	mov	WORD PTR [eax+260], cx

; 353  : 	tex->height = rows;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	cx, WORD PTR _rows$[ebp]
	mov	WORD PTR [eax+262], cx

; 354  : 
; 355  : 	pglTexImage2D( GL_TEXTURE_2D, 0, tex->format, cols, rows, 0, GL_BGRA, GL_UNSIGNED_BYTE, raw );

	mov	eax, DWORD PTR _raw$[ebp]
	push	eax
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	mov	ecx, DWORD PTR _rows$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cols$[ebp]
	push	edx
	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	push	0
	push	3553					; 00000de1H
	call	DWORD PTR _pglTexImage2D

; 356  : 	GL_ApplyTextureParams( tex );

	mov	eax, DWORD PTR _tex$[ebp]
	push	eax
	call	_GL_ApplyTextureParams
	add	esp, 4

; 357  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_UploadStretchRaw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_DrawTileClear
_TEXT	SEGMENT
_glt$ = -12						; size = 4
_th$ = -8						; size = 4
_tw$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_R_DrawTileClear PROC					; COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 217  : 	float		tw, th;
; 218  : 	gl_texture_t	*glt;
; 219  : 
; 220  : 	GL_SetRenderMode( kRenderNormal );

	push	0
	call	_GL_SetRenderMode
	add	esp, 4

; 221  : 	pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 222  : 	GL_Bind( GL_TEXTURE0, cls.tileImage );

	mov	eax, DWORD PTR _cls+290624
	push	eax
	push	0
	call	_GL_Bind
	add	esp, 8

; 223  : 
; 224  : 	glt = R_GetTexture( cls.tileImage );

	mov	eax, DWORD PTR _cls+290624
	push	eax
	call	_R_GetTexture
	add	esp, 4
	mov	DWORD PTR _glt$[ebp], eax

; 225  : 	tw = glt->srcWidth;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+256]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _tw$[ebp], xmm0

; 226  : 	th = glt->srcHeight;

	mov	eax, DWORD PTR _glt$[ebp]
	movzx	ecx, WORD PTR [eax+258]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _th$[ebp], xmm0

; 227  : 
; 228  : 	pglBegin( GL_QUADS );

	push	7
	call	DWORD PTR _pglBegin

; 229  : 		pglTexCoord2f( x / tw, y / th );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	divss	xmm0, DWORD PTR _th$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR _tw$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 230  : 		pglVertex2f( x, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 231  : 		pglTexCoord2f((x + w) / tw, y / th );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	divss	xmm0, DWORD PTR _th$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _tw$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 232  : 		pglVertex2f( x + w, y );

	cvtsi2ss xmm0, DWORD PTR _y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 233  : 		pglTexCoord2f((x + w) / tw, (y + h) / th );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _th$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR _tw$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 234  : 		pglVertex2f( x + w, y + h );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	cvtsi2ss xmm0, ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 235  : 		pglTexCoord2f( x / tw, (y + h) / th );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	divss	xmm0, DWORD PTR _th$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	divss	xmm0, DWORD PTR _tw$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglTexCoord2f

; 236  : 		pglVertex2f( x, y + h );

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	cvtsi2ss xmm0, DWORD PTR _x$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglVertex2f

; 237  : 	pglEnd ();

	call	DWORD PTR _pglEnd

; 238  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_DrawTileClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\gl_draw.c
;	COMDAT _R_Set2DMode
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_R_Set2DMode PROC					; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 366  : 	if( enable )

	cmp	DWORD PTR _enable$[ebp], 0
	je	$LN2@R_Set2DMod

; 367  : 	{
; 368  : 		if( glState.in2DMode )

	cmp	DWORD PTR _glState+572, 0
	je	SHORT $LN4@R_Set2DMod

; 369  : 			return;

	jmp	$LN3@R_Set2DMod
$LN4@R_Set2DMod:

; 370  : 
; 371  : 		// set 2D virtual screen size
; 372  : 		pglViewport( 0, 0, glState.width, glState.height );

	mov	eax, DWORD PTR _glState+4
	push	eax
	mov	ecx, DWORD PTR _glState
	push	ecx
	push	0
	push	0
	call	DWORD PTR _pglViewport

; 373  : 		pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR _pglMatrixMode

; 374  : 		pglLoadIdentity();

	call	DWORD PTR _pglLoadIdentity

; 375  : 		pglOrtho( 0, glState.width, glState.height, 0, -99999, 99999 );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@40f869f000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@c0f869f000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR _glState+4
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtsi2sd xmm0, DWORD PTR _glState
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR _pglOrtho

; 376  : 		pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 377  : 		pglLoadIdentity();

	call	DWORD PTR _pglLoadIdentity

; 378  : 
; 379  : 		GL_Cull( GL_NONE );

	push	0
	call	_GL_Cull
	add	esp, 4

; 380  : 
; 381  : 		pglDepthMask( GL_FALSE );

	push	0
	call	DWORD PTR _pglDepthMask

; 382  : 		pglDisable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglDisable

; 383  : 		pglEnable( GL_ALPHA_TEST );

	push	3008					; 00000bc0H
	call	DWORD PTR _pglEnable

; 384  : 		pglColor4f( 1.0f, 1.0f, 1.0f, 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR _pglColor4f

; 385  : 
; 386  : 		glState.in2DMode = true;

	mov	DWORD PTR _glState+572, 1

; 387  : 		RI.currententity = NULL;

	mov	DWORD PTR _RI+28, 0

; 388  : 		RI.currentmodel = NULL;

	mov	DWORD PTR _RI+32, 0

; 389  : 	}

	jmp	SHORT $LN3@R_Set2DMod
$LN2@R_Set2DMod:

; 390  : 	else
; 391  : 	{
; 392  : 		pglDepthMask( GL_TRUE );

	push	1
	call	DWORD PTR _pglDepthMask

; 393  : 		pglEnable( GL_DEPTH_TEST );

	push	2929					; 00000b71H
	call	DWORD PTR _pglEnable

; 394  : 		glState.in2DMode = false;

	mov	DWORD PTR _glState+572, 0

; 395  : 
; 396  : 		pglMatrixMode( GL_PROJECTION );

	push	5889					; 00001701H
	call	DWORD PTR _pglMatrixMode

; 397  : 		GL_LoadMatrix( RI.projectionMatrix );

	push	OFFSET _RI+648
	call	_GL_LoadMatrix
	add	esp, 4

; 398  : 
; 399  : 		pglMatrixMode( GL_MODELVIEW );

	push	5888					; 00001700H
	call	DWORD PTR _pglMatrixMode

; 400  : 		GL_LoadMatrix( RI.worldviewMatrix );

	push	OFFSET _RI+520
	call	_GL_LoadMatrix
	add	esp, 4

; 401  : 
; 402  : 		GL_Cull( GL_FRONT );

	push	1028					; 00000404H
	call	_GL_Cull
	add	esp, 4
$LN3@R_Set2DMod:

; 403  : 	}
; 404  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_R_Set2DMode ENDP
_TEXT	ENDS
END
