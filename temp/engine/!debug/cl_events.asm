; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_events.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CL_ParseEvent
PUBLIC	_CL_ParseReliableEvent
PUBLIC	_CL_SetEventIndex
PUBLIC	_CL_QueueEvent
PUBLIC	_CL_PlaybackEvent
PUBLIC	_CL_RegisterEvent
PUBLIC	_CL_ResetEvent
PUBLIC	_CL_EventIndex
PUBLIC	_CL_FireEvents
PUBLIC	_CL_CalcPlayerVelocity
PUBLIC	_CL_DescribeEvent
PUBLIC	_CL_FireEvent
PUBLIC	_CL_FindEmptyEvent
PUBLIC	_CL_FindUnreliableEvent
PUBLIC	??_C@_08KDMLJNJ@?$CFi?5?$CFf?5?$CFs@		; `string'
PUBLIC	?__LINE__Var@?0??CL_RegisterEvent@@9@9		; `CL_RegisterEvent'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@DHCGFLEM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0CL@LJIHFNFD@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@ ; `string'
PUBLIC	??_C@_0CI@BCEPDBOC@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@ ; `string'
PUBLIC	??_C@_0DE@BKCJEFDK@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5in@ ; `string'
PUBLIC	??_C@_0DJ@NDKPCIEN@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5ev@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@c0400000
EXTRN	_memset:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	_COM_NormalizeAngles:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_NXPrintf:PROC
EXTRN	_MSG_ReadOneBit:PROC
EXTRN	_MSG_ReadUBitLong:PROC
EXTRN	_MSG_ReadWord:PROC
EXTRN	_MSG_ReadDeltaEvent:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_cl_showevents:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0DJ@NDKPCIEN@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5ev@
CONST	SEGMENT
??_C@_0DJ@NDKPCIEN@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5ev@ DB '^1Error'
	DB	':^7 CL_PlaybackEvent: event %i was not precached', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BKCJEFDK@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5in@
CONST	SEGMENT
??_C@_0DE@BKCJEFDK@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5in@ DB '^1Error'
	DB	':^7 CL_PlaybackEvent: invalid eventindex %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BCEPDBOC@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@
CONST	SEGMENT
??_C@_0CI@BCEPDBOC@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@ DB '^1E'
	DB	'rror:^7 CL_FireEvent: %s not hooked', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LJIHFNFD@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@
CONST	SEGMENT
??_C@_0CL@LJIHFNFD@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@ DB '^1E'
	DB	'rror:^7 CL_FireEvent: %s not precached', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DHCGFLEM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DG@DHCGFLEM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_events.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_RegisterEvent@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_RegisterEvent@@9@9 DD 09cH		; `CL_RegisterEvent'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08KDMLJNJ@?$CFi?5?$CFf?5?$CFs@
CONST	SEGMENT
??_C@_08KDMLJNJ@?$CFi?5?$CFf?5?$CFs@ DB '%i %f %s', 00H	; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0f5H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	032dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	02c8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0f0H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0409H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_FindUnreliableEvent
_TEXT	SEGMENT
_i$ = -12						; size = 4
_ei$ = -8						; size = 4
_es$ = -4						; size = 4
_CL_FindUnreliableEvent PROC				; COMDAT

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 289  : 	event_state_t	*es;
; 290  : 	event_info_t	*ei;
; 291  : 	int		i;
; 292  : 
; 293  : 	es = &cl.events;

	mov	DWORD PTR _es$[ebp], OFFSET _cl+2203896

; 294  : 
; 295  : 	for ( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindUnr
$LN2@CL_FindUnr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FindUnr:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_FindUnr

; 296  : 	{
; 297  : 		ei = &es->ei[i];

	imul	eax, DWORD PTR _i$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 298  : 		if( ei->index != 0 )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@CL_FindUnr

; 299  : 		{
; 300  : 			// it's reliable, so skip it
; 301  : 			if( FBitSet( ei->flags, FEV_RELIABLE ))

	mov	eax, DWORD PTR _ei$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	and	ecx, 2
	je	SHORT $LN5@CL_FindUnr

; 302  : 				continue;

	jmp	SHORT $LN2@CL_FindUnr
$LN5@CL_FindUnr:

; 303  : 		}
; 304  : 		return ei;

	mov	eax, DWORD PTR _ei$[ebp]
	jmp	SHORT $LN1@CL_FindUnr

; 305  : 	}

	jmp	SHORT $LN2@CL_FindUnr
$LN3@CL_FindUnr:

; 306  : 
; 307  : 	// this should never happen
; 308  : 	return NULL;

	xor	eax, eax
$LN1@CL_FindUnr:

; 309  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindUnreliableEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_FindEmptyEvent
_TEXT	SEGMENT
_ei$ = -12						; size = 4
_es$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_FindEmptyEvent PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 261  : 	int		i;
; 262  : 	event_state_t	*es;
; 263  : 	event_info_t	*ei;
; 264  : 
; 265  : 	es = &cl.events;

	mov	DWORD PTR _es$[ebp], OFFSET _cl+2203896

; 266  : 
; 267  : 	// look for first slot where index is != 0
; 268  : 	for( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FindEmp
$LN2@CL_FindEmp:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FindEmp:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_FindEmp

; 269  : 	{
; 270  : 		ei = &es->ei[i];

	imul	eax, DWORD PTR _i$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 271  : 		if( ei->index != 0 )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@CL_FindEmp

; 272  : 			continue;

	jmp	SHORT $LN2@CL_FindEmp
$LN5@CL_FindEmp:

; 273  : 		return ei;

	mov	eax, DWORD PTR _ei$[ebp]
	jmp	SHORT $LN1@CL_FindEmp

; 274  : 	}

	jmp	SHORT $LN2@CL_FindEmp
$LN3@CL_FindEmp:

; 275  : 
; 276  : 	// no slots available
; 277  : 	return NULL;

	xor	eax, eax
$LN1@CL_FindEmp:

; 278  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FindEmptyEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_FireEvent
_TEXT	SEGMENT
tv82 = -88						; size = 4
tv81 = -84						; size = 4
_idx$ = -16						; size = 4
_i$ = -12						; size = 4
_name$ = -8						; size = 4
_ev$ = -4						; size = 4
_ei$ = 8						; size = 4
_slot$ = 12						; size = 4
_CL_FireEvent PROC					; COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi

; 182  : 	cl_user_event_t	*ev;
; 183  : 	const char	*name;
; 184  : 	int		i, idx;
; 185  : 
; 186  : 	if( !ei || !ei->index )

	cmp	DWORD PTR _ei$[ebp], 0
	je	SHORT $LN6@CL_FireEve
	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@CL_FireEve
$LN6@CL_FireEve:

; 187  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_FireEve
$LN5@CL_FireEve:

; 188  : 
; 189  : 	// get the func pointer
; 190  : 	for( i = 0; i < MAX_EVENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FireEve
$LN2@CL_FireEve:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FireEve:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	$LN3@CL_FireEve

; 191  : 	{
; 192  : 		ev = clgame.events[i];		

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10028]
	mov	DWORD PTR _ev$[ebp], ecx

; 193  : 
; 194  : 		if( !ev )

	cmp	DWORD PTR _ev$[ebp], 0
	jne	SHORT $LN7@CL_FireEve

; 195  : 		{
; 196  : 			idx = bound( 1, ei->index, ( MAX_EVENTS - 1 ));

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 1
	jl	SHORT $LN13@CL_FireEve
	mov	edx, DWORD PTR _ei$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 1023				; 000003ffH
	jge	SHORT $LN11@CL_FireEve
	mov	ecx, DWORD PTR _ei$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@CL_FireEve
$LN11@CL_FireEve:
	mov	DWORD PTR tv81[ebp], 1023		; 000003ffH
$LN12@CL_FireEve:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN14@CL_FireEve
$LN13@CL_FireEve:
	mov	DWORD PTR tv82[ebp], 1
$LN14@CL_FireEve:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _idx$[ebp], ecx

; 197  : 			Con_Reportf( S_ERROR "CL_FireEvent: %s not precached\n", cl.event_precache[idx] );

	mov	eax, DWORD PTR _idx$[ebp]
	shl	eax, 6
	add	eax, OFFSET _cl+2766228
	push	eax
	push	OFFSET ??_C@_0CL@LJIHFNFD@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@
	call	_Con_Reportf
	add	esp, 8

; 198  : 			break;

	jmp	$LN3@CL_FireEve
$LN7@CL_FireEve:

; 199  : 		}
; 200  : 
; 201  : 		if( ev->index == ei->index )

	mov	eax, DWORD PTR _ev$[ebp]
	movzx	ecx, WORD PTR [eax+64]
	mov	edx, DWORD PTR _ei$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN8@CL_FireEve

; 202  : 		{
; 203  : 			if( ev->func )

	mov	eax, DWORD PTR _ev$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN9@CL_FireEve

; 204  : 			{
; 205  : 				CL_DescribeEvent( slot, ei->flags, cl.event_precache[ei->index] );

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	shl	ecx, 6
	add	ecx, OFFSET _cl+2766228
	push	ecx
	mov	edx, DWORD PTR _ei$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	call	_CL_DescribeEvent
	add	esp, 12					; 0000000cH

; 206  : 				ev->func( &ei->args );

	mov	eax, DWORD PTR _ei$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _ev$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	call	edx
	add	esp, 4

; 207  : 				return true;

	mov	eax, 1
	jmp	SHORT $LN1@CL_FireEve
$LN9@CL_FireEve:

; 208  : 			}
; 209  : 
; 210  : 			name = cl.event_precache[ei->index];

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	shl	ecx, 6
	add	ecx, OFFSET _cl+2766228
	mov	DWORD PTR _name$[ebp], ecx

; 211  : 			Con_Reportf( S_ERROR "CL_FireEvent: %s not hooked\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@BCEPDBOC@?$FO1Error?3?$FO7?5CL_FireEvent?3?5?$CFs?5not@
	call	_Con_Reportf
	add	esp, 8

; 212  : 			break;			

	jmp	SHORT $LN3@CL_FireEve
$LN8@CL_FireEve:

; 213  : 		}
; 214  : 	}

	jmp	$LN2@CL_FireEve
$LN3@CL_FireEve:

; 215  : 
; 216  : 	return false;

	xor	eax, eax
$LN1@CL_FireEve:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FireEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_DescribeEvent
_TEXT	SEGMENT
_info$ = -28						; size = 20
_idx$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_slot$ = 8						; size = 4
_flags$ = 12						; size = 4
_eventname$ = 16					; size = 4
_CL_DescribeEvent PROC					; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 83   : 	int		idx = (slot & 31);

	mov	eax, DWORD PTR _slot$[ebp]
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _idx$[ebp], eax

; 84   : 	con_nprint_t	info;
; 85   : 
; 86   : 	if( !eventname || !cl_showevents->value )

	cmp	DWORD PTR _eventname$[ebp], 0
	je	SHORT $LN3@CL_Describ
	mov	eax, DWORD PTR _cl_showevents
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_Describ
$LN3@CL_Describ:

; 87   : 		return;

	jmp	$LN1@CL_Describ
$LN2@CL_Describ:

; 88   : 
; 89   : 	// mark reliable as green and unreliable as red
; 90   : 	if( FBitSet( flags, FEV_RELIABLE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN4@CL_Describ

; 91   : 		VectorSet( info.color, 0.0f, 1.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
	jmp	SHORT $LN5@CL_Describ
$LN4@CL_Describ:

; 92   : 	else VectorSet( info.color, 1.0f, 0.0f, 0.0f );

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _info$[ebp+ecx+8], xmm0
	mov	edx, 4
	shl	edx, 0
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+edx+8], xmm0
	mov	eax, 4
	shl	eax, 1
	xorps	xmm0, xmm0
	movss	DWORD PTR _info$[ebp+eax+8], xmm0
$LN5@CL_Describ:

; 93   : 
; 94   : 	info.time_to_live = 0.5f;

	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _info$[ebp+4], xmm0

; 95   : 	info.index = idx;

	mov	eax, DWORD PTR _idx$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 96   : 
; 97   : 	Con_NXPrintf( &info, "%i %f %s", slot, cl.time, eventname );

	mov	eax, DWORD PTR _eventname$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _slot$[ebp]
	push	ecx
	push	OFFSET ??_C@_08KDMLJNJ@?$CFi?5?$CFf?5?$CFs@
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_Con_NXPrintf
	add	esp, 24					; 00000018H
$LN1@CL_Describ:

; 98   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DescribeEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_CalcPlayerVelocity
_TEXT	SEGMENT
tv198 = -96						; size = 4
tv171 = -96						; size = 4
_dt$ = -28						; size = 8
_delta$ = -20						; size = 12
_pcd$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_idx$ = 8						; size = 4
_velocity$ = 12						; size = 4
_CL_CalcPlayerVelocity PROC				; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 45   : 	clientdata_t	*pcd;
; 46   : 	vec3_t		delta;
; 47   : 	double		dt;
; 48   : 
; 49   : 	VectorClear( velocity );

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _velocity$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _velocity$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _velocity$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+edx], xmm0

; 50   : 
; 51   : 	if( idx <= 0 || idx > cl.maxclients )

	cmp	DWORD PTR _idx$[ebp], 0
	jle	SHORT $LN3@CL_CalcPla
	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, DWORD PTR _cl+2213004
	jle	SHORT $LN2@CL_CalcPla
$LN3@CL_CalcPla:

; 52   : 		return;

	jmp	$LN7@CL_CalcPla
$LN2@CL_CalcPla:

; 53   : 
; 54   : 	if( idx == cl.playernum + 1 )

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	cmp	DWORD PTR _idx$[ebp], eax
	jne	SHORT $LN4@CL_CalcPla

; 55   : 	{
; 56   : 		pcd = &cl.frames[cl.parsecountmod].clientdata;

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+120
	mov	DWORD PTR _pcd$[ebp], eax

; 57   : 		VectorCopy( pcd->velocity, velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _pcd$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [edx+eax], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _pcd$[ebp]
	mov	edx, DWORD PTR [esi+edx+12]
	mov	DWORD PTR [ecx+eax], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _velocity$[ebp]
	mov	esi, DWORD PTR _pcd$[ebp]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [edx+ecx], eax

; 58   : 	}

	jmp	$LN7@CL_CalcPla
$LN4@CL_CalcPla:

; 59   : 	else
; 60   : 	{
; 61   : 		dt = clgame.entities[idx].curstate.animtime - clgame.entities[idx].prevstate.animtime;

	imul	eax, DWORD PTR _idx$[ebp], 3336
	imul	ecx, DWORD PTR _idx$[ebp], 3336
	mov	edx, DWORD PTR _clgame+996
	mov	esi, DWORD PTR _clgame+996
	movss	xmm0, DWORD PTR [edx+eax+1004]
	subss	xmm0, DWORD PTR [esi+ecx+552]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _dt$[ebp], xmm0

; 62   : 
; 63   : 		if( dt != 0.0 )

	movsd	xmm0, QWORD PTR _dt$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN6@CL_CalcPla

; 64   : 		{
; 65   : 			VectorSubtract( clgame.entities[idx].curstate.velocity, clgame.entities[idx].prevstate.velocity, delta );

	imul	eax, DWORD PTR _idx$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	mov	ecx, 4
	imul	edx, ecx, 0
	imul	ecx, DWORD PTR _idx$[ebp], 3336
	add	ecx, DWORD PTR _clgame+996
	mov	esi, 4
	imul	esi, esi, 0
	movss	xmm0, DWORD PTR [eax+edx+1020]
	subss	xmm0, DWORD PTR [ecx+esi+568]
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _delta$[ebp+eax], xmm0
	imul	ecx, DWORD PTR _idx$[ebp], 3336
	add	ecx, DWORD PTR _clgame+996
	mov	edx, 4
	shl	edx, 0
	imul	eax, DWORD PTR _idx$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [ecx+edx+1020]
	subss	xmm0, DWORD PTR [eax+esi+568]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _delta$[ebp+ecx], xmm0
	imul	edx, DWORD PTR _idx$[ebp], 3336
	add	edx, DWORD PTR _clgame+996
	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _idx$[ebp], 3336
	add	ecx, DWORD PTR _clgame+996
	mov	esi, 4
	shl	esi, 1
	movss	xmm0, DWORD PTR [edx+eax+1020]
	subss	xmm0, DWORD PTR [ecx+esi+568]
	movss	DWORD PTR tv171[ebp], xmm0
	mov	edx, 4
	shl	edx, 1
	movss	xmm0, DWORD PTR tv171[ebp]
	movss	DWORD PTR _delta$[ebp+edx], xmm0

; 66   : 			VectorScale( delta, 1.0 / dt, velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	cvtss2sd xmm0, DWORD PTR _delta$[ebp+ecx]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, QWORD PTR _dt$[ebp]
	mulsd	xmm0, xmm1
	mov	edx, 4
	imul	eax, edx, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 0
	cvtss2sd xmm0, DWORD PTR _delta$[ebp+edx]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, QWORD PTR _dt$[ebp]
	mulsd	xmm0, xmm1
	mov	eax, 4
	shl	eax, 0
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
	mov	edx, 4
	shl	edx, 1
	cvtss2sd xmm0, DWORD PTR _delta$[ebp+edx]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, QWORD PTR _dt$[ebp]
	mulsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv198[ebp], xmm0
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _velocity$[ebp]
	movss	xmm0, DWORD PTR tv198[ebp]
	movss	DWORD PTR [ecx+eax], xmm0

; 67   : 		}

	jmp	SHORT $LN7@CL_CalcPla
$LN6@CL_CalcPla:

; 68   : 		else
; 69   : 		{
; 70   : 			VectorCopy( clgame.entities[idx].curstate.velocity, velocity );

	imul	eax, DWORD PTR _idx$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	edx, DWORD PTR [eax+edx+1020]
	mov	DWORD PTR [esi+ecx], edx
	imul	eax, DWORD PTR _idx$[ebp], 3336
	add	eax, DWORD PTR _clgame+996
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	eax, DWORD PTR [eax+ecx+1020]
	mov	DWORD PTR [esi+edx], eax
	imul	ecx, DWORD PTR _idx$[ebp], 3336
	add	ecx, DWORD PTR _clgame+996
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	esi, DWORD PTR _velocity$[ebp]
	mov	ecx, DWORD PTR [ecx+edx+1020]
	mov	DWORD PTR [esi+eax], ecx
$LN7@CL_CalcPla:

; 71   : 		}
; 72   : 	}
; 73   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CalcPlayerVelocity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_FireEvents
_TEXT	SEGMENT
_i$ = -12						; size = 4
_ei$ = -8						; size = 4
_es$ = -4						; size = 4
_CL_FireEvents PROC					; COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 228  : 	event_state_t	*es;
; 229  : 	event_info_t	*ei;
; 230  : 	int		i;
; 231  : 
; 232  : 	es = &cl.events;

	mov	DWORD PTR _es$[ebp], OFFSET _cl+2203896

; 233  : 
; 234  : 	for( i = 0; i < MAX_EVENT_QUEUE; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_FireEve
$LN2@CL_FireEve:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_FireEve:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	SHORT $LN3@CL_FireEve

; 235  : 	{
; 236  : 		ei = &es->ei[i];

	imul	eax, DWORD PTR _i$[ebp], 124
	add	eax, DWORD PTR _es$[ebp]
	mov	DWORD PTR _ei$[ebp], eax

; 237  : 
; 238  : 		if( ei->index == 0 )

	mov	eax, DWORD PTR _ei$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@CL_FireEve

; 239  : 			continue;

	jmp	SHORT $LN2@CL_FireEve
$LN5@CL_FireEve:

; 240  : 
; 241  : 		// delayed event!
; 242  : 		if( ei->fire_time && ( ei->fire_time > cl.time ))

	mov	eax, DWORD PTR _ei$[ebp]
	movss	xmm0, DWORD PTR [eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_FireEve
	mov	eax, DWORD PTR _ei$[ebp]
	cvtss2sd xmm0, DWORD PTR [eax+8]
	comisd	xmm0, QWORD PTR _cl+2167640
	jbe	SHORT $LN6@CL_FireEve

; 243  : 			continue;

	jmp	SHORT $LN2@CL_FireEve
$LN6@CL_FireEve:

; 244  : 
; 245  : 		CL_FireEvent( ei, i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ei$[ebp]
	push	ecx
	call	_CL_FireEvent
	add	esp, 8

; 246  : 
; 247  : 		// zero out the remaining fields
; 248  : 		CL_ResetEvent( ei );

	mov	eax, DWORD PTR _ei$[ebp]
	push	eax
	call	_CL_ResetEvent
	add	esp, 4

; 249  : 	}

	jmp	SHORT $LN2@CL_FireEve
$LN3@CL_FireEve:

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FireEvents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_EventIndex
_TEXT	SEGMENT
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_EventIndex PROC					; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 136  : 	int	i;
; 137  : 	
; 138  : 	if( !COM_CheckString( name ))

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@CL_EventIn

; 139  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CL_EventIn
$LN5@CL_EventIn:

; 140  : 
; 141  : 	for( i = 1; i < MAX_EVENTS && cl.event_precache[i][0]; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_EventIn
$LN2@CL_EventIn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_EventIn:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN3@CL_EventIn
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _cl[eax+edx+2766228]
	test	eax, eax
	je	SHORT $LN3@CL_EventIn

; 142  : 	{
; 143  : 		if( !Q_stricmp( cl.event_precache[i], name ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	add	ecx, OFFSET _cl+2766228
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@CL_EventIn

; 144  : 			return i;

	mov	ax, WORD PTR _i$[ebp]
	jmp	SHORT $LN1@CL_EventIn
$LN6@CL_EventIn:

; 145  : 	}

	jmp	SHORT $LN2@CL_EventIn
$LN3@CL_EventIn:

; 146  : 	return 0;

	xor	eax, eax
$LN1@CL_EventIn:

; 147  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_EventIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_ResetEvent
_TEXT	SEGMENT
_ei$ = 8						; size = 4
_CL_ResetEvent PROC					; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 30   : 	ei->index = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _ei$[ebp]
	mov	WORD PTR [ecx], ax

; 31   : 	memset( &ei->args, 0, sizeof( ei->args ));

	push	108					; 0000006cH
	push	0
	mov	eax, DWORD PTR _ei$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 32   : 	ei->fire_time = 0.0;

	mov	eax, DWORD PTR _ei$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+8], xmm0

; 33   : 	ei->flags = 0;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	DWORD PTR [eax+120], 0

; 34   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ResetEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_RegisterEvent
_TEXT	SEGMENT
_ev$ = -4						; size = 4
_lastnum$ = 8						; size = 4
_szEvName$ = 12						; size = 4
_func$ = 16						; size = 4
_CL_RegisterEvent PROC					; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 157  : 	cl_user_event_t	*ev;
; 158  : 
; 159  : 	if( lastnum == MAX_EVENTS )

	cmp	DWORD PTR _lastnum$[ebp], 1024		; 00000400H
	jne	SHORT $LN2@CL_Registe

; 160  : 		return;

	jmp	SHORT $LN1@CL_Registe
$LN2@CL_Registe:

; 161  : 
; 162  : 	// clear existing or allocate new one
; 163  : 	if( !clgame.events[lastnum] )

	mov	eax, DWORD PTR _lastnum$[ebp]
	cmp	DWORD PTR _clgame[eax*4+10028], 0
	jne	SHORT $LN3@CL_Registe

; 164  : 		clgame.events[lastnum] = Mem_Calloc( cls.mempool, sizeof( cl_user_event_t ));

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_RegisterEvent@@9@9
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0DG@DHCGFLEM@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	push	72					; 00000048H
	mov	ecx, DWORD PTR _cls+40
	push	ecx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lastnum$[ebp]
	mov	DWORD PTR _clgame[edx*4+10028], eax
	jmp	SHORT $LN4@CL_Registe
$LN3@CL_Registe:

; 165  : 	else memset( clgame.events[lastnum], 0, sizeof( cl_user_event_t ));

	push	72					; 00000048H
	push	0
	mov	eax, DWORD PTR _lastnum$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10028]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN4@CL_Registe:

; 166  : 
; 167  : 	ev = clgame.events[lastnum];

	mov	eax, DWORD PTR _lastnum$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10028]
	mov	DWORD PTR _ev$[ebp], ecx

; 168  : 
; 169  : 	// NOTE: ev->index will be set later
; 170  : 	Q_strncpy( ev->name, szEvName, MAX_QPATH );

	push	64					; 00000040H
	mov	eax, DWORD PTR _szEvName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 171  : 	ev->func = func;

	mov	eax, DWORD PTR _ev$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+68], ecx
$LN1@CL_Registe:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_RegisterEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_PlaybackEvent
_TEXT	SEGMENT
tv159 = -180						; size = 4
_args$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_flags$ = 8						; size = 4
_pInvoker$ = 12						; size = 4
_eventindex$ = 16					; size = 2
_delay$ = 20						; size = 4
_origin$ = 24						; size = 4
_angles$ = 28						; size = 4
_fparam1$ = 32						; size = 4
_fparam2$ = 36						; size = 4
_iparam1$ = 40						; size = 4
_iparam2$ = 44						; size = 4
_bparam1$ = 48						; size = 4
_bparam2$ = 52						; size = 4
_vparam1$ = 56						; size = 4
_vparam2$ = 60						; size = 4
_aparam1$ = 64						; size = 4
_aparam2$ = 68						; size = 4
_aparam3$ = 72						; size = 1
_CL_PlaybackEvent PROC					; COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 456  : 	event_args_t	args;
; 457  : 
; 458  : 	if( FBitSet( flags, FEV_SERVER ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN2@CL_Playbac

; 459  : 		return;

	jmp	$LN1@CL_Playbac
$LN2@CL_Playbac:

; 460  : 
; 461  : 	// first check event for out of bounds
; 462  : 	if( eventindex < 1 || eventindex > MAX_EVENTS )

	movzx	eax, WORD PTR _eventindex$[ebp]
	cmp	eax, 1
	jl	SHORT $LN4@CL_Playbac
	movzx	eax, WORD PTR _eventindex$[ebp]
	cmp	eax, 1024				; 00000400H
	jle	SHORT $LN3@CL_Playbac
$LN4@CL_Playbac:

; 463  : 	{
; 464  : 		Con_DPrintf( S_ERROR "CL_PlaybackEvent: invalid eventindex %i\n", eventindex );

	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@BKCJEFDK@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5in@
	call	_Con_DPrintf
	add	esp, 8

; 465  : 		return;

	jmp	$LN1@CL_Playbac
$LN3@CL_Playbac:

; 466  : 	}
; 467  : 
; 468  : 	// check event for precached
; 469  : 	if( !CL_EventIndex( cl.event_precache[eventindex] ))

	movzx	eax, WORD PTR _eventindex$[ebp]
	shl	eax, 6
	add	eax, OFFSET _cl+2766228
	push	eax
	call	_CL_EventIndex
	add	esp, 4
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN5@CL_Playbac

; 470  : 	{
; 471  : 		Con_DPrintf( S_ERROR "CL_PlaybackEvent: event %i was not precached\n", eventindex );

	movzx	eax, WORD PTR _eventindex$[ebp]
	push	eax
	push	OFFSET ??_C@_0DJ@NDKPCIEN@?$FO1Error?3?$FO7?5CL_PlaybackEvent?3?5ev@
	call	_Con_DPrintf
	add	esp, 8

; 472  : 		return;		

	jmp	$LN1@CL_Playbac
$LN5@CL_Playbac:

; 473  : 	}
; 474  : 
; 475  : 	SetBits( flags, FEV_CLIENT ); // it's a client event

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _flags$[ebp], eax

; 476  : 	ClearBits( flags, FEV_NOTHOST|FEV_HOSTONLY|FEV_GLOBAL );

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, -22				; ffffffeaH
	mov	DWORD PTR _flags$[ebp], eax

; 477  : 	if( delay < 0.0f ) delay = 0.0f; // fixup negative delays

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR _delay$[ebp]
	jbe	SHORT $LN6@CL_Playbac
	xorps	xmm0, xmm0
	movss	DWORD PTR _delay$[ebp], xmm0
$LN6@CL_Playbac:

; 478  : 
; 479  : 	memset( &args, 0, sizeof( args ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 
; 481  : 	VectorCopy( origin, args.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+8], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+8], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _origin$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+8], eax

; 482  : 	VectorCopy( angles, args.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _angles$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+20], eax

; 483  : 	VectorCopy( cl.simvel, args.velocity );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cl[ecx+2212988]
	mov	DWORD PTR _args$[ebp+eax+32], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl[edx+2212988]
	mov	DWORD PTR _args$[ebp+eax+32], ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _cl[edx+2212988]
	mov	DWORD PTR _args$[ebp+eax+32], ecx

; 484  : 	args.entindex = cl.playernum + 1;

	mov	eax, DWORD PTR _cl+2213000
	add	eax, 1
	mov	DWORD PTR _args$[ebp+4], eax

; 485  : 	args.ducking = ( cl.local.usehull == 1 );

	cmp	DWORD PTR _cl+2212740, 1
	jne	SHORT $LN8@CL_Playbac
	mov	DWORD PTR tv159[ebp], 1
	jmp	SHORT $LN9@CL_Playbac
$LN8@CL_Playbac:
	mov	DWORD PTR tv159[ebp], 0
$LN9@CL_Playbac:
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR _args$[ebp+44], eax

; 486  : 
; 487  : 	args.fparam1 = fparam1;

	movss	xmm0, DWORD PTR _fparam1$[ebp]
	movss	DWORD PTR _args$[ebp+48], xmm0

; 488  : 	args.fparam2 = fparam2;

	movss	xmm0, DWORD PTR _fparam2$[ebp]
	movss	DWORD PTR _args$[ebp+52], xmm0

; 489  : 	args.iparam1 = iparam1;

	mov	eax, DWORD PTR _iparam1$[ebp]
	mov	DWORD PTR _args$[ebp+56], eax

; 490  : 	args.iparam2 = iparam2;

	mov	eax, DWORD PTR _iparam2$[ebp]
	mov	DWORD PTR _args$[ebp+60], eax

; 491  : 	args.bparam1 = bparam1;

	mov	eax, DWORD PTR _bparam1$[ebp]
	mov	DWORD PTR _args$[ebp+64], eax

; 492  : 	args.bparam2 = bparam2;

	mov	eax, DWORD PTR _bparam2$[ebp]
	mov	DWORD PTR _args$[ebp+68], eax

; 493  : 
; 494  : 	VectorCopy(vparam1, args.vparam1);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vparam1$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+72], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam1$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+72], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vparam1$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+72], eax

; 495  : 	VectorCopy(vparam2, args.vparam2);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _vparam2$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _args$[ebp+eax+84], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _vparam2$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _args$[ebp+eax+84], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _vparam2$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _args$[ebp+ecx+84], eax

; 496  : 
; 497  : 	args.aparam1 = aparam1;

	mov	eax, DWORD PTR _aparam1$[ebp]
	mov	DWORD PTR _args$[ebp+96], eax

; 498  : 	args.aparam2 = aparam1;

	cvtsi2ss xmm0, DWORD PTR _aparam1$[ebp]
	movss	DWORD PTR _args$[ebp+100], xmm0

; 499  : 	args.aparam3 = aparam1;

	mov	al, BYTE PTR _aparam1$[ebp]
	mov	BYTE PTR _args$[ebp+104], al

; 500  : 
; 501  : 	CL_QueueEvent( flags, eventindex, delay, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	ecx, WORD PTR _eventindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	call	_CL_QueueEvent
	add	esp, 16					; 00000010H
$LN1@CL_Playbac:

; 502  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlaybackEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_QueueEvent
_TEXT	SEGMENT
tv77 = -76						; size = 8
_ei$ = -4						; size = 4
_flags$ = 8						; size = 4
_index$ = 12						; size = 4
_delay$ = 16						; size = 4
_args$ = 20						; size = 4
_CL_QueueEvent PROC					; COMDAT

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 319  : 	event_info_t	*ei;
; 320  : 
; 321  : 	// find a normal slot
; 322  : 	ei = CL_FindEmptyEvent();

	call	_CL_FindEmptyEvent
	mov	DWORD PTR _ei$[ebp], eax

; 323  : 
; 324  : 	if( !ei )

	cmp	DWORD PTR _ei$[ebp], 0
	jne	SHORT $LN4@CL_QueueEv

; 325  : 	{
; 326  : 		if( FBitSet( flags, FEV_RELIABLE ))

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@CL_QueueEv

; 327  : 		{
; 328  : 			ei = CL_FindUnreliableEvent();

	call	_CL_FindUnreliableEvent
	mov	DWORD PTR _ei$[ebp], eax
$LN3@CL_QueueEv:

; 329  : 		}
; 330  : 
; 331  : 		if( !ei ) return;

	cmp	DWORD PTR _ei$[ebp], 0
	jne	SHORT $LN4@CL_QueueEv
	jmp	SHORT $LN1@CL_QueueEv
$LN4@CL_QueueEv:

; 332  : 	}
; 333  : 
; 334  : 	ei->index	= index;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	cx, WORD PTR _index$[ebp]
	mov	WORD PTR [eax], cx

; 335  : 	ei->packet_index = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _ei$[ebp]
	mov	WORD PTR [ecx+2], ax

; 336  : 	ei->fire_time = delay ? (cl.time + delay) : 0.0f;

	movss	xmm0, DWORD PTR _delay$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CL_QueueEv
	cvtss2sd xmm0, DWORD PTR _delay$[ebp]
	addsd	xmm0, QWORD PTR _cl+2167640
	movsd	QWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN7@CL_QueueEv
$LN6@CL_QueueEv:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv77[ebp], xmm0
$LN7@CL_QueueEv:
	cvtsd2ss xmm0, QWORD PTR tv77[ebp]
	mov	eax, DWORD PTR _ei$[ebp]
	movss	DWORD PTR [eax+8], xmm0

; 337  : 	ei->flags	= flags;

	mov	eax, DWORD PTR _ei$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 338  : 	ei->args = *args;

	mov	edi, DWORD PTR _ei$[ebp]
	add	edi, 12					; 0000000cH
	mov	ecx, 27					; 0000001bH
	mov	esi, DWORD PTR _args$[ebp]
	rep movsd
$LN1@CL_QueueEv:

; 339  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_QueueEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_SetEventIndex
_TEXT	SEGMENT
_i$ = -8						; size = 4
_ev$ = -4						; size = 4
_szEvName$ = 8						; size = 4
_ev_index$ = 12						; size = 4
_CL_SetEventIndex PROC					; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 108  : 	cl_user_event_t	*ev;
; 109  : 	int		i;
; 110  : 
; 111  : 	if( !szEvName || !*szEvName )

	cmp	DWORD PTR _szEvName$[ebp], 0
	je	SHORT $LN6@CL_SetEven
	mov	eax, DWORD PTR _szEvName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@CL_SetEven
$LN6@CL_SetEven:

; 112  : 		return; // ignore blank names

	jmp	SHORT $LN1@CL_SetEven
$LN5@CL_SetEven:

; 113  : 
; 114  : 	// search event by name to link with
; 115  : 	for( i = 0; i < MAX_EVENTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_SetEven
$LN2@CL_SetEven:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_SetEven:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN1@CL_SetEven

; 116  : 	{
; 117  : 		ev = clgame.events[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _clgame[eax*4+10028]
	mov	DWORD PTR _ev$[ebp], ecx

; 118  : 		if( !ev ) break;

	cmp	DWORD PTR _ev$[ebp], 0
	jne	SHORT $LN7@CL_SetEven
	jmp	SHORT $LN1@CL_SetEven
$LN7@CL_SetEven:

; 119  : 
; 120  : 		if( !Q_stricmp( ev->name, szEvName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _szEvName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ev$[ebp]
	push	ecx
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@CL_SetEven

; 121  : 		{
; 122  : 			ev->index = ev_index;

	mov	eax, DWORD PTR _ev$[ebp]
	mov	cx, WORD PTR _ev_index$[ebp]
	mov	WORD PTR [eax+64], cx

; 123  : 			return;

	jmp	SHORT $LN1@CL_SetEven
$LN8@CL_SetEven:

; 124  : 		}
; 125  : 	}

	jmp	SHORT $LN2@CL_SetEven
$LN1@CL_SetEven:

; 126  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_SetEventIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_ParseReliableEvent
_TEXT	SEGMENT
_delay$ = -228						; size = 4
_args$ = -224						; size = 108
_nullargs$ = -116					; size = 108
_event_index$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseReliableEvent PROC				; COMDAT

; 348  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 349  : 	int		event_index;
; 350  : 	event_args_t	nullargs, args;
; 351  : 	float		delay = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _delay$[ebp], xmm0

; 352  : 
; 353  : 	memset( &nullargs, 0, sizeof( nullargs ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 354  : 
; 355  : 	event_index = MSG_ReadUBitLong( msg, MAX_EVENT_BITS );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _event_index$[ebp], eax

; 356  : 
; 357  : 	if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@CL_ParseRe

; 358  : 		delay = (float)MSG_ReadWord( msg ) * (1.0f / 100.0f);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _delay$[ebp], xmm0
$LN2@CL_ParseRe:

; 359  : 
; 360  : 	// reliable events not use delta-compression just null-compression
; 361  : 	MSG_ReadDeltaEvent( msg, &nullargs, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nullargs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadDeltaEvent
	add	esp, 12					; 0000000cH

; 362  : 
; 363  : 	if( args.entindex > 0 && args.entindex <= cl.maxclients )

	cmp	DWORD PTR _args$[ebp+4], 0
	jle	SHORT $LN3@CL_ParseRe
	mov	eax, DWORD PTR _args$[ebp+4]
	cmp	eax, DWORD PTR _cl+2213004
	jg	SHORT $LN3@CL_ParseRe

; 364  : 		args.angles[PITCH] *= -3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+ecx+20]
	mulss	xmm0, DWORD PTR __real@c0400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _args$[ebp+eax+20], xmm0
$LN3@CL_ParseRe:

; 365  : 
; 366  : 	CL_QueueEvent( FEV_RELIABLE|FEV_SERVER, event_index, delay, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _event_index$[ebp]
	push	ecx
	push	34					; 00000022H
	call	_CL_QueueEvent
	add	esp, 16					; 00000010H

; 367  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseReliableEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_events.c
;	COMDAT _CL_ParseEvent
_TEXT	SEGMENT
tv203 = -316						; size = 4
_frame$1 = -248						; size = 4
_delay$ = -244						; size = 4
_state$ = -240						; size = 4
_args$ = -236						; size = 108
_nullargs$ = -128					; size = 108
_packet_index$ = -20					; size = 4
_num_events$ = -16					; size = 4
_i$ = -12						; size = 4
_event_index$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_msg$ = 8						; size = 4
_CL_ParseEvent PROC					; COMDAT

; 377  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 378  : 	int		event_index;
; 379  : 	int		i, num_events;
; 380  : 	int		packet_index;
; 381  : 	event_args_t	nullargs, args;
; 382  : 	entity_state_t	*state;
; 383  : 	float		delay;
; 384  : 
; 385  : 	memset( &nullargs, 0, sizeof( nullargs ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _nullargs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 386  : 	memset( &args, 0, sizeof( args ));

	push	108					; 0000006cH
	push	0
	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 387  : 
; 388  : 	num_events = MSG_ReadUBitLong( msg, 5 );

	push	5
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _num_events$[ebp], eax

; 389  : 
; 390  : 	// parse events queue
; 391  : 	for( i = 0 ; i < num_events; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_ParseEv
$LN2@CL_ParseEv:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_ParseEv:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_events$[ebp]
	jge	$LN3@CL_ParseEv

; 392  : 	{
; 393  : 		event_index = MSG_ReadUBitLong( msg, MAX_EVENT_BITS );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _event_index$[ebp], eax

; 394  : 
; 395  : 		if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN5@CL_ParseEv

; 396  : 			packet_index = MSG_ReadUBitLong( msg, MAX_ENTITY_BITS );

	push	13					; 0000000dH
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadUBitLong
	add	esp, 8
	mov	DWORD PTR _packet_index$[ebp], eax
	jmp	SHORT $LN6@CL_ParseEv
$LN5@CL_ParseEv:

; 397  : 		else packet_index = -1;

	mov	DWORD PTR _packet_index$[ebp], -1
$LN6@CL_ParseEv:

; 398  : 
; 399  : 		if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@CL_ParseEv

; 400  : 		{
; 401  : 			MSG_ReadDeltaEvent( msg, &nullargs, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nullargs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	_MSG_ReadDeltaEvent
	add	esp, 12					; 0000000cH
$LN7@CL_ParseEv:

; 402  : 		}
; 403  : 
; 404  : 		if( MSG_ReadOneBit( msg ))

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadOneBit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@CL_ParseEv

; 405  : 			delay = (float)MSG_ReadWord( msg ) * (1.0f / 100.0f);

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_ReadWord
	add	esp, 4
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR _delay$[ebp], xmm0
	jmp	SHORT $LN9@CL_ParseEv
$LN8@CL_ParseEv:

; 406  : 		else delay = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _delay$[ebp], xmm0
$LN9@CL_ParseEv:

; 407  : 
; 408  : 		if( packet_index != -1 )

	cmp	DWORD PTR _packet_index$[ebp], -1
	je	$LN10@CL_ParseEv

; 409  : 		{
; 410  : 			frame_t	*frame = &cl.frames[cl.parsecountmod];

	imul	eax, DWORD PTR _cl+12, 24056
	add	eax, OFFSET _cl+88
	mov	DWORD PTR _frame$1[ebp], eax

; 411  : 
; 412  : 			if( packet_index < frame->num_entities )

	mov	eax, DWORD PTR _frame$1[ebp]
	mov	ecx, DWORD PTR _packet_index$[ebp]
	cmp	ecx, DWORD PTR [eax+24044]
	jge	$LN11@CL_ParseEv

; 413  : 			{
; 414  : 				state = &cls.packet_entities[(frame->first_entity+packet_index)%cls.num_client_entities];

	mov	eax, DWORD PTR _frame$1[ebp]
	mov	eax, DWORD PTR [eax+24048]
	add	eax, DWORD PTR _packet_index$[ebp]
	cdq
	idiv	DWORD PTR _cls+295004
	imul	ecx, edx, 452
	add	ecx, DWORD PTR _cls+295012
	mov	DWORD PTR _state$[ebp], ecx

; 415  : 				args.entindex = state->number;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _args$[ebp+4], ecx

; 416  : 
; 417  : 				if( VectorIsNull( args.origin ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+ecx+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN13@CL_ParseEv
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@CL_ParseEv
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _args$[ebp+eax+8]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@CL_ParseEv

; 418  : 					VectorCopy( state->origin, args.origin );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _args$[ebp+eax+8], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR _args$[ebp+eax+8], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR _args$[ebp+ecx+8], eax
$LN13@CL_ParseEv:

; 419  : 
; 420  : 				if( VectorIsNull( args.angles ))

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+ecx+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	$LN14@CL_ParseEv
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+eax+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_ParseEv
	mov	eax, 4
	shl	eax, 1
	movss	xmm0, DWORD PTR _args$[ebp+eax+20]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@CL_ParseEv

; 421  : 					VectorCopy( state->angles, args.angles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+28]
	mov	DWORD PTR _args$[ebp+eax+20], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR _args$[ebp+eax+20], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR _args$[ebp+ecx+20], eax
$LN14@CL_ParseEv:

; 422  : 
; 423  : 				COM_NormalizeAngles( args.angles );

	lea	eax, DWORD PTR _args$[ebp+20]
	push	eax
	call	_COM_NormalizeAngles
	add	esp, 4

; 424  : 
; 425  : 				if( state->number > 0 && state->number <= cl.maxclients )

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	$LN15@CL_ParseEv
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _cl+2213004
	jg	SHORT $LN15@CL_ParseEv

; 426  : 				{
; 427  : 					args.angles[PITCH] *= -3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+ecx+20]
	mulss	xmm0, DWORD PTR __real@c0400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _args$[ebp+eax+20], xmm0

; 428  : 					CL_CalcPlayerVelocity( state->number, args.velocity );

	lea	eax, DWORD PTR _args$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_CL_CalcPlayerVelocity
	add	esp, 8

; 429  : 					args.ducking = ( state->usehull == 1 );

	mov	eax, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [eax+312], 1
	jne	SHORT $LN19@CL_ParseEv
	mov	DWORD PTR tv203[ebp], 1
	jmp	SHORT $LN20@CL_ParseEv
$LN19@CL_ParseEv:
	mov	DWORD PTR tv203[ebp], 0
$LN20@CL_ParseEv:
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR _args$[ebp+44], ecx
$LN15@CL_ParseEv:

; 430  : 				}
; 431  : 			}

	jmp	SHORT $LN17@CL_ParseEv
$LN11@CL_ParseEv:

; 432  : 			else
; 433  : 			{
; 434  : 				if( args.entindex != 0 )

	cmp	DWORD PTR _args$[ebp+4], 0
	je	SHORT $LN17@CL_ParseEv

; 435  : 				{
; 436  : 					if( args.entindex > 0 && args.entindex <= cl.maxclients )

	cmp	DWORD PTR _args$[ebp+4], 0
	jle	SHORT $LN17@CL_ParseEv
	mov	eax, DWORD PTR _args$[ebp+4]
	cmp	eax, DWORD PTR _cl+2213004
	jg	SHORT $LN17@CL_ParseEv

; 437  : 						args.angles[PITCH] /= -3.0f;

	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _args$[ebp+ecx+20]
	divss	xmm0, DWORD PTR __real@c0400000
	mov	edx, 4
	imul	eax, edx, 0
	movss	DWORD PTR _args$[ebp+eax+20], xmm0
$LN17@CL_ParseEv:

; 438  : 				}
; 439  : 			}
; 440  : 		
; 441  : 			// Place event on queue
; 442  : 			CL_QueueEvent( FEV_SERVER, event_index, delay, &args );

	lea	eax, DWORD PTR _args$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _delay$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _event_index$[ebp]
	push	ecx
	push	32					; 00000020H
	call	_CL_QueueEvent
	add	esp, 16					; 00000010H
$LN10@CL_ParseEv:

; 443  : 		}
; 444  : 	}

	jmp	$LN2@CL_ParseEv
$LN3@CL_ParseEv:

; 445  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ParseEvent ENDP
_TEXT	ENDS
END
