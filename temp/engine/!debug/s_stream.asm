; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\s_stream.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_S_StreamGetCurrentState
PUBLIC	_S_StopBackgroundTrack
PUBLIC	_S_GetMusicVolume
PUBLIC	_S_StreamSoundTrack
PUBLIC	_S_StreamBackgroundTrack
PUBLIC	_S_PrintBackgroundTrackState
PUBLIC	_S_FadeMusicVolume
PUBLIC	_S_StartBackgroundTrack
PUBLIC	_S_StreamSetPause
PUBLIC	_S_StartStreaming
PUBLIC	_S_StopStreaming
PUBLIC	??_C@_0BC@JAOJLBEL@BackgroundTrack?3?5@		; `string'
PUBLIC	??_C@_0BD@PLBNGAAL@intro?5?$CFs?0?5loop?5?$CFs?6@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0L@KPBCLAFJ@?$CFs?5?$FLloop?$FN?6@	; `string'
PUBLIC	??_C@_0N@NBFJHDBB@not?5playing?6@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	?__LINE__Var@?0??S_StreamBackgroundTrack@@9@9	; `S_StreamBackgroundTrack'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@KJIABGIH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0L@NIBHLGHE@ch?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??S_StreamSoundTrack@@9@9	; `S_StreamSoundTrack'::`1'::__LINE__Var
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@42c80000
PUBLIC	__real@472c4400
EXTRN	_memset:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_va:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_COM_CheckString:PROC
EXTRN	_FS_OpenStream:PROC
EXTRN	_FS_StreamInfo:PROC
EXTRN	_FS_ReadStream:PROC
EXTRN	_FS_SetStreamPos:PROC
EXTRN	_FS_GetStreamPos:PROC
EXTRN	_FS_FreeStream:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_SCR_GetAudioChunk:PROC
EXTRN	_SCR_GetMovieInfo:PROC
EXTRN	_S_FindRawChannel:PROC
EXTRN	_S_RawSamples:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_soundtime:DWORD
EXTRN	_s_listener:BYTE
EXTRN	_dma:BYTE
EXTRN	_s_musicvolume:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_s_bgTrack DB	0210H DUP (?)
_musicfade DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@472c4400
CONST	SEGMENT
__real@472c4400 DD 0472c4400r			; 44100
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_StreamSoundTrack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_StreamSoundTrack@@9@9 DD 0185H	; `S_StreamSoundTrack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0L@NIBHLGHE@ch?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0L@NIBHLGHE@ch?5?$CB?$DN?5NULL@ DB 'ch != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KJIABGIH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DF@KJIABGIH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\s_stream.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??S_StreamBackgroundTrack@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??S_StreamBackgroundTrack@@9@9 DD 0102H	; `S_StreamBackgroundTrack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NBFJHDBB@not?5playing?6@
CONST	SEGMENT
??_C@_0N@NBFJHDBB@not?5playing?6@ DB 'not playing', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KPBCLAFJ@?$CFs?5?$FLloop?$FN?6@
CONST	SEGMENT
??_C@_0L@KPBCLAFJ@?$CFs?5?$FLloop?$FN?6@ DB '%s [loop]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PLBNGAAL@intro?5?$CFs?0?5loop?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@PLBNGAAL@intro?5?$CFs?0?5loop?5?$CFs?6@ DB 'intro %s, loop %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JAOJLBEL@BackgroundTrack?3?5@
CONST	SEGMENT
??_C@_0BC@JAOJLBEL@BackgroundTrack?3?5@ DB 'BackgroundTrack: ', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	0114H
	DW	012bH
	DW	0143H
	DW	0166H
	DW	037aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	014H
	DW	09fH
	DW	0b6H
	DW	0ceH
	DW	0f6H
	DW	0242H
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StopStreaming
_TEXT	SEGMENT
_S_StopStreaming PROC					; COMDAT

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 379  : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StopStre
	jmp	SHORT $LN1@S_StopStre
$LN2@S_StopStre:

; 380  : 	s_listener.streaming = false;

	mov	DWORD PTR _s_listener+84, 0
$LN1@S_StopStre:

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopStreaming ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StartStreaming
_TEXT	SEGMENT
_S_StartStreaming PROC					; COMDAT

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 367  : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StartStr
	jmp	SHORT $LN1@S_StartStr
$LN2@S_StartStr:

; 368  : 	// begin streaming movie soundtrack
; 369  : 	s_listener.streaming = true;

	mov	DWORD PTR _s_listener+84, 1
$LN1@S_StartStr:

; 370  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartStreaming ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StreamSetPause
_TEXT	SEGMENT
_pause$ = 8						; size = 4
_S_StreamSetPause PROC					; COMDAT

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 211  : 	s_listener.stream_paused = pause;

	mov	eax, DWORD PTR _pause$[ebp]
	mov	DWORD PTR _s_listener+88, eax

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamSetPause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StartBackgroundTrack
_TEXT	SEGMENT
_iWhich$ = -4						; size = 4
_introTrack$ = 8					; size = 4
_mainTrack$ = 12					; size = 4
_position$ = 16						; size = 4
_loopCount$ = 20					; size = 4
_onLoop$ = 24						; size = 4
_restored$ = 28						; size = 4
_fullpath$ = 32						; size = 4
_S_StartBackgroundTrack PROC				; COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 76   : 	S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 77   : 
; 78   : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StartBac
	jmp	$LN1@S_StartBac
$LN2@S_StartBac:

; 79   : 
; 80   : 	// check for special symbols
; 81   : 	if( introTrack && *introTrack == '*' )

	cmp	DWORD PTR _introTrack$[ebp], 0
	je	SHORT $LN3@S_StartBac
	mov	eax, DWORD PTR _introTrack$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN3@S_StartBac

; 82   : 		introTrack = NULL;

	mov	DWORD PTR _introTrack$[ebp], 0
$LN3@S_StartBac:

; 83   : 
; 84   : 	if( mainTrack && *mainTrack == '*' )

	cmp	DWORD PTR _mainTrack$[ebp], 0
	je	SHORT $LN4@S_StartBac
	mov	eax, DWORD PTR _mainTrack$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN4@S_StartBac

; 85   : 		mainTrack = NULL;

	mov	DWORD PTR _mainTrack$[ebp], 0
$LN4@S_StartBac:

; 86   : 
; 87   : 	// Do not start anything if either tracks are null
; 88   : 	if( !COM_CheckString( introTrack ) && !COM_CheckString( mainTrack ))

	mov	eax, DWORD PTR _introTrack$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@S_StartBac
	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN5@S_StartBac

; 89   : 		return;

	jmp	$LN1@S_StartBac
$LN5@S_StartBac:

; 90   : 
; 91   : 	// Now we need to set up the track
; 92   : 	int iWhich = 1 * COM_CheckString(introTrack) + 2 * COM_CheckString(mainTrack);

	mov	eax, DWORD PTR _introTrack$[ebp]
	push	eax
	call	_COM_CheckString
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _mainTrack$[ebp]
	push	ecx
	call	_COM_CheckString
	add	esp, 4
	lea	edx, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _iWhich$[ebp], edx

; 93   : 
; 94   : 	// If neither are valid, don't bother at all
; 95   : 	if (!(iWhich & (1 | 2)))

	mov	eax, DWORD PTR _iWhich$[ebp]
	and	eax, 3
	jne	SHORT $LN6@S_StartBac

; 96   : 		return;

	jmp	$LN1@S_StartBac
$LN6@S_StartBac:

; 97   : 
; 98   : 	// Set the loop count
; 99   : 	if (!restored)

	cmp	DWORD PTR _restored$[ebp], 0
	jne	SHORT $LN7@S_StartBac

; 100  : 	{
; 101  : 		if (loopCount > 1)

	cmp	DWORD PTR _loopCount$[ebp], 1
	jle	SHORT $LN8@S_StartBac

; 102  : 		{
; 103  : 			if ((iWhich & (1 | 2)) == 3)

	mov	eax, DWORD PTR _iWhich$[ebp]
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN10@S_StartBac

; 104  : 				s_bgTrack.loopCount = loopCount;

	mov	eax, DWORD PTR _loopCount$[ebp]
	mov	DWORD PTR _s_bgTrack+512, eax
	jmp	SHORT $LN11@S_StartBac
$LN10@S_StartBac:

; 105  : 			else
; 106  : 				s_bgTrack.loopCount = loopCount - 1;

	mov	eax, DWORD PTR _loopCount$[ebp]
	sub	eax, 1
	mov	DWORD PTR _s_bgTrack+512, eax
$LN11@S_StartBac:

; 107  : 		}

	jmp	SHORT $LN7@S_StartBac
$LN8@S_StartBac:

; 108  : 		else
; 109  : 		{
; 110  : 			if (loopCount <= -1)

	cmp	DWORD PTR _loopCount$[ebp], -1
	jg	SHORT $LN12@S_StartBac

; 111  : 			{
; 112  : 				s_bgTrack.loopCount = -1;

	mov	DWORD PTR _s_bgTrack+512, -1

; 113  : 			}

	jmp	SHORT $LN7@S_StartBac
$LN12@S_StartBac:

; 114  : 			else
; 115  : 			{
; 116  : 				s_bgTrack.loopCount = 1;	

	mov	DWORD PTR _s_bgTrack+512, 1
$LN7@S_StartBac:

; 117  : 			}
; 118  : 
; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	// Copy them anyways
; 123  : 	Q_strncpy(s_bgTrack.current, introTrack, sizeof(s_bgTrack.current));

	push	256					; 00000100H
	mov	eax, DWORD PTR _introTrack$[ebp]
	push	eax
	push	OFFSET _s_bgTrack
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 124  : 	Q_strncpy(s_bgTrack.loopName, mainTrack, sizeof(s_bgTrack.loopName));

	push	256					; 00000100H
	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	push	OFFSET _s_bgTrack+256
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 125  : 
; 126  : 	if (restored)

	cmp	DWORD PTR _restored$[ebp], 0
	je	SHORT $LN14@S_StartBac

; 127  : 	{
; 128  : 		// Loop count must be preserved, do not change it
; 129  : 		if (loopCount == 0)

	cmp	DWORD PTR _loopCount$[ebp], 0
	jne	SHORT $LN16@S_StartBac

; 130  : 			loopCount++;

	mov	eax, DWORD PTR _loopCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _loopCount$[ebp], eax
$LN16@S_StartBac:

; 131  : 		s_bgTrack.loopCount = loopCount;

	mov	eax, DWORD PTR _loopCount$[ebp]
	mov	DWORD PTR _s_bgTrack+512, eax

; 132  : 
; 133  : 		// If we're restoring a track
; 134  : 		if (onLoop)

	cmp	DWORD PTR _onLoop$[ebp], 0
	je	SHORT $LN17@S_StartBac

; 135  : 		{
; 136  : 			s_bgTrack.stream = FS_OpenStream(va("%s", mainTrack));

	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 137  : 			s_bgTrack.onLoop = true;

	mov	DWORD PTR _s_bgTrack+516, 1

; 138  : 		}

	jmp	SHORT $LN18@S_StartBac
$LN17@S_StartBac:

; 139  : 		else
; 140  : 		{
; 141  : 			s_bgTrack.stream = FS_OpenStream(va("%s", introTrack));

	mov	eax, DWORD PTR _introTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 142  : 			s_bgTrack.onLoop = false;

	mov	DWORD PTR _s_bgTrack+516, 0
$LN18@S_StartBac:

; 143  : 		}
; 144  : 	}

	jmp	$LN15@S_StartBac
$LN14@S_StartBac:

; 145  : 	else
; 146  : 	{
; 147  : 		// In case we're not restoring a track
; 148  : 		if (iWhich & 1 == 1)

	mov	eax, DWORD PTR _iWhich$[ebp]
	and	eax, 1
	je	$LN19@S_StartBac

; 149  : 		{
; 150  : 			// New code
; 151  : 			s_bgTrack.stream = FS_OpenStream(va("%s", mainTrack));

	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 152  : 			if (!s_bgTrack.stream && s_bgTrack.loopCount > 0) s_bgTrack.loopCount--;

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN21@S_StartBac
	cmp	DWORD PTR _s_bgTrack+512, 0
	jle	SHORT $LN21@S_StartBac
	mov	eax, DWORD PTR _s_bgTrack+512
	sub	eax, 1
	mov	DWORD PTR _s_bgTrack+512, eax
$LN21@S_StartBac:

; 153  : 
; 154  : 			s_bgTrack.stream = FS_OpenStream(va("%s", introTrack));

	mov	eax, DWORD PTR _introTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 155  : 			s_bgTrack.onLoop = false;

	mov	DWORD PTR _s_bgTrack+516, 0

; 156  : 
; 157  : 			if (iWhich & 2 == 2)

	mov	eax, DWORD PTR _iWhich$[ebp]
	and	eax, 1
	je	SHORT $LN22@S_StartBac

; 158  : 			{
; 159  : 				if (!s_bgTrack.stream)

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN22@S_StartBac

; 160  : 				{
; 161  : 					if (s_bgTrack.loopCount > 0)

	cmp	DWORD PTR _s_bgTrack+512, 0
	jle	SHORT $LN24@S_StartBac

; 162  : 						s_bgTrack.loopCount--;

	mov	eax, DWORD PTR _s_bgTrack+512
	sub	eax, 1
	mov	DWORD PTR _s_bgTrack+512, eax
$LN24@S_StartBac:

; 163  : 					s_bgTrack.stream = FS_OpenStream(va("%s", mainTrack));

	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 164  : 					s_bgTrack.onLoop = true;

	mov	DWORD PTR _s_bgTrack+516, 1
$LN22@S_StartBac:

; 165  : 				}
; 166  : 			}
; 167  : 		}

	jmp	SHORT $LN15@S_StartBac
$LN19@S_StartBac:

; 168  : 		else if (iWhich & 2 == 2)

	mov	eax, DWORD PTR _iWhich$[ebp]
	and	eax, 1
	je	SHORT $LN15@S_StartBac

; 169  : 		{
; 170  : 			if (s_bgTrack.loopCount > 1)

	cmp	DWORD PTR _s_bgTrack+512, 1
	jle	SHORT $LN26@S_StartBac

; 171  : 				s_bgTrack.loopCount--;

	mov	eax, DWORD PTR _s_bgTrack+512
	sub	eax, 1
	mov	DWORD PTR _s_bgTrack+512, eax
$LN26@S_StartBac:

; 172  : 			s_bgTrack.stream = FS_OpenStream(va("%s", mainTrack));

	mov	eax, DWORD PTR _mainTrack$[ebp]
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 173  : 			s_bgTrack.onLoop = true;

	mov	DWORD PTR _s_bgTrack+516, 1
$LN15@S_StartBac:

; 174  : 		}
; 175  : 	}
; 176  : 
; 177  : 	memset( &musicfade, 0, sizeof( musicfade )); // clear any soundfade

	push	4
	push	0
	push	OFFSET _musicfade
	call	_memset
	add	esp, 12					; 0000000cH

; 178  : 	s_bgTrack.source = cls.key_dest;

	mov	eax, DWORD PTR _cls+36
	mov	DWORD PTR _s_bgTrack+524, eax

; 179  : 
; 180  : 	if( position != 0 )

	cmp	DWORD PTR _position$[ebp], 0
	je	SHORT $LN1@S_StartBac

; 181  : 	{
; 182  : 		// restore message, update song position
; 183  : 		FS_SetStreamPos( s_bgTrack.stream, position );

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s_bgTrack+520
	push	ecx
	call	_FS_SetStreamPos
	add	esp, 8
$LN1@S_StartBac:

; 184  : 	}
; 185  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StartBackgroundTrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_FadeMusicVolume
_TEXT	SEGMENT
tv67 = -72						; size = 4
tv66 = -68						; size = 4
_fadePercent$ = 8					; size = 4
_S_FadeMusicVolume PROC					; COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 48   : 	musicfade.percent = bound( 0.0f, fadePercent, 100.0f );       

	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN5@S_FadeMusi
	movss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR _fadePercent$[ebp]
	jbe	SHORT $LN3@S_FadeMusi
	movss	xmm0, DWORD PTR _fadePercent$[ebp]
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN4@S_FadeMusi
$LN3@S_FadeMusi:
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv66[ebp], xmm0
$LN4@S_FadeMusi:
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN6@S_FadeMusi
$LN5@S_FadeMusi:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv67[ebp], xmm0
$LN6@S_FadeMusi:
	movss	xmm0, DWORD PTR tv67[ebp]
	movss	DWORD PTR _musicfade, xmm0

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_FadeMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_PrintBackgroundTrackState
_TEXT	SEGMENT
_S_PrintBackgroundTrackState PROC			; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 30   : 	Con_Printf( "BackgroundTrack: " );

	push	OFFSET ??_C@_0BC@JAOJLBEL@BackgroundTrack?3?5@
	call	_Con_Printf
	add	esp, 4

; 31   : 
; 32   : 	if( s_bgTrack.current[0] && s_bgTrack.loopName[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx]
	test	edx, edx
	je	SHORT $LN2@S_PrintBac
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx+256]
	test	edx, edx
	je	SHORT $LN2@S_PrintBac

; 33   : 		Con_Printf( "intro %s, loop %s\n", s_bgTrack.current, s_bgTrack.loopName );

	push	OFFSET _s_bgTrack+256
	push	OFFSET _s_bgTrack
	push	OFFSET ??_C@_0BD@PLBNGAAL@intro?5?$CFs?0?5loop?5?$CFs?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@S_PrintBac
$LN2@S_PrintBac:

; 34   : 	else if( s_bgTrack.current[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx]
	test	edx, edx
	je	SHORT $LN4@S_PrintBac

; 35   : 		Con_Printf( "%s\n", s_bgTrack.current );

	push	OFFSET _s_bgTrack
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@S_PrintBac
$LN4@S_PrintBac:

; 36   : 	else if( s_bgTrack.loopName[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx+256]
	test	edx, edx
	je	SHORT $LN6@S_PrintBac

; 37   : 		Con_Printf( "%s [loop]\n", s_bgTrack.loopName );

	push	OFFSET _s_bgTrack+256
	push	OFFSET ??_C@_0L@KPBCLAFJ@?$CFs?5?$FLloop?$FN?6@
	call	_Con_Printf
	add	esp, 8
	jmp	SHORT $LN1@S_PrintBac
$LN6@S_PrintBac:

; 38   : 	else Con_Printf( "not playing\n" );

	push	OFFSET ??_C@_0N@NBFJHDBB@not?5playing?6@
	call	_Con_Printf
	add	esp, 4
$LN1@S_PrintBac:

; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_PrintBackgroundTrackState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StreamBackgroundTrack
_TEXT	SEGMENT
tv86 = -8736						; size = 4
_info$1 = -8220						; size = 4
_ch$ = -8216						; size = 4
_fileBytes$ = -8212					; size = 4
_r$ = -8208						; size = 4
_raw$ = -8204						; size = 8192
_fileSamples$ = -12					; size = 4
_bufferSamples$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_S_StreamBackgroundTrack PROC				; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8736				; 00002220H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 259  : 	int	bufferSamples;
; 260  : 	int	fileSamples;
; 261  : 	byte	raw[MAX_RAW_SAMPLES];
; 262  : 	int	r, fileBytes;
; 263  : 	rawchan_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 264  : 
; 265  : 	if( !dma.initialized || !s_bgTrack.stream || s_listener.streaming )

	cmp	DWORD PTR _dma+12, 0
	je	SHORT $LN5@S_StreamBa
	cmp	DWORD PTR _s_bgTrack+520, 0
	je	SHORT $LN5@S_StreamBa
	cmp	DWORD PTR _s_listener+84, 0
	je	SHORT $LN4@S_StreamBa
$LN5@S_StreamBa:

; 266  : 		return;

	jmp	$LN3@S_StreamBa
$LN4@S_StreamBa:

; 267  : 
; 268  : 	// don't bother playing anything if musicvolume is 0
; 269  : 	if( !s_musicvolume->value || s_listener.paused || s_listener.stream_paused )

	mov	eax, DWORD PTR _s_musicvolume
	movss	xmm0, DWORD PTR [eax+12]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@S_StreamBa
	cmp	DWORD PTR _s_listener+80, 0
	jne	SHORT $LN7@S_StreamBa
	cmp	DWORD PTR _s_listener+88, 0
	je	SHORT $LN6@S_StreamBa
$LN7@S_StreamBa:

; 270  : 		return;

	jmp	$LN3@S_StreamBa
$LN6@S_StreamBa:

; 271  : 
; 272  : 	if( !cl.background )

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN8@S_StreamBa

; 273  : 	{
; 274  : 		// pause music by source type
; 275  : 		if( s_bgTrack.source == key_game && cls.key_dest == key_menu ) return;

	cmp	DWORD PTR _s_bgTrack+524, 1
	jne	SHORT $LN10@S_StreamBa
	cmp	DWORD PTR _cls+36, 2
	jne	SHORT $LN10@S_StreamBa
	jmp	$LN3@S_StreamBa
$LN10@S_StreamBa:

; 276  : 		if( s_bgTrack.source == key_menu && cls.key_dest != key_menu ) return;

	cmp	DWORD PTR _s_bgTrack+524, 2
	jne	SHORT $LN11@S_StreamBa
	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN11@S_StreamBa
	jmp	$LN3@S_StreamBa
$LN11@S_StreamBa:

; 277  : 	}

	jmp	SHORT $LN12@S_StreamBa
$LN8@S_StreamBa:

; 278  : 	else if( cls.key_dest == key_console )

	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN12@S_StreamBa

; 279  : 		return;

	jmp	$LN3@S_StreamBa
$LN12@S_StreamBa:

; 280  : 
; 281  : 	ch = S_FindRawChannel( S_RAW_SOUND_BACKGROUNDTRACK, true );

	push	1
	push	-2					; fffffffeH
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax

; 282  : 
; 283  : 	Assert( ch != NULL );

	cmp	DWORD PTR _ch$[ebp], 0
	je	SHORT $LN28@S_StreamBa
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN29@S_StreamBa
$LN28@S_StreamBa:
	mov	DWORD PTR tv86[ebp], 0
$LN29@S_StreamBa:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_StreamBackgroundTrack@@9@9
	add	eax, 25					; 00000019H
	push	eax
	push	OFFSET ??_C@_0DF@KJIABGIH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@NIBHLGHE@ch?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 284  : 
; 285  : 	// see how many samples should be copied into the raw buffer
; 286  : 	if( ch->s_rawend < soundtime )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _soundtime
	jae	SHORT $LN13@S_StreamBa

; 287  : 		ch->s_rawend = soundtime;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	mov	DWORD PTR [eax+36], ecx
$LN13@S_StreamBa:

; 288  : 
; 289  : 	while( ch->s_rawend < soundtime + ch->max_samples )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	add	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+36], ecx
	jae	$LN3@S_StreamBa

; 290  : 	{
; 291  : 		wavdata_t	*info = FS_StreamInfo( s_bgTrack.stream );

	mov	eax, DWORD PTR _s_bgTrack+520
	push	eax
	call	_FS_StreamInfo
	add	esp, 4
	mov	DWORD PTR _info$1[ebp], eax

; 292  : 
; 293  : 		bufferSamples = ch->max_samples - (ch->s_rawend - soundtime);

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR _soundtime
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+72]
	sub	eax, ecx
	mov	DWORD PTR _bufferSamples$[ebp], eax

; 294  : 
; 295  : 		// decide how much data needs to be read from the file
; 296  : 		fileSamples = bufferSamples * ((float)info->rate / SOUND_DMA_SPEED );

	cvtsi2ss xmm0, DWORD PTR _bufferSamples$[ebp]
	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, WORD PTR [eax]
	cvtsi2ss xmm1, ecx
	divss	xmm1, DWORD PTR __real@472c4400
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _fileSamples$[ebp], edx

; 297  : 		if( fileSamples <= 1 ) return; // no more samples need

	cmp	DWORD PTR _fileSamples$[ebp], 1
	jg	SHORT $LN14@S_StreamBa
	jmp	$LN3@S_StreamBa
$LN14@S_StreamBa:

; 298  : 
; 299  : 		// our max buffer size
; 300  : 		fileBytes = fileSamples * ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	imul	ecx, DWORD PTR _fileSamples$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], ecx

; 301  : 
; 302  : 		if( fileBytes > sizeof( raw ))

	cmp	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H
	jbe	SHORT $LN15@S_StreamBa

; 303  : 		{
; 304  : 			fileBytes = sizeof( raw );

	mov	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H

; 305  : 			fileSamples = fileBytes / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _fileBytes$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN15@S_StreamBa:

; 306  : 		}
; 307  : 
; 308  : 		// read
; 309  : 		r = FS_ReadStream( s_bgTrack.stream, fileBytes, raw );

	lea	eax, DWORD PTR _raw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s_bgTrack+520
	push	edx
	call	_FS_ReadStream
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r$[ebp], eax

; 310  : 
; 311  : 		if( r < fileBytes )

	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _fileBytes$[ebp]
	jge	SHORT $LN16@S_StreamBa

; 312  : 		{
; 313  : 			fileBytes = r;

	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], eax

; 314  : 			fileSamples = r / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _r$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN16@S_StreamBa:

; 315  : 		}
; 316  : 
; 317  : 		if( r > 0 )

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN17@S_StreamBa

; 318  : 		{
; 319  : 			// add to raw buffer
; 320  : 			S_RawSamples( fileSamples, info->rate, info->width, info->channels, raw, S_RAW_SOUND_BACKGROUNDTRACK );

	push	-2					; fffffffeH
	lea	eax, DWORD PTR _raw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+3]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+2]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _fileSamples$[ebp]
	push	eax
	call	_S_RawSamples
	add	esp, 24					; 00000018H

; 321  : 		}

	jmp	$LN20@S_StreamBa
$LN17@S_StreamBa:

; 322  : 		else
; 323  : 		{
; 324  : 			// loop section
; 325  : 			if ((s_bgTrack.loopCount < 0 || s_bgTrack.loopCount > 0))

	cmp	DWORD PTR _s_bgTrack+512, 0
	jl	SHORT $LN21@S_StreamBa
	cmp	DWORD PTR _s_bgTrack+512, 0
	jle	$LN19@S_StreamBa
$LN21@S_StreamBa:

; 326  : 			{
; 327  : 				if (s_bgTrack.loopCount > 0)

	cmp	DWORD PTR _s_bgTrack+512, 0
	jle	SHORT $LN22@S_StreamBa

; 328  : 					--s_bgTrack.loopCount;

	mov	eax, DWORD PTR _s_bgTrack+512
	sub	eax, 1
	mov	DWORD PTR _s_bgTrack+512, eax
$LN22@S_StreamBa:

; 329  : 
; 330  : 				FS_FreeStream(s_bgTrack.stream);

	mov	eax, DWORD PTR _s_bgTrack+520
	push	eax
	call	_FS_FreeStream
	add	esp, 4

; 331  : 
; 332  : 				if (s_bgTrack.loopName[0])

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx+256]
	test	edx, edx
	je	SHORT $LN23@S_StreamBa

; 333  : 				{
; 334  : 					s_bgTrack.stream = FS_OpenStream(s_bgTrack.loopName);

	push	OFFSET _s_bgTrack+256
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 335  : 					s_bgTrack.onLoop = true;

	mov	DWORD PTR _s_bgTrack+516, 1

; 336  : 					if (!s_bgTrack.stream)

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN25@S_StreamBa

; 337  : 					{
; 338  : 						s_bgTrack.stream = FS_OpenStream(s_bgTrack.current);

	push	OFFSET _s_bgTrack
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 339  : 						s_bgTrack.onLoop = false;

	mov	DWORD PTR _s_bgTrack+516, 0
$LN25@S_StreamBa:

; 340  : 					}
; 341  : 				}

	jmp	SHORT $LN24@S_StreamBa
$LN23@S_StreamBa:

; 342  : 				else
; 343  : 				{
; 344  : 					s_bgTrack.stream = FS_OpenStream(s_bgTrack.current);

	push	OFFSET _s_bgTrack
	call	_FS_OpenStream
	add	esp, 4
	mov	DWORD PTR _s_bgTrack+520, eax

; 345  : 					s_bgTrack.onLoop = false;

	mov	DWORD PTR _s_bgTrack+516, 0
$LN24@S_StreamBa:

; 346  : 				}
; 347  : 
; 348  : 				if (!s_bgTrack.stream) return;

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN26@S_StreamBa
	jmp	SHORT $LN3@S_StreamBa
$LN26@S_StreamBa:

; 349  : 			}

	jmp	SHORT $LN20@S_StreamBa
$LN19@S_StreamBa:

; 350  : 			else
; 351  : 			{
; 352  : 				S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 353  : 				return;

	jmp	SHORT $LN3@S_StreamBa
$LN20@S_StreamBa:

; 354  : 			}
; 355  : 		}
; 356  : 
; 357  : 	}

	jmp	$LN13@S_StreamBa
$LN3@S_StreamBa:

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamBackgroundTrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StreamSoundTrack
_TEXT	SEGMENT
tv76 = -8736						; size = 4
_info$1 = -8220						; size = 4
_ch$ = -8216						; size = 4
_fileBytes$ = -8212					; size = 4
_r$ = -8208						; size = 4
_raw$ = -8204						; size = 8192
_fileSamples$ = -12					; size = 4
_bufferSamples$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_S_StreamSoundTrack PROC				; COMDAT

; 389  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8736				; 00002220H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 390  : 	int	bufferSamples;
; 391  : 	int	fileSamples;
; 392  : 	byte	raw[MAX_RAW_SAMPLES];
; 393  : 	int	r, fileBytes;
; 394  : 	rawchan_t	*ch = NULL;

	mov	DWORD PTR _ch$[ebp], 0

; 395  : 
; 396  : 	if( !dma.initialized || !s_listener.streaming || s_listener.paused )

	cmp	DWORD PTR _dma+12, 0
	je	SHORT $LN5@S_StreamSo
	cmp	DWORD PTR _s_listener+84, 0
	je	SHORT $LN5@S_StreamSo
	cmp	DWORD PTR _s_listener+80, 0
	je	SHORT $LN4@S_StreamSo
$LN5@S_StreamSo:

; 397  : 		return;

	jmp	$LN3@S_StreamSo
$LN4@S_StreamSo:

; 398  : 
; 399  : 	ch = S_FindRawChannel( S_RAW_SOUND_SOUNDTRACK, true );

	push	1
	push	-1
	call	_S_FindRawChannel
	add	esp, 8
	mov	DWORD PTR _ch$[ebp], eax

; 400  : 
; 401  : 	Assert( ch != NULL );

	cmp	DWORD PTR _ch$[ebp], 0
	je	SHORT $LN14@S_StreamSo
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN15@S_StreamSo
$LN14@S_StreamSo:
	mov	DWORD PTR tv76[ebp], 0
$LN15@S_StreamSo:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??S_StreamSoundTrack@@9@9
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0DF@KJIABGIH@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0L@NIBHLGHE@ch?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 402  : 
; 403  : 	// see how many samples should be copied into the raw buffer
; 404  : 	if( ch->s_rawend < soundtime )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR _soundtime
	jae	SHORT $LN6@S_StreamSo

; 405  : 		ch->s_rawend = soundtime;

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	mov	DWORD PTR [eax+36], ecx
$LN6@S_StreamSo:

; 406  : 
; 407  : 	while( ch->s_rawend < soundtime + ch->max_samples )

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR _soundtime
	add	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _ch$[ebp]
	cmp	DWORD PTR [edx+36], ecx
	jae	$LN3@S_StreamSo

; 408  : 	{
; 409  : 		wavdata_t	*info = SCR_GetMovieInfo();

	call	_SCR_GetMovieInfo
	mov	DWORD PTR _info$1[ebp], eax

; 410  : 
; 411  : 		if( !info ) break;	// bad soundtrack?

	cmp	DWORD PTR _info$1[ebp], 0
	jne	SHORT $LN7@S_StreamSo
	jmp	$LN3@S_StreamSo
$LN7@S_StreamSo:

; 412  : 
; 413  : 		bufferSamples = ch->max_samples - (ch->s_rawend - soundtime);

	mov	eax, DWORD PTR _ch$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sub	ecx, DWORD PTR _soundtime
	mov	edx, DWORD PTR _ch$[ebp]
	mov	eax, DWORD PTR [edx+72]
	sub	eax, ecx
	mov	DWORD PTR _bufferSamples$[ebp], eax

; 414  : 
; 415  : 		// decide how much data needs to be read from the file
; 416  : 		fileSamples = bufferSamples * ((float)info->rate / SOUND_DMA_SPEED );

	cvtsi2ss xmm0, DWORD PTR _bufferSamples$[ebp]
	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, WORD PTR [eax]
	cvtsi2ss xmm1, ecx
	divss	xmm1, DWORD PTR __real@472c4400
	mulss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _fileSamples$[ebp], edx

; 417  : 		if( fileSamples <= 1 ) return; // no more samples need

	cmp	DWORD PTR _fileSamples$[ebp], 1
	jg	SHORT $LN8@S_StreamSo
	jmp	$LN3@S_StreamSo
$LN8@S_StreamSo:

; 418  : 
; 419  : 		// our max buffer size
; 420  : 		fileBytes = fileSamples * ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	imul	ecx, DWORD PTR _fileSamples$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], ecx

; 421  : 
; 422  : 		if( fileBytes > sizeof( raw ))

	cmp	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H
	jbe	SHORT $LN9@S_StreamSo

; 423  : 		{
; 424  : 			fileBytes = sizeof( raw );

	mov	DWORD PTR _fileBytes$[ebp], 8192	; 00002000H

; 425  : 			fileSamples = fileBytes / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _fileBytes$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN9@S_StreamSo:

; 426  : 		}
; 427  : 
; 428  : 		// read audio stream
; 429  : 		r = SCR_GetAudioChunk( raw, fileBytes );

	mov	eax, DWORD PTR _fileBytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _raw$[ebp]
	push	ecx
	call	_SCR_GetAudioChunk
	add	esp, 8
	mov	DWORD PTR _r$[ebp], eax

; 430  : 
; 431  : 		if( r < fileBytes )

	mov	eax, DWORD PTR _r$[ebp]
	cmp	eax, DWORD PTR _fileBytes$[ebp]
	jge	SHORT $LN10@S_StreamSo

; 432  : 		{
; 433  : 			fileBytes = r;

	mov	eax, DWORD PTR _r$[ebp]
	mov	DWORD PTR _fileBytes$[ebp], eax

; 434  : 			fileSamples = r / ( info->width * info->channels );

	mov	eax, DWORD PTR _info$1[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _info$1[ebp]
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, eax
	mov	eax, DWORD PTR _r$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _fileSamples$[ebp], eax
$LN10@S_StreamSo:

; 435  : 		}
; 436  : 
; 437  : 		if( r > 0 )

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN11@S_StreamSo

; 438  : 		{
; 439  : 			// add to raw buffer
; 440  : 			S_RawSamples( fileSamples, info->rate, info->width, info->channels, raw, S_RAW_SOUND_SOUNDTRACK );

	push	-1
	lea	eax, DWORD PTR _raw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+3]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	dx, BYTE PTR [ecx+2]
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _fileSamples$[ebp]
	push	eax
	call	_S_RawSamples
	add	esp, 24					; 00000018H

; 441  : 		}

	jmp	SHORT $LN12@S_StreamSo
$LN11@S_StreamSo:

; 442  : 		else break; // no more samples for this frame

	jmp	SHORT $LN3@S_StreamSo
$LN12@S_StreamSo:

; 443  : 	}

	jmp	$LN6@S_StreamSo
$LN3@S_StreamSo:

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamSoundTrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_GetMusicVolume
_TEXT	SEGMENT
tv75 = -76						; size = 4
tv129 = -72						; size = 4
tv74 = -72						; size = 4
_scale$ = -4						; size = 4
_S_GetMusicVolume PROC					; COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 58   : 	float	scale = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _scale$[ebp], xmm0

; 59   : 
; 60   : 	if( !s_listener.inmenu && musicfade.percent != 0 )

	cmp	DWORD PTR _s_listener+76, 0
	jne	$LN2@S_GetMusic
	movss	xmm0, DWORD PTR _musicfade
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN2@S_GetMusic

; 61   : 	{
; 62   : 		scale = bound( 0.0f, musicfade.percent / 100.0f, 1.0f );

	movss	xmm0, DWORD PTR _musicfade
	divss	xmm0, DWORD PTR __real@42c80000
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN6@S_GetMusic
	movss	xmm0, DWORD PTR _musicfade
	divss	xmm0, DWORD PTR __real@42c80000
	movss	xmm1, DWORD PTR __real@3f800000
	comiss	xmm1, xmm0
	jbe	SHORT $LN4@S_GetMusic
	movss	xmm0, DWORD PTR _musicfade
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	jmp	SHORT $LN5@S_GetMusic
$LN4@S_GetMusic:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv74[ebp], xmm0
$LN5@S_GetMusic:
	movss	xmm0, DWORD PTR tv74[ebp]
	movss	DWORD PTR tv75[ebp], xmm0
	jmp	SHORT $LN7@S_GetMusic
$LN6@S_GetMusic:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
$LN7@S_GetMusic:
	movss	xmm0, DWORD PTR tv75[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0

; 63   : 		scale = 1.0f - scale;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR _scale$[ebp], xmm0
$LN2@S_GetMusic:

; 64   : 	}
; 65   : 
; 66   : 	return s_musicvolume->value * scale;

	mov	eax, DWORD PTR _s_musicvolume
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR _scale$[ebp]
	movss	DWORD PTR tv129[ebp], xmm0
	fld	DWORD PTR tv129[ebp]

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_GetMusicVolume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StopBackgroundTrack
_TEXT	SEGMENT
_S_StopBackgroundTrack PROC				; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 194  : 	s_listener.stream_paused = false;

	mov	DWORD PTR _s_listener+88, 0

; 195  : 
; 196  : 	if( !dma.initialized ) return;

	cmp	DWORD PTR _dma+12, 0
	jne	SHORT $LN2@S_StopBack
	jmp	SHORT $LN1@S_StopBack
$LN2@S_StopBack:

; 197  : 	if( !s_bgTrack.stream ) return;

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN3@S_StopBack
	jmp	SHORT $LN1@S_StopBack
$LN3@S_StopBack:

; 198  : 
; 199  : 	FS_FreeStream( s_bgTrack.stream );

	mov	eax, DWORD PTR _s_bgTrack+520
	push	eax
	call	_FS_FreeStream
	add	esp, 4

; 200  : 	memset( &s_bgTrack, 0, sizeof( bg_track_t ));

	push	528					; 00000210H
	push	0
	push	OFFSET _s_bgTrack
	call	_memset
	add	esp, 12					; 0000000cH

; 201  : 	memset( &musicfade, 0, sizeof( musicfade ));

	push	4
	push	0
	push	OFFSET _musicfade
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@S_StopBack:

; 202  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StopBackgroundTrack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\s_stream.c
;	COMDAT _S_StreamGetCurrentState
_TEXT	SEGMENT
_currentTrack$ = 8					; size = 4
_loopTrack$ = 12					; size = 4
_position$ = 16						; size = 4
_loopNum$ = 20						; size = 4
_onLoop$ = 24						; size = 4
_S_StreamGetCurrentState PROC				; COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 223  : 	if( !s_bgTrack.stream )

	cmp	DWORD PTR _s_bgTrack+520, 0
	jne	SHORT $LN2@S_StreamGe

; 224  : 		return false; // not active

	xor	eax, eax
	jmp	$LN1@S_StreamGe
$LN2@S_StreamGe:

; 225  : 
; 226  : 	if( currentTrack )

	cmp	DWORD PTR _currentTrack$[ebp], 0
	je	SHORT $LN3@S_StreamGe

; 227  : 	{
; 228  : 		if( s_bgTrack.current[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx]
	test	edx, edx
	je	SHORT $LN4@S_StreamGe

; 229  : 			Q_strncpy( currentTrack, s_bgTrack.current, MAX_STRING );

	push	256					; 00000100H
	push	OFFSET _s_bgTrack
	mov	eax, DWORD PTR _currentTrack$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@S_StreamGe
$LN4@S_StreamGe:

; 230  : 		else Q_strncpy( currentTrack, "*", MAX_STRING ); // no track

	push	256					; 00000100H
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	mov	eax, DWORD PTR _currentTrack$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN3@S_StreamGe:

; 231  : 	}
; 232  : 
; 233  : 	if( loopTrack )

	cmp	DWORD PTR _loopTrack$[ebp], 0
	je	SHORT $LN6@S_StreamGe

; 234  : 	{
; 235  : 		if( s_bgTrack.loopName[0] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _s_bgTrack[ecx+256]
	test	edx, edx
	je	SHORT $LN7@S_StreamGe

; 236  : 			Q_strncpy( loopTrack, s_bgTrack.loopName, MAX_STRING );

	push	256					; 00000100H
	push	OFFSET _s_bgTrack+256
	mov	eax, DWORD PTR _loopTrack$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@S_StreamGe
$LN7@S_StreamGe:

; 237  : 		else Q_strncpy( loopTrack, "*", MAX_STRING ); // no track

	push	256					; 00000100H
	push	OFFSET ??_C@_01NBENCBCI@?$CK@
	mov	eax, DWORD PTR _loopTrack$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN6@S_StreamGe:

; 238  : 	}
; 239  : 
; 240  : 	if( position )

	cmp	DWORD PTR _position$[ebp], 0
	je	SHORT $LN9@S_StreamGe

; 241  : 		*position = FS_GetStreamPos( s_bgTrack.stream );

	mov	eax, DWORD PTR _s_bgTrack+520
	push	eax
	call	_FS_GetStreamPos
	add	esp, 4
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [ecx], eax
$LN9@S_StreamGe:

; 242  : 
; 243  : 	if (loopNum)

	cmp	DWORD PTR _loopNum$[ebp], 0
	je	SHORT $LN10@S_StreamGe

; 244  : 		*loopNum = s_bgTrack.loopCount;

	mov	eax, DWORD PTR _loopNum$[ebp]
	mov	ecx, DWORD PTR _s_bgTrack+512
	mov	DWORD PTR [eax], ecx
$LN10@S_StreamGe:

; 245  : 
; 246  : 	if (onLoop)

	cmp	DWORD PTR _onLoop$[ebp], 0
	je	SHORT $LN11@S_StreamGe

; 247  : 		*onLoop = s_bgTrack.onLoop;

	mov	eax, DWORD PTR _onLoop$[ebp]
	mov	ecx, DWORD PTR _s_bgTrack+516
	mov	DWORD PTR [eax], ecx
$LN11@S_StreamGe:

; 248  : 
; 249  : 	return true;

	mov	eax, 1
$LN1@S_StreamGe:

; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_S_StreamGetCurrentState ENDP
_TEXT	ENDS
END
