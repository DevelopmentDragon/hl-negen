; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32705.0 

	TITLE	D:\DevDragon\XashFE\dev\src\temp\engine\!debug\cl_demo.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_demo_cmd
PUBLIC	??_C@_0M@LFICBEKK@dem_unknown@			; `string'
PUBLIC	??_C@_0N@KNMPGPEC@dem_norewind@			; `string'
PUBLIC	??_C@_08FAKFLJAL@dem_read@			; `string'
PUBLIC	??_C@_0N@IDCIJJGK@dem_jumptime@			; `string'
PUBLIC	??_C@_0N@JKNGBALH@dem_userdata@			; `string'
PUBLIC	??_C@_0M@INBJIDMD@dem_usercmd@			; `string'
PUBLIC	??_C@_08KBFAFKBO@dem_stop@			; `string'
_DATA	SEGMENT
COMM	_pglGetError:DWORD
COMM	_pglGetString:DWORD
COMM	_pglAccum:DWORD
COMM	_pglAlphaFunc:DWORD
COMM	_pglArrayElement:DWORD
COMM	_pglBegin:DWORD
COMM	_pglBindTexture:DWORD
COMM	_pglBitmap:DWORD
COMM	_pglBlendFunc:DWORD
COMM	_pglCallList:DWORD
COMM	_pglCallLists:DWORD
COMM	_pglClear:DWORD
COMM	_pglClearAccum:DWORD
COMM	_pglClearColor:DWORD
COMM	_pglClearDepth:DWORD
COMM	_pglClearIndex:DWORD
COMM	_pglClearStencil:DWORD
COMM	_pglIsEnabled:DWORD
COMM	_pglIsList:DWORD
COMM	_pglIsTexture:DWORD
COMM	_pglClipPlane:DWORD
COMM	_pglColor3b:DWORD
COMM	_pglColor3bv:DWORD
COMM	_pglColor3d:DWORD
COMM	_pglColor3dv:DWORD
COMM	_pglColor3f:DWORD
COMM	_pglColor3fv:DWORD
COMM	_pglColor3i:DWORD
COMM	_pglColor3iv:DWORD
COMM	_pglColor3s:DWORD
COMM	_pglColor3sv:DWORD
COMM	_pglColor3ub:DWORD
COMM	_pglColor3ubv:DWORD
COMM	_pglColor3ui:DWORD
COMM	_pglColor3uiv:DWORD
COMM	_pglColor3us:DWORD
COMM	_pglColor3usv:DWORD
COMM	_pglColor4b:DWORD
COMM	_pglColor4bv:DWORD
COMM	_pglColor4d:DWORD
COMM	_pglColor4dv:DWORD
COMM	_pglColor4f:DWORD
COMM	_pglColor4fv:DWORD
COMM	_pglColor4i:DWORD
COMM	_pglColor4iv:DWORD
COMM	_pglColor4s:DWORD
COMM	_pglColor4sv:DWORD
COMM	_pglColor4ub:DWORD
COMM	_pglColor4ubv:DWORD
COMM	_pglColor4ui:DWORD
COMM	_pglColor4uiv:DWORD
COMM	_pglColor4us:DWORD
COMM	_pglColor4usv:DWORD
COMM	_pglColorMask:DWORD
COMM	_pglColorMaterial:DWORD
COMM	_pglColorPointer:DWORD
COMM	_pglCopyPixels:DWORD
COMM	_pglCopyTexImage1D:DWORD
COMM	_pglCopyTexImage2D:DWORD
COMM	_pglCopyTexSubImage1D:DWORD
COMM	_pglCopyTexSubImage2D:DWORD
COMM	_pglCullFace:DWORD
COMM	_pglDeleteLists:DWORD
COMM	_pglDeleteTextures:DWORD
COMM	_pglDepthFunc:DWORD
COMM	_pglDepthMask:DWORD
COMM	_pglDepthRange:DWORD
COMM	_pglDisable:DWORD
COMM	_pglDisableClientState:DWORD
COMM	_pglDrawArrays:DWORD
COMM	_pglDrawBuffer:DWORD
COMM	_pglDrawElements:DWORD
COMM	_pglDrawPixels:DWORD
COMM	_pglEdgeFlag:DWORD
COMM	_pglEdgeFlagPointer:DWORD
COMM	_pglEdgeFlagv:DWORD
COMM	_pglEnable:DWORD
COMM	_pglEnableClientState:DWORD
COMM	_pglEnd:DWORD
COMM	_pglEndList:DWORD
COMM	_pglEvalCoord1d:DWORD
COMM	_pglEvalCoord1dv:DWORD
COMM	_pglEvalCoord1f:DWORD
COMM	_pglEvalCoord1fv:DWORD
COMM	_pglEvalCoord2d:DWORD
COMM	_pglEvalCoord2dv:DWORD
COMM	_pglEvalCoord2f:DWORD
COMM	_pglEvalCoord2fv:DWORD
COMM	_pglEvalMesh1:DWORD
COMM	_pglEvalMesh2:DWORD
COMM	_pglEvalPoint1:DWORD
COMM	_pglEvalPoint2:DWORD
COMM	_pglFeedbackBuffer:DWORD
COMM	_pglFinish:DWORD
COMM	_pglFlush:DWORD
COMM	_pglFogf:DWORD
COMM	_pglFogfv:DWORD
COMM	_pglFogi:DWORD
COMM	_pglFogiv:DWORD
COMM	_pglFrontFace:DWORD
COMM	_pglFrustum:DWORD
COMM	_pglGenTextures:DWORD
COMM	_pglGetBooleanv:DWORD
COMM	_pglGetClipPlane:DWORD
COMM	_pglGetDoublev:DWORD
COMM	_pglGetFloatv:DWORD
COMM	_pglGetIntegerv:DWORD
COMM	_pglGetLightfv:DWORD
COMM	_pglGetLightiv:DWORD
COMM	_pglGetMapdv:DWORD
COMM	_pglGetMapfv:DWORD
COMM	_pglGetMapiv:DWORD
COMM	_pglGetMaterialfv:DWORD
COMM	_pglGetMaterialiv:DWORD
COMM	_pglGetPixelMapfv:DWORD
COMM	_pglGetPixelMapuiv:DWORD
COMM	_pglGetPixelMapusv:DWORD
COMM	_pglGetPointerv:DWORD
COMM	_pglGetPolygonStipple:DWORD
COMM	_pglGetTexEnvfv:DWORD
COMM	_pglGetTexEnviv:DWORD
COMM	_pglGetTexGendv:DWORD
COMM	_pglGetTexGenfv:DWORD
COMM	_pglGetTexGeniv:DWORD
COMM	_pglGetTexImage:DWORD
COMM	_pglGetTexLevelParameterfv:DWORD
COMM	_pglGetTexLevelParameteriv:DWORD
COMM	_pglGetTexParameterfv:DWORD
COMM	_pglGetTexParameteriv:DWORD
COMM	_pglHint:DWORD
COMM	_pglIndexMask:DWORD
COMM	_pglIndexPointer:DWORD
COMM	_pglIndexd:DWORD
COMM	_pglIndexdv:DWORD
COMM	_pglIndexf:DWORD
COMM	_pglIndexfv:DWORD
COMM	_pglIndexi:DWORD
COMM	_pglIndexiv:DWORD
COMM	_pglIndexs:DWORD
COMM	_pglIndexsv:DWORD
COMM	_pglIndexub:DWORD
COMM	_pglIndexubv:DWORD
COMM	_pglInitNames:DWORD
COMM	_pglInterleavedArrays:DWORD
COMM	_pglLightModelf:DWORD
COMM	_pglLightModelfv:DWORD
COMM	_pglLightModeli:DWORD
COMM	_pglLightModeliv:DWORD
COMM	_pglLightf:DWORD
COMM	_pglLightfv:DWORD
COMM	_pglLighti:DWORD
COMM	_pglLightiv:DWORD
COMM	_pglLineStipple:DWORD
COMM	_pglLineWidth:DWORD
COMM	_pglListBase:DWORD
COMM	_pglLoadIdentity:DWORD
COMM	_pglLoadMatrixd:DWORD
COMM	_pglLoadMatrixf:DWORD
COMM	_pglLoadName:DWORD
COMM	_pglLogicOp:DWORD
COMM	_pglMap1d:DWORD
COMM	_pglMap1f:DWORD
COMM	_pglMap2d:DWORD
COMM	_pglMap2f:DWORD
COMM	_pglMapGrid1d:DWORD
COMM	_pglMapGrid1f:DWORD
COMM	_pglMapGrid2d:DWORD
COMM	_pglMapGrid2f:DWORD
COMM	_pglMaterialf:DWORD
COMM	_pglMaterialfv:DWORD
COMM	_pglMateriali:DWORD
COMM	_pglMaterialiv:DWORD
COMM	_pglMatrixMode:DWORD
COMM	_pglMultMatrixd:DWORD
COMM	_pglMultMatrixf:DWORD
COMM	_pglNewList:DWORD
COMM	_pglNormal3b:DWORD
COMM	_pglNormal3bv:DWORD
COMM	_pglNormal3d:DWORD
COMM	_pglNormal3dv:DWORD
COMM	_pglNormal3f:DWORD
COMM	_pglNormal3fv:DWORD
COMM	_pglNormal3i:DWORD
COMM	_pglNormal3iv:DWORD
COMM	_pglNormal3s:DWORD
COMM	_pglNormal3sv:DWORD
COMM	_pglNormalPointer:DWORD
COMM	_pglOrtho:DWORD
COMM	_pglPassThrough:DWORD
COMM	_pglPixelMapfv:DWORD
COMM	_pglPixelMapuiv:DWORD
COMM	_pglPixelMapusv:DWORD
COMM	_pglPixelStoref:DWORD
COMM	_pglPixelStorei:DWORD
COMM	_pglPixelTransferf:DWORD
COMM	_pglPixelTransferi:DWORD
COMM	_pglPixelZoom:DWORD
COMM	_pglPointSize:DWORD
COMM	_pglPolygonMode:DWORD
COMM	_pglPolygonOffset:DWORD
COMM	_pglPolygonStipple:DWORD
COMM	_pglPopAttrib:DWORD
COMM	_pglPopClientAttrib:DWORD
COMM	_pglPopMatrix:DWORD
COMM	_pglPopName:DWORD
COMM	_pglPushAttrib:DWORD
COMM	_pglPushClientAttrib:DWORD
COMM	_pglPushMatrix:DWORD
COMM	_pglPushName:DWORD
COMM	_pglRasterPos2d:DWORD
COMM	_pglRasterPos2dv:DWORD
COMM	_pglRasterPos2f:DWORD
COMM	_pglRasterPos2fv:DWORD
COMM	_pglRasterPos2i:DWORD
COMM	_pglRasterPos2iv:DWORD
COMM	_pglRasterPos2s:DWORD
COMM	_pglRasterPos2sv:DWORD
COMM	_pglRasterPos3d:DWORD
COMM	_pglRasterPos3dv:DWORD
COMM	_pglRasterPos3f:DWORD
COMM	_pglRasterPos3fv:DWORD
COMM	_pglRasterPos3i:DWORD
COMM	_pglRasterPos3iv:DWORD
COMM	_pglRasterPos3s:DWORD
COMM	_pglRasterPos3sv:DWORD
COMM	_pglRasterPos4d:DWORD
COMM	_pglRasterPos4dv:DWORD
COMM	_pglRasterPos4f:DWORD
COMM	_pglRasterPos4fv:DWORD
COMM	_pglRasterPos4i:DWORD
COMM	_pglRasterPos4iv:DWORD
COMM	_pglRasterPos4s:DWORD
COMM	_pglRasterPos4sv:DWORD
COMM	_pglReadBuffer:DWORD
COMM	_pglReadPixels:DWORD
COMM	_pglRectd:DWORD
COMM	_pglRectdv:DWORD
COMM	_pglRectf:DWORD
COMM	_pglRectfv:DWORD
COMM	_pglRecti:DWORD
COMM	_pglRectiv:DWORD
COMM	_pglRects:DWORD
COMM	_pglRectsv:DWORD
COMM	_pglRotated:DWORD
COMM	_pglRotatef:DWORD
COMM	_pglScaled:DWORD
COMM	_pglScalef:DWORD
COMM	_pglScissor:DWORD
COMM	_pglSelectBuffer:DWORD
COMM	_pglShadeModel:DWORD
COMM	_pglStencilFunc:DWORD
COMM	_pglStencilMask:DWORD
COMM	_pglStencilOp:DWORD
COMM	_pglTexCoord1d:DWORD
COMM	_pglTexCoord1dv:DWORD
COMM	_pglTexCoord1f:DWORD
COMM	_pglTexCoord1fv:DWORD
COMM	_pglTexCoord1i:DWORD
COMM	_pglTexCoord1iv:DWORD
COMM	_pglTexCoord1s:DWORD
COMM	_pglTexCoord1sv:DWORD
COMM	_pglTexCoord2d:DWORD
COMM	_pglTexCoord2dv:DWORD
COMM	_pglTexCoord2f:DWORD
COMM	_pglTexCoord2fv:DWORD
COMM	_pglTexCoord2i:DWORD
COMM	_pglTexCoord2iv:DWORD
COMM	_pglTexCoord2s:DWORD
COMM	_pglTexCoord2sv:DWORD
COMM	_pglTexCoord3d:DWORD
COMM	_pglTexCoord3dv:DWORD
COMM	_pglTexCoord3f:DWORD
COMM	_pglTexCoord3fv:DWORD
COMM	_pglTexCoord3i:DWORD
COMM	_pglTexCoord3iv:DWORD
COMM	_pglTexCoord3s:DWORD
COMM	_pglTexCoord3sv:DWORD
COMM	_pglTexCoord4d:DWORD
COMM	_pglTexCoord4dv:DWORD
COMM	_pglTexCoord4f:DWORD
COMM	_pglTexCoord4fv:DWORD
COMM	_pglTexCoord4i:DWORD
COMM	_pglTexCoord4iv:DWORD
COMM	_pglTexCoord4s:DWORD
COMM	_pglTexCoord4sv:DWORD
COMM	_pglTexCoordPointer:DWORD
COMM	_pglTexEnvf:DWORD
COMM	_pglTexEnvfv:DWORD
COMM	_pglTexEnvi:DWORD
COMM	_pglTexEnviv:DWORD
COMM	_pglTexGend:DWORD
COMM	_pglTexGendv:DWORD
COMM	_pglTexGenf:DWORD
COMM	_pglTexGenfv:DWORD
COMM	_pglTexGeni:DWORD
COMM	_pglTexGeniv:DWORD
COMM	_pglTexImage1D:DWORD
COMM	_pglTexImage2D:DWORD
COMM	_pglTexParameterf:DWORD
COMM	_pglTexParameterfv:DWORD
COMM	_pglTexParameteri:DWORD
COMM	_pglTexParameteriv:DWORD
COMM	_pglTexSubImage1D:DWORD
COMM	_pglTexSubImage2D:DWORD
COMM	_pglTranslated:DWORD
COMM	_pglTranslatef:DWORD
COMM	_pglVertex2d:DWORD
COMM	_pglVertex2dv:DWORD
COMM	_pglVertex2f:DWORD
COMM	_pglVertex2fv:DWORD
COMM	_pglVertex2i:DWORD
COMM	_pglVertex2iv:DWORD
COMM	_pglVertex2s:DWORD
COMM	_pglVertex2sv:DWORD
COMM	_pglVertex3d:DWORD
COMM	_pglVertex3dv:DWORD
COMM	_pglVertex3f:DWORD
COMM	_pglVertex3fv:DWORD
COMM	_pglVertex3i:DWORD
COMM	_pglVertex3iv:DWORD
COMM	_pglVertex3s:DWORD
COMM	_pglVertex3sv:DWORD
COMM	_pglVertex4d:DWORD
COMM	_pglVertex4dv:DWORD
COMM	_pglVertex4f:DWORD
COMM	_pglVertex4fv:DWORD
COMM	_pglVertex4i:DWORD
COMM	_pglVertex4iv:DWORD
COMM	_pglVertex4s:DWORD
COMM	_pglVertex4sv:DWORD
COMM	_pglVertexPointer:DWORD
COMM	_pglViewport:DWORD
COMM	_pglPointParameterfEXT:DWORD
COMM	_pglPointParameterfvEXT:DWORD
COMM	_pglLockArraysEXT:DWORD
COMM	_pglUnlockArraysEXT:DWORD
COMM	_pglActiveTextureARB:DWORD
COMM	_pglClientActiveTextureARB:DWORD
COMM	_pglGetCompressedTexImage:DWORD
COMM	_pglDrawRangeElements:DWORD
COMM	_pglDrawRangeElementsEXT:DWORD
COMM	_pglMultiTexCoord1f:DWORD
COMM	_pglMultiTexCoord2f:DWORD
COMM	_pglMultiTexCoord3f:DWORD
COMM	_pglMultiTexCoord4f:DWORD
COMM	_pglActiveTexture:DWORD
COMM	_pglClientActiveTexture:DWORD
COMM	_pglCompressedTexImage3DARB:DWORD
COMM	_pglCompressedTexImage2DARB:DWORD
COMM	_pglCompressedTexImage1DARB:DWORD
COMM	_pglCompressedTexSubImage3DARB:DWORD
COMM	_pglCompressedTexSubImage2DARB:DWORD
COMM	_pglCompressedTexSubImage1DARB:DWORD
COMM	_pglDeleteObjectARB:DWORD
COMM	_pglGetHandleARB:DWORD
COMM	_pglDetachObjectARB:DWORD
COMM	_pglCreateShaderObjectARB:DWORD
COMM	_pglShaderSourceARB:DWORD
COMM	_pglCompileShaderARB:DWORD
COMM	_pglCreateProgramObjectARB:DWORD
COMM	_pglAttachObjectARB:DWORD
COMM	_pglLinkProgramARB:DWORD
COMM	_pglUseProgramObjectARB:DWORD
COMM	_pglValidateProgramARB:DWORD
COMM	_pglBindProgramARB:DWORD
COMM	_pglDeleteProgramsARB:DWORD
COMM	_pglGenProgramsARB:DWORD
COMM	_pglProgramStringARB:DWORD
COMM	_pglProgramEnvParameter4fARB:DWORD
COMM	_pglProgramLocalParameter4fARB:DWORD
COMM	_pglUniform1fARB:DWORD
COMM	_pglUniform2fARB:DWORD
COMM	_pglUniform3fARB:DWORD
COMM	_pglUniform4fARB:DWORD
COMM	_pglUniform1iARB:DWORD
COMM	_pglUniform2iARB:DWORD
COMM	_pglUniform3iARB:DWORD
COMM	_pglUniform4iARB:DWORD
COMM	_pglUniform1fvARB:DWORD
COMM	_pglUniform2fvARB:DWORD
COMM	_pglUniform3fvARB:DWORD
COMM	_pglUniform4fvARB:DWORD
COMM	_pglUniform1ivARB:DWORD
COMM	_pglUniform2ivARB:DWORD
COMM	_pglUniform3ivARB:DWORD
COMM	_pglUniform4ivARB:DWORD
COMM	_pglUniformMatrix2fvARB:DWORD
COMM	_pglUniformMatrix3fvARB:DWORD
COMM	_pglUniformMatrix4fvARB:DWORD
COMM	_pglGetObjectParameterfvARB:DWORD
COMM	_pglGetObjectParameterivARB:DWORD
COMM	_pglGetInfoLogARB:DWORD
COMM	_pglGetAttachedObjectsARB:DWORD
COMM	_pglGetUniformLocationARB:DWORD
COMM	_pglGetActiveUniformARB:DWORD
COMM	_pglGetUniformfvARB:DWORD
COMM	_pglGetUniformivARB:DWORD
COMM	_pglGetShaderSourceARB:DWORD
COMM	_pglTexImage3D:DWORD
COMM	_pglTexSubImage3D:DWORD
COMM	_pglCopyTexSubImage3D:DWORD
COMM	_pglBlendEquationEXT:DWORD
COMM	_pglStencilOpSeparate:DWORD
COMM	_pglStencilFuncSeparate:DWORD
COMM	_pglActiveStencilFaceEXT:DWORD
COMM	_pglVertexAttribPointerARB:DWORD
COMM	_pglEnableVertexAttribArrayARB:DWORD
COMM	_pglDisableVertexAttribArrayARB:DWORD
COMM	_pglBindAttribLocationARB:DWORD
COMM	_pglGetActiveAttribARB:DWORD
COMM	_pglGetAttribLocationARB:DWORD
COMM	_pglBindFragDataLocation:DWORD
COMM	_pglVertexAttrib2fARB:DWORD
COMM	_pglVertexAttrib2fvARB:DWORD
COMM	_pglVertexAttrib3fvARB:DWORD
COMM	_pglBindBufferARB:DWORD
COMM	_pglDeleteBuffersARB:DWORD
COMM	_pglGenBuffersARB:DWORD
COMM	_pglIsBufferARB:DWORD
COMM	_pglMapBufferARB:DWORD
COMM	_pglUnmapBufferARB:DWORD
COMM	_pglBufferDataARB:DWORD
COMM	_pglBufferSubDataARB:DWORD
COMM	_pglGenQueriesARB:DWORD
COMM	_pglDeleteQueriesARB:DWORD
COMM	_pglIsQueryARB:DWORD
COMM	_pglBeginQueryARB:DWORD
COMM	_pglEndQueryARB:DWORD
COMM	_pglGetQueryivARB:DWORD
COMM	_pglGetQueryObjectivARB:DWORD
COMM	_pglGetQueryObjectuivARB:DWORD
COMM	_pglDebugMessageControlARB:DWORD
COMM	_pglDebugMessageInsertARB:DWORD
COMM	_pglDebugMessageCallbackARB:DWORD
COMM	_pglGetDebugMessageLogARB:DWORD
COMM	_pglIsRenderbuffer:DWORD
COMM	_pglBindRenderbuffer:DWORD
COMM	_pglDeleteRenderbuffers:DWORD
COMM	_pglGenRenderbuffers:DWORD
COMM	_pglRenderbufferStorage:DWORD
COMM	_pglRenderbufferStorageMultisample:DWORD
COMM	_pglGetRenderbufferParameteriv:DWORD
COMM	_pglIsFramebuffer:DWORD
COMM	_pglBindFramebuffer:DWORD
COMM	_pglDeleteFramebuffers:DWORD
COMM	_pglGenFramebuffers:DWORD
COMM	_pglCheckFramebufferStatus:DWORD
COMM	_pglFramebufferTexture1D:DWORD
COMM	_pglFramebufferTexture2D:DWORD
COMM	_pglFramebufferTexture3D:DWORD
COMM	_pglFramebufferTextureLayer:DWORD
COMM	_pglFramebufferRenderbuffer:DWORD
COMM	_pglGetFramebufferAttachmentParameteriv:DWORD
COMM	_pglBlitFramebuffer:DWORD
COMM	_pglDrawBuffersARB:DWORD
COMM	_pglGenerateMipmap:DWORD
COMM	_pglBindVertexArray:DWORD
COMM	_pglDeleteVertexArrays:DWORD
COMM	_pglGenVertexArrays:DWORD
COMM	_pglIsVertexArray:DWORD
COMM	_pglSwapInterval:DWORD
COMM	_pwglSwapBuffers:DWORD
COMM	_pwglCopyContext:DWORD
COMM	_pwglCreateContext:DWORD
COMM	_pwglCreateLayerContext:DWORD
COMM	_pwglDeleteContext:DWORD
COMM	_pwglGetCurrentContext:DWORD
COMM	_pwglGetProcAddress:DWORD
COMM	_pwglMakeCurrent:DWORD
COMM	_pwglShareLists:DWORD
COMM	_pwglUseFontBitmaps:DWORD
COMM	_pwglUseFontOutlines:DWORD
COMM	_pwglDescribeLayerPlane:DWORD
COMM	_pwglSetLayerPaletteEntries:DWORD
COMM	_pwglGetLayerPaletteEntries:DWORD
COMM	_pwglRealizeLayerPalette:DWORD
COMM	_pwglSwapLayerBuffers:DWORD
COMM	_pwglSwapIntervalEXT:DWORD
COMM	_pwglCreateContextAttribsARB:DWORD
COMM	_pwglGetPixelFormatAttribiv:DWORD
COMM	_pwglChoosePixelFormat:DWORD
COMM	_pwglGetExtensionsStringEXT:DWORD
COMM	_demo:BYTE:0208H
_DATA	ENDS
;	COMDAT ??_C@_08KBFAFKBO@dem_stop@
CONST	SEGMENT
??_C@_08KBFAFKBO@dem_stop@ DB 'dem_stop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@INBJIDMD@dem_usercmd@
CONST	SEGMENT
??_C@_0M@INBJIDMD@dem_usercmd@ DB 'dem_usercmd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKNGBALH@dem_userdata@
CONST	SEGMENT
??_C@_0N@JKNGBALH@dem_userdata@ DB 'dem_userdata', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDCIJJGK@dem_jumptime@
CONST	SEGMENT
??_C@_0N@IDCIJJGK@dem_jumptime@ DB 'dem_jumptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FAKFLJAL@dem_read@
CONST	SEGMENT
??_C@_08FAKFLJAL@dem_read@ DB 'dem_read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNMPGPEC@dem_norewind@
CONST	SEGMENT
??_C@_0N@KNMPGPEC@dem_norewind@ DB 'dem_norewind', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFICBEKK@dem_unknown@
CONST	SEGMENT
??_C@_0M@LFICBEKK@dem_unknown@ DB 'dem_unknown', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_demo_cmd DD	FLAT:??_C@_0M@LFICBEKK@dem_unknown@
	DD	FLAT:??_C@_0N@KNMPGPEC@dem_norewind@
	DD	FLAT:??_C@_08FAKFLJAL@dem_read@
	DD	FLAT:??_C@_0N@IDCIJJGK@dem_jumptime@
	DD	FLAT:??_C@_0N@JKNGBALH@dem_userdata@
	DD	FLAT:??_C@_0M@INBJIDMD@dem_usercmd@
	DD	FLAT:??_C@_08KBFAFKBO@dem_stop@
_DATA	ENDS
PUBLIC	_CL_GetDemoComment
PUBLIC	_CL_GetDemoFramerate
PUBLIC	_CL_StopPlayback
PUBLIC	_CL_NextDemo
PUBLIC	_BitByte
PUBLIC	_MSG_GetNumBytesWritten
PUBLIC	_MSG_GetData
PUBLIC	_CL_StartupDemoHeader
PUBLIC	_CL_DrawDemoRecording
PUBLIC	_CL_WriteDemoUserCmd
PUBLIC	_CL_WriteDemoMessage
PUBLIC	_CL_WriteDemoUserMessage
PUBLIC	_CL_DemoReadMessage
PUBLIC	_CL_DemoInterpolateAngles
PUBLIC	_CL_CheckStartupDemos
PUBLIC	_CL_WriteDemoJumpTime
PUBLIC	_CL_CloseDemoHeader
PUBLIC	_CL_DemoCompleted
PUBLIC	_CL_StopRecord
PUBLIC	_CL_PlayDemo_f
PUBLIC	_CL_TimeDemo_f
PUBLIC	_CL_StartDemos_f
PUBLIC	_CL_Demos_f
PUBLIC	_CL_Record_f
PUBLIC	_CL_Stop_f
PUBLIC	_CL_GetDemoRecordClock
PUBLIC	_CL_GetDemoPlaybackClock
PUBLIC	_CL_WriteDemoCmdHeader
PUBLIC	_CL_WriteDemoSequence
PUBLIC	_CL_WriteDemoHeader
PUBLIC	_CL_ReadDemoCmdHeader
PUBLIC	_CL_ReadDemoUserCmd
PUBLIC	_CL_ReadDemoSequence
PUBLIC	_CL_DemoStartPlayback
PUBLIC	_CL_DemoAborted
PUBLIC	_CL_DemoMoveToNextSection
PUBLIC	_CL_ReadRawNetworkData
PUBLIC	_CL_DemoReadMessageQuake
PUBLIC	_CL_DemoFindInterpolatedViewAngles
PUBLIC	_CL_FinishTimeDemo
PUBLIC	??_C@_03ELIABIOC@w?$CLb@			; `string'
PUBLIC	??_C@_0P@FDJBLPMJ@demoheader?4tmp@		; `string'
PUBLIC	??_C@_0DB@JOENKEFE@?$FO1Error?3?$FO7?5couldn?8t?5open?5tempor@ ; `string'
PUBLIC	??_C@_0BH@KHFPKOBF@Spooling?5demo?5header?4?6@	; `string'
PUBLIC	?__LINE__Var@?0??CL_WriteDemoCmdHeader@@9@9	; `CL_WriteDemoCmdHeader'::`1'::__LINE__Var
PUBLIC	??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ ; `string'
PUBLIC	??_C@_0BP@HPDCKCMF@cmd?5?$DO?$DN?51?5?$CG?$CG?5cmd?5?$DM?$DN?5dem_lastcmd@ ; `string'
PUBLIC	??_C@_07EJIPDLMH@UserCmd@			; `string'
PUBLIC	?__LINE__Var@?0??CL_WriteDemoSequence@@9@9	; `CL_WriteDemoSequence'::`1'::__LINE__Var
PUBLIC	??_C@_0N@MBAPGNHG@file?5?$CB?$DN?5NULL@		; `string'
PUBLIC	?__LINE__Var@?0??CL_WriteDemoHeader@@9@9	; `CL_WriteDemoHeader'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@PMCLPAOL@recording?5to?5?$CFs?4?6@	; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0M@NCPNBCGD@fullupdate?6@			; `string'
PUBLIC	?__LINE__Var@?0??CL_StopRecord@@9@9		; `CL_StopRecord'::`1'::__LINE__Var
PUBLIC	??_C@_0DF@ICOLEAFE@Completed?5demo?6Recording?5time?3?5@ ; `string'
PUBLIC	??_C@_0CG@CPGNIJNE@?$FO1RECORDING?3?$FO7?5?$CFs?3?5?$CFs?5time?3?5?$CF02@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_ReadDemoCmdHeader@@9@9	; `CL_ReadDemoCmdHeader'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@CKNEEIIK@?$CKcmd?5?$DO?$DN?51?5?$CG?$CG?5?$CKcmd?5?$DM?$DN?5dem_lastcm@ ; `string'
PUBLIC	??_C@_09HOOHLIKH@net_qport@			; `string'
PUBLIC	??_C@_06COKHDAAL@v_dark@			; `string'
PUBLIC	?__LINE__Var@?0??CL_ReadRawNetworkData@@9@9	; `CL_ReadRawNetworkData'::`1'::__LINE__Var
PUBLIC	??_C@_0P@FBHHDKCM@buffer?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0P@EEOEILBN@length?5?$CB?$DN?5NULL@	; `string'
PUBLIC	??_C@_0CE@EHAEKDPM@?$FO1Error?3?$FO7?5Demo?5message?5length?5@ ; `string'
PUBLIC	??_C@_0CB@NNICALKP@?$FO1Error?3?$FO7?5Demo?5message?5?$CFi?5?$DO?5?$CFi@ ; `string'
PUBLIC	??_C@_0CM@IJBEDAC@?$FO1Error?3?$FO7?5Error?5reading?5demo?5m@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_DemoReadMessage@@9@9	; `CL_DemoReadMessage'::`1'::__LINE__Var
PUBLIC	??_C@_0CD@PBKBJCHL@?$CFi?5frames?5?$CF5?43f?5seconds?5?$CF5?43f?5f@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_StopPlayback@@9@9		; `CL_StopPlayback'::`1'::__LINE__Var
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_0O@NGAMONDD@cl_background@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@		; `string'
PUBLIC	??_C@_0BD@FFMIBALC@?$DMinvalid?5protocol?$DO@	; `string'
PUBLIC	??_C@_06FCGABIIB@?$CFg?5sec@			; `string'
PUBLIC	??_C@_0CB@CFHCDJLA@no?5demos?5listed?5with?5startdemos@ ; `string'
PUBLIC	??_C@_0N@IMBDKDIM@playdemo?5?$CFs?6@		; `string'
PUBLIC	??_C@_08JHJNDLPF@demo9999@			; `string'
PUBLIC	??_C@_0N@EFJGOOKC@demo?$CFi?$CFi?$CFi?$CFi@	; `string'
PUBLIC	??_C@_03CLCAEGCJ@new@				; `string'
PUBLIC	??_C@_0BK@GAMAPOBB@Usage?3?5record?5?$DMdemoname?$DO?6@ ; `string'
PUBLIC	??_C@_0BE@GOGLPLDO@Already?5recording?4?6@	; `string'
PUBLIC	??_C@_0CE@JONEFKEO@Can?8t?5record?5during?5demo?5playba@ ; `string'
PUBLIC	??_C@_0CD@JLOAFGIP@You?5must?5be?5in?5a?5level?5to?5recor@ ; `string'
PUBLIC	??_C@_06CGFKKEMF@?$CFs?4dem@			; `string'
PUBLIC	??_C@_0CN@IFAPNGAK@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5de@ ; `string'
PUBLIC	?__LINE__Var@?0??CL_PlayDemo_f@@9@9		; `CL_PlayDemo_f'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@MMEGPPDD@Usage?3?5playdemo?5?$DMdemoname?$DO?6@ ; `string'
PUBLIC	??_C@_0CE@BCMNCJOD@Can?8t?5playback?5during?5demo?5reco@ ; `string'
PUBLIC	??_C@_08DAPDEFAC@lastdemo@			; `string'
PUBLIC	??_C@_0BN@JCJEHCDP@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CC@HOPJFPNL@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5a?5demo?5fil@ ; `string'
PUBLIC	??_C@_0DP@IGNNJFBI@?$FO1Error?3?$FO7?5playdemo?3?5demo?5proto@ ; `string'
PUBLIC	??_C@_0DO@MFOJFLLP@?$FO1Error?3?$FO7?5playdemo?3?5net?5protoc@ ; `string'
PUBLIC	??_C@_0DG@HAPBGNEA@?$FO1Error?3?$FO7?5demo?5had?5bogus?5?$CD?5of?5@ ; `string'
PUBLIC	??_C@_0BM@CHKGBOOC@Usage?3?5timedemo?5?$DMdemoname?$DO?6@ ; `string'
PUBLIC	??_C@_0CM@HAFACEJC@?8startdemos?8?5is?5not?5valid?5from?5@ ; `string'
PUBLIC	??_C@_0DI@IHKDLIPA@?$FO3Warning?3?$FO7?5Host_StartDemos?3?5m@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s@				; `string'
PUBLIC	??_C@_0BD@HJODIKBK@?$CFi?5demo?$CFs?5in?5loop?6@ ; `string'
PUBLIC	??_C@_0CH@LMAJFMII@?8demos?8?5is?5not?5valid?5from?5the?5c@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fb99999a0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@404e000000000000
PUBLIC	__real@4069000000000000
EXTRN	_memset:PROC
EXTRN	_Cbuf_InsertText:PROC
EXTRN	_Cbuf_Execute:PROC
EXTRN	_Cmd_Argc:PROC
EXTRN	_Cmd_Argv:PROC
EXTRN	_Q_strncpy:PROC
EXTRN	_Q_atoi:PROC
EXTRN	_Q_strnicmp:PROC
EXTRN	_Q_snprintf:PROC
EXTRN	_Q_sprintf:PROC
EXTRN	_Q_pretifymem:PROC
EXTRN	_va:PROC
EXTRN	__Mem_Alloc:PROC
EXTRN	__Mem_Free:PROC
EXTRN	_Cvar_FullSet:PROC
EXTRN	_Cvar_Set:PROC
EXTRN	_Cvar_SetValue:PROC
EXTRN	_Cvar_VariableInteger:PROC
EXTRN	_DBG_AssertFunction:PROC
EXTRN	_FS_Open:PROC
EXTRN	_FS_Write:PROC
EXTRN	_FS_Read:PROC
EXTRN	_FS_Seek:PROC
EXTRN	_FS_FileExists:PROC
EXTRN	_FS_FileCopy:PROC
EXTRN	_FS_Delete:PROC
EXTRN	_COM_StripExtension:PROC
EXTRN	_FS_Tell:PROC
EXTRN	_FS_Close:PROC
EXTRN	_FS_Getc:PROC
EXTRN	_Host_ShutdownServer:PROC
EXTRN	_SV_Active:PROC
EXTRN	_Con_Reportf:PROC
EXTRN	_Con_DPrintf:PROC
EXTRN	_Con_Printf:PROC
EXTRN	_CL_Disconnect:PROC
EXTRN	_SCR_BeginLoadingPlaque:PROC
EXTRN	_UI_SetActiveMenu:PROC
EXTRN	_S_StopBackgroundTrack:PROC
EXTRN	_S_StopAllSounds:PROC
EXTRN	_fmod:PROC
EXTRN	_AngleQuaternion:PROC
EXTRN	_QuaternionAngle:PROC
EXTRN	_QuaternionSlerp:PROC
EXTRN	_MSG_InitExt:PROC
EXTRN	_Netchan_Setup:PROC
EXTRN	_CL_WriteUsercmd:PROC
EXTRN	_CL_GetFragmentSize:PROC
EXTRN	_CL_ClearState:PROC
EXTRN	_CL_InitEdicts:PROC
EXTRN	_Con_DrawStringLen:PROC
EXTRN	_Con_DrawString:PROC
EXTRN	_Con_FastClose:PROC
EXTRN	_SCR_StopCinematic:PROC
EXTRN	_MSG_ReadDeltaUsercmd:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_host_developer:BYTE
EXTRN	_host_maxfps:DWORD
EXTRN	_host:BYTE
EXTRN	_SI:BYTE
EXTRN	_net_from:BYTE
EXTRN	_CL_UPDATE_BACKUP:DWORD
EXTRN	_cl:BYTE
EXTRN	_cls:BYTE
EXTRN	_clgame:BYTE
EXTRN	_gameui:BYTE
EXTRN	_glState:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?tdlastdemoframe@?1??CL_DemoReadMessage@@9@9 DD 01H DUP (?) ; `CL_DemoReadMessage'::`2'::tdlastdemoframe
_BSS	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@404e000000000000
CONST	SEGMENT
__real@404e000000000000 DQ 0404e000000000000r	; 60
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fb99999a0000000
CONST	SEGMENT
__real@3fb99999a0000000 DQ 03fb99999a0000000r	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CH@LMAJFMII@?8demos?8?5is?5not?5valid?5from?5the?5c@
CONST	SEGMENT
??_C@_0CH@LMAJFMII@?8demos?8?5is?5not?5valid?5from?5the?5c@ DB '''demos'''
	DB	' is not valid from the console', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJODIKBK@?$CFi?5demo?$CFs?5in?5loop?6@
CONST	SEGMENT
??_C@_0BD@HJODIKBK@?$CFi?5demo?$CFs?5in?5loop?6@ DB '%i demo%s in loop', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s@
CONST	SEGMENT
??_C@_01LKDEMHDF@s@ DB 's', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IHKDLIPA@?$FO3Warning?3?$FO7?5Host_StartDemos?3?5m@
CONST	SEGMENT
??_C@_0DI@IHKDLIPA@?$FO3Warning?3?$FO7?5Host_StartDemos?3?5m@ DB '^3Warni'
	DB	'ng:^7 Host_StartDemos: max %i demos in demoloop', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HAFACEJC@?8startdemos?8?5is?5not?5valid?5from?5@
CONST	SEGMENT
??_C@_0CM@HAFACEJC@?8startdemos?8?5is?5not?5valid?5from?5@ DB '''startdem'
	DB	'os'' is not valid from the console', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CHKGBOOC@Usage?3?5timedemo?5?$DMdemoname?$DO?6@
CONST	SEGMENT
??_C@_0BM@CHKGBOOC@Usage?3?5timedemo?5?$DMdemoname?$DO?6@ DB 'Usage: time'
	DB	'demo <demoname>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HAPBGNEA@?$FO1Error?3?$FO7?5demo?5had?5bogus?5?$CD?5of?5@
CONST	SEGMENT
??_C@_0DG@HAPBGNEA@?$FO1Error?3?$FO7?5demo?5had?5bogus?5?$CD?5of?5@ DB '^'
	DB	'1Error:^7 demo had bogus # of directory entries: %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MFOJFLLP@?$FO1Error?3?$FO7?5playdemo?3?5net?5protoc@
CONST	SEGMENT
??_C@_0DO@MFOJFLLP@?$FO1Error?3?$FO7?5playdemo?3?5net?5protoc@ DB '^1Erro'
	DB	'r:^7 playdemo: net protocol outdated (%i should be %i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IGNNJFBI@?$FO1Error?3?$FO7?5playdemo?3?5demo?5proto@
CONST	SEGMENT
??_C@_0DP@IGNNJFBI@?$FO1Error?3?$FO7?5playdemo?3?5demo?5proto@ DB '^1Erro'
	DB	'r:^7 playdemo: demo protocol outdated (%i should be %i)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HOPJFPNL@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5a?5demo?5fil@
CONST	SEGMENT
??_C@_0CC@HOPJFPNL@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5a?5demo?5fil@ DB '^'
	DB	'1Error:^7 %s is not a demo file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JCJEHCDP@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?6@
CONST	SEGMENT
??_C@_0BN@JCJEHCDP@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?6@ DB '^1Err'
	DB	'or:^7 couldn''t open %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAPDEFAC@lastdemo@
CONST	SEGMENT
??_C@_08DAPDEFAC@lastdemo@ DB 'lastdemo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BCMNCJOD@Can?8t?5playback?5during?5demo?5reco@
CONST	SEGMENT
??_C@_0CE@BCMNCJOD@Can?8t?5playback?5during?5demo?5reco@ DB 'Can''t playb'
	DB	'ack during demo record.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMEGPPDD@Usage?3?5playdemo?5?$DMdemoname?$DO?6@
CONST	SEGMENT
??_C@_0BM@MMEGPPDD@Usage?3?5playdemo?5?$DMdemoname?$DO?6@ DB 'Usage: play'
	DB	'demo <demoname>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_PlayDemo_f@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_PlayDemo_f@@9@9 DD 0582H		; `CL_PlayDemo_f'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CN@IFAPNGAK@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5de@
CONST	SEGMENT
??_C@_0CN@IFAPNGAK@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5de@ DB '^1Err'
	DB	'or:^7 no free slots for demo recording', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGFKKEMF@?$CFs?4dem@
CONST	SEGMENT
??_C@_06CGFKKEMF@?$CFs?4dem@ DB '%s.dem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JLOAFGIP@You?5must?5be?5in?5a?5level?5to?5recor@
CONST	SEGMENT
??_C@_0CD@JLOAFGIP@You?5must?5be?5in?5a?5level?5to?5recor@ DB 'You must b'
	DB	'e in a level to record.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JONEFKEO@Can?8t?5record?5during?5demo?5playba@
CONST	SEGMENT
??_C@_0CE@JONEFKEO@Can?8t?5record?5during?5demo?5playba@ DB 'Can''t recor'
	DB	'd during demo playback.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOGLPLDO@Already?5recording?4?6@
CONST	SEGMENT
??_C@_0BE@GOGLPLDO@Already?5recording?4?6@ DB 'Already recording.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GAMAPOBB@Usage?3?5record?5?$DMdemoname?$DO?6@
CONST	SEGMENT
??_C@_0BK@GAMAPOBB@Usage?3?5record?5?$DMdemoname?$DO?6@ DB 'Usage: record'
	DB	' <demoname>', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLCAEGCJ@new@
CONST	SEGMENT
??_C@_03CLCAEGCJ@new@ DB 'new', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EFJGOOKC@demo?$CFi?$CFi?$CFi?$CFi@
CONST	SEGMENT
??_C@_0N@EFJGOOKC@demo?$CFi?$CFi?$CFi?$CFi@ DB 'demo%i%i%i%i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHJNDLPF@demo9999@
CONST	SEGMENT
??_C@_08JHJNDLPF@demo9999@ DB 'demo9999', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IMBDKDIM@playdemo?5?$CFs?6@
CONST	SEGMENT
??_C@_0N@IMBDKDIM@playdemo?5?$CFs?6@ DB 'playdemo %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CFHCDJLA@no?5demos?5listed?5with?5startdemos@
CONST	SEGMENT
??_C@_0CB@CFHCDJLA@no?5demos?5listed?5with?5startdemos@ DB 'no demos list'
	DB	'ed with startdemos', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FCGABIIB@?$CFg?5sec@
CONST	SEGMENT
??_C@_06FCGABIIB@?$CFg?5sec@ DB '%g sec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFMIBALC@?$DMinvalid?5protocol?$DO@
CONST	SEGMENT
??_C@_0BD@FFMIBALC@?$DMinvalid?5protocol?$DO@ DB '<invalid protocol>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@
CONST	SEGMENT
??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@ DB '<corrupted>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGAMONDD@cl_background@
CONST	SEGMENT
??_C@_0O@NGAMONDD@cl_background@ DB 'cl_background', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_StopPlayback@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_StopPlayback@@9@9 DD 0462H		; `CL_StopPlayback'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CD@PBKBJCHL@?$CFi?5frames?5?$CF5?43f?5seconds?5?$CF5?43f?5f@
CONST	SEGMENT
??_C@_0CD@PBKBJCHL@?$CFi?5frames?5?$CF5?43f?5seconds?5?$CF5?43f?5f@ DB '%'
	DB	'i frames %5.3f seconds %5.3f fps', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_DemoReadMessage@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_DemoReadMessage@@9@9 DD 0374H	; `CL_DemoReadMessage'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CM@IJBEDAC@?$FO1Error?3?$FO7?5Error?5reading?5demo?5m@
CONST	SEGMENT
??_C@_0CM@IJBEDAC@?$FO1Error?3?$FO7?5Error?5reading?5demo?5m@ DB '^1Error'
	DB	':^7 Error reading demo message data', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NNICALKP@?$FO1Error?3?$FO7?5Demo?5message?5?$CFi?5?$DO?5?$CFi@
CONST	SEGMENT
??_C@_0CB@NNICALKP@?$FO1Error?3?$FO7?5Demo?5message?5?$CFi?5?$DO?5?$CFi@ DB '^'
	DB	'1Error:^7 Demo message %i > %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EHAEKDPM@?$FO1Error?3?$FO7?5Demo?5message?5length?5@
CONST	SEGMENT
??_C@_0CE@EHAEKDPM@?$FO1Error?3?$FO7?5Demo?5message?5length?5@ DB '^1Erro'
	DB	'r:^7 Demo message length < 0', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEOEILBN@length?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@EEOEILBN@length?5?$CB?$DN?5NULL@ DB 'length != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBHHDKCM@buffer?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0P@FBHHDKCM@buffer?5?$CB?$DN?5NULL@ DB 'buffer != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ReadRawNetworkData@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ReadRawNetworkData@@9@9 DD 02e4H	; `CL_ReadRawNetworkData'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06COKHDAAL@v_dark@
CONST	SEGMENT
??_C@_06COKHDAAL@v_dark@ DB 'v_dark', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOOHLIKH@net_qport@
CONST	SEGMENT
??_C@_09HOOHLIKH@net_qport@ DB 'net_qport', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CKNEEIIK@?$CKcmd?5?$DO?$DN?51?5?$CG?$CG?5?$CKcmd?5?$DM?$DN?5dem_lastcm@
CONST	SEGMENT
??_C@_0CB@CKNEEIIK@?$CKcmd?5?$DO?$DN?51?5?$CG?$CG?5?$CKcmd?5?$DM?$DN?5dem_lastcm@ DB '*'
	DB	'cmd >= 1 && *cmd <= dem_lastcmd', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_ReadDemoCmdHeader@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_ReadDemoCmdHeader@@9@9 DD 0209H	; `CL_ReadDemoCmdHeader'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@CPGNIJNE@?$FO1RECORDING?3?$FO7?5?$CFs?3?5?$CFs?5time?3?5?$CF02@
CONST	SEGMENT
??_C@_0CG@CPGNIJNE@?$FO1RECORDING?3?$FO7?5?$CFs?3?5?$CFs?5time?3?5?$CF02@ DB '^'
	DB	'1RECORDING:^7 %s: %s time: %02d:%02d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ICOLEAFE@Completed?5demo?6Recording?5time?3?5@
CONST	SEGMENT
??_C@_0DF@ICOLEAFE@Completed?5demo?6Recording?5time?3?5@ DB 'Completed de'
	DB	'mo', 0aH, 'Recording time: %02d:%02d, frames %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_StopRecord@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_StopRecord@@9@9 DD 01b7H		; `CL_StopRecord'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@NCPNBCGD@fullupdate?6@
CONST	SEGMENT
??_C@_0M@NCPNBCGD@fullupdate?6@ DB 'fullupdate', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@ DB '^1E'
	DB	'rror:^7 couldn''t open %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PMCLPAOL@recording?5to?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0BC@PMCLPAOL@recording?5to?5?$CFs?4?6@ DB 'recording to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_WriteDemoHeader@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_WriteDemoHeader@@9@9 DD 015fH	; `CL_WriteDemoHeader'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@MBAPGNHG@file?5?$CB?$DN?5NULL@
CONST	SEGMENT
??_C@_0N@MBAPGNHG@file?5?$CB?$DN?5NULL@ DB 'file != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_WriteDemoSequence@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_WriteDemoSequence@@9@9 DD 010eH	; `CL_WriteDemoSequence'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07EJIPDLMH@UserCmd@
CONST	SEGMENT
??_C@_07EJIPDLMH@UserCmd@ DB 'UserCmd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HPDCKCMF@cmd?5?$DO?$DN?51?5?$CG?$CG?5cmd?5?$DM?$DN?5dem_lastcmd@
CONST	SEGMENT
??_C@_0BP@HPDCKCMF@cmd?5?$DO?$DN?51?5?$CG?$CG?5cmd?5?$DM?$DN?5dem_lastcmd@ DB 'c'
	DB	'md >= 1 && cmd <= dem_lastcmd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
CONST	SEGMENT
??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@ DB 'D:\DevDrago'
	DB	'n\XashFE\dev\src\engine\client\cl_demo.c', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??CL_WriteDemoCmdHeader@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??CL_WriteDemoCmdHeader@@9@9 DD 0c5H	; `CL_WriteDemoCmdHeader'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@KHFPKOBF@Spooling?5demo?5header?4?6@
CONST	SEGMENT
??_C@_0BH@KHFPKOBF@Spooling?5demo?5header?4?6@ DB 'Spooling demo header.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JOENKEFE@?$FO1Error?3?$FO7?5couldn?8t?5open?5tempor@
CONST	SEGMENT
??_C@_0DB@JOENKEFE@?$FO1Error?3?$FO7?5couldn?8t?5open?5tempor@ DB '^1Erro'
	DB	'r:^7 couldn''t open temporary header file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDJBLPMJ@demoheader?4tmp@
CONST	SEGMENT
??_C@_0P@FDJBLPMJ@demoheader?4tmp@ DB 'demoheader.tmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELIABIOC@w?$CLb@
CONST	SEGMENT
??_C@_03ELIABIOC@w?$CLb@ DB 'w+b', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0dH
	DW	0293H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0232H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01f9H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	03eeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	01ceH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0dbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	0105H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	0dbH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	010H
	DW	021eH
voltbl	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoGetName
_TEXT	SEGMENT
_d$ = -16						; size = 4
_c$ = -12						; size = 4
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_lastnum$ = 8						; size = 4
_filename$ = 12						; size = 4
_CL_DemoGetName PROC					; COMDAT

; 1304 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1305 : 	int	a, b, c, d;
; 1306 : 
; 1307 : 	if( lastnum < 0 || lastnum > 9999 )

	cmp	DWORD PTR _lastnum$[ebp], 0
	jl	SHORT $LN3@CL_DemoGet
	cmp	DWORD PTR _lastnum$[ebp], 9999		; 0000270fH
	jle	SHORT $LN2@CL_DemoGet
$LN3@CL_DemoGet:

; 1308 : 	{
; 1309 : 		// bound
; 1310 : 		Q_strcpy( filename, "demo9999" );

	push	99999					; 0001869fH
	push	OFFSET ??_C@_08JHJNDLPF@demo9999@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1311 : 		return;

	jmp	SHORT $LN1@CL_DemoGet
$LN2@CL_DemoGet:

; 1312 : 	}
; 1313 : 
; 1314 : 	a = lastnum / 1000;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _a$[ebp], eax

; 1315 : 	lastnum -= a * 1000;

	imul	eax, DWORD PTR _a$[ebp], 1000
	mov	ecx, DWORD PTR _lastnum$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lastnum$[ebp], ecx

; 1316 : 	b = lastnum / 100;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _b$[ebp], eax

; 1317 : 	lastnum -= b * 100;

	imul	eax, DWORD PTR _b$[ebp], 100
	mov	ecx, DWORD PTR _lastnum$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lastnum$[ebp], ecx

; 1318 : 	c = lastnum / 10;

	mov	eax, DWORD PTR _lastnum$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _c$[ebp], eax

; 1319 : 	lastnum -= c * 10;

	imul	eax, DWORD PTR _c$[ebp], 10
	mov	ecx, DWORD PTR _lastnum$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lastnum$[ebp], ecx

; 1320 : 	d = lastnum;

	mov	eax, DWORD PTR _lastnum$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1321 : 
; 1322 : 	Q_sprintf( filename, "demo%i%i%i%i", a, b, c, d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b$[ebp]
	push	edx
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@EFJGOOKC@demo?$CFi?$CFi?$CFi?$CFi@
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 24					; 00000018H
$LN1@CL_DemoGet:

; 1323 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoGetName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_FinishTimeDemo
_TEXT	SEGMENT
_time$ = -12						; size = 8
_frames$ = -4						; size = 4
_CL_FinishTimeDemo PROC					; COMDAT

; 1100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1101 : 	int	frames;
; 1102 : 	double	time;
; 1103 : 	
; 1104 : 	cls.timedemo = false;

	mov	DWORD PTR _cls+300836, 0

; 1105 : 	
; 1106 : 	// the first frame didn't count
; 1107 : 	frames = (host.framecount - cls.td_startframe) - 1;

	mov	eax, DWORD PTR _host+1464
	sub	eax, DWORD PTR _cls+290604
	sub	eax, 1
	mov	DWORD PTR _frames$[ebp], eax

; 1108 : 	time = host.realtime - cls.td_starttime;

	movsd	xmm0, QWORD PTR _host+1440
	subsd	xmm0, QWORD PTR _cls+290608
	movsd	QWORD PTR _time$[ebp], xmm0

; 1109 : 	if( !time ) time = 1.0;

	movsd	xmm0, QWORD PTR _time$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CL_FinishT
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _time$[ebp], xmm0
$LN2@CL_FinishT:

; 1110 : 
; 1111 : 	Con_Printf( "%i frames %5.3f seconds %5.3f fps\n", frames, time, frames / time );

	cvtsi2sd xmm0, DWORD PTR _frames$[ebp]
	divsd	xmm0, QWORD PTR _time$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _time$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _frames$[ebp]
	push	eax
	push	OFFSET ??_C@_0CD@PBKBJCHL@?$CFi?5frames?5?$CF5?43f?5seconds?5?$CF5?43f?5f@
	call	_Con_Printf
	add	esp, 24					; 00000018H

; 1112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_FinishTimeDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoFindInterpolatedViewAngles
_TEXT	SEGMENT
tv135 = -92						; size = 4
tv134 = -88						; size = 4
_at$ = -20						; size = 4
_imod$ = -16						; size = 4
_i1$ = -12						; size = 4
_i0$ = -8						; size = 4
_i$ = -4						; size = 4
_t$ = 8							; size = 4
_frac$ = 12						; size = 4
_prev$ = 16						; size = 4
_next$ = 20						; size = 4
_CL_DemoFindInterpolatedViewAngles PROC			; COMDAT

; 1005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 1006 : 	int	i, i0, i1, imod;
; 1007 : 	float	at;
; 1008 : 
; 1009 : 	if( cls.timedemo ) return;

	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN5@CL_DemoFin
	jmp	$LN1@CL_DemoFin
$LN5@CL_DemoFin:

; 1010 : 
; 1011 : 	imod = demo.angle_position - 1;

	mov	eax, DWORD PTR _demo+516
	sub	eax, 1
	mov	DWORD PTR _imod$[ebp], eax

; 1012 : 	i0 = (imod + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], eax

; 1013 : 	i1 = (imod + 0) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], eax

; 1014 : 
; 1015 : 	if( demo.cmds[i0].starttime >= t )

	mov	eax, DWORD PTR _i0$[ebp]
	shl	eax, 4
	movss	xmm0, DWORD PTR _demo[eax+260]
	comiss	xmm0, DWORD PTR _t$[ebp]
	jb	SHORT $LN3@CL_DemoFin

; 1016 : 	{
; 1017 : 		for( i = 0; i < ANGLE_BACKUP - 2; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_DemoFin
$LN2@CL_DemoFin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_DemoFin:
	cmp	DWORD PTR _i$[ebp], 14			; 0000000eH
	jge	SHORT $LN3@CL_DemoFin

; 1018 : 		{
; 1019 : 			at = demo.cmds[imod & ANGLE_MASK].starttime;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	shl	eax, 4
	movss	xmm0, DWORD PTR _demo[eax+260]
	movss	DWORD PTR _at$[ebp], xmm0

; 1020 : 			if( at == 0.0f ) break;

	movss	xmm0, DWORD PTR _at$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CL_DemoFin
	jmp	SHORT $LN3@CL_DemoFin
$LN7@CL_DemoFin:

; 1021 : 
; 1022 : 			if( at < t )

	movss	xmm0, DWORD PTR _t$[ebp]
	comiss	xmm0, DWORD PTR _at$[ebp]
	jbe	SHORT $LN8@CL_DemoFin

; 1023 : 			{
; 1024 : 				i0 = (imod + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i0$[ebp], eax

; 1025 : 				i1 = (imod + 0) & ANGLE_MASK;

	mov	eax, DWORD PTR _imod$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i1$[ebp], eax

; 1026 : 				break;

	jmp	SHORT $LN3@CL_DemoFin
$LN8@CL_DemoFin:

; 1027 : 			}
; 1028 : 			imod--;

	mov	eax, DWORD PTR _imod$[ebp]
	sub	eax, 1
	mov	DWORD PTR _imod$[ebp], eax

; 1029 : 		}

	jmp	SHORT $LN2@CL_DemoFin
$LN3@CL_DemoFin:

; 1030 : 	}
; 1031 : 
; 1032 : 	*next = &demo.cmds[i0];

	mov	eax, DWORD PTR _i0$[ebp]
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [ecx], eax

; 1033 : 	*prev = &demo.cmds[i1];

	mov	eax, DWORD PTR _i1$[ebp]
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR [ecx], eax

; 1034 : 
; 1035 : 	// avoid division by zero (probably this should never happens)
; 1036 : 	if((*prev)->starttime == (*next)->starttime )

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, DWORD PTR [eax]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CL_DemoFin

; 1037 : 	{
; 1038 : 		*prev = *next;

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1039 : 		*frac = 0.0f;

	mov	eax, DWORD PTR _frac$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax], xmm0

; 1040 : 		return;

	jmp	$LN1@CL_DemoFin
$LN9@CL_DemoFin:

; 1041 : 	}
; 1042 : 
; 1043 : 	// time spans the two entries
; 1044 : 	*frac = ( t - (*prev)->starttime ) / ((*next)->starttime - (*prev)->starttime );

	mov	eax, DWORD PTR _prev$[ebp]
	mov	ecx, DWORD PTR [eax]
	movss	xmm0, DWORD PTR _t$[ebp]
	subss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _next$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, DWORD PTR [edx]
	divss	xmm0, xmm1
	mov	eax, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1045 : 	*frac = bound( 0.0f, *frac, 1.0f );

	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN13@CL_DemoFin
	mov	ecx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN11@CL_DemoFin
	mov	edx, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR tv134[ebp], xmm0
	jmp	SHORT $LN12@CL_DemoFin
$LN11@CL_DemoFin:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv134[ebp], xmm0
$LN12@CL_DemoFin:
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR tv135[ebp], xmm0
	jmp	SHORT $LN14@CL_DemoFin
$LN13@CL_DemoFin:
	xorps	xmm0, xmm0
	movss	DWORD PTR tv135[ebp], xmm0
$LN14@CL_DemoFin:
	mov	eax, DWORD PTR _frac$[ebp]
	movss	xmm0, DWORD PTR tv135[ebp]
	movss	DWORD PTR [eax], xmm0
$LN1@CL_DemoFin:

; 1046 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoFindInterpolatedViewAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoReadMessageQuake
_TEXT	SEGMENT
_a$ = -24						; size = 4
_msglen$ = -20						; size = 4
_viewangles$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_CL_DemoReadMessageQuake PROC				; COMDAT

; 791  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 792  : 	vec3_t		viewangles;
; 793  : 	int		msglen = 0;

	mov	DWORD PTR _msglen$[ebp], 0

; 794  : 	demoangle_t	*a;
; 795  : 
; 796  : 	*length = 0; // assume we fail

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 797  : 	
; 798  : 	// decide if it is time to grab the next message		
; 799  : 	if( cls.signon == SIGNONS )	// allways grab until fully connected

	cmp	DWORD PTR _cls+64, 2
	jne	SHORT $LN7@CL_DemoRea

; 800  : 	{
; 801  : 		if( cls.timedemo )

	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN3@CL_DemoRea

; 802  : 		{
; 803  : 			if( host.framecount == cls.td_lastframe )

	mov	eax, DWORD PTR _host+1464
	cmp	eax, DWORD PTR _cls+290600
	jne	SHORT $LN5@CL_DemoRea

; 804  : 				return false; // already read this frame's message

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN5@CL_DemoRea:

; 805  : 
; 806  : 			cls.td_lastframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR _cls+290600, eax

; 807  : 
; 808  : 			// if this is the second frame, grab the real td_starttime
; 809  : 			// so the bogus time on the first frame doesn't count
; 810  : 			if( host.framecount == cls.td_startframe + 1 )

	mov	eax, DWORD PTR _cls+290604
	add	eax, 1
	cmp	DWORD PTR _host+1464, eax
	jne	SHORT $LN6@CL_DemoRea

; 811  : 				cls.td_starttime = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+290608, xmm0
$LN6@CL_DemoRea:

; 812  : 		}

	jmp	SHORT $LN7@CL_DemoRea
$LN3@CL_DemoRea:

; 813  : 		else if( cl.time <= cl.mtime[0] )

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _cl[ecx+32]
	comisd	xmm0, QWORD PTR _cl+2167640
	jb	SHORT $LN7@CL_DemoRea

; 814  : 		{
; 815  : 			// don't need another message yet
; 816  : 			return false;

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN7@CL_DemoRea:

; 817  : 		}
; 818  : 	}
; 819  : 
; 820  : 	// get the next message
; 821  : 	FS_Read( cls.demofile, &msglen, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _msglen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 822  : 	FS_Read( cls.demofile, &viewangles[0], sizeof( float ));

	push	4
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _viewangles$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 823  : 	FS_Read( cls.demofile, &viewangles[1], sizeof( float ));

	push	4
	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _viewangles$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 824  : 	FS_Read( cls.demofile, &viewangles[2], sizeof( float ));

	push	4
	mov	eax, 4
	shl	eax, 1
	lea	ecx, DWORD PTR _viewangles$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 825  : 	cls.netchan.incoming_sequence++;

	mov	eax, DWORD PTR _cls+26864
	add	eax, 1
	mov	DWORD PTR _cls+26864, eax

; 826  : 	demo.timestamp = cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR _demo+248, xmm0

; 827  : 	cl.skip_interp = false;

	mov	DWORD PTR _cl+76, 0

; 828  : 
; 829  : 	// make sure what interp info contain angles from different frames
; 830  : 	// or lerping will stop working
; 831  : 	if( demo.lasttime != demo.timestamp )

	movss	xmm0, DWORD PTR _demo+252
	ucomiss	xmm0, DWORD PTR _demo+248
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@CL_DemoRea

; 832  : 	{
; 833  : 		// select entry into circular buffer
; 834  : 		demo.angle_position = (demo.angle_position + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _demo+516
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _demo+516, eax

; 835  : 		a = &demo.cmds[demo.angle_position];

	mov	eax, DWORD PTR _demo+516
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	DWORD PTR _a$[ebp], eax

; 836  : 
; 837  : 		// record update
; 838  : 		a->starttime = demo.timestamp;

	mov	eax, DWORD PTR _a$[ebp]
	movss	xmm0, DWORD PTR _demo+248
	movss	DWORD PTR [eax], xmm0

; 839  : 		VectorCopy( viewangles, a->viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _viewangles$[ebp+ecx]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _viewangles$[ebp+edx]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _viewangles$[ebp+eax]
	mov	DWORD PTR [edx+ecx+4], eax

; 840  : 		demo.lasttime = demo.timestamp;

	movss	xmm0, DWORD PTR _demo+248
	movss	DWORD PTR _demo+252, xmm0
$LN8@CL_DemoRea:

; 841  : 	}
; 842  : 
; 843  : 	if( msglen < 0 )

	cmp	DWORD PTR _msglen$[ebp], 0
	jge	SHORT $LN9@CL_DemoRea

; 844  : 	{
; 845  : 		Con_Reportf( S_ERROR "Demo message length < 0\n" );

	push	OFFSET ??_C@_0CE@EHAEKDPM@?$FO1Error?3?$FO7?5Demo?5message?5length?5@
	call	_Con_Reportf
	add	esp, 4

; 846  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 847  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN9@CL_DemoRea:

; 848  : 	}
; 849  : 
; 850  : 	if( msglen > MAX_INIT_MSG )

	cmp	DWORD PTR _msglen$[ebp], 131072		; 00020000H
	jle	SHORT $LN10@CL_DemoRea

; 851  : 	{
; 852  : 		Con_Reportf( S_ERROR "Demo message %i > %i\n", msglen, MAX_INIT_MSG );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _msglen$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@NNICALKP@?$FO1Error?3?$FO7?5Demo?5message?5?$CFi?5?$DO?5?$CFi@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 853  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 854  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DemoRea
$LN10@CL_DemoRea:

; 855  : 	}
; 856  : 
; 857  : 	if( msglen > 0 )

	cmp	DWORD PTR _msglen$[ebp], 0
	jle	SHORT $LN12@CL_DemoRea

; 858  : 	{
; 859  : 		if( FS_Read( cls.demofile, buffer, msglen ) != msglen )

	mov	eax, DWORD PTR _msglen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _msglen$[ebp]
	je	SHORT $LN12@CL_DemoRea

; 860  : 		{
; 861  : 			Con_Reportf( S_ERROR "Error reading demo message data\n" );

	push	OFFSET ??_C@_0CM@IJBEDAC@?$FO1Error?3?$FO7?5Error?5reading?5demo?5m@
	call	_Con_Reportf
	add	esp, 4

; 862  : 			CL_DemoCompleted();

	call	_CL_DemoCompleted

; 863  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DemoRea
$LN12@CL_DemoRea:

; 864  : 		}
; 865  : 	}
; 866  : 
; 867  : 	cls.netchan.last_received = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+26832, xmm0

; 868  : 	cls.netchan.total_received += msglen;

	mov	eax, DWORD PTR _cls+290564
	add	eax, DWORD PTR _msglen$[ebp]
	mov	DWORD PTR _cls+290564, eax

; 869  : 	*length = msglen;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _msglen$[ebp]
	mov	DWORD PTR [eax], ecx

; 870  : 
; 871  : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN13@CL_DemoRea

; 872  : 		Cbuf_Execute();

	call	_Cbuf_Execute
$LN13@CL_DemoRea:

; 873  : 	return true;

	mov	eax, 1
$LN1@CL_DemoRea:

; 874  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoReadMessageQuake ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_ReadRawNetworkData
_TEXT	SEGMENT
tv78 = -72						; size = 4
tv70 = -72						; size = 4
_msglen$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_CL_ReadRawNetworkData PROC				; COMDAT

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 741  : 	int	msglen = 0;	

	mov	DWORD PTR _msglen$[ebp], 0

; 742  : 
; 743  : 	Assert( buffer != NULL );

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN8@CL_ReadRaw
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN9@CL_ReadRaw
$LN8@CL_ReadRaw:
	mov	DWORD PTR tv70[ebp], 0
$LN9@CL_ReadRaw:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ReadRawNetworkData@@9@9
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@FBHHDKCM@buffer?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 744  : 	Assert( length != NULL );

	cmp	DWORD PTR _length$[ebp], 0
	je	SHORT $LN10@CL_ReadRaw
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN11@CL_ReadRaw
$LN10@CL_ReadRaw:
	mov	DWORD PTR tv78[ebp], 0
$LN11@CL_ReadRaw:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_ReadRawNetworkData@@9@9
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0P@EEOEILBN@length?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 745  : 
; 746  : 	*length = 0; // assume we fail

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR [eax], 0

; 747  : 	FS_Read( cls.demofile, &msglen, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _msglen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 748  : 
; 749  : 	if( msglen < 0 )

	cmp	DWORD PTR _msglen$[ebp], 0
	jge	SHORT $LN2@CL_ReadRaw

; 750  : 	{
; 751  : 		Con_Reportf( S_ERROR "Demo message length < 0\n" );

	push	OFFSET ??_C@_0CE@EHAEKDPM@?$FO1Error?3?$FO7?5Demo?5message?5length?5@
	call	_Con_Reportf
	add	esp, 4

; 752  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 753  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_ReadRaw
$LN2@CL_ReadRaw:

; 754  : 	}
; 755  : 
; 756  : 	if( msglen > MAX_INIT_MSG )

	cmp	DWORD PTR _msglen$[ebp], 131072		; 00020000H
	jle	SHORT $LN3@CL_ReadRaw

; 757  : 	{
; 758  : 		Con_Reportf( S_ERROR "Demo message %i > %i\n", msglen, MAX_INIT_MSG );

	push	131072					; 00020000H
	mov	eax, DWORD PTR _msglen$[ebp]
	push	eax
	push	OFFSET ??_C@_0CB@NNICALKP@?$FO1Error?3?$FO7?5Demo?5message?5?$CFi?5?$DO?5?$CFi@
	call	_Con_Reportf
	add	esp, 12					; 0000000cH

; 759  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 760  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_ReadRaw
$LN3@CL_ReadRaw:

; 761  : 	}
; 762  : 
; 763  : 	if( msglen > 0 )

	cmp	DWORD PTR _msglen$[ebp], 0
	jle	SHORT $LN5@CL_ReadRaw

; 764  : 	{
; 765  : 		if( FS_Read( cls.demofile, buffer, msglen ) != msglen )

	mov	eax, DWORD PTR _msglen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _msglen$[ebp]
	je	SHORT $LN5@CL_ReadRaw

; 766  : 		{
; 767  : 			Con_Reportf( S_ERROR "Error reading demo message data\n" );

	push	OFFSET ??_C@_0CM@IJBEDAC@?$FO1Error?3?$FO7?5Error?5reading?5demo?5m@
	call	_Con_Reportf
	add	esp, 4

; 768  : 			CL_DemoCompleted();

	call	_CL_DemoCompleted

; 769  : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_ReadRaw
$LN5@CL_ReadRaw:

; 770  : 		}
; 771  : 	}
; 772  : 
; 773  : 	cls.netchan.last_received = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+26832, xmm0

; 774  : 	cls.netchan.total_received += msglen;

	mov	eax, DWORD PTR _cls+290564
	add	eax, DWORD PTR _msglen$[ebp]
	mov	DWORD PTR _cls+290564, eax

; 775  : 	*length = msglen;

	mov	eax, DWORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _msglen$[ebp]
	mov	DWORD PTR [eax], ecx

; 776  : 
; 777  : 	if( cls.state != ca_active )

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN6@CL_ReadRaw

; 778  : 		Cbuf_Execute();

	call	_Cbuf_Execute
$LN6@CL_ReadRaw:

; 779  : 
; 780  : 	return true;

	mov	eax, 1
$LN1@CL_ReadRaw:

; 781  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadRawNetworkData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoMoveToNextSection
_TEXT	SEGMENT
_CL_DemoMoveToNextSection PROC				; COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 719  : 	if( ++demo.entryIndex >= demo.directory.numentries )

	mov	eax, DWORD PTR _demo+256
	add	eax, 1
	mov	DWORD PTR _demo+256, eax
	mov	ecx, DWORD PTR _demo+256
	cmp	ecx, DWORD PTR _demo+232
	jl	SHORT $LN2@CL_DemoMov

; 720  : 	{
; 721  : 		// done
; 722  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 723  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DemoMov
$LN2@CL_DemoMov:

; 724  : 	}
; 725  : 
; 726  : 	// switch to next section, we got a dem_stop
; 727  : 	demo.entry = &demo.directory.entries[demo.entryIndex];

	imul	eax, DWORD PTR _demo+256, 88
	add	eax, DWORD PTR _demo+228
	mov	DWORD PTR _demo+224, eax

; 728  : 	
; 729  : 	// ready to continue reading, reset clock.
; 730  : 	FS_Seek( cls.demofile, demo.entry->offset, SEEK_SET ); 

	push	0
	mov	eax, DWORD PTR _demo+224
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 731  : 
; 732  : 	// time is now relative to this chunk's clock.
; 733  : 	demo.starttime = CL_GetDemoPlaybackClock();

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR _demo+240

; 734  : 	demo.framecount = 0;

	mov	DWORD PTR _demo+236, 0

; 735  : 
; 736  : 	return true;

	mov	eax, 1
$LN1@CL_DemoMov:

; 737  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoMoveToNextSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoAborted
_TEXT	SEGMENT
_CL_DemoAborted PROC					; COMDAT

; 678  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 679  : 	if( cls.demofile )

	cmp	DWORD PTR _cls+301108, 0
	je	SHORT $LN2@CL_DemoAbo

; 680  : 		FS_Close( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Close
	add	esp, 4
$LN2@CL_DemoAbo:

; 681  : 	cls.demoplayback = false;

	mov	DWORD PTR _cls+300828, 0

; 682  : 	cls.changedemo = false;

	mov	DWORD PTR _cls+12, 0

; 683  : 	cls.timedemo = false;

	mov	DWORD PTR _cls+300836, 0

; 684  : 	demo.framecount = 0;

	mov	DWORD PTR _demo+236, 0

; 685  : 	cls.demofile = NULL;

	mov	DWORD PTR _cls+301108, 0

; 686  : 	cls.demonum = -1;

	mov	DWORD PTR _cls+296712, -1

; 687  : 
; 688  : 	Cvar_SetValue( "v_dark", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06COKHDAAL@v_dark@
	call	_Cvar_SetValue
	add	esp, 8

; 689  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoAborted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoStartPlayback
_TEXT	SEGMENT
tv69 = -68						; size = 4
_mode$ = 8						; size = 4
_CL_DemoStartPlayback PROC				; COMDAT

; 635  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 636  : 	if( cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	je	SHORT $LN2@CL_DemoSta

; 637  : 	{
; 638  : 		S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 639  : 		SCR_BeginLoadingPlaque( false );

	push	0
	call	_SCR_BeginLoadingPlaque
	add	esp, 4

; 640  : 
; 641  : 		CL_ClearState ();

	call	_CL_ClearState

; 642  : 		CL_InitEdicts (); // re-arrange edicts

	call	_CL_InitEdicts

; 643  : 	}

	jmp	SHORT $LN3@CL_DemoSta
$LN2@CL_DemoSta:

; 644  : 	else
; 645  : 	{
; 646  : 		// NOTE: at this point demo is still valid
; 647  : 		CL_Disconnect();

	call	_CL_Disconnect

; 648  : 		Host_ShutdownServer();

	call	_Host_ShutdownServer

; 649  : 
; 650  : 		Con_FastClose();

	call	_Con_FastClose

; 651  : 		UI_SetActiveMenu( false );

	push	0
	call	_UI_SetActiveMenu
	add	esp, 4
$LN3@CL_DemoSta:

; 652  : 	}
; 653  : 
; 654  : 	cls.demoplayback = mode;

	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR _cls+300828, eax

; 655  : 	cls.state = ca_connected;

	mov	DWORD PTR _cls, 2

; 656  : 	cl.background = (cls.demonum != -1) ? true : false;

	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN5@CL_DemoSta
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN6@CL_DemoSta
$LN5@CL_DemoSta:
	mov	DWORD PTR tv69[ebp], 0
$LN6@CL_DemoSta:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _cl+64, eax

; 657  : 	cls.spectator = false;

	mov	DWORD PTR _cls+152, 0

; 658  : 	cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 659  : 
; 660  : 	demo.starttime = CL_GetDemoPlaybackClock(); // for determining whether to read another message

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR _demo+240

; 661  : 
; 662  : 	Netchan_Setup( NS_CLIENT, &cls.netchan, net_from, Cvar_VariableInteger( "net_qport" ), NULL, CL_GetFragmentSize );

	push	OFFSET _CL_GetFragmentSize
	push	0
	push	OFFSET ??_C@_09HOOHLIKH@net_qport@
	call	_Cvar_VariableInteger
	add	esp, 4
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _net_from
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _net_from+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _net_from+8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _net_from+12
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _net_from+16
	mov	DWORD PTR [eax+16], ecx
	push	OFFSET _cls+26800
	push	0
	call	_Netchan_Setup
	add	esp, 40					; 00000028H

; 663  : 
; 664  : 	memset( demo.cmds, 0, sizeof( demo.cmds ));

	push	256					; 00000100H
	push	0
	push	OFFSET _demo+260
	call	_memset
	add	esp, 12					; 0000000cH

; 665  : 	demo.angle_position = 1;

	mov	DWORD PTR _demo+516, 1

; 666  : 	demo.framecount = 0;

	mov	DWORD PTR _demo+236, 0

; 667  : 	cls.lastoutgoingcommand = -1;

	mov	DWORD PTR _cls+290592, -1

; 668  :  	cls.nextcmdtime = host.realtime;

	cvtsd2ss xmm0, QWORD PTR _host+1440
	movss	DWORD PTR _cls+290588, xmm0

; 669  : 	cl.last_command_ack = -1;

	mov	DWORD PTR _cl+52, -1

; 670  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoStartPlayback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_ReadDemoSequence
_TEXT	SEGMENT
_last_reliable_sequence$ = -28				; size = 4
_reliable_sequence$ = -24				; size = 4
_outgoing_sequence$ = -20				; size = 4
_incoming_reliable_sequence$ = -16			; size = 4
_incoming_reliable_acknowledged$ = -12			; size = 4
_incoming_acknowledged$ = -8				; size = 4
_incoming_sequence$ = -4				; size = 4
_discard$ = 8						; size = 4
_CL_ReadDemoSequence PROC				; COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 602  : 	int	incoming_sequence;
; 603  : 	int	incoming_acknowledged;
; 604  : 	int	incoming_reliable_acknowledged;
; 605  : 	int	incoming_reliable_sequence;
; 606  : 	int	outgoing_sequence;
; 607  : 	int	reliable_sequence;
; 608  : 	int	last_reliable_sequence;
; 609  : 
; 610  : 	FS_Read( cls.demofile, &incoming_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _incoming_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 611  : 	FS_Read( cls.demofile, &incoming_acknowledged, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _incoming_acknowledged$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 612  : 	FS_Read( cls.demofile, &incoming_reliable_acknowledged, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _incoming_reliable_acknowledged$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 613  : 	FS_Read( cls.demofile, &incoming_reliable_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _incoming_reliable_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 614  : 	FS_Read( cls.demofile, &outgoing_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _outgoing_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 615  : 	FS_Read( cls.demofile, &reliable_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _reliable_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 616  : 	FS_Read( cls.demofile, &last_reliable_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _last_reliable_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 617  : 
; 618  : 	if( discard ) return;

	cmp	DWORD PTR _discard$[ebp], 0
	je	SHORT $LN2@CL_ReadDem
	jmp	SHORT $LN1@CL_ReadDem
$LN2@CL_ReadDem:

; 619  : 
; 620  : 	cls.netchan.incoming_sequence	= incoming_sequence;

	mov	eax, DWORD PTR _incoming_sequence$[ebp]
	mov	DWORD PTR _cls+26864, eax

; 621  : 	cls.netchan.incoming_acknowledged = incoming_acknowledged;

	mov	eax, DWORD PTR _incoming_acknowledged$[ebp]
	mov	DWORD PTR _cls+26868, eax

; 622  : 	cls.netchan.incoming_reliable_acknowledged = incoming_reliable_acknowledged;

	mov	eax, DWORD PTR _incoming_reliable_acknowledged$[ebp]
	mov	DWORD PTR _cls+26872, eax

; 623  : 	cls.netchan.incoming_reliable_sequence = incoming_reliable_sequence;

	mov	eax, DWORD PTR _incoming_reliable_sequence$[ebp]
	mov	DWORD PTR _cls+26876, eax

; 624  : 	cls.netchan.outgoing_sequence	= outgoing_sequence;

	mov	eax, DWORD PTR _outgoing_sequence$[ebp]
	mov	DWORD PTR _cls+26880, eax

; 625  : 	cls.netchan.reliable_sequence	= reliable_sequence;

	mov	eax, DWORD PTR _reliable_sequence$[ebp]
	mov	DWORD PTR _cls+26884, eax

; 626  : 	cls.netchan.last_reliable_sequence = last_reliable_sequence;

	mov	eax, DWORD PTR _last_reliable_sequence$[ebp]
	mov	DWORD PTR _cls+26888, eax
$LN1@CL_ReadDem:

; 627  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadDemoSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_ReadDemoUserCmd
_TEXT	SEGMENT
_a$1 = -1124						; size = 4
_buf$2 = -1120						; size = 20
_nullcmd$3 = -1100					; size = 56
_bytes$ = -1044						; size = 2
_pcmd$ = -1040						; size = 4
_outgoing_sequence$ = -1036				; size = 4
_cmdnumber$ = -1032					; size = 4
_data$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_discard$ = 8						; size = 4
_CL_ReadDemoUserCmd PROC				; COMDAT

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1316				; 00000524H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 540  : 	byte	data[1024];
; 541  : 	int	cmdnumber;
; 542  : 	int	outgoing_sequence;
; 543  : 	runcmd_t	*pcmd;
; 544  : 	word	bytes;
; 545  : 
; 546  : 	FS_Read( cls.demofile, &outgoing_sequence, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _outgoing_sequence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 547  : 	FS_Read( cls.demofile, &cmdnumber, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _cmdnumber$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 548  : 	FS_Read( cls.demofile, &bytes, sizeof( short ));

	push	2
	lea	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 549  : 	FS_Read( cls.demofile, data, bytes );

	movzx	eax, WORD PTR _bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 550  : 
; 551  : 	if( !discard )

	cmp	DWORD PTR _discard$[ebp], 0
	jne	$LN2@CL_ReadDem

; 552  : 	{
; 553  : 		usercmd_t		nullcmd;
; 554  : 		sizebuf_t		buf;
; 555  : 		demoangle_t	*a;
; 556  : 
; 557  : 		memset( &nullcmd, 0, sizeof( nullcmd ));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _nullcmd$3[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 558  : 		MSG_Init( &buf, "UserCmd", data, sizeof( data ));

	push	-1
	push	1024					; 00000400H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET ??_C@_07EJIPDLMH@UserCmd@
	lea	ecx, DWORD PTR _buf$2[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 559  : 
; 560  : 		pcmd = &cl.commands[cmdnumber & CL_UPDATE_MASK];

	mov	eax, DWORD PTR _CL_UPDATE_BACKUP
	sub	eax, 1
	and	eax, DWORD PTR _cmdnumber$[ebp]
	imul	ecx, eax, 88
	add	ecx, OFFSET _cl+1539672
	mov	DWORD PTR _pcmd$[ebp], ecx

; 561  : 		pcmd->processedfuncs = false;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+76], 0

; 562  : 		pcmd->senttime = 0.0f;

	mov	eax, DWORD PTR _pcmd$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax], xmm0

; 563  : 		pcmd->receivedtime = 0.1f;

	mov	eax, DWORD PTR _pcmd$[ebp]
	movsd	xmm0, QWORD PTR __real@3fb99999a0000000
	movsd	QWORD PTR [eax+8], xmm0

; 564  : 		pcmd->frame_lerp = 0.1f;

	mov	eax, DWORD PTR _pcmd$[ebp]
	movss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR [eax+16], xmm0

; 565  : 		pcmd->heldback = false;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+80], 0

; 566  : 		pcmd->sendsize = 1;

	mov	eax, DWORD PTR _pcmd$[ebp]
	mov	DWORD PTR [eax+84], 1

; 567  : 
; 568  : 		// always delta'ing from null
; 569  : 		cl.cmd = &pcmd->cmd;

	mov	eax, DWORD PTR _pcmd$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _cl+2212776, eax

; 570  : 
; 571  : 		MSG_ReadDeltaUsercmd( &buf, &nullcmd, cl.cmd );

	mov	eax, DWORD PTR _cl+2212776
	push	eax
	lea	ecx, DWORD PTR _nullcmd$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _buf$2[ebp]
	push	edx
	call	_MSG_ReadDeltaUsercmd
	add	esp, 12					; 0000000cH

; 572  : 
; 573  : 		// make sure what interp info contain angles from different frames
; 574  : 		// or lerping will stop working
; 575  : 		if( demo.lasttime != demo.timestamp )

	movss	xmm0, DWORD PTR _demo+252
	ucomiss	xmm0, DWORD PTR _demo+248
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN3@CL_ReadDem

; 576  : 		{
; 577  : 			// select entry into circular buffer
; 578  : 			demo.angle_position = (demo.angle_position + 1) & ANGLE_MASK;

	mov	eax, DWORD PTR _demo+516
	add	eax, 1
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _demo+516, eax

; 579  : 			a = &demo.cmds[demo.angle_position];

	mov	eax, DWORD PTR _demo+516
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	DWORD PTR _a$1[ebp], eax

; 580  : 
; 581  : 			// record update
; 582  : 			a->starttime = demo.timestamp;

	mov	eax, DWORD PTR _a$1[ebp]
	movss	xmm0, DWORD PTR _demo+248
	movss	DWORD PTR [eax], xmm0

; 583  : 			VectorCopy( cl.cmd->viewangles, a->viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _a$1[ebp]
	mov	esi, DWORD PTR _cl+2212776
	mov	ecx, DWORD PTR [esi+ecx+4]
	mov	DWORD PTR [edx+eax+4], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _a$1[ebp]
	mov	esi, DWORD PTR _cl+2212776
	mov	edx, DWORD PTR [esi+edx+4]
	mov	DWORD PTR [ecx+eax+4], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _a$1[ebp]
	mov	esi, DWORD PTR _cl+2212776
	mov	eax, DWORD PTR [esi+eax+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 584  : 			demo.lasttime = demo.timestamp;

	movss	xmm0, DWORD PTR _demo+248
	movss	DWORD PTR _demo+252, xmm0
$LN3@CL_ReadDem:

; 585  : 		}
; 586  : 
; 587  : 		// NOTE: we need to have the current outgoing sequence correct
; 588  : 		// so we can do prediction correctly during playback
; 589  : 		cls.netchan.outgoing_sequence = outgoing_sequence;

	mov	eax, DWORD PTR _outgoing_sequence$[ebp]
	mov	DWORD PTR _cls+26880, eax
$LN2@CL_ReadDem:

; 590  : 	}
; 591  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadDemoUserCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_ReadDemoCmdHeader
_TEXT	SEGMENT
tv76 = -68						; size = 4
_cmd$ = 8						; size = 4
_dt$ = 12						; size = 4
_CL_ReadDemoCmdHeader PROC				; COMDAT

; 521  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 522  : 	// read the command
; 523  : 	FS_Read( cls.demofile, cmd, sizeof( byte ));

	push	1
	mov	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 524  : 	Assert( *cmd >= 1 && *cmd <= dem_lastcmd );

	mov	eax, DWORD PTR _cmd$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jl	SHORT $LN3@CL_ReadDem
	mov	edx, DWORD PTR _cmd$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 6
	jg	SHORT $LN3@CL_ReadDem
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@CL_ReadDem
$LN3@CL_ReadDem:
	mov	DWORD PTR tv76[ebp], 0
$LN4@CL_ReadDem:
	push	0
	mov	ecx, DWORD PTR ?__LINE__Var@?0??CL_ReadDemoCmdHeader@@9@9
	add	ecx, 3
	push	ecx
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0CB@CKNEEIIK@?$CKcmd?5?$DO?$DN?51?5?$CG?$CG?5?$CKcmd?5?$DM?$DN?5dem_lastcm@
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 525  : 
; 526  : 	// read the timestamp
; 527  : 	FS_Read( cls.demofile, dt, sizeof( float ));

	push	4
	mov	eax, DWORD PTR _dt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 528  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_ReadDemoCmdHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoHeader
_TEXT	SEGMENT
tv88 = -92						; size = 8
tv87 = -84						; size = 8
_curpos$ = -12						; size = 4
_savepos$ = -8						; size = 4
_copysize$ = -4						; size = 4
_name$ = 8						; size = 4
_CL_WriteDemoHeader PROC				; COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi

; 352  : 	long	copysize;
; 353  : 	long	savepos;
; 354  : 	long	curpos;
; 355  : 	
; 356  : 	Con_Printf( "recording to %s.\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@PMCLPAOL@recording?5to?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8

; 357  : 	cls.demofile = FS_Open( name, "wb", false );

	push	0
	push	OFFSET ??_C@_02GMLFBBN@wb@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cls+301108, eax

; 358  : 	cls.demotime = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+301096, xmm0

; 359  : 
; 360  : 	if( !cls.demofile )

	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN2@CL_WriteDe

; 361  : 	{
; 362  : 		Con_Printf( S_ERROR "couldn't open %s.\n", name );

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BO@HDFPLPPJ@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?4?6@
	call	_Con_Printf
	add	esp, 8

; 363  : 		return;

	jmp	$LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 364  : 	}
; 365  : 
; 366  : 	cls.demorecording = true;

	mov	DWORD PTR _cls+300824, 1

; 367  : 	cls.demowaiting = true;	// don't start saving messages until a non-delta compressed message is received

	mov	DWORD PTR _cls+300832, 1

; 368  : 
; 369  : 	memset( &demo.header, 0, sizeof( demo.header ));

	push	224					; 000000e0H
	push	0
	push	OFFSET _demo
	call	_memset
	add	esp, 12					; 0000000cH

; 370  : 
; 371  : 	demo.header.id = IDEMOHEADER;

	mov	DWORD PTR _demo, 1296385097		; 4d454449H

; 372  : 	demo.header.dem_protocol = DEMO_PROTOCOL;

	mov	DWORD PTR _demo+4, 3

; 373  : 	demo.header.net_protocol = PROTOCOL_VERSION;

	mov	DWORD PTR _demo+8, 49			; 00000031H

; 374  : 	demo.header.host_fps = bound( MIN_FPS, host_maxfps->value, MAX_FPS );

	mov	eax, DWORD PTR _host_maxfps
	movss	xmm0, DWORD PTR [eax+12]
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR __real@4034000000000000
	jb	SHORT $LN7@CL_WriteDe
	mov	ecx, DWORD PTR _host_maxfps
	movss	xmm0, DWORD PTR [ecx+12]
	cvtss2sd xmm0, xmm0
	movsd	xmm1, QWORD PTR __real@4069000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN5@CL_WriteDe
	mov	edx, DWORD PTR _host_maxfps
	movss	xmm0, DWORD PTR [edx+12]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv87[ebp], xmm0
	jmp	SHORT $LN6@CL_WriteDe
$LN5@CL_WriteDe:
	movsd	xmm0, QWORD PTR __real@4069000000000000
	movsd	QWORD PTR tv87[ebp], xmm0
$LN6@CL_WriteDe:
	movsd	xmm0, QWORD PTR tv87[ebp]
	movsd	QWORD PTR tv88[ebp], xmm0
	jmp	SHORT $LN8@CL_WriteDe
$LN7@CL_WriteDe:
	movsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv88[ebp], xmm0
$LN8@CL_WriteDe:
	movsd	xmm0, QWORD PTR tv88[ebp]
	movsd	QWORD PTR _demo+16, xmm0

; 375  : 	Q_strncpy( demo.header.mapname, clgame.mapname, sizeof( demo.header.mapname ));

	push	64					; 00000040H
	push	OFFSET _clgame+228
	push	OFFSET _demo+24
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 376  : 	Q_strncpy( demo.header.comment, clgame.maptitle, sizeof( demo.header.comment ));

	push	64					; 00000040H
	push	OFFSET _clgame+484
	push	OFFSET _demo+88
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 377  : 	Q_strncpy( demo.header.gamedir, FS_Gamedir(), sizeof( demo.header.gamedir ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _SI+768
	add	eax, 128				; 00000080H
	push	eax
	push	OFFSET _demo+152
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 378  : 
; 379  : 	// write header
; 380  : 	FS_Write( cls.demofile, &demo.header, sizeof( demo.header ));

	push	224					; 000000e0H
	push	OFFSET _demo
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 381  : 
; 382  : 	demo.directory.numentries = 2;

	mov	DWORD PTR _demo+232, 2

; 383  : 	demo.directory.entries = Mem_Calloc( cls.mempool, sizeof( demoentry_t ) * demo.directory.numentries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_WriteDemoHeader@@9@9
	add	eax, 32					; 00000020H
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	1
	imul	ecx, DWORD PTR _demo+232, 88
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _demo+228, eax

; 384  : 
; 385  : 	// DIRECTORY ENTRY # 0
; 386  : 	demo.entry = &demo.directory.entries[0];	// only one here.

	mov	eax, 88					; 00000058H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _demo+228
	mov	DWORD PTR _demo+224, ecx

; 387  : 	demo.entry->entrytype = DEMO_STARTUP;

	mov	eax, DWORD PTR _demo+224
	mov	DWORD PTR [eax], 0

; 388  : 	demo.entry->playback_time = 0.0f;		// startup takes 0 time.

	mov	eax, DWORD PTR _demo+224
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+4], xmm0

; 389  : 	demo.entry->offset = FS_Tell( cls.demofile );	// position for this chunk.

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _demo+224
	mov	DWORD PTR [ecx+12], eax

; 390  : 
; 391  : 	// finish off the startup info.
; 392  : 	CL_WriteDemoCmdHeader( dem_stop, cls.demoheader );

	mov	eax, DWORD PTR _cls+301112
	push	eax
	push	6
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 393  : 
; 394  : 	// now copy the stuff we cached from the server.
; 395  : 	copysize = savepos = FS_Tell( cls.demoheader );

	mov	eax, DWORD PTR _cls+301112
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _savepos$[ebp], eax
	mov	ecx, DWORD PTR _savepos$[ebp]
	mov	DWORD PTR _copysize$[ebp], ecx

; 396  : 
; 397  : 	FS_Seek( cls.demoheader, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _cls+301112
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 398  : 
; 399  : 	FS_FileCopy( cls.demofile, cls.demoheader, copysize );

	mov	eax, DWORD PTR _copysize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301112
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_FileCopy
	add	esp, 12					; 0000000cH

; 400  : 
; 401  : 	// jump back to end, in case we record another demo for this session.
; 402  : 	FS_Seek( cls.demoheader, savepos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _savepos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301112
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 403  : 
; 404  : 	demo.starttime = CL_GetDemoRecordClock();	// setup the demo starttime

	call	_CL_GetDemoRecordClock
	fstp	DWORD PTR _demo+240

; 405  : 	demo.realstarttime = demo.starttime;

	movss	xmm0, DWORD PTR _demo+240
	movss	DWORD PTR _demo+244, xmm0

; 406  : 	demo.framecount = 0;

	mov	DWORD PTR _demo+236, 0

; 407  : 	cls.td_startframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR _cls+290604, eax

; 408  : 	cls.td_lastframe = -1;			// get a new message this frame

	mov	DWORD PTR _cls+290600, -1

; 409  : 
; 410  : 	// now move on to entry # 1, the first data chunk.
; 411  : 	curpos = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _curpos$[ebp], eax

; 412  : 	demo.entry->length = curpos - demo.entry->offset;

	mov	eax, DWORD PTR _demo+224
	mov	ecx, DWORD PTR _curpos$[ebp]
	sub	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _demo+224
	mov	DWORD PTR [edx+16], ecx

; 413  : 
; 414  : 	// now we are writing the first real lump.
; 415  : 	demo.entry = &demo.directory.entries[1]; // first real data lump

	mov	eax, 88					; 00000058H
	shl	eax, 0
	add	eax, DWORD PTR _demo+228
	mov	DWORD PTR _demo+224, eax

; 416  : 	demo.entry->entrytype = DEMO_NORMAL;

	mov	eax, DWORD PTR _demo+224
	mov	DWORD PTR [eax], 1

; 417  : 	demo.entry->playback_time = 0.0f; // startup takes 0 time.

	mov	eax, DWORD PTR _demo+224
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+4], xmm0

; 418  : 
; 419  : 	demo.entry->offset = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	ecx, DWORD PTR _demo+224
	mov	DWORD PTR [ecx+12], eax

; 420  : 
; 421  : 	// demo playback should read this as an incoming message.
; 422  : 	// write the client's realtime value out so we can synchronize the reads.
; 423  : 	CL_WriteDemoCmdHeader( dem_jumptime, cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	push	3
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 424  : 
; 425  : 	if( clgame.hInstance ) clgame.dllFuncs.pfnReset();

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN3@CL_WriteDe
	call	DWORD PTR _clgame+24
$LN3@CL_WriteDe:

; 426  : 
; 427  : 	Cbuf_InsertText( "fullupdate\n" );

	push	OFFSET ??_C@_0M@NCPNBCGD@fullupdate?6@
	call	_Cbuf_InsertText
	add	esp, 4

; 428  : 	Cbuf_Execute();

	call	_Cbuf_Execute
$LN1@CL_WriteDe:

; 429  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoSequence
_TEXT	SEGMENT
tv70 = -68						; size = 4
_file$ = 8						; size = 4
_CL_WriteDemoSequence PROC				; COMDAT

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 271  : 	Assert( file != NULL );

	cmp	DWORD PTR _file$[ebp], 0
	je	SHORT $LN3@CL_WriteDe
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@CL_WriteDe
$LN3@CL_WriteDe:
	mov	DWORD PTR tv70[ebp], 0
$LN4@CL_WriteDe:
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_WriteDemoSequence@@9@9
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0N@MBAPGNHG@file?5?$CB?$DN?5NULL@
	mov	ecx, DWORD PTR tv70[ebp]
	push	ecx
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 272  : 
; 273  : 	FS_Write( file, &cls.netchan.incoming_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26864
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 274  : 	FS_Write( file, &cls.netchan.incoming_acknowledged, sizeof( int ));

	push	4
	push	OFFSET _cls+26868
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 275  : 	FS_Write( file, &cls.netchan.incoming_reliable_acknowledged, sizeof( int ));

	push	4
	push	OFFSET _cls+26872
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 276  : 	FS_Write( file, &cls.netchan.incoming_reliable_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26876
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 277  : 	FS_Write( file, &cls.netchan.outgoing_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26880
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 278  : 	FS_Write( file, &cls.netchan.reliable_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26884
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 279  : 	FS_Write( file, &cls.netchan.last_reliable_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26888
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoCmdHeader
_TEXT	SEGMENT
tv92 = -72						; size = 4
tv73 = -72						; size = 4
_dt$ = -4						; size = 4
_cmd$ = 8						; size = 1
_file$ = 12						; size = 4
_CL_WriteDemoCmdHeader PROC				; COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 198  : 	float	dt;
; 199  : 
; 200  : 	Assert( cmd >= 1 && cmd <= dem_lastcmd );

	movzx	eax, BYTE PTR _cmd$[ebp]
	cmp	eax, 1
	jl	SHORT $LN4@CL_WriteDe
	movzx	ecx, BYTE PTR _cmd$[ebp]
	cmp	ecx, 6
	jg	SHORT $LN4@CL_WriteDe
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN5@CL_WriteDe
$LN4@CL_WriteDe:
	mov	DWORD PTR tv73[ebp], 0
$LN5@CL_WriteDe:
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??CL_WriteDemoCmdHeader@@9@9
	add	edx, 3
	push	edx
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	OFFSET ??_C@_0BP@HPDCKCMF@cmd?5?$DO?$DN?51?5?$CG?$CG?5cmd?5?$DM?$DN?5dem_lastcmd@
	mov	eax, DWORD PTR tv73[ebp]
	push	eax
	call	_DBG_AssertFunction
	add	esp, 20					; 00000014H

; 201  : 	if( !file ) return;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@CL_WriteDe
	jmp	SHORT $LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 202  : 
; 203  : 	// command
; 204  : 	FS_Write( file, &cmd, sizeof( byte ));

	push	1
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 205  : 
; 206  : 	// time offset
; 207  : 	dt = (float)(CL_GetDemoRecordClock() - demo.starttime);

	call	_CL_GetDemoRecordClock
	fstp	DWORD PTR tv92[ebp]
	movss	xmm0, DWORD PTR tv92[ebp]
	subss	xmm0, DWORD PTR _demo+240
	movss	DWORD PTR _dt$[ebp], xmm0

; 208  : 	FS_Write( file, &dt, sizeof( float ));

	push	4
	lea	eax, DWORD PTR _dt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN1@CL_WriteDe:

; 209  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoCmdHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_GetDemoPlaybackClock
_TEXT	SEGMENT
tv68 = -68						; size = 4
_CL_GetDemoPlaybackClock PROC				; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 172  : 	return host.realtime + host.frametime;

	movsd	xmm0, QWORD PTR _host+1440
	addsd	xmm0, QWORD PTR _host+1448
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 173  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDemoPlaybackClock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_GetDemoRecordClock
_TEXT	SEGMENT
tv69 = -68						; size = 4
_CL_GetDemoRecordClock PROC				; COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 160  : 	return cl.mtime[0];

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsd2ss xmm0, QWORD PTR _cl[ecx+32]
	movss	DWORD PTR tv69[ebp], xmm0
	fld	DWORD PTR tv69[ebp]

; 161  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDemoRecordClock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_Stop_f
_TEXT	SEGMENT
_CL_Stop_f PROC						; COMDAT

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1620 : 	// stop all
; 1621 : 	CL_StopRecord();

	call	_CL_StopRecord

; 1622 : 	CL_StopPlayback();

	call	_CL_StopPlayback

; 1623 : 	SCR_StopCinematic();

	call	_SCR_StopCinematic

; 1624 : 
; 1625 : 	// stop background track that was runned from the console
; 1626 : 	if( !SV_Active( ))

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN1@CL_Stop_f

; 1627 : 	{
; 1628 : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack
$LN1@CL_Stop_f:

; 1629 : 	}
; 1630 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Stop_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_Record_f
_TEXT	SEGMENT
_n$ = -524						; size = 4
_name$ = -520						; size = 4
_demopath$ = -516					; size = 256
_demoname$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_CL_Record_f PROC					; COMDAT

; 1334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 652				; 0000028cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1335 : 	string		demoname, demopath;
; 1336 : 	const char	*name;
; 1337 : 	int		n;
; 1338 : 
; 1339 : 	if( Cmd_Argc() == 1 )

	call	_Cmd_Argc
	cmp	eax, 1
	jne	SHORT $LN5@CL_Record_

; 1340 : 	{
; 1341 : 		name = "new";

	mov	DWORD PTR _name$[ebp], OFFSET ??_C@_03CLCAEGCJ@new@

; 1342 : 	}

	jmp	SHORT $LN6@CL_Record_
$LN5@CL_Record_:

; 1343 : 	else if( Cmd_Argc() == 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jne	SHORT $LN7@CL_Record_

; 1344 : 	{
; 1345 : 		name = Cmd_Argv( 1 );

	push	1
	call	_Cmd_Argv
	add	esp, 4
	mov	DWORD PTR _name$[ebp], eax

; 1346 : 	}

	jmp	SHORT $LN6@CL_Record_
$LN7@CL_Record_:

; 1347 : 	else
; 1348 : 	{
; 1349 : 		Con_Printf( S_USAGE "record <demoname>\n" );

	push	OFFSET ??_C@_0BK@GAMAPOBB@Usage?3?5record?5?$DMdemoname?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1350 : 		return;

	jmp	$LN1@CL_Record_
$LN6@CL_Record_:

; 1351 : 	}
; 1352 : 
; 1353 : 	if( cls.demorecording )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN9@CL_Record_

; 1354 : 	{
; 1355 : 		Con_Printf( "Already recording.\n");

	push	OFFSET ??_C@_0BE@GOGLPLDO@Already?5recording?4?6@
	call	_Con_Printf
	add	esp, 4

; 1356 : 		return;

	jmp	$LN1@CL_Record_
$LN9@CL_Record_:

; 1357 : 	}
; 1358 : 
; 1359 : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN10@CL_Record_

; 1360 : 	{
; 1361 : 		Con_Printf( "Can't record during demo playback.\n");

	push	OFFSET ??_C@_0CE@JONEFKEO@Can?8t?5record?5during?5demo?5playba@
	call	_Con_Printf
	add	esp, 4

; 1362 : 		return;

	jmp	$LN1@CL_Record_
$LN10@CL_Record_:

; 1363 : 	}
; 1364 : 
; 1365 : 	if( !cls.demoheader || cls.state != ca_active )

	cmp	DWORD PTR _cls+301112, 0
	je	SHORT $LN12@CL_Record_
	cmp	DWORD PTR _cls, 4
	je	SHORT $LN11@CL_Record_
$LN12@CL_Record_:

; 1366 : 	{
; 1367 : 		Con_Printf( "You must be in a level to record.\n");

	push	OFFSET ??_C@_0CD@JLOAFGIP@You?5must?5be?5in?5a?5level?5to?5recor@
	call	_Con_Printf
	add	esp, 4

; 1368 : 		return;

	jmp	$LN1@CL_Record_
$LN11@CL_Record_:

; 1369 : 	}
; 1370 : 
; 1371 : 	if( !Q_stricmp( name, "new" ))

	push	99999					; 0001869fH
	push	OFFSET ??_C@_03CLCAEGCJ@new@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN13@CL_Record_

; 1372 : 	{
; 1373 : 		// scan for a free filename
; 1374 : 		for( n = 0; n < 10000; n++ )

	mov	DWORD PTR _n$[ebp], 0
	jmp	SHORT $LN4@CL_Record_
$LN2@CL_Record_:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN4@CL_Record_:
	cmp	DWORD PTR _n$[ebp], 10000		; 00002710H
	jge	SHORT $LN3@CL_Record_

; 1375 : 		{
; 1376 : 			CL_DemoGetName( n, demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_CL_DemoGetName
	add	esp, 8

; 1377 : 			if( !FS_FileExists( va( "%s.dem", demoname ), true ))

	push	1
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET ??_C@_06CGFKKEMF@?$CFs?4dem@
	call	_va
	add	esp, 8
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@CL_Record_

; 1378 : 				break;

	jmp	SHORT $LN3@CL_Record_
$LN15@CL_Record_:

; 1379 : 		}

	jmp	SHORT $LN2@CL_Record_
$LN3@CL_Record_:

; 1380 : 
; 1381 : 		if( n == 10000 )

	cmp	DWORD PTR _n$[ebp], 10000		; 00002710H
	jne	SHORT $LN16@CL_Record_

; 1382 : 		{
; 1383 : 			Con_Printf( S_ERROR "no free slots for demo recording\n" );

	push	OFFSET ??_C@_0CN@IFAPNGAK@?$FO1Error?3?$FO7?5no?5free?5slots?5for?5de@
	call	_Con_Printf
	add	esp, 4

; 1384 : 			return;

	jmp	$LN1@CL_Record_
$LN16@CL_Record_:

; 1385 : 		}
; 1386 : 	}

	jmp	SHORT $LN14@CL_Record_
$LN13@CL_Record_:

; 1387 : 	else Q_strncpy( demoname, name, sizeof( demoname ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _demoname$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN14@CL_Record_:

; 1388 : 
; 1389 : 	// open the demo file
; 1390 : 	Q_sprintf( demopath, "%s.dem", demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET ??_C@_06CGFKKEMF@?$CFs?4dem@
	lea	ecx, DWORD PTR _demopath$[ebp]
	push	ecx
	call	_Q_sprintf
	add	esp, 12					; 0000000cH

; 1391 : 
; 1392 : 	// make sure what old demo is removed
; 1393 : 	if( FS_FileExists( demopath, false ))

	push	0
	lea	eax, DWORD PTR _demopath$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@CL_Record_

; 1394 : 		FS_Delete( demopath );

	lea	eax, DWORD PTR _demopath$[ebp]
	push	eax
	call	_FS_Delete
	add	esp, 4
$LN17@CL_Record_:

; 1395 : 
; 1396 : 	Q_strncpy( cls.demoname, demoname, sizeof( cls.demoname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET _cls+300840
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1397 : 	Q_strncpy( gameui.globals->demoname, demoname, sizeof( gameui.globals->demoname ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gameui+7048
	add	ecx, 32					; 00000020H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1398 : 	
; 1399 : 	CL_WriteDemoHeader( demopath );

	lea	eax, DWORD PTR _demopath$[ebp]
	push	eax
	call	_CL_WriteDemoHeader
	add	esp, 4
$LN1@CL_Record_:

; 1400 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Record_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_Demos_f
_TEXT	SEGMENT
_CL_Demos_f PROC					; COMDAT

; 1592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1593 : 	if( cls.key_dest != key_menu )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN2@CL_Demos_f

; 1594 : 	{
; 1595 : 		Con_Printf( "'demos' is not valid from the console\n" );

	push	OFFSET ??_C@_0CH@LMAJFMII@?8demos?8?5is?5not?5valid?5from?5the?5c@
	call	_Con_Printf
	add	esp, 4

; 1596 : 		return;

	jmp	SHORT $LN1@CL_Demos_f
$LN2@CL_Demos_f:

; 1597 : 	}
; 1598 : 
; 1599 : 	// demos loop are not running
; 1600 : 	if( cls.olddemonum == -1 )

	cmp	DWORD PTR _cls+296716, -1
	jne	SHORT $LN3@CL_Demos_f

; 1601 : 		return;

	jmp	SHORT $LN1@CL_Demos_f
$LN3@CL_Demos_f:

; 1602 : 
; 1603 : 	cls.demonum = cls.olddemonum;

	mov	eax, DWORD PTR _cls+296716
	mov	DWORD PTR _cls+296712, eax

; 1604 : 
; 1605 : 	// run demos loop in background mode
; 1606 : 	if( !SV_Active() && !cls.demoplayback )

	call	_SV_Active
	test	eax, eax
	jne	SHORT $LN1@CL_Demos_f
	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN1@CL_Demos_f

; 1607 : 		CL_NextDemo ();

	call	_CL_NextDemo
$LN1@CL_Demos_f:

; 1608 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_Demos_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_StartDemos_f
_TEXT	SEGMENT
tv72 = -76						; size = 4
_c$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_StartDemos_f PROC					; COMDAT

; 1561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1562 : 	int	i, c;
; 1563 : 
; 1564 : 	if( cls.key_dest != key_menu )

	cmp	DWORD PTR _cls+36, 2
	je	SHORT $LN5@CL_StartDe

; 1565 : 	{
; 1566 : 		Con_Printf( "'startdemos' is not valid from the console\n" );

	push	OFFSET ??_C@_0CM@HAFACEJC@?8startdemos?8?5is?5not?5valid?5from?5@
	call	_Con_Printf
	add	esp, 4

; 1567 : 		return;

	jmp	$LN1@CL_StartDe
$LN5@CL_StartDe:

; 1568 : 	}
; 1569 : 
; 1570 : 	c = Cmd_Argc() - 1;

	call	_Cmd_Argc
	sub	eax, 1
	mov	DWORD PTR _c$[ebp], eax

; 1571 : 	if( c > MAX_DEMOS )

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	jle	SHORT $LN6@CL_StartDe

; 1572 : 	{
; 1573 : 		Con_DPrintf( S_WARN "Host_StartDemos: max %i demos in demoloop\n", MAX_DEMOS );

	push	32					; 00000020H
	push	OFFSET ??_C@_0DI@IHKDLIPA@?$FO3Warning?3?$FO7?5Host_StartDemos?3?5m@
	call	_Con_DPrintf
	add	esp, 8

; 1574 : 		c = MAX_DEMOS;

	mov	DWORD PTR _c$[ebp], 32			; 00000020H
$LN6@CL_StartDe:

; 1575 : 	}
; 1576 : 
; 1577 : 	Con_Printf( "%i demo%s in loop\n", c, (c > 1) ? "s" : "" );

	cmp	DWORD PTR _c$[ebp], 1
	jle	SHORT $LN8@CL_StartDe
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_01LKDEMHDF@s@
	jmp	SHORT $LN9@CL_StartDe
$LN8@CL_StartDe:
	mov	DWORD PTR tv72[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN9@CL_StartDe:
	mov	eax, DWORD PTR tv72[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@HJODIKBK@?$CFi?5demo?$CFs?5in?5loop?6@
	call	_Con_Printf
	add	esp, 12					; 0000000cH

; 1578 : 
; 1579 : 	for( i = 1; i < c + 1; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN4@CL_StartDe
$LN2@CL_StartDe:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_StartDe:
	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN3@CL_StartDe

; 1580 : 		Q_strncpy( cls.demos[i-1], Cmd_Argv( i ), sizeof( cls.demos[0] ));

	push	64					; 00000040H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	shl	ecx, 6
	add	ecx, OFFSET _cls+296720
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@CL_StartDe
$LN3@CL_StartDe:

; 1581 : 	cls.demos_pending = true;

	mov	DWORD PTR _cls+298768, 1
$LN1@CL_StartDe:

; 1582 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StartDemos_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_TimeDemo_f
_TEXT	SEGMENT
_CL_TimeDemo_f PROC					; COMDAT

; 1538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1539 : 	if( Cmd_Argc() != 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	je	SHORT $LN2@CL_TimeDem

; 1540 : 	{
; 1541 : 		Con_Printf( S_USAGE "timedemo <demoname>\n" );

	push	OFFSET ??_C@_0BM@CHKGBOOC@Usage?3?5timedemo?5?$DMdemoname?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1542 : 		return;

	jmp	SHORT $LN1@CL_TimeDem
$LN2@CL_TimeDem:

; 1543 : 	}
; 1544 : 
; 1545 : 	CL_PlayDemo_f ();

	call	_CL_PlayDemo_f

; 1546 : 
; 1547 : 	// cls.td_starttime will be grabbed at the second frame of the demo, so
; 1548 : 	// all the loading time doesn't get counted
; 1549 : 	cls.timedemo = true;

	mov	DWORD PTR _cls+300836, 1

; 1550 : 	cls.td_starttime = host.realtime;

	movsd	xmm0, QWORD PTR _host+1440
	movsd	QWORD PTR _cls+290608, xmm0

; 1551 : 	cls.td_startframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR _cls+290604, eax

; 1552 : 	cls.td_lastframe = -1;		// get a new message this frame

	mov	DWORD PTR _cls+290600, -1
$LN1@CL_TimeDem:

; 1553 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_TimeDemo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_PlayDemo_f
_TEXT	SEGMENT
_neg$1 = -148						; size = 4
_c$2 = -144						; size = 4
_ident$ = -140						; size = 4
_i$ = -136						; size = 4
_demoname$ = -132					; size = 64
_filename$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_CL_PlayDemo_f PROC					; COMDAT

; 1410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1411 : 	char	filename[MAX_QPATH];
; 1412 : 	char	demoname[MAX_QPATH];
; 1413 : 	int	i, ident;
; 1414 : 
; 1415 : 	if( Cmd_Argc() < 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jae	SHORT $LN7@CL_PlayDem

; 1416 : 	{
; 1417 : 		Con_Printf( S_USAGE "playdemo <demoname>\n" );

	push	OFFSET ??_C@_0BM@MMEGPPDD@Usage?3?5playdemo?5?$DMdemoname?$DO?6@
	call	_Con_Printf
	add	esp, 4

; 1418 : 		return;

	jmp	$LN1@CL_PlayDem
$LN7@CL_PlayDem:

; 1419 : 	}
; 1420 : 
; 1421 : 	if( cls.demoplayback )

	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN8@CL_PlayDem

; 1422 : 	{
; 1423 : 		CL_StopPlayback();

	call	_CL_StopPlayback
$LN8@CL_PlayDem:

; 1424 : 	}
; 1425 : 
; 1426 : 	if( cls.demorecording )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN9@CL_PlayDem

; 1427 : 	{
; 1428 : 		Con_Printf( "Can't playback during demo record.\n");

	push	OFFSET ??_C@_0CE@BCMNCJOD@Can?8t?5playback?5during?5demo?5reco@
	call	_Con_Printf
	add	esp, 4

; 1429 : 		return;

	jmp	$LN1@CL_PlayDem
$LN9@CL_PlayDem:

; 1430 : 	}
; 1431 : 
; 1432 : 	Q_strncpy( demoname, Cmd_Argv( 1 ), sizeof( demoname ));

	push	64					; 00000040H
	push	1
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1433 : 	COM_StripExtension( demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	call	_COM_StripExtension
	add	esp, 4

; 1434 : 	Q_snprintf( filename, sizeof( filename ), "%s.dem", demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET ??_C@_06CGFKKEMF@?$CFs?4dem@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1435 : 
; 1436 : 	// hidden parameter
; 1437 : 	if( Cmd_Argc() > 2 )

	call	_Cmd_Argc
	cmp	eax, 2
	jbe	SHORT $LN10@CL_PlayDem

; 1438 : 		cls.set_lastdemo = Q_atoi( Cmd_Argv( 2 ));

	push	2
	call	_Cmd_Argv
	add	esp, 4
	push	eax
	call	_Q_atoi
	add	esp, 4
	mov	DWORD PTR _cls+301104, eax
$LN10@CL_PlayDem:

; 1439 : 
; 1440 : 	// member last demo
; 1441 : 	if( cls.set_lastdemo )

	cmp	DWORD PTR _cls+301104, 0
	je	SHORT $LN11@CL_PlayDem

; 1442 : 		Cvar_Set( "lastdemo", demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET ??_C@_08DAPDEFAC@lastdemo@
	call	_Cvar_Set
	add	esp, 8
$LN11@CL_PlayDem:

; 1443 : 
; 1444 : 	if( !FS_FileExists( filename, true ))

	push	1
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_FileExists
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@CL_PlayDem

; 1445 : 	{
; 1446 : 		Con_Printf( S_ERROR "couldn't open %s\n", filename );

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@JCJEHCDP@?$FO1Error?3?$FO7?5couldn?8t?5open?5?$CFs?6@
	call	_Con_Printf
	add	esp, 8

; 1447 : 		CL_DemoAborted();

	call	_CL_DemoAborted

; 1448 : 		return;

	jmp	$LN1@CL_PlayDem
$LN12@CL_PlayDem:

; 1449 : 	}
; 1450 : 
; 1451 : 	cls.demofile = FS_Open( filename, "rb", true );

	push	1
	push	OFFSET ??_C@_02JDPG@rb@
	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cls+301108, eax

; 1452 : 	Q_strncpy( cls.demoname, demoname, sizeof( cls.demoname ));

	push	256					; 00000100H
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET _cls+300840
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1453 : 	Q_strncpy( gameui.globals->demoname, demoname, sizeof( gameui.globals->demoname ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _gameui+7048
	add	ecx, 32					; 00000020H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1454 : 
; 1455 : 	FS_Read( cls.demofile, &ident, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _ident$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1456 : 	FS_Seek( cls.demofile, 0, SEEK_SET ); // rewind back to start

	push	0
	push	0
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1457 : 	cls.forcetrack = 0;

	mov	DWORD PTR _cls+290616, 0

; 1458 : 
; 1459 : 	// check for quake demos
; 1460 : 	if( ident != IDEMOHEADER )

	cmp	DWORD PTR _ident$[ebp], 1296385097	; 4d454449H
	je	$LN13@CL_PlayDem

; 1461 : 	{
; 1462 : 		int	c, neg = false;

	mov	DWORD PTR _neg$1[ebp], 0

; 1463 : 
; 1464 : 		demo.header.host_fps = host_maxfps->value;

	mov	eax, DWORD PTR _host_maxfps
	cvtss2sd xmm0, DWORD PTR [eax+12]
	movsd	QWORD PTR _demo+16, xmm0
$LN2@CL_PlayDem:

; 1465 : 
; 1466 : 		while(( c = FS_Getc( cls.demofile )) != '\n' )

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Getc
	add	esp, 4
	mov	DWORD PTR _c$2[ebp], eax
	cmp	DWORD PTR _c$2[ebp], 10			; 0000000aH
	je	SHORT $LN3@CL_PlayDem

; 1467 : 		{
; 1468 : 			if( c == '-' ) neg = true;

	cmp	DWORD PTR _c$2[ebp], 45			; 0000002dH
	jne	SHORT $LN14@CL_PlayDem
	mov	DWORD PTR _neg$1[ebp], 1
	jmp	SHORT $LN15@CL_PlayDem
$LN14@CL_PlayDem:

; 1469 : 			else cls.forcetrack = cls.forcetrack * 10 + (c - '0');

	imul	eax, DWORD PTR _cls+290616, 10
	mov	ecx, DWORD PTR _c$2[ebp]
	lea	edx, DWORD PTR [eax+ecx-48]
	mov	DWORD PTR _cls+290616, edx
$LN15@CL_PlayDem:

; 1470 : 		}

	jmp	SHORT $LN2@CL_PlayDem
$LN3@CL_PlayDem:

; 1471 : 
; 1472 : 		if( neg ) cls.forcetrack = -cls.forcetrack;

	cmp	DWORD PTR _neg$1[ebp], 0
	je	SHORT $LN16@CL_PlayDem
	mov	eax, DWORD PTR _cls+290616
	neg	eax
	mov	DWORD PTR _cls+290616, eax
$LN16@CL_PlayDem:

; 1473 : 		CL_DemoStartPlayback( DEMO_QUAKE1 );

	push	2
	call	_CL_DemoStartPlayback
	add	esp, 4

; 1474 : 		return; // quake demo is started

	jmp	$LN1@CL_PlayDem
$LN13@CL_PlayDem:

; 1475 : 	}
; 1476 : 
; 1477 : 	// read in the demo header
; 1478 : 	FS_Read( cls.demofile, &demo.header, sizeof( demoheader_t ));

	push	224					; 000000e0H
	push	OFFSET _demo
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1479 : 
; 1480 : 	if( demo.header.id != IDEMOHEADER )

	cmp	DWORD PTR _demo, 1296385097		; 4d454449H
	je	SHORT $LN17@CL_PlayDem

; 1481 : 	{
; 1482 : 		Con_Printf( S_ERROR "%s is not a demo file\n", demoname );

	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@HOPJFPNL@?$FO1Error?3?$FO7?5?$CFs?5is?5not?5a?5demo?5fil@
	call	_Con_Printf
	add	esp, 8

; 1483 : 		CL_DemoAborted();

	call	_CL_DemoAborted

; 1484 : 		return;

	jmp	$LN1@CL_PlayDem
$LN17@CL_PlayDem:

; 1485 : 	}
; 1486 : 
; 1487 : 	if( demo.header.net_protocol != PROTOCOL_VERSION || demo.header.dem_protocol != DEMO_PROTOCOL )

	cmp	DWORD PTR _demo+8, 49			; 00000031H
	jne	SHORT $LN19@CL_PlayDem
	cmp	DWORD PTR _demo+4, 3
	je	SHORT $LN18@CL_PlayDem
$LN19@CL_PlayDem:

; 1488 : 	{
; 1489 : 		if( demo.header.dem_protocol != DEMO_PROTOCOL )

	cmp	DWORD PTR _demo+4, 3
	je	SHORT $LN20@CL_PlayDem

; 1490 : 			Con_Printf( S_ERROR "playdemo: demo protocol outdated (%i should be %i)\n", demo.header.dem_protocol, DEMO_PROTOCOL );

	push	3
	mov	eax, DWORD PTR _demo+4
	push	eax
	push	OFFSET ??_C@_0DP@IGNNJFBI@?$FO1Error?3?$FO7?5playdemo?3?5demo?5proto@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN20@CL_PlayDem:

; 1491 : 
; 1492 : 		if( demo.header.net_protocol != PROTOCOL_VERSION )

	cmp	DWORD PTR _demo+8, 49			; 00000031H
	je	SHORT $LN21@CL_PlayDem

; 1493 : 			Con_Printf( S_ERROR "playdemo: net protocol outdated (%i should be %i)\n", demo.header.net_protocol, PROTOCOL_VERSION );

	push	49					; 00000031H
	mov	eax, DWORD PTR _demo+8
	push	eax
	push	OFFSET ??_C@_0DO@MFOJFLLP@?$FO1Error?3?$FO7?5playdemo?3?5net?5protoc@
	call	_Con_Printf
	add	esp, 12					; 0000000cH
$LN21@CL_PlayDem:

; 1494 : 		CL_DemoAborted();

	call	_CL_DemoAborted

; 1495 : 		return;

	jmp	$LN1@CL_PlayDem
$LN18@CL_PlayDem:

; 1496 : 	}
; 1497 : 
; 1498 : 	// now read in the directory structure.
; 1499 : 	FS_Seek( cls.demofile, demo.header.directory_offset, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _demo+216
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1500 : 	FS_Read( cls.demofile, &demo.directory.numentries, sizeof( int ));

	push	4
	push	OFFSET _demo+232
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1501 : 
; 1502 : 	if( demo.directory.numentries < 1 || demo.directory.numentries > 1024 )

	cmp	DWORD PTR _demo+232, 1
	jl	SHORT $LN23@CL_PlayDem
	cmp	DWORD PTR _demo+232, 1024		; 00000400H
	jle	SHORT $LN22@CL_PlayDem
$LN23@CL_PlayDem:

; 1503 : 	{
; 1504 : 		Con_Printf( S_ERROR "demo had bogus # of directory entries: %i\n", demo.directory.numentries );

	mov	eax, DWORD PTR _demo+232
	push	eax
	push	OFFSET ??_C@_0DG@HAPBGNEA@?$FO1Error?3?$FO7?5demo?5had?5bogus?5?$CD?5of?5@
	call	_Con_Printf
	add	esp, 8

; 1505 : 		CL_DemoAborted();

	call	_CL_DemoAborted

; 1506 : 		return;

	jmp	$LN1@CL_PlayDem
$LN22@CL_PlayDem:

; 1507 : 	}
; 1508 : 
; 1509 : 	// allocate demo entries
; 1510 : 	demo.directory.entries = Mem_Malloc( cls.mempool, sizeof( demoentry_t ) * demo.directory.numentries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_PlayDemo_f@@9@9
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	imul	ecx, DWORD PTR _demo+232, 88
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _demo+228, eax

; 1511 : 
; 1512 : 	for( i = 0; i < demo.directory.numentries; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@CL_PlayDem
$LN4@CL_PlayDem:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@CL_PlayDem:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _demo+232
	jge	SHORT $LN5@CL_PlayDem

; 1513 : 	{
; 1514 : 		FS_Read( cls.demofile, &demo.directory.entries[i], sizeof( demoentry_t ));

	push	88					; 00000058H
	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, DWORD PTR _demo+228
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1515 : 	}

	jmp	SHORT $LN4@CL_PlayDem
$LN5@CL_PlayDem:

; 1516 : 
; 1517 : 	demo.entryIndex = 0;

	mov	DWORD PTR _demo+256, 0

; 1518 : 	demo.entry = &demo.directory.entries[demo.entryIndex];

	imul	eax, DWORD PTR _demo+256, 88
	add	eax, DWORD PTR _demo+228
	mov	DWORD PTR _demo+224, eax

; 1519 : 
; 1520 : 	FS_Seek( cls.demofile, demo.entry->offset, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _demo+224
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1521 : 
; 1522 : 	CL_DemoStartPlayback( DEMO_XASH3D );

	push	1
	call	_CL_DemoStartPlayback
	add	esp, 4

; 1523 : 
; 1524 : 	// g-cont. is this need?
; 1525 : 	Q_strncpy( cls.servername, demoname, sizeof( cls.servername ));

	push	64					; 00000040H
	lea	eax, DWORD PTR _demoname$[ebp]
	push	eax
	push	OFFSET _cls+72
	call	_Q_strncpy
	add	esp, 12					; 0000000cH
$LN1@CL_PlayDem:

; 1526 : 
; 1527 : 	// begin a playback demo
; 1528 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_PlayDemo_f ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_StopRecord
_TEXT	SEGMENT
_frames$ = -16						; size = 4
_stoptime$ = -12					; size = 4
_curpos$ = -8						; size = 4
_i$ = -4						; size = 4
_CL_StopRecord PROC					; COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 440  : 	int	i, curpos;
; 441  : 	float	stoptime;
; 442  : 	int	frames;
; 443  : 
; 444  : 	if( !cls.demorecording ) return;

	cmp	DWORD PTR _cls+300824, 0
	jne	SHORT $LN5@CL_StopRec
	jmp	$LN1@CL_StopRec
$LN5@CL_StopRec:

; 445  : 
; 446  : 	// demo playback should read this as an incoming message.
; 447  : 	CL_WriteDemoCmdHeader( dem_stop, cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	push	6
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 448  : 
; 449  : 	stoptime = CL_GetDemoRecordClock();

	call	_CL_GetDemoRecordClock
	fstp	DWORD PTR _stoptime$[ebp]

; 450  : 	if( clgame.hInstance ) clgame.dllFuncs.pfnReset();

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN6@CL_StopRec
	call	DWORD PTR _clgame+24
$LN6@CL_StopRec:

; 451  : 
; 452  : 	curpos = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _curpos$[ebp], eax

; 453  : 	demo.entry->length = curpos - demo.entry->offset;

	mov	eax, DWORD PTR _demo+224
	mov	ecx, DWORD PTR _curpos$[ebp]
	sub	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _demo+224
	mov	DWORD PTR [edx+16], ecx

; 454  : 	demo.entry->playback_time = stoptime - demo.realstarttime;

	movss	xmm0, DWORD PTR _stoptime$[ebp]
	subss	xmm0, DWORD PTR _demo+244
	mov	eax, DWORD PTR _demo+224
	movss	DWORD PTR [eax+4], xmm0

; 455  : 	demo.entry->playback_frames = demo.framecount;

	mov	eax, DWORD PTR _demo+224
	mov	ecx, DWORD PTR _demo+236
	mov	DWORD PTR [eax+8], ecx

; 456  : 
; 457  : 	//  Now write out the directory and free it and touch up the demo header.
; 458  : 	FS_Write( cls.demofile, &demo.directory.numentries, sizeof( int ));

	push	4
	push	OFFSET _demo+232
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 459  : 
; 460  : 	for( i = 0; i < demo.directory.numentries; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_StopRec
$LN2@CL_StopRec:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_StopRec:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _demo+232
	jge	SHORT $LN3@CL_StopRec

; 461  : 		FS_Write( cls.demofile, &demo.directory.entries[i], sizeof( demoentry_t ));

	push	88					; 00000058H
	imul	eax, DWORD PTR _i$[ebp], 88
	add	eax, DWORD PTR _demo+228
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@CL_StopRec
$LN3@CL_StopRec:

; 462  : 
; 463  : 	Mem_Free( demo.directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_StopRecord@@9@9
	add	eax, 24					; 00000018H
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _demo+228
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 464  : 	demo.directory.numentries = 0;

	mov	DWORD PTR _demo+232, 0

; 465  : 
; 466  : 	demo.header.directory_offset = curpos;

	mov	eax, DWORD PTR _curpos$[ebp]
	mov	DWORD PTR _demo+216, eax

; 467  : 	FS_Seek( cls.demofile, 0, SEEK_SET );

	push	0
	push	0
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 468  : 	FS_Write( cls.demofile, &demo.header, sizeof( demo.header ));

	push	224					; 000000e0H
	push	OFFSET _demo
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 469  : 	
; 470  : 	FS_Close( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Close
	add	esp, 4

; 471  : 	cls.demofile = NULL;

	mov	DWORD PTR _cls+301108, 0

; 472  : 	cls.demorecording = false;

	mov	DWORD PTR _cls+300824, 0

; 473  : 	cls.demoname[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _cls[ecx+300840], 0

; 474  : 	cls.td_lastframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR _cls+290600, eax

; 475  : 	gameui.globals->demoname[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gameui+7048
	mov	BYTE PTR [edx+ecx+32], 0

; 476  : 	demo.header.host_fps = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _demo+16, xmm0

; 477  : 
; 478  : 	frames = cls.td_lastframe - cls.td_startframe;

	mov	eax, DWORD PTR _cls+290600
	sub	eax, DWORD PTR _cls+290604
	mov	DWORD PTR _frames$[ebp], eax

; 479  : 	Con_Printf( "Completed demo\nRecording time: %02d:%02d, frames %i\n", (int)(cls.demotime / 60.0f), (int)fmod(cls.demotime, 60.0f), frames );

	mov	eax, DWORD PTR _frames$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cls+301096
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	push	eax
	movsd	xmm0, QWORD PTR _cls+301096
	divsd	xmm0, QWORD PTR __real@404e000000000000
	cvttsd2si ecx, xmm0
	push	ecx
	push	OFFSET ??_C@_0DF@ICOLEAFE@Completed?5demo?6Recording?5time?3?5@
	call	_Con_Printf
	add	esp, 16					; 00000010H

; 480  : 	cls.demotime = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+301096, xmm0
$LN1@CL_StopRec:

; 481  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StopRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoCompleted
_TEXT	SEGMENT
_CL_DemoCompleted PROC					; COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 698  : 	if( cls.demonum != -1 )

	cmp	DWORD PTR _cls+296712, -1
	je	SHORT $LN2@CL_DemoCom

; 699  : 		cls.changedemo = true;

	mov	DWORD PTR _cls+12, 1
$LN2@CL_DemoCom:

; 700  : 
; 701  : 	CL_StopPlayback();

	call	_CL_StopPlayback

; 702  : 
; 703  : 	if( !CL_NextDemo() && !cls.changedemo )

	call	_CL_NextDemo
	test	eax, eax
	jne	SHORT $LN3@CL_DemoCom
	cmp	DWORD PTR _cls+12, 0
	jne	SHORT $LN3@CL_DemoCom

; 704  : 		UI_SetActiveMenu( true );

	push	1
	call	_UI_SetActiveMenu
	add	esp, 4
$LN3@CL_DemoCom:

; 705  : 
; 706  : 	Cvar_SetValue( "v_dark", 0.0f );

	push	ecx
	xorps	xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06COKHDAAL@v_dark@
	call	_Cvar_SetValue
	add	esp, 8

; 707  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoCompleted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_CloseDemoHeader
_TEXT	SEGMENT
_CL_CloseDemoHeader PROC				; COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 145  : 	if( !cls.demoheader )

	cmp	DWORD PTR _cls+301112, 0
	jne	SHORT $LN2@CL_CloseDe

; 146  : 		return;

	jmp	SHORT $LN1@CL_CloseDe
$LN2@CL_CloseDe:

; 147  : 
; 148  : 	FS_Close( cls.demoheader );

	mov	eax, DWORD PTR _cls+301112
	push	eax
	call	_FS_Close
	add	esp, 4
$LN1@CL_CloseDe:

; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CloseDemoHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoJumpTime
_TEXT	SEGMENT
_CL_WriteDemoJumpTime PROC				; COMDAT

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 220  : 	if( cls.demowaiting || !cls.demofile )

	cmp	DWORD PTR _cls+300832, 0
	jne	SHORT $LN3@CL_WriteDe
	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN2@CL_WriteDe
$LN3@CL_WriteDe:

; 221  : 		return;

	jmp	SHORT $LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 222  : 
; 223  : 	demo.starttime = CL_GetDemoRecordClock(); // setup the demo starttime

	call	_CL_GetDemoRecordClock
	fstp	DWORD PTR _demo+240

; 224  : 
; 225  : 	// demo playback should read this as an incoming message.
; 226  : 	// write the client's realtime value out so we can synchronize the reads.
; 227  : 	CL_WriteDemoCmdHeader( dem_jumptime, cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	push	3
	call	_CL_WriteDemoCmdHeader
	add	esp, 8
$LN1@CL_WriteDe:

; 228  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoJumpTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_CheckStartupDemos
_TEXT	SEGMENT
_CL_CheckStartupDemos PROC				; COMDAT

; 1276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1277 : 	if( !cls.demos_pending )

	cmp	DWORD PTR _cls+298768, 0
	jne	SHORT $LN2@CL_CheckSt

; 1278 : 		return; // no demos in loop

	jmp	SHORT $LN1@CL_CheckSt
$LN2@CL_CheckSt:

; 1279 : 
; 1280 : 	if( cls.movienum != -1 )

	cmp	DWORD PTR _cls+298772, -1
	je	SHORT $LN3@CL_CheckSt

; 1281 : 		return; // wait until movies finished

	jmp	SHORT $LN1@CL_CheckSt
$LN3@CL_CheckSt:

; 1282 : 
; 1283 : 	if( GameState->nextstate != STATE_RUNFRAME || cls.demoplayback )

	cmp	DWORD PTR _host+20, 0
	jne	SHORT $LN5@CL_CheckSt
	cmp	DWORD PTR _cls+300828, 0
	je	SHORT $LN4@CL_CheckSt
$LN5@CL_CheckSt:

; 1284 : 	{
; 1285 : 		// commandline override
; 1286 : 		cls.demos_pending = false;

	mov	DWORD PTR _cls+298768, 0

; 1287 : 		cls.demonum = -1;

	mov	DWORD PTR _cls+296712, -1

; 1288 : 		return;

	jmp	SHORT $LN1@CL_CheckSt
$LN4@CL_CheckSt:

; 1289 : 	}
; 1290 : 
; 1291 : 	// run demos loop in background mode
; 1292 : 	Cvar_SetValue( "v_dark", 1.0f );

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06COKHDAAL@v_dark@
	call	_Cvar_SetValue
	add	esp, 8

; 1293 : 	cls.demos_pending = false;

	mov	DWORD PTR _cls+298768, 0

; 1294 : 	cls.demonum = 0;

	mov	DWORD PTR _cls+296712, 0

; 1295 : 	CL_NextDemo ();

	call	_CL_NextDemo
$LN1@CL_CheckSt:

; 1296 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_CheckStartupDemos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoInterpolateAngles
_TEXT	SEGMENT
tv170 = -136						; size = 4
_q2$1 = -68						; size = 16
_q1$2 = -52						; size = 16
_q$3 = -36						; size = 16
_curtime$ = -20						; size = 4
_frac$ = -16						; size = 4
_next$ = -12						; size = 4
_prev$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_CL_DemoInterpolateAngles PROC				; COMDAT

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1058 : 	demoangle_t	*prev = NULL, *next = NULL;

	mov	DWORD PTR _prev$[ebp], 0
	mov	DWORD PTR _next$[ebp], 0

; 1059 : 	float		frac = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _frac$[ebp], xmm0

; 1060 : 	float		curtime;
; 1061 : 
; 1062 : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN2@CL_DemoInt

; 1063 : 	{
; 1064 : 		// manually select next & prev states
; 1065 : 		next = &demo.cmds[(demo.angle_position - 0) & ANGLE_MASK];

	mov	eax, DWORD PTR _demo+516
	and	eax, 15					; 0000000fH
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	DWORD PTR _next$[ebp], eax

; 1066 : 		prev = &demo.cmds[(demo.angle_position - 1) & ANGLE_MASK];

	mov	eax, DWORD PTR _demo+516
	sub	eax, 1
	and	eax, 15					; 0000000fH
	shl	eax, 4
	add	eax, OFFSET _demo+260
	mov	DWORD PTR _prev$[ebp], eax

; 1067 : 		if( cl.skip_interp ) *prev = *next; // camera was teleported

	cmp	DWORD PTR _cl+76, 0
	je	SHORT $LN4@CL_DemoInt
	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR _prev$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$LN4@CL_DemoInt:

; 1068 : 		frac = cl.lerpFrac;

	movss	xmm0, DWORD PTR _cl+48
	movss	DWORD PTR _frac$[ebp], xmm0

; 1069 : 	}

	jmp	SHORT $LN3@CL_DemoInt
$LN2@CL_DemoInt:

; 1070 : 	else
; 1071 : 	{
; 1072 : 		curtime = (CL_GetDemoPlaybackClock() - demo.starttime) - host.frametime;

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR tv170[ebp]
	movss	xmm0, DWORD PTR tv170[ebp]
	subss	xmm0, DWORD PTR _demo+240
	cvtss2sd xmm0, xmm0
	subsd	xmm0, QWORD PTR _host+1448
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _curtime$[ebp], xmm0

; 1073 : 		if( curtime > demo.timestamp )

	movss	xmm0, DWORD PTR _curtime$[ebp]
	comiss	xmm0, DWORD PTR _demo+248
	jbe	SHORT $LN5@CL_DemoInt

; 1074 : 			curtime = demo.timestamp; // don't run too far

	movss	xmm0, DWORD PTR _demo+248
	movss	DWORD PTR _curtime$[ebp], xmm0
$LN5@CL_DemoInt:

; 1075 : 
; 1076 : 		CL_DemoFindInterpolatedViewAngles( curtime, &frac, &prev, &next );

	lea	eax, DWORD PTR _next$[ebp]
	push	eax
	lea	ecx, DWORD PTR _prev$[ebp]
	push	ecx
	lea	edx, DWORD PTR _frac$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _curtime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_CL_DemoFindInterpolatedViewAngles
	add	esp, 16					; 00000010H
$LN3@CL_DemoInt:

; 1077 : 	}
; 1078 : 
; 1079 : 	if( prev && next )

	cmp	DWORD PTR _prev$[ebp], 0
	je	SHORT $LN6@CL_DemoInt
	cmp	DWORD PTR _next$[ebp], 0
	je	SHORT $LN6@CL_DemoInt

; 1080 : 	{
; 1081 : 		vec4_t	q, q1, q2;
; 1082 : 
; 1083 : 		AngleQuaternion( next->viewangles, q1, false );

	push	0
	lea	eax, DWORD PTR _q1$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _next$[ebp]
	add	ecx, 4
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 1084 : 		AngleQuaternion( prev->viewangles, q2, false );

	push	0
	lea	eax, DWORD PTR _q2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _prev$[ebp]
	add	ecx, 4
	push	ecx
	call	_AngleQuaternion
	add	esp, 12					; 0000000cH

; 1085 : 		QuaternionSlerp( q2, q1, frac, q );

	lea	eax, DWORD PTR _q$3[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _frac$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _q1$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _q2$1[ebp]
	push	edx
	call	_QuaternionSlerp
	add	esp, 16					; 00000010H

; 1086 : 		QuaternionAngle( q, cl.viewangles );

	push	OFFSET _cl+2212784
	lea	eax, DWORD PTR _q$3[ebp]
	push	eax
	call	_QuaternionAngle
	add	esp, 8

; 1087 : 	}

	jmp	SHORT $LN8@CL_DemoInt
$LN6@CL_DemoInt:

; 1088 : 	else if( cl.cmd != NULL )

	cmp	DWORD PTR _cl+2212776, 0
	je	SHORT $LN8@CL_DemoInt

; 1089 : 		VectorCopy( cl.cmd->viewangles, cl.viewangles );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cl+2212776
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _cl[eax+2212784], ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cl+2212776
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR _cl[eax+2212784], edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _cl+2212776
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _cl[ecx+2212784], eax
$LN8@CL_DemoInt:

; 1090 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DemoInterpolateAngles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DemoReadMessage
_TEXT	SEGMENT
tv243 = -100						; size = 4
tv152 = -100						; size = 4
tv95 = -100						; size = 4
_bSkipMessage$1 = -32					; size = 4
_cmd$ = -25						; size = 1
_size$ = -24						; size = 4
_userbuf$ = -20						; size = 4
_swallowmessages$ = -16					; size = 4
_fElapsedTime$ = -12					; size = 4
_lastpos$ = -8						; size = 4
_curpos$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_CL_DemoReadMessage PROC				; COMDAT

; 884  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 885  : 	size_t		curpos = 0, lastpos = 0;

	mov	DWORD PTR _curpos$[ebp], 0
	mov	DWORD PTR _lastpos$[ebp], 0

; 886  : 	float		fElapsedTime = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _fElapsedTime$[ebp], xmm0

; 887  : 	qboolean		swallowmessages = true;

	mov	DWORD PTR _swallowmessages$[ebp], 1

; 888  : 	static int	tdlastdemoframe = 0;
; 889  : 	byte		*userbuf = NULL;

	mov	DWORD PTR _userbuf$[ebp], 0

; 890  : 	size_t		size;
; 891  : 	byte		cmd;
; 892  : 
; 893  : 	if( !cls.demofile )

	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN7@CL_DemoRea

; 894  : 	{
; 895  : 		CL_DemoCompleted();

	call	_CL_DemoCompleted

; 896  : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN7@CL_DemoRea:

; 897  : 	}
; 898  : 
; 899  : 	if(( !cl.background && ( cl.paused || cls.key_dest != key_game )) || cls.key_dest == key_console )

	cmp	DWORD PTR _cl+64, 0
	jne	SHORT $LN10@CL_DemoRea
	cmp	DWORD PTR _cl+24, 0
	jne	SHORT $LN9@CL_DemoRea
	cmp	DWORD PTR _cls+36, 1
	jne	SHORT $LN9@CL_DemoRea
$LN10@CL_DemoRea:
	cmp	DWORD PTR _cls+36, 0
	jne	SHORT $LN8@CL_DemoRea
$LN9@CL_DemoRea:

; 900  : 	{
; 901  : 		demo.starttime += host.frametime;

	cvtss2sd xmm0, DWORD PTR _demo+240
	addsd	xmm0, QWORD PTR _host+1448
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _demo+240, xmm0

; 902  : 		return false; // paused

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN8@CL_DemoRea:

; 903  : 	}
; 904  : 
; 905  : 	if( cls.demoplayback == DEMO_QUAKE1 )

	cmp	DWORD PTR _cls+300828, 2
	jne	SHORT $LN11@CL_DemoRea

; 906  : 		return CL_DemoReadMessageQuake( buffer, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_CL_DemoReadMessageQuake
	add	esp, 8
	jmp	$LN1@CL_DemoRea
$LN11@CL_DemoRea:

; 907  : 
; 908  : 	do
; 909  : 	{
; 910  : 		qboolean	bSkipMessage = false;

	mov	DWORD PTR _bSkipMessage$1[ebp], 0

; 911  : 
; 912  : 		if( !cls.demofile ) break;

	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN12@CL_DemoRea
	jmp	$LN3@CL_DemoRea
$LN12@CL_DemoRea:

; 913  : 		curpos = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _curpos$[ebp], eax

; 914  : 
; 915  : 		CL_ReadDemoCmdHeader( &cmd, &demo.timestamp );

	push	OFFSET _demo+248
	lea	eax, DWORD PTR _cmd$[ebp]
	push	eax
	call	_CL_ReadDemoCmdHeader
	add	esp, 8

; 916  : 
; 917  : 		fElapsedTime = CL_GetDemoPlaybackClock() - demo.starttime;

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR tv243[ebp]
	movss	xmm0, DWORD PTR tv243[ebp]
	subss	xmm0, DWORD PTR _demo+240
	movss	DWORD PTR _fElapsedTime$[ebp], xmm0

; 918  : 		if( !cls.timedemo ) bSkipMessage = ((demo.timestamp - cl_serverframetime()) >= fElapsedTime) ? true : false;

	cmp	DWORD PTR _cls+300836, 0
	jne	SHORT $LN13@CL_DemoRea
	cvtss2sd xmm0, DWORD PTR _demo+248
	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, 8
	shl	edx, 0
	movsd	xmm1, QWORD PTR _cl[ecx+32]
	subsd	xmm1, QWORD PTR _cl[edx+32]
	subsd	xmm0, xmm1
	cvtss2sd xmm1, DWORD PTR _fElapsedTime$[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN30@CL_DemoRea
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN31@CL_DemoRea
$LN30@CL_DemoRea:
	mov	DWORD PTR tv95[ebp], 0
$LN31@CL_DemoRea:
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR _bSkipMessage$1[ebp], eax
$LN13@CL_DemoRea:

; 919  : 		if( cls.changelevel ) demo.framecount = 1;

	cmp	DWORD PTR _cls+8, 0
	je	SHORT $LN14@CL_DemoRea
	mov	DWORD PTR _demo+236, 1
$LN14@CL_DemoRea:

; 920  : 
; 921  : 		// changelevel issues
; 922  : 		if( demo.framecount <= 2 && ( fElapsedTime - demo.timestamp ) > host.frametime )

	cmp	DWORD PTR _demo+236, 2
	jg	SHORT $LN15@CL_DemoRea
	movss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	subss	xmm0, DWORD PTR _demo+248
	cvtss2sd xmm0, xmm0
	comisd	xmm0, QWORD PTR _host+1448
	jbe	SHORT $LN15@CL_DemoRea

; 923  : 			demo.starttime = CL_GetDemoPlaybackClock();

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR _demo+240
$LN15@CL_DemoRea:

; 924  : 
; 925  : 		// not ready for a message yet, put it back on the file.
; 926  : 		if( cmd != dem_norewind && cmd != dem_stop && bSkipMessage )

	movzx	eax, BYTE PTR _cmd$[ebp]
	cmp	eax, 1
	je	SHORT $LN17@CL_DemoRea
	movzx	eax, BYTE PTR _cmd$[ebp]
	cmp	eax, 6
	je	SHORT $LN17@CL_DemoRea
	cmp	DWORD PTR _bSkipMessage$1[ebp], 0
	je	SHORT $LN17@CL_DemoRea

; 927  : 		{
; 928  : 			// never skip first message
; 929  : 			if( demo.framecount != 0 )

	cmp	DWORD PTR _demo+236, 0
	je	SHORT $LN17@CL_DemoRea

; 930  : 			{
; 931  : 				FS_Seek( cls.demofile, curpos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _curpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 932  : 				return false; // not time yet.

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN17@CL_DemoRea:

; 933  : 			}
; 934  : 		}
; 935  : 
; 936  : 		// we already have the usercmd_t for this frame
; 937  : 		// don't read next usercmd_t so predicting will work properly
; 938  : 		if( cmd == dem_usercmd && lastpos != 0 && demo.framecount != 0 )

	movzx	eax, BYTE PTR _cmd$[ebp]
	cmp	eax, 5
	jne	SHORT $LN18@CL_DemoRea
	cmp	DWORD PTR _lastpos$[ebp], 0
	je	SHORT $LN18@CL_DemoRea
	cmp	DWORD PTR _demo+236, 0
	je	SHORT $LN18@CL_DemoRea

; 939  : 		{
; 940  : 			FS_Seek( cls.demofile, lastpos, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _lastpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 941  : 			return false; // not time yet.

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN18@CL_DemoRea:

; 942  : 		}
; 943  : 
; 944  : 		// COMMAND HANDLERS
; 945  : 		switch( cmd )

	movzx	eax, BYTE PTR _cmd$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv152[ebp], ecx
	cmp	DWORD PTR tv152[ebp], 3
	ja	$LN24@CL_DemoRea
	mov	edx, DWORD PTR tv152[ebp]
	jmp	DWORD PTR $LN32@CL_DemoRea[edx*4]
$LN19@CL_DemoRea:

; 946  : 		{
; 947  : 		case dem_jumptime:
; 948  : 			demo.starttime = CL_GetDemoPlaybackClock();

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR _demo+240

; 949  : 			return false; // time is changed, skip frame

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN20@CL_DemoRea:

; 950  : 		case dem_stop:
; 951  : 			CL_DemoMoveToNextSection();

	call	_CL_DemoMoveToNextSection

; 952  : 			return false; // header is ended, skip frame

	xor	eax, eax
	jmp	$LN1@CL_DemoRea
$LN21@CL_DemoRea:

; 953  : 		case dem_userdata:
; 954  : 			FS_Read( cls.demofile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 955  : 			userbuf = Mem_Malloc( cls.mempool, size );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_DemoReadMessage@@9@9
	add	eax, 71					; 00000047H
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+40
	push	edx
	call	__Mem_Alloc
	add	esp, 20					; 00000014H
	mov	DWORD PTR _userbuf$[ebp], eax

; 956  : 			FS_Read( cls.demofile, userbuf, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _userbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 957  : 
; 958  : 			if( clgame.hInstance )

	cmp	DWORD PTR _clgame, 0
	je	SHORT $LN22@CL_DemoRea

; 959  : 				clgame.dllFuncs.pfnDemo_ReadBuffer( size, userbuf );

	mov	eax, DWORD PTR _userbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	call	DWORD PTR _clgame+124
	add	esp, 8
$LN22@CL_DemoRea:

; 960  : 			Mem_Free( userbuf );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_DemoReadMessage@@9@9
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _userbuf$[ebp]
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH

; 961  : 			userbuf = NULL;

	mov	DWORD PTR _userbuf$[ebp], 0

; 962  : 			break;

	jmp	SHORT $LN5@CL_DemoRea
$LN23@CL_DemoRea:

; 963  : 		case dem_usercmd:
; 964  : 			CL_ReadDemoUserCmd( false );

	push	0
	call	_CL_ReadDemoUserCmd
	add	esp, 4

; 965  : 			lastpos = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _lastpos$[ebp], eax

; 966  : 			break;

	jmp	SHORT $LN5@CL_DemoRea
$LN24@CL_DemoRea:

; 967  : 		default:
; 968  : 			swallowmessages = false;

	mov	DWORD PTR _swallowmessages$[ebp], 0
$LN5@CL_DemoRea:

; 969  : 			break;
; 970  : 		}
; 971  : 	} while( swallowmessages );

	cmp	DWORD PTR _swallowmessages$[ebp], 0
	jne	$LN11@CL_DemoRea
$LN3@CL_DemoRea:

; 972  : 
; 973  : 	// If we are playing back a timedemo, and we've already passed on a 
; 974  : 	//  frame update for this host_frame tag, then we'll just skip this message.
; 975  : 	if( cls.timedemo && ( tdlastdemoframe == host.framecount ))

	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN25@CL_DemoRea
	mov	eax, DWORD PTR ?tdlastdemoframe@?1??CL_DemoReadMessage@@9@9
	cmp	eax, DWORD PTR _host+1464
	jne	SHORT $LN25@CL_DemoRea

; 976  : 	{
; 977  : 		FS_Seek( cls.demofile, FS_Tell ( cls.demofile ) - 5, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	sub	eax, 5
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 978  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DemoRea
$LN25@CL_DemoRea:

; 979  : 	}
; 980  : 
; 981  : 	tdlastdemoframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR ?tdlastdemoframe@?1??CL_DemoReadMessage@@9@9, eax

; 982  : 
; 983  : 	if( !cls.demofile )

	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN26@CL_DemoRea

; 984  : 		return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_DemoRea
$LN26@CL_DemoRea:

; 985  : 
; 986  : 	// if not on "LOADING" section, check a few things
; 987  : 	if( demo.entryIndex )

	cmp	DWORD PTR _demo+256, 0
	je	SHORT $LN28@CL_DemoRea

; 988  : 	{
; 989  : 		// We are now on the second frame of a new section,
; 990  : 		// if so, reset start time (unless in a timedemo)
; 991  : 		if( demo.framecount == 1 && !cls.timedemo )

	cmp	DWORD PTR _demo+236, 1
	jne	SHORT $LN28@CL_DemoRea
	cmp	DWORD PTR _cls+300836, 0
	jne	SHORT $LN28@CL_DemoRea

; 992  : 		{
; 993  : 			// cheat by moving the relative start time forward.
; 994  : 			demo.starttime = CL_GetDemoPlaybackClock();

	call	_CL_GetDemoPlaybackClock
	fstp	DWORD PTR _demo+240
$LN28@CL_DemoRea:

; 995  : 		}	
; 996  : 	}
; 997  : 
; 998  : 	demo.framecount++;

	mov	eax, DWORD PTR _demo+236
	add	eax, 1
	mov	DWORD PTR _demo+236, eax

; 999  : 	CL_ReadDemoSequence( false );

	push	0
	call	_CL_ReadDemoSequence
	add	esp, 4

; 1000 : 
; 1001 : 	return CL_ReadRawNetworkData( buffer, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_CL_ReadRawNetworkData
	add	esp, 8
$LN1@CL_DemoRea:

; 1002 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@CL_DemoRea:
	DD	$LN19@CL_DemoRea
	DD	$LN21@CL_DemoRea
	DD	$LN23@CL_DemoRea
	DD	$LN20@CL_DemoRea
_CL_DemoReadMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoUserMessage
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
_CL_WriteDemoUserMessage PROC				; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 328  : 	if( !cls.demorecording || cls.demowaiting )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN3@CL_WriteDe
	cmp	DWORD PTR _cls+300832, 0
	je	SHORT $LN2@CL_WriteDe
$LN3@CL_WriteDe:

; 329  : 		return;

	jmp	SHORT $LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 330  : 
; 331  : 	if( !cls.demofile || !buffer || size <= 0 )

	cmp	DWORD PTR _cls+301108, 0
	je	SHORT $LN5@CL_WriteDe
	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN5@CL_WriteDe
	cmp	DWORD PTR _size$[ebp], 0
	ja	SHORT $LN4@CL_WriteDe
$LN5@CL_WriteDe:

; 332  : 		return;

	jmp	SHORT $LN1@CL_WriteDe
$LN4@CL_WriteDe:

; 333  : 
; 334  : 	CL_WriteDemoCmdHeader( dem_userdata, cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	push	4
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 335  : 
; 336  : 	// write the length out.
; 337  : 	FS_Write( cls.demofile, &size, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 338  : 
; 339  : 	// output the buffer.
; 340  : 	FS_Write( cls.demofile, buffer, size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN1@CL_WriteDe:

; 341  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoUserMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoMessage
_TEXT	SEGMENT
tv76 = -80						; size = 4
tv65 = -80						; size = 4
_c$ = -9						; size = 1
_swlen$ = -8						; size = 4
_file$ = -4						; size = 4
_startup$ = 8						; size = 4
_start$ = 12						; size = 4
_msg$ = 16						; size = 4
_CL_WriteDemoMessage PROC				; COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 291  : 	file_t	*file = startup ? cls.demoheader : cls.demofile;

	cmp	DWORD PTR _startup$[ebp], 0
	je	SHORT $LN7@CL_WriteDe
	mov	eax, DWORD PTR _cls+301112
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN8@CL_WriteDe
$LN7@CL_WriteDe:
	mov	ecx, DWORD PTR _cls+301108
	mov	DWORD PTR tv65[ebp], ecx
$LN8@CL_WriteDe:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR _file$[ebp], edx

; 292  : 	int	swlen;
; 293  : 	byte	c;
; 294  : 
; 295  : 	if( !file ) return;

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $LN2@CL_WriteDe
	jmp	$LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 296  : 
; 297  : 	// past the start but not recording a demo.
; 298  : 	if( !startup && !cls.demorecording )

	cmp	DWORD PTR _startup$[ebp], 0
	jne	SHORT $LN3@CL_WriteDe
	cmp	DWORD PTR _cls+300824, 0
	jne	SHORT $LN3@CL_WriteDe

; 299  : 		return;

	jmp	$LN1@CL_WriteDe
$LN3@CL_WriteDe:

; 300  : 
; 301  : 	swlen = MSG_GetNumBytesWritten( msg ) - start;

	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	sub	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR _swlen$[ebp], eax

; 302  : 	if( swlen <= 0 ) return;

	cmp	DWORD PTR _swlen$[ebp], 0
	jg	SHORT $LN4@CL_WriteDe
	jmp	$LN1@CL_WriteDe
$LN4@CL_WriteDe:

; 303  : 
; 304  : 	if( !startup ) demo.framecount++;

	cmp	DWORD PTR _startup$[ebp], 0
	jne	SHORT $LN5@CL_WriteDe
	mov	eax, DWORD PTR _demo+236
	add	eax, 1
	mov	DWORD PTR _demo+236, eax
$LN5@CL_WriteDe:

; 305  : 
; 306  : 	// demo playback should read this as an incoming message.
; 307  : 	c = (cls.state != ca_active) ? dem_norewind : dem_read;

	cmp	DWORD PTR _cls, 4
	je	SHORT $LN9@CL_WriteDe
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN10@CL_WriteDe
$LN9@CL_WriteDe:
	mov	DWORD PTR tv76[ebp], 2
$LN10@CL_WriteDe:
	mov	al, BYTE PTR tv76[ebp]
	mov	BYTE PTR _c$[ebp], al

; 308  : 
; 309  : 	CL_WriteDemoCmdHeader( c, file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _c$[ebp]
	push	ecx
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 310  : 	CL_WriteDemoSequence( file );

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_CL_WriteDemoSequence
	add	esp, 4

; 311  : 
; 312  : 	// write the length out.
; 313  : 	FS_Write( file, &swlen, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _swlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 314  : 
; 315  : 	// output the buffer. Skip the network packet stuff.
; 316  : 	FS_Write( file, MSG_GetData( msg ) + start, swlen );

	mov	eax, DWORD PTR _swlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	_MSG_GetData
	add	esp, 4
	add	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN1@CL_WriteDe:

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_WriteDemoUserCmd
_TEXT	SEGMENT
_data$ = -1052						; size = 1024
_bytes$ = -28						; size = 2
_buf$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_cmdnumber$ = 8						; size = 4
_CL_WriteDemoUserCmd PROC				; COMDAT

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1244				; 000004dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 239  : 	sizebuf_t	buf;
; 240  : 	word	bytes;
; 241  : 	byte	data[1024];
; 242  : 
; 243  : 	if( !cls.demorecording || !cls.demofile )

	cmp	DWORD PTR _cls+300824, 0
	je	SHORT $LN3@CL_WriteDe
	cmp	DWORD PTR _cls+301108, 0
	jne	SHORT $LN2@CL_WriteDe
$LN3@CL_WriteDe:

; 244  : 		return;

	jmp	$LN1@CL_WriteDe
$LN2@CL_WriteDe:

; 245  : 
; 246  : 	CL_WriteDemoCmdHeader( dem_usercmd, cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	push	5
	call	_CL_WriteDemoCmdHeader
	add	esp, 8

; 247  : 
; 248  : 	FS_Write( cls.demofile, &cls.netchan.outgoing_sequence, sizeof( int ));

	push	4
	push	OFFSET _cls+26880
	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 249  : 	FS_Write( cls.demofile, &cmdnumber, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _cmdnumber$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 250  : 
; 251  : 	// write usercmd_t
; 252  : 	MSG_Init( &buf, "UserCmd", data, sizeof( data ));

	push	-1
	push	1024					; 00000400H
	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	push	OFFSET ??_C@_07EJIPDLMH@UserCmd@
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_MSG_InitExt
	add	esp, 20					; 00000014H

; 253  : 	CL_WriteUsercmd( &buf, -1, cmdnumber );	// always no delta

	mov	eax, DWORD PTR _cmdnumber$[ebp]
	push	eax
	push	-1
	lea	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	call	_CL_WriteUsercmd
	add	esp, 12					; 0000000cH

; 254  : 
; 255  : 	bytes = MSG_GetNumBytesWritten( &buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_MSG_GetNumBytesWritten
	add	esp, 4
	mov	WORD PTR _bytes$[ebp], ax

; 256  : 
; 257  : 	FS_Write( cls.demofile, &bytes, sizeof( word ));

	push	2
	lea	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cls+301108
	push	ecx
	call	_FS_Write
	add	esp, 12					; 0000000cH

; 258  : 	FS_Write( cls.demofile, data, bytes );

	movzx	eax, WORD PTR _bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cls+301108
	push	edx
	call	_FS_Write
	add	esp, 12					; 0000000cH
$LN1@CL_WriteDe:

; 259  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_WriteDemoUserCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_DrawDemoRecording
_TEXT	SEGMENT
_len$ = -80						; size = 4
_pos$ = -76						; size = 4
_color$ = -72						; size = 4
_string$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_CL_DrawDemoRecording PROC				; COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 490  : 	char	string[64];
; 491  : 	rgba_t	color = { 255, 255, 255, 255 };

	mov	BYTE PTR _color$[ebp], 255		; 000000ffH
	mov	BYTE PTR _color$[ebp+1], 255		; 000000ffH
	mov	BYTE PTR _color$[ebp+2], 255		; 000000ffH
	mov	BYTE PTR _color$[ebp+3], 255		; 000000ffH

; 492  : 	long	pos;
; 493  : 	int	len;
; 494  : 
; 495  : 	if(!( host_developer.value && cls.demorecording ))

	movss	xmm0, DWORD PTR _host_developer+12
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@CL_DrawDem
	cmp	DWORD PTR _cls+300824, 0
	jne	SHORT $LN2@CL_DrawDem
$LN3@CL_DrawDem:

; 496  : 		return;

	jmp	$LN1@CL_DrawDem
$LN2@CL_DrawDem:

; 497  : 
; 498  : 	pos = FS_Tell( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Tell
	add	esp, 4
	mov	DWORD PTR _pos$[ebp], eax

; 499  : 	Q_snprintf( string, sizeof( string ), "^1RECORDING:^7 %s: %s time: %02d:%02d", cls.demoname,

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@404e000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _cls+301096
	movsd	QWORD PTR [esp], xmm0
	call	_fmod
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	push	eax
	movsd	xmm0, QWORD PTR _cls+301096
	divsd	xmm0, QWORD PTR __real@404e000000000000
	cvttsd2si eax, xmm0
	push	eax
	push	2
	cvtsi2ss xmm0, DWORD PTR _pos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_Q_pretifymem
	add	esp, 8
	push	eax
	push	OFFSET _cls+300840
	push	OFFSET ??_C@_0CG@CPGNIJNE@?$FO1RECORDING?3?$FO7?5?$CFs?3?5?$CFs?5time?3?5?$CF02@
	push	64					; 00000040H
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 28					; 0000001cH

; 500  : 	Q_memprint( pos ), (int)(cls.demotime / 60.0f ), (int)fmod( cls.demotime, 60.0f ));
; 501  : 
; 502  : 	Con_DrawStringLen( string, &len, NULL );

	push	0
	lea	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	call	_Con_DrawStringLen
	add	esp, 12					; 0000000cH

; 503  : 	Con_DrawString(( glState.width - len ) >> 1, glState.height >> 2, string, color );

	lea	eax, DWORD PTR _color$[ebp]
	push	eax
	lea	ecx, DWORD PTR _string$[ebp]
	push	ecx
	mov	edx, DWORD PTR _glState+4
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _glState
	sub	eax, DWORD PTR _len$[ebp]
	sar	eax, 1
	push	eax
	call	_Con_DrawString
	add	esp, 16					; 00000010H
$LN1@CL_DrawDem:

; 504  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_DrawDemoRecording ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_StartupDemoHeader
_TEXT	SEGMENT
_CL_StartupDemoHeader PROC				; COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 119  : 	if( cls.demoheader )

	cmp	DWORD PTR _cls+301112, 0
	je	SHORT $LN2@CL_Startup

; 120  : 	{
; 121  : 		FS_Close( cls.demoheader );

	mov	eax, DWORD PTR _cls+301112
	push	eax
	call	_FS_Close
	add	esp, 4
$LN2@CL_Startup:

; 122  : 	}
; 123  : 
; 124  : 	// Note: this is replacing tmpfile()
; 125  : 	cls.demoheader = FS_Open( "demoheader.tmp", "w+b", true );

	push	1
	push	OFFSET ??_C@_03ELIABIOC@w?$CLb@
	push	OFFSET ??_C@_0P@FDJBLPMJ@demoheader?4tmp@
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cls+301112, eax

; 126  : 
; 127  : 	if( !cls.demoheader )

	cmp	DWORD PTR _cls+301112, 0
	jne	SHORT $LN3@CL_Startup

; 128  : 	{
; 129  : 		Con_DPrintf( S_ERROR "couldn't open temporary header file.\n" );

	push	OFFSET ??_C@_0DB@JOENKEFE@?$FO1Error?3?$FO7?5couldn?8t?5open?5tempor@
	call	_Con_DPrintf
	add	esp, 4

; 130  : 		return;

	jmp	SHORT $LN1@CL_Startup
$LN3@CL_Startup:

; 131  : 	}
; 132  : 
; 133  : 	Con_Printf( "Spooling demo header.\n" );

	push	OFFSET ??_C@_0BH@KHFPKOBF@Spooling?5demo?5header?4?6@
	call	_Con_Printf
	add	esp, 4
$LN1@CL_Startup:

; 134  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StartupDemoHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetData
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetData PROC					; COMDAT

; 109  : _inline byte *MSG_GetData( sizebuf_t *sb ) { return sb->pData; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _MSG_GetNumBytesWritten
_TEXT	SEGMENT
_sb$ = 8						; size = 4
_MSG_GetNumBytesWritten PROC				; COMDAT

; 102  : _inline int MSG_GetNumBytesWritten( sizebuf_t *sb ) { return BitByte( sb->iCurBit ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _sb$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_BitByte
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_MSG_GetNumBytesWritten ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\common\net_buffer.h
;	COMDAT _BitByte
_TEXT	SEGMENT
_bits$ = 8						; size = 4
_BitByte PROC						; COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 35   : 	return PAD_NUMBER( bits, 8 ) >> 3;

	mov	eax, DWORD PTR _bits$[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	shl	eax, 3
	sar	eax, 3

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BitByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_NextDemo
_TEXT	SEGMENT
_str$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_CL_NextDemo PROC					; COMDAT

; 1243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1244 : 	char	str[MAX_QPATH];
; 1245 : 
; 1246 : 	if( cls.demonum == -1 )

	cmp	DWORD PTR _cls+296712, -1
	jne	SHORT $LN2@CL_NextDem

; 1247 : 		return false; // don't play demos

	xor	eax, eax
	jmp	$LN1@CL_NextDem
$LN2@CL_NextDem:

; 1248 : 	S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1249 : 
; 1250 : 	if( !cls.demos[cls.demonum][0] || cls.demonum == MAX_DEMOS )

	mov	eax, DWORD PTR _cls+296712
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _cls[eax+edx+296720]
	test	eax, eax
	je	SHORT $LN4@CL_NextDem
	cmp	DWORD PTR _cls+296712, 32		; 00000020H
	jne	SHORT $LN3@CL_NextDem
$LN4@CL_NextDem:

; 1251 : 	{
; 1252 : 		cls.demonum = 0;

	mov	DWORD PTR _cls+296712, 0

; 1253 : 		if( !cls.demos[cls.demonum][0] )

	mov	eax, DWORD PTR _cls+296712
	shl	eax, 6
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _cls[eax+edx+296720]
	test	eax, eax
	jne	SHORT $LN3@CL_NextDem

; 1254 : 		{
; 1255 : 			Con_Printf( "no demos listed with startdemos\n" );

	push	OFFSET ??_C@_0CB@CFHCDJLA@no?5demos?5listed?5with?5startdemos@
	call	_Con_Printf
	add	esp, 4

; 1256 : 			cls.demonum = -1;

	mov	DWORD PTR _cls+296712, -1

; 1257 : 			return false;

	xor	eax, eax
	jmp	SHORT $LN1@CL_NextDem
$LN3@CL_NextDem:

; 1258 : 		}
; 1259 : 	}
; 1260 : 
; 1261 : 	Q_snprintf( str, MAX_STRING, "playdemo %s\n", cls.demos[cls.demonum] );

	mov	eax, DWORD PTR _cls+296712
	shl	eax, 6
	add	eax, OFFSET _cls+296720
	push	eax
	push	OFFSET ??_C@_0N@IMBDKDIM@playdemo?5?$CFs?6@
	push	256					; 00000100H
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_Q_snprintf
	add	esp, 16					; 00000010H

; 1262 : 	Cbuf_InsertText( str );

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_Cbuf_InsertText
	add	esp, 4

; 1263 : 	cls.demonum++;

	mov	eax, DWORD PTR _cls+296712
	add	eax, 1
	mov	DWORD PTR _cls+296712, eax

; 1264 : 
; 1265 : 	return true;

	mov	eax, 1
$LN1@CL_NextDem:

; 1266 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_NextDemo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_StopPlayback
_TEXT	SEGMENT
tv69 = -68						; size = 4
_CL_StopPlayback PROC					; COMDAT

; 1122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1123 : 	if( !cls.demoplayback ) return;

	cmp	DWORD PTR _cls+300828, 0
	jne	SHORT $LN2@CL_StopPla
	jmp	$LN6@CL_StopPla
$LN2@CL_StopPla:

; 1124 : 
; 1125 : 	// release demofile
; 1126 : 	FS_Close( cls.demofile );

	mov	eax, DWORD PTR _cls+301108
	push	eax
	call	_FS_Close
	add	esp, 4

; 1127 : 	cls.demoplayback = false;

	mov	DWORD PTR _cls+300828, 0

; 1128 : 	demo.framecount = 0;

	mov	DWORD PTR _demo+236, 0

; 1129 : 	cls.demofile = NULL;

	mov	DWORD PTR _cls+301108, 0

; 1130 : 
; 1131 : 	cls.olddemonum = Q_max( -1, cls.demonum - 1 );

	mov	eax, DWORD PTR _cls+296712
	sub	eax, 1
	cmp	eax, -1
	jge	SHORT $LN8@CL_StopPla
	mov	DWORD PTR tv69[ebp], -1
	jmp	SHORT $LN9@CL_StopPla
$LN8@CL_StopPla:
	mov	ecx, DWORD PTR _cls+296712
	sub	ecx, 1
	mov	DWORD PTR tv69[ebp], ecx
$LN9@CL_StopPla:
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _cls+296716, edx

; 1132 : 	if( demo.directory.entries != NULL )

	cmp	DWORD PTR _demo+228, 0
	je	SHORT $LN3@CL_StopPla

; 1133 : 		Mem_Free( demo.directory.entries );

	mov	eax, DWORD PTR ?__LINE__Var@?0??CL_StopPlayback@@9@9
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET ??_C@_0DE@OIGBHOCG@D?3?2DevDragon?2XashFE?2dev?2src?2eng@
	mov	ecx, DWORD PTR _demo+228
	push	ecx
	call	__Mem_Free
	add	esp, 12					; 0000000cH
$LN3@CL_StopPla:

; 1134 : 	cls.td_lastframe = host.framecount;

	mov	eax, DWORD PTR _host+1464
	mov	DWORD PTR _cls+290600, eax

; 1135 : 	demo.directory.numentries = 0;

	mov	DWORD PTR _demo+232, 0

; 1136 : 	demo.directory.entries = NULL;

	mov	DWORD PTR _demo+228, 0

; 1137 : 	demo.header.host_fps = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _demo+16, xmm0

; 1138 : 	demo.entry = NULL;

	mov	DWORD PTR _demo+224, 0

; 1139 : 
; 1140 : 	cls.demoname[0] = '\0';	// clear demoname too

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _cls[ecx+300840], 0

; 1141 : 	gameui.globals->demoname[0] = '\0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gameui+7048
	mov	BYTE PTR [edx+ecx+32], 0

; 1142 : 
; 1143 : 	if( cls.timedemo )

	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN4@CL_StopPla

; 1144 : 		CL_FinishTimeDemo();

	call	_CL_FinishTimeDemo
$LN4@CL_StopPla:

; 1145 : 
; 1146 : 	if( cls.changedemo )

	cmp	DWORD PTR _cls+12, 0
	je	SHORT $LN5@CL_StopPla

; 1147 : 	{
; 1148 : 		S_StopAllSounds( true );

	push	1
	call	_S_StopAllSounds
	add	esp, 4

; 1149 : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 1150 : 	}

	jmp	SHORT $LN6@CL_StopPla
$LN5@CL_StopPla:

; 1151 : 	else
; 1152 : 	{
; 1153 : 		// let game known about demo state	
; 1154 : 		Cvar_FullSet( "cl_background", "0", FCVAR_READ_ONLY );

	push	131072					; 00020000H
	push	OFFSET ??_C@_01GBGANLPD@0@
	push	OFFSET ??_C@_0O@NGAMONDD@cl_background@
	call	_Cvar_FullSet
	add	esp, 12					; 0000000cH

; 1155 : 		cls.state = ca_disconnected;

	mov	DWORD PTR _cls, 0

; 1156 : 		cls.set_lastdemo = false;

	mov	DWORD PTR _cls+301104, 0

; 1157 : 		S_StopBackgroundTrack();

	call	_S_StopBackgroundTrack

; 1158 : 		cls.connect_time = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cls+136, xmm0

; 1159 : 		cls.demonum = -1;

	mov	DWORD PTR _cls+296712, -1

; 1160 : 		cls.signon = 0;

	mov	DWORD PTR _cls+64, 0

; 1161 : 
; 1162 : 		// and finally clear the state
; 1163 : 		CL_ClearState ();

	call	_CL_ClearState
$LN6@CL_StopPla:

; 1164 : 	}
; 1165 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_StopPlayback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_GetDemoFramerate
_TEXT	SEGMENT
tv68 = -80						; size = 8
tv67 = -72						; size = 8
_CL_GetDemoFramerate PROC				; COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 184  : 	if( cls.timedemo )

	cmp	DWORD PTR _cls+300836, 0
	je	SHORT $LN2@CL_GetDemo

; 185  : 		return 0.0;

	fldz
	jmp	SHORT $LN1@CL_GetDemo
$LN2@CL_GetDemo:

; 186  : 	return bound( MIN_FPS, demo.header.host_fps, MAX_FPS );

	movsd	xmm0, QWORD PTR _demo+16
	comisd	xmm0, QWORD PTR __real@4034000000000000
	jb	SHORT $LN6@CL_GetDemo
	movsd	xmm0, QWORD PTR __real@4069000000000000
	comisd	xmm0, QWORD PTR _demo+16
	jbe	SHORT $LN4@CL_GetDemo
	movsd	xmm0, QWORD PTR _demo+16
	movsd	QWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN5@CL_GetDemo
$LN4@CL_GetDemo:
	movsd	xmm0, QWORD PTR __real@4069000000000000
	movsd	QWORD PTR tv67[ebp], xmm0
$LN5@CL_GetDemo:
	movsd	xmm0, QWORD PTR tv67[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN7@CL_GetDemo
$LN6@CL_GetDemo:
	movsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR tv68[ebp], xmm0
$LN7@CL_GetDemo:
	fld	QWORD PTR tv68[ebp]
$LN1@CL_GetDemo:

; 187  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDemoFramerate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File D:\DevDragon\XashFE\dev\src\engine\client\cl_demo.c
;	COMDAT _CL_GetDemoComment
_TEXT	SEGMENT
_i$ = -336						; size = 4
_playtime$ = -332					; size = 4
_entry$ = -328						; size = 88
_directory$ = -240					; size = 8
_demohdr$ = -232					; size = 224
_demfile$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_demoname$ = 8						; size = 4
_comment$ = 12						; size = 4
_CL_GetDemoComment PROC					; COMDAT

; 1173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1174 : 	file_t		*demfile;
; 1175 : 	demoheader_t	demohdr;
; 1176 : 	demodirectory_t	directory;
; 1177 : 	demoentry_t	entry;
; 1178 : 	float		playtime = 0.0f;

	xorps	xmm0, xmm0
	movss	DWORD PTR _playtime$[ebp], xmm0

; 1179 : 	int		i;
; 1180 : 	
; 1181 : 	if( !comment ) return false;

	cmp	DWORD PTR _comment$[ebp], 0
	jne	SHORT $LN5@CL_GetDemo
	xor	eax, eax
	jmp	$LN1@CL_GetDemo
$LN5@CL_GetDemo:

; 1182 : 
; 1183 : 	demfile = FS_Open( demoname, "rb", false );

	push	0
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _demoname$[ebp]
	push	eax
	call	_FS_Open
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _demfile$[ebp], eax

; 1184 : 	if( !demfile )

	cmp	DWORD PTR _demfile$[ebp], 0
	jne	SHORT $LN6@CL_GetDemo

; 1185 : 	{
; 1186 : 		Q_strncpy( comment, "", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_00CNPNBAHC@@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1187 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_GetDemo
$LN6@CL_GetDemo:

; 1188 :           }
; 1189 : 
; 1190 : 	// read in the m_DemoHeader
; 1191 : 	FS_Read( demfile, &demohdr, sizeof( demoheader_t ));

	push	224					; 000000e0H
	lea	eax, DWORD PTR _demohdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _demfile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1192 : 
; 1193 : 	if( demohdr.id != IDEMOHEADER )

	cmp	DWORD PTR _demohdr$[ebp], 1296385097	; 4d454449H
	je	SHORT $LN7@CL_GetDemo

; 1194 : 	{
; 1195 : 		FS_Close( demfile );

	mov	eax, DWORD PTR _demfile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1196 : 		Q_strncpy( comment, "<corrupted>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1197 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_GetDemo
$LN7@CL_GetDemo:

; 1198 : 	}
; 1199 : 
; 1200 : 	if( demohdr.net_protocol != PROTOCOL_VERSION || demohdr.dem_protocol != DEMO_PROTOCOL )

	cmp	DWORD PTR _demohdr$[ebp+8], 49		; 00000031H
	jne	SHORT $LN9@CL_GetDemo
	cmp	DWORD PTR _demohdr$[ebp+4], 3
	je	SHORT $LN8@CL_GetDemo
$LN9@CL_GetDemo:

; 1201 : 	{
; 1202 : 		FS_Close( demfile );

	mov	eax, DWORD PTR _demfile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1203 : 		Q_strncpy( comment, "<invalid protocol>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0BD@FFMIBALC@?$DMinvalid?5protocol?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1204 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_GetDemo
$LN8@CL_GetDemo:

; 1205 : 	}
; 1206 : 
; 1207 : 	// now read in the directory structure.
; 1208 : 	FS_Seek( demfile, demohdr.directory_offset, SEEK_SET );

	push	0
	mov	eax, DWORD PTR _demohdr$[ebp+216]
	push	eax
	mov	ecx, DWORD PTR _demfile$[ebp]
	push	ecx
	call	_FS_Seek
	add	esp, 12					; 0000000cH

; 1209 : 	FS_Read( demfile, &directory.numentries, sizeof( int ));

	push	4
	lea	eax, DWORD PTR _directory$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _demfile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1210 : 
; 1211 : 	if( directory.numentries < 1 || directory.numentries > 1024 )

	cmp	DWORD PTR _directory$[ebp+4], 1
	jl	SHORT $LN11@CL_GetDemo
	cmp	DWORD PTR _directory$[ebp+4], 1024	; 00000400H
	jle	SHORT $LN10@CL_GetDemo
$LN11@CL_GetDemo:

; 1212 : 	{
; 1213 : 		FS_Close( demfile );

	mov	eax, DWORD PTR _demfile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1214 : 		Q_strncpy( comment, "<corrupted>", MAX_STRING );

	push	256					; 00000100H
	push	OFFSET ??_C@_0M@PHDAFLJN@?$DMcorrupted?$DO@
	mov	eax, DWORD PTR _comment$[ebp]
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1215 : 		return false;

	xor	eax, eax
	jmp	$LN1@CL_GetDemo
$LN10@CL_GetDemo:

; 1216 : 	}
; 1217 : 
; 1218 : 	for( i = 0; i < directory.numentries; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@CL_GetDemo
$LN2@CL_GetDemo:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@CL_GetDemo:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _directory$[ebp+4]
	jge	SHORT $LN3@CL_GetDemo

; 1219 : 	{
; 1220 : 		FS_Read( demfile, &entry, sizeof( demoentry_t ));

	push	88					; 00000058H
	lea	eax, DWORD PTR _entry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _demfile$[ebp]
	push	ecx
	call	_FS_Read
	add	esp, 12					; 0000000cH

; 1221 : 		playtime += entry.playback_time;

	movss	xmm0, DWORD PTR _playtime$[ebp]
	addss	xmm0, DWORD PTR _entry$[ebp+4]
	movss	DWORD PTR _playtime$[ebp], xmm0

; 1222 : 	}

	jmp	SHORT $LN2@CL_GetDemo
$LN3@CL_GetDemo:

; 1223 : 
; 1224 : 	// split comment to sections
; 1225 : 	Q_strncpy( comment, demohdr.mapname, CS_SIZE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _demohdr$[ebp+24]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1226 : 	Q_strncpy( comment + CS_SIZE, demohdr.comment, CS_SIZE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _demohdr$[ebp+88]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1227 : 	Q_strncpy( comment + CS_SIZE * 2, va( "%g sec", playtime ), CS_TIME );

	push	16					; 00000010H
	cvtss2sd xmm0, DWORD PTR _playtime$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06FCGABIIB@?$CFg?5sec@
	call	_va
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR _comment$[ebp]
	add	eax, 128				; 00000080H
	push	eax
	call	_Q_strncpy
	add	esp, 12					; 0000000cH

; 1228 : 
; 1229 : 	// all done
; 1230 : 	FS_Close( demfile );

	mov	eax, DWORD PTR _demfile$[ebp]
	push	eax
	call	_FS_Close
	add	esp, 4

; 1231 : 		
; 1232 : 	return true;

	mov	eax, 1
$LN1@CL_GetDemo:

; 1233 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CL_GetDemoComment ENDP
_TEXT	ENDS
END
